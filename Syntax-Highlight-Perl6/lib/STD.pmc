# Emulate context vars by localizing 'our' vars living in main
our $ACTIONS;
our $BORG;
our $CORE;
our $CTX;
our $CURPAD;
our $CURPKG;
our $DECLARAND;
our $DELIM;
our $GLOBAL;
our $GOAL;
our $HIGHEXPECT;
our $HIGHMESS;
our $HIGHWATER;
our $INVOCANT_IS;
our $INVOCANT_OK;
our $IN_DECL;
our $IN_META;
our $IN_REDUCE;
our $LEFTSIGIL;
our $MULTINESS;
our $ORIG;
our $PKGDECL;
our $PKGNAME;
our $PROCESS;
our $QSIGIL;
our $QUASIMODO;
our $SCOPE;
our $SETTING;
our $SETTINGNAME;
our $TMP_PREFIX;
our $UNIT;
our $VAR;
our $begin_compunit;
our $endargs;
our $endsym;
our $ignoreaccent;
our $ignorecase;
our $ratchet;
our $sigspace;
our $sym;
our $zone;
our %LANG;
our %MYSTERY;
our @MEMOS;
our @ORIG;
our @PKGS;

our $moreinput;
our $DEBUG;

our %INSTANTIATED;
require 'mangle.pl';
use utf8;

package STD;
use 5.010;
use strict;
use warnings;
no warnings 'qw', 'recursion';
use Cursor; # for base class as well as DEBUG constants
use Moose ':all' => { -prefix => "moose_" };
moose_extends('Cursor');
my $retree;
use utf8;

$DB::deep = $DB::deep = 1000; # suppress used-once warning

sub BUILD {
my $self = shift;
$self->_AUTOLEXpeek('termish',$retree);
}

use YAML::Syck;


use DEBUG;

# per parse
local $::ACTIONS;         # class or object which defines reduce actions
local $::SETTINGNAME;     # name of core setting
local $::TMP_PREFIX;      # where to put tmp files
local $::ORIG;            # the original program string
local @::ORIG;            # same thing as individual chars
local @::MEMOS;           # per-position info such as ws and line number
local $::HIGHWATER;      # where we were last looking for things
local $::HIGHMESS;       # current parse failure message
local $::HIGHEXPECT;     # things we were looking for at the bleeding edge

# symbol table management
local $::CORE;            # the CORE scope
local $::SETTING;         # the SETTING scope
local $::GLOBAL;          # the GLOBAL scope
local $::PROCESS;         # the PROCESS scope
local $::UNIT;            # the UNIT scope
local $::CURPAD;      # current lexical scope
local $::CURPKG;          # current package scope
local $::PKGNAME = "";    # full package name of package assoc with current lexical scope
local @::PKGS = ();   # stack of outer lexical packages

local %::MYSTERY;     # names we assume may be post-declared functions

# tree attributes, marked as propagating up (u) down (d) or up-and-down (u/d)
local %::LANG;            # (d) braided languages: MAIN, Q, Regex, etc

local $::IN_DECL;     # (d) a declarator is looking for a name to declare
local $::SCOPE = "";      # (d) which scope declarator we're under
local $::MULTINESS;       # (d) which multi declarator we're under
local $::PKGDECL;         # (d) current package declarator
local $::DECLARAND;   # (u/d) new object associated with declaration

local $::GOAL = "(eof)";  # (d) which special terminator we're most wanting
local $::IN_REDUCE;   # (d) attempting to parse an [op] construct
local $::IN_META;     # (d) parsing a metaoperator like [..]
local $::QUASIMODO;   # (d) don't carp about quasi variables
local $::LEFTSIGIL;   # (u) sigil of LHS for item vs list assignment
local $::QSIGIL;      # (d) sigil of current interpolation

local $::INVOCANT_OK; # (d) parsing a list that allows an invocant
local $::INVOCANT_IS; # (u) invocant of args match

local $::BORG;            # (u/d) who to blame if we're missing a block

# =begin comment overview
# 
# This file is designed to be either preprocessed into a grammar with
# action statements or used as-is without any preprocessing.  The {*}
# notation is a no-op action block, but can be identified uniquely via a
# combination of the preceding token or rule name plus any additional text
# following a #= comment.  We put this into a comment rather than using
# a macro so that bootstrap compilers don't have to worry about macros
# yet, and to keep the main grammar relatively uncluttered by action
# statements.  Note that the preprocessor can certainly generate accesses
# to the match state within the action block, so we need not mention it
# explicitly.
# 
# Also, some rules are named by syntactic category plus an additonal symbol
# specified in adverbial form, either in bare :name form or in :sym<name>
# form.  (It does not matter which form you use for identifier symbols,
# except that to specify a symbol "sym" you must use the :sym<sym> form
# of adverb.)  If you use the <sym> rule within the rule, it will parse the
# symbol at that point.  At the final reduction point of a rule, if $sym
# has been set, that is used as the final symbol name for the rule.  This
# need not match the symbol specified as part the rule name; that is just
# for disambiguating the name.  However, if no $sym is set, the original
# symbol will be used by default.
# 
# Note that rules automatically get an implicit {*} at their return, so
# for the TOP rule the implicit action name is also simply "TOP".
# 
# Another nod toward preprocessing is that blocks that contain nested braces
# are delimited by double braces so that the preprocessor does not need to
# understand Perl 6 code.
# 
# This grammar relies on transitive longest-token semantics, though
# initially we made a feeble attempt to order rules so a procedural
# interpretation of alternation could usually produce a correct parse.
# (This is becoming less true over time.)
# 
# =end comment overview

## method TOP ($STOP = undef)
sub TOP {
my $self = shift;
my $STOP = shift() // undef;


if (defined $STOP) {
local $::GOAL = $STOP;
$self->unitstop($STOP)->comp_unit;
}
else {
$self->comp_unit;
}
}

## method initparse ($text, :$rule = 'TOP', :$tmp_prefix = '', :$setting = 'CORE', :$actions = '')
sub initparse {
my $self = shift;
my $text = shift;
my %args = @_;
my $rule = $args{rule} // 'TOP';
my $tmp_prefix = $args{tmp_prefix} // '';
my $setting = $args{setting} // 'CORE';
my $actions = $args{actions} // '';


local $::TMP_PREFIX = $tmp_prefix;
local $::SETTINGNAME = $setting;
local $::ACTIONS = $actions;
local $::DEBUG = $DEBUG;
local @::MEMOS = @::MEMOS;

# various bits of info useful for error messages
local $::HIGHWATER = 0;
local $::HIGHMESS = '';
local $::HIGHEXPECT = {};
local $::LAST_NIBBLE = { firstline => 0, lastline => 0 };
local $::LAST_NIBBLE_MULTILINE = { firstline => 0, lastline => 0 };
local $::GOAL = "(eof)";
$::ORIG = $text . "\n;";           # original string

my $result = $self->new($text)->$rule();

# XXX here attach stuff that will enable :cont

$result;
}

##############
# Precedence #
##############

# The internal precedence levels are *not* part of the public interface.
# The current values are mere implementation; they may change at any time.
# Users should specify precedence only in relation to existing levels.

our %term            = ('dba' => ('term')            , 'prec' => 'z=');
our %methodcall      = ('dba' => ('methodcall')      , 'prec' => 'y=', 'assoc' => 'unary', 'uassoc' => 'left', 'fiddly' => 1);
our %autoincrement   = ('dba' => ('autoincrement')   , 'prec' => 'x=', 'assoc' => 'unary', 'uassoc' => 'non');
our %exponentiation  = ('dba' => ('exponentiation')  , 'prec' => 'w=', 'assoc' => 'right');
our %symbolic_unary  = ('dba' => ('symbolic unary')  , 'prec' => 'v=', 'assoc' => 'unary', 'uassoc' => 'left');
our %multiplicative  = ('dba' => ('multiplicative')  , 'prec' => 'u=', 'assoc' => 'left');
our %additive        = ('dba' => ('additive')        , 'prec' => 't=', 'assoc' => 'left');
our %replication     = ('dba' => ('replication')     , 'prec' => 's=', 'assoc' => 'left');
our %concatenation   = ('dba' => ('concatenation')   , 'prec' => 'r=', 'assoc' => 'list');
our %junctive_and    = ('dba' => ('junctive and')    , 'prec' => 'q=', 'assoc' => 'list');
our %junctive_or     = ('dba' => ('junctive or')     , 'prec' => 'p=', 'assoc' => 'list');
our %named_unary     = ('dba' => ('named unary')     , 'prec' => 'o=', 'assoc' => 'unary', 'uassoc' => 'left');
our %structural      = ('dba' => ('structural infix'), 'prec' => 'n=', 'assoc' => 'non', 'diffy' => 1);
our %chaining        = ('dba' => ('chaining')        , 'prec' => 'm=', 'assoc' => 'chain', 'diffy' => 1, 'iffy' => 1);
our %tight_and       = ('dba' => ('tight and')       , 'prec' => 'l=', 'assoc' => 'list');
our %tight_or        = ('dba' => ('tight or')        , 'prec' => 'k=', 'assoc' => 'list');
our %conditional     = ('dba' => ('conditional')     , 'prec' => 'j=', 'assoc' => 'right', 'fiddly' => 1);
our %item_assignment = ('dba' => ('item assignment') , 'prec' => 'i=', 'assoc' => 'right');
our %loose_unary     = ('dba' => ('loose unary')     , 'prec' => 'h=', 'assoc' => 'unary', 'uassoc' => 'left');
our %comma           = ('dba' => ('comma')           , 'prec' => 'g=', 'assoc' => 'list', 'nextterm' => 'nulltermish', 'fiddly' => 1);
our %list_infix      = ('dba' => ('list infix')      , 'prec' => 'f=', 'assoc' => 'list');
our %list_assignment = ('dba' => ('list assignment') , 'prec' => 'i=', 'assoc' => 'right', 'sub' => 'e=', 'fiddly' => 1);
our %list_prefix     = ('dba' => ('list prefix')     , 'prec' => 'e=', 'assoc' => 'unary', 'uassoc' => 'left');
our %loose_and       = ('dba' => ('loose and')       , 'prec' => 'd=', 'assoc' => 'list');
our %loose_or        = ('dba' => ('loose or')        , 'prec' => 'c=', 'assoc' => 'list');
our %sequencer       = ('dba' => ('sequencer')       , 'prec' => 'b=', 'assoc' => 'list', 'nextterm' => 'statement', 'fiddly' => 1);
our %LOOSEST         = ('dba' => ('LOOSEST')         , 'prec' => 'a=!');
our %terminator      = ('dba' => ('terminator')      , 'prec' => 'a=', 'assoc' => 'list');

# "epsilon" tighter than terminator
#constant $LOOSEST = %LOOSEST<prec>;
my $LOOSEST = "a=!"; # XXX preceding line is busted
my $item_assignment_prec = 'i=';
my $methodcall_prec = 'y=';


{ package STD::PrecOp;
use Moose::Role ':all' => { -prefix => "moose_" };
my $retree;

# This is hopefully called on a match to mix in operator info by type.
##     method coerce (Match $m)
sub coerce {
my $self = shift;
my $m = shift;


# $m but= ::?CLASS;
my $var = (ref($self)||$self) . '::o';
my $d = do { no strict 'refs'; \%{$var}}; 
if (not $d->{'transparent'}) {
for (keys(%$d)) { $m->{'O'}{$_} //= $d->{$_} };
$m->deb("coercing to " . $self) if $::DEBUG & DEBUG::EXPR;
}
$m->{'O'}{'kind'} = (ref($self)||$self);
return $m;
}

} ## end role

{ package STD::Transparent;
use Moose ':all' => { -prefix => "moose_" };
my $retree;
moose_with(qw(STD::PrecOp)); our %o = ('transparent' => 1);
} ## end class

{ package STD::Term;
use Moose ':all' => { -prefix => "moose_" };
my $retree;
moose_with(qw(STD::PrecOp));    our %o = %term;
} ## end class
{ package STD::Methodcall;
use Moose ':all' => { -prefix => "moose_" };
my $retree;
moose_with(qw(STD::PrecOp));    our %o = %methodcall;
} ## end class
{ package STD::Autoincrement;
use Moose ':all' => { -prefix => "moose_" };
my $retree;
moose_with(qw(STD::PrecOp));    our %o = %autoincrement;
} ## end class
{ package STD::Exponentiation;
use Moose ':all' => { -prefix => "moose_" };
my $retree;
moose_with(qw(STD::PrecOp));    our %o = %exponentiation;
} ## end class
{ package STD::Symbolic_unary;
use Moose ':all' => { -prefix => "moose_" };
my $retree;
moose_with(qw(STD::PrecOp));    our %o = %symbolic_unary;
} ## end class
{ package STD::Multiplicative;
use Moose ':all' => { -prefix => "moose_" };
my $retree;
moose_with(qw(STD::PrecOp));    our %o = %multiplicative;
} ## end class
{ package STD::Additive;
use Moose ':all' => { -prefix => "moose_" };
my $retree;
moose_with(qw(STD::PrecOp));    our %o = %additive;
} ## end class
{ package STD::Replication;
use Moose ':all' => { -prefix => "moose_" };
my $retree;
moose_with(qw(STD::PrecOp));    our %o = %replication;
} ## end class
{ package STD::Concatenation;
use Moose ':all' => { -prefix => "moose_" };
my $retree;
moose_with(qw(STD::PrecOp));    our %o = %concatenation;
} ## end class
{ package STD::Junctive_and;
use Moose ':all' => { -prefix => "moose_" };
my $retree;
moose_with(qw(STD::PrecOp));    our %o = %junctive_and;
} ## end class
{ package STD::Junctive_or;
use Moose ':all' => { -prefix => "moose_" };
my $retree;
moose_with(qw(STD::PrecOp));    our %o = %junctive_or;
} ## end class
{ package STD::Named_unary;
use Moose ':all' => { -prefix => "moose_" };
my $retree;
moose_with(qw(STD::PrecOp));    our %o = %named_unary;
} ## end class
{ package STD::Structural;
use Moose ':all' => { -prefix => "moose_" };
my $retree;
moose_with(qw(STD::PrecOp));    our %o = %structural;
} ## end class
{ package STD::Chaining;
use Moose ':all' => { -prefix => "moose_" };
my $retree;
moose_with(qw(STD::PrecOp));    our %o = %chaining;
} ## end class
{ package STD::Tight_and;
use Moose ':all' => { -prefix => "moose_" };
my $retree;
moose_with(qw(STD::PrecOp));    our %o = %tight_and;
} ## end class
{ package STD::Tight_or;
use Moose ':all' => { -prefix => "moose_" };
my $retree;
moose_with(qw(STD::PrecOp));    our %o = %tight_or;
} ## end class
{ package STD::Conditional;
use Moose ':all' => { -prefix => "moose_" };
my $retree;
moose_with(qw(STD::PrecOp));    our %o = %conditional;
} ## end class
{ package STD::Item_assignment;
use Moose ':all' => { -prefix => "moose_" };
my $retree;
moose_with(qw(STD::PrecOp));    our %o = %item_assignment;
} ## end class
{ package STD::Loose_unary;
use Moose ':all' => { -prefix => "moose_" };
my $retree;
moose_with(qw(STD::PrecOp));    our %o = %loose_unary;
} ## end class
{ package STD::Comma;
use Moose ':all' => { -prefix => "moose_" };
my $retree;
moose_with(qw(STD::PrecOp));    our %o = %comma;
} ## end class
{ package STD::List_infix;
use Moose ':all' => { -prefix => "moose_" };
my $retree;
moose_with(qw(STD::PrecOp));    our %o = %list_infix;
} ## end class
{ package STD::List_assignment;
use Moose ':all' => { -prefix => "moose_" };
my $retree;
moose_with(qw(STD::PrecOp));    our %o = %list_assignment;
} ## end class
{ package STD::List_prefix;
use Moose ':all' => { -prefix => "moose_" };
my $retree;
moose_with(qw(STD::PrecOp));    our %o = %list_prefix;
} ## end class
{ package STD::Loose_and;
use Moose ':all' => { -prefix => "moose_" };
my $retree;
moose_with(qw(STD::PrecOp));    our %o = %loose_and;
} ## end class
{ package STD::Loose_or;
use Moose ':all' => { -prefix => "moose_" };
my $retree;
moose_with(qw(STD::PrecOp));    our %o = %loose_or;
} ## end class
{ package STD::Sequencer;
use Moose ':all' => { -prefix => "moose_" };
my $retree;
moose_with(qw(STD::PrecOp));    our %o = %sequencer;
} ## end class
{ package STD::Terminator;
use Moose ':all' => { -prefix => "moose_" };
my $retree;
moose_with(qw(STD::PrecOp));    our %o = %terminator;
} ## end class

##############
# Categories #
##############

# Categories are designed to be easily extensible in derived grammars
# by merely adding more rules in the same category.  The rules within
# a given category start with the category name followed by a differentiating
# adverbial qualifier to serve (along with the category) as the longer name.

# The endsym context, if specified, says what to implicitly check for in each
# rule right after the initial <sym>.  Normally this is used to make sure
# there's appropriate whitespace.  # Note that endsym isn't called if <sym>
# isn't called.

local $::endsym = "null";
local $::endargs = -1;

#proto token category { <...> }
sub category__PEEK { $_[0]->_AUTOLEXpeek('category:*',$retree); }
sub category {
my $self = shift;
my $subs;

local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;

my $C = $self;
my $S = $C->{'_pos'};

my @result = eval {
my $trystate;
my ($tag, $try);
my @try;
my $relex;
if (my $fate = $C->{'_fate'}) {
if ($fate->[1] eq 'category') {
$C->deb("Fate passed to category: ", ::fatestr($fate)) if $::DEBUG & DEBUG::fates;
($C->{'_fate'}, $tag, $try) = @$fate;
@try = ($try);
}
}

my @gather = ();
for (;;) {
if (not @try) {
$relex //= $C->cursor_fate('STD', 'category:*', $retree);
@try = $relex->($C, $trystate);
}
last unless @try;
$try = shift(@try) // next;

if (ref $try eq 'ARRAY') {
($C->{'_fate'}, $tag, $try) = @$try;	# next candidate fate
}

$C->deb("category trying $tag $try") if $::DEBUG & DEBUG::try_processing;
push @gather, $C->$try(@_);
last if @gather;
}
$self->_MATCHIFY($S, "category", @gather);
};
if ($@) {
return () if $@ =~ /^ABORTRULE/;
die $@;
}
@result;
}


## token category__S_000category (:$sym is context<rw> = 'category')
##      token category:category { <sym> }

sub category__S_000category__PEEK { $_[0]->_AUTOLEXpeek('category__S_000category',$retree) }
sub category__S_000category {
my $self = shift;
local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;
my %args = @_;
local $sym = $args{sym} // 'category';


my $C = $self;
my $S = $C->{'_pos'};
$C->{'sym'} = $sym;

$self->_MATCHIFYr($S, "category__S_000category", 
$C->_PATTERN(qr/\Gcategory/)
);
}

## token category__S_001sigil (:$sym is context<rw> = 'sigil')
##      token category:sigil { <sym> }

sub category__S_001sigil__PEEK { $_[0]->_AUTOLEXpeek('category__S_001sigil',$retree) }
sub category__S_001sigil {
my $self = shift;
local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;
my %args = @_;
local $sym = $args{sym} // 'sigil';


my $C = $self;
my $S = $C->{'_pos'};
$C->{'sym'} = $sym;

$self->_MATCHIFYr($S, "category__S_001sigil", 
$C->_PATTERN(qr/\Gsigil/)
);
}
#proto token sigil { <...> }
sub sigil__PEEK { $_[0]->_AUTOLEXpeek('sigil:*',$retree); }
sub sigil {
my $self = shift;
my $subs;

local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;

my $C = $self;
my $S = $C->{'_pos'};

my @result = eval {
my $trystate;
my ($tag, $try);
my @try;
my $relex;
if (my $fate = $C->{'_fate'}) {
if ($fate->[1] eq 'sigil') {
$C->deb("Fate passed to sigil: ", ::fatestr($fate)) if $::DEBUG & DEBUG::fates;
($C->{'_fate'}, $tag, $try) = @$fate;
@try = ($try);
}
}

my @gather = ();
for (;;) {
if (not @try) {
$relex //= $C->cursor_fate('STD', 'sigil:*', $retree);
@try = $relex->($C, $trystate);
}
last unless @try;
$try = shift(@try) // next;

if (ref $try eq 'ARRAY') {
($C->{'_fate'}, $tag, $try) = @$try;	# next candidate fate
}

$C->deb("sigil trying $tag $try") if $::DEBUG & DEBUG::try_processing;
push @gather, $C->$try(@_);
last if @gather;
}
$self->_MATCHIFY($S, "sigil", @gather);
};
if ($@) {
return () if $@ =~ /^ABORTRULE/;
die $@;
}
@result;
}


## token category__S_002twigil (:$sym is context<rw> = 'twigil')
##      token category:twigil { <sym> }

sub category__S_002twigil__PEEK { $_[0]->_AUTOLEXpeek('category__S_002twigil',$retree) }
sub category__S_002twigil {
my $self = shift;
local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;
my %args = @_;
local $sym = $args{sym} // 'twigil';


my $C = $self;
my $S = $C->{'_pos'};
$C->{'sym'} = $sym;

$self->_MATCHIFYr($S, "category__S_002twigil", 
$C->_PATTERN(qr/\Gtwigil/)
);
}
#proto token twigil { <...> }
sub twigil__PEEK { $_[0]->_AUTOLEXpeek('twigil:*',$retree); }
sub twigil {
my $self = shift;
my $subs;

local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;

my $C = $self;
my $S = $C->{'_pos'};

my @result = eval {
my $trystate;
my ($tag, $try);
my @try;
my $relex;
if (my $fate = $C->{'_fate'}) {
if ($fate->[1] eq 'twigil') {
$C->deb("Fate passed to twigil: ", ::fatestr($fate)) if $::DEBUG & DEBUG::fates;
($C->{'_fate'}, $tag, $try) = @$fate;
@try = ($try);
}
}

my @gather = ();
for (;;) {
if (not @try) {
$relex //= $C->cursor_fate('STD', 'twigil:*', $retree);
@try = $relex->($C, $trystate);
}
last unless @try;
$try = shift(@try) // next;

if (ref $try eq 'ARRAY') {
($C->{'_fate'}, $tag, $try) = @$try;	# next candidate fate
}

$C->deb("twigil trying $tag $try") if $::DEBUG & DEBUG::try_processing;
push @gather, $C->$try(@_);
last if @gather;
}
$self->_MATCHIFY($S, "twigil", @gather);
};
if ($@) {
return () if $@ =~ /^ABORTRULE/;
die $@;
}
@result;
}


## token category__S_003special_variable (:$sym is context<rw> = 'special_variable')
##      token category:special_variable { <sym> }

sub category__S_003special_variable__PEEK { $_[0]->_AUTOLEXpeek('category__S_003special_variable',$retree) }
sub category__S_003special_variable {
my $self = shift;
local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;
my %args = @_;
local $sym = $args{sym} // 'special_variable';


my $C = $self;
my $S = $C->{'_pos'};
$C->{'sym'} = $sym;

$self->_MATCHIFYr($S, "category__S_003special_variable", 
$C->_PATTERN(qr/\Gspecial_variable/)
);
}
#proto token special_variable { <...> }
sub special_variable__PEEK { $_[0]->_AUTOLEXpeek('special_variable:*',$retree); }
sub special_variable {
my $self = shift;
my $subs;

local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;

my $C = $self;
my $S = $C->{'_pos'};

my @result = eval {
my $trystate;
my ($tag, $try);
my @try;
my $relex;
if (my $fate = $C->{'_fate'}) {
if ($fate->[1] eq 'special_variable') {
$C->deb("Fate passed to special_variable: ", ::fatestr($fate)) if $::DEBUG & DEBUG::fates;
($C->{'_fate'}, $tag, $try) = @$fate;
@try = ($try);
}
}

my @gather = ();
for (;;) {
if (not @try) {
$relex //= $C->cursor_fate('STD', 'special_variable:*', $retree);
@try = $relex->($C, $trystate);
}
last unless @try;
$try = shift(@try) // next;

if (ref $try eq 'ARRAY') {
($C->{'_fate'}, $tag, $try) = @$try;	# next candidate fate
}

$C->deb("special_variable trying $tag $try") if $::DEBUG & DEBUG::try_processing;
push @gather, $C->$try(@_);
last if @gather;
}
$self->_MATCHIFY($S, "special_variable", @gather);
};
if ($@) {
return () if $@ =~ /^ABORTRULE/;
die $@;
}
@result;
}


## token category__S_004version (:$sym is context<rw> = 'version')
##      token category:version { <sym> }

sub category__S_004version__PEEK { $_[0]->_AUTOLEXpeek('category__S_004version',$retree) }
sub category__S_004version {
my $self = shift;
local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;
my %args = @_;
local $sym = $args{sym} // 'version';


my $C = $self;
my $S = $C->{'_pos'};
$C->{'sym'} = $sym;

$self->_MATCHIFYr($S, "category__S_004version", 
$C->_PATTERN(qr/\Gversion/)
);
}
#proto token version { <...> }
sub version__PEEK { $_[0]->_AUTOLEXpeek('version:*',$retree); }
sub version {
my $self = shift;
my $subs;

local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;

my $C = $self;
my $S = $C->{'_pos'};

my @result = eval {
my $trystate;
my ($tag, $try);
my @try;
my $relex;
if (my $fate = $C->{'_fate'}) {
if ($fate->[1] eq 'version') {
$C->deb("Fate passed to version: ", ::fatestr($fate)) if $::DEBUG & DEBUG::fates;
($C->{'_fate'}, $tag, $try) = @$fate;
@try = ($try);
}
}

my @gather = ();
for (;;) {
if (not @try) {
$relex //= $C->cursor_fate('STD', 'version:*', $retree);
@try = $relex->($C, $trystate);
}
last unless @try;
$try = shift(@try) // next;

if (ref $try eq 'ARRAY') {
($C->{'_fate'}, $tag, $try) = @$try;	# next candidate fate
}

$C->deb("version trying $tag $try") if $::DEBUG & DEBUG::try_processing;
push @gather, $C->$try(@_);
last if @gather;
}
$self->_MATCHIFY($S, "version", @gather);
};
if ($@) {
return () if $@ =~ /^ABORTRULE/;
die $@;
}
@result;
}


## token category__S_005module_name (:$sym is context<rw> = 'module_name')
##      token category:module_name { <sym> }

sub category__S_005module_name__PEEK { $_[0]->_AUTOLEXpeek('category__S_005module_name',$retree) }
sub category__S_005module_name {
my $self = shift;
local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;
my %args = @_;
local $sym = $args{sym} // 'module_name';


my $C = $self;
my $S = $C->{'_pos'};
$C->{'sym'} = $sym;

$self->_MATCHIFYr($S, "category__S_005module_name", 
$C->_PATTERN(qr/\Gmodule_name/)
);
}
#proto token module_name { <...> }
sub module_name__PEEK { $_[0]->_AUTOLEXpeek('module_name:*',$retree); }
sub module_name {
my $self = shift;
my $subs;

local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;

my $C = $self;
my $S = $C->{'_pos'};

my @result = eval {
my $trystate;
my ($tag, $try);
my @try;
my $relex;
if (my $fate = $C->{'_fate'}) {
if ($fate->[1] eq 'module_name') {
$C->deb("Fate passed to module_name: ", ::fatestr($fate)) if $::DEBUG & DEBUG::fates;
($C->{'_fate'}, $tag, $try) = @$fate;
@try = ($try);
}
}

my @gather = ();
for (;;) {
if (not @try) {
$relex //= $C->cursor_fate('STD', 'module_name:*', $retree);
@try = $relex->($C, $trystate);
}
last unless @try;
$try = shift(@try) // next;

if (ref $try eq 'ARRAY') {
($C->{'_fate'}, $tag, $try) = @$try;	# next candidate fate
}

$C->deb("module_name trying $tag $try") if $::DEBUG & DEBUG::try_processing;
push @gather, $C->$try(@_);
last if @gather;
}
$self->_MATCHIFY($S, "module_name", @gather);
};
if ($@) {
return () if $@ =~ /^ABORTRULE/;
die $@;
}
@result;
}


## token category__S_006noun (:$sym is context<rw> = 'noun')
##      token category:noun { <sym> }

sub category__S_006noun__PEEK { $_[0]->_AUTOLEXpeek('category__S_006noun',$retree) }
sub category__S_006noun {
my $self = shift;
local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;
my %args = @_;
local $sym = $args{sym} // 'noun';


my $C = $self;
my $S = $C->{'_pos'};
$C->{'sym'} = $sym;

$self->_MATCHIFYr($S, "category__S_006noun", 
$C->_PATTERN(qr/\Gnoun/)
);
}
#proto token noun { <...> }
sub noun__PEEK { $_[0]->_AUTOLEXpeek('noun:*',$retree); }
sub noun {
my $self = shift;
my $subs;

local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;

my $C = $self;
my $S = $C->{'_pos'};

my @result = eval {
my $trystate;
my ($tag, $try);
my @try;
my $relex;
if (my $fate = $C->{'_fate'}) {
if ($fate->[1] eq 'noun') {
$C->deb("Fate passed to noun: ", ::fatestr($fate)) if $::DEBUG & DEBUG::fates;
($C->{'_fate'}, $tag, $try) = @$fate;
@try = ($try);
}
}

my @gather = ();
for (;;) {
if (not @try) {
$relex //= $C->cursor_fate('STD', 'noun:*', $retree);
@try = $relex->($C, $trystate);
}
last unless @try;
$try = shift(@try) // next;

if (ref $try eq 'ARRAY') {
($C->{'_fate'}, $tag, $try) = @$try;	# next candidate fate
}

$C->deb("noun trying $tag $try") if $::DEBUG & DEBUG::try_processing;
push @gather, $C->$try(@_);
last if @gather;
}
$self->_MATCHIFY($S, "noun", @gather);
};
if ($@) {
return () if $@ =~ /^ABORTRULE/;
die $@;
}
@result;
}


## token category__S_007value (:$sym is context<rw> = 'value')
##      token category:value { <sym> }

sub category__S_007value__PEEK { $_[0]->_AUTOLEXpeek('category__S_007value',$retree) }
sub category__S_007value {
my $self = shift;
local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;
my %args = @_;
local $sym = $args{sym} // 'value';


my $C = $self;
my $S = $C->{'_pos'};
$C->{'sym'} = $sym;

$self->_MATCHIFYr($S, "category__S_007value", 
$C->_PATTERN(qr/\Gvalue/)
);
}
#proto token value { <...> }
sub value__PEEK { $_[0]->_AUTOLEXpeek('value:*',$retree); }
sub value {
my $self = shift;
my $subs;

local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;

my $C = $self;
my $S = $C->{'_pos'};

my @result = eval {
my $trystate;
my ($tag, $try);
my @try;
my $relex;
if (my $fate = $C->{'_fate'}) {
if ($fate->[1] eq 'value') {
$C->deb("Fate passed to value: ", ::fatestr($fate)) if $::DEBUG & DEBUG::fates;
($C->{'_fate'}, $tag, $try) = @$fate;
@try = ($try);
}
}

my @gather = ();
for (;;) {
if (not @try) {
$relex //= $C->cursor_fate('STD', 'value:*', $retree);
@try = $relex->($C, $trystate);
}
last unless @try;
$try = shift(@try) // next;

if (ref $try eq 'ARRAY') {
($C->{'_fate'}, $tag, $try) = @$try;	# next candidate fate
}

$C->deb("value trying $tag $try") if $::DEBUG & DEBUG::try_processing;
push @gather, $C->$try(@_);
last if @gather;
}
$self->_MATCHIFY($S, "value", @gather);
};
if ($@) {
return () if $@ =~ /^ABORTRULE/;
die $@;
}
@result;
}


## token category__S_008term (:$sym is context<rw> = 'term')
##      token category:term { <sym> }

sub category__S_008term__PEEK { $_[0]->_AUTOLEXpeek('category__S_008term',$retree) }
sub category__S_008term {
my $self = shift;
local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;
my %args = @_;
local $sym = $args{sym} // 'term';


my $C = $self;
my $S = $C->{'_pos'};
$C->{'sym'} = $sym;

$self->_MATCHIFYr($S, "category__S_008term", 
$C->_PATTERN(qr/\Gterm/)
);
}
#proto token term { <...> }
sub term__PEEK { $_[0]->_AUTOLEXpeek('term:*',$retree); }
sub term {
my $self = shift;
my $subs;

local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;

my $C = $self;
my $S = $C->{'_pos'};

my @result = eval {
my $trystate;
my ($tag, $try);
my @try;
my $relex;
if (my $fate = $C->{'_fate'}) {
if ($fate->[1] eq 'term') {
$C->deb("Fate passed to term: ", ::fatestr($fate)) if $::DEBUG & DEBUG::fates;
($C->{'_fate'}, $tag, $try) = @$fate;
@try = ($try);
}
}

my @gather = ();
for (;;) {
if (not @try) {
$relex //= $C->cursor_fate('STD', 'term:*', $retree);
@try = $relex->($C, $trystate);
}
last unless @try;
$try = shift(@try) // next;

if (ref $try eq 'ARRAY') {
($C->{'_fate'}, $tag, $try) = @$try;	# next candidate fate
}

$C->deb("term trying $tag $try") if $::DEBUG & DEBUG::try_processing;
push @gather, $C->$try(@_);
last if @gather;
}
$self->_MATCHIFY($S, "term", @gather);
};
if ($@) {
return () if $@ =~ /^ABORTRULE/;
die $@;
}
@result;
}


## token category__S_009number (:$sym is context<rw> = 'number')
##      token category:number { <sym> }

sub category__S_009number__PEEK { $_[0]->_AUTOLEXpeek('category__S_009number',$retree) }
sub category__S_009number {
my $self = shift;
local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;
my %args = @_;
local $sym = $args{sym} // 'number';


my $C = $self;
my $S = $C->{'_pos'};
$C->{'sym'} = $sym;

$self->_MATCHIFYr($S, "category__S_009number", 
$C->_PATTERN(qr/\Gnumber/)
);
}
#proto token number { <...> }
sub number__PEEK { $_[0]->_AUTOLEXpeek('number:*',$retree); }
sub number {
my $self = shift;
my $subs;

local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;

my $C = $self;
my $S = $C->{'_pos'};

my @result = eval {
my $trystate;
my ($tag, $try);
my @try;
my $relex;
if (my $fate = $C->{'_fate'}) {
if ($fate->[1] eq 'number') {
$C->deb("Fate passed to number: ", ::fatestr($fate)) if $::DEBUG & DEBUG::fates;
($C->{'_fate'}, $tag, $try) = @$fate;
@try = ($try);
}
}

my @gather = ();
for (;;) {
if (not @try) {
$relex //= $C->cursor_fate('STD', 'number:*', $retree);
@try = $relex->($C, $trystate);
}
last unless @try;
$try = shift(@try) // next;

if (ref $try eq 'ARRAY') {
($C->{'_fate'}, $tag, $try) = @$try;	# next candidate fate
}

$C->deb("number trying $tag $try") if $::DEBUG & DEBUG::try_processing;
push @gather, $C->$try(@_);
last if @gather;
}
$self->_MATCHIFY($S, "number", @gather);
};
if ($@) {
return () if $@ =~ /^ABORTRULE/;
die $@;
}
@result;
}


## token category__S_010quote (:$sym is context<rw> = 'quote')
##      token category:quote { <sym> }

sub category__S_010quote__PEEK { $_[0]->_AUTOLEXpeek('category__S_010quote',$retree) }
sub category__S_010quote {
my $self = shift;
local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;
my %args = @_;
local $sym = $args{sym} // 'quote';


my $C = $self;
my $S = $C->{'_pos'};
$C->{'sym'} = $sym;

$self->_MATCHIFYr($S, "category__S_010quote", 
$C->_PATTERN(qr/\Gquote/)
);
}
#proto token quote () { <...> }
sub quote__PEEK { $_[0]->_AUTOLEXpeek('quote:*',$retree); }
sub quote {
my $self = shift;
my $subs;

local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;

my $C = $self;
my $S = $C->{'_pos'};

my @result = eval {
my $trystate;
my ($tag, $try);
my @try;
my $relex;
if (my $fate = $C->{'_fate'}) {
if ($fate->[1] eq 'quote') {
$C->deb("Fate passed to quote: ", ::fatestr($fate)) if $::DEBUG & DEBUG::fates;
($C->{'_fate'}, $tag, $try) = @$fate;
@try = ($try);
}
}

my @gather = ();
for (;;) {
if (not @try) {
$relex //= $C->cursor_fate('STD', 'quote:*', $retree);
@try = $relex->($C, $trystate);
}
last unless @try;
$try = shift(@try) // next;

if (ref $try eq 'ARRAY') {
($C->{'_fate'}, $tag, $try) = @$try;	# next candidate fate
}

$C->deb("quote trying $tag $try") if $::DEBUG & DEBUG::try_processing;
push @gather, $C->$try(@_);
last if @gather;
}
$self->_MATCHIFY($S, "quote", @gather);
};
if ($@) {
return () if $@ =~ /^ABORTRULE/;
die $@;
}
@result;
}


## token category__S_011prefix (:$sym is context<rw> = 'prefix')
##      token category:prefix { <sym> }

sub category__S_011prefix__PEEK { $_[0]->_AUTOLEXpeek('category__S_011prefix',$retree) }
sub category__S_011prefix {
my $self = shift;
local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;
my %args = @_;
local $sym = $args{sym} // 'prefix';


my $C = $self;
my $S = $C->{'_pos'};
$C->{'sym'} = $sym;

$self->_MATCHIFYr($S, "category__S_011prefix", 
$C->_PATTERN(qr/\Gprefix/)
);
}
#proto token prefix is unary is defequiv(%symbolic_unary) { <...> }
sub prefix__PEEK { $_[0]->_AUTOLEXpeek('prefix:*',$retree); }
sub prefix {
my $self = shift;
my $subs;

local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;

my $C = $self;
my $S = $C->{'_pos'};

my @result = eval {
my $trystate;
my ($tag, $try);
my @try;
my $relex;
if (my $fate = $C->{'_fate'}) {
if ($fate->[1] eq 'prefix') {
$C->deb("Fate passed to prefix: ", ::fatestr($fate)) if $::DEBUG & DEBUG::fates;
($C->{'_fate'}, $tag, $try) = @$fate;
@try = ($try);
}
}

my @gather = ();
for (;;) {
if (not @try) {
$relex //= $C->cursor_fate('STD', 'prefix:*', $retree);
@try = $relex->($C, $trystate);
}
last unless @try;
$try = shift(@try) // next;

if (ref $try eq 'ARRAY') {
($C->{'_fate'}, $tag, $try) = @$try;	# next candidate fate
}

$C->deb("prefix trying $tag $try") if $::DEBUG & DEBUG::try_processing;
push @gather, $C->$try(@_);
last if @gather;
}
$self->_MATCHIFY($S, "prefix", @gather);
};
if ($@) {
return () if $@ =~ /^ABORTRULE/;
die $@;
}
@result;
}


## token category__S_012infix (:$sym is context<rw> = 'infix')
##      token category:infix { <sym> }

sub category__S_012infix__PEEK { $_[0]->_AUTOLEXpeek('category__S_012infix',$retree) }
sub category__S_012infix {
my $self = shift;
local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;
my %args = @_;
local $sym = $args{sym} // 'infix';


my $C = $self;
my $S = $C->{'_pos'};
$C->{'sym'} = $sym;

$self->_MATCHIFYr($S, "category__S_012infix", 
$C->_PATTERN(qr/\Ginfix/)
);
}
#proto token infix is binary is defequiv(%additive) { <...> }
sub infix__PEEK { $_[0]->_AUTOLEXpeek('infix:*',$retree); }
sub infix {
my $self = shift;
my $subs;

local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;

my $C = $self;
my $S = $C->{'_pos'};

my @result = eval {
my $trystate;
my ($tag, $try);
my @try;
my $relex;
if (my $fate = $C->{'_fate'}) {
if ($fate->[1] eq 'infix') {
$C->deb("Fate passed to infix: ", ::fatestr($fate)) if $::DEBUG & DEBUG::fates;
($C->{'_fate'}, $tag, $try) = @$fate;
@try = ($try);
}
}

my @gather = ();
for (;;) {
if (not @try) {
$relex //= $C->cursor_fate('STD', 'infix:*', $retree);
@try = $relex->($C, $trystate);
}
last unless @try;
$try = shift(@try) // next;

if (ref $try eq 'ARRAY') {
($C->{'_fate'}, $tag, $try) = @$try;	# next candidate fate
}

$C->deb("infix trying $tag $try") if $::DEBUG & DEBUG::try_processing;
push @gather, $C->$try(@_);
last if @gather;
}
$self->_MATCHIFY($S, "infix", @gather);
};
if ($@) {
return () if $@ =~ /^ABORTRULE/;
die $@;
}
@result;
}


## token category__S_013postfix (:$sym is context<rw> = 'postfix')
##      token category:postfix { <sym> }

sub category__S_013postfix__PEEK { $_[0]->_AUTOLEXpeek('category__S_013postfix',$retree) }
sub category__S_013postfix {
my $self = shift;
local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;
my %args = @_;
local $sym = $args{sym} // 'postfix';


my $C = $self;
my $S = $C->{'_pos'};
$C->{'sym'} = $sym;

$self->_MATCHIFYr($S, "category__S_013postfix", 
$C->_PATTERN(qr/\Gpostfix/)
);
}
#proto token postfix is unary is defequiv(%autoincrement) { <...> }
sub postfix__PEEK { $_[0]->_AUTOLEXpeek('postfix:*',$retree); }
sub postfix {
my $self = shift;
my $subs;

local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;

my $C = $self;
my $S = $C->{'_pos'};

my @result = eval {
my $trystate;
my ($tag, $try);
my @try;
my $relex;
if (my $fate = $C->{'_fate'}) {
if ($fate->[1] eq 'postfix') {
$C->deb("Fate passed to postfix: ", ::fatestr($fate)) if $::DEBUG & DEBUG::fates;
($C->{'_fate'}, $tag, $try) = @$fate;
@try = ($try);
}
}

my @gather = ();
for (;;) {
if (not @try) {
$relex //= $C->cursor_fate('STD', 'postfix:*', $retree);
@try = $relex->($C, $trystate);
}
last unless @try;
$try = shift(@try) // next;

if (ref $try eq 'ARRAY') {
($C->{'_fate'}, $tag, $try) = @$try;	# next candidate fate
}

$C->deb("postfix trying $tag $try") if $::DEBUG & DEBUG::try_processing;
push @gather, $C->$try(@_);
last if @gather;
}
$self->_MATCHIFY($S, "postfix", @gather);
};
if ($@) {
return () if $@ =~ /^ABORTRULE/;
die $@;
}
@result;
}


## token category__S_014dotty (:$sym is context<rw> = 'dotty')
##      token category:dotty { <sym> }

sub category__S_014dotty__PEEK { $_[0]->_AUTOLEXpeek('category__S_014dotty',$retree) }
sub category__S_014dotty {
my $self = shift;
local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;
my %args = @_;
local $sym = $args{sym} // 'dotty';


my $C = $self;
my $S = $C->{'_pos'};
$C->{'sym'} = $sym;

$self->_MATCHIFYr($S, "category__S_014dotty", 
$C->_PATTERN(qr/\Gdotty/)
);
}
#proto token dotty (:$endsym is context = 'unspacey') { <...> }
sub dotty__PEEK { $_[0]->_AUTOLEXpeek('dotty:*',$retree); }
sub dotty {
my $self = shift;
my $subs;

local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;

my $C = $self;
my $S = $C->{'_pos'};

my @result = eval {
my $trystate;
my ($tag, $try);
my @try;
my $relex;
if (my $fate = $C->{'_fate'}) {
if ($fate->[1] eq 'dotty') {
$C->deb("Fate passed to dotty: ", ::fatestr($fate)) if $::DEBUG & DEBUG::fates;
($C->{'_fate'}, $tag, $try) = @$fate;
@try = ($try);
}
}

my @gather = ();
for (;;) {
if (not @try) {
$relex //= $C->cursor_fate('STD', 'dotty:*', $retree);
@try = $relex->($C, $trystate);
}
last unless @try;
$try = shift(@try) // next;

if (ref $try eq 'ARRAY') {
($C->{'_fate'}, $tag, $try) = @$try;	# next candidate fate
}

$C->deb("dotty trying $tag $try") if $::DEBUG & DEBUG::try_processing;
push @gather, $C->$try(@_);
last if @gather;
}
$self->_MATCHIFY($S, "dotty", @gather);
};
if ($@) {
return () if $@ =~ /^ABORTRULE/;
die $@;
}
@result;
}


## token category__S_015circumfix (:$sym is context<rw> = 'circumfix')
##      token category:circumfix { <sym> }

sub category__S_015circumfix__PEEK { $_[0]->_AUTOLEXpeek('category__S_015circumfix',$retree) }
sub category__S_015circumfix {
my $self = shift;
local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;
my %args = @_;
local $sym = $args{sym} // 'circumfix';


my $C = $self;
my $S = $C->{'_pos'};
$C->{'sym'} = $sym;

$self->_MATCHIFYr($S, "category__S_015circumfix", 
$C->_PATTERN(qr/\Gcircumfix/)
);
}
#proto token circumfix { <...> }
sub circumfix__PEEK { $_[0]->_AUTOLEXpeek('circumfix:*',$retree); }
sub circumfix {
my $self = shift;
my $subs;

local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;

my $C = $self;
my $S = $C->{'_pos'};

my @result = eval {
my $trystate;
my ($tag, $try);
my @try;
my $relex;
if (my $fate = $C->{'_fate'}) {
if ($fate->[1] eq 'circumfix') {
$C->deb("Fate passed to circumfix: ", ::fatestr($fate)) if $::DEBUG & DEBUG::fates;
($C->{'_fate'}, $tag, $try) = @$fate;
@try = ($try);
}
}

my @gather = ();
for (;;) {
if (not @try) {
$relex //= $C->cursor_fate('STD', 'circumfix:*', $retree);
@try = $relex->($C, $trystate);
}
last unless @try;
$try = shift(@try) // next;

if (ref $try eq 'ARRAY') {
($C->{'_fate'}, $tag, $try) = @$try;	# next candidate fate
}

$C->deb("circumfix trying $tag $try") if $::DEBUG & DEBUG::try_processing;
push @gather, $C->$try(@_);
last if @gather;
}
$self->_MATCHIFY($S, "circumfix", @gather);
};
if ($@) {
return () if $@ =~ /^ABORTRULE/;
die $@;
}
@result;
}


## token category__S_016postcircumfix (:$sym is context<rw> = 'postcircumfix')
##      token category:postcircumfix { <sym> }

sub category__S_016postcircumfix__PEEK { $_[0]->_AUTOLEXpeek('category__S_016postcircumfix',$retree) }
sub category__S_016postcircumfix {
my $self = shift;
local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;
my %args = @_;
local $sym = $args{sym} // 'postcircumfix';


my $C = $self;
my $S = $C->{'_pos'};
$C->{'sym'} = $sym;

$self->_MATCHIFYr($S, "category__S_016postcircumfix", 
$C->_PATTERN(qr/\Gpostcircumfix/)
);
}
#proto token postcircumfix is unary { <...> }  # unary as far as EXPR knows...
sub postcircumfix__PEEK { $_[0]->_AUTOLEXpeek('postcircumfix:*',$retree); }
sub postcircumfix {
my $self = shift;
my $subs;

local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;

my $C = $self;
my $S = $C->{'_pos'};

my @result = eval {
my $trystate;
my ($tag, $try);
my @try;
my $relex;
if (my $fate = $C->{'_fate'}) {
if ($fate->[1] eq 'postcircumfix') {
$C->deb("Fate passed to postcircumfix: ", ::fatestr($fate)) if $::DEBUG & DEBUG::fates;
($C->{'_fate'}, $tag, $try) = @$fate;
@try = ($try);
}
}

my @gather = ();
for (;;) {
if (not @try) {
$relex //= $C->cursor_fate('STD', 'postcircumfix:*', $retree);
@try = $relex->($C, $trystate);
}
last unless @try;
$try = shift(@try) // next;

if (ref $try eq 'ARRAY') {
($C->{'_fate'}, $tag, $try) = @$try;	# next candidate fate
}

$C->deb("postcircumfix trying $tag $try") if $::DEBUG & DEBUG::try_processing;
push @gather, $C->$try(@_);
last if @gather;
}
$self->_MATCHIFY($S, "postcircumfix", @gather);
};
if ($@) {
return () if $@ =~ /^ABORTRULE/;
die $@;
}
@result;
}


## token category__S_017quote_mod (:$sym is context<rw> = 'quote_mod')
##      token category:quote_mod { <sym> }

sub category__S_017quote_mod__PEEK { $_[0]->_AUTOLEXpeek('category__S_017quote_mod',$retree) }
sub category__S_017quote_mod {
my $self = shift;
local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;
my %args = @_;
local $sym = $args{sym} // 'quote_mod';


my $C = $self;
my $S = $C->{'_pos'};
$C->{'sym'} = $sym;

$self->_MATCHIFYr($S, "category__S_017quote_mod", 
$C->_PATTERN(qr/\Gquote_mod/)
);
}
#proto token quote_mod { <...> }
sub quote_mod__PEEK { $_[0]->_AUTOLEXpeek('quote_mod:*',$retree); }
sub quote_mod {
my $self = shift;
my $subs;

local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;

my $C = $self;
my $S = $C->{'_pos'};

my @result = eval {
my $trystate;
my ($tag, $try);
my @try;
my $relex;
if (my $fate = $C->{'_fate'}) {
if ($fate->[1] eq 'quote_mod') {
$C->deb("Fate passed to quote_mod: ", ::fatestr($fate)) if $::DEBUG & DEBUG::fates;
($C->{'_fate'}, $tag, $try) = @$fate;
@try = ($try);
}
}

my @gather = ();
for (;;) {
if (not @try) {
$relex //= $C->cursor_fate('STD', 'quote_mod:*', $retree);
@try = $relex->($C, $trystate);
}
last unless @try;
$try = shift(@try) // next;

if (ref $try eq 'ARRAY') {
($C->{'_fate'}, $tag, $try) = @$try;	# next candidate fate
}

$C->deb("quote_mod trying $tag $try") if $::DEBUG & DEBUG::try_processing;
push @gather, $C->$try(@_);
last if @gather;
}
$self->_MATCHIFY($S, "quote_mod", @gather);
};
if ($@) {
return () if $@ =~ /^ABORTRULE/;
die $@;
}
@result;
}


## token category__S_018trait_mod (:$sym is context<rw> = 'trait_mod')
##      token category:trait_mod { <sym> }

sub category__S_018trait_mod__PEEK { $_[0]->_AUTOLEXpeek('category__S_018trait_mod',$retree) }
sub category__S_018trait_mod {
my $self = shift;
local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;
my %args = @_;
local $sym = $args{sym} // 'trait_mod';


my $C = $self;
my $S = $C->{'_pos'};
$C->{'sym'} = $sym;

$self->_MATCHIFYr($S, "category__S_018trait_mod", 
$C->_PATTERN(qr/\Gtrait_mod/)
);
}
#proto token trait_mod (:$endsym is context = 'spacey') { <...> }
sub trait_mod__PEEK { $_[0]->_AUTOLEXpeek('trait_mod:*',$retree); }
sub trait_mod {
my $self = shift;
my $subs;

local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;

my $C = $self;
my $S = $C->{'_pos'};

my @result = eval {
my $trystate;
my ($tag, $try);
my @try;
my $relex;
if (my $fate = $C->{'_fate'}) {
if ($fate->[1] eq 'trait_mod') {
$C->deb("Fate passed to trait_mod: ", ::fatestr($fate)) if $::DEBUG & DEBUG::fates;
($C->{'_fate'}, $tag, $try) = @$fate;
@try = ($try);
}
}

my @gather = ();
for (;;) {
if (not @try) {
$relex //= $C->cursor_fate('STD', 'trait_mod:*', $retree);
@try = $relex->($C, $trystate);
}
last unless @try;
$try = shift(@try) // next;

if (ref $try eq 'ARRAY') {
($C->{'_fate'}, $tag, $try) = @$try;	# next candidate fate
}

$C->deb("trait_mod trying $tag $try") if $::DEBUG & DEBUG::try_processing;
push @gather, $C->$try(@_);
last if @gather;
}
$self->_MATCHIFY($S, "trait_mod", @gather);
};
if ($@) {
return () if $@ =~ /^ABORTRULE/;
die $@;
}
@result;
}


## token category__S_019type_declarator (:$sym is context<rw> = 'type_declarator')
##      token category:type_declarator { <sym> }

sub category__S_019type_declarator__PEEK { $_[0]->_AUTOLEXpeek('category__S_019type_declarator',$retree) }
sub category__S_019type_declarator {
my $self = shift;
local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;
my %args = @_;
local $sym = $args{sym} // 'type_declarator';


my $C = $self;
my $S = $C->{'_pos'};
$C->{'sym'} = $sym;

$self->_MATCHIFYr($S, "category__S_019type_declarator", 
$C->_PATTERN(qr/\Gtype_declarator/)
);
}
#proto token type_declarator (:$endsym is context = 'spacey') { <...> }
sub type_declarator__PEEK { $_[0]->_AUTOLEXpeek('type_declarator:*',$retree); }
sub type_declarator {
my $self = shift;
my $subs;

local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;

my $C = $self;
my $S = $C->{'_pos'};

my @result = eval {
my $trystate;
my ($tag, $try);
my @try;
my $relex;
if (my $fate = $C->{'_fate'}) {
if ($fate->[1] eq 'type_declarator') {
$C->deb("Fate passed to type_declarator: ", ::fatestr($fate)) if $::DEBUG & DEBUG::fates;
($C->{'_fate'}, $tag, $try) = @$fate;
@try = ($try);
}
}

my @gather = ();
for (;;) {
if (not @try) {
$relex //= $C->cursor_fate('STD', 'type_declarator:*', $retree);
@try = $relex->($C, $trystate);
}
last unless @try;
$try = shift(@try) // next;

if (ref $try eq 'ARRAY') {
($C->{'_fate'}, $tag, $try) = @$try;	# next candidate fate
}

$C->deb("type_declarator trying $tag $try") if $::DEBUG & DEBUG::try_processing;
push @gather, $C->$try(@_);
last if @gather;
}
$self->_MATCHIFY($S, "type_declarator", @gather);
};
if ($@) {
return () if $@ =~ /^ABORTRULE/;
die $@;
}
@result;
}


## token category__S_020scope_declarator (:$sym is context<rw> = 'scope_declarator')
##      token category:scope_declarator { <sym> }

sub category__S_020scope_declarator__PEEK { $_[0]->_AUTOLEXpeek('category__S_020scope_declarator',$retree) }
sub category__S_020scope_declarator {
my $self = shift;
local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;
my %args = @_;
local $sym = $args{sym} // 'scope_declarator';


my $C = $self;
my $S = $C->{'_pos'};
$C->{'sym'} = $sym;

$self->_MATCHIFYr($S, "category__S_020scope_declarator", 
$C->_PATTERN(qr/\Gscope_declarator/)
);
}
#proto token scope_declarator (:$endsym is context = 'nofun') { <...> }
sub scope_declarator__PEEK { $_[0]->_AUTOLEXpeek('scope_declarator:*',$retree); }
sub scope_declarator {
my $self = shift;
my $subs;

local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;

my $C = $self;
my $S = $C->{'_pos'};

my @result = eval {
my $trystate;
my ($tag, $try);
my @try;
my $relex;
if (my $fate = $C->{'_fate'}) {
if ($fate->[1] eq 'scope_declarator') {
$C->deb("Fate passed to scope_declarator: ", ::fatestr($fate)) if $::DEBUG & DEBUG::fates;
($C->{'_fate'}, $tag, $try) = @$fate;
@try = ($try);
}
}

my @gather = ();
for (;;) {
if (not @try) {
$relex //= $C->cursor_fate('STD', 'scope_declarator:*', $retree);
@try = $relex->($C, $trystate);
}
last unless @try;
$try = shift(@try) // next;

if (ref $try eq 'ARRAY') {
($C->{'_fate'}, $tag, $try) = @$try;	# next candidate fate
}

$C->deb("scope_declarator trying $tag $try") if $::DEBUG & DEBUG::try_processing;
push @gather, $C->$try(@_);
last if @gather;
}
$self->_MATCHIFY($S, "scope_declarator", @gather);
};
if ($@) {
return () if $@ =~ /^ABORTRULE/;
die $@;
}
@result;
}


## token category__S_021package_declarator (:$sym is context<rw> = 'package_declarator')
##      token category:package_declarator { <sym> }

sub category__S_021package_declarator__PEEK { $_[0]->_AUTOLEXpeek('category__S_021package_declarator',$retree) }
sub category__S_021package_declarator {
my $self = shift;
local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;
my %args = @_;
local $sym = $args{sym} // 'package_declarator';


my $C = $self;
my $S = $C->{'_pos'};
$C->{'sym'} = $sym;

$self->_MATCHIFYr($S, "category__S_021package_declarator", 
$C->_PATTERN(qr/\Gpackage_declarator/)
);
}
#proto token package_declarator (:$endsym is context = 'spacey') { <...> }
sub package_declarator__PEEK { $_[0]->_AUTOLEXpeek('package_declarator:*',$retree); }
sub package_declarator {
my $self = shift;
my $subs;

local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;

my $C = $self;
my $S = $C->{'_pos'};

my @result = eval {
my $trystate;
my ($tag, $try);
my @try;
my $relex;
if (my $fate = $C->{'_fate'}) {
if ($fate->[1] eq 'package_declarator') {
$C->deb("Fate passed to package_declarator: ", ::fatestr($fate)) if $::DEBUG & DEBUG::fates;
($C->{'_fate'}, $tag, $try) = @$fate;
@try = ($try);
}
}

my @gather = ();
for (;;) {
if (not @try) {
$relex //= $C->cursor_fate('STD', 'package_declarator:*', $retree);
@try = $relex->($C, $trystate);
}
last unless @try;
$try = shift(@try) // next;

if (ref $try eq 'ARRAY') {
($C->{'_fate'}, $tag, $try) = @$try;	# next candidate fate
}

$C->deb("package_declarator trying $tag $try") if $::DEBUG & DEBUG::try_processing;
push @gather, $C->$try(@_);
last if @gather;
}
$self->_MATCHIFY($S, "package_declarator", @gather);
};
if ($@) {
return () if $@ =~ /^ABORTRULE/;
die $@;
}
@result;
}


## token category__S_022multi_declarator (:$sym is context<rw> = 'multi_declarator')
##      token category:multi_declarator { <sym> }

sub category__S_022multi_declarator__PEEK { $_[0]->_AUTOLEXpeek('category__S_022multi_declarator',$retree) }
sub category__S_022multi_declarator {
my $self = shift;
local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;
my %args = @_;
local $sym = $args{sym} // 'multi_declarator';


my $C = $self;
my $S = $C->{'_pos'};
$C->{'sym'} = $sym;

$self->_MATCHIFYr($S, "category__S_022multi_declarator", 
$C->_PATTERN(qr/\Gmulti_declarator/)
);
}
#proto token multi_declarator (:$endsym is context = 'spacey') { <...> }
sub multi_declarator__PEEK { $_[0]->_AUTOLEXpeek('multi_declarator:*',$retree); }
sub multi_declarator {
my $self = shift;
my $subs;

local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;

my $C = $self;
my $S = $C->{'_pos'};

my @result = eval {
my $trystate;
my ($tag, $try);
my @try;
my $relex;
if (my $fate = $C->{'_fate'}) {
if ($fate->[1] eq 'multi_declarator') {
$C->deb("Fate passed to multi_declarator: ", ::fatestr($fate)) if $::DEBUG & DEBUG::fates;
($C->{'_fate'}, $tag, $try) = @$fate;
@try = ($try);
}
}

my @gather = ();
for (;;) {
if (not @try) {
$relex //= $C->cursor_fate('STD', 'multi_declarator:*', $retree);
@try = $relex->($C, $trystate);
}
last unless @try;
$try = shift(@try) // next;

if (ref $try eq 'ARRAY') {
($C->{'_fate'}, $tag, $try) = @$try;	# next candidate fate
}

$C->deb("multi_declarator trying $tag $try") if $::DEBUG & DEBUG::try_processing;
push @gather, $C->$try(@_);
last if @gather;
}
$self->_MATCHIFY($S, "multi_declarator", @gather);
};
if ($@) {
return () if $@ =~ /^ABORTRULE/;
die $@;
}
@result;
}


## token category__S_023routine_declarator (:$sym is context<rw> = 'routine_declarator')
##      token category:routine_declarator { <sym> }

sub category__S_023routine_declarator__PEEK { $_[0]->_AUTOLEXpeek('category__S_023routine_declarator',$retree) }
sub category__S_023routine_declarator {
my $self = shift;
local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;
my %args = @_;
local $sym = $args{sym} // 'routine_declarator';


my $C = $self;
my $S = $C->{'_pos'};
$C->{'sym'} = $sym;

$self->_MATCHIFYr($S, "category__S_023routine_declarator", 
$C->_PATTERN(qr/\Groutine_declarator/)
);
}
#proto token routine_declarator (:$endsym is context = 'endid') { <...> }
sub routine_declarator__PEEK { $_[0]->_AUTOLEXpeek('routine_declarator:*',$retree); }
sub routine_declarator {
my $self = shift;
my $subs;

local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;

my $C = $self;
my $S = $C->{'_pos'};

my @result = eval {
my $trystate;
my ($tag, $try);
my @try;
my $relex;
if (my $fate = $C->{'_fate'}) {
if ($fate->[1] eq 'routine_declarator') {
$C->deb("Fate passed to routine_declarator: ", ::fatestr($fate)) if $::DEBUG & DEBUG::fates;
($C->{'_fate'}, $tag, $try) = @$fate;
@try = ($try);
}
}

my @gather = ();
for (;;) {
if (not @try) {
$relex //= $C->cursor_fate('STD', 'routine_declarator:*', $retree);
@try = $relex->($C, $trystate);
}
last unless @try;
$try = shift(@try) // next;

if (ref $try eq 'ARRAY') {
($C->{'_fate'}, $tag, $try) = @$try;	# next candidate fate
}

$C->deb("routine_declarator trying $tag $try") if $::DEBUG & DEBUG::try_processing;
push @gather, $C->$try(@_);
last if @gather;
}
$self->_MATCHIFY($S, "routine_declarator", @gather);
};
if ($@) {
return () if $@ =~ /^ABORTRULE/;
die $@;
}
@result;
}


## token category__S_024regex_declarator (:$sym is context<rw> = 'regex_declarator')
##      token category:regex_declarator { <sym> }

sub category__S_024regex_declarator__PEEK { $_[0]->_AUTOLEXpeek('category__S_024regex_declarator',$retree) }
sub category__S_024regex_declarator {
my $self = shift;
local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;
my %args = @_;
local $sym = $args{sym} // 'regex_declarator';


my $C = $self;
my $S = $C->{'_pos'};
$C->{'sym'} = $sym;

$self->_MATCHIFYr($S, "category__S_024regex_declarator", 
$C->_PATTERN(qr/\Gregex_declarator/)
);
}
#proto token regex_declarator (:$endsym is context = 'spacey') { <...> }
sub regex_declarator__PEEK { $_[0]->_AUTOLEXpeek('regex_declarator:*',$retree); }
sub regex_declarator {
my $self = shift;
my $subs;

local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;

my $C = $self;
my $S = $C->{'_pos'};

my @result = eval {
my $trystate;
my ($tag, $try);
my @try;
my $relex;
if (my $fate = $C->{'_fate'}) {
if ($fate->[1] eq 'regex_declarator') {
$C->deb("Fate passed to regex_declarator: ", ::fatestr($fate)) if $::DEBUG & DEBUG::fates;
($C->{'_fate'}, $tag, $try) = @$fate;
@try = ($try);
}
}

my @gather = ();
for (;;) {
if (not @try) {
$relex //= $C->cursor_fate('STD', 'regex_declarator:*', $retree);
@try = $relex->($C, $trystate);
}
last unless @try;
$try = shift(@try) // next;

if (ref $try eq 'ARRAY') {
($C->{'_fate'}, $tag, $try) = @$try;	# next candidate fate
}

$C->deb("regex_declarator trying $tag $try") if $::DEBUG & DEBUG::try_processing;
push @gather, $C->$try(@_);
last if @gather;
}
$self->_MATCHIFY($S, "regex_declarator", @gather);
};
if ($@) {
return () if $@ =~ /^ABORTRULE/;
die $@;
}
@result;
}


## token category__S_025statement_prefix (:$sym is context<rw> = 'statement_prefix')
##      token category:statement_prefix { <sym> }

sub category__S_025statement_prefix__PEEK { $_[0]->_AUTOLEXpeek('category__S_025statement_prefix',$retree) }
sub category__S_025statement_prefix {
my $self = shift;
local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;
my %args = @_;
local $sym = $args{sym} // 'statement_prefix';


my $C = $self;
my $S = $C->{'_pos'};
$C->{'sym'} = $sym;

$self->_MATCHIFYr($S, "category__S_025statement_prefix", 
$C->_PATTERN(qr/\Gstatement_prefix/)
);
}
#proto rule  statement_prefix () { <...> }
sub statement_prefix__PEEK { $_[0]->_AUTOLEXpeek('statement_prefix:*',$retree); }
sub statement_prefix {
my $self = shift;
my $subs;

local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;

my $C = $self;
my $S = $C->{'_pos'};

my @result = eval {
my $trystate;
my ($tag, $try);
my @try;
my $relex;
if (my $fate = $C->{'_fate'}) {
if ($fate->[1] eq 'statement_prefix') {
$C->deb("Fate passed to statement_prefix: ", ::fatestr($fate)) if $::DEBUG & DEBUG::fates;
($C->{'_fate'}, $tag, $try) = @$fate;
@try = ($try);
}
}

my @gather = ();
for (;;) {
if (not @try) {
$relex //= $C->cursor_fate('STD', 'statement_prefix:*', $retree);
@try = $relex->($C, $trystate);
}
last unless @try;
$try = shift(@try) // next;

if (ref $try eq 'ARRAY') {
($C->{'_fate'}, $tag, $try) = @$try;	# next candidate fate
}

$C->deb("statement_prefix trying $tag $try") if $::DEBUG & DEBUG::try_processing;
push @gather, $C->$try(@_);
last if @gather;
}
$self->_MATCHIFY($S, "statement_prefix", @gather);
};
if ($@) {
return () if $@ =~ /^ABORTRULE/;
die $@;
}
@result;
}


## token category__S_026statement_control (:$sym is context<rw> = 'statement_control')
##      token category:statement_control { <sym> }

sub category__S_026statement_control__PEEK { $_[0]->_AUTOLEXpeek('category__S_026statement_control',$retree) }
sub category__S_026statement_control {
my $self = shift;
local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;
my %args = @_;
local $sym = $args{sym} // 'statement_control';


my $C = $self;
my $S = $C->{'_pos'};
$C->{'sym'} = $sym;

$self->_MATCHIFYr($S, "category__S_026statement_control", 
$C->_PATTERN(qr/\Gstatement_control/)
);
}
#proto rule  statement_control (:$endsym is context = 'spacey') { <...> }
sub statement_control__PEEK { $_[0]->_AUTOLEXpeek('statement_control:*',$retree); }
sub statement_control {
my $self = shift;
my $subs;

local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;

my $C = $self;
my $S = $C->{'_pos'};

my @result = eval {
my $trystate;
my ($tag, $try);
my @try;
my $relex;
if (my $fate = $C->{'_fate'}) {
if ($fate->[1] eq 'statement_control') {
$C->deb("Fate passed to statement_control: ", ::fatestr($fate)) if $::DEBUG & DEBUG::fates;
($C->{'_fate'}, $tag, $try) = @$fate;
@try = ($try);
}
}

my @gather = ();
for (;;) {
if (not @try) {
$relex //= $C->cursor_fate('STD', 'statement_control:*', $retree);
@try = $relex->($C, $trystate);
}
last unless @try;
$try = shift(@try) // next;

if (ref $try eq 'ARRAY') {
($C->{'_fate'}, $tag, $try) = @$try;	# next candidate fate
}

$C->deb("statement_control trying $tag $try") if $::DEBUG & DEBUG::try_processing;
push @gather, $C->$try(@_);
last if @gather;
}
$self->_MATCHIFY($S, "statement_control", @gather);
};
if ($@) {
return () if $@ =~ /^ABORTRULE/;
die $@;
}
@result;
}


## token category__S_027statement_mod_cond (:$sym is context<rw> = 'statement_mod_cond')
##      token category:statement_mod_cond { <sym> }

sub category__S_027statement_mod_cond__PEEK { $_[0]->_AUTOLEXpeek('category__S_027statement_mod_cond',$retree) }
sub category__S_027statement_mod_cond {
my $self = shift;
local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;
my %args = @_;
local $sym = $args{sym} // 'statement_mod_cond';


my $C = $self;
my $S = $C->{'_pos'};
$C->{'sym'} = $sym;

$self->_MATCHIFYr($S, "category__S_027statement_mod_cond", 
$C->_PATTERN(qr/\Gstatement_mod_cond/)
);
}
#proto rule  statement_mod_cond (:$endsym is context = 'nofun') { <...> }
sub statement_mod_cond__PEEK { $_[0]->_AUTOLEXpeek('statement_mod_cond:*',$retree); }
sub statement_mod_cond {
my $self = shift;
my $subs;

local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;

my $C = $self;
my $S = $C->{'_pos'};

my @result = eval {
my $trystate;
my ($tag, $try);
my @try;
my $relex;
if (my $fate = $C->{'_fate'}) {
if ($fate->[1] eq 'statement_mod_cond') {
$C->deb("Fate passed to statement_mod_cond: ", ::fatestr($fate)) if $::DEBUG & DEBUG::fates;
($C->{'_fate'}, $tag, $try) = @$fate;
@try = ($try);
}
}

my @gather = ();
for (;;) {
if (not @try) {
$relex //= $C->cursor_fate('STD', 'statement_mod_cond:*', $retree);
@try = $relex->($C, $trystate);
}
last unless @try;
$try = shift(@try) // next;

if (ref $try eq 'ARRAY') {
($C->{'_fate'}, $tag, $try) = @$try;	# next candidate fate
}

$C->deb("statement_mod_cond trying $tag $try") if $::DEBUG & DEBUG::try_processing;
push @gather, $C->$try(@_);
last if @gather;
}
$self->_MATCHIFY($S, "statement_mod_cond", @gather);
};
if ($@) {
return () if $@ =~ /^ABORTRULE/;
die $@;
}
@result;
}


## token category__S_028statement_mod_loop (:$sym is context<rw> = 'statement_mod_loop')
##      token category:statement_mod_loop { <sym> }

sub category__S_028statement_mod_loop__PEEK { $_[0]->_AUTOLEXpeek('category__S_028statement_mod_loop',$retree) }
sub category__S_028statement_mod_loop {
my $self = shift;
local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;
my %args = @_;
local $sym = $args{sym} // 'statement_mod_loop';


my $C = $self;
my $S = $C->{'_pos'};
$C->{'sym'} = $sym;

$self->_MATCHIFYr($S, "category__S_028statement_mod_loop", 
$C->_PATTERN(qr/\Gstatement_mod_loop/)
);
}
#proto rule  statement_mod_loop (:$endsym is context = 'nofun') { <...> }
sub statement_mod_loop__PEEK { $_[0]->_AUTOLEXpeek('statement_mod_loop:*',$retree); }
sub statement_mod_loop {
my $self = shift;
my $subs;

local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;

my $C = $self;
my $S = $C->{'_pos'};

my @result = eval {
my $trystate;
my ($tag, $try);
my @try;
my $relex;
if (my $fate = $C->{'_fate'}) {
if ($fate->[1] eq 'statement_mod_loop') {
$C->deb("Fate passed to statement_mod_loop: ", ::fatestr($fate)) if $::DEBUG & DEBUG::fates;
($C->{'_fate'}, $tag, $try) = @$fate;
@try = ($try);
}
}

my @gather = ();
for (;;) {
if (not @try) {
$relex //= $C->cursor_fate('STD', 'statement_mod_loop:*', $retree);
@try = $relex->($C, $trystate);
}
last unless @try;
$try = shift(@try) // next;

if (ref $try eq 'ARRAY') {
($C->{'_fate'}, $tag, $try) = @$try;	# next candidate fate
}

$C->deb("statement_mod_loop trying $tag $try") if $::DEBUG & DEBUG::try_processing;
push @gather, $C->$try(@_);
last if @gather;
}
$self->_MATCHIFY($S, "statement_mod_loop", @gather);
};
if ($@) {
return () if $@ =~ /^ABORTRULE/;
die $@;
}
@result;
}


## token category__S_029infix_prefix_meta_operator (:$sym is context<rw> = 'infix_prefix_meta_operator')
##      token category:infix_prefix_meta_operator { <sym> }

sub category__S_029infix_prefix_meta_operator__PEEK { $_[0]->_AUTOLEXpeek('category__S_029infix_prefix_meta_operator',$retree) }
sub category__S_029infix_prefix_meta_operator {
my $self = shift;
local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;
my %args = @_;
local $sym = $args{sym} // 'infix_prefix_meta_operator';


my $C = $self;
my $S = $C->{'_pos'};
$C->{'sym'} = $sym;

$self->_MATCHIFYr($S, "category__S_029infix_prefix_meta_operator", 
$C->_PATTERN(qr/\Ginfix_prefix_meta_operator/)
);
}
#proto token infix_prefix_meta_operator is binary { <...> }
sub infix_prefix_meta_operator__PEEK { $_[0]->_AUTOLEXpeek('infix_prefix_meta_operator:*',$retree); }
sub infix_prefix_meta_operator {
my $self = shift;
my $subs;

local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;

my $C = $self;
my $S = $C->{'_pos'};

my @result = eval {
my $trystate;
my ($tag, $try);
my @try;
my $relex;
if (my $fate = $C->{'_fate'}) {
if ($fate->[1] eq 'infix_prefix_meta_operator') {
$C->deb("Fate passed to infix_prefix_meta_operator: ", ::fatestr($fate)) if $::DEBUG & DEBUG::fates;
($C->{'_fate'}, $tag, $try) = @$fate;
@try = ($try);
}
}

my @gather = ();
for (;;) {
if (not @try) {
$relex //= $C->cursor_fate('STD', 'infix_prefix_meta_operator:*', $retree);
@try = $relex->($C, $trystate);
}
last unless @try;
$try = shift(@try) // next;

if (ref $try eq 'ARRAY') {
($C->{'_fate'}, $tag, $try) = @$try;	# next candidate fate
}

$C->deb("infix_prefix_meta_operator trying $tag $try") if $::DEBUG & DEBUG::try_processing;
push @gather, $C->$try(@_);
last if @gather;
}
$self->_MATCHIFY($S, "infix_prefix_meta_operator", @gather);
};
if ($@) {
return () if $@ =~ /^ABORTRULE/;
die $@;
}
@result;
}


## token category__S_030infix_postfix_meta_operator (:$sym is context<rw> = 'infix_postfix_meta_operator')
##      token category:infix_postfix_meta_operator { <sym> }

sub category__S_030infix_postfix_meta_operator__PEEK { $_[0]->_AUTOLEXpeek('category__S_030infix_postfix_meta_operator',$retree) }
sub category__S_030infix_postfix_meta_operator {
my $self = shift;
local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;
my %args = @_;
local $sym = $args{sym} // 'infix_postfix_meta_operator';


my $C = $self;
my $S = $C->{'_pos'};
$C->{'sym'} = $sym;

$self->_MATCHIFYr($S, "category__S_030infix_postfix_meta_operator", 
$C->_PATTERN(qr/\Ginfix_postfix_meta_operator/)
);
}
#proto token infix_postfix_meta_operator ($op) is binary { <...> }
sub infix_postfix_meta_operator__PEEK { $_[0]->_AUTOLEXpeek('infix_postfix_meta_operator:*',$retree); }
sub infix_postfix_meta_operator {
my $self = shift;
my $subs;

local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;

my $C = $self;
my $S = $C->{'_pos'};

my @result = eval {
my $trystate;
my ($tag, $try);
my @try;
my $relex;
if (my $fate = $C->{'_fate'}) {
if ($fate->[1] eq 'infix_postfix_meta_operator') {
$C->deb("Fate passed to infix_postfix_meta_operator: ", ::fatestr($fate)) if $::DEBUG & DEBUG::fates;
($C->{'_fate'}, $tag, $try) = @$fate;
@try = ($try);
}
}

my @gather = ();
for (;;) {
if (not @try) {
$relex //= $C->cursor_fate('STD', 'infix_postfix_meta_operator:*', $retree);
@try = $relex->($C, $trystate);
}
last unless @try;
$try = shift(@try) // next;

if (ref $try eq 'ARRAY') {
($C->{'_fate'}, $tag, $try) = @$try;	# next candidate fate
}

$C->deb("infix_postfix_meta_operator trying $tag $try") if $::DEBUG & DEBUG::try_processing;
push @gather, $C->$try(@_);
last if @gather;
}
$self->_MATCHIFY($S, "infix_postfix_meta_operator", @gather);
};
if ($@) {
return () if $@ =~ /^ABORTRULE/;
die $@;
}
@result;
}


## token category__S_031infix_circumfix_meta_operator (:$sym is context<rw> = 'infix_circumfix_meta_operator')
##      token category:infix_circumfix_meta_operator { <sym> }

sub category__S_031infix_circumfix_meta_operator__PEEK { $_[0]->_AUTOLEXpeek('category__S_031infix_circumfix_meta_operator',$retree) }
sub category__S_031infix_circumfix_meta_operator {
my $self = shift;
local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;
my %args = @_;
local $sym = $args{sym} // 'infix_circumfix_meta_operator';


my $C = $self;
my $S = $C->{'_pos'};
$C->{'sym'} = $sym;

$self->_MATCHIFYr($S, "category__S_031infix_circumfix_meta_operator", 
$C->_PATTERN(qr/\Ginfix_circumfix_meta_operator/)
);
}
#proto token infix_circumfix_meta_operator is binary { <...> }
sub infix_circumfix_meta_operator__PEEK { $_[0]->_AUTOLEXpeek('infix_circumfix_meta_operator:*',$retree); }
sub infix_circumfix_meta_operator {
my $self = shift;
my $subs;

local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;

my $C = $self;
my $S = $C->{'_pos'};

my @result = eval {
my $trystate;
my ($tag, $try);
my @try;
my $relex;
if (my $fate = $C->{'_fate'}) {
if ($fate->[1] eq 'infix_circumfix_meta_operator') {
$C->deb("Fate passed to infix_circumfix_meta_operator: ", ::fatestr($fate)) if $::DEBUG & DEBUG::fates;
($C->{'_fate'}, $tag, $try) = @$fate;
@try = ($try);
}
}

my @gather = ();
for (;;) {
if (not @try) {
$relex //= $C->cursor_fate('STD', 'infix_circumfix_meta_operator:*', $retree);
@try = $relex->($C, $trystate);
}
last unless @try;
$try = shift(@try) // next;

if (ref $try eq 'ARRAY') {
($C->{'_fate'}, $tag, $try) = @$try;	# next candidate fate
}

$C->deb("infix_circumfix_meta_operator trying $tag $try") if $::DEBUG & DEBUG::try_processing;
push @gather, $C->$try(@_);
last if @gather;
}
$self->_MATCHIFY($S, "infix_circumfix_meta_operator", @gather);
};
if ($@) {
return () if $@ =~ /^ABORTRULE/;
die $@;
}
@result;
}


## token category__S_032postfix_prefix_meta_operator (:$sym is context<rw> = 'postfix_prefix_meta_operator')
##      token category:postfix_prefix_meta_operator { <sym> }

sub category__S_032postfix_prefix_meta_operator__PEEK { $_[0]->_AUTOLEXpeek('category__S_032postfix_prefix_meta_operator',$retree) }
sub category__S_032postfix_prefix_meta_operator {
my $self = shift;
local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;
my %args = @_;
local $sym = $args{sym} // 'postfix_prefix_meta_operator';


my $C = $self;
my $S = $C->{'_pos'};
$C->{'sym'} = $sym;

$self->_MATCHIFYr($S, "category__S_032postfix_prefix_meta_operator", 
$C->_PATTERN(qr/\Gpostfix_prefix_meta_operator/)
);
}
#proto token postfix_prefix_meta_operator is unary { <...> }
sub postfix_prefix_meta_operator__PEEK { $_[0]->_AUTOLEXpeek('postfix_prefix_meta_operator:*',$retree); }
sub postfix_prefix_meta_operator {
my $self = shift;
my $subs;

local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;

my $C = $self;
my $S = $C->{'_pos'};

my @result = eval {
my $trystate;
my ($tag, $try);
my @try;
my $relex;
if (my $fate = $C->{'_fate'}) {
if ($fate->[1] eq 'postfix_prefix_meta_operator') {
$C->deb("Fate passed to postfix_prefix_meta_operator: ", ::fatestr($fate)) if $::DEBUG & DEBUG::fates;
($C->{'_fate'}, $tag, $try) = @$fate;
@try = ($try);
}
}

my @gather = ();
for (;;) {
if (not @try) {
$relex //= $C->cursor_fate('STD', 'postfix_prefix_meta_operator:*', $retree);
@try = $relex->($C, $trystate);
}
last unless @try;
$try = shift(@try) // next;

if (ref $try eq 'ARRAY') {
($C->{'_fate'}, $tag, $try) = @$try;	# next candidate fate
}

$C->deb("postfix_prefix_meta_operator trying $tag $try") if $::DEBUG & DEBUG::try_processing;
push @gather, $C->$try(@_);
last if @gather;
}
$self->_MATCHIFY($S, "postfix_prefix_meta_operator", @gather);
};
if ($@) {
return () if $@ =~ /^ABORTRULE/;
die $@;
}
@result;
}


## token category__S_033prefix_postfix_meta_operator (:$sym is context<rw> = 'prefix_postfix_meta_operator')
##      token category:prefix_postfix_meta_operator { <sym> }

sub category__S_033prefix_postfix_meta_operator__PEEK { $_[0]->_AUTOLEXpeek('category__S_033prefix_postfix_meta_operator',$retree) }
sub category__S_033prefix_postfix_meta_operator {
my $self = shift;
local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;
my %args = @_;
local $sym = $args{sym} // 'prefix_postfix_meta_operator';


my $C = $self;
my $S = $C->{'_pos'};
$C->{'sym'} = $sym;

$self->_MATCHIFYr($S, "category__S_033prefix_postfix_meta_operator", 
$C->_PATTERN(qr/\Gprefix_postfix_meta_operator/)
);
}
#proto token prefix_postfix_meta_operator is unary { <...> }
sub prefix_postfix_meta_operator__PEEK { $_[0]->_AUTOLEXpeek('prefix_postfix_meta_operator:*',$retree); }
sub prefix_postfix_meta_operator {
my $self = shift;
my $subs;

local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;

my $C = $self;
my $S = $C->{'_pos'};

my @result = eval {
my $trystate;
my ($tag, $try);
my @try;
my $relex;
if (my $fate = $C->{'_fate'}) {
if ($fate->[1] eq 'prefix_postfix_meta_operator') {
$C->deb("Fate passed to prefix_postfix_meta_operator: ", ::fatestr($fate)) if $::DEBUG & DEBUG::fates;
($C->{'_fate'}, $tag, $try) = @$fate;
@try = ($try);
}
}

my @gather = ();
for (;;) {
if (not @try) {
$relex //= $C->cursor_fate('STD', 'prefix_postfix_meta_operator:*', $retree);
@try = $relex->($C, $trystate);
}
last unless @try;
$try = shift(@try) // next;

if (ref $try eq 'ARRAY') {
($C->{'_fate'}, $tag, $try) = @$try;	# next candidate fate
}

$C->deb("prefix_postfix_meta_operator trying $tag $try") if $::DEBUG & DEBUG::try_processing;
push @gather, $C->$try(@_);
last if @gather;
}
$self->_MATCHIFY($S, "prefix_postfix_meta_operator", @gather);
};
if ($@) {
return () if $@ =~ /^ABORTRULE/;
die $@;
}
@result;
}


## token category__S_034prefix_circumfix_meta_operator (:$sym is context<rw> = 'prefix_circumfix_meta_operator')
##      token category:prefix_circumfix_meta_operator { <sym> }

sub category__S_034prefix_circumfix_meta_operator__PEEK { $_[0]->_AUTOLEXpeek('category__S_034prefix_circumfix_meta_operator',$retree) }
sub category__S_034prefix_circumfix_meta_operator {
my $self = shift;
local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;
my %args = @_;
local $sym = $args{sym} // 'prefix_circumfix_meta_operator';


my $C = $self;
my $S = $C->{'_pos'};
$C->{'sym'} = $sym;

$self->_MATCHIFYr($S, "category__S_034prefix_circumfix_meta_operator", 
$C->_PATTERN(qr/\Gprefix_circumfix_meta_operator/)
);
}
#proto token prefix_circumfix_meta_operator is unary { <...> }
sub prefix_circumfix_meta_operator__PEEK { $_[0]->_AUTOLEXpeek('prefix_circumfix_meta_operator:*',$retree); }
sub prefix_circumfix_meta_operator {
my $self = shift;
my $subs;

local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;

my $C = $self;
my $S = $C->{'_pos'};

my @result = eval {
my $trystate;
my ($tag, $try);
my @try;
my $relex;
if (my $fate = $C->{'_fate'}) {
if ($fate->[1] eq 'prefix_circumfix_meta_operator') {
$C->deb("Fate passed to prefix_circumfix_meta_operator: ", ::fatestr($fate)) if $::DEBUG & DEBUG::fates;
($C->{'_fate'}, $tag, $try) = @$fate;
@try = ($try);
}
}

my @gather = ();
for (;;) {
if (not @try) {
$relex //= $C->cursor_fate('STD', 'prefix_circumfix_meta_operator:*', $retree);
@try = $relex->($C, $trystate);
}
last unless @try;
$try = shift(@try) // next;

if (ref $try eq 'ARRAY') {
($C->{'_fate'}, $tag, $try) = @$try;	# next candidate fate
}

$C->deb("prefix_circumfix_meta_operator trying $tag $try") if $::DEBUG & DEBUG::try_processing;
push @gather, $C->$try(@_);
last if @gather;
}
$self->_MATCHIFY($S, "prefix_circumfix_meta_operator", @gather);
};
if ($@) {
return () if $@ =~ /^ABORTRULE/;
die $@;
}
@result;
}


## token category__S_035terminator (:$sym is context<rw> = 'terminator')
##      token category:terminator { <sym> }

sub category__S_035terminator__PEEK { $_[0]->_AUTOLEXpeek('category__S_035terminator',$retree) }
sub category__S_035terminator {
my $self = shift;
local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;
my %args = @_;
local $sym = $args{sym} // 'terminator';


my $C = $self;
my $S = $C->{'_pos'};
$C->{'sym'} = $sym;

$self->_MATCHIFYr($S, "category__S_035terminator", 
$C->_PATTERN(qr/\Gterminator/)
);
}
#proto token terminator { <...> }
sub terminator__PEEK { $_[0]->_AUTOLEXpeek('terminator:*',$retree); }
sub terminator {
my $self = shift;
my $subs;

local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;

my $C = $self;
my $S = $C->{'_pos'};

my @result = eval {
my $trystate;
my ($tag, $try);
my @try;
my $relex;
if (my $fate = $C->{'_fate'}) {
if ($fate->[1] eq 'terminator') {
$C->deb("Fate passed to terminator: ", ::fatestr($fate)) if $::DEBUG & DEBUG::fates;
($C->{'_fate'}, $tag, $try) = @$fate;
@try = ($try);
}
}

my @gather = ();
for (;;) {
if (not @try) {
$relex //= $C->cursor_fate('STD', 'terminator:*', $retree);
@try = $relex->($C, $trystate);
}
last unless @try;
$try = shift(@try) // next;

if (ref $try eq 'ARRAY') {
($C->{'_fate'}, $tag, $try) = @$try;	# next candidate fate
}

$C->deb("terminator trying $tag $try") if $::DEBUG & DEBUG::try_processing;
push @gather, $C->$try(@_);
last if @gather;
}
$self->_MATCHIFY($S, "terminator", @gather);
};
if ($@) {
return () if $@ =~ /^ABORTRULE/;
die $@;
}
@result;
}


## token unspacey
##      token unspacey { <.unsp>? }

sub unspacey__PEEK { $_[0]->_AUTOLEXpeek('unspacey',$retree) }
sub unspacey {
my $self = shift;
local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;


my $C = $self;
my $S = $C->{'_pos'};

$self->_MATCHIFYr($S, "unspacey", 
$C->_OPTr(sub { my $C=shift;
$C->unsp
})
);
}
## token endid
##      token endid { <?before <-[ \- \' \w ]> > }

sub endid__PEEK { $_[0]->_AUTOLEXpeek('endid',$retree) }
sub endid {
my $self = shift;
local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;


my $C = $self;
my $S = $C->{'_pos'};

$self->_MATCHIFYr($S, "endid", 
$C->before(sub { my $C=shift;
$C->_PATTERN(qr/\G[^\-\'\w]/)
})
);
}
## token spacey
##      token spacey { <?before <[ \s \# ]> > }

sub spacey__PEEK { $_[0]->_AUTOLEXpeek('spacey',$retree) }
sub spacey {
my $self = shift;
local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;


my $C = $self;
my $S = $C->{'_pos'};

$self->_MATCHIFYr($S, "spacey", 
$C->before(sub { my $C=shift;
$C->_PATTERN(qr/\G[\s\#]/)
})
);
}
## token nofun
##      token nofun { <!before '(' | '.(' | '\\' | '\'' | '-' > }

sub nofun__PEEK { $_[0]->_AUTOLEXpeek('nofun',$retree) }
sub nofun {
my $self = shift;
local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;


my $C = $self;
my $S = $C->{'_pos'};

$self->_MATCHIFYr($S, "nofun", 
$C->_NOTBEFORE( sub { my $C=shift;
$C->before(sub { my $C=shift;
do {
my @result = eval {
my $trystate;
my ($tag, $try);
my @try;
my $relex;

my $fate;
if ($fate = $C->{'_fate'} and $fate->[1] eq 'nofun_01') {
$C->deb("Fate passed to nofun_01: ", ::fatestr($fate)) if $::DEBUG & DEBUG::fates;
($C->{'_fate'}, $tag, $try) = @$fate;
@try = ($try);
}

my @gather = ();
for (;;) {
if (not @try) {
$relex //= $C->cursor_fate('STD', 'nofun_01', $retree);
@try = $relex->($C, $trystate);
}
last unless @try;
$try = shift(@try) // next;

if (ref $try eq 'ARRAY') {
($C->{'_fate'}, $tag, $try) = @$try;	# next candidate fate
}

$C->deb("nofun_01 trying $tag $try") if $::DEBUG & DEBUG::try_processing;
push @gather, ((
sub { my $C=shift;
$C->_EXACT('(')
},
sub { my $C=shift;
$C->_EXACT('.(')
},
sub { my $C=shift;
$C->_EXACT('\\')
},
sub { my $C=shift;
$C->_EXACT('\'')
},
sub { my $C=shift;
$C->_EXACT('-')
},
)[$try])->($C);
last if @gather;
}
@gather;
};
if (@result) {
@result;
}
elsif ($@) {
my ($first) = $@ =~ /(^.*)/;
$self->deb("CAUGHT $first") if $::DEBUG & DEBUG::trace_call;
die $@ if $@ !~ /^ABORTBRANCH/;
();
}
else {
();
}
}

})
})
);
}

##################
# Lexer routines #
##################

## token ws
##      token ws {
##          :my @stub = return self if @*MEMOS[self.pos]<ws> :exists;
##          :my $startpos = self.pos;
##      
##          :dba('whitespace')
##          [
##              | \h+ <![#\s\\]> { @*MEMOS[$¢.pos]<ws> = $startpos; }   # common case
##              | <?before \w> <?after \w> :::
##                  { @*MEMOS[$startpos]<ws> = undef; }
##                  <.panic: "Whitespace is required between alphanumeric tokens">        # must \s+ between words
##          ]
##          ||
##          [
##          | <.unsp>
##          | <.vws> <.heredoc>
##          | <.unv>
##          | $ { $¢.moreinput }
##          ]*
##      
##          {{
##              if ($¢.pos == $startpos) {
##                  @*MEMOS[$¢.pos]<ws> = undef;
##              }
##              else {
##                  @*MEMOS[$¢.pos]<ws> = $startpos;
##                  @*MEMOS[$¢.pos]<endstmt> = @*MEMOS[$startpos]<endstmt>
##                      if @*MEMOS[$startpos]<endstmt> :exists;
##              }
##          }}
##      }

sub ws__PEEK { '' }
sub ws {
my $self = shift;
local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;
my @stub = return $self if exists $::MEMOS[$self->{'_pos'}]{'ws'};
my $startpos = $self->{'_pos'};


my $C = $self;
my $S = $C->{'_pos'};

$self->_MATCHIFY($S, "ws", 
do { my @gather;
eval { push @gather, $C->_BRACKET( sub { my $C=shift;
do {
my @result = eval {
my $trystate;
my ($tag, $try);
my @try;
my $relex;

my $fate;
if ($fate = $C->{'_fate'} and $fate->[1] eq 'ws_01') {
$C->deb("Fate passed to ws_01: ", ::fatestr($fate)) if $::DEBUG & DEBUG::fates;
($C->{'_fate'}, $tag, $try) = @$fate;
@try = ($try);
}

my @gather = ();
for (;;) {
if (not @try) {
$relex //= $C->cursor_fate('STD', 'ws_01', $retree);
@try = $relex->($C, $trystate);
}
last unless @try;
$try = shift(@try) // next;

if (ref $try eq 'ARRAY') {
($C->{'_fate'}, $tag, $try) = @$try;	# next candidate fate
}

$C->deb("ws_01 trying $tag $try") if $::DEBUG & DEBUG::try_processing;
push @gather, ((
sub { my $C=shift;
do {
if (my ($C) = ($C->_PATTERN(qr/\G((?:[\x20\t\r])++)/))) {
do {
if (my ($C) = ($C->_NOTBEFORE( sub { my $C=shift;
$C->_PATTERN(qr/\G[#\s\\]/)
}))) {
scalar(do {
$::MEMOS[$C->{'_pos'}]{'ws'} = $startpos; 
}, $C);
}
else {
();
}
};
}
else {
();
}
}
},
sub { my $C=shift;
Cursor::lazymap(sub { my $C=$_[0];
Cursor::lazymap(sub { my $C=$_[0];
Cursor::lazymap(sub { my $C=$_[0];
Cursor::lazymap(sub { my $C=$_[0];
$C->panic("Whitespace is required between alphanumeric tokens")
}, scalar(do {
$::MEMOS[$startpos]{'ws'} = undef; 
}, $C))
}, $C->_COMMITRULE())
}, $C->before( sub { my $C=shift;
$C->after(sub { my $C=shift;
$C->_PATTERN(qr/\G(?<=\w)/)
})
}))
}, $C->before(sub { my $C=shift;
$C->_PATTERN(qr/\G\w/)
}))
},
)[$try])->($C);
last if @gather;
}
@gather;
};
if (@result) {
@result;
}
elsif ($@) {
my ($first) = $@ =~ /(^.*)/;
$self->deb("CAUGHT $first") if $::DEBUG & DEBUG::trace_call;
die $@ if $@ !~ /^ABORTBRANCH/;
();
}
else {
();
}
}

})} // do {die $@ if $@ and $@ !~ /ABORT/;1} 
or
eval { push @gather, Cursor::lazymap(sub { my $C=$_[0];
scalar(do {

if (($C->{'_pos'} == $startpos)) {
$::MEMOS[$C->{'_pos'}]{'ws'} = undef;
}
else {
$::MEMOS[$C->{'_pos'}]{'ws'} = $startpos;
$::MEMOS[$C->{'_pos'}]{'endstmt'} = $::MEMOS[$startpos]{'endstmt'}
if exists $::MEMOS[$startpos]{'endstmt'};
}

}, $C)
}, $C->_STARr(sub { my $C=shift;
$C->_BRACKET( sub { my $C=shift;
do {
my @result = eval {
my $trystate;
my ($tag, $try);
my @try;
my $relex;

my $fate;
if ($fate = $C->{'_fate'} and $fate->[1] eq 'ws_05') {
$C->deb("Fate passed to ws_05: ", ::fatestr($fate)) if $::DEBUG & DEBUG::fates;
($C->{'_fate'}, $tag, $try) = @$fate;
@try = ($try);
}

my @gather = ();
for (;;) {
if (not @try) {
$relex //= $C->cursor_fate('STD', 'ws_05', $retree);
@try = $relex->($C, $trystate);
}
last unless @try;
$try = shift(@try) // next;

if (ref $try eq 'ARRAY') {
($C->{'_fate'}, $tag, $try) = @$try;	# next candidate fate
}

$C->deb("ws_05 trying $tag $try") if $::DEBUG & DEBUG::try_processing;
push @gather, ((
sub { my $C=shift;
$C->unsp
},
sub { my $C=shift;
Cursor::lazymap(sub { my $C=$_[0];
$C->heredoc
}, $C->vws)
},
sub { my $C=shift;
$C->unv
},
sub { my $C=shift;
Cursor::lazymap(sub { my $C=$_[0];
scalar(do {
$C->moreinput 
}, $C)
}, $C->_PATTERN(qr/\G\z/))
},
)[$try])->($C);
last if @gather;
}
@gather;
};
if (@result) {
@result;
}
elsif ($@) {
my ($first) = $@ =~ /(^.*)/;
$self->deb("CAUGHT $first") if $::DEBUG & DEBUG::trace_call;
die $@ if $@ !~ /^ABORTBRANCH/;
();
}
else {
();
}
}

})
}))} or do { die $@ if $@ };
@gather;
}
);
}

## token unsp
##      token unsp {
##          \\ <?before [\s|'#'] >
##          :dba('unspace')
##          [
##          | <.vws>                     {*}                             #= vwhite
##          | <.unv>                  {*}                                #= unv
##          | $ { $¢.moreinput }
##          ]*
##      }

sub unsp__PEEK { $_[0]->_AUTOLEXpeek('unsp',$retree) }
sub unsp {
my $self = shift;
local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;


my $C = $self;
my $S = $C->{'_pos'};

$self->_MATCHIFYr($S, "unsp", 
do {
if (my ($C) = ($C->_EXACT('\\'))) {
do {
if (my ($C) = ($C->before(sub { my $C=shift;
$C->_BRACKETr( sub { my $C=shift;
do {
my @result = eval {
my $trystate;
my ($tag, $try);
my @try;
my $relex;

my $fate;
if ($fate = $C->{'_fate'} and $fate->[1] eq 'unsp_02') {
$C->deb("Fate passed to unsp_02: ", ::fatestr($fate)) if $::DEBUG & DEBUG::fates;
($C->{'_fate'}, $tag, $try) = @$fate;
@try = ($try);
}

my @gather = ();
for (;;) {
if (not @try) {
$relex //= $C->cursor_fate('STD', 'unsp_02', $retree);
@try = $relex->($C, $trystate);
}
last unless @try;
$try = shift(@try) // next;

if (ref $try eq 'ARRAY') {
($C->{'_fate'}, $tag, $try) = @$try;	# next candidate fate
}

$C->deb("unsp_02 trying $tag $try") if $::DEBUG & DEBUG::try_processing;
push @gather, ((
sub { my $C=shift;
$C->_PATTERN(qr/\G\s/)
},
sub { my $C=shift;
$C->_EXACT('#')
},
)[$try])->($C);
last if @gather;
}
@gather;
};
if (@result) {
@result;
}
elsif ($@) {
my ($first) = $@ =~ /(^.*)/;
$self->deb("CAUGHT $first") if $::DEBUG & DEBUG::trace_call;
die $@ if $@ !~ /^ABORTBRANCH/;
();
}
else {
();
}
}

})
}))) {
$C->_STARr(sub { my $C=shift;
$C->_BRACKETr( sub { my $C=shift;
do {
my @result = eval {
my $trystate;
my ($tag, $try);
my @try;
my $relex;

my $fate;
if ($fate = $C->{'_fate'} and $fate->[1] eq 'unsp_03') {
$C->deb("Fate passed to unsp_03: ", ::fatestr($fate)) if $::DEBUG & DEBUG::fates;
($C->{'_fate'}, $tag, $try) = @$fate;
@try = ($try);
}

my @gather = ();
for (;;) {
if (not @try) {
$relex //= $C->cursor_fate('STD', 'unsp_03', $retree);
@try = $relex->($C, $trystate);
}
last unless @try;
$try = shift(@try) // next;

if (ref $try eq 'ARRAY') {
($C->{'_fate'}, $tag, $try) = @$try;	# next candidate fate
}

$C->deb("unsp_03 trying $tag $try") if $::DEBUG & DEBUG::try_processing;
push @gather, ((
sub { my $C=shift;
do {
if (my ($C) = ($C->vws)) {
$C->_REDUCE($S, 'unsp', 'vwhite');
}
else {
();
}
}
},
sub { my $C=shift;
do {
if (my ($C) = ($C->unv)) {
$C->_REDUCE($S, 'unsp', 'unv');
}
else {
();
}
}
},
sub { my $C=shift;
do {
if (my ($C) = ($C->_PATTERN(qr/\G\z/))) {
scalar(do {
$C->moreinput 
}, $C);
}
else {
();
}
}
},
)[$try])->($C);
last if @gather;
}
@gather;
};
if (@result) {
@result;
}
elsif ($@) {
my ($first) = $@ =~ /(^.*)/;
$self->deb("CAUGHT $first") if $::DEBUG & DEBUG::trace_call;
die $@ if $@ !~ /^ABORTBRANCH/;
();
}
else {
();
}
}

})
});
}
else {
();
}
};
}
else {
();
}
}
);
}

## token vws
##      token vws {
##          :dba('vertical whitespace')
##          \v
##          [ '#DEBUG -1' { say "DEBUG"; $STD::DEBUG = $*DEBUG = -1; } ]?
##      }

sub vws__PEEK { $_[0]->_AUTOLEXpeek('vws',$retree) }
sub vws {
my $self = shift;
local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;


my $C = $self;
my $S = $C->{'_pos'};

$self->_MATCHIFYr($S, "vws", 
do {
if (my ($C) = ($C->_PATTERN(qr/\G[\n]/))) {
$C->_OPTr(sub { my $C=shift;
$C->_BRACKETr( sub { my $C=shift;
do {
if (my ($C) = ($C->_EXACT('#DEBUG -1'))) {
scalar(do {
say "DEBUG"; $STD::DEBUG = $::DEBUG = -1; 
}, $C);
}
else {
();
}
}
})
});
}
else {
();
}
}
);
}

# We provide two mechanisms here:
# 1) define $*moreinput, or
# 2) override moreinput method
## method moreinput ()
sub moreinput {
my $self = shift;


$::moreinput->() if $::moreinput;
}

## token unv
##      token unv {
##         :dba('horizontal whitespace')
##         [
##         | \h+                 {*}                                    #= hwhite
##         | <?before '='> ^^ <.pod_comment>  {*}                    #= pod
##         | \h* '#' [
##               |  <?opener>
##                  [ <!after ^^ . > || <.panic: "Can't use embedded comments in column 1"> ]
##                  <.quibble($¢.cursor_fresh( %*LANG<Q> ))>   {*}                               #= embedded
##               | {} \N*            {*}                                 #= end
##               ]
##          ]
##      }

sub unv__PEEK { $_[0]->_AUTOLEXpeek('unv',$retree) }
sub unv {
my $self = shift;
local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;


my $C = $self;
my $S = $C->{'_pos'};

$self->_MATCHIFYr($S, "unv", 
$C->_BRACKETr( sub { my $C=shift;
do {
my @result = eval {
my $trystate;
my ($tag, $try);
my @try;
my $relex;

my $fate;
if ($fate = $C->{'_fate'} and $fate->[1] eq 'unv_01') {
$C->deb("Fate passed to unv_01: ", ::fatestr($fate)) if $::DEBUG & DEBUG::fates;
($C->{'_fate'}, $tag, $try) = @$fate;
@try = ($try);
}

my @gather = ();
for (;;) {
if (not @try) {
$relex //= $C->cursor_fate('STD', 'unv_01', $retree);
@try = $relex->($C, $trystate);
}
last unless @try;
$try = shift(@try) // next;

if (ref $try eq 'ARRAY') {
($C->{'_fate'}, $tag, $try) = @$try;	# next candidate fate
}

$C->deb("unv_01 trying $tag $try") if $::DEBUG & DEBUG::try_processing;
push @gather, ((
sub { my $C=shift;
do {
if (my ($C) = ($C->_PATTERN(qr/\G((?:[\x20\t\r])++)/))) {
$C->_REDUCE($S, 'unv', 'hwhite');
}
else {
();
}
}
},
sub { my $C=shift;
do {
if (my ($C) = ($C->before(sub { my $C=shift;
$C->_EXACT('=')
}))) {
do {
if (my ($C) = ($C->_PATTERN(qr/\G(?m:^)/))) {
do {
if (my ($C) = ($C->pod_comment)) {
$C->_REDUCE($S, 'unv', 'pod');
}
else {
();
}
};
}
else {
();
}
};
}
else {
();
}
}
},
sub { my $C=shift;
do {
if (my ($C) = ($C->_PATTERN(qr/\G((?:[\x20\t\r])*+)/))) {
do {
if (my ($C) = ($C->_EXACT('#'))) {
$C->_BRACKETr( sub { my $C=shift;
do {
my @result = eval {
my $trystate;
my ($tag, $try);
my @try;
my $relex;

my $fate;
if ($fate = $C->{'_fate'} and $fate->[1] eq 'unv_03') {
$C->deb("Fate passed to unv_03: ", ::fatestr($fate)) if $::DEBUG & DEBUG::fates;
($C->{'_fate'}, $tag, $try) = @$fate;
@try = ($try);
}

my @gather = ();
for (;;) {
if (not @try) {
$relex //= $C->cursor_fate('STD', 'unv_03', $retree);
@try = $relex->($C, $trystate);
}
last unless @try;
$try = shift(@try) // next;

if (ref $try eq 'ARRAY') {
($C->{'_fate'}, $tag, $try) = @$try;	# next candidate fate
}

$C->deb("unv_03 trying $tag $try") if $::DEBUG & DEBUG::try_processing;
push @gather, ((
sub { my $C=shift;
do {
if (my ($C) = ($C->before( sub { my $C=shift;
$C->opener
}))) {
do {
if (my ($C) = ($C->_BRACKETr( sub { my $C=shift;
do { my @gather;
eval { push @gather, $C->_NOTBEFORE( sub { my $C=shift;
$C->after(sub { my $C=shift;
$C->_PATTERN(qr/\G(?<=(?s:.))(?m:^)/)
})
})} // do {die $@ if $@ and $@ !~ /ABORT/;1} 
or
eval { push @gather, $C->panic("Can't use embedded comments in column 1")} or do { die $@ if $@ };
@gather;
}
}))) {
do {
if (my ($C) = ($C->quibble($C->cursor_fresh( $::LANG{'Q'} )))) {
$C->_REDUCE($S, 'unv', 'embedded');
}
else {
();
}
};
}
else {
();
}
};
}
else {
();
}
}
},
sub { my $C=shift;
do {
if (my ($C) = (scalar(do {

}, $C))) {
do {
if (my ($C) = ($C->_STARr(sub { my $C=shift;
$C->_NOTCHAR( sub { my $C=shift;
$C->_EXACT("\n")
})
}))) {
$C->_REDUCE($S, 'unv', 'end');
}
else {
();
}
};
}
else {
();
}
}
},
)[$try])->($C);
last if @gather;
}
@gather;
};
if (@result) {
@result;
}
elsif ($@) {
my ($first) = $@ =~ /(^.*)/;
$self->deb("CAUGHT $first") if $::DEBUG & DEBUG::trace_call;
die $@ if $@ !~ /^ABORTBRANCH/;
();
}
else {
();
}
}

});
}
else {
();
}
};
}
else {
();
}
}
},
)[$try])->($C);
last if @gather;
}
@gather;
};
if (@result) {
@result;
}
elsif ($@) {
my ($first) = $@ =~ /(^.*)/;
$self->deb("CAUGHT $first") if $::DEBUG & DEBUG::trace_call;
die $@ if $@ !~ /^ABORTBRANCH/;
();
}
else {
();
}
}

})
);
}

## token ident
##      token ident {
##          <.alpha> \w*
##      }

sub ident__PEEK { $_[0]->_AUTOLEXpeek('ident',$retree) }
sub ident {
my $self = shift;
local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;


my $C = $self;
my $S = $C->{'_pos'};

$self->_MATCHIFYr($S, "ident", 
$C->_PATTERN(qr/\G[_[:alpha:]]((?:\w)*+)/)
);
}

## token apostrophe
##      token apostrophe {
##          <[ ' \- ]>
##      }

sub apostrophe__PEEK { $_[0]->_AUTOLEXpeek('apostrophe',$retree) }
sub apostrophe {
my $self = shift;
local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;


my $C = $self;
my $S = $C->{'_pos'};

$self->_MATCHIFYr($S, "apostrophe", 
$C->_PATTERN(qr/\G['\-]/)
);
}

## token identifier
##      token identifier {
##          <.ident> [ <.apostrophe> <.ident> ]*
##      }

sub identifier__PEEK { $_[0]->_AUTOLEXpeek('identifier',$retree) }
sub identifier {
my $self = shift;
local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;


my $C = $self;
my $S = $C->{'_pos'};

$self->_MATCHIFYr($S, "identifier", 
do {
if (my ($C) = ($C->ident)) {
$C->_STARr(sub { my $C=shift;
$C->_BRACKETr( sub { my $C=shift;
do {
if (my ($C) = ($C->apostrophe)) {
$C->ident;
}
else {
();
}
}
})
});
}
else {
();
}
}
);
}

# XXX We need to parse the pod eventually to support $= variables.

## token pod_comment
##      token pod_comment {
##          ^^ '=' <.unsp>?
##          [
##          | 'begin' \h+ <identifier> ::
##              [
##              ||  .*? "\n=" <.unsp>? 'end' \h+ $<identifier> » \N*          {*} #= tagged
##              ||  <?{ $<identifier>.Str eq 'END'}> .*                           {*} #= end
##              || { my $id = $<identifier>.Str; self.panic("=begin $id without matching =end $id"); }
##              ]
##          | 'begin' » :: \h* [ $$ || '#' || <.panic: "Unrecognized token after =begin"> ]
##              [ .*?  "\n=" <.unsp>? 'end' » \N* || { self.panic("=begin without matching =end"); } ]   {*}       #= anon
##              
##          | 'for' » :: \h* [ <identifier> || $$ || '#' || <.panic: "Unrecognized token after =for"> ]
##              [.*?  ^^ \h* $$ || .*]
##          | :: 
##              [ <?before .*? ^^ '=cut' » > <.panic: "Obsolete pod format, please use =begin/=end instead"> ]?
##              [<alpha>||\s||<.panic: "Illegal pod directive">]
##              \N*                                           {*}       #= misc
##          ]
##      }

sub pod_comment__PEEK { $_[0]->_AUTOLEXpeek('pod_comment',$retree) }
sub pod_comment {
my $self = shift;
local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;


my $C = $self;
my $S = $C->{'_pos'};

$self->_MATCHIFY($S, "pod_comment", 
Cursor::lazymap(sub { my $C=$_[0];
Cursor::lazymap(sub { my $C=$_[0];
Cursor::lazymap(sub { my $C=$_[0];
$C->_BRACKET( sub { my $C=shift;
do {
my @result = eval {
my $trystate;
my ($tag, $try);
my @try;
my $relex;

my $fate;
if ($fate = $C->{'_fate'} and $fate->[1] eq 'pod_comment_01') {
$C->deb("Fate passed to pod_comment_01: ", ::fatestr($fate)) if $::DEBUG & DEBUG::fates;
($C->{'_fate'}, $tag, $try) = @$fate;
@try = ($try);
}

my @gather = ();
for (;;) {
if (not @try) {
$relex //= $C->cursor_fate('STD', 'pod_comment_01', $retree);
@try = $relex->($C, $trystate);
}
last unless @try;
$try = shift(@try) // next;

if (ref $try eq 'ARRAY') {
($C->{'_fate'}, $tag, $try) = @$try;	# next candidate fate
}

$C->deb("pod_comment_01 trying $tag $try") if $::DEBUG & DEBUG::try_processing;
push @gather, ((
sub { my $C=shift;
Cursor::lazymap(sub { my $C=$_[0];
Cursor::lazymap(sub { my $C=$_[0];
Cursor::lazymap(sub { my $C=$_[0];
Cursor::lazymap(sub { my $C=$_[0];
$C->_BRACKET( sub { my $C=shift;
do { my @gather;
eval { push @gather, Cursor::lazymap(sub { my $C=$_[0];
Cursor::lazymap(sub { my $C=$_[0];
Cursor::lazymap(sub { my $C=$_[0];
Cursor::lazymap(sub { my $C=$_[0];
Cursor::lazymap(sub { my $C=$_[0];
Cursor::lazymap(sub { my $C=$_[0];
Cursor::lazymap(sub { my $C=$_[0];
Cursor::lazymap(sub { my $C=$_[0];
$C->_REDUCE($S, 'pod_comment', 'tagged')
}, $C->_STARr(sub { my $C=shift;
$C->_NOTCHAR( sub { my $C=shift;
$C->_EXACT("\n")
})
}))
}, $C->_PATTERN(qr/\G\b/))
}, $C->_BACKREFn('identifier'))
}, $C->_PATTERN(qr/\G((?:[\x20\t\r])++)/))
}, $C->_EXACT('end'))
}, $C->_OPTr(sub { my $C=shift;
$C->unsp
}))
}, $C->_PATTERN(qr/\G\n=/))
}, $C->_SCANf())} // do {die $@ if $@ and $@ !~ /ABORT/;1} 
or
eval { push @gather, Cursor::lazymap(sub { my $C=$_[0];
Cursor::lazymap(sub { my $C=$_[0];
$C->_REDUCE($S, 'pod_comment', 'end')
}, $C->_SCANg())
}, $C->before( sub { my $C=shift;
(($C) x !!do {
my $M = $C;  $M->{'identifier'}->Str eq 'END';
})
}))} // do {die $@ if $@ and $@ !~ /ABORT/;1} 
or
eval { push @gather, scalar(do {
my $M = $C;  my $id = $M->{'identifier'}->Str; $self->panic("=begin $id without matching =end $id"); ;
}, $C)} or do { die $@ if $@ };
@gather;
}
})
}, $C->_COMMITBRANCH())
}, $C->_SUBSUMEr(['identifier'], sub {
my $C = shift;
$C->identifier
}))
}, $C->_PATTERN(qr/\G((?:[\x20\t\r])++)/))
}, $C->_EXACT('begin'))
},
sub { my $C=shift;
Cursor::lazymap(sub { my $C=$_[0];
Cursor::lazymap(sub { my $C=$_[0];
Cursor::lazymap(sub { my $C=$_[0];
Cursor::lazymap(sub { my $C=$_[0];
Cursor::lazymap(sub { my $C=$_[0];
Cursor::lazymap(sub { my $C=$_[0];
$C->_REDUCE($S, 'pod_comment', 'anon')
}, $C->_BRACKET( sub { my $C=shift;
do { my @gather;
eval { push @gather, Cursor::lazymap(sub { my $C=$_[0];
Cursor::lazymap(sub { my $C=$_[0];
Cursor::lazymap(sub { my $C=$_[0];
Cursor::lazymap(sub { my $C=$_[0];
Cursor::lazymap(sub { my $C=$_[0];
$C->_STARr(sub { my $C=shift;
$C->_NOTCHAR( sub { my $C=shift;
$C->_EXACT("\n")
})
})
}, $C->_PATTERN(qr/\G\b/))
}, $C->_EXACT('end'))
}, $C->_OPTr(sub { my $C=shift;
$C->unsp
}))
}, $C->_PATTERN(qr/\G\n=/))
}, $C->_SCANf())} // do {die $@ if $@ and $@ !~ /ABORT/;1} 
or
eval { push @gather, scalar(do {
$self->panic("=begin without matching =end"); 
}, $C)} or do { die $@ if $@ };
@gather;
}
}))
}, $C->_BRACKET( sub { my $C=shift;
do { my @gather;
eval { push @gather, $C->_PATTERN(qr/\G(?m:$)/)} // do {die $@ if $@ and $@ !~ /ABORT/;1} 
or
eval { push @gather, $C->_EXACT('#')} // do {die $@ if $@ and $@ !~ /ABORT/;1} 
or
eval { push @gather, $C->panic("Unrecognized token after =begin")} or do { die $@ if $@ };
@gather;
}
}))
}, $C->_PATTERN(qr/\G((?:[\x20\t\r])*+)/))
}, $C->_COMMITBRANCH())
}, $C->_PATTERN(qr/\G\b/))
}, $C->_EXACT('begin'))
},
sub { my $C=shift;
Cursor::lazymap(sub { my $C=$_[0];
Cursor::lazymap(sub { my $C=$_[0];
Cursor::lazymap(sub { my $C=$_[0];
Cursor::lazymap(sub { my $C=$_[0];
Cursor::lazymap(sub { my $C=$_[0];
$C->_BRACKET( sub { my $C=shift;
do { my @gather;
eval { push @gather, Cursor::lazymap(sub { my $C=$_[0];
Cursor::lazymap(sub { my $C=$_[0];
Cursor::lazymap(sub { my $C=$_[0];
$C->_PATTERN(qr/\G(?m:$)/)
}, $C->_PATTERN(qr/\G((?:[\x20\t\r])*+)/))
}, $C->_PATTERN(qr/\G(?m:^)/))
}, $C->_SCANf())} // do {die $@ if $@ and $@ !~ /ABORT/;1} 
or
eval { push @gather, $C->_SCANg()} or do { die $@ if $@ };
@gather;
}
})
}, $C->_BRACKET( sub { my $C=shift;
do { my @gather;
eval { push @gather, $C->_SUBSUME(['identifier'], sub {
my $C = shift;
$C->identifier
})} // do {die $@ if $@ and $@ !~ /ABORT/;1} 
or
eval { push @gather, $C->_PATTERN(qr/\G(?m:$)/)} // do {die $@ if $@ and $@ !~ /ABORT/;1} 
or
eval { push @gather, $C->_EXACT('#')} // do {die $@ if $@ and $@ !~ /ABORT/;1} 
or
eval { push @gather, $C->panic("Unrecognized token after =for")} or do { die $@ if $@ };
@gather;
}
}))
}, $C->_PATTERN(qr/\G((?:[\x20\t\r])*+)/))
}, $C->_COMMITBRANCH())
}, $C->_PATTERN(qr/\G\b/))
}, $C->_EXACT('for'))
},
sub { my $C=shift;
Cursor::lazymap(sub { my $C=$_[0];
Cursor::lazymap(sub { my $C=$_[0];
Cursor::lazymap(sub { my $C=$_[0];
Cursor::lazymap(sub { my $C=$_[0];
$C->_REDUCE($S, 'pod_comment', 'misc')
}, $C->_STARr(sub { my $C=shift;
$C->_NOTCHAR( sub { my $C=shift;
$C->_EXACT("\n")
})
}))
}, $C->_BRACKET( sub { my $C=shift;
do { my @gather;
eval { push @gather, $C->_PATTERN(qr/\G[_[:alpha:]]/)} // do {die $@ if $@ and $@ !~ /ABORT/;1} 
or
eval { push @gather, $C->_PATTERN(qr/\G\s/)} // do {die $@ if $@ and $@ !~ /ABORT/;1} 
or
eval { push @gather, $C->panic("Illegal pod directive")} or do { die $@ if $@ };
@gather;
}
}))
}, $C->_OPTr(sub { my $C=shift;
$C->_BRACKET( sub { my $C=shift;
Cursor::lazymap(sub { my $C=$_[0];
$C->panic("Obsolete pod format, please use =begin/=end instead")
}, $C->before(sub { my $C=shift;
Cursor::lazymap(sub { my $C=$_[0];
Cursor::lazymap(sub { my $C=$_[0];
Cursor::lazymap(sub { my $C=$_[0];
$C->_PATTERN(qr/\G\b/)
}, $C->_EXACT('=cut'))
}, $C->_PATTERN(qr/\G(?m:^)/))
}, $C->_SCANf())
}))
})
}))
}, $C->_COMMITBRANCH())
},
)[$try])->($C);
last if @gather;
}
@gather;
};
if (@result) {
@result;
}
elsif ($@) {
my ($first) = $@ =~ /(^.*)/;
$self->deb("CAUGHT $first") if $::DEBUG & DEBUG::trace_call;
die $@ if $@ !~ /^ABORTBRANCH/;
();
}
else {
();
}
}

})
}, $C->_OPTr(sub { my $C=shift;
$C->unsp
}))
}, $C->_EXACT('='))
}, $C->_PATTERN(qr/\G(?m:^)/))
);
}

###################
# Top-level rules #
###################

# Note: we only check for the stopper.  We don't check for ^ because
# we might be embedded in something else.
## rule comp_unit
##      rule comp_unit {
##          :my $begin_compunit is context = 1;
##          :my $endargs        is context<rw> = -1;
##          :my %LANG is context;
##          :my $PKGDECL is context = "";
##          :my $PKGNAME is context = "GLOBAL";
##          :my @PKGS is context<rw> = ();
##          :my $IN_DECL is context<rw>;
##          :my $DECLARAND is context<rw>;
##          :my $QSIGIL is context<rw> = '';
##          :my $IN_META is context<rw> = 0;
##          :my $QUASIMODO is context<rw>;
##          :my $SCOPE is context = "";
##          :my $LEFTSIGIL is context<rw>;
##          :my %MYSTERY is context<rw> = ();
##          :my $INVOCANT_OK is context<rw>;
##          :my $INVOCANT_IS is context<rw>;
##          :my $CURPAD is context<rw>;
##          :my $MULTINESS is context = '';
##      
##          :my $CURPKG is context;
##          {{
##      
##              %*LANG<MAIN>    = ::STD ;
##              %*LANG<Q>       = ::STD::Q ;
##              %*LANG<Quasi>   = ::STD::Quasi ;
##              %*LANG<Regex>   = ::STD::Regex ;
##              %*LANG<Trans>   = ::STD::Trans ;
##              %*LANG<P5Regex> = ::STD::P5Regex ;
##      
##              @*WORRIES = ();
##              self.load_setting($*SETTINGNAME);
##              self.newpad;
##              $*UNIT = $*CURPAD;
##              self.finishpad(1);
##          }}
##          <statementlist>
##          [ <?unitstopper> || <.panic: "Confused"> ]
##      #    { $<CORE> = $*CORE; }
##          # "CHECK" time...
##          {{
##              if @*WORRIES {
##                  warn "Potential difficulties:\n  " ~ join( "\n  ", @*WORRIES) ~ "\n";
##              }
##              my $m = $¢.explain_mystery();
##              warn $m if $m;
##          }}
##      }

sub comp_unit__PEEK { $_[0]->_AUTOLEXpeek('comp_unit',$retree) }
sub comp_unit {
my $self = shift;
local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;
local $::begin_compunit = 1;
local $::endargs = -1;
local %::LANG;
local $::PKGDECL = "";
local $::PKGNAME = "GLOBAL";
local @::PKGS = ();
local $::IN_DECL;
local $::DECLARAND;
local $::QSIGIL = '';
local $::IN_META = 0;
local $::QUASIMODO;
local $::SCOPE = "";
local $::LEFTSIGIL;
local %::MYSTERY = ();
local $::INVOCANT_OK;
local $::INVOCANT_IS;
local $::CURPAD;
local $::MULTINESS = '';
local $::CURPKG;


my $C = $self;
my $S = $C->{'_pos'};

$self->_MATCHIFYr($S, "comp_unit", 
do {
if (my ($C) = ($C->ws)) {
do {
if (my ($C) = (scalar(do {


$::LANG{'MAIN'}    = 'STD' ;
$::LANG{'Q'}       = 'STD::Q' ;
$::LANG{'Quasi'}   = 'STD::Quasi' ;
$::LANG{'Regex'}   = 'STD::Regex' ;
$::LANG{'Trans'}   = 'STD::Trans' ;
$::LANG{'P5Regex'} = 'STD::P5Regex' ;

@::WORRIES = ();
$self->load_setting($::SETTINGNAME);
$self->newpad;
$::UNIT = $::CURPAD;
$self->finishpad(1);

}, $C))) {
do {
if (my ($C) = ($C->ws)) {
do {
if (my ($C) = ($C->_SUBSUMEr(['statementlist'], sub {
my $C = shift;
$C->statementlist
}))) {
do {
if (my ($C) = ($C->ws)) {
do {
if (my ($C) = ($C->_BRACKETr( sub { my $C=shift;
do { my @gather;
eval { push @gather, do {
if (my ($C) = ($C->before( sub { my $C=shift;
$C->unitstopper
}))) {
$C->ws;
}
else {
();
}
}} // do {die $@ if $@ and $@ !~ /ABORT/;1} 
or
eval { push @gather, do {
if (my ($C) = ($C->panic("Confused"))) {
$C->ws;
}
else {
();
}
}} or do { die $@ if $@ };
@gather;
}
}))) {
do {
if (my ($C) = ($C->ws)) {
do {
if (my ($C) = (scalar(do {

if (@::WORRIES) {
warn "Potential difficulties:\n  " . join( "\n  ", @::WORRIES) . "\n";
}
my $m = $C->explain_mystery();
warn $m if $m;

}, $C))) {
$C->ws;
}
else {
();
}
};
}
else {
();
}
};
}
else {
();
}
};
}
else {
();
}
};
}
else {
();
}
};
}
else {
();
}
};
}
else {
();
}
};
}
else {
();
}
}
);
}

## method explain_mystery()
sub explain_mystery {
my $self = shift;


my %post_types;
my %unk_types;
my %unk_routines;
my $m = '';
for (keys(%::MYSTERY)) {
my $p = $::MYSTERY{$_}->{'pad'};
if ($self->is_name($_, $p)) {
# types may not be post-declared
$post_types{$_} = $::MYSTERY{$_};
next;
}

next if $self->is_known($_, $p) or $self->is_known('&' . $_, $p);

# just a guess, but good enough to improve error reporting
if ($_ lt 'a') {
$unk_types{$_} = $::MYSTERY{$_};
}
else {
$unk_routines{$_} = $::MYSTERY{$_};
}
}
if (%post_types) {
my @tmp = sort keys(%post_types);
$m .= "Illegally post-declared type" . ('s' x (@tmp != 1)) . ":\n";
for (@tmp) {
$m .= "\t$_ used at " . $post_types{$_}->{'line'} . "\n";
}
}
if (%unk_types) {
my @tmp = sort keys(%unk_types);
$m .= "Undeclared name" . ('s' x (@tmp != 1)) . ":\n";
for (@tmp) {
$m .= "\t$_ used at " . $unk_types{$_}->{'line'} . "\n";
}
}
if (%unk_routines) {
my @tmp = sort keys(%unk_routines);
$m .= "Undeclared routine" . ('s' x (@tmp != 1)) . ":\n";
for (@tmp) {
$m .= "\t$_ used at " . $unk_routines{$_}->{'line'} . "\n";
}
}
$m;
}

# Note: because of the possibility of placeholders we can't determine arity of
# the block syntactically, so this must be determined via semantic analysis.
# Also, pblocks used in an if/unless statement do not treat $_ as a placeholder,
# while most other blocks treat $_ as equivalent to $^x.  Therefore the first
# possible place to check arity is not here but in the rule that calls this
# rule.  (Could also be done in a later pass.)

## token pblock ($CURPAD is context<rw> = $*CURPAD)
##      token pblock ($CURPAD is context<rw> = $*CURPAD) {
##          :dba('parameterized block')
##          [<?before <.lambda> | '{' > ||
##              {{
##                  if $*BORG and $*BORG.<block> {
##                      if $*BORG.<name> {
##                          my $m = "Function '" ~ $BORG.<name> ~ "' needs parens to avoid gobbling block" ~ $*BORG.<culprit>.locmess;
##                          $*BORG.<block>.panic($m ~ "\nMissing block (apparently gobbled by '" ~ $BORG.<name> ~ "')");
##                      }
##                      else {
##                          my $m = "Expression needs parens to avoid gobbling block" ~ $*BORG.<culprit>.locmess;
##                          $*BORG.<block>.panic($m ~ "\nMissing block (apparently gobbled by expression)");
##                      }
##                  }
##                  elsif %*MYSTERY {
##                      $¢.panic("Missing block (apparently gobbled by undeclared routine?)");
##                  }
##                  else {
##                      $¢.panic("Missing block");
##                  }
##              }}
##          ]
##          [
##          | <lambda>
##              <.newpad>
##              <signature>
##              <blockoid>
##          | <?before '{'>
##              <.newpad>
##              <blockoid>
##          ]
##      }

sub pblock__PEEK { $_[0]->_AUTOLEXpeek('pblock',$retree) }
sub pblock {
my $self = shift;
local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;
local $CURPAD = shift() // $::CURPAD;


my $C = $self;
my $S = $C->{'_pos'};

$self->_MATCHIFYr($S, "pblock", 
do {
if (my ($C) = ($C->_BRACKETr( sub { my $C=shift;
do { my @gather;
eval { push @gather, $C->before(sub { my $C=shift;
do {
my @result = eval {
my $trystate;
my ($tag, $try);
my @try;
my $relex;

my $fate;
if ($fate = $C->{'_fate'} and $fate->[1] eq 'pblock_02') {
$C->deb("Fate passed to pblock_02: ", ::fatestr($fate)) if $::DEBUG & DEBUG::fates;
($C->{'_fate'}, $tag, $try) = @$fate;
@try = ($try);
}

my @gather = ();
for (;;) {
if (not @try) {
$relex //= $C->cursor_fate('STD', 'pblock_02', $retree);
@try = $relex->($C, $trystate);
}
last unless @try;
$try = shift(@try) // next;

if (ref $try eq 'ARRAY') {
($C->{'_fate'}, $tag, $try) = @$try;	# next candidate fate
}

$C->deb("pblock_02 trying $tag $try") if $::DEBUG & DEBUG::try_processing;
push @gather, ((
sub { my $C=shift;
$C->lambda
},
sub { my $C=shift;
$C->_EXACT('{')
},
)[$try])->($C);
last if @gather;
}
@gather;
};
if (@result) {
@result;
}
elsif ($@) {
my ($first) = $@ =~ /(^.*)/;
$self->deb("CAUGHT $first") if $::DEBUG & DEBUG::trace_call;
die $@ if $@ !~ /^ABORTBRANCH/;
();
}
else {
();
}
}

})} // do {die $@ if $@ and $@ !~ /ABORT/;1} 
or
eval { push @gather, scalar(do {

if ($::BORG and $::BORG->{'block'}) {
if ($::BORG->{'name'}) {
my $m = "Function '" . $BORG->{'name'} . "' needs parens to avoid gobbling block" . $::BORG->{'culprit'}->locmess;
$::BORG->{'block'}->panic($m . "\nMissing block (apparently gobbled by '" . $BORG->{'name'} . "')");
}
else {
my $m = "Expression needs parens to avoid gobbling block" . $::BORG->{'culprit'}->locmess;
$::BORG->{'block'}->panic($m . "\nMissing block (apparently gobbled by expression)");
}
}
elsif (%::MYSTERY) {
$C->panic("Missing block (apparently gobbled by undeclared routine?)");
}
else {
$C->panic("Missing block");
}

}, $C)} or do { die $@ if $@ };
@gather;
}
}))) {
$C->_BRACKETr( sub { my $C=shift;
do {
my @result = eval {
my $trystate;
my ($tag, $try);
my @try;
my $relex;

my $fate;
if ($fate = $C->{'_fate'} and $fate->[1] eq 'pblock_04') {
$C->deb("Fate passed to pblock_04: ", ::fatestr($fate)) if $::DEBUG & DEBUG::fates;
($C->{'_fate'}, $tag, $try) = @$fate;
@try = ($try);
}

my @gather = ();
for (;;) {
if (not @try) {
$relex //= $C->cursor_fate('STD', 'pblock_04', $retree);
@try = $relex->($C, $trystate);
}
last unless @try;
$try = shift(@try) // next;

if (ref $try eq 'ARRAY') {
($C->{'_fate'}, $tag, $try) = @$try;	# next candidate fate
}

$C->deb("pblock_04 trying $tag $try") if $::DEBUG & DEBUG::try_processing;
push @gather, ((
sub { my $C=shift;
do {
if (my ($C) = ($C->_SUBSUMEr(['lambda'], sub {
my $C = shift;
$C->lambda
}))) {
do {
if (my ($C) = ($C->newpad)) {
do {
if (my ($C) = ($C->_SUBSUMEr(['signature'], sub {
my $C = shift;
$C->signature
}))) {
$C->_SUBSUMEr(['blockoid'], sub {
my $C = shift;
$C->blockoid
});
}
else {
();
}
};
}
else {
();
}
};
}
else {
();
}
}
},
sub { my $C=shift;
do {
if (my ($C) = ($C->before(sub { my $C=shift;
$C->_EXACT('{')
}))) {
do {
if (my ($C) = ($C->newpad)) {
$C->_SUBSUMEr(['blockoid'], sub {
my $C = shift;
$C->blockoid
});
}
else {
();
}
};
}
else {
();
}
}
},
)[$try])->($C);
last if @gather;
}
@gather;
};
if (@result) {
@result;
}
elsif ($@) {
my ($first) = $@ =~ /(^.*)/;
$self->deb("CAUGHT $first") if $::DEBUG & DEBUG::trace_call;
die $@ if $@ !~ /^ABORTBRANCH/;
();
}
else {
();
}
}

});
}
else {
();
}
}
);
}

## token lambda
##      token lambda { '->' | '<->' }

sub lambda__PEEK { $_[0]->_AUTOLEXpeek('lambda',$retree) }
sub lambda {
my $self = shift;
local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;


my $C = $self;
my $S = $C->{'_pos'};

$self->_MATCHIFYr($S, "lambda", 
do {
my @result = eval {
my $trystate;
my ($tag, $try);
my @try;
my $relex;

my $fate;
if ($fate = $C->{'_fate'} and $fate->[1] eq 'lambda_00') {
$C->deb("Fate passed to lambda_00: ", ::fatestr($fate)) if $::DEBUG & DEBUG::fates;
($C->{'_fate'}, $tag, $try) = @$fate;
@try = ($try);
}

my @gather = ();
for (;;) {
if (not @try) {
$relex //= $C->cursor_fate('STD', 'lambda_00', $retree);
@try = $relex->($C, $trystate);
}
last unless @try;
$try = shift(@try) // next;

if (ref $try eq 'ARRAY') {
($C->{'_fate'}, $tag, $try) = @$try;	# next candidate fate
}

$C->deb("lambda_00 trying $tag $try") if $::DEBUG & DEBUG::try_processing;
push @gather, ((
sub { my $C=shift;
$C->_EXACT('->')
},
sub { my $C=shift;
$C->_EXACT('<->')
},
)[$try])->($C);
last if @gather;
}
@gather;
};
if (@result) {
@result;
}
elsif ($@) {
my ($first) = $@ =~ /(^.*)/;
$self->deb("CAUGHT $first") if $::DEBUG & DEBUG::trace_call;
die $@ if $@ !~ /^ABORTBRANCH/;
();
}
else {
();
}
}

);
}

# Look for an expression followed by a required lambda.
## token xblock
##      token xblock {
##          :my $GOAL is context = '{';
##          :my $BORG is context = {};
##          <EXPR>
##          { $BORG.<culprit> //= $<EXPR>.cursor(self.pos) }
##          <.ws>
##          <pblock>
##      }

sub xblock__PEEK { $_[0]->_AUTOLEXpeek('xblock',$retree) }
sub xblock {
my $self = shift;
local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;
local $::GOAL = '{';
local $::BORG = {};


my $C = $self;
my $S = $C->{'_pos'};

$self->_MATCHIFYr($S, "xblock", 
do {
if (my ($C) = ($C->_SUBSUMEr(['EXPR'], sub {
my $C = shift;
$C->EXPR
}))) {
do {
if (my ($C) = (scalar(do {
my $M = $C;  $BORG->{'culprit'} //= $M->{'EXPR'}->cursor($self->{'_pos'}) ;
}, $C))) {
do {
if (my ($C) = ($C->ws)) {
$C->_SUBSUMEr(['pblock'], sub {
my $C = shift;
$C->pblock
});
}
else {
();
}
};
}
else {
();
}
};
}
else {
();
}
}
);
}

## token block ($CURPAD is context<rw> = $*CURPAD)
##      token block ($CURPAD is context<rw> = $*CURPAD) {
##          :dba('scoped block')
##          [ <?before '{' > || <.panic: "Missing block"> ]
##          <.newpad>
##          <blockoid>
##      }

sub block__PEEK { $_[0]->_AUTOLEXpeek('block',$retree) }
sub block {
my $self = shift;
local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;
local $CURPAD = shift() // $::CURPAD;


my $C = $self;
my $S = $C->{'_pos'};

$self->_MATCHIFYr($S, "block", 
do {
if (my ($C) = ($C->_BRACKETr( sub { my $C=shift;
do { my @gather;
eval { push @gather, $C->before(sub { my $C=shift;
$C->_EXACT('{')
})} // do {die $@ if $@ and $@ !~ /ABORT/;1} 
or
eval { push @gather, $C->panic("Missing block")} or do { die $@ if $@ };
@gather;
}
}))) {
do {
if (my ($C) = ($C->newpad)) {
$C->_SUBSUMEr(['blockoid'], sub {
my $C = shift;
$C->blockoid
});
}
else {
();
}
};
}
else {
();
}
}
);
}

## token blockoid
##      token blockoid {
##          # temporize braided languages
##          :temp %*LANG;
##      
##          <.finishpad>
##          [
##          | :dba('block') '{' ~ '}' <statementlist>
##          | <?terminator> <.panic: 'Missing block'>
##          | <?> <.panic: "Malformed block">
##          ]
##      
##          [
##          | <?before \h* $$>  # (usual case without comments)
##              { @*MEMOS[$¢.pos]<endstmt> = 2; } {*}                    #= endstmt simple 
##          | \h* <?before <[\\,:]>> {*}                         #= normal 
##          | <.unv>? $$
##              { @*MEMOS[$¢.pos]<endstmt> = 2; } {*}                    #= endstmt complex
##          | {} <.unsp>? { @*MEMOS[$¢.pos]<endargs> = 1; } {*}             #= endargs
##          ]
##      }

sub blockoid__PEEK { $_[0]->_AUTOLEXpeek('blockoid',$retree) }
sub blockoid {
my $self = shift;
local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;
local %::LANG = %::LANG;


my $C = $self;
my $S = $C->{'_pos'};

$self->_MATCHIFY($S, "blockoid", 
Cursor::lazymap(sub { my $C=$_[0];
Cursor::lazymap(sub { my $C=$_[0];
$C->_BRACKET( sub { my $C=shift;
do {
my @result = eval {
my $trystate;
my ($tag, $try);
my @try;
my $relex;

my $fate;
if ($fate = $C->{'_fate'} and $fate->[1] eq 'blockoid_02') {
$C->deb("Fate passed to blockoid_02: ", ::fatestr($fate)) if $::DEBUG & DEBUG::fates;
($C->{'_fate'}, $tag, $try) = @$fate;
@try = ($try);
}

my @gather = ();
for (;;) {
if (not @try) {
$relex //= $C->cursor_fate('STD', 'blockoid_02', $retree);
@try = $relex->($C, $trystate);
}
last unless @try;
$try = shift(@try) // next;

if (ref $try eq 'ARRAY') {
($C->{'_fate'}, $tag, $try) = @$try;	# next candidate fate
}

$C->deb("blockoid_02 trying $tag $try") if $::DEBUG & DEBUG::try_processing;
push @gather, ((
sub { my $C=shift;
Cursor::lazymap(sub { my $C=$_[0];
Cursor::lazymap(sub { my $C=$_[0];
$C->_REDUCE($S, 'blockoid', 'endstmt simple ')
}, scalar(do {
$::MEMOS[$C->{'_pos'}]{'endstmt'} = 2; 
}, $C))
}, $C->before(sub { my $C=shift;
Cursor::lazymap(sub { my $C=$_[0];
$C->_PATTERN(qr/\G(?m:$)/)
}, $C->_PATTERN(qr/\G((?:[\x20\t\r])*+)/))
}))
},
sub { my $C=shift;
Cursor::lazymap(sub { my $C=$_[0];
Cursor::lazymap(sub { my $C=$_[0];
$C->_REDUCE($S, 'blockoid', 'normal ')
}, $C->before(sub { my $C=shift;
$C->_PATTERN(qr/\G[\\,:]/)
}))
}, $C->_PATTERN(qr/\G((?:[\x20\t\r])*+)/))
},
sub { my $C=shift;
Cursor::lazymap(sub { my $C=$_[0];
Cursor::lazymap(sub { my $C=$_[0];
Cursor::lazymap(sub { my $C=$_[0];
$C->_REDUCE($S, 'blockoid', 'endstmt complex')
}, scalar(do {
$::MEMOS[$C->{'_pos'}]{'endstmt'} = 2; 
}, $C))
}, $C->_PATTERN(qr/\G(?m:$)/))
}, $C->_OPTr(sub { my $C=shift;
$C->unv
}))
},
sub { my $C=shift;
Cursor::lazymap(sub { my $C=$_[0];
Cursor::lazymap(sub { my $C=$_[0];
Cursor::lazymap(sub { my $C=$_[0];
$C->_REDUCE($S, 'blockoid', 'endargs')
}, scalar(do {
$::MEMOS[$C->{'_pos'}]{'endargs'} = 1; 
}, $C))
}, $C->_OPTr(sub { my $C=shift;
$C->unsp
}))
}, scalar(do {

}, $C))
},
)[$try])->($C);
last if @gather;
}
@gather;
};
if (@result) {
@result;
}
elsif ($@) {
my ($first) = $@ =~ /(^.*)/;
$self->deb("CAUGHT $first") if $::DEBUG & DEBUG::trace_call;
die $@ if $@ !~ /^ABORTBRANCH/;
();
}
else {
();
}
}

})
}, $C->_BRACKET( sub { my $C=shift;
do {
my @result = eval {
my $trystate;
my ($tag, $try);
my @try;
my $relex;

my $fate;
if ($fate = $C->{'_fate'} and $fate->[1] eq 'blockoid_01') {
$C->deb("Fate passed to blockoid_01: ", ::fatestr($fate)) if $::DEBUG & DEBUG::fates;
($C->{'_fate'}, $tag, $try) = @$fate;
@try = ($try);
}

my @gather = ();
for (;;) {
if (not @try) {
$relex //= $C->cursor_fate('STD', 'blockoid_01', $retree);
@try = $relex->($C, $trystate);
}
last unless @try;
$try = shift(@try) // next;

if (ref $try eq 'ARRAY') {
($C->{'_fate'}, $tag, $try) = @$try;	# next candidate fate
}

$C->deb("blockoid_01 trying $tag $try") if $::DEBUG & DEBUG::try_processing;
push @gather, ((
sub { my $C=shift;
Cursor::lazymap(sub { my $C=$_[0];
Cursor::lazymap(sub { my $C=$_[0];
Cursor::lazymap(sub { my $C=$_[0];
$C->_BRACKET( sub { my $C=shift;
do { my @gather;
eval { push @gather, $C->_EXACT('}')} // do {die $@ if $@ and $@ !~ /ABORT/;1} 
or
eval { push @gather, $C->FAILGOAL('}' , 'block')} or do { die $@ if $@ };
@gather;
}
})
}, $C->_SUBSUME(['statementlist'], sub {
my $C = shift;
$C->statementlist
}))
}, $C->_COMMITBRANCH(local $::GOAL = '}' ))
}, $C->_EXACT('{'))
},
sub { my $C=shift;
Cursor::lazymap(sub { my $C=$_[0];
$C->panic('Missing block')
}, $C->before( sub { my $C=shift;
$C->terminator
}))
},
sub { my $C=shift;
Cursor::lazymap(sub { my $C=$_[0];
$C->panic("Malformed block")
}, $C->before( sub { my $C=shift;
$C
}))
},
)[$try])->($C);
last if @gather;
}
@gather;
};
if (@result) {
@result;
}
elsif ($@) {
my ($first) = $@ =~ /(^.*)/;
$self->deb("CAUGHT $first") if $::DEBUG & DEBUG::trace_call;
die $@ if $@ !~ /^ABORTBRANCH/;
();
}
else {
();
}
}

}))
}, $C->finishpad)
);
}

## token regex_block
##      token regex_block {
##          # temporize braided languages
##          :temp %*LANG;
##      
##          :my $lang = %*LANG<Regex>;
##          :my $GOAL is context = '}';
##      
##          [ <quotepair> <.ws>
##              {
##                  my $kv = $<quotepair>[*-1];
##                  $lang = $lang.tweak($kv.<k>, $kv.<v>)
##                      or self.panic("Unrecognized adverb :" ~ $kv.<k> ~ '(' ~ $kv.<v> ~ ')');
##              }
##          ]*
##      
##          '{'
##          <nibble( $¢.cursor_fresh($lang).unbalanced('}') )>
##          [ '}' || <.panic: "Unable to parse regex; couldn't find right brace"> ]
##      
##          [
##          | <?before \h* $$>  # (usual case without comments)
##              { @*MEMOS[$¢.pos]<endstmt> = 2; } {*}                    #= endstmt simple 
##          | \h* <?before <[\\,:]>> {*}                         #= normal 
##          | <.unv>? $$
##              { @*MEMOS[$¢.pos]<endstmt> = 2; } {*}                    #= endstmt complex
##          | {} <.unsp>? { @*MEMOS[$¢.pos]<endargs> = 1; }   {*}           #= endargs
##          ]
##      }

sub regex_block__PEEK { $_[0]->_AUTOLEXpeek('regex_block',$retree) }
sub regex_block {
my $self = shift;
local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;
local %::LANG = %::LANG;
my $lang = $::LANG{'Regex'};
local $::GOAL = '}';


my $C = $self;
my $S = $C->{'_pos'};
$C->{'quotepair'} = [];

$self->_MATCHIFYr($S, "regex_block", 
do {
if (my ($C) = ($C->_STARr(sub { my $C=shift;
$C->_BRACKETr( sub { my $C=shift;
do {
if (my ($C) = ($C->_SUBSUMEr(['quotepair'], sub {
my $C = shift;
$C->quotepair
}))) {
do {
if (my ($C) = ($C->ws)) {
scalar(do {
my $M = $C; 
my $kv = $M->{'quotepair'}[-1];
$lang = $lang->tweak($kv->{'k'}, $kv->{'v'})
or $self->panic("Unrecognized adverb :" . $kv->{'k'} . '(' . $kv->{'v'} . ')');
;
}, $C);
}
else {
();
}
};
}
else {
();
}
}
})
}))) {
do {
if (my ($C) = ($C->_EXACT('{'))) {
do {
if (my ($C) = ($C->_SUBSUMEr(['nibble'], sub {
my $C = shift;
$C->nibble( $C->cursor_fresh($lang)->unbalanced('}') )
}))) {
do {
if (my ($C) = ($C->_BRACKETr( sub { my $C=shift;
do { my @gather;
eval { push @gather, $C->_EXACT('}')} // do {die $@ if $@ and $@ !~ /ABORT/;1} 
or
eval { push @gather, $C->panic("Unable to parse regex; couldn't find right brace")} or do { die $@ if $@ };
@gather;
}
}))) {
$C->_BRACKETr( sub { my $C=shift;
do {
my @result = eval {
my $trystate;
my ($tag, $try);
my @try;
my $relex;

my $fate;
if ($fate = $C->{'_fate'} and $fate->[1] eq 'regex_block_04') {
$C->deb("Fate passed to regex_block_04: ", ::fatestr($fate)) if $::DEBUG & DEBUG::fates;
($C->{'_fate'}, $tag, $try) = @$fate;
@try = ($try);
}

my @gather = ();
for (;;) {
if (not @try) {
$relex //= $C->cursor_fate('STD', 'regex_block_04', $retree);
@try = $relex->($C, $trystate);
}
last unless @try;
$try = shift(@try) // next;

if (ref $try eq 'ARRAY') {
($C->{'_fate'}, $tag, $try) = @$try;	# next candidate fate
}

$C->deb("regex_block_04 trying $tag $try") if $::DEBUG & DEBUG::try_processing;
push @gather, ((
sub { my $C=shift;
do {
if (my ($C) = ($C->before(sub { my $C=shift;
$C->_PATTERN(qr/\G((?:[\x20\t\r])*+)(?m:$)/)
}))) {
do {
if (my ($C) = (scalar(do {
$::MEMOS[$C->{'_pos'}]{'endstmt'} = 2; 
}, $C))) {
$C->_REDUCE($S, 'regex_block', 'endstmt simple ');
}
else {
();
}
};
}
else {
();
}
}
},
sub { my $C=shift;
do {
if (my ($C) = ($C->_PATTERN(qr/\G((?:[\x20\t\r])*+)/))) {
do {
if (my ($C) = ($C->before(sub { my $C=shift;
$C->_PATTERN(qr/\G[\\,:]/)
}))) {
$C->_REDUCE($S, 'regex_block', 'normal ');
}
else {
();
}
};
}
else {
();
}
}
},
sub { my $C=shift;
do {
if (my ($C) = ($C->_OPTr(sub { my $C=shift;
$C->unv
}))) {
do {
if (my ($C) = ($C->_PATTERN(qr/\G(?m:$)/))) {
do {
if (my ($C) = (scalar(do {
$::MEMOS[$C->{'_pos'}]{'endstmt'} = 2; 
}, $C))) {
$C->_REDUCE($S, 'regex_block', 'endstmt complex');
}
else {
();
}
};
}
else {
();
}
};
}
else {
();
}
}
},
sub { my $C=shift;
do {
if (my ($C) = (scalar(do {

}, $C))) {
do {
if (my ($C) = ($C->_OPTr(sub { my $C=shift;
$C->unsp
}))) {
do {
if (my ($C) = (scalar(do {
$::MEMOS[$C->{'_pos'}]{'endargs'} = 1; 
}, $C))) {
$C->_REDUCE($S, 'regex_block', 'endargs');
}
else {
();
}
};
}
else {
();
}
};
}
else {
();
}
}
},
)[$try])->($C);
last if @gather;
}
@gather;
};
if (@result) {
@result;
}
elsif ($@) {
my ($first) = $@ =~ /(^.*)/;
$self->deb("CAUGHT $first") if $::DEBUG & DEBUG::trace_call;
die $@ if $@ !~ /^ABORTBRANCH/;
();
}
else {
();
}
}

});
}
else {
();
}
};
}
else {
();
}
};
}
else {
();
}
};
}
else {
();
}
}
);
}

# statement semantics
## rule statementlist
##      rule statementlist {
##          :my $INVOCANT_OK is context<rw> = 0;
##          :dba('statement list')
##      
##          [
##          | $
##          | <?before <[\)\]\}]> >
##          | [<statement><eat_terminator> ]*
##          ]
##      }

sub statementlist__PEEK { $_[0]->_AUTOLEXpeek('statementlist',$retree) }
sub statementlist {
my $self = shift;
local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;
local $::INVOCANT_OK = 0;


my $C = $self;
my $S = $C->{'_pos'};
$C->{'statement'} = [];
$C->{'eat_terminator'} = [];

$self->_MATCHIFYr($S, "statementlist", 
do {
if (my ($C) = ($C->ws)) {
do {
if (my ($C) = ($C->ws)) {
do {
if (my ($C) = ($C->_BRACKETr( sub { my $C=shift;
do {
my @result = eval {
my $trystate;
my ($tag, $try);
my @try;
my $relex;

my $fate;
if ($fate = $C->{'_fate'} and $fate->[1] eq 'statementlist_01') {
$C->deb("Fate passed to statementlist_01: ", ::fatestr($fate)) if $::DEBUG & DEBUG::fates;
($C->{'_fate'}, $tag, $try) = @$fate;
@try = ($try);
}

my @gather = ();
for (;;) {
if (not @try) {
$relex //= $C->cursor_fate('STD', 'statementlist_01', $retree);
@try = $relex->($C, $trystate);
}
last unless @try;
$try = shift(@try) // next;

if (ref $try eq 'ARRAY') {
($C->{'_fate'}, $tag, $try) = @$try;	# next candidate fate
}

$C->deb("statementlist_01 trying $tag $try") if $::DEBUG & DEBUG::try_processing;
push @gather, ((
sub { my $C=shift;
do {
if (my ($C) = ($C->_PATTERN(qr/\G\z/))) {
$C->ws;
}
else {
();
}
}
},
sub { my $C=shift;
do {
if (my ($C) = ($C->before(sub { my $C=shift;
do {
if (my ($C) = ($C->_PATTERN(qr/\G[\)\]\}]/))) {
$C->ws;
}
else {
();
}
}
}))) {
$C->ws;
}
else {
();
}
}
},
sub { my $C=shift;
do {
if (my ($C) = ($C->_STARr(sub { my $C=shift;
$C->_BRACKETr( sub { my $C=shift;
do {
if (my ($C) = ($C->_SUBSUMEr(['statement'], sub {
my $C = shift;
$C->statement
}))) {
do {
if (my ($C) = ($C->_SUBSUMEr(['eat_terminator'], sub {
my $C = shift;
$C->eat_terminator
}))) {
$C->ws;
}
else {
();
}
};
}
else {
();
}
}
})
}))) {
$C->ws;
}
else {
();
}
}
},
)[$try])->($C);
last if @gather;
}
@gather;
};
if (@result) {
@result;
}
elsif ($@) {
my ($first) = $@ =~ /(^.*)/;
$self->deb("CAUGHT $first") if $::DEBUG & DEBUG::trace_call;
die $@ if $@ !~ /^ABORTBRANCH/;
();
}
else {
();
}
}

}))) {
$C->ws;
}
else {
();
}
};
}
else {
();
}
};
}
else {
();
}
}
);
}

# embedded semis, context-dependent semantics
## rule semilist
##      rule semilist {
##          :my $INVOCANT_OK is context<rw> = 0;
##          :dba('semicolon list')
##          [
##          | <?before <[\)\]\}]> >
##          | [<statement><eat_terminator> ]*
##          ]
##      }

sub semilist__PEEK { $_[0]->_AUTOLEXpeek('semilist',$retree) }
sub semilist {
my $self = shift;
local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;
local $::INVOCANT_OK = 0;


my $C = $self;
my $S = $C->{'_pos'};
$C->{'statement'} = [];
$C->{'eat_terminator'} = [];

$self->_MATCHIFYr($S, "semilist", 
do {
if (my ($C) = ($C->ws)) {
do {
if (my ($C) = ($C->ws)) {
do {
if (my ($C) = ($C->_BRACKETr( sub { my $C=shift;
do {
my @result = eval {
my $trystate;
my ($tag, $try);
my @try;
my $relex;

my $fate;
if ($fate = $C->{'_fate'} and $fate->[1] eq 'semilist_01') {
$C->deb("Fate passed to semilist_01: ", ::fatestr($fate)) if $::DEBUG & DEBUG::fates;
($C->{'_fate'}, $tag, $try) = @$fate;
@try = ($try);
}

my @gather = ();
for (;;) {
if (not @try) {
$relex //= $C->cursor_fate('STD', 'semilist_01', $retree);
@try = $relex->($C, $trystate);
}
last unless @try;
$try = shift(@try) // next;

if (ref $try eq 'ARRAY') {
($C->{'_fate'}, $tag, $try) = @$try;	# next candidate fate
}

$C->deb("semilist_01 trying $tag $try") if $::DEBUG & DEBUG::try_processing;
push @gather, ((
sub { my $C=shift;
do {
if (my ($C) = ($C->before(sub { my $C=shift;
do {
if (my ($C) = ($C->_PATTERN(qr/\G[\)\]\}]/))) {
$C->ws;
}
else {
();
}
}
}))) {
$C->ws;
}
else {
();
}
}
},
sub { my $C=shift;
do {
if (my ($C) = ($C->_STARr(sub { my $C=shift;
$C->_BRACKETr( sub { my $C=shift;
do {
if (my ($C) = ($C->_SUBSUMEr(['statement'], sub {
my $C = shift;
$C->statement
}))) {
do {
if (my ($C) = ($C->_SUBSUMEr(['eat_terminator'], sub {
my $C = shift;
$C->eat_terminator
}))) {
$C->ws;
}
else {
();
}
};
}
else {
();
}
}
})
}))) {
$C->ws;
}
else {
();
}
}
},
)[$try])->($C);
last if @gather;
}
@gather;
};
if (@result) {
@result;
}
elsif ($@) {
my ($first) = $@ =~ /(^.*)/;
$self->deb("CAUGHT $first") if $::DEBUG & DEBUG::trace_call;
die $@ if $@ !~ /^ABORTBRANCH/;
();
}
else {
();
}
}

}))) {
$C->ws;
}
else {
();
}
};
}
else {
();
}
};
}
else {
();
}
}
);
}


## token label
##      token label {
##          :my $label;
##          <identifier> ':' <?before \s> <.ws>
##      
##          [ <?{ $¢.is_name($label = $<identifier>.Str) }>
##            <.panic("Illegal redeclaration of '$label'")>
##          ]?
##      
##          # add label as a pseudo type
##          {{ $¢.add_my_name($label); }}
##      
##      }

sub label__PEEK { $_[0]->_AUTOLEXpeek('label',$retree) }
sub label {
my $self = shift;
local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;
my $label;


my $C = $self;
my $S = $C->{'_pos'};

$self->_MATCHIFYr($S, "label", 
do {
if (my ($C) = ($C->_SUBSUMEr(['identifier'], sub {
my $C = shift;
$C->identifier
}))) {
do {
if (my ($C) = ($C->_EXACT(':'))) {
do {
if (my ($C) = ($C->before(sub { my $C=shift;
$C->_PATTERN(qr/\G\s/)
}))) {
do {
if (my ($C) = ($C->ws)) {
do {
if (my ($C) = ($C->_OPTr(sub { my $C=shift;
$C->_BRACKETr( sub { my $C=shift;
do {
if (my ($C) = ($C->before( sub { my $C=shift;
(($C) x !!do {
my $M = $C;  $C->is_name($label = $M->{'identifier'}->Str) ;
})
}))) {
$C->panic("Illegal redeclaration of '$label'");
}
else {
();
}
}
})
}))) {
scalar(do {
$C->add_my_name($label); 
}, $C);
}
else {
();
}
};
}
else {
();
}
};
}
else {
();
}
};
}
else {
();
}
};
}
else {
();
}
}
);
}

## token statement
##      token statement {
##          :my $endargs is context = -1;
##          :my $QSIGIL is context<rw> = 0;
##          <!before <[\)\]\}]> >
##      
##          # this could either be a statement that follows a declaration
##          # or a statement that is within the block of a code declaration
##          <!!{ $¢ = %*LANG<MAIN>.bless($¢); }>
##      
##          [
##          | <label> <statement>                        {*}            #= label
##          | <statement_control>                        {*}            #= control
##          | <EXPR> {*}                                                #= expr
##              :dba('statement end')
##              [
##              || <?{ (@*MEMOS[$¢.pos]<endstmt> // 0) == 2 }>   # no mod after end-line curly
##              ||
##                  :dba('statement modifier')
##                  <.ws>
##                  [
##                  | <statement_mod_loop> {*}                              #= mod loop
##                      {{
##                          my $sp = $<EXPR><statement_prefix>;
##                          if $sp and $sp<sym> eq 'do' {
##                             my $s = $<statement_mod_loop>[0]<sym>;
##                             $¢.obs("do...$s" ,"repeat...$s");
##                          }
##                      }}
##                  | <statement_mod_cond> {*}                              #= mod cond
##                      :dba('statement modifier loop')
##                      [
##                      || <?{ (@*MEMOS[$¢.pos]<endstmt> // 0) == 2 }>
##                      || <.ws> <statement_mod_loop>? {*}                  #= mod condloop
##                      ]
##                  ]?
##              ]
##              {*}                                                     #= modexpr
##          | <?before ';'> {*}                                         #= null
##          ]
##      
##          # Is there more on same line after a block?
##          [ <?{ (@*MEMOS[@*MEMOS[$¢.pos]<ws>//$¢.pos]<endargs>//0) == 1 }>
##              \h*
##              <!before ';' | ')' | ']' | '}' >
##              <!infixstopper>
##              <.panic: "Statements must be separated with semicolon">
##          ]?
##      }

sub statement__PEEK { $_[0]->_AUTOLEXpeek('statement',$retree) }
sub statement {
my $self = shift;
local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;
local $::endargs = -1;
local $::QSIGIL = 0;


my $C = $self;
my $S = $C->{'_pos'};
$C->{'statement_mod_loop'} = [];
$C->{'statement_mod_cond'} = [];

$self->_MATCHIFYr($S, "statement", 
do {
if (my ($C) = ($C->_NOTBEFORE( sub { my $C=shift;
$C->before(sub { my $C=shift;
$C->_PATTERN(qr/\G[\)\]\}]/)
})
}))) {
do {
if (my ($C) = ($C->_NOTBEFORE( sub { my $C=shift;
$C->_NOTBEFORE( sub { my $C=shift;
(($C) x !!do {
$C = $::LANG{'MAIN'}->bless($C); 
})
})
}))) {
do {
if (my ($C) = ($C->_BRACKETr( sub { my $C=shift;
do {
my @result = eval {
my $trystate;
my ($tag, $try);
my @try;
my $relex;

my $fate;
if ($fate = $C->{'_fate'} and $fate->[1] eq 'statement_02') {
$C->deb("Fate passed to statement_02: ", ::fatestr($fate)) if $::DEBUG & DEBUG::fates;
($C->{'_fate'}, $tag, $try) = @$fate;
@try = ($try);
}

my @gather = ();
for (;;) {
if (not @try) {
$relex //= $C->cursor_fate('STD', 'statement_02', $retree);
@try = $relex->($C, $trystate);
}
last unless @try;
$try = shift(@try) // next;

if (ref $try eq 'ARRAY') {
($C->{'_fate'}, $tag, $try) = @$try;	# next candidate fate
}

$C->deb("statement_02 trying $tag $try") if $::DEBUG & DEBUG::try_processing;
push @gather, ((
sub { my $C=shift;
do {
if (my ($C) = ($C->_SUBSUMEr(['label'], sub {
my $C = shift;
$C->label
}))) {
do {
if (my ($C) = ($C->_SUBSUMEr(['statement'], sub {
my $C = shift;
$C->statement
}))) {
$C->_REDUCE($S, 'statement', 'label');
}
else {
();
}
};
}
else {
();
}
}
},
sub { my $C=shift;
do {
if (my ($C) = ($C->_SUBSUMEr(['statement_control'], sub {
my $C = shift;
$C->statement_control
}))) {
$C->_REDUCE($S, 'statement', 'control');
}
else {
();
}
}
},
sub { my $C=shift;
do {
if (my ($C) = ($C->_SUBSUMEr(['EXPR'], sub {
my $C = shift;
$C->EXPR
}))) {
do {
if (my ($C) = ($C->_REDUCE($S, 'statement', 'expr'))) {
do {
if (my ($C) = ($C->_BRACKETr( sub { my $C=shift;
do { my @gather;
eval { push @gather, $C->before( sub { my $C=shift;
(($C) x !!do {
($::MEMOS[$C->{'_pos'}]{'endstmt'} // 0) == 2 
})
})} // do {die $@ if $@ and $@ !~ /ABORT/;1} 
or
eval { push @gather, do {
if (my ($C) = ($C->ws)) {
$C->_OPTr(sub { my $C=shift;
$C->_BRACKETr( sub { my $C=shift;
do {
my @result = eval {
my $trystate;
my ($tag, $try);
my @try;
my $relex;

my $fate;
if ($fate = $C->{'_fate'} and $fate->[1] eq 'statement_05') {
$C->deb("Fate passed to statement_05: ", ::fatestr($fate)) if $::DEBUG & DEBUG::fates;
($C->{'_fate'}, $tag, $try) = @$fate;
@try = ($try);
}

my @gather = ();
for (;;) {
if (not @try) {
$relex //= $C->cursor_fate('STD', 'statement_05', $retree);
@try = $relex->($C, $trystate);
}
last unless @try;
$try = shift(@try) // next;

if (ref $try eq 'ARRAY') {
($C->{'_fate'}, $tag, $try) = @$try;	# next candidate fate
}

$C->deb("statement_05 trying $tag $try") if $::DEBUG & DEBUG::try_processing;
push @gather, ((
sub { my $C=shift;
do {
if (my ($C) = ($C->_SUBSUMEr(['statement_mod_loop'], sub {
my $C = shift;
$C->statement_mod_loop
}))) {
do {
if (my ($C) = ($C->_REDUCE($S, 'statement', 'mod loop'))) {
scalar(do {
my $M = $C; 
my $sp = $M->{'EXPR'}{'statement_prefix'};
if ($sp and $sp->{'sym'} eq 'do') {
my $s = $M->{'statement_mod_loop'}[0]{'sym'};
$C->obs("do...$s" ,"repeat...$s");
}
;
}, $C);
}
else {
();
}
};
}
else {
();
}
}
},
sub { my $C=shift;
do {
if (my ($C) = ($C->_SUBSUMEr(['statement_mod_cond'], sub {
my $C = shift;
$C->statement_mod_cond
}))) {
do {
if (my ($C) = ($C->_REDUCE($S, 'statement', 'mod cond'))) {
$C->_BRACKETr( sub { my $C=shift;
do { my @gather;
eval { push @gather, $C->before( sub { my $C=shift;
(($C) x !!do {
($::MEMOS[$C->{'_pos'}]{'endstmt'} // 0) == 2 
})
})} // do {die $@ if $@ and $@ !~ /ABORT/;1} 
or
eval { push @gather, do {
if (my ($C) = ($C->ws)) {
do {
if (my ($C) = ($C->_OPTr(sub { my $C=shift;
$C->_SUBSUMEr(['statement_mod_loop'], sub {
my $C = shift;
$C->statement_mod_loop
})
}))) {
$C->_REDUCE($S, 'statement', 'mod condloop');
}
else {
();
}
};
}
else {
();
}
}} or do { die $@ if $@ };
@gather;
}
});
}
else {
();
}
};
}
else {
();
}
}
},
)[$try])->($C);
last if @gather;
}
@gather;
};
if (@result) {
@result;
}
elsif ($@) {
my ($first) = $@ =~ /(^.*)/;
$self->deb("CAUGHT $first") if $::DEBUG & DEBUG::trace_call;
die $@ if $@ !~ /^ABORTBRANCH/;
();
}
else {
();
}
}

})
});
}
else {
();
}
}} or do { die $@ if $@ };
@gather;
}
}))) {
$C->_REDUCE($S, 'statement', 'modexpr');
}
else {
();
}
};
}
else {
();
}
};
}
else {
();
}
}
},
sub { my $C=shift;
do {
if (my ($C) = ($C->before(sub { my $C=shift;
$C->_EXACT(';')
}))) {
$C->_REDUCE($S, 'statement', 'null');
}
else {
();
}
}
},
)[$try])->($C);
last if @gather;
}
@gather;
};
if (@result) {
@result;
}
elsif ($@) {
my ($first) = $@ =~ /(^.*)/;
$self->deb("CAUGHT $first") if $::DEBUG & DEBUG::trace_call;
die $@ if $@ !~ /^ABORTBRANCH/;
();
}
else {
();
}
}

}))) {
$C->_OPTr(sub { my $C=shift;
$C->_BRACKETr( sub { my $C=shift;
do {
if (my ($C) = ($C->before( sub { my $C=shift;
(($C) x !!do {
($::MEMOS[$::MEMOS[$C->{'_pos'}]{'ws'}//$C->{'_pos'}]{'endargs'}//0) == 1 
})
}))) {
do {
if (my ($C) = ($C->_PATTERN(qr/\G((?:[\x20\t\r])*+)/))) {
do {
if (my ($C) = ($C->_NOTBEFORE( sub { my $C=shift;
$C->before(sub { my $C=shift;
do {
my @result = eval {
my $trystate;
my ($tag, $try);
my @try;
my $relex;

my $fate;
if ($fate = $C->{'_fate'} and $fate->[1] eq 'statement_10') {
$C->deb("Fate passed to statement_10: ", ::fatestr($fate)) if $::DEBUG & DEBUG::fates;
($C->{'_fate'}, $tag, $try) = @$fate;
@try = ($try);
}

my @gather = ();
for (;;) {
if (not @try) {
$relex //= $C->cursor_fate('STD', 'statement_10', $retree);
@try = $relex->($C, $trystate);
}
last unless @try;
$try = shift(@try) // next;

if (ref $try eq 'ARRAY') {
($C->{'_fate'}, $tag, $try) = @$try;	# next candidate fate
}

$C->deb("statement_10 trying $tag $try") if $::DEBUG & DEBUG::try_processing;
push @gather, ((
sub { my $C=shift;
$C->_EXACT(';')
},
sub { my $C=shift;
$C->_EXACT(')')
},
sub { my $C=shift;
$C->_EXACT(']')
},
sub { my $C=shift;
$C->_EXACT('}')
},
)[$try])->($C);
last if @gather;
}
@gather;
};
if (@result) {
@result;
}
elsif ($@) {
my ($first) = $@ =~ /(^.*)/;
$self->deb("CAUGHT $first") if $::DEBUG & DEBUG::trace_call;
die $@ if $@ !~ /^ABORTBRANCH/;
();
}
else {
();
}
}

})
}))) {
do {
if (my ($C) = ($C->_NOTBEFORE( sub { my $C=shift;
$C->infixstopper
}))) {
$C->panic("Statements must be separated with semicolon");
}
else {
();
}
};
}
else {
();
}
};
}
else {
();
}
};
}
else {
();
}
}
})
});
}
else {
();
}
};
}
else {
();
}
};
}
else {
();
}
}
);
}

## token eat_terminator
##      token eat_terminator {
##          [
##          || ';'
##          || <?{ @*MEMOS[$¢.pos]<endstmt> }> <.ws>
##          || <?terminator>
##          || $
##          || {{ if @*MEMOS[$¢.pos]<ws> { $¢.pos = @*MEMOS[$¢.pos]<ws>; } }}   # undo any line transition
##              <.panic: "Confused">
##          ]
##      }

sub eat_terminator__PEEK { $_[0]->_AUTOLEXpeek('eat_terminator',$retree) }
sub eat_terminator {
my $self = shift;
local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;


my $C = $self;
my $S = $C->{'_pos'};

$self->_MATCHIFYr($S, "eat_terminator", 
$C->_BRACKETr( sub { my $C=shift;
do { my @gather;
eval { push @gather, $C->_EXACT(';')} // do {die $@ if $@ and $@ !~ /ABORT/;1} 
or
eval { push @gather, do {
if (my ($C) = ($C->before( sub { my $C=shift;
(($C) x !!do {
$::MEMOS[$C->{'_pos'}]{'endstmt'} 
})
}))) {
$C->ws;
}
else {
();
}
}} // do {die $@ if $@ and $@ !~ /ABORT/;1} 
or
eval { push @gather, $C->before( sub { my $C=shift;
$C->terminator
})} // do {die $@ if $@ and $@ !~ /ABORT/;1} 
or
eval { push @gather, $C->_PATTERN(qr/\G\z/)} // do {die $@ if $@ and $@ !~ /ABORT/;1} 
or
eval { push @gather, do {
if (my ($C) = (scalar(do {
if ($::MEMOS[$C->{'_pos'}]{'ws'}) { $C->{'_pos'} = $::MEMOS[$C->{'_pos'}]{'ws'}; } 
}, $C))) {
$C->panic("Confused");
}
else {
();
}
}} or do { die $@ if $@ };
@gather;
}
})
);
}

#####################
# statement control #
#####################

## token statement_control__S_036need (:$endsym is context = 'spacey', :$sym is context<rw> = 'need')
##      token statement_control:need {
##          :my $longname;
##          <sym>:s
##          [
##          |<version>
##          |<module_name>
##              {{
##                  my $SCOPE is context = 'use';
##                  $longname = $<module_name>[*-1]<longname>.Str;
##                  $¢.do_need($longname);
##              }}
##          ] ** ','
##      }

sub statement_control__S_036need__PEEK { $_[0]->_AUTOLEXpeek('statement_control__S_036need',$retree) }
sub statement_control__S_036need {
my $self = shift;
local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;
my %args = @_;
local $endsym = $args{endsym} // 'spacey';
local $sym = $args{sym} // 'need';
my $longname;


my $C = $self;
my $S = $C->{'_pos'};
$C->{'version'} = [];
$C->{'module_name'} = [];
$C->{'sym'} = $sym;

$self->_MATCHIFYr($S, "statement_control__S_036need", 
do {
if (my ($C) = ($C->_PATTERN(qr/\Gneed/))) {
do {
if (my ($C) = ($C->spacey)) {
do {
if (my ($C) = ($C->ws)) {
do {
if (my ($C) = ($C->_REPSEPr(  sub { my $C=shift;
$C->_EXACT(',')
}, sub { my $C=shift;
$C->_BRACKETr( sub { my $C=shift;
do {
my @result = eval {
my $trystate;
my ($tag, $try);
my @try;
my $relex;

my $fate;
if ($fate = $C->{'_fate'} and $fate->[1] eq 'statement_control__S_036need_01') {
$C->deb("Fate passed to statement_control__S_036need_01: ", ::fatestr($fate)) if $::DEBUG & DEBUG::fates;
($C->{'_fate'}, $tag, $try) = @$fate;
@try = ($try);
}

my @gather = ();
for (;;) {
if (not @try) {
$relex //= $C->cursor_fate('STD', 'statement_control__S_036need_01', $retree);
@try = $relex->($C, $trystate);
}
last unless @try;
$try = shift(@try) // next;

if (ref $try eq 'ARRAY') {
($C->{'_fate'}, $tag, $try) = @$try;	# next candidate fate
}

$C->deb("statement_control__S_036need_01 trying $tag $try") if $::DEBUG & DEBUG::try_processing;
push @gather, ((
sub { my $C=shift;
do {
if (my ($C) = ($C->_SUBSUMEr(['version'], sub {
my $C = shift;
$C->version
}))) {
$C->ws;
}
else {
();
}
}
},
sub { my $C=shift;
do {
if (my ($C) = ($C->_SUBSUMEr(['module_name'], sub {
my $C = shift;
$C->module_name
}))) {
do {
if (my ($C) = ($C->ws)) {
do {
if (my ($C) = (scalar(do {
my $M = $C; 
local $::SCOPE = 'use';
$longname = $M->{'module_name'}[-1]{'longname'}->Str;
$C->do_need($longname);
;
}, $C))) {
$C->ws;
}
else {
();
}
};
}
else {
();
}
};
}
else {
();
}
}
},
)[$try])->($C);
last if @gather;
}
@gather;
};
if (@result) {
@result;
}
elsif ($@) {
my ($first) = $@ =~ /(^.*)/;
$self->deb("CAUGHT $first") if $::DEBUG & DEBUG::trace_call;
die $@ if $@ !~ /^ABORTBRANCH/;
();
}
else {
();
}
}

})
}))) {
$C->ws;
}
else {
();
}
};
}
else {
();
}
};
}
else {
();
}
};
}
else {
();
}
}
);
}

## token statement_control__S_037use (:$endsym is context = 'spacey', :$sym is context<rw> = 'use')
##      token statement_control:use {
##          :my $longname;
##          :my $SCOPE is context = 'use';
##          <sym> <.ws>
##          [
##          | <version>
##          | <module_name>
##              {{
##                  $longname = $<module_name><longname>.Str;
##              }}
##              [
##              || <.spacey> <arglist>
##                  {{
##                      $¢.do_use($longname, $<arglist>);
##                  }}
##              || {{ $¢.do_use($longname, ''); }}
##              ]
##          ]
##          <.ws>
##      }

sub statement_control__S_037use__PEEK { $_[0]->_AUTOLEXpeek('statement_control__S_037use',$retree) }
sub statement_control__S_037use {
my $self = shift;
local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;
my %args = @_;
local $endsym = $args{endsym} // 'spacey';
local $sym = $args{sym} // 'use';
my $longname;
local $::SCOPE = 'use';


my $C = $self;
my $S = $C->{'_pos'};
$C->{'sym'} = $sym;

$self->_MATCHIFYr($S, "statement_control__S_037use", 
do {
if (my ($C) = ($C->_PATTERN(qr/\Guse/))) {
do {
if (my ($C) = ($C->spacey)) {
do {
if (my ($C) = ($C->ws)) {
do {
if (my ($C) = ($C->_BRACKETr( sub { my $C=shift;
do {
my @result = eval {
my $trystate;
my ($tag, $try);
my @try;
my $relex;

my $fate;
if ($fate = $C->{'_fate'} and $fate->[1] eq 'statement_control__S_037use_01') {
$C->deb("Fate passed to statement_control__S_037use_01: ", ::fatestr($fate)) if $::DEBUG & DEBUG::fates;
($C->{'_fate'}, $tag, $try) = @$fate;
@try = ($try);
}

my @gather = ();
for (;;) {
if (not @try) {
$relex //= $C->cursor_fate('STD', 'statement_control__S_037use_01', $retree);
@try = $relex->($C, $trystate);
}
last unless @try;
$try = shift(@try) // next;

if (ref $try eq 'ARRAY') {
($C->{'_fate'}, $tag, $try) = @$try;	# next candidate fate
}

$C->deb("statement_control__S_037use_01 trying $tag $try") if $::DEBUG & DEBUG::try_processing;
push @gather, ((
sub { my $C=shift;
$C->_SUBSUMEr(['version'], sub {
my $C = shift;
$C->version
})
},
sub { my $C=shift;
do {
if (my ($C) = ($C->_SUBSUMEr(['module_name'], sub {
my $C = shift;
$C->module_name
}))) {
do {
if (my ($C) = (scalar(do {
my $M = $C; 
$longname = $M->{'module_name'}{'longname'}->Str;
;
}, $C))) {
$C->_BRACKETr( sub { my $C=shift;
do { my @gather;
eval { push @gather, do {
if (my ($C) = ($C->spacey)) {
do {
if (my ($C) = ($C->_SUBSUMEr(['arglist'], sub {
my $C = shift;
$C->arglist
}))) {
scalar(do {
my $M = $C; 
$C->do_use($longname, $M->{'arglist'});
;
}, $C);
}
else {
();
}
};
}
else {
();
}
}} // do {die $@ if $@ and $@ !~ /ABORT/;1} 
or
eval { push @gather, scalar(do {
$C->do_use($longname, ''); 
}, $C)} or do { die $@ if $@ };
@gather;
}
});
}
else {
();
}
};
}
else {
();
}
}
},
)[$try])->($C);
last if @gather;
}
@gather;
};
if (@result) {
@result;
}
elsif ($@) {
my ($first) = $@ =~ /(^.*)/;
$self->deb("CAUGHT $first") if $::DEBUG & DEBUG::trace_call;
die $@ if $@ !~ /^ABORTBRANCH/;
();
}
else {
();
}
}

}))) {
$C->ws;
}
else {
();
}
};
}
else {
();
}
};
}
else {
();
}
};
}
else {
();
}
}
);
}


## token statement_control__S_038no (:$endsym is context = 'spacey', :$sym is context<rw> = 'no')
##      token statement_control:no {
##          <sym> <.ws>
##          <module_name>[<.spacey><arglist>]?
##          <.ws>
##      }

sub statement_control__S_038no__PEEK { $_[0]->_AUTOLEXpeek('statement_control__S_038no',$retree) }
sub statement_control__S_038no {
my $self = shift;
local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;
my %args = @_;
local $endsym = $args{endsym} // 'spacey';
local $sym = $args{sym} // 'no';


my $C = $self;
my $S = $C->{'_pos'};
$C->{'arglist'} = [];
$C->{'sym'} = $sym;

$self->_MATCHIFYr($S, "statement_control__S_038no", 
do {
if (my ($C) = ($C->_PATTERN(qr/\Gno/))) {
do {
if (my ($C) = ($C->spacey)) {
do {
if (my ($C) = ($C->ws)) {
do {
if (my ($C) = ($C->_SUBSUMEr(['module_name'], sub {
my $C = shift;
$C->module_name
}))) {
do {
if (my ($C) = ($C->_OPTr(sub { my $C=shift;
$C->_BRACKETr( sub { my $C=shift;
do {
if (my ($C) = ($C->spacey)) {
$C->_SUBSUMEr(['arglist'], sub {
my $C = shift;
$C->arglist
});
}
else {
();
}
}
})
}))) {
$C->ws;
}
else {
();
}
};
}
else {
();
}
};
}
else {
();
}
};
}
else {
();
}
};
}
else {
();
}
}
);
}


## token statement_control__S_039if (:$endsym is context = 'spacey', :$sym is context<rw> = 'if')
##      token statement_control:if {
##          <sym> :s
##          <xblock>
##          [
##              [ <!before 'else'\s*'if'> || <.panic: "Please use 'elsif'"> ]
##              'elsif'<?spacey> <elsif=xblock>       {*}                #= elsif
##          ]*
##          [
##              'else'<?spacey> <else=pblock>       {*}             #= else
##          ]?
##      }

sub statement_control__S_039if__PEEK { $_[0]->_AUTOLEXpeek('statement_control__S_039if',$retree) }
sub statement_control__S_039if {
my $self = shift;
local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;
my %args = @_;
local $endsym = $args{endsym} // 'spacey';
local $sym = $args{sym} // 'if';


my $C = $self;
my $S = $C->{'_pos'};
$C->{'else'} = [];
$C->{'elsif'} = [];
$C->{'sym'} = $sym;

$self->_MATCHIFYr($S, "statement_control__S_039if", 
do {
if (my ($C) = ($C->_PATTERN(qr/\Gif/))) {
do {
if (my ($C) = ($C->spacey)) {
do {
if (my ($C) = ($C->ws)) {
do {
if (my ($C) = ($C->_SUBSUMEr(['xblock'], sub {
my $C = shift;
$C->xblock
}))) {
do {
if (my ($C) = ($C->ws)) {
do {
if (my ($C) = ($C->_STARr(sub { my $C=shift;
$C->_BRACKETr( sub { my $C=shift;
do {
if (my ($C) = ($C->ws)) {
do {
if (my ($C) = ($C->_BRACKETr( sub { my $C=shift;
do { my @gather;
eval { push @gather, do {
if (my ($C) = ($C->_NOTBEFORE( sub { my $C=shift;
$C->before(sub { my $C=shift;
do {
if (my ($C) = ($C->_EXACT('else'))) {
do {
if (my ($C) = ($C->_PATTERN(qr/\G((?:\s)*+)/))) {
$C->_EXACT('if');
}
else {
();
}
};
}
else {
();
}
}
})
}))) {
$C->ws;
}
else {
();
}
}} // do {die $@ if $@ and $@ !~ /ABORT/;1} 
or
eval { push @gather, do {
if (my ($C) = ($C->panic("Please use 'elsif'"))) {
$C->ws;
}
else {
();
}
}} or do { die $@ if $@ };
@gather;
}
}))) {
do {
if (my ($C) = ($C->ws)) {
do {
if (my ($C) = ($C->_EXACT('elsif'))) {
do {
if (my ($C) = ($C->before( sub { my $C=shift;
$C->spacey
}))) {
do {
if (my ($C) = ($C->ws)) {
do {
if (my ($C) = (    $C->_SUBSUMEr(['elsif'], sub {
my $C = shift;
$C->xblock
}))) {
do {
if (my ($C) = ($C->ws)) {
do {
if (my ($C) = ($C->_REDUCE($S, 'statement_control__S_039if', 'elsif'))) {
$C->ws;
}
else {
();
}
};
}
else {
();
}
};
}
else {
();
}
};
}
else {
();
}
};
}
else {
();
}
};
}
else {
();
}
};
}
else {
();
}
};
}
else {
();
}
};
}
else {
();
}
}
})
}))) {
do {
if (my ($C) = ($C->ws)) {
do {
if (my ($C) = ($C->_OPTr(sub { my $C=shift;
$C->_BRACKETr( sub { my $C=shift;
do {
if (my ($C) = ($C->ws)) {
do {
if (my ($C) = ($C->_EXACT('else'))) {
do {
if (my ($C) = ($C->before( sub { my $C=shift;
$C->spacey
}))) {
do {
if (my ($C) = ($C->ws)) {
do {
if (my ($C) = (    $C->_SUBSUMEr(['else'], sub {
my $C = shift;
$C->pblock
}))) {
do {
if (my ($C) = ($C->ws)) {
do {
if (my ($C) = ($C->_REDUCE($S, 'statement_control__S_039if', 'else'))) {
$C->ws;
}
else {
();
}
};
}
else {
();
}
};
}
else {
();
}
};
}
else {
();
}
};
}
else {
();
}
};
}
else {
();
}
};
}
else {
();
}
}
})
}))) {
$C->ws;
}
else {
();
}
};
}
else {
();
}
};
}
else {
();
}
};
}
else {
();
}
};
}
else {
();
}
};
}
else {
();
}
};
}
else {
();
}
};
}
else {
();
}
}
);
}


## token statement_control__S_040unless (:$endsym is context = 'spacey', :$sym is context<rw> = 'unless')
##      token statement_control:unless {
##          <sym> :s
##          <xblock>
##          [ <!before 'else'> || <.panic: "unless does not take \"else\" in Perl 6; please rewrite using \"if\""> ]
##      }

sub statement_control__S_040unless__PEEK { $_[0]->_AUTOLEXpeek('statement_control__S_040unless',$retree) }
sub statement_control__S_040unless {
my $self = shift;
local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;
my %args = @_;
local $endsym = $args{endsym} // 'spacey';
local $sym = $args{sym} // 'unless';


my $C = $self;
my $S = $C->{'_pos'};
$C->{'sym'} = $sym;

$self->_MATCHIFYr($S, "statement_control__S_040unless", 
do {
if (my ($C) = ($C->_PATTERN(qr/\Gunless/))) {
do {
if (my ($C) = ($C->spacey)) {
do {
if (my ($C) = ($C->ws)) {
do {
if (my ($C) = ($C->_SUBSUMEr(['xblock'], sub {
my $C = shift;
$C->xblock
}))) {
do {
if (my ($C) = ($C->ws)) {
do {
if (my ($C) = ($C->_BRACKETr( sub { my $C=shift;
do { my @gather;
eval { push @gather, do {
if (my ($C) = ($C->_NOTBEFORE( sub { my $C=shift;
$C->before(sub { my $C=shift;
$C->_EXACT('else')
})
}))) {
$C->ws;
}
else {
();
}
}} // do {die $@ if $@ and $@ !~ /ABORT/;1} 
or
eval { push @gather, do {
if (my ($C) = ($C->panic("unless does not take \"else\" in Perl 6; please rewrite using \"if\""))) {
$C->ws;
}
else {
();
}
}} or do { die $@ if $@ };
@gather;
}
}))) {
$C->ws;
}
else {
();
}
};
}
else {
();
}
};
}
else {
();
}
};
}
else {
();
}
};
}
else {
();
}
};
}
else {
();
}
}
);
}


## token statement_control__S_041while (:$endsym is context = 'spacey', :$sym is context<rw> = 'while')
##      token statement_control:while {
##          <sym> :s
##          [ <?before '(' ['my'? '$'\w+ '=']? '<' '$'?\w+ '>' ')'>   #'
##              <.panic: "This appears to be Perl 5 code"> ]?
##          <xblock>
##      }

sub statement_control__S_041while__PEEK { $_[0]->_AUTOLEXpeek('statement_control__S_041while',$retree) }
sub statement_control__S_041while {
my $self = shift;
local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;
my %args = @_;
local $endsym = $args{endsym} // 'spacey';
local $sym = $args{sym} // 'while';


my $C = $self;
my $S = $C->{'_pos'};
$C->{'sym'} = $sym;

$self->_MATCHIFYr($S, "statement_control__S_041while", 
do {
if (my ($C) = ($C->_PATTERN(qr/\Gwhile/))) {
do {
if (my ($C) = ($C->spacey)) {
do {
if (my ($C) = ($C->ws)) {
do {
if (my ($C) = ($C->_OPTr(sub { my $C=shift;
$C->_BRACKETr( sub { my $C=shift;
do {
if (my ($C) = ($C->ws)) {
do {
if (my ($C) = ($C->before(sub { my $C=shift;
do {
if (my ($C) = ($C->_EXACT('('))) {
do {
if (my ($C) = ($C->ws)) {
do {
if (my ($C) = ($C->_OPTr(sub { my $C=shift;
$C->_BRACKETr( sub { my $C=shift;
do {
if (my ($C) = ($C->_OPTr(sub { my $C=shift;
$C->_EXACT('my')
}))) {
do {
if (my ($C) = ($C->ws)) {
do {
if (my ($C) = ($C->_EXACT('$'))) {
do {
if (my ($C) = ($C->_PATTERN(qr/\G((?:\w)++)/))) {
do {
if (my ($C) = ($C->ws)) {
$C->_EXACT('=');
}
else {
();
}
};
}
else {
();
}
};
}
else {
();
}
};
}
else {
();
}
};
}
else {
();
}
}
})
}))) {
do {
if (my ($C) = ($C->ws)) {
do {
if (my ($C) = ($C->_EXACT('<'))) {
do {
if (my ($C) = ($C->ws)) {
do {
if (my ($C) = ($C->_OPTr(sub { my $C=shift;
$C->_EXACT('$')
}))) {
do {
if (my ($C) = ($C->_PATTERN(qr/\G((?:\w)++)/))) {
do {
if (my ($C) = ($C->ws)) {
do {
if (my ($C) = ($C->_EXACT('>'))) {
do {
if (my ($C) = ($C->ws)) {
$C->_EXACT(')');
}
else {
();
}
};
}
else {
();
}
};
}
else {
();
}
};
}
else {
();
}
};
}
else {
();
}
};
}
else {
();
}
};
}
else {
();
}
};
}
else {
();
}
};
}
else {
();
}
};
}
else {
();
}
};
}
else {
();
}
}
}))) {
do {
if (my ($C) = ($C->ws)) {
do {
if (my ($C) = ($C->panic("This appears to be Perl 5 code"))) {
$C->ws;
}
else {
();
}
};
}
else {
();
}
};
}
else {
();
}
};
}
else {
();
}
}
})
}))) {
do {
if (my ($C) = ($C->ws)) {
do {
if (my ($C) = ($C->_SUBSUMEr(['xblock'], sub {
my $C = shift;
$C->xblock
}))) {
$C->ws;
}
else {
();
}
};
}
else {
();
}
};
}
else {
();
}
};
}
else {
();
}
};
}
else {
();
}
};
}
else {
();
}
}
);
}


## token statement_control__S_042until (:$endsym is context = 'spacey', :$sym is context<rw> = 'until')
##      token statement_control:until {
##          <sym> :s
##          <xblock>
##      }

sub statement_control__S_042until__PEEK { $_[0]->_AUTOLEXpeek('statement_control__S_042until',$retree) }
sub statement_control__S_042until {
my $self = shift;
local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;
my %args = @_;
local $endsym = $args{endsym} // 'spacey';
local $sym = $args{sym} // 'until';


my $C = $self;
my $S = $C->{'_pos'};
$C->{'sym'} = $sym;

$self->_MATCHIFYr($S, "statement_control__S_042until", 
do {
if (my ($C) = ($C->_PATTERN(qr/\Guntil/))) {
do {
if (my ($C) = ($C->spacey)) {
do {
if (my ($C) = ($C->ws)) {
do {
if (my ($C) = ($C->_SUBSUMEr(['xblock'], sub {
my $C = shift;
$C->xblock
}))) {
$C->ws;
}
else {
();
}
};
}
else {
();
}
};
}
else {
();
}
};
}
else {
();
}
}
);
}


## token statement_control__S_043repeat (:$endsym is context = 'spacey', :$sym is context<rw> = 'repeat')
##      token statement_control:repeat {
##          <sym> :s
##          [
##              | ('while'|'until')
##                <xblock>
##              | <block>                      {*}                      #= block wu
##                ('while'|'until') <EXPR>         {*}                      #= expr wu
##          ]
##      }

sub statement_control__S_043repeat__PEEK { $_[0]->_AUTOLEXpeek('statement_control__S_043repeat',$retree) }
sub statement_control__S_043repeat {
my $self = shift;
local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;
my %args = @_;
local $endsym = $args{endsym} // 'spacey';
local $sym = $args{sym} // 'repeat';


my $C = $self;
my $S = $C->{'_pos'};
$C->{'sym'} = $sym;

$self->_MATCHIFYr($S, "statement_control__S_043repeat", 
do {
if (my ($C) = ($C->_PATTERN(qr/\Grepeat/))) {
do {
if (my ($C) = ($C->spacey)) {
do {
if (my ($C) = ($C->ws)) {
do {
if (my ($C) = ($C->_BRACKETr( sub { my $C=shift;
do {
my @result = eval {
my $trystate;
my ($tag, $try);
my @try;
my $relex;

my $fate;
if ($fate = $C->{'_fate'} and $fate->[1] eq 'statement_control__S_043repeat_01') {
$C->deb("Fate passed to statement_control__S_043repeat_01: ", ::fatestr($fate)) if $::DEBUG & DEBUG::fates;
($C->{'_fate'}, $tag, $try) = @$fate;
@try = ($try);
}

my @gather = ();
for (;;) {
if (not @try) {
$relex //= $C->cursor_fate('STD', 'statement_control__S_043repeat_01', $retree);
@try = $relex->($C, $trystate);
}
last unless @try;
$try = shift(@try) // next;

if (ref $try eq 'ARRAY') {
($C->{'_fate'}, $tag, $try) = @$try;	# next candidate fate
}

$C->deb("statement_control__S_043repeat_01 trying $tag $try") if $::DEBUG & DEBUG::try_processing;
push @gather, ((
sub { my $C=shift;
do {
if (my ($C) = (    $C->_SUBSUMEr(['0'], sub {
my $C = shift;
do { $C->_PAREN( sub { my $C=shift;
do {
my @result = eval {
my $trystate;
my ($tag, $try);
my @try;
my $relex;

my $fate;
if ($fate = $C->{'_fate'} and $fate->[1] eq 'statement_control__S_043repeat_02') {
$C->deb("Fate passed to statement_control__S_043repeat_02: ", ::fatestr($fate)) if $::DEBUG & DEBUG::fates;
($C->{'_fate'}, $tag, $try) = @$fate;
@try = ($try);
}

my @gather = ();
for (;;) {
if (not @try) {
$relex //= $C->cursor_fate('STD', 'statement_control__S_043repeat_02', $retree);
@try = $relex->($C, $trystate);
}
last unless @try;
$try = shift(@try) // next;

if (ref $try eq 'ARRAY') {
($C->{'_fate'}, $tag, $try) = @$try;	# next candidate fate
}

$C->deb("statement_control__S_043repeat_02 trying $tag $try") if $::DEBUG & DEBUG::try_processing;
push @gather, ((
sub { my $C=shift;
$C->_EXACT('while')
},
sub { my $C=shift;
$C->_EXACT('until')
},
)[$try])->($C);
last if @gather;
}
@gather;
};
if (@result) {
@result;
}
elsif ($@) {
my ($first) = $@ =~ /(^.*)/;
$self->deb("CAUGHT $first") if $::DEBUG & DEBUG::trace_call;
die $@ if $@ !~ /^ABORTBRANCH/;
();
}
else {
();
}
}

})}
}))) {
do {
if (my ($C) = ($C->ws)) {
do {
if (my ($C) = ($C->_SUBSUMEr(['xblock'], sub {
my $C = shift;
$C->xblock
}))) {
$C->ws;
}
else {
();
}
};
}
else {
();
}
};
}
else {
();
}
}
},
sub { my $C=shift;
do {
if (my ($C) = ($C->_SUBSUMEr(['block'], sub {
my $C = shift;
$C->block
}))) {
do {
if (my ($C) = ($C->ws)) {
do {
if (my ($C) = ($C->_REDUCE($S, 'statement_control__S_043repeat', 'block wu'))) {
do {
if (my ($C) = ($C->ws)) {
do {
if (my ($C) = (    $C->_SUBSUMEr(['1'], sub {
my $C = shift;
do { $C->_PAREN( sub { my $C=shift;
do {
my @result = eval {
my $trystate;
my ($tag, $try);
my @try;
my $relex;

my $fate;
if ($fate = $C->{'_fate'} and $fate->[1] eq 'statement_control__S_043repeat_03') {
$C->deb("Fate passed to statement_control__S_043repeat_03: ", ::fatestr($fate)) if $::DEBUG & DEBUG::fates;
($C->{'_fate'}, $tag, $try) = @$fate;
@try = ($try);
}

my @gather = ();
for (;;) {
if (not @try) {
$relex //= $C->cursor_fate('STD', 'statement_control__S_043repeat_03', $retree);
@try = $relex->($C, $trystate);
}
last unless @try;
$try = shift(@try) // next;

if (ref $try eq 'ARRAY') {
($C->{'_fate'}, $tag, $try) = @$try;	# next candidate fate
}

$C->deb("statement_control__S_043repeat_03 trying $tag $try") if $::DEBUG & DEBUG::try_processing;
push @gather, ((
sub { my $C=shift;
$C->_EXACT('while')
},
sub { my $C=shift;
$C->_EXACT('until')
},
)[$try])->($C);
last if @gather;
}
@gather;
};
if (@result) {
@result;
}
elsif ($@) {
my ($first) = $@ =~ /(^.*)/;
$self->deb("CAUGHT $first") if $::DEBUG & DEBUG::trace_call;
die $@ if $@ !~ /^ABORTBRANCH/;
();
}
else {
();
}
}

})}
}))) {
do {
if (my ($C) = ($C->ws)) {
do {
if (my ($C) = ($C->_SUBSUMEr(['EXPR'], sub {
my $C = shift;
$C->EXPR
}))) {
do {
if (my ($C) = ($C->ws)) {
do {
if (my ($C) = ($C->_REDUCE($S, 'statement_control__S_043repeat', 'expr wu'))) {
$C->ws;
}
else {
();
}
};
}
else {
();
}
};
}
else {
();
}
};
}
else {
();
}
};
}
else {
();
}
};
}
else {
();
}
};
}
else {
();
}
};
}
else {
();
}
};
}
else {
();
}
}
},
)[$try])->($C);
last if @gather;
}
@gather;
};
if (@result) {
@result;
}
elsif ($@) {
my ($first) = $@ =~ /(^.*)/;
$self->deb("CAUGHT $first") if $::DEBUG & DEBUG::trace_call;
die $@ if $@ !~ /^ABORTBRANCH/;
();
}
else {
();
}
}

}))) {
$C->ws;
}
else {
();
}
};
}
else {
();
}
};
}
else {
();
}
};
}
else {
();
}
}
);
}

## token statement_control__S_044loop (:$endsym is context = 'spacey', :$sym is context<rw> = 'loop')
##      token statement_control:loop {
##          <sym> :s
##          $<eee> = (
##              '('
##                  <e1=EXPR>? ';'   {*}                            #= e1
##                  <e2=EXPR>? ';'   {*}                            #= e2
##                  <e3=EXPR>?       {*}                            #= e3
##              ')'                      {*}                            #= eee
##          )?
##          <block>                     {*}                             #= block
##      }

sub statement_control__S_044loop__PEEK { $_[0]->_AUTOLEXpeek('statement_control__S_044loop',$retree) }
sub statement_control__S_044loop {
my $self = shift;
local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;
my %args = @_;
local $endsym = $args{endsym} // 'spacey';
local $sym = $args{sym} // 'loop';


my $C = $self;
my $S = $C->{'_pos'};
$C->{'sym'} = $sym;

$self->_MATCHIFYr($S, "statement_control__S_044loop", 
do {
if (my ($C) = ($C->_PATTERN(qr/\Gloop/))) {
do {
if (my ($C) = ($C->spacey)) {
do {
if (my ($C) = ($C->ws)) {
do {
if (my ($C) = (    $C->_OPTr(sub { my $C=shift;
$C->_SUBSUMEr(['eee'], sub {
my $C = shift;
do { $C->_PAREN( sub { my $C=shift;
do {
if (my ($C) = ($C->ws)) {
do {
if (my ($C) = ($C->_EXACT('('))) {
do {
if (my ($C) = ($C->ws)) {
do {
if (my ($C) = (    $C->_OPTr(sub { my $C=shift;
$C->_SUBSUMEr(['e1','EXPR'], sub {
my $C = shift;
$C->EXPR
})
}))) {
do {
if (my ($C) = ($C->ws)) {
do {
if (my ($C) = ($C->_EXACT(';'))) {
do {
if (my ($C) = ($C->ws)) {
do {
if (my ($C) = ($C->_REDUCE($S, 'statement_control__S_044loop', 'e1'))) {
do {
if (my ($C) = ($C->ws)) {
do {
if (my ($C) = (    $C->_OPTr(sub { my $C=shift;
$C->_SUBSUMEr(['e2','EXPR'], sub {
my $C = shift;
$C->EXPR
})
}))) {
do {
if (my ($C) = ($C->ws)) {
do {
if (my ($C) = ($C->_EXACT(';'))) {
do {
if (my ($C) = ($C->ws)) {
do {
if (my ($C) = ($C->_REDUCE($S, 'statement_control__S_044loop', 'e2'))) {
do {
if (my ($C) = ($C->ws)) {
do {
if (my ($C) = (    $C->_OPTr(sub { my $C=shift;
$C->_SUBSUMEr(['e3','EXPR'], sub {
my $C = shift;
$C->EXPR
})
}))) {
do {
if (my ($C) = ($C->ws)) {
do {
if (my ($C) = ($C->_REDUCE($S, 'statement_control__S_044loop', 'e3'))) {
do {
if (my ($C) = ($C->ws)) {
do {
if (my ($C) = ($C->_EXACT(')'))) {
do {
if (my ($C) = ($C->ws)) {
do {
if (my ($C) = ($C->_REDUCE($S, 'statement_control__S_044loop', 'eee'))) {
$C->ws;
}
else {
();
}
};
}
else {
();
}
};
}
else {
();
}
};
}
else {
();
}
};
}
else {
();
}
};
}
else {
();
}
};
}
else {
();
}
};
}
else {
();
}
};
}
else {
();
}
};
}
else {
();
}
};
}
else {
();
}
};
}
else {
();
}
};
}
else {
();
}
};
}
else {
();
}
};
}
else {
();
}
};
}
else {
();
}
};
}
else {
();
}
};
}
else {
();
}
};
}
else {
();
}
};
}
else {
();
}
};
}
else {
();
}
};
}
else {
();
}
}
})}
})
}))) {
do {
if (my ($C) = ($C->ws)) {
do {
if (my ($C) = ($C->_SUBSUMEr(['block'], sub {
my $C = shift;
$C->block
}))) {
do {
if (my ($C) = ($C->ws)) {
do {
if (my ($C) = ($C->_REDUCE($S, 'statement_control__S_044loop', 'block'))) {
$C->ws;
}
else {
();
}
};
}
else {
();
}
};
}
else {
();
}
};
}
else {
();
}
};
}
else {
();
}
};
}
else {
();
}
};
}
else {
();
}
};
}
else {
();
}
}
);
}


## token statement_control__S_045for (:$endsym is context = 'spacey', :$sym is context<rw> = 'for')
##      token statement_control:for {
##          <sym> :s
##          [ <?before 'my'? '$'\w+ '(' >
##              <.panic: "This appears to be Perl 5 code"> ]?
##          [ <?before '(' <.EXPR>? ';' <.EXPR>? ';' <.EXPR>? ')' >
##              <.obs('C-style "for (;;)" loop', '"loop (;;)"')> ]?
##          <xblock>
##      }

sub statement_control__S_045for__PEEK { $_[0]->_AUTOLEXpeek('statement_control__S_045for',$retree) }
sub statement_control__S_045for {
my $self = shift;
local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;
my %args = @_;
local $endsym = $args{endsym} // 'spacey';
local $sym = $args{sym} // 'for';


my $C = $self;
my $S = $C->{'_pos'};
$C->{'sym'} = $sym;

$self->_MATCHIFYr($S, "statement_control__S_045for", 
do {
if (my ($C) = ($C->_PATTERN(qr/\Gfor/))) {
do {
if (my ($C) = ($C->spacey)) {
do {
if (my ($C) = ($C->ws)) {
do {
if (my ($C) = ($C->_OPTr(sub { my $C=shift;
$C->_BRACKETr( sub { my $C=shift;
do {
if (my ($C) = ($C->ws)) {
do {
if (my ($C) = ($C->before(sub { my $C=shift;
do {
if (my ($C) = ($C->_OPTr(sub { my $C=shift;
$C->_EXACT('my')
}))) {
do {
if (my ($C) = ($C->ws)) {
do {
if (my ($C) = ($C->_EXACT('$'))) {
do {
if (my ($C) = ($C->_PATTERN(qr/\G((?:\w)++)/))) {
do {
if (my ($C) = ($C->ws)) {
do {
if (my ($C) = ($C->_EXACT('('))) {
$C->ws;
}
else {
();
}
};
}
else {
();
}
};
}
else {
();
}
};
}
else {
();
}
};
}
else {
();
}
};
}
else {
();
}
}
}))) {
do {
if (my ($C) = ($C->ws)) {
do {
if (my ($C) = ($C->panic("This appears to be Perl 5 code"))) {
$C->ws;
}
else {
();
}
};
}
else {
();
}
};
}
else {
();
}
};
}
else {
();
}
}
})
}))) {
do {
if (my ($C) = ($C->ws)) {
do {
if (my ($C) = ($C->_OPTr(sub { my $C=shift;
$C->_BRACKETr( sub { my $C=shift;
do {
if (my ($C) = ($C->ws)) {
do {
if (my ($C) = ($C->before(sub { my $C=shift;
do {
if (my ($C) = ($C->_EXACT('('))) {
do {
if (my ($C) = ($C->ws)) {
do {
if (my ($C) = ($C->_OPTr(sub { my $C=shift;
$C->EXPR
}))) {
do {
if (my ($C) = ($C->ws)) {
do {
if (my ($C) = ($C->_EXACT(';'))) {
do {
if (my ($C) = ($C->ws)) {
do {
if (my ($C) = ($C->_OPTr(sub { my $C=shift;
$C->EXPR
}))) {
do {
if (my ($C) = ($C->ws)) {
do {
if (my ($C) = ($C->_EXACT(';'))) {
do {
if (my ($C) = ($C->ws)) {
do {
if (my ($C) = ($C->_OPTr(sub { my $C=shift;
$C->EXPR
}))) {
do {
if (my ($C) = ($C->ws)) {
do {
if (my ($C) = ($C->_EXACT(')'))) {
$C->ws;
}
else {
();
}
};
}
else {
();
}
};
}
else {
();
}
};
}
else {
();
}
};
}
else {
();
}
};
}
else {
();
}
};
}
else {
();
}
};
}
else {
();
}
};
}
else {
();
}
};
}
else {
();
}
};
}
else {
();
}
};
}
else {
();
}
};
}
else {
();
}
}
}))) {
do {
if (my ($C) = ($C->ws)) {
do {
if (my ($C) = ($C->obs('C-style "for (;;)" loop', '"loop (;;)"'))) {
$C->ws;
}
else {
();
}
};
}
else {
();
}
};
}
else {
();
}
};
}
else {
();
}
}
})
}))) {
do {
if (my ($C) = ($C->ws)) {
do {
if (my ($C) = ($C->_SUBSUMEr(['xblock'], sub {
my $C = shift;
$C->xblock
}))) {
$C->ws;
}
else {
();
}
};
}
else {
();
}
};
}
else {
();
}
};
}
else {
();
}
};
}
else {
();
}
};
}
else {
();
}
};
}
else {
();
}
};
}
else {
();
}
}
);
}

## token statement_control__S_046given (:$endsym is context = 'spacey', :$sym is context<rw> = 'given')
##      token statement_control:given {
##          <sym> :s
##          <xblock>
##      }

sub statement_control__S_046given__PEEK { $_[0]->_AUTOLEXpeek('statement_control__S_046given',$retree) }
sub statement_control__S_046given {
my $self = shift;
local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;
my %args = @_;
local $endsym = $args{endsym} // 'spacey';
local $sym = $args{sym} // 'given';


my $C = $self;
my $S = $C->{'_pos'};
$C->{'sym'} = $sym;

$self->_MATCHIFYr($S, "statement_control__S_046given", 
do {
if (my ($C) = ($C->_PATTERN(qr/\Ggiven/))) {
do {
if (my ($C) = ($C->spacey)) {
do {
if (my ($C) = ($C->ws)) {
do {
if (my ($C) = ($C->_SUBSUMEr(['xblock'], sub {
my $C = shift;
$C->xblock
}))) {
$C->ws;
}
else {
();
}
};
}
else {
();
}
};
}
else {
();
}
};
}
else {
();
}
}
);
}
## token statement_control__S_047when (:$endsym is context = 'spacey', :$sym is context<rw> = 'when')
##      token statement_control:when {
##          <sym> :s
##          <xblock>
##      }

sub statement_control__S_047when__PEEK { $_[0]->_AUTOLEXpeek('statement_control__S_047when',$retree) }
sub statement_control__S_047when {
my $self = shift;
local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;
my %args = @_;
local $endsym = $args{endsym} // 'spacey';
local $sym = $args{sym} // 'when';


my $C = $self;
my $S = $C->{'_pos'};
$C->{'sym'} = $sym;

$self->_MATCHIFYr($S, "statement_control__S_047when", 
do {
if (my ($C) = ($C->_PATTERN(qr/\Gwhen/))) {
do {
if (my ($C) = ($C->spacey)) {
do {
if (my ($C) = ($C->ws)) {
do {
if (my ($C) = ($C->_SUBSUMEr(['xblock'], sub {
my $C = shift;
$C->xblock
}))) {
$C->ws;
}
else {
();
}
};
}
else {
();
}
};
}
else {
();
}
};
}
else {
();
}
}
);
}
## rule statement_control__S_048default (:$endsym is context = 'spacey', :$sym is context<rw> = 'default')
##      rule statement_control:default {<sym> <block> }

sub statement_control__S_048default__PEEK { $_[0]->_AUTOLEXpeek('statement_control__S_048default',$retree) }
sub statement_control__S_048default {
my $self = shift;
local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;
my %args = @_;
local $endsym = $args{endsym} // 'spacey';
local $sym = $args{sym} // 'default';


my $C = $self;
my $S = $C->{'_pos'};
$C->{'sym'} = $sym;

$self->_MATCHIFYr($S, "statement_control__S_048default", 
do {
if (my ($C) = ($C->_PATTERN(qr/\Gdefault/))) {
do {
if (my ($C) = ($C->spacey)) {
do {
if (my ($C) = ($C->ws)) {
do {
if (my ($C) = ($C->_SUBSUMEr(['block'], sub {
my $C = shift;
$C->block
}))) {
$C->ws;
}
else {
();
}
};
}
else {
();
}
};
}
else {
();
}
};
}
else {
();
}
}
);
}

## token statement_prefix__S_049BEGIN (:$sym is context<rw> = 'BEGIN')
##      token statement_prefix:BEGIN   { <sym> <blorst> }

sub statement_prefix__S_049BEGIN__PEEK { $_[0]->_AUTOLEXpeek('statement_prefix__S_049BEGIN',$retree) }
sub statement_prefix__S_049BEGIN {
my $self = shift;
local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;
my %args = @_;
local $sym = $args{sym} // 'BEGIN';


my $C = $self;
my $S = $C->{'_pos'};
$C->{'sym'} = $sym;

$self->_MATCHIFYr($S, "statement_prefix__S_049BEGIN", 
do {
if (my ($C) = ($C->_PATTERN(qr/\GBEGIN/))) {
$C->_SUBSUMEr(['blorst'], sub {
my $C = shift;
$C->blorst
});
}
else {
();
}
}
);
}
## token statement_prefix__S_050CHECK (:$sym is context<rw> = 'CHECK')
##      token statement_prefix:CHECK   { <sym> <blorst> }

sub statement_prefix__S_050CHECK__PEEK { $_[0]->_AUTOLEXpeek('statement_prefix__S_050CHECK',$retree) }
sub statement_prefix__S_050CHECK {
my $self = shift;
local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;
my %args = @_;
local $sym = $args{sym} // 'CHECK';


my $C = $self;
my $S = $C->{'_pos'};
$C->{'sym'} = $sym;

$self->_MATCHIFYr($S, "statement_prefix__S_050CHECK", 
do {
if (my ($C) = ($C->_PATTERN(qr/\GCHECK/))) {
$C->_SUBSUMEr(['blorst'], sub {
my $C = shift;
$C->blorst
});
}
else {
();
}
}
);
}
## token statement_prefix__S_051INIT (:$sym is context<rw> = 'INIT')
##      token statement_prefix:INIT    { <sym> <blorst> }

sub statement_prefix__S_051INIT__PEEK { $_[0]->_AUTOLEXpeek('statement_prefix__S_051INIT',$retree) }
sub statement_prefix__S_051INIT {
my $self = shift;
local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;
my %args = @_;
local $sym = $args{sym} // 'INIT';


my $C = $self;
my $S = $C->{'_pos'};
$C->{'sym'} = $sym;

$self->_MATCHIFYr($S, "statement_prefix__S_051INIT", 
do {
if (my ($C) = ($C->_PATTERN(qr/\GINIT/))) {
$C->_SUBSUMEr(['blorst'], sub {
my $C = shift;
$C->blorst
});
}
else {
();
}
}
);
}
## token statement_prefix__S_052START (:$sym is context<rw> = 'START')
##      token statement_prefix:START   { <sym> <blorst> }

sub statement_prefix__S_052START__PEEK { $_[0]->_AUTOLEXpeek('statement_prefix__S_052START',$retree) }
sub statement_prefix__S_052START {
my $self = shift;
local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;
my %args = @_;
local $sym = $args{sym} // 'START';


my $C = $self;
my $S = $C->{'_pos'};
$C->{'sym'} = $sym;

$self->_MATCHIFYr($S, "statement_prefix__S_052START", 
do {
if (my ($C) = ($C->_PATTERN(qr/\GSTART/))) {
$C->_SUBSUMEr(['blorst'], sub {
my $C = shift;
$C->blorst
});
}
else {
();
}
}
);
}
## token statement_prefix__S_053ENTER (:$sym is context<rw> = 'ENTER')
##      token statement_prefix:ENTER   { <sym> <blorst> }

sub statement_prefix__S_053ENTER__PEEK { $_[0]->_AUTOLEXpeek('statement_prefix__S_053ENTER',$retree) }
sub statement_prefix__S_053ENTER {
my $self = shift;
local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;
my %args = @_;
local $sym = $args{sym} // 'ENTER';


my $C = $self;
my $S = $C->{'_pos'};
$C->{'sym'} = $sym;

$self->_MATCHIFYr($S, "statement_prefix__S_053ENTER", 
do {
if (my ($C) = ($C->_PATTERN(qr/\GENTER/))) {
$C->_SUBSUMEr(['blorst'], sub {
my $C = shift;
$C->blorst
});
}
else {
();
}
}
);
}
## token statement_prefix__S_054FIRST (:$sym is context<rw> = 'FIRST')
##      token statement_prefix:FIRST   { <sym> <blorst> }

sub statement_prefix__S_054FIRST__PEEK { $_[0]->_AUTOLEXpeek('statement_prefix__S_054FIRST',$retree) }
sub statement_prefix__S_054FIRST {
my $self = shift;
local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;
my %args = @_;
local $sym = $args{sym} // 'FIRST';


my $C = $self;
my $S = $C->{'_pos'};
$C->{'sym'} = $sym;

$self->_MATCHIFYr($S, "statement_prefix__S_054FIRST", 
do {
if (my ($C) = ($C->_PATTERN(qr/\GFIRST/))) {
$C->_SUBSUMEr(['blorst'], sub {
my $C = shift;
$C->blorst
});
}
else {
();
}
}
);
}

## rule statement_control__S_055END (:$endsym is context = 'spacey', :$sym is context<rw> = 'END')
##      rule statement_control:END     {<sym> <block> }

sub statement_control__S_055END__PEEK { $_[0]->_AUTOLEXpeek('statement_control__S_055END',$retree) }
sub statement_control__S_055END {
my $self = shift;
local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;
my %args = @_;
local $endsym = $args{endsym} // 'spacey';
local $sym = $args{sym} // 'END';


my $C = $self;
my $S = $C->{'_pos'};
$C->{'sym'} = $sym;

$self->_MATCHIFYr($S, "statement_control__S_055END", 
do {
if (my ($C) = ($C->_PATTERN(qr/\GEND/))) {
do {
if (my ($C) = ($C->spacey)) {
do {
if (my ($C) = ($C->ws)) {
do {
if (my ($C) = ($C->_SUBSUMEr(['block'], sub {
my $C = shift;
$C->block
}))) {
$C->ws;
}
else {
();
}
};
}
else {
();
}
};
}
else {
();
}
};
}
else {
();
}
}
);
}
## rule statement_control__S_056LEAVE (:$endsym is context = 'spacey', :$sym is context<rw> = 'LEAVE')
##      rule statement_control:LEAVE   {<sym> <block> }

sub statement_control__S_056LEAVE__PEEK { $_[0]->_AUTOLEXpeek('statement_control__S_056LEAVE',$retree) }
sub statement_control__S_056LEAVE {
my $self = shift;
local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;
my %args = @_;
local $endsym = $args{endsym} // 'spacey';
local $sym = $args{sym} // 'LEAVE';


my $C = $self;
my $S = $C->{'_pos'};
$C->{'sym'} = $sym;

$self->_MATCHIFYr($S, "statement_control__S_056LEAVE", 
do {
if (my ($C) = ($C->_PATTERN(qr/\GLEAVE/))) {
do {
if (my ($C) = ($C->spacey)) {
do {
if (my ($C) = ($C->ws)) {
do {
if (my ($C) = ($C->_SUBSUMEr(['block'], sub {
my $C = shift;
$C->block
}))) {
$C->ws;
}
else {
();
}
};
}
else {
();
}
};
}
else {
();
}
};
}
else {
();
}
}
);
}
## rule statement_control__S_057KEEP (:$endsym is context = 'spacey', :$sym is context<rw> = 'KEEP')
##      rule statement_control:KEEP    {<sym> <block> }

sub statement_control__S_057KEEP__PEEK { $_[0]->_AUTOLEXpeek('statement_control__S_057KEEP',$retree) }
sub statement_control__S_057KEEP {
my $self = shift;
local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;
my %args = @_;
local $endsym = $args{endsym} // 'spacey';
local $sym = $args{sym} // 'KEEP';


my $C = $self;
my $S = $C->{'_pos'};
$C->{'sym'} = $sym;

$self->_MATCHIFYr($S, "statement_control__S_057KEEP", 
do {
if (my ($C) = ($C->_PATTERN(qr/\GKEEP/))) {
do {
if (my ($C) = ($C->spacey)) {
do {
if (my ($C) = ($C->ws)) {
do {
if (my ($C) = ($C->_SUBSUMEr(['block'], sub {
my $C = shift;
$C->block
}))) {
$C->ws;
}
else {
();
}
};
}
else {
();
}
};
}
else {
();
}
};
}
else {
();
}
}
);
}
## rule statement_control__S_058UNDO (:$endsym is context = 'spacey', :$sym is context<rw> = 'UNDO')
##      rule statement_control:UNDO    {<sym> <block> }

sub statement_control__S_058UNDO__PEEK { $_[0]->_AUTOLEXpeek('statement_control__S_058UNDO',$retree) }
sub statement_control__S_058UNDO {
my $self = shift;
local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;
my %args = @_;
local $endsym = $args{endsym} // 'spacey';
local $sym = $args{sym} // 'UNDO';


my $C = $self;
my $S = $C->{'_pos'};
$C->{'sym'} = $sym;

$self->_MATCHIFYr($S, "statement_control__S_058UNDO", 
do {
if (my ($C) = ($C->_PATTERN(qr/\GUNDO/))) {
do {
if (my ($C) = ($C->spacey)) {
do {
if (my ($C) = ($C->ws)) {
do {
if (my ($C) = ($C->_SUBSUMEr(['block'], sub {
my $C = shift;
$C->block
}))) {
$C->ws;
}
else {
();
}
};
}
else {
();
}
};
}
else {
();
}
};
}
else {
();
}
}
);
}
## rule statement_control__S_059NEXT (:$endsym is context = 'spacey', :$sym is context<rw> = 'NEXT')
##      rule statement_control:NEXT    {<sym> <block> }

sub statement_control__S_059NEXT__PEEK { $_[0]->_AUTOLEXpeek('statement_control__S_059NEXT',$retree) }
sub statement_control__S_059NEXT {
my $self = shift;
local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;
my %args = @_;
local $endsym = $args{endsym} // 'spacey';
local $sym = $args{sym} // 'NEXT';


my $C = $self;
my $S = $C->{'_pos'};
$C->{'sym'} = $sym;

$self->_MATCHIFYr($S, "statement_control__S_059NEXT", 
do {
if (my ($C) = ($C->_PATTERN(qr/\GNEXT/))) {
do {
if (my ($C) = ($C->spacey)) {
do {
if (my ($C) = ($C->ws)) {
do {
if (my ($C) = ($C->_SUBSUMEr(['block'], sub {
my $C = shift;
$C->block
}))) {
$C->ws;
}
else {
();
}
};
}
else {
();
}
};
}
else {
();
}
};
}
else {
();
}
}
);
}
## rule statement_control__S_060LAST (:$endsym is context = 'spacey', :$sym is context<rw> = 'LAST')
##      rule statement_control:LAST    {<sym> <block> }

sub statement_control__S_060LAST__PEEK { $_[0]->_AUTOLEXpeek('statement_control__S_060LAST',$retree) }
sub statement_control__S_060LAST {
my $self = shift;
local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;
my %args = @_;
local $endsym = $args{endsym} // 'spacey';
local $sym = $args{sym} // 'LAST';


my $C = $self;
my $S = $C->{'_pos'};
$C->{'sym'} = $sym;

$self->_MATCHIFYr($S, "statement_control__S_060LAST", 
do {
if (my ($C) = ($C->_PATTERN(qr/\GLAST/))) {
do {
if (my ($C) = ($C->spacey)) {
do {
if (my ($C) = ($C->ws)) {
do {
if (my ($C) = ($C->_SUBSUMEr(['block'], sub {
my $C = shift;
$C->block
}))) {
$C->ws;
}
else {
();
}
};
}
else {
();
}
};
}
else {
();
}
};
}
else {
();
}
}
);
}
## rule statement_control__S_061PRE (:$endsym is context = 'spacey', :$sym is context<rw> = 'PRE')
##      rule statement_control:PRE     {<sym> <block> }

sub statement_control__S_061PRE__PEEK { $_[0]->_AUTOLEXpeek('statement_control__S_061PRE',$retree) }
sub statement_control__S_061PRE {
my $self = shift;
local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;
my %args = @_;
local $endsym = $args{endsym} // 'spacey';
local $sym = $args{sym} // 'PRE';


my $C = $self;
my $S = $C->{'_pos'};
$C->{'sym'} = $sym;

$self->_MATCHIFYr($S, "statement_control__S_061PRE", 
do {
if (my ($C) = ($C->_PATTERN(qr/\GPRE/))) {
do {
if (my ($C) = ($C->spacey)) {
do {
if (my ($C) = ($C->ws)) {
do {
if (my ($C) = ($C->_SUBSUMEr(['block'], sub {
my $C = shift;
$C->block
}))) {
$C->ws;
}
else {
();
}
};
}
else {
();
}
};
}
else {
();
}
};
}
else {
();
}
}
);
}
## rule statement_control__S_062POST (:$endsym is context = 'spacey', :$sym is context<rw> = 'POST')
##      rule statement_control:POST    {<sym> <block> }

sub statement_control__S_062POST__PEEK { $_[0]->_AUTOLEXpeek('statement_control__S_062POST',$retree) }
sub statement_control__S_062POST {
my $self = shift;
local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;
my %args = @_;
local $endsym = $args{endsym} // 'spacey';
local $sym = $args{sym} // 'POST';


my $C = $self;
my $S = $C->{'_pos'};
$C->{'sym'} = $sym;

$self->_MATCHIFYr($S, "statement_control__S_062POST", 
do {
if (my ($C) = ($C->_PATTERN(qr/\GPOST/))) {
do {
if (my ($C) = ($C->spacey)) {
do {
if (my ($C) = ($C->ws)) {
do {
if (my ($C) = ($C->_SUBSUMEr(['block'], sub {
my $C = shift;
$C->block
}))) {
$C->ws;
}
else {
();
}
};
}
else {
();
}
};
}
else {
();
}
};
}
else {
();
}
}
);
}
## rule statement_control__S_063CATCH (:$endsym is context = 'spacey', :$sym is context<rw> = 'CATCH')
##      rule statement_control:CATCH   {<sym> <block> }

sub statement_control__S_063CATCH__PEEK { $_[0]->_AUTOLEXpeek('statement_control__S_063CATCH',$retree) }
sub statement_control__S_063CATCH {
my $self = shift;
local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;
my %args = @_;
local $endsym = $args{endsym} // 'spacey';
local $sym = $args{sym} // 'CATCH';


my $C = $self;
my $S = $C->{'_pos'};
$C->{'sym'} = $sym;

$self->_MATCHIFYr($S, "statement_control__S_063CATCH", 
do {
if (my ($C) = ($C->_PATTERN(qr/\GCATCH/))) {
do {
if (my ($C) = ($C->spacey)) {
do {
if (my ($C) = ($C->ws)) {
do {
if (my ($C) = ($C->_SUBSUMEr(['block'], sub {
my $C = shift;
$C->block
}))) {
$C->ws;
}
else {
();
}
};
}
else {
();
}
};
}
else {
();
}
};
}
else {
();
}
}
);
}
## rule statement_control__S_064CONTROL (:$endsym is context = 'spacey', :$sym is context<rw> = 'CONTROL')
##      rule statement_control:CONTROL {<sym> <block> }

sub statement_control__S_064CONTROL__PEEK { $_[0]->_AUTOLEXpeek('statement_control__S_064CONTROL',$retree) }
sub statement_control__S_064CONTROL {
my $self = shift;
local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;
my %args = @_;
local $endsym = $args{endsym} // 'spacey';
local $sym = $args{sym} // 'CONTROL';


my $C = $self;
my $S = $C->{'_pos'};
$C->{'sym'} = $sym;

$self->_MATCHIFYr($S, "statement_control__S_064CONTROL", 
do {
if (my ($C) = ($C->_PATTERN(qr/\GCONTROL/))) {
do {
if (my ($C) = ($C->spacey)) {
do {
if (my ($C) = ($C->ws)) {
do {
if (my ($C) = ($C->_SUBSUMEr(['block'], sub {
my $C = shift;
$C->block
}))) {
$C->ws;
}
else {
();
}
};
}
else {
();
}
};
}
else {
();
}
};
}
else {
();
}
}
);
}
## rule statement_control__S_065TEMP (:$endsym is context = 'spacey', :$sym is context<rw> = 'TEMP')
##      rule statement_control:TEMP    {<sym> <block> }

sub statement_control__S_065TEMP__PEEK { $_[0]->_AUTOLEXpeek('statement_control__S_065TEMP',$retree) }
sub statement_control__S_065TEMP {
my $self = shift;
local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;
my %args = @_;
local $endsym = $args{endsym} // 'spacey';
local $sym = $args{sym} // 'TEMP';


my $C = $self;
my $S = $C->{'_pos'};
$C->{'sym'} = $sym;

$self->_MATCHIFYr($S, "statement_control__S_065TEMP", 
do {
if (my ($C) = ($C->_PATTERN(qr/\GTEMP/))) {
do {
if (my ($C) = ($C->spacey)) {
do {
if (my ($C) = ($C->ws)) {
do {
if (my ($C) = ($C->_SUBSUMEr(['block'], sub {
my $C = shift;
$C->block
}))) {
$C->ws;
}
else {
();
}
};
}
else {
();
}
};
}
else {
();
}
};
}
else {
();
}
}
);
}

#######################
# statement modifiers #
#######################

## rule modifier_expr
##      rule modifier_expr { <EXPR> }

sub modifier_expr__PEEK { $_[0]->_AUTOLEXpeek('modifier_expr',$retree) }
sub modifier_expr {
my $self = shift;
local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;


my $C = $self;
my $S = $C->{'_pos'};

$self->_MATCHIFYr($S, "modifier_expr", 
do {
if (my ($C) = ($C->ws)) {
do {
if (my ($C) = ($C->_SUBSUMEr(['EXPR'], sub {
my $C = shift;
$C->EXPR
}))) {
$C->ws;
}
else {
();
}
};
}
else {
();
}
}
);
}

## rule statement_mod_cond__S_066if (:$endsym is context = 'nofun', :$sym is context<rw> = 'if')
##      rule statement_mod_cond:if     {<sym> <modifier_expr> }

sub statement_mod_cond__S_066if__PEEK { $_[0]->_AUTOLEXpeek('statement_mod_cond__S_066if',$retree) }
sub statement_mod_cond__S_066if {
my $self = shift;
local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;
my %args = @_;
local $endsym = $args{endsym} // 'nofun';
local $sym = $args{sym} // 'if';


my $C = $self;
my $S = $C->{'_pos'};
$C->{'sym'} = $sym;

$self->_MATCHIFYr($S, "statement_mod_cond__S_066if", 
do {
if (my ($C) = ($C->_PATTERN(qr/\Gif/))) {
do {
if (my ($C) = ($C->nofun)) {
do {
if (my ($C) = ($C->ws)) {
do {
if (my ($C) = ($C->_SUBSUMEr(['modifier_expr'], sub {
my $C = shift;
$C->modifier_expr
}))) {
$C->ws;
}
else {
();
}
};
}
else {
();
}
};
}
else {
();
}
};
}
else {
();
}
}
);
}
## rule statement_mod_cond__S_067unless (:$endsym is context = 'nofun', :$sym is context<rw> = 'unless')
##      rule statement_mod_cond:unless {<sym> <modifier_expr> }

sub statement_mod_cond__S_067unless__PEEK { $_[0]->_AUTOLEXpeek('statement_mod_cond__S_067unless',$retree) }
sub statement_mod_cond__S_067unless {
my $self = shift;
local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;
my %args = @_;
local $endsym = $args{endsym} // 'nofun';
local $sym = $args{sym} // 'unless';


my $C = $self;
my $S = $C->{'_pos'};
$C->{'sym'} = $sym;

$self->_MATCHIFYr($S, "statement_mod_cond__S_067unless", 
do {
if (my ($C) = ($C->_PATTERN(qr/\Gunless/))) {
do {
if (my ($C) = ($C->nofun)) {
do {
if (my ($C) = ($C->ws)) {
do {
if (my ($C) = ($C->_SUBSUMEr(['modifier_expr'], sub {
my $C = shift;
$C->modifier_expr
}))) {
$C->ws;
}
else {
();
}
};
}
else {
();
}
};
}
else {
();
}
};
}
else {
();
}
}
);
}
## rule statement_mod_cond__S_068when (:$endsym is context = 'nofun', :$sym is context<rw> = 'when')
##      rule statement_mod_cond:when   {<sym> <modifier_expr> }

sub statement_mod_cond__S_068when__PEEK { $_[0]->_AUTOLEXpeek('statement_mod_cond__S_068when',$retree) }
sub statement_mod_cond__S_068when {
my $self = shift;
local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;
my %args = @_;
local $endsym = $args{endsym} // 'nofun';
local $sym = $args{sym} // 'when';


my $C = $self;
my $S = $C->{'_pos'};
$C->{'sym'} = $sym;

$self->_MATCHIFYr($S, "statement_mod_cond__S_068when", 
do {
if (my ($C) = ($C->_PATTERN(qr/\Gwhen/))) {
do {
if (my ($C) = ($C->nofun)) {
do {
if (my ($C) = ($C->ws)) {
do {
if (my ($C) = ($C->_SUBSUMEr(['modifier_expr'], sub {
my $C = shift;
$C->modifier_expr
}))) {
$C->ws;
}
else {
();
}
};
}
else {
();
}
};
}
else {
();
}
};
}
else {
();
}
}
);
}

## rule statement_mod_loop__S_069while (:$endsym is context = 'nofun', :$sym is context<rw> = 'while')
##      rule statement_mod_loop:while {<sym> <modifier_expr> }

sub statement_mod_loop__S_069while__PEEK { $_[0]->_AUTOLEXpeek('statement_mod_loop__S_069while',$retree) }
sub statement_mod_loop__S_069while {
my $self = shift;
local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;
my %args = @_;
local $endsym = $args{endsym} // 'nofun';
local $sym = $args{sym} // 'while';


my $C = $self;
my $S = $C->{'_pos'};
$C->{'sym'} = $sym;

$self->_MATCHIFYr($S, "statement_mod_loop__S_069while", 
do {
if (my ($C) = ($C->_PATTERN(qr/\Gwhile/))) {
do {
if (my ($C) = ($C->nofun)) {
do {
if (my ($C) = ($C->ws)) {
do {
if (my ($C) = ($C->_SUBSUMEr(['modifier_expr'], sub {
my $C = shift;
$C->modifier_expr
}))) {
$C->ws;
}
else {
();
}
};
}
else {
();
}
};
}
else {
();
}
};
}
else {
();
}
}
);
}
## rule statement_mod_loop__S_070until (:$endsym is context = 'nofun', :$sym is context<rw> = 'until')
##      rule statement_mod_loop:until {<sym> <modifier_expr> }

sub statement_mod_loop__S_070until__PEEK { $_[0]->_AUTOLEXpeek('statement_mod_loop__S_070until',$retree) }
sub statement_mod_loop__S_070until {
my $self = shift;
local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;
my %args = @_;
local $endsym = $args{endsym} // 'nofun';
local $sym = $args{sym} // 'until';


my $C = $self;
my $S = $C->{'_pos'};
$C->{'sym'} = $sym;

$self->_MATCHIFYr($S, "statement_mod_loop__S_070until", 
do {
if (my ($C) = ($C->_PATTERN(qr/\Guntil/))) {
do {
if (my ($C) = ($C->nofun)) {
do {
if (my ($C) = ($C->ws)) {
do {
if (my ($C) = ($C->_SUBSUMEr(['modifier_expr'], sub {
my $C = shift;
$C->modifier_expr
}))) {
$C->ws;
}
else {
();
}
};
}
else {
();
}
};
}
else {
();
}
};
}
else {
();
}
}
);
}

## rule statement_mod_loop__S_071for (:$endsym is context = 'nofun', :$sym is context<rw> = 'for')
##      rule statement_mod_loop:for   {<sym> <modifier_expr> }

sub statement_mod_loop__S_071for__PEEK { $_[0]->_AUTOLEXpeek('statement_mod_loop__S_071for',$retree) }
sub statement_mod_loop__S_071for {
my $self = shift;
local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;
my %args = @_;
local $endsym = $args{endsym} // 'nofun';
local $sym = $args{sym} // 'for';


my $C = $self;
my $S = $C->{'_pos'};
$C->{'sym'} = $sym;

$self->_MATCHIFYr($S, "statement_mod_loop__S_071for", 
do {
if (my ($C) = ($C->_PATTERN(qr/\Gfor/))) {
do {
if (my ($C) = ($C->nofun)) {
do {
if (my ($C) = ($C->ws)) {
do {
if (my ($C) = ($C->_SUBSUMEr(['modifier_expr'], sub {
my $C = shift;
$C->modifier_expr
}))) {
$C->ws;
}
else {
();
}
};
}
else {
();
}
};
}
else {
();
}
};
}
else {
();
}
}
);
}
## rule statement_mod_loop__S_072given (:$endsym is context = 'nofun', :$sym is context<rw> = 'given')
##      rule statement_mod_loop:given {<sym> <modifier_expr> }

sub statement_mod_loop__S_072given__PEEK { $_[0]->_AUTOLEXpeek('statement_mod_loop__S_072given',$retree) }
sub statement_mod_loop__S_072given {
my $self = shift;
local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;
my %args = @_;
local $endsym = $args{endsym} // 'nofun';
local $sym = $args{sym} // 'given';


my $C = $self;
my $S = $C->{'_pos'};
$C->{'sym'} = $sym;

$self->_MATCHIFYr($S, "statement_mod_loop__S_072given", 
do {
if (my ($C) = ($C->_PATTERN(qr/\Ggiven/))) {
do {
if (my ($C) = ($C->nofun)) {
do {
if (my ($C) = ($C->ws)) {
do {
if (my ($C) = ($C->_SUBSUMEr(['modifier_expr'], sub {
my $C = shift;
$C->modifier_expr
}))) {
$C->ws;
}
else {
();
}
};
}
else {
();
}
};
}
else {
();
}
};
}
else {
();
}
}
);
}

################
# module names #
################

## token def_module_name
##      token def_module_name {
##          <longname>
##          [ :dba('generic role')
##              <?before '['>
##              <?{ ($*PKGDECL//'') eq 'role' }>
##              <.newpad>
##              '[' ~ ']' <signature>
##              { $*IN_DECL = 0; }
##              <.finishpad>
##          ]?
##      }

sub def_module_name__PEEK { $_[0]->_AUTOLEXpeek('def_module_name',$retree) }
sub def_module_name {
my $self = shift;
local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;


my $C = $self;
my $S = $C->{'_pos'};
$C->{'signature'} = [];

$self->_MATCHIFY($S, "def_module_name", 
Cursor::lazymap(sub { my $C=$_[0];
$C->_OPTr(sub { my $C=shift;
$C->_BRACKET( sub { my $C=shift;
Cursor::lazymap(sub { my $C=$_[0];
Cursor::lazymap(sub { my $C=$_[0];
Cursor::lazymap(sub { my $C=$_[0];
Cursor::lazymap(sub { my $C=$_[0];
Cursor::lazymap(sub { my $C=$_[0];
Cursor::lazymap(sub { my $C=$_[0];
Cursor::lazymap(sub { my $C=$_[0];
Cursor::lazymap(sub { my $C=$_[0];
$C->finishpad
}, scalar(do {
$::IN_DECL = 0; 
}, $C))
}, $C->_BRACKET( sub { my $C=shift;
do { my @gather;
eval { push @gather, $C->_EXACT(']')} // do {die $@ if $@ and $@ !~ /ABORT/;1} 
or
eval { push @gather, $C->FAILGOAL(']' , 'generic role')} or do { die $@ if $@ };
@gather;
}
}))
}, $C->_SUBSUME(['signature'], sub {
my $C = shift;
$C->signature
}))
}, $C->_COMMITBRANCH(local $::GOAL = ']' ))
}, $C->_EXACT('['))
}, $C->newpad)
}, $C->before( sub { my $C=shift;
(($C) x !!do {
($::PKGDECL//'') eq 'role' 
})
}))
}, $C->before(sub { my $C=shift;
$C->_EXACT('[')
}))
})
})
}, $C->_SUBSUMEr(['longname'], sub {
my $C = shift;
$C->longname
}))
);
}

## token module_name__S_073normal (:$sym is context<rw> = 'normal')
##      token module_name:normal {
##          <longname>
##          [ <?before '['> :dba('generic role') '[' ~ ']' <arglist> ]?
##      }

sub module_name__S_073normal__PEEK { $_[0]->_AUTOLEXpeek('module_name__S_073normal',$retree) }
sub module_name__S_073normal {
my $self = shift;
local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;
my %args = @_;
local $sym = $args{sym} // 'normal';


my $C = $self;
my $S = $C->{'_pos'};
$C->{'arglist'} = [];
$C->{'sym'} = $sym;

$self->_MATCHIFY($S, "module_name__S_073normal", 
Cursor::lazymap(sub { my $C=$_[0];
$C->_OPTr(sub { my $C=shift;
$C->_BRACKET( sub { my $C=shift;
Cursor::lazymap(sub { my $C=$_[0];
Cursor::lazymap(sub { my $C=$_[0];
Cursor::lazymap(sub { my $C=$_[0];
Cursor::lazymap(sub { my $C=$_[0];
$C->_BRACKET( sub { my $C=shift;
do { my @gather;
eval { push @gather, $C->_EXACT(']')} // do {die $@ if $@ and $@ !~ /ABORT/;1} 
or
eval { push @gather, $C->FAILGOAL(']' , 'generic role')} or do { die $@ if $@ };
@gather;
}
})
}, $C->_SUBSUME(['arglist'], sub {
my $C = shift;
$C->arglist
}))
}, $C->_COMMITBRANCH(local $::GOAL = ']' ))
}, $C->_EXACT('['))
}, $C->before(sub { my $C=shift;
$C->_EXACT('[')
}))
})
})
}, $C->_SUBSUMEr(['longname'], sub {
my $C = shift;
$C->longname
}))
);
}

## token module_name__S_074deprecated (:$sym is context<rw> = 'deprecated')
##      token module_name:deprecated { 'v6-alpha' }

sub module_name__S_074deprecated__PEEK { $_[0]->_AUTOLEXpeek('module_name__S_074deprecated',$retree) }
sub module_name__S_074deprecated {
my $self = shift;
local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;
my %args = @_;
local $sym = $args{sym} // 'deprecated';


my $C = $self;
my $S = $C->{'_pos'};
$C->{'sym'} = $sym;

$self->_MATCHIFYr($S, "module_name__S_074deprecated", 
$C->_EXACT('v6-alpha')
);
}

## token vnum
##      token vnum {
##          \d+ | '*'
##      }

sub vnum__PEEK { $_[0]->_AUTOLEXpeek('vnum',$retree) }
sub vnum {
my $self = shift;
local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;


my $C = $self;
my $S = $C->{'_pos'};

$self->_MATCHIFYr($S, "vnum", 
do {
my @result = eval {
my $trystate;
my ($tag, $try);
my @try;
my $relex;

my $fate;
if ($fate = $C->{'_fate'} and $fate->[1] eq 'vnum_00') {
$C->deb("Fate passed to vnum_00: ", ::fatestr($fate)) if $::DEBUG & DEBUG::fates;
($C->{'_fate'}, $tag, $try) = @$fate;
@try = ($try);
}

my @gather = ();
for (;;) {
if (not @try) {
$relex //= $C->cursor_fate('STD', 'vnum_00', $retree);
@try = $relex->($C, $trystate);
}
last unless @try;
$try = shift(@try) // next;

if (ref $try eq 'ARRAY') {
($C->{'_fate'}, $tag, $try) = @$try;	# next candidate fate
}

$C->deb("vnum_00 trying $tag $try") if $::DEBUG & DEBUG::try_processing;
push @gather, ((
sub { my $C=shift;
$C->_PATTERN(qr/\G((?:\d)++)/)
},
sub { my $C=shift;
$C->_EXACT('*')
},
)[$try])->($C);
last if @gather;
}
@gather;
};
if (@result) {
@result;
}
elsif ($@) {
my ($first) = $@ =~ /(^.*)/;
$self->deb("CAUGHT $first") if $::DEBUG & DEBUG::trace_call;
die $@ if $@ !~ /^ABORTBRANCH/;
();
}
else {
();
}
}

);
}

## token version__S_075v (:$sym is context<rw> = <v>)
##      token version:sym<v> {
##          'v' <?before \d+> :: <vnum> ** '.' '+'?
##      }

sub version__S_075v__PEEK { $_[0]->_AUTOLEXpeek('version__S_075v',$retree) }
sub version__S_075v {
my $self = shift;
local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;
my %args = @_;
local $sym = $args{sym} // q(v);


my $C = $self;
my $S = $C->{'_pos'};
$C->{'vnum'} = [];
$C->{'sym'} = $sym;

$self->_MATCHIFY($S, "version__S_075v", 
Cursor::lazymap(sub { my $C=$_[0];
Cursor::lazymap(sub { my $C=$_[0];
Cursor::lazymap(sub { my $C=$_[0];
Cursor::lazymap(sub { my $C=$_[0];
$C->_OPTr(sub { my $C=shift;
$C->_EXACT('+')
})
}, $C->_REPSEPr(  sub { my $C=shift;
$C->_EXACT('.')
}, sub { my $C=shift;
$C->_SUBSUME(['vnum'], sub {
my $C = shift;
$C->vnum
})
}))
}, $C->_COMMITBRANCH())
}, $C->before(sub { my $C=shift;
$C->_PATTERN(qr/\G((?:\d)++)/)
}))
}, $C->_EXACT('v'))
);
}

###############
# Declarators #
###############

## token constant_declarator
##      token constant_declarator {
##          :my $IN_DECL is context<rw> = 1;
##          :my $DECLARAND is context<rw>;
##          <?{ $*SCOPE eq 'constant' }>
##          <identifier> <.ws> <?before '='|'is'\s>
##          { $*IN_DECL = 0; self.add_name($<identifier>.Str) }
##      
##          <trait>*
##      }

sub constant_declarator__PEEK { $_[0]->_AUTOLEXpeek('constant_declarator',$retree) }
sub constant_declarator {
my $self = shift;
local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;
local $::IN_DECL = 1;
local $::DECLARAND;


my $C = $self;
my $S = $C->{'_pos'};
$C->{'trait'} = [];

$self->_MATCHIFYr($S, "constant_declarator", 
do {
if (my ($C) = ($C->before( sub { my $C=shift;
(($C) x !!do {
$::SCOPE eq 'constant' 
})
}))) {
do {
if (my ($C) = ($C->_SUBSUMEr(['identifier'], sub {
my $C = shift;
$C->identifier
}))) {
do {
if (my ($C) = ($C->ws)) {
do {
if (my ($C) = ($C->before(sub { my $C=shift;
do {
my @result = eval {
my $trystate;
my ($tag, $try);
my @try;
my $relex;

my $fate;
if ($fate = $C->{'_fate'} and $fate->[1] eq 'constant_declarator_01') {
$C->deb("Fate passed to constant_declarator_01: ", ::fatestr($fate)) if $::DEBUG & DEBUG::fates;
($C->{'_fate'}, $tag, $try) = @$fate;
@try = ($try);
}

my @gather = ();
for (;;) {
if (not @try) {
$relex //= $C->cursor_fate('STD', 'constant_declarator_01', $retree);
@try = $relex->($C, $trystate);
}
last unless @try;
$try = shift(@try) // next;

if (ref $try eq 'ARRAY') {
($C->{'_fate'}, $tag, $try) = @$try;	# next candidate fate
}

$C->deb("constant_declarator_01 trying $tag $try") if $::DEBUG & DEBUG::try_processing;
push @gather, ((
sub { my $C=shift;
$C->_EXACT('=')
},
sub { my $C=shift;
do {
if (my ($C) = ($C->_EXACT('is'))) {
$C->_PATTERN(qr/\G\s/);
}
else {
();
}
}
},
)[$try])->($C);
last if @gather;
}
@gather;
};
if (@result) {
@result;
}
elsif ($@) {
my ($first) = $@ =~ /(^.*)/;
$self->deb("CAUGHT $first") if $::DEBUG & DEBUG::trace_call;
die $@ if $@ !~ /^ABORTBRANCH/;
();
}
else {
();
}
}

}))) {
do {
if (my ($C) = (scalar(do {
my $M = $C;  $::IN_DECL = 0; $self->add_name($M->{'identifier'}->Str) ;
}, $C))) {
$C->_STARr(sub { my $C=shift;
$C->_SUBSUMEr(['trait'], sub {
my $C = shift;
$C->trait
})
});
}
else {
();
}
};
}
else {
();
}
};
}
else {
();
}
};
}
else {
();
}
};
}
else {
();
}
}
);
}

## token variable_declarator
##      token variable_declarator {
##          :my $IN_DECL is context<rw> = 1;
##          :my $DECLARAND is context<rw>;
##          <variable>
##          { $*IN_DECL = 0; self.add_variable($<variable>.Str) }
##          [   # Is it a shaped array or hash declaration?
##            #  <?{ $<sigil> eq '@' | '%' }>
##              <.unsp>?
##              $<shape> = [
##              | '(' ~ ')' <signature>
##              | :dba('shape definition') '[' ~ ']' <semilist>
##              | :dba('shape definition') '{' ~ '}' <semilist>
##              | <?before '<'> <postcircumfix>
##              ]*
##          ]?
##          <.ws>
##      
##          <trait>*
##      }

sub variable_declarator__PEEK { $_[0]->_AUTOLEXpeek('variable_declarator',$retree) }
sub variable_declarator {
my $self = shift;
local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;
local $::IN_DECL = 1;
local $::DECLARAND;


my $C = $self;
my $S = $C->{'_pos'};
$C->{'trait'} = [];
$C->{'signature'} = [];
$C->{'shape'} = [];
$C->{'postcircumfix'} = [];
$C->{'semilist'} = [];

$self->_MATCHIFY($S, "variable_declarator", 
Cursor::lazymap(sub { my $C=$_[0];
Cursor::lazymap(sub { my $C=$_[0];
Cursor::lazymap(sub { my $C=$_[0];
Cursor::lazymap(sub { my $C=$_[0];
$C->_STARr(sub { my $C=shift;
$C->_SUBSUME(['trait'], sub {
my $C = shift;
$C->trait
})
})
}, $C->ws)
}, $C->_OPTr(sub { my $C=shift;
$C->_BRACKET( sub { my $C=shift;
Cursor::lazymap(sub { my $C=$_[0];
$C->_STARr(sub { my $C=shift;
$C->_SUBSUME(['shape'], sub {
my $C = shift;
$C->_BRACKET( sub { my $C=shift;
do {
my @result = eval {
my $trystate;
my ($tag, $try);
my @try;
my $relex;

my $fate;
if ($fate = $C->{'_fate'} and $fate->[1] eq 'variable_declarator_02') {
$C->deb("Fate passed to variable_declarator_02: ", ::fatestr($fate)) if $::DEBUG & DEBUG::fates;
($C->{'_fate'}, $tag, $try) = @$fate;
@try = ($try);
}

my @gather = ();
for (;;) {
if (not @try) {
$relex //= $C->cursor_fate('STD', 'variable_declarator_02', $retree);
@try = $relex->($C, $trystate);
}
last unless @try;
$try = shift(@try) // next;

if (ref $try eq 'ARRAY') {
($C->{'_fate'}, $tag, $try) = @$try;	# next candidate fate
}

$C->deb("variable_declarator_02 trying $tag $try") if $::DEBUG & DEBUG::try_processing;
push @gather, ((
sub { my $C=shift;
Cursor::lazymap(sub { my $C=$_[0];
Cursor::lazymap(sub { my $C=$_[0];
Cursor::lazymap(sub { my $C=$_[0];
$C->_BRACKET( sub { my $C=shift;
do { my @gather;
eval { push @gather, $C->_EXACT(')')} // do {die $@ if $@ and $@ !~ /ABORT/;1} 
or
eval { push @gather, $C->FAILGOAL(')' , 'variable_declarator')} or do { die $@ if $@ };
@gather;
}
})
}, $C->_SUBSUME(['signature'], sub {
my $C = shift;
$C->signature
}))
}, $C->_COMMITBRANCH(local $::GOAL = ')' ))
}, $C->_EXACT('('))
},
sub { my $C=shift;
Cursor::lazymap(sub { my $C=$_[0];
Cursor::lazymap(sub { my $C=$_[0];
Cursor::lazymap(sub { my $C=$_[0];
$C->_BRACKET( sub { my $C=shift;
do { my @gather;
eval { push @gather, $C->_EXACT(']')} // do {die $@ if $@ and $@ !~ /ABORT/;1} 
or
eval { push @gather, $C->FAILGOAL(']' , 'shape definition')} or do { die $@ if $@ };
@gather;
}
})
}, $C->_SUBSUME(['semilist'], sub {
my $C = shift;
$C->semilist
}))
}, $C->_COMMITBRANCH(local $::GOAL = ']' ))
}, $C->_EXACT('['))
},
sub { my $C=shift;
Cursor::lazymap(sub { my $C=$_[0];
Cursor::lazymap(sub { my $C=$_[0];
Cursor::lazymap(sub { my $C=$_[0];
$C->_BRACKET( sub { my $C=shift;
do { my @gather;
eval { push @gather, $C->_EXACT('}')} // do {die $@ if $@ and $@ !~ /ABORT/;1} 
or
eval { push @gather, $C->FAILGOAL('}' , 'shape definition')} or do { die $@ if $@ };
@gather;
}
})
}, $C->_SUBSUME(['semilist'], sub {
my $C = shift;
$C->semilist
}))
}, $C->_COMMITBRANCH(local $::GOAL = '}' ))
}, $C->_EXACT('{'))
},
sub { my $C=shift;
Cursor::lazymap(sub { my $C=$_[0];
$C->_SUBSUME(['postcircumfix'], sub {
my $C = shift;
$C->postcircumfix
})
}, $C->before(sub { my $C=shift;
$C->_EXACT('<')
}))
},
)[$try])->($C);
last if @gather;
}
@gather;
};
if (@result) {
@result;
}
elsif ($@) {
my ($first) = $@ =~ /(^.*)/;
$self->deb("CAUGHT $first") if $::DEBUG & DEBUG::trace_call;
die $@ if $@ !~ /^ABORTBRANCH/;
();
}
else {
();
}
}

})
})
})
}, $C->_OPTr(sub { my $C=shift;
$C->unsp
}))
})
}))
}, scalar(do {
my $M = $C;  $::IN_DECL = 0; $self->add_variable($M->{'variable'}->Str) ;
}, $C))
}, $C->_SUBSUMEr(['variable'], sub {
my $C = shift;
$C->variable
}))
);
}

## rule scoped
##      rule scoped {
##          :dba('scoped declarator')
##          [
##          | <declarator>
##          | <regex_declarator>
##          | <package_declarator>
##          | <typename>+
##              {
##                  my $t = $<typename>;
##                  @$t > 1 and $¢.panic("Multiple prefix constraints not yet supported")
##              }
##              <multi_declarator>
##          | <multi_declarator>
##          ]
##          || <?before <[A..Z]>><longname>{{
##                  my $t = $<longname>.Str;
##                  if not $¢.is_known($t) {
##                      $¢.panic("In \"$*SCOPE\" declaration, typename $t must be predeclared (or marked as declarative with :: prefix)");
##                  }
##              }}
##              <!> # drop through
##          || <.panic: "Malformed $*SCOPE">
##      }

sub scoped__PEEK { $_[0]->_AUTOLEXpeek('scoped',$retree) }
sub scoped {
my $self = shift;
local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;


my $C = $self;
my $S = $C->{'_pos'};
$C->{'typename'} = [];

$self->_MATCHIFYr($S, "scoped", 
do { my @gather;
eval { push @gather, do {
if (my ($C) = ($C->ws)) {
do {
if (my ($C) = ($C->ws)) {
do {
if (my ($C) = ($C->_BRACKETr( sub { my $C=shift;
do {
my @result = eval {
my $trystate;
my ($tag, $try);
my @try;
my $relex;

my $fate;
if ($fate = $C->{'_fate'} and $fate->[1] eq 'scoped_01') {
$C->deb("Fate passed to scoped_01: ", ::fatestr($fate)) if $::DEBUG & DEBUG::fates;
($C->{'_fate'}, $tag, $try) = @$fate;
@try = ($try);
}

my @gather = ();
for (;;) {
if (not @try) {
$relex //= $C->cursor_fate('STD', 'scoped_01', $retree);
@try = $relex->($C, $trystate);
}
last unless @try;
$try = shift(@try) // next;

if (ref $try eq 'ARRAY') {
($C->{'_fate'}, $tag, $try) = @$try;	# next candidate fate
}

$C->deb("scoped_01 trying $tag $try") if $::DEBUG & DEBUG::try_processing;
push @gather, ((
sub { my $C=shift;
do {
if (my ($C) = ($C->_SUBSUMEr(['declarator'], sub {
my $C = shift;
$C->declarator
}))) {
$C->ws;
}
else {
();
}
}
},
sub { my $C=shift;
do {
if (my ($C) = ($C->_SUBSUMEr(['regex_declarator'], sub {
my $C = shift;
$C->regex_declarator
}))) {
$C->ws;
}
else {
();
}
}
},
sub { my $C=shift;
do {
if (my ($C) = ($C->_SUBSUMEr(['package_declarator'], sub {
my $C = shift;
$C->package_declarator
}))) {
$C->ws;
}
else {
();
}
}
},
sub { my $C=shift;
do {
if (my ($C) = ($C->_PLUSr(sub { my $C=shift;
$C->_SUBSUMEr(['typename'], sub {
my $C = shift;
$C->typename
})
}))) {
do {
if (my ($C) = ($C->ws)) {
do {
if (my ($C) = (scalar(do {
my $M = $C; 
my $t = $M->{'typename'};
@$t > 1 and $C->panic("Multiple prefix constraints not yet supported")
;
}, $C))) {
do {
if (my ($C) = ($C->ws)) {
do {
if (my ($C) = ($C->_SUBSUMEr(['multi_declarator'], sub {
my $C = shift;
$C->multi_declarator
}))) {
$C->ws;
}
else {
();
}
};
}
else {
();
}
};
}
else {
();
}
};
}
else {
();
}
};
}
else {
();
}
}
},
sub { my $C=shift;
do {
if (my ($C) = ($C->_SUBSUMEr(['multi_declarator'], sub {
my $C = shift;
$C->multi_declarator
}))) {
$C->ws;
}
else {
();
}
}
},
)[$try])->($C);
last if @gather;
}
@gather;
};
if (@result) {
@result;
}
elsif ($@) {
my ($first) = $@ =~ /(^.*)/;
$self->deb("CAUGHT $first") if $::DEBUG & DEBUG::trace_call;
die $@ if $@ !~ /^ABORTBRANCH/;
();
}
else {
();
}
}

}))) {
$C->ws;
}
else {
();
}
};
}
else {
();
}
};
}
else {
();
}
}} // do {die $@ if $@ and $@ !~ /ABORT/;1} 
or
eval { push @gather, do {
if (my ($C) = ($C->ws)) {
do {
if (my ($C) = ($C->before(sub { my $C=shift;
$C->_PATTERN(qr/\G[A-Z]/)
}))) {
do {
if (my ($C) = ($C->_SUBSUMEr(['longname'], sub {
my $C = shift;
$C->longname
}))) {
do {
if (my ($C) = (scalar(do {
my $M = $C; 
my $t = $M->{'longname'}->Str;
if (not $C->is_known($t)) {
$C->panic("In \"$::SCOPE\" declaration, typename $t must be predeclared (or marked as declarative with :: prefix)");
}
;
}, $C))) {
do {
if (my ($C) = ($C->ws)) {
do {
if (my ($C) = ($C->_NOTBEFORE( sub { my $C=shift;
$C
}))) {
$C->ws;
}
else {
();
}
};
}
else {
();
}
};
}
else {
();
}
};
}
else {
();
}
};
}
else {
();
}
};
}
else {
();
}
}} // do {die $@ if $@ and $@ !~ /ABORT/;1} 
or
eval { push @gather, do {
if (my ($C) = ($C->ws)) {
do {
if (my ($C) = ($C->panic("Malformed $::SCOPE"))) {
$C->ws;
}
else {
();
}
};
}
else {
();
}
}} or do { die $@ if $@ };
@gather;
}
);
}


## token scope_declarator__S_076my (:$endsym is context = 'nofun', :$sym is context<rw> = 'my')
##      token scope_declarator:my        { <sym> { $*SCOPE = $<sym> } <scoped> }

sub scope_declarator__S_076my__PEEK { $_[0]->_AUTOLEXpeek('scope_declarator__S_076my',$retree) }
sub scope_declarator__S_076my {
my $self = shift;
local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;
my %args = @_;
local $endsym = $args{endsym} // 'nofun';
local $sym = $args{sym} // 'my';


my $C = $self;
my $S = $C->{'_pos'};
$C->{'sym'} = $sym;

$self->_MATCHIFYr($S, "scope_declarator__S_076my", 
do {
if (my ($C) = ($C->_PATTERN(qr/\Gmy/))) {
do {
if (my ($C) = ($C->nofun)) {
do {
if (my ($C) = (scalar(do {
my $M = $C;  $::SCOPE = $M->{'sym'} ;
}, $C))) {
$C->_SUBSUMEr(['scoped'], sub {
my $C = shift;
$C->scoped
});
}
else {
();
}
};
}
else {
();
}
};
}
else {
();
}
}
);
}
## token scope_declarator__S_077our (:$endsym is context = 'nofun', :$sym is context<rw> = 'our')
##      token scope_declarator:our       { <sym> { $*SCOPE = $<sym> } <scoped> }

sub scope_declarator__S_077our__PEEK { $_[0]->_AUTOLEXpeek('scope_declarator__S_077our',$retree) }
sub scope_declarator__S_077our {
my $self = shift;
local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;
my %args = @_;
local $endsym = $args{endsym} // 'nofun';
local $sym = $args{sym} // 'our';


my $C = $self;
my $S = $C->{'_pos'};
$C->{'sym'} = $sym;

$self->_MATCHIFYr($S, "scope_declarator__S_077our", 
do {
if (my ($C) = ($C->_PATTERN(qr/\Gour/))) {
do {
if (my ($C) = ($C->nofun)) {
do {
if (my ($C) = (scalar(do {
my $M = $C;  $::SCOPE = $M->{'sym'} ;
}, $C))) {
$C->_SUBSUMEr(['scoped'], sub {
my $C = shift;
$C->scoped
});
}
else {
();
}
};
}
else {
();
}
};
}
else {
();
}
}
);
}
## token scope_declarator__S_078state (:$endsym is context = 'nofun', :$sym is context<rw> = 'state')
##      token scope_declarator:state     { <sym> { $*SCOPE = $<sym> } <scoped> }

sub scope_declarator__S_078state__PEEK { $_[0]->_AUTOLEXpeek('scope_declarator__S_078state',$retree) }
sub scope_declarator__S_078state {
my $self = shift;
local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;
my %args = @_;
local $endsym = $args{endsym} // 'nofun';
local $sym = $args{sym} // 'state';


my $C = $self;
my $S = $C->{'_pos'};
$C->{'sym'} = $sym;

$self->_MATCHIFYr($S, "scope_declarator__S_078state", 
do {
if (my ($C) = ($C->_PATTERN(qr/\Gstate/))) {
do {
if (my ($C) = ($C->nofun)) {
do {
if (my ($C) = (scalar(do {
my $M = $C;  $::SCOPE = $M->{'sym'} ;
}, $C))) {
$C->_SUBSUMEr(['scoped'], sub {
my $C = shift;
$C->scoped
});
}
else {
();
}
};
}
else {
();
}
};
}
else {
();
}
}
);
}
## token scope_declarator__S_079constant (:$endsym is context = 'nofun', :$sym is context<rw> = 'constant')
##      token scope_declarator:constant  { <sym> { $*SCOPE = $<sym> } <scoped> }

sub scope_declarator__S_079constant__PEEK { $_[0]->_AUTOLEXpeek('scope_declarator__S_079constant',$retree) }
sub scope_declarator__S_079constant {
my $self = shift;
local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;
my %args = @_;
local $endsym = $args{endsym} // 'nofun';
local $sym = $args{sym} // 'constant';


my $C = $self;
my $S = $C->{'_pos'};
$C->{'sym'} = $sym;

$self->_MATCHIFYr($S, "scope_declarator__S_079constant", 
do {
if (my ($C) = ($C->_PATTERN(qr/\Gconstant/))) {
do {
if (my ($C) = ($C->nofun)) {
do {
if (my ($C) = (scalar(do {
my $M = $C;  $::SCOPE = $M->{'sym'} ;
}, $C))) {
$C->_SUBSUMEr(['scoped'], sub {
my $C = shift;
$C->scoped
});
}
else {
();
}
};
}
else {
();
}
};
}
else {
();
}
}
);
}
## token scope_declarator__S_080has (:$endsym is context = 'nofun', :$sym is context<rw> = 'has')
##      token scope_declarator:has       { <sym> { $*SCOPE = $<sym> } <scoped> }

sub scope_declarator__S_080has__PEEK { $_[0]->_AUTOLEXpeek('scope_declarator__S_080has',$retree) }
sub scope_declarator__S_080has {
my $self = shift;
local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;
my %args = @_;
local $endsym = $args{endsym} // 'nofun';
local $sym = $args{sym} // 'has';


my $C = $self;
my $S = $C->{'_pos'};
$C->{'sym'} = $sym;

$self->_MATCHIFYr($S, "scope_declarator__S_080has", 
do {
if (my ($C) = ($C->_PATTERN(qr/\Ghas/))) {
do {
if (my ($C) = ($C->nofun)) {
do {
if (my ($C) = (scalar(do {
my $M = $C;  $::SCOPE = $M->{'sym'} ;
}, $C))) {
$C->_SUBSUMEr(['scoped'], sub {
my $C = shift;
$C->scoped
});
}
else {
();
}
};
}
else {
();
}
};
}
else {
();
}
}
);
}
## token scope_declarator__S_081augment (:$endsym is context = 'nofun', :$sym is context<rw> = 'augment')
##      token scope_declarator:augment   { <sym> { $*SCOPE = $<sym> } <scoped> }

sub scope_declarator__S_081augment__PEEK { $_[0]->_AUTOLEXpeek('scope_declarator__S_081augment',$retree) }
sub scope_declarator__S_081augment {
my $self = shift;
local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;
my %args = @_;
local $endsym = $args{endsym} // 'nofun';
local $sym = $args{sym} // 'augment';


my $C = $self;
my $S = $C->{'_pos'};
$C->{'sym'} = $sym;

$self->_MATCHIFYr($S, "scope_declarator__S_081augment", 
do {
if (my ($C) = ($C->_PATTERN(qr/\Gaugment/))) {
do {
if (my ($C) = ($C->nofun)) {
do {
if (my ($C) = (scalar(do {
my $M = $C;  $::SCOPE = $M->{'sym'} ;
}, $C))) {
$C->_SUBSUMEr(['scoped'], sub {
my $C = shift;
$C->scoped
});
}
else {
();
}
};
}
else {
();
}
};
}
else {
();
}
}
);
}
## token scope_declarator__S_082supersede (:$endsym is context = 'nofun', :$sym is context<rw> = 'supersede')
##      token scope_declarator:supersede { <sym> { $*SCOPE = $<sym> } <scoped> }

sub scope_declarator__S_082supersede__PEEK { $_[0]->_AUTOLEXpeek('scope_declarator__S_082supersede',$retree) }
sub scope_declarator__S_082supersede {
my $self = shift;
local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;
my %args = @_;
local $endsym = $args{endsym} // 'nofun';
local $sym = $args{sym} // 'supersede';


my $C = $self;
my $S = $C->{'_pos'};
$C->{'sym'} = $sym;

$self->_MATCHIFYr($S, "scope_declarator__S_082supersede", 
do {
if (my ($C) = ($C->_PATTERN(qr/\Gsupersede/))) {
do {
if (my ($C) = ($C->nofun)) {
do {
if (my ($C) = (scalar(do {
my $M = $C;  $::SCOPE = $M->{'sym'} ;
}, $C))) {
$C->_SUBSUMEr(['scoped'], sub {
my $C = shift;
$C->scoped
});
}
else {
();
}
};
}
else {
();
}
};
}
else {
();
}
}
);
}


## token package_declarator__S_083class (:$endsym is context = 'spacey', :$sym is context<rw> = 'class')
##      token package_declarator:class {
##          :my $PKGDECL is context = 'class';
##          <sym> <package_def>
##      }

sub package_declarator__S_083class__PEEK { $_[0]->_AUTOLEXpeek('package_declarator__S_083class',$retree) }
sub package_declarator__S_083class {
my $self = shift;
local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;
my %args = @_;
local $endsym = $args{endsym} // 'spacey';
local $sym = $args{sym} // 'class';
local $::PKGDECL = 'class';


my $C = $self;
my $S = $C->{'_pos'};
$C->{'sym'} = $sym;

$self->_MATCHIFYr($S, "package_declarator__S_083class", 
do {
if (my ($C) = ($C->_PATTERN(qr/\Gclass/))) {
do {
if (my ($C) = ($C->spacey)) {
$C->_SUBSUMEr(['package_def'], sub {
my $C = shift;
$C->package_def
});
}
else {
();
}
};
}
else {
();
}
}
);
}

## token package_declarator__S_084grammar (:$endsym is context = 'spacey', :$sym is context<rw> = 'grammar')
##      token package_declarator:grammar {
##          :my $PKGDECL is context = 'grammar';
##          <sym> <package_def>
##      }

sub package_declarator__S_084grammar__PEEK { $_[0]->_AUTOLEXpeek('package_declarator__S_084grammar',$retree) }
sub package_declarator__S_084grammar {
my $self = shift;
local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;
my %args = @_;
local $endsym = $args{endsym} // 'spacey';
local $sym = $args{sym} // 'grammar';
local $::PKGDECL = 'grammar';


my $C = $self;
my $S = $C->{'_pos'};
$C->{'sym'} = $sym;

$self->_MATCHIFYr($S, "package_declarator__S_084grammar", 
do {
if (my ($C) = ($C->_PATTERN(qr/\Ggrammar/))) {
do {
if (my ($C) = ($C->spacey)) {
$C->_SUBSUMEr(['package_def'], sub {
my $C = shift;
$C->package_def
});
}
else {
();
}
};
}
else {
();
}
}
);
}

## token package_declarator__S_085module (:$endsym is context = 'spacey', :$sym is context<rw> = 'module')
##      token package_declarator:module {
##          :my $PKGDECL is context = 'module';
##          <sym> <package_def>
##      }

sub package_declarator__S_085module__PEEK { $_[0]->_AUTOLEXpeek('package_declarator__S_085module',$retree) }
sub package_declarator__S_085module {
my $self = shift;
local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;
my %args = @_;
local $endsym = $args{endsym} // 'spacey';
local $sym = $args{sym} // 'module';
local $::PKGDECL = 'module';


my $C = $self;
my $S = $C->{'_pos'};
$C->{'sym'} = $sym;

$self->_MATCHIFYr($S, "package_declarator__S_085module", 
do {
if (my ($C) = ($C->_PATTERN(qr/\Gmodule/))) {
do {
if (my ($C) = ($C->spacey)) {
$C->_SUBSUMEr(['package_def'], sub {
my $C = shift;
$C->package_def
});
}
else {
();
}
};
}
else {
();
}
}
);
}

## token package_declarator__S_086package (:$endsym is context = 'spacey', :$sym is context<rw> = 'package')
##      token package_declarator:package {
##          :my $PKGDECL is context = 'package';
##          <sym> <package_def>
##      }

sub package_declarator__S_086package__PEEK { $_[0]->_AUTOLEXpeek('package_declarator__S_086package',$retree) }
sub package_declarator__S_086package {
my $self = shift;
local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;
my %args = @_;
local $endsym = $args{endsym} // 'spacey';
local $sym = $args{sym} // 'package';
local $::PKGDECL = 'package';


my $C = $self;
my $S = $C->{'_pos'};
$C->{'sym'} = $sym;

$self->_MATCHIFYr($S, "package_declarator__S_086package", 
do {
if (my ($C) = ($C->_PATTERN(qr/\Gpackage/))) {
do {
if (my ($C) = ($C->spacey)) {
$C->_SUBSUMEr(['package_def'], sub {
my $C = shift;
$C->package_def
});
}
else {
();
}
};
}
else {
();
}
}
);
}

## token package_declarator__S_087role (:$endsym is context = 'spacey', :$sym is context<rw> = 'role')
##      token package_declarator:role {
##          :my $PKGDECL is context = 'role';
##          <sym> <package_def>
##      }

sub package_declarator__S_087role__PEEK { $_[0]->_AUTOLEXpeek('package_declarator__S_087role',$retree) }
sub package_declarator__S_087role {
my $self = shift;
local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;
my %args = @_;
local $endsym = $args{endsym} // 'spacey';
local $sym = $args{sym} // 'role';
local $::PKGDECL = 'role';


my $C = $self;
my $S = $C->{'_pos'};
$C->{'sym'} = $sym;

$self->_MATCHIFYr($S, "package_declarator__S_087role", 
do {
if (my ($C) = ($C->_PATTERN(qr/\Grole/))) {
do {
if (my ($C) = ($C->spacey)) {
$C->_SUBSUMEr(['package_def'], sub {
my $C = shift;
$C->package_def
});
}
else {
();
}
};
}
else {
();
}
}
);
}

## token package_declarator__S_088knowhow (:$endsym is context = 'spacey', :$sym is context<rw> = 'knowhow')
##      token package_declarator:knowhow {
##          :my $PKGDECL is context = 'knowhow';
##          <sym> <package_def>
##      }

sub package_declarator__S_088knowhow__PEEK { $_[0]->_AUTOLEXpeek('package_declarator__S_088knowhow',$retree) }
sub package_declarator__S_088knowhow {
my $self = shift;
local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;
my %args = @_;
local $endsym = $args{endsym} // 'spacey';
local $sym = $args{sym} // 'knowhow';
local $::PKGDECL = 'knowhow';


my $C = $self;
my $S = $C->{'_pos'};
$C->{'sym'} = $sym;

$self->_MATCHIFYr($S, "package_declarator__S_088knowhow", 
do {
if (my ($C) = ($C->_PATTERN(qr/\Gknowhow/))) {
do {
if (my ($C) = ($C->spacey)) {
$C->_SUBSUMEr(['package_def'], sub {
my $C = shift;
$C->package_def
});
}
else {
();
}
};
}
else {
();
}
}
);
}

## token package_declarator__S_089slang (:$endsym is context = 'spacey', :$sym is context<rw> = 'slang')
##      token package_declarator:slang {
##          :my $PKGDECL is context = 'slang';
##          <sym> <package_def>
##      }

sub package_declarator__S_089slang__PEEK { $_[0]->_AUTOLEXpeek('package_declarator__S_089slang',$retree) }
sub package_declarator__S_089slang {
my $self = shift;
local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;
my %args = @_;
local $endsym = $args{endsym} // 'spacey';
local $sym = $args{sym} // 'slang';
local $::PKGDECL = 'slang';


my $C = $self;
my $S = $C->{'_pos'};
$C->{'sym'} = $sym;

$self->_MATCHIFYr($S, "package_declarator__S_089slang", 
do {
if (my ($C) = ($C->_PATTERN(qr/\Gslang/))) {
do {
if (my ($C) = ($C->spacey)) {
$C->_SUBSUMEr(['package_def'], sub {
my $C = shift;
$C->package_def
});
}
else {
();
}
};
}
else {
();
}
}
);
}

## token package_declarator__S_090require (:$endsym is context = 'spacey', :$sym is context<rw> = 'require')
##      token package_declarator:require {   # here because of declarational aspects
##          <sym> <.ws>
##          [
##          || <module_name> <EXPR>?
##          || <EXPR>
##          ]
##      }

sub package_declarator__S_090require__PEEK { $_[0]->_AUTOLEXpeek('package_declarator__S_090require',$retree) }
sub package_declarator__S_090require {
my $self = shift;
local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;
my %args = @_;
local $endsym = $args{endsym} // 'spacey';
local $sym = $args{sym} // 'require';


my $C = $self;
my $S = $C->{'_pos'};
$C->{'EXPR'} = [];
$C->{'sym'} = $sym;

$self->_MATCHIFYr($S, "package_declarator__S_090require", 
do {
if (my ($C) = ($C->_PATTERN(qr/\Grequire/))) {
do {
if (my ($C) = ($C->spacey)) {
do {
if (my ($C) = ($C->ws)) {
$C->_BRACKETr( sub { my $C=shift;
do { my @gather;
eval { push @gather, do {
if (my ($C) = ($C->_SUBSUMEr(['module_name'], sub {
my $C = shift;
$C->module_name
}))) {
$C->_OPTr(sub { my $C=shift;
$C->_SUBSUMEr(['EXPR'], sub {
my $C = shift;
$C->EXPR
})
});
}
else {
();
}
}} // do {die $@ if $@ and $@ !~ /ABORT/;1} 
or
eval { push @gather, $C->_SUBSUMEr(['EXPR'], sub {
my $C = shift;
$C->EXPR
})} or do { die $@ if $@ };
@gather;
}
});
}
else {
();
}
};
}
else {
();
}
};
}
else {
();
}
}
);
}

## token package_declarator__S_091trusts (:$endsym is context = 'spacey', :$sym is context<rw> = 'trusts')
##      token package_declarator:trusts {
##          <sym> <.ws>
##          <module_name>
##      }

sub package_declarator__S_091trusts__PEEK { $_[0]->_AUTOLEXpeek('package_declarator__S_091trusts',$retree) }
sub package_declarator__S_091trusts {
my $self = shift;
local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;
my %args = @_;
local $endsym = $args{endsym} // 'spacey';
local $sym = $args{sym} // 'trusts';


my $C = $self;
my $S = $C->{'_pos'};
$C->{'sym'} = $sym;

$self->_MATCHIFYr($S, "package_declarator__S_091trusts", 
do {
if (my ($C) = ($C->_PATTERN(qr/\Gtrusts/))) {
do {
if (my ($C) = ($C->spacey)) {
do {
if (my ($C) = ($C->ws)) {
$C->_SUBSUMEr(['module_name'], sub {
my $C = shift;
$C->module_name
});
}
else {
();
}
};
}
else {
();
}
};
}
else {
();
}
}
);
}

## token package_declarator__S_092does (:$endsym is context = 'spacey', :$sym is context<rw> = 'does')
##      token package_declarator:does {
##          <sym> <.ws>
##          <typename>
##      }

sub package_declarator__S_092does__PEEK { $_[0]->_AUTOLEXpeek('package_declarator__S_092does',$retree) }
sub package_declarator__S_092does {
my $self = shift;
local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;
my %args = @_;
local $endsym = $args{endsym} // 'spacey';
local $sym = $args{sym} // 'does';


my $C = $self;
my $S = $C->{'_pos'};
$C->{'sym'} = $sym;

$self->_MATCHIFYr($S, "package_declarator__S_092does", 
do {
if (my ($C) = ($C->_PATTERN(qr/\Gdoes/))) {
do {
if (my ($C) = ($C->spacey)) {
do {
if (my ($C) = ($C->ws)) {
$C->_SUBSUMEr(['typename'], sub {
my $C = shift;
$C->typename
});
}
else {
();
}
};
}
else {
();
}
};
}
else {
();
}
}
);
}

## rule package_def
##      rule package_def {
##          :my $longname;
##          :my $IN_DECL is context<rw> = 1;
##          :my $DECLARAND is context<rw>;
##          [
##              [
##                  <def_module_name>{
##                      $longname = $<def_module_name>[0]<longname>;
##                      $¢.add_name($longname.Str);
##                  }
##              ]?
##              <trait>*
##              [
##              || <?before '{'>
##                  {{
##                      # figure out the actual full package name (nested in outer package)
##                      my $pkg = $*PKGNAME || "GLOBAL";
##                      my $shortname;
##                      if $longname {
##                           $shortname = $longname.<name>.Str;
##                      }
##                      else {
##                          $shortname = '_anon_';
##                      }
##                      $*PKGNAME = $pkg ~ '::' ~ $shortname;
##                      my $newpkg = $*CURPKG.{$shortname ~ '::'};
##                      $newpkg.<PARENT::> = $*CURPKG;
##                      $*CURPKG = $newpkg;
##                      push @PKGS, $pkg;
##                      say "adding $newpkg " ~ $*PKGNAME if $*DEBUG +& DEBUG::symtab;
##                  }}
##      
##                  <block>
##                  {{
##                      $*PKGNAME = pop(@PKGS);
##                      $*CURPKG = $*CURPKG.<PARENT::>;
##                  }}
##                  {*}                                                     #= block
##              || <?before ';'>
##                  [
##                  || <?{ $*begin_compunit }>
##                      {{
##                          $longname orelse $¢.panic("Compilation unit cannot be anonymous");
##                          my $shortname = $longname.<name>.Str;
##                          $*PKGNAME = $shortname;
##                          my $newpkg = $*CURPKG.{$shortname ~ '::'};
##                          $newpkg.<PARENT::> = $*CURPKG;
##                          $*CURPKG = $newpkg;
##                          $*begin_compunit = 0;
##                      }}
##                      {*}                                                     #= semi
##                  || <.panic: "Too late for semicolon form of " ~ $*PKGDECL ~ " definition">
##                  ]
##              || <.panic: "Unable to parse " ~ $*PKGDECL ~ " definition">
##              ]
##          ] || <.panic: "Malformed $*PKGDECL">
##      }

sub package_def__PEEK { $_[0]->_AUTOLEXpeek('package_def',$retree) }
sub package_def {
my $self = shift;
local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;
my $longname;
local $::IN_DECL = 1;
local $::DECLARAND;


my $C = $self;
my $S = $C->{'_pos'};
$C->{'trait'} = [];
$C->{'def_module_name'} = [];

$self->_MATCHIFYr($S, "package_def", 
do { my @gather;
eval { push @gather, do {
if (my ($C) = ($C->ws)) {
do {
if (my ($C) = ($C->_BRACKETr( sub { my $C=shift;
do {
if (my ($C) = ($C->_OPTr(sub { my $C=shift;
$C->_BRACKETr( sub { my $C=shift;
do {
if (my ($C) = ($C->ws)) {
do {
if (my ($C) = ($C->_SUBSUMEr(['def_module_name'], sub {
my $C = shift;
$C->def_module_name
}))) {
do {
if (my ($C) = (scalar(do {
my $M = $C; 
$longname = $M->{'def_module_name'}[0]{'longname'};
$C->add_name($longname->Str);
;
}, $C))) {
$C->ws;
}
else {
();
}
};
}
else {
();
}
};
}
else {
();
}
}
})
}))) {
do {
if (my ($C) = ($C->ws)) {
do {
if (my ($C) = ($C->_STARr(sub { my $C=shift;
$C->_SUBSUMEr(['trait'], sub {
my $C = shift;
$C->trait
})
}))) {
do {
if (my ($C) = ($C->ws)) {
do {
if (my ($C) = ($C->_BRACKETr( sub { my $C=shift;
do { my @gather;
eval { push @gather, do {
if (my ($C) = ($C->before(sub { my $C=shift;
$C->_EXACT('{')
}))) {
do {
if (my ($C) = ($C->ws)) {
do {
if (my ($C) = (scalar(do {

# figure out the actual full package name (nested in outer package)
my $pkg = $::PKGNAME || "GLOBAL";
my $shortname;
if ($longname) {
$shortname = $longname->{'name'}->Str;
}
else {
$shortname = '_anon_';
}
$::PKGNAME = $pkg . '::' . $shortname;
my $newpkg = $::CURPKG->{$shortname . '::'};
$newpkg->{'PARENT::'} = $::CURPKG;
$::CURPKG = $newpkg;
push @PKGS, $pkg;
say "adding $newpkg " . $::PKGNAME if $::DEBUG & DEBUG::symtab;

}, $C))) {
do {
if (my ($C) = ($C->ws)) {
do {
if (my ($C) = ($C->_SUBSUMEr(['block'], sub {
my $C = shift;
$C->block
}))) {
do {
if (my ($C) = ($C->ws)) {
do {
if (my ($C) = (scalar(do {

$::PKGNAME = pop(@PKGS);
$::CURPKG = $::CURPKG->{'PARENT::'};

}, $C))) {
do {
if (my ($C) = ($C->ws)) {
do {
if (my ($C) = ($C->_REDUCE($S, 'package_def', 'block'))) {
$C->ws;
}
else {
();
}
};
}
else {
();
}
};
}
else {
();
}
};
}
else {
();
}
};
}
else {
();
}
};
}
else {
();
}
};
}
else {
();
}
};
}
else {
();
}
};
}
else {
();
}
}} // do {die $@ if $@ and $@ !~ /ABORT/;1} 
or
eval { push @gather, do {
if (my ($C) = ($C->before(sub { my $C=shift;
$C->_EXACT(';')
}))) {
do {
if (my ($C) = ($C->ws)) {
do {
if (my ($C) = ($C->_BRACKETr( sub { my $C=shift;
do { my @gather;
eval { push @gather, do {
if (my ($C) = ($C->before( sub { my $C=shift;
(($C) x !!do {
$::begin_compunit 
})
}))) {
do {
if (my ($C) = ($C->ws)) {
do {
if (my ($C) = (scalar(do {

$longname or $C->panic("Compilation unit cannot be anonymous");
my $shortname = $longname->{'name'}->Str;
$::PKGNAME = $shortname;
my $newpkg = $::CURPKG->{$shortname . '::'};
$newpkg->{'PARENT::'} = $::CURPKG;
$::CURPKG = $newpkg;
$::begin_compunit = 0;

}, $C))) {
do {
if (my ($C) = ($C->ws)) {
do {
if (my ($C) = ($C->_REDUCE($S, 'package_def', 'semi'))) {
$C->ws;
}
else {
();
}
};
}
else {
();
}
};
}
else {
();
}
};
}
else {
();
}
};
}
else {
();
}
}} // do {die $@ if $@ and $@ !~ /ABORT/;1} 
or
eval { push @gather, do {
if (my ($C) = ($C->panic("Too late for semicolon form of " . $::PKGDECL . " definition"))) {
$C->ws;
}
else {
();
}
}} or do { die $@ if $@ };
@gather;
}
}))) {
$C->ws;
}
else {
();
}
};
}
else {
();
}
};
}
else {
();
}
}} // do {die $@ if $@ and $@ !~ /ABORT/;1} 
or
eval { push @gather, do {
if (my ($C) = ($C->panic("Unable to parse " . $::PKGDECL . " definition"))) {
$C->ws;
}
else {
();
}
}} or do { die $@ if $@ };
@gather;
}
}))) {
$C->ws;
}
else {
();
}
};
}
else {
();
}
};
}
else {
();
}
};
}
else {
();
}
};
}
else {
();
}
}
}))) {
$C->ws;
}
else {
();
}
};
}
else {
();
}
}} // do {die $@ if $@ and $@ !~ /ABORT/;1} 
or
eval { push @gather, do {
if (my ($C) = ($C->ws)) {
do {
if (my ($C) = ($C->panic("Malformed $::PKGDECL"))) {
$C->ws;
}
else {
();
}
};
}
else {
();
}
}} or do { die $@ if $@ };
@gather;
}
);
}

## token declarator
##      token declarator {
##          [
##          | <constant_declarator>
##          | <variable_declarator>
##          | '(' ~ ')' <signature> <trait>*
##          | <routine_declarator>
##          | <regex_declarator>
##          | <type_declarator>
##          ]
##      }

sub declarator__PEEK { $_[0]->_AUTOLEXpeek('declarator',$retree) }
sub declarator {
my $self = shift;
local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;


my $C = $self;
my $S = $C->{'_pos'};
$C->{'trait'} = [];

$self->_MATCHIFY($S, "declarator", 
$C->_BRACKET( sub { my $C=shift;
do {
my @result = eval {
my $trystate;
my ($tag, $try);
my @try;
my $relex;

my $fate;
if ($fate = $C->{'_fate'} and $fate->[1] eq 'declarator_01') {
$C->deb("Fate passed to declarator_01: ", ::fatestr($fate)) if $::DEBUG & DEBUG::fates;
($C->{'_fate'}, $tag, $try) = @$fate;
@try = ($try);
}

my @gather = ();
for (;;) {
if (not @try) {
$relex //= $C->cursor_fate('STD', 'declarator_01', $retree);
@try = $relex->($C, $trystate);
}
last unless @try;
$try = shift(@try) // next;

if (ref $try eq 'ARRAY') {
($C->{'_fate'}, $tag, $try) = @$try;	# next candidate fate
}

$C->deb("declarator_01 trying $tag $try") if $::DEBUG & DEBUG::try_processing;
push @gather, ((
sub { my $C=shift;
$C->_SUBSUMEr(['constant_declarator'], sub {
my $C = shift;
$C->constant_declarator
})
},
sub { my $C=shift;
$C->_SUBSUMEr(['variable_declarator'], sub {
my $C = shift;
$C->variable_declarator
})
},
sub { my $C=shift;
Cursor::lazymap(sub { my $C=$_[0];
Cursor::lazymap(sub { my $C=$_[0];
Cursor::lazymap(sub { my $C=$_[0];
Cursor::lazymap(sub { my $C=$_[0];
$C->_STARr(sub { my $C=shift;
$C->_SUBSUME(['trait'], sub {
my $C = shift;
$C->trait
})
})
}, $C->_BRACKET( sub { my $C=shift;
do { my @gather;
eval { push @gather, $C->_EXACT(')')} // do {die $@ if $@ and $@ !~ /ABORT/;1} 
or
eval { push @gather, $C->FAILGOAL(')' , 'declarator')} or do { die $@ if $@ };
@gather;
}
}))
}, $C->_SUBSUME(['signature'], sub {
my $C = shift;
$C->signature
}))
}, $C->_COMMITBRANCH(local $::GOAL = ')' ))
}, $C->_EXACT('('))
},
sub { my $C=shift;
$C->_SUBSUME(['routine_declarator'], sub {
my $C = shift;
$C->routine_declarator
})
},
sub { my $C=shift;
$C->_SUBSUME(['regex_declarator'], sub {
my $C = shift;
$C->regex_declarator
})
},
sub { my $C=shift;
$C->_SUBSUME(['type_declarator'], sub {
my $C = shift;
$C->type_declarator
})
},
)[$try])->($C);
last if @gather;
}
@gather;
};
if (@result) {
@result;
}
elsif ($@) {
my ($first) = $@ =~ /(^.*)/;
$self->deb("CAUGHT $first") if $::DEBUG & DEBUG::trace_call;
die $@ if $@ !~ /^ABORTBRANCH/;
();
}
else {
();
}
}

})
);
}

## token multi_declarator__S_093multi (:$endsym is context = 'spacey', :$sym is context<rw> = 'multi')
##      token multi_declarator:multi {
##          :my $MULTINESS is context = 'multi';
##          <sym> <.ws> [ <declarator> || <routine_def> || <.panic: 'Malformed multi'> ]
##      }

sub multi_declarator__S_093multi__PEEK { $_[0]->_AUTOLEXpeek('multi_declarator__S_093multi',$retree) }
sub multi_declarator__S_093multi {
my $self = shift;
local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;
my %args = @_;
local $endsym = $args{endsym} // 'spacey';
local $sym = $args{sym} // 'multi';
local $::MULTINESS = 'multi';


my $C = $self;
my $S = $C->{'_pos'};
$C->{'sym'} = $sym;

$self->_MATCHIFYr($S, "multi_declarator__S_093multi", 
do {
if (my ($C) = ($C->_PATTERN(qr/\Gmulti/))) {
do {
if (my ($C) = ($C->spacey)) {
do {
if (my ($C) = ($C->ws)) {
$C->_BRACKETr( sub { my $C=shift;
do { my @gather;
eval { push @gather, $C->_SUBSUMEr(['declarator'], sub {
my $C = shift;
$C->declarator
})} // do {die $@ if $@ and $@ !~ /ABORT/;1} 
or
eval { push @gather, $C->_SUBSUMEr(['routine_def'], sub {
my $C = shift;
$C->routine_def
})} // do {die $@ if $@ and $@ !~ /ABORT/;1} 
or
eval { push @gather, $C->panic('Malformed multi')} or do { die $@ if $@ };
@gather;
}
});
}
else {
();
}
};
}
else {
();
}
};
}
else {
();
}
}
);
}
## token multi_declarator__S_094proto (:$endsym is context = 'spacey', :$sym is context<rw> = 'proto')
##      token multi_declarator:proto {
##          :my $MULTINESS is context = 'proto';
##          <sym> <.ws> [ <declarator> || <routine_def> || <.panic: 'Malformed proto'> ]
##      }

sub multi_declarator__S_094proto__PEEK { $_[0]->_AUTOLEXpeek('multi_declarator__S_094proto',$retree) }
sub multi_declarator__S_094proto {
my $self = shift;
local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;
my %args = @_;
local $endsym = $args{endsym} // 'spacey';
local $sym = $args{sym} // 'proto';
local $::MULTINESS = 'proto';


my $C = $self;
my $S = $C->{'_pos'};
$C->{'sym'} = $sym;

$self->_MATCHIFYr($S, "multi_declarator__S_094proto", 
do {
if (my ($C) = ($C->_PATTERN(qr/\Gproto/))) {
do {
if (my ($C) = ($C->spacey)) {
do {
if (my ($C) = ($C->ws)) {
$C->_BRACKETr( sub { my $C=shift;
do { my @gather;
eval { push @gather, $C->_SUBSUMEr(['declarator'], sub {
my $C = shift;
$C->declarator
})} // do {die $@ if $@ and $@ !~ /ABORT/;1} 
or
eval { push @gather, $C->_SUBSUMEr(['routine_def'], sub {
my $C = shift;
$C->routine_def
})} // do {die $@ if $@ and $@ !~ /ABORT/;1} 
or
eval { push @gather, $C->panic('Malformed proto')} or do { die $@ if $@ };
@gather;
}
});
}
else {
();
}
};
}
else {
();
}
};
}
else {
();
}
}
);
}
## token multi_declarator__S_095only (:$endsym is context = 'spacey', :$sym is context<rw> = 'only')
##      token multi_declarator:only {
##          :my $MULTINESS is context = 'only';
##          <sym> <.ws> [ <declarator> || <routine_def> || <.panic: 'Malformed only'> ]
##      }

sub multi_declarator__S_095only__PEEK { $_[0]->_AUTOLEXpeek('multi_declarator__S_095only',$retree) }
sub multi_declarator__S_095only {
my $self = shift;
local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;
my %args = @_;
local $endsym = $args{endsym} // 'spacey';
local $sym = $args{sym} // 'only';
local $::MULTINESS = 'only';


my $C = $self;
my $S = $C->{'_pos'};
$C->{'sym'} = $sym;

$self->_MATCHIFYr($S, "multi_declarator__S_095only", 
do {
if (my ($C) = ($C->_PATTERN(qr/\Gonly/))) {
do {
if (my ($C) = ($C->spacey)) {
do {
if (my ($C) = ($C->ws)) {
$C->_BRACKETr( sub { my $C=shift;
do { my @gather;
eval { push @gather, $C->_SUBSUMEr(['declarator'], sub {
my $C = shift;
$C->declarator
})} // do {die $@ if $@ and $@ !~ /ABORT/;1} 
or
eval { push @gather, $C->_SUBSUMEr(['routine_def'], sub {
my $C = shift;
$C->routine_def
})} // do {die $@ if $@ and $@ !~ /ABORT/;1} 
or
eval { push @gather, $C->panic('Malformed only')} or do { die $@ if $@ };
@gather;
}
});
}
else {
();
}
};
}
else {
();
}
};
}
else {
();
}
}
);
}
## token multi_declarator__S_096null (:$endsym is context = 'spacey', :$sym is context<rw> = 'null')
##      token multi_declarator:null {
##          :my $MULTINESS is context = '';
##          <declarator>
##      }

sub multi_declarator__S_096null__PEEK { $_[0]->_AUTOLEXpeek('multi_declarator__S_096null',$retree) }
sub multi_declarator__S_096null {
my $self = shift;
local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;
my %args = @_;
local $endsym = $args{endsym} // 'spacey';
local $sym = $args{sym} // 'null';
local $::MULTINESS = '';


my $C = $self;
my $S = $C->{'_pos'};
$C->{'sym'} = $sym;

$self->_MATCHIFYr($S, "multi_declarator__S_096null", 
$C->_SUBSUMEr(['declarator'], sub {
my $C = shift;
$C->declarator
})
);
}

## token routine_declarator__S_097sub (:$endsym is context = 'endid', :$sym is context<rw> = 'sub')
##      token routine_declarator:sub       { <sym> <routine_def> }

sub routine_declarator__S_097sub__PEEK { $_[0]->_AUTOLEXpeek('routine_declarator__S_097sub',$retree) }
sub routine_declarator__S_097sub {
my $self = shift;
local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;
my %args = @_;
local $endsym = $args{endsym} // 'endid';
local $sym = $args{sym} // 'sub';


my $C = $self;
my $S = $C->{'_pos'};
$C->{'sym'} = $sym;

$self->_MATCHIFYr($S, "routine_declarator__S_097sub", 
do {
if (my ($C) = ($C->_PATTERN(qr/\Gsub/))) {
do {
if (my ($C) = ($C->endid)) {
$C->_SUBSUMEr(['routine_def'], sub {
my $C = shift;
$C->routine_def
});
}
else {
();
}
};
}
else {
();
}
}
);
}
## token routine_declarator__S_098method (:$endsym is context = 'endid', :$sym is context<rw> = 'method')
##      token routine_declarator:method    { <sym> <method_def> }

sub routine_declarator__S_098method__PEEK { $_[0]->_AUTOLEXpeek('routine_declarator__S_098method',$retree) }
sub routine_declarator__S_098method {
my $self = shift;
local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;
my %args = @_;
local $endsym = $args{endsym} // 'endid';
local $sym = $args{sym} // 'method';


my $C = $self;
my $S = $C->{'_pos'};
$C->{'sym'} = $sym;

$self->_MATCHIFYr($S, "routine_declarator__S_098method", 
do {
if (my ($C) = ($C->_PATTERN(qr/\Gmethod/))) {
do {
if (my ($C) = ($C->endid)) {
$C->_SUBSUMEr(['method_def'], sub {
my $C = shift;
$C->method_def
});
}
else {
();
}
};
}
else {
();
}
}
);
}
## token routine_declarator__S_099submethod (:$endsym is context = 'endid', :$sym is context<rw> = 'submethod')
##      token routine_declarator:submethod { <sym> <method_def> }

sub routine_declarator__S_099submethod__PEEK { $_[0]->_AUTOLEXpeek('routine_declarator__S_099submethod',$retree) }
sub routine_declarator__S_099submethod {
my $self = shift;
local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;
my %args = @_;
local $endsym = $args{endsym} // 'endid';
local $sym = $args{sym} // 'submethod';


my $C = $self;
my $S = $C->{'_pos'};
$C->{'sym'} = $sym;

$self->_MATCHIFYr($S, "routine_declarator__S_099submethod", 
do {
if (my ($C) = ($C->_PATTERN(qr/\Gsubmethod/))) {
do {
if (my ($C) = ($C->endid)) {
$C->_SUBSUMEr(['method_def'], sub {
my $C = shift;
$C->method_def
});
}
else {
();
}
};
}
else {
();
}
}
);
}
## token routine_declarator__S_100macro (:$endsym is context = 'endid', :$sym is context<rw> = 'macro')
##      token routine_declarator:macro     { <sym> <macro_def> }

sub routine_declarator__S_100macro__PEEK { $_[0]->_AUTOLEXpeek('routine_declarator__S_100macro',$retree) }
sub routine_declarator__S_100macro {
my $self = shift;
local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;
my %args = @_;
local $endsym = $args{endsym} // 'endid';
local $sym = $args{sym} // 'macro';


my $C = $self;
my $S = $C->{'_pos'};
$C->{'sym'} = $sym;

$self->_MATCHIFYr($S, "routine_declarator__S_100macro", 
do {
if (my ($C) = ($C->_PATTERN(qr/\Gmacro/))) {
do {
if (my ($C) = ($C->endid)) {
$C->_SUBSUMEr(['macro_def'], sub {
my $C = shift;
$C->macro_def
});
}
else {
();
}
};
}
else {
();
}
}
);
}

## token regex_declarator__S_101regex (:$endsym is context = 'spacey', :$sym is context<rw> = 'regex')
##      token regex_declarator:regex { <sym>       <regex_def> }

sub regex_declarator__S_101regex__PEEK { $_[0]->_AUTOLEXpeek('regex_declarator__S_101regex',$retree) }
sub regex_declarator__S_101regex {
my $self = shift;
local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;
my %args = @_;
local $endsym = $args{endsym} // 'spacey';
local $sym = $args{sym} // 'regex';


my $C = $self;
my $S = $C->{'_pos'};
$C->{'sym'} = $sym;

$self->_MATCHIFYr($S, "regex_declarator__S_101regex", 
do {
if (my ($C) = ($C->_PATTERN(qr/\Gregex/))) {
do {
if (my ($C) = ($C->spacey)) {
$C->_SUBSUMEr(['regex_def'], sub {
my $C = shift;
$C->regex_def
});
}
else {
();
}
};
}
else {
();
}
}
);
}
## token regex_declarator__S_102token (:$endsym is context = 'spacey', :$sym is context<rw> = 'token')
##      token regex_declarator:token { <sym>       <regex_def> }

sub regex_declarator__S_102token__PEEK { $_[0]->_AUTOLEXpeek('regex_declarator__S_102token',$retree) }
sub regex_declarator__S_102token {
my $self = shift;
local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;
my %args = @_;
local $endsym = $args{endsym} // 'spacey';
local $sym = $args{sym} // 'token';


my $C = $self;
my $S = $C->{'_pos'};
$C->{'sym'} = $sym;

$self->_MATCHIFYr($S, "regex_declarator__S_102token", 
do {
if (my ($C) = ($C->_PATTERN(qr/\Gtoken/))) {
do {
if (my ($C) = ($C->spacey)) {
$C->_SUBSUMEr(['regex_def'], sub {
my $C = shift;
$C->regex_def
});
}
else {
();
}
};
}
else {
();
}
}
);
}
## token regex_declarator__S_103rule (:$endsym is context = 'spacey', :$sym is context<rw> = 'rule')
##      token regex_declarator:rule  { <sym>       <regex_def> }

sub regex_declarator__S_103rule__PEEK { $_[0]->_AUTOLEXpeek('regex_declarator__S_103rule',$retree) }
sub regex_declarator__S_103rule {
my $self = shift;
local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;
my %args = @_;
local $endsym = $args{endsym} // 'spacey';
local $sym = $args{sym} // 'rule';


my $C = $self;
my $S = $C->{'_pos'};
$C->{'sym'} = $sym;

$self->_MATCHIFYr($S, "regex_declarator__S_103rule", 
do {
if (my ($C) = ($C->_PATTERN(qr/\Grule/))) {
do {
if (my ($C) = ($C->spacey)) {
$C->_SUBSUMEr(['regex_def'], sub {
my $C = shift;
$C->regex_def
});
}
else {
();
}
};
}
else {
();
}
}
);
}

## rule multisig
##      rule multisig {
##          :dba('signature')
##          [
##              ':'?'(' ~ ')' <signature>
##          ]
##          ** '|'
##      }

sub multisig__PEEK { $_[0]->_AUTOLEXpeek('multisig',$retree) }
sub multisig {
my $self = shift;
local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;


my $C = $self;
my $S = $C->{'_pos'};
$C->{'signature'} = [];

$self->_MATCHIFY($S, "multisig", 
Cursor::lazymap(sub { my $C=$_[0];
Cursor::lazymap(sub { my $C=$_[0];
Cursor::lazymap(sub { my $C=$_[0];
$C->ws
}, $C->_REPSEPr(  sub { my $C=shift;
$C->_EXACT('|')
}, sub { my $C=shift;
$C->_BRACKET( sub { my $C=shift;
Cursor::lazymap(sub { my $C=$_[0];
Cursor::lazymap(sub { my $C=$_[0];
Cursor::lazymap(sub { my $C=$_[0];
Cursor::lazymap(sub { my $C=$_[0];
Cursor::lazymap(sub { my $C=$_[0];
Cursor::lazymap(sub { my $C=$_[0];
Cursor::lazymap(sub { my $C=$_[0];
$C->ws
}, $C->_BRACKET( sub { my $C=shift;
do { my @gather;
eval { push @gather, $C->_EXACT(')')} // do {die $@ if $@ and $@ !~ /ABORT/;1} 
or
eval { push @gather, $C->FAILGOAL(')', 'signature')} or do { die $@ if $@ };
@gather;
}
}))
}, $C->_SUBSUME(['signature'], sub {
my $C = shift;
$C->signature
}))
}, $C->_COMMITBRANCH(local $::GOAL = ')'))
}, $C->ws)
}, $C->_EXACT('('))
}, $C->_OPTr(sub { my $C=shift;
$C->_EXACT(':')
}))
}, $C->ws)
})
}))
}, $C->ws)
}, $C->ws)
);
}

## rule routine_def ($CURPAD is context<rw> = $*CURPAD)
##      rule routine_def ($CURPAD is context<rw> = $*CURPAD) {
##          :my $IN_DECL is context<rw> = 1;
##          :my $DECLARAND is context<rw>;
##          [
##              [ '&'<deflongname>? | <deflongname> ]?
##              <.newpad>
##              [ <multisig> | <trait> ]*
##              <!{
##                  $*IN_DECL = 0;
##              }>
##              <blockoid>:!s
##          ] || <.panic: "Malformed routine">
##      }

sub routine_def__PEEK { $_[0]->_AUTOLEXpeek('routine_def',$retree) }
sub routine_def {
my $self = shift;
local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;
local $CURPAD = shift() // $::CURPAD;
local $::IN_DECL = 1;
local $::DECLARAND;


my $C = $self;
my $S = $C->{'_pos'};
$C->{'deflongname'} = [];
$C->{'multisig'} = [];
$C->{'trait'} = [];

$self->_MATCHIFYr($S, "routine_def", 
do { my @gather;
eval { push @gather, do {
if (my ($C) = ($C->ws)) {
do {
if (my ($C) = ($C->_BRACKETr( sub { my $C=shift;
do {
if (my ($C) = ($C->_OPTr(sub { my $C=shift;
$C->_BRACKETr( sub { my $C=shift;
do {
my @result = eval {
my $trystate;
my ($tag, $try);
my @try;
my $relex;

my $fate;
if ($fate = $C->{'_fate'} and $fate->[1] eq 'routine_def_02') {
$C->deb("Fate passed to routine_def_02: ", ::fatestr($fate)) if $::DEBUG & DEBUG::fates;
($C->{'_fate'}, $tag, $try) = @$fate;
@try = ($try);
}

my @gather = ();
for (;;) {
if (not @try) {
$relex //= $C->cursor_fate('STD', 'routine_def_02', $retree);
@try = $relex->($C, $trystate);
}
last unless @try;
$try = shift(@try) // next;

if (ref $try eq 'ARRAY') {
($C->{'_fate'}, $tag, $try) = @$try;	# next candidate fate
}

$C->deb("routine_def_02 trying $tag $try") if $::DEBUG & DEBUG::try_processing;
push @gather, ((
sub { my $C=shift;
do {
if (my ($C) = ($C->ws)) {
do {
if (my ($C) = ($C->_EXACT('&'))) {
do {
if (my ($C) = ($C->_OPTr(sub { my $C=shift;
$C->_SUBSUMEr(['deflongname'], sub {
my $C = shift;
$C->deflongname
})
}))) {
$C->ws;
}
else {
();
}
};
}
else {
();
}
};
}
else {
();
}
}
},
sub { my $C=shift;
do {
if (my ($C) = ($C->ws)) {
do {
if (my ($C) = ($C->_SUBSUMEr(['deflongname'], sub {
my $C = shift;
$C->deflongname
}))) {
$C->ws;
}
else {
();
}
};
}
else {
();
}
}
},
)[$try])->($C);
last if @gather;
}
@gather;
};
if (@result) {
@result;
}
elsif ($@) {
my ($first) = $@ =~ /(^.*)/;
$self->deb("CAUGHT $first") if $::DEBUG & DEBUG::trace_call;
die $@ if $@ !~ /^ABORTBRANCH/;
();
}
else {
();
}
}

})
}))) {
do {
if (my ($C) = ($C->ws)) {
do {
if (my ($C) = ($C->newpad)) {
do {
if (my ($C) = ($C->ws)) {
do {
if (my ($C) = ($C->_STARr(sub { my $C=shift;
$C->_BRACKETr( sub { my $C=shift;
do {
my @result = eval {
my $trystate;
my ($tag, $try);
my @try;
my $relex;

my $fate;
if ($fate = $C->{'_fate'} and $fate->[1] eq 'routine_def_03') {
$C->deb("Fate passed to routine_def_03: ", ::fatestr($fate)) if $::DEBUG & DEBUG::fates;
($C->{'_fate'}, $tag, $try) = @$fate;
@try = ($try);
}

my @gather = ();
for (;;) {
if (not @try) {
$relex //= $C->cursor_fate('STD', 'routine_def_03', $retree);
@try = $relex->($C, $trystate);
}
last unless @try;
$try = shift(@try) // next;

if (ref $try eq 'ARRAY') {
($C->{'_fate'}, $tag, $try) = @$try;	# next candidate fate
}

$C->deb("routine_def_03 trying $tag $try") if $::DEBUG & DEBUG::try_processing;
push @gather, ((
sub { my $C=shift;
do {
if (my ($C) = ($C->ws)) {
do {
if (my ($C) = ($C->_SUBSUMEr(['multisig'], sub {
my $C = shift;
$C->multisig
}))) {
$C->ws;
}
else {
();
}
};
}
else {
();
}
}
},
sub { my $C=shift;
do {
if (my ($C) = ($C->ws)) {
do {
if (my ($C) = ($C->_SUBSUMEr(['trait'], sub {
my $C = shift;
$C->trait
}))) {
$C->ws;
}
else {
();
}
};
}
else {
();
}
}
},
)[$try])->($C);
last if @gather;
}
@gather;
};
if (@result) {
@result;
}
elsif ($@) {
my ($first) = $@ =~ /(^.*)/;
$self->deb("CAUGHT $first") if $::DEBUG & DEBUG::trace_call;
die $@ if $@ !~ /^ABORTBRANCH/;
();
}
else {
();
}
}

})
}))) {
do {
if (my ($C) = ($C->ws)) {
do {
if (my ($C) = ($C->_NOTBEFORE( sub { my $C=shift;
(($C) x !!do {

$::IN_DECL = 0;

})
}))) {
do {
if (my ($C) = ($C->ws)) {
$C->_SUBSUMEr(['blockoid'], sub {
my $C = shift;
$C->blockoid
});
}
else {
();
}
};
}
else {
();
}
};
}
else {
();
}
};
}
else {
();
}
};
}
else {
();
}
};
}
else {
();
}
};
}
else {
();
}
};
}
else {
();
}
}
}))) {
$C->ws;
}
else {
();
}
};
}
else {
();
}
}} // do {die $@ if $@ and $@ !~ /ABORT/;1} 
or
eval { push @gather, do {
if (my ($C) = ($C->ws)) {
do {
if (my ($C) = ($C->panic("Malformed routine"))) {
$C->ws;
}
else {
();
}
};
}
else {
();
}
}} or do { die $@ if $@ };
@gather;
}
);
}

## rule method_def ($CURPAD is context<rw> = $*CURPAD)
##      rule method_def ($CURPAD is context<rw> = $*CURPAD) {
##          :my $IN_DECL is context<rw> = 1;
##          :my $DECLARAND is context<rw>;
##          <.newpad>
##          [
##              [
##              | <[ ! ^ ]>?<longname> [ <multisig> | <trait> ]*
##              | <multisig> <trait>*
##              | <sigil> '.'
##                  :dba('subscript signature')
##                  [
##                  | '(' ~ ')' <signature>
##                  | '[' ~ ']' <signature>
##                  | '{' ~ '}' <signature>
##                  | <?before '<'> <postcircumfix>
##                  ]
##                  <trait>*
##              | <?>
##              ]
##              <blockoid>:!s
##          ] || <.panic: "Malformed method">
##      }

sub method_def__PEEK { $_[0]->_AUTOLEXpeek('method_def',$retree) }
sub method_def {
my $self = shift;
local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;
local $CURPAD = shift() // $::CURPAD;
local $::IN_DECL = 1;
local $::DECLARAND;


my $C = $self;
my $S = $C->{'_pos'};
$C->{'multisig'} = [];
$C->{'trait'} = [];

$self->_MATCHIFY($S, "method_def", 
do { my @gather;
eval { push @gather, Cursor::lazymap(sub { my $C=$_[0];
Cursor::lazymap(sub { my $C=$_[0];
Cursor::lazymap(sub { my $C=$_[0];
Cursor::lazymap(sub { my $C=$_[0];
$C->ws
}, $C->_BRACKET( sub { my $C=shift;
Cursor::lazymap(sub { my $C=$_[0];
Cursor::lazymap(sub { my $C=$_[0];
$C->_SUBSUME(['blockoid'], sub {
my $C = shift;
$C->blockoid
})
}, $C->ws)
}, $C->_BRACKET( sub { my $C=shift;
do {
my @result = eval {
my $trystate;
my ($tag, $try);
my @try;
my $relex;

my $fate;
if ($fate = $C->{'_fate'} and $fate->[1] eq 'method_def_02') {
$C->deb("Fate passed to method_def_02: ", ::fatestr($fate)) if $::DEBUG & DEBUG::fates;
($C->{'_fate'}, $tag, $try) = @$fate;
@try = ($try);
}

my @gather = ();
for (;;) {
if (not @try) {
$relex //= $C->cursor_fate('STD', 'method_def_02', $retree);
@try = $relex->($C, $trystate);
}
last unless @try;
$try = shift(@try) // next;

if (ref $try eq 'ARRAY') {
($C->{'_fate'}, $tag, $try) = @$try;	# next candidate fate
}

$C->deb("method_def_02 trying $tag $try") if $::DEBUG & DEBUG::try_processing;
push @gather, ((
sub { my $C=shift;
do {
if (my ($C) = ($C->_PATTERN(qr/\G((?:[!^])?+)/))) {
do {
if (my ($C) = ($C->_SUBSUMEr(['longname'], sub {
my $C = shift;
$C->longname
}))) {
do {
if (my ($C) = ($C->ws)) {
do {
if (my ($C) = ($C->_STARr(sub { my $C=shift;
$C->_BRACKETr( sub { my $C=shift;
do {
my @result = eval {
my $trystate;
my ($tag, $try);
my @try;
my $relex;

my $fate;
if ($fate = $C->{'_fate'} and $fate->[1] eq 'method_def_03') {
$C->deb("Fate passed to method_def_03: ", ::fatestr($fate)) if $::DEBUG & DEBUG::fates;
($C->{'_fate'}, $tag, $try) = @$fate;
@try = ($try);
}

my @gather = ();
for (;;) {
if (not @try) {
$relex //= $C->cursor_fate('STD', 'method_def_03', $retree);
@try = $relex->($C, $trystate);
}
last unless @try;
$try = shift(@try) // next;

if (ref $try eq 'ARRAY') {
($C->{'_fate'}, $tag, $try) = @$try;	# next candidate fate
}

$C->deb("method_def_03 trying $tag $try") if $::DEBUG & DEBUG::try_processing;
push @gather, ((
sub { my $C=shift;
do {
if (my ($C) = ($C->ws)) {
do {
if (my ($C) = ($C->_SUBSUMEr(['multisig'], sub {
my $C = shift;
$C->multisig
}))) {
$C->ws;
}
else {
();
}
};
}
else {
();
}
}
},
sub { my $C=shift;
do {
if (my ($C) = ($C->ws)) {
do {
if (my ($C) = ($C->_SUBSUMEr(['trait'], sub {
my $C = shift;
$C->trait
}))) {
$C->ws;
}
else {
();
}
};
}
else {
();
}
}
},
)[$try])->($C);
last if @gather;
}
@gather;
};
if (@result) {
@result;
}
elsif ($@) {
my ($first) = $@ =~ /(^.*)/;
$self->deb("CAUGHT $first") if $::DEBUG & DEBUG::trace_call;
die $@ if $@ !~ /^ABORTBRANCH/;
();
}
else {
();
}
}

})
}))) {
$C->ws;
}
else {
();
}
};
}
else {
();
}
};
}
else {
();
}
};
}
else {
();
}
}
},
sub { my $C=shift;
do {
if (my ($C) = ($C->_SUBSUMEr(['multisig'], sub {
my $C = shift;
$C->multisig
}))) {
do {
if (my ($C) = ($C->ws)) {
do {
if (my ($C) = ($C->_STARr(sub { my $C=shift;
$C->_SUBSUMEr(['trait'], sub {
my $C = shift;
$C->trait
})
}))) {
$C->ws;
}
else {
();
}
};
}
else {
();
}
};
}
else {
();
}
}
},
sub { my $C=shift;
Cursor::lazymap(sub { my $C=$_[0];
Cursor::lazymap(sub { my $C=$_[0];
Cursor::lazymap(sub { my $C=$_[0];
Cursor::lazymap(sub { my $C=$_[0];
Cursor::lazymap(sub { my $C=$_[0];
Cursor::lazymap(sub { my $C=$_[0];
Cursor::lazymap(sub { my $C=$_[0];
Cursor::lazymap(sub { my $C=$_[0];
$C->ws
}, $C->_STARr(sub { my $C=shift;
$C->_SUBSUME(['trait'], sub {
my $C = shift;
$C->trait
})
}))
}, $C->ws)
}, $C->_BRACKET( sub { my $C=shift;
do {
my @result = eval {
my $trystate;
my ($tag, $try);
my @try;
my $relex;

my $fate;
if ($fate = $C->{'_fate'} and $fate->[1] eq 'method_def_04') {
$C->deb("Fate passed to method_def_04: ", ::fatestr($fate)) if $::DEBUG & DEBUG::fates;
($C->{'_fate'}, $tag, $try) = @$fate;
@try = ($try);
}

my @gather = ();
for (;;) {
if (not @try) {
$relex //= $C->cursor_fate('STD', 'method_def_04', $retree);
@try = $relex->($C, $trystate);
}
last unless @try;
$try = shift(@try) // next;

if (ref $try eq 'ARRAY') {
($C->{'_fate'}, $tag, $try) = @$try;	# next candidate fate
}

$C->deb("method_def_04 trying $tag $try") if $::DEBUG & DEBUG::try_processing;
push @gather, ((
sub { my $C=shift;
Cursor::lazymap(sub { my $C=$_[0];
Cursor::lazymap(sub { my $C=$_[0];
Cursor::lazymap(sub { my $C=$_[0];
Cursor::lazymap(sub { my $C=$_[0];
Cursor::lazymap(sub { my $C=$_[0];
$C->ws
}, $C->_BRACKET( sub { my $C=shift;
do { my @gather;
eval { push @gather, $C->_EXACT(')')} // do {die $@ if $@ and $@ !~ /ABORT/;1} 
or
eval { push @gather, $C->FAILGOAL(')', 'subscript signature')} or do { die $@ if $@ };
@gather;
}
}))
}, $C->_SUBSUME(['signature'], sub {
my $C = shift;
$C->signature
}))
}, $C->_COMMITBRANCH(local $::GOAL = ')'))
}, $C->ws)
}, $C->_EXACT('('))
},
sub { my $C=shift;
Cursor::lazymap(sub { my $C=$_[0];
Cursor::lazymap(sub { my $C=$_[0];
Cursor::lazymap(sub { my $C=$_[0];
Cursor::lazymap(sub { my $C=$_[0];
Cursor::lazymap(sub { my $C=$_[0];
$C->ws
}, $C->_BRACKET( sub { my $C=shift;
do { my @gather;
eval { push @gather, $C->_EXACT(']')} // do {die $@ if $@ and $@ !~ /ABORT/;1} 
or
eval { push @gather, $C->FAILGOAL(']', 'subscript signature')} or do { die $@ if $@ };
@gather;
}
}))
}, $C->_SUBSUME(['signature'], sub {
my $C = shift;
$C->signature
}))
}, $C->_COMMITBRANCH(local $::GOAL = ']'))
}, $C->ws)
}, $C->_EXACT('['))
},
sub { my $C=shift;
Cursor::lazymap(sub { my $C=$_[0];
Cursor::lazymap(sub { my $C=$_[0];
Cursor::lazymap(sub { my $C=$_[0];
Cursor::lazymap(sub { my $C=$_[0];
Cursor::lazymap(sub { my $C=$_[0];
$C->ws
}, $C->_BRACKET( sub { my $C=shift;
do { my @gather;
eval { push @gather, $C->_EXACT('}')} // do {die $@ if $@ and $@ !~ /ABORT/;1} 
or
eval { push @gather, $C->FAILGOAL('}', 'subscript signature')} or do { die $@ if $@ };
@gather;
}
}))
}, $C->_SUBSUME(['signature'], sub {
my $C = shift;
$C->signature
}))
}, $C->_COMMITBRANCH(local $::GOAL = '}'))
}, $C->ws)
}, $C->_EXACT('{'))
},
sub { my $C=shift;
Cursor::lazymap(sub { my $C=$_[0];
Cursor::lazymap(sub { my $C=$_[0];
Cursor::lazymap(sub { my $C=$_[0];
$C->ws
}, $C->_SUBSUME(['postcircumfix'], sub {
my $C = shift;
$C->postcircumfix
}))
}, $C->ws)
}, $C->before(sub { my $C=shift;
$C->_EXACT('<')
}))
},
)[$try])->($C);
last if @gather;
}
@gather;
};
if (@result) {
@result;
}
elsif ($@) {
my ($first) = $@ =~ /(^.*)/;
$self->deb("CAUGHT $first") if $::DEBUG & DEBUG::trace_call;
die $@ if $@ !~ /^ABORTBRANCH/;
();
}
else {
();
}
}

}))
}, $C->ws)
}, $C->ws)
}, $C->_EXACT('.'))
}, $C->ws)
}, $C->_SUBSUMEr(['sigil'], sub {
my $C = shift;
$C->sigil
}))
},
sub { my $C=shift;
Cursor::lazymap(sub { my $C=$_[0];
$C->ws
}, $C->before( sub { my $C=shift;
$C
}))
},
)[$try])->($C);
last if @gather;
}
@gather;
};
if (@result) {
@result;
}
elsif ($@) {
my ($first) = $@ =~ /(^.*)/;
$self->deb("CAUGHT $first") if $::DEBUG & DEBUG::trace_call;
die $@ if $@ !~ /^ABORTBRANCH/;
();
}
else {
();
}
}

}))
}))
}, $C->ws)
}, $C->newpad)
}, $C->ws)} // do {die $@ if $@ and $@ !~ /ABORT/;1} 
or
eval { push @gather, Cursor::lazymap(sub { my $C=$_[0];
Cursor::lazymap(sub { my $C=$_[0];
$C->ws
}, $C->panic("Malformed method"))
}, $C->ws)} or do { die $@ if $@ };
@gather;
}
);
}

## rule regex_def ($CURPAD is context<rw> = $*CURPAD)
##      rule regex_def ($CURPAD is context<rw> = $*CURPAD) {
##          :my $IN_DECL is context<rw> = 1;
##          :my $DECLARAND is context<rw>;
##          [
##              [ '&'<deflongname>? | <deflongname> ]?
##              <.newpad>
##              [ [ ':'?'(' <signature> ')'] | <trait> ]*
##              { $*IN_DECL = 0; }
##              <.finishpad>
##              <regex_block>:!s
##          ] || <.panic: "Malformed regex">
##      }

sub regex_def__PEEK { $_[0]->_AUTOLEXpeek('regex_def',$retree) }
sub regex_def {
my $self = shift;
local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;
local $CURPAD = shift() // $::CURPAD;
local $::IN_DECL = 1;
local $::DECLARAND;


my $C = $self;
my $S = $C->{'_pos'};
$C->{'deflongname'} = [];
$C->{'signature'} = [];
$C->{'trait'} = [];

$self->_MATCHIFYr($S, "regex_def", 
do { my @gather;
eval { push @gather, do {
if (my ($C) = ($C->ws)) {
do {
if (my ($C) = ($C->_BRACKETr( sub { my $C=shift;
do {
if (my ($C) = ($C->_OPTr(sub { my $C=shift;
$C->_BRACKETr( sub { my $C=shift;
do {
my @result = eval {
my $trystate;
my ($tag, $try);
my @try;
my $relex;

my $fate;
if ($fate = $C->{'_fate'} and $fate->[1] eq 'regex_def_02') {
$C->deb("Fate passed to regex_def_02: ", ::fatestr($fate)) if $::DEBUG & DEBUG::fates;
($C->{'_fate'}, $tag, $try) = @$fate;
@try = ($try);
}

my @gather = ();
for (;;) {
if (not @try) {
$relex //= $C->cursor_fate('STD', 'regex_def_02', $retree);
@try = $relex->($C, $trystate);
}
last unless @try;
$try = shift(@try) // next;

if (ref $try eq 'ARRAY') {
($C->{'_fate'}, $tag, $try) = @$try;	# next candidate fate
}

$C->deb("regex_def_02 trying $tag $try") if $::DEBUG & DEBUG::try_processing;
push @gather, ((
sub { my $C=shift;
do {
if (my ($C) = ($C->ws)) {
do {
if (my ($C) = ($C->_EXACT('&'))) {
do {
if (my ($C) = ($C->_OPTr(sub { my $C=shift;
$C->_SUBSUMEr(['deflongname'], sub {
my $C = shift;
$C->deflongname
})
}))) {
$C->ws;
}
else {
();
}
};
}
else {
();
}
};
}
else {
();
}
}
},
sub { my $C=shift;
do {
if (my ($C) = ($C->ws)) {
do {
if (my ($C) = ($C->_SUBSUMEr(['deflongname'], sub {
my $C = shift;
$C->deflongname
}))) {
$C->ws;
}
else {
();
}
};
}
else {
();
}
}
},
)[$try])->($C);
last if @gather;
}
@gather;
};
if (@result) {
@result;
}
elsif ($@) {
my ($first) = $@ =~ /(^.*)/;
$self->deb("CAUGHT $first") if $::DEBUG & DEBUG::trace_call;
die $@ if $@ !~ /^ABORTBRANCH/;
();
}
else {
();
}
}

})
}))) {
do {
if (my ($C) = ($C->ws)) {
do {
if (my ($C) = ($C->newpad)) {
do {
if (my ($C) = ($C->ws)) {
do {
if (my ($C) = ($C->_STARr(sub { my $C=shift;
$C->_BRACKETr( sub { my $C=shift;
do {
my @result = eval {
my $trystate;
my ($tag, $try);
my @try;
my $relex;

my $fate;
if ($fate = $C->{'_fate'} and $fate->[1] eq 'regex_def_03') {
$C->deb("Fate passed to regex_def_03: ", ::fatestr($fate)) if $::DEBUG & DEBUG::fates;
($C->{'_fate'}, $tag, $try) = @$fate;
@try = ($try);
}

my @gather = ();
for (;;) {
if (not @try) {
$relex //= $C->cursor_fate('STD', 'regex_def_03', $retree);
@try = $relex->($C, $trystate);
}
last unless @try;
$try = shift(@try) // next;

if (ref $try eq 'ARRAY') {
($C->{'_fate'}, $tag, $try) = @$try;	# next candidate fate
}

$C->deb("regex_def_03 trying $tag $try") if $::DEBUG & DEBUG::try_processing;
push @gather, ((
sub { my $C=shift;
do {
if (my ($C) = ($C->ws)) {
do {
if (my ($C) = ($C->_BRACKETr( sub { my $C=shift;
do {
if (my ($C) = ($C->_OPTr(sub { my $C=shift;
$C->_EXACT(':')
}))) {
do {
if (my ($C) = ($C->_EXACT('('))) {
do {
if (my ($C) = ($C->ws)) {
do {
if (my ($C) = ($C->_SUBSUMEr(['signature'], sub {
my $C = shift;
$C->signature
}))) {
do {
if (my ($C) = ($C->ws)) {
$C->_EXACT(')');
}
else {
();
}
};
}
else {
();
}
};
}
else {
();
}
};
}
else {
();
}
};
}
else {
();
}
}
}))) {
$C->ws;
}
else {
();
}
};
}
else {
();
}
}
},
sub { my $C=shift;
do {
if (my ($C) = ($C->ws)) {
do {
if (my ($C) = ($C->_SUBSUMEr(['trait'], sub {
my $C = shift;
$C->trait
}))) {
$C->ws;
}
else {
();
}
};
}
else {
();
}
}
},
)[$try])->($C);
last if @gather;
}
@gather;
};
if (@result) {
@result;
}
elsif ($@) {
my ($first) = $@ =~ /(^.*)/;
$self->deb("CAUGHT $first") if $::DEBUG & DEBUG::trace_call;
die $@ if $@ !~ /^ABORTBRANCH/;
();
}
else {
();
}
}

})
}))) {
do {
if (my ($C) = ($C->ws)) {
do {
if (my ($C) = (scalar(do {
$::IN_DECL = 0; 
}, $C))) {
do {
if (my ($C) = ($C->ws)) {
do {
if (my ($C) = ($C->finishpad)) {
do {
if (my ($C) = ($C->ws)) {
$C->_SUBSUMEr(['regex_block'], sub {
my $C = shift;
$C->regex_block
});
}
else {
();
}
};
}
else {
();
}
};
}
else {
();
}
};
}
else {
();
}
};
}
else {
();
}
};
}
else {
();
}
};
}
else {
();
}
};
}
else {
();
}
};
}
else {
();
}
};
}
else {
();
}
}
}))) {
$C->ws;
}
else {
();
}
};
}
else {
();
}
}} // do {die $@ if $@ and $@ !~ /ABORT/;1} 
or
eval { push @gather, do {
if (my ($C) = ($C->ws)) {
do {
if (my ($C) = ($C->panic("Malformed regex"))) {
$C->ws;
}
else {
();
}
};
}
else {
();
}
}} or do { die $@ if $@ };
@gather;
}
);
}

## rule macro_def ($CURPAD is context<rw> = $*CURPAD)
##      rule macro_def ($CURPAD is context<rw> = $*CURPAD) {
##          :my $IN_DECL is context<rw> = 1;
##          :my $DECLARAND is context<rw>;
##          [
##              [ '&'<deflongname>? | <deflongname> ]?
##              <.newpad>
##              [ <multisig> | <trait> ]*
##              <!{
##                  $*IN_DECL = 0;
##              }>
##              <blockoid>:!s
##          ] || <.panic: "Malformed macro">
##      }

sub macro_def__PEEK { $_[0]->_AUTOLEXpeek('macro_def',$retree) }
sub macro_def {
my $self = shift;
local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;
local $CURPAD = shift() // $::CURPAD;
local $::IN_DECL = 1;
local $::DECLARAND;


my $C = $self;
my $S = $C->{'_pos'};
$C->{'deflongname'} = [];
$C->{'multisig'} = [];
$C->{'trait'} = [];

$self->_MATCHIFYr($S, "macro_def", 
do { my @gather;
eval { push @gather, do {
if (my ($C) = ($C->ws)) {
do {
if (my ($C) = ($C->_BRACKETr( sub { my $C=shift;
do {
if (my ($C) = ($C->_OPTr(sub { my $C=shift;
$C->_BRACKETr( sub { my $C=shift;
do {
my @result = eval {
my $trystate;
my ($tag, $try);
my @try;
my $relex;

my $fate;
if ($fate = $C->{'_fate'} and $fate->[1] eq 'macro_def_02') {
$C->deb("Fate passed to macro_def_02: ", ::fatestr($fate)) if $::DEBUG & DEBUG::fates;
($C->{'_fate'}, $tag, $try) = @$fate;
@try = ($try);
}

my @gather = ();
for (;;) {
if (not @try) {
$relex //= $C->cursor_fate('STD', 'macro_def_02', $retree);
@try = $relex->($C, $trystate);
}
last unless @try;
$try = shift(@try) // next;

if (ref $try eq 'ARRAY') {
($C->{'_fate'}, $tag, $try) = @$try;	# next candidate fate
}

$C->deb("macro_def_02 trying $tag $try") if $::DEBUG & DEBUG::try_processing;
push @gather, ((
sub { my $C=shift;
do {
if (my ($C) = ($C->ws)) {
do {
if (my ($C) = ($C->_EXACT('&'))) {
do {
if (my ($C) = ($C->_OPTr(sub { my $C=shift;
$C->_SUBSUMEr(['deflongname'], sub {
my $C = shift;
$C->deflongname
})
}))) {
$C->ws;
}
else {
();
}
};
}
else {
();
}
};
}
else {
();
}
}
},
sub { my $C=shift;
do {
if (my ($C) = ($C->ws)) {
do {
if (my ($C) = ($C->_SUBSUMEr(['deflongname'], sub {
my $C = shift;
$C->deflongname
}))) {
$C->ws;
}
else {
();
}
};
}
else {
();
}
}
},
)[$try])->($C);
last if @gather;
}
@gather;
};
if (@result) {
@result;
}
elsif ($@) {
my ($first) = $@ =~ /(^.*)/;
$self->deb("CAUGHT $first") if $::DEBUG & DEBUG::trace_call;
die $@ if $@ !~ /^ABORTBRANCH/;
();
}
else {
();
}
}

})
}))) {
do {
if (my ($C) = ($C->ws)) {
do {
if (my ($C) = ($C->newpad)) {
do {
if (my ($C) = ($C->ws)) {
do {
if (my ($C) = ($C->_STARr(sub { my $C=shift;
$C->_BRACKETr( sub { my $C=shift;
do {
my @result = eval {
my $trystate;
my ($tag, $try);
my @try;
my $relex;

my $fate;
if ($fate = $C->{'_fate'} and $fate->[1] eq 'macro_def_03') {
$C->deb("Fate passed to macro_def_03: ", ::fatestr($fate)) if $::DEBUG & DEBUG::fates;
($C->{'_fate'}, $tag, $try) = @$fate;
@try = ($try);
}

my @gather = ();
for (;;) {
if (not @try) {
$relex //= $C->cursor_fate('STD', 'macro_def_03', $retree);
@try = $relex->($C, $trystate);
}
last unless @try;
$try = shift(@try) // next;

if (ref $try eq 'ARRAY') {
($C->{'_fate'}, $tag, $try) = @$try;	# next candidate fate
}

$C->deb("macro_def_03 trying $tag $try") if $::DEBUG & DEBUG::try_processing;
push @gather, ((
sub { my $C=shift;
do {
if (my ($C) = ($C->ws)) {
do {
if (my ($C) = ($C->_SUBSUMEr(['multisig'], sub {
my $C = shift;
$C->multisig
}))) {
$C->ws;
}
else {
();
}
};
}
else {
();
}
}
},
sub { my $C=shift;
do {
if (my ($C) = ($C->ws)) {
do {
if (my ($C) = ($C->_SUBSUMEr(['trait'], sub {
my $C = shift;
$C->trait
}))) {
$C->ws;
}
else {
();
}
};
}
else {
();
}
}
},
)[$try])->($C);
last if @gather;
}
@gather;
};
if (@result) {
@result;
}
elsif ($@) {
my ($first) = $@ =~ /(^.*)/;
$self->deb("CAUGHT $first") if $::DEBUG & DEBUG::trace_call;
die $@ if $@ !~ /^ABORTBRANCH/;
();
}
else {
();
}
}

})
}))) {
do {
if (my ($C) = ($C->ws)) {
do {
if (my ($C) = ($C->_NOTBEFORE( sub { my $C=shift;
(($C) x !!do {

$::IN_DECL = 0;

})
}))) {
do {
if (my ($C) = ($C->ws)) {
$C->_SUBSUMEr(['blockoid'], sub {
my $C = shift;
$C->blockoid
});
}
else {
();
}
};
}
else {
();
}
};
}
else {
();
}
};
}
else {
();
}
};
}
else {
();
}
};
}
else {
();
}
};
}
else {
();
}
};
}
else {
();
}
}
}))) {
$C->ws;
}
else {
();
}
};
}
else {
();
}
}} // do {die $@ if $@ and $@ !~ /ABORT/;1} 
or
eval { push @gather, do {
if (my ($C) = ($C->ws)) {
do {
if (my ($C) = ($C->panic("Malformed macro"))) {
$C->ws;
}
else {
();
}
};
}
else {
();
}
}} or do { die $@ if $@ };
@gather;
}
);
}

## rule trait
##      rule trait {
##          :my $IN_DECL is context<rw> = 0;
##          [
##          | <trait_mod>
##          | <colonpair>
##          ]
##      }

sub trait__PEEK { $_[0]->_AUTOLEXpeek('trait',$retree) }
sub trait {
my $self = shift;
local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;
local $::IN_DECL = 0;


my $C = $self;
my $S = $C->{'_pos'};

$self->_MATCHIFYr($S, "trait", 
do {
if (my ($C) = ($C->ws)) {
do {
if (my ($C) = ($C->_BRACKETr( sub { my $C=shift;
do {
my @result = eval {
my $trystate;
my ($tag, $try);
my @try;
my $relex;

my $fate;
if ($fate = $C->{'_fate'} and $fate->[1] eq 'trait_01') {
$C->deb("Fate passed to trait_01: ", ::fatestr($fate)) if $::DEBUG & DEBUG::fates;
($C->{'_fate'}, $tag, $try) = @$fate;
@try = ($try);
}

my @gather = ();
for (;;) {
if (not @try) {
$relex //= $C->cursor_fate('STD', 'trait_01', $retree);
@try = $relex->($C, $trystate);
}
last unless @try;
$try = shift(@try) // next;

if (ref $try eq 'ARRAY') {
($C->{'_fate'}, $tag, $try) = @$try;	# next candidate fate
}

$C->deb("trait_01 trying $tag $try") if $::DEBUG & DEBUG::try_processing;
push @gather, ((
sub { my $C=shift;
do {
if (my ($C) = ($C->_SUBSUMEr(['trait_mod'], sub {
my $C = shift;
$C->trait_mod
}))) {
$C->ws;
}
else {
();
}
}
},
sub { my $C=shift;
do {
if (my ($C) = ($C->_SUBSUMEr(['colonpair'], sub {
my $C = shift;
$C->colonpair
}))) {
$C->ws;
}
else {
();
}
}
},
)[$try])->($C);
last if @gather;
}
@gather;
};
if (@result) {
@result;
}
elsif ($@) {
my ($first) = $@ =~ /(^.*)/;
$self->deb("CAUGHT $first") if $::DEBUG & DEBUG::trace_call;
die $@ if $@ !~ /^ABORTBRANCH/;
();
}
else {
();
}
}

}))) {
$C->ws;
}
else {
();
}
};
}
else {
();
}
}
);
}

## token trait_mod__S_104is (:$endsym is context = 'spacey', :$sym is context<rw> = 'is')
##      token trait_mod:is {
##          <sym>:s <longname><circumfix>?  # e.g. context<rw> and Array[Int]
##          {{
##              if $*DECLARAND {
##                  my $traitname = $<longname>.Str;
##                  # XXX eventually will use multiple dispatch
##                  $*DECLARAND{$traitname} = self.gettrait($traitname, $<circumfix>);
##              }
##          }}
##      }

sub trait_mod__S_104is__PEEK { $_[0]->_AUTOLEXpeek('trait_mod__S_104is',$retree) }
sub trait_mod__S_104is {
my $self = shift;
local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;
my %args = @_;
local $endsym = $args{endsym} // 'spacey';
local $sym = $args{sym} // 'is';


my $C = $self;
my $S = $C->{'_pos'};
$C->{'circumfix'} = [];
$C->{'sym'} = $sym;

$self->_MATCHIFYr($S, "trait_mod__S_104is", 
do {
if (my ($C) = ($C->_PATTERN(qr/\Gis/))) {
do {
if (my ($C) = ($C->spacey)) {
do {
if (my ($C) = ($C->ws)) {
do {
if (my ($C) = ($C->_SUBSUMEr(['longname'], sub {
my $C = shift;
$C->longname
}))) {
do {
if (my ($C) = ($C->_OPTr(sub { my $C=shift;
$C->_SUBSUMEr(['circumfix'], sub {
my $C = shift;
$C->circumfix
})
}))) {
do {
if (my ($C) = ($C->ws)) {
do {
if (my ($C) = (scalar(do {
my $M = $C; 
if ($::DECLARAND) {
my $traitname = $M->{'longname'}->Str;
# XXX eventually will use multiple dispatch
$::DECLARAND->{$traitname} = $self->gettrait($traitname, $M->{'circumfix'});
}
;
}, $C))) {
$C->ws;
}
else {
();
}
};
}
else {
();
}
};
}
else {
();
}
};
}
else {
();
}
};
}
else {
();
}
};
}
else {
();
}
};
}
else {
();
}
}
);
}
## token trait_mod__S_105hides (:$endsym is context = 'spacey', :$sym is context<rw> = 'hides')
##      token trait_mod:hides {
##          <sym>:s <module_name>
##      }

sub trait_mod__S_105hides__PEEK { $_[0]->_AUTOLEXpeek('trait_mod__S_105hides',$retree) }
sub trait_mod__S_105hides {
my $self = shift;
local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;
my %args = @_;
local $endsym = $args{endsym} // 'spacey';
local $sym = $args{sym} // 'hides';


my $C = $self;
my $S = $C->{'_pos'};
$C->{'sym'} = $sym;

$self->_MATCHIFYr($S, "trait_mod__S_105hides", 
do {
if (my ($C) = ($C->_PATTERN(qr/\Ghides/))) {
do {
if (my ($C) = ($C->spacey)) {
do {
if (my ($C) = ($C->ws)) {
do {
if (my ($C) = ($C->_SUBSUMEr(['module_name'], sub {
my $C = shift;
$C->module_name
}))) {
$C->ws;
}
else {
();
}
};
}
else {
();
}
};
}
else {
();
}
};
}
else {
();
}
}
);
}
## token trait_mod__S_106does (:$endsym is context = 'spacey', :$sym is context<rw> = 'does')
##      token trait_mod:does {
##          :my $PKGDECL is context = 'role';
##          <sym>:s <module_name>
##      }

sub trait_mod__S_106does__PEEK { $_[0]->_AUTOLEXpeek('trait_mod__S_106does',$retree) }
sub trait_mod__S_106does {
my $self = shift;
local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;
my %args = @_;
local $endsym = $args{endsym} // 'spacey';
local $sym = $args{sym} // 'does';
local $::PKGDECL = 'role';


my $C = $self;
my $S = $C->{'_pos'};
$C->{'sym'} = $sym;

$self->_MATCHIFYr($S, "trait_mod__S_106does", 
do {
if (my ($C) = ($C->_PATTERN(qr/\Gdoes/))) {
do {
if (my ($C) = ($C->spacey)) {
do {
if (my ($C) = ($C->ws)) {
do {
if (my ($C) = ($C->_SUBSUMEr(['module_name'], sub {
my $C = shift;
$C->module_name
}))) {
$C->ws;
}
else {
();
}
};
}
else {
();
}
};
}
else {
();
}
};
}
else {
();
}
}
);
}
## token trait_mod__S_107will (:$endsym is context = 'spacey', :$sym is context<rw> = 'will')
##      token trait_mod:will {
##          <sym>:s <identifier> <block>
##      }

sub trait_mod__S_107will__PEEK { $_[0]->_AUTOLEXpeek('trait_mod__S_107will',$retree) }
sub trait_mod__S_107will {
my $self = shift;
local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;
my %args = @_;
local $endsym = $args{endsym} // 'spacey';
local $sym = $args{sym} // 'will';


my $C = $self;
my $S = $C->{'_pos'};
$C->{'sym'} = $sym;

$self->_MATCHIFYr($S, "trait_mod__S_107will", 
do {
if (my ($C) = ($C->_PATTERN(qr/\Gwill/))) {
do {
if (my ($C) = ($C->spacey)) {
do {
if (my ($C) = ($C->ws)) {
do {
if (my ($C) = ($C->_SUBSUMEr(['identifier'], sub {
my $C = shift;
$C->identifier
}))) {
do {
if (my ($C) = ($C->ws)) {
do {
if (my ($C) = ($C->_SUBSUMEr(['block'], sub {
my $C = shift;
$C->block
}))) {
$C->ws;
}
else {
();
}
};
}
else {
();
}
};
}
else {
();
}
};
}
else {
();
}
};
}
else {
();
}
};
}
else {
();
}
}
);
}

## token trait_mod__S_108of (:$endsym is context = 'spacey', :$sym is context<rw> = 'of')
##      token trait_mod:of      { <sym>:s <typename> }

sub trait_mod__S_108of__PEEK { $_[0]->_AUTOLEXpeek('trait_mod__S_108of',$retree) }
sub trait_mod__S_108of {
my $self = shift;
local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;
my %args = @_;
local $endsym = $args{endsym} // 'spacey';
local $sym = $args{sym} // 'of';


my $C = $self;
my $S = $C->{'_pos'};
$C->{'sym'} = $sym;

$self->_MATCHIFYr($S, "trait_mod__S_108of", 
do {
if (my ($C) = ($C->_PATTERN(qr/\Gof/))) {
do {
if (my ($C) = ($C->spacey)) {
do {
if (my ($C) = ($C->ws)) {
do {
if (my ($C) = ($C->_SUBSUMEr(['typename'], sub {
my $C = shift;
$C->typename
}))) {
$C->ws;
}
else {
();
}
};
}
else {
();
}
};
}
else {
();
}
};
}
else {
();
}
}
);
}
## token trait_mod__S_109as (:$endsym is context = 'spacey', :$sym is context<rw> = 'as')
##      token trait_mod:as      { <sym>:s <typename> }

sub trait_mod__S_109as__PEEK { $_[0]->_AUTOLEXpeek('trait_mod__S_109as',$retree) }
sub trait_mod__S_109as {
my $self = shift;
local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;
my %args = @_;
local $endsym = $args{endsym} // 'spacey';
local $sym = $args{sym} // 'as';


my $C = $self;
my $S = $C->{'_pos'};
$C->{'sym'} = $sym;

$self->_MATCHIFYr($S, "trait_mod__S_109as", 
do {
if (my ($C) = ($C->_PATTERN(qr/\Gas/))) {
do {
if (my ($C) = ($C->spacey)) {
do {
if (my ($C) = ($C->ws)) {
do {
if (my ($C) = ($C->_SUBSUMEr(['typename'], sub {
my $C = shift;
$C->typename
}))) {
$C->ws;
}
else {
();
}
};
}
else {
();
}
};
}
else {
();
}
};
}
else {
();
}
}
);
}
## token trait_mod__S_110returns (:$endsym is context = 'spacey', :$sym is context<rw> = 'returns')
##      token trait_mod:returns { <sym>:s <typename> }

sub trait_mod__S_110returns__PEEK { $_[0]->_AUTOLEXpeek('trait_mod__S_110returns',$retree) }
sub trait_mod__S_110returns {
my $self = shift;
local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;
my %args = @_;
local $endsym = $args{endsym} // 'spacey';
local $sym = $args{sym} // 'returns';


my $C = $self;
my $S = $C->{'_pos'};
$C->{'sym'} = $sym;

$self->_MATCHIFYr($S, "trait_mod__S_110returns", 
do {
if (my ($C) = ($C->_PATTERN(qr/\Greturns/))) {
do {
if (my ($C) = ($C->spacey)) {
do {
if (my ($C) = ($C->ws)) {
do {
if (my ($C) = ($C->_SUBSUMEr(['typename'], sub {
my $C = shift;
$C->typename
}))) {
$C->ws;
}
else {
();
}
};
}
else {
();
}
};
}
else {
();
}
};
}
else {
();
}
}
);
}
## token trait_mod__S_111handles (:$endsym is context = 'spacey', :$sym is context<rw> = 'handles')
##      token trait_mod:handles { <sym>:s <noun> }

sub trait_mod__S_111handles__PEEK { $_[0]->_AUTOLEXpeek('trait_mod__S_111handles',$retree) }
sub trait_mod__S_111handles {
my $self = shift;
local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;
my %args = @_;
local $endsym = $args{endsym} // 'spacey';
local $sym = $args{sym} // 'handles';


my $C = $self;
my $S = $C->{'_pos'};
$C->{'sym'} = $sym;

$self->_MATCHIFYr($S, "trait_mod__S_111handles", 
do {
if (my ($C) = ($C->_PATTERN(qr/\Ghandles/))) {
do {
if (my ($C) = ($C->spacey)) {
do {
if (my ($C) = ($C->ws)) {
do {
if (my ($C) = ($C->_SUBSUMEr(['noun'], sub {
my $C = shift;
$C->noun
}))) {
$C->ws;
}
else {
();
}
};
}
else {
();
}
};
}
else {
();
}
};
}
else {
();
}
}
);
}

#########
# Nouns #
#########

# (for when you want to tell EXPR that infix already parsed the term)
## token nullterm
##      token nullterm {
##          <?>
##      }

sub nullterm__PEEK { $_[0]->_AUTOLEXpeek('nullterm',$retree) }
sub nullterm {
my $self = shift;
local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;


my $C = $self;
my $S = $C->{'_pos'};

$self->_MATCHIFYr($S, "nullterm", 
$C->before( sub { my $C=shift;
$C
})
);
}

## token nulltermish
##      token nulltermish {
##          :dba('null term')
##          [
##          | <?stdstopper>
##          | <noun=termish>
##              {
##                  $¢.<PRE>  = $<noun><PRE>:delete;
##                  $¢.<POST> = $<noun><POST>:delete;
##                  $¢.<~CAPS> = $<noun><~CAPS>;
##              }
##          | <?>
##          ]
##      }

sub nulltermish__PEEK { $_[0]->_AUTOLEXpeek('nulltermish',$retree) }
sub nulltermish {
my $self = shift;
local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;


my $C = $self;
my $S = $C->{'_pos'};

$self->_MATCHIFYr($S, "nulltermish", 
$C->_BRACKETr( sub { my $C=shift;
do {
my @result = eval {
my $trystate;
my ($tag, $try);
my @try;
my $relex;

my $fate;
if ($fate = $C->{'_fate'} and $fate->[1] eq 'nulltermish_01') {
$C->deb("Fate passed to nulltermish_01: ", ::fatestr($fate)) if $::DEBUG & DEBUG::fates;
($C->{'_fate'}, $tag, $try) = @$fate;
@try = ($try);
}

my @gather = ();
for (;;) {
if (not @try) {
$relex //= $C->cursor_fate('STD', 'nulltermish_01', $retree);
@try = $relex->($C, $trystate);
}
last unless @try;
$try = shift(@try) // next;

if (ref $try eq 'ARRAY') {
($C->{'_fate'}, $tag, $try) = @$try;	# next candidate fate
}

$C->deb("nulltermish_01 trying $tag $try") if $::DEBUG & DEBUG::try_processing;
push @gather, ((
sub { my $C=shift;
$C->before( sub { my $C=shift;
$C->stdstopper
})
},
sub { my $C=shift;
do {
if (my ($C) = (    $C->_SUBSUMEr(['noun'], sub {
my $C = shift;
$C->termish
}))) {
scalar(do {
my $M = $C; 
$C->{'PRE'}  = delete $M->{'noun'}{'PRE'};
$C->{'POST'} = delete $M->{'noun'}{'POST'};
$C->{'~CAPS'} = $M->{'noun'}{'~CAPS'};
;
}, $C);
}
else {
();
}
}
},
sub { my $C=shift;
$C->before( sub { my $C=shift;
$C
})
},
)[$try])->($C);
last if @gather;
}
@gather;
};
if (@result) {
@result;
}
elsif ($@) {
my ($first) = $@ =~ /(^.*)/;
$self->deb("CAUGHT $first") if $::DEBUG & DEBUG::trace_call;
die $@ if $@ !~ /^ABORTBRANCH/;
();
}
else {
();
}
}

})
);
}

## token termish
##      token termish {
##          :my $SCOPE is context<rw> = "our";
##          :my $VAR is context<rw>;
##          :dba('prefix or noun')
##          [
##          | <PRE> [ <!{ my $p = $<PRE>; my @p = @$p; @p[*-1]<O><noun> and $<noun> = pop @$p }> <PRE> ]*
##              [ <?{ $<noun> }> || <noun> ]
##          | <noun>
##          ]
##      
##          # also queue up any postfixes
##          :dba('postfix')
##          [
##          || <?{ $*QSIGIL }>
##              [
##              || <?{ $*QSIGIL eq '$' }> [ <POST>+! <?after <[ \] } > ) ]> > ]?
##              ||                          <POST>+! <?after <[ \] } > ) ]> > 
##              || { $VAR = 0; }
##              ]
##          || <!{ $*QSIGIL }>
##              <POST>*
##          ]
##          {
##              self.check_variable($VAR) if $VAR;
##              $¢.<~CAPS> = $<noun><~CAPS>;
##          }
##      }

sub termish__PEEK { $_[0]->_AUTOLEXpeek('termish',$retree) }
sub termish {
my $self = shift;
local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;
local $::SCOPE = "our";
local $::VAR;


my $C = $self;
my $S = $C->{'_pos'};
$C->{'PRE'} = [];
$C->{'POST'} = [];

$self->_MATCHIFY($S, "termish", 
Cursor::lazymap(sub { my $C=$_[0];
Cursor::lazymap(sub { my $C=$_[0];
scalar(do {
my $M = $C; 
$self->check_variable($VAR) if $VAR;
$C->{'~CAPS'} = $M->{'noun'}{'~CAPS'};
;
}, $C)
}, $C->_BRACKET( sub { my $C=shift;
do { my @gather;
eval { push @gather, Cursor::lazymap(sub { my $C=$_[0];
$C->_BRACKET( sub { my $C=shift;
do { my @gather;
eval { push @gather, Cursor::lazymap(sub { my $C=$_[0];
$C->_OPTr(sub { my $C=shift;
$C->_BRACKET( sub { my $C=shift;
Cursor::lazymap(sub { my $C=$_[0];
$C->before( sub { my $C=shift;
$C->after(sub { my $C=shift;
$C->_PATTERN(qr/\G(?<=[\]}>)])/)
})
})
}, $C->_PLUSg(sub { my $C=shift;
$C->_SUBSUME(['POST'], sub {
my $C = shift;
$C->POST
})
}))
})
})
}, $C->before( sub { my $C=shift;
(($C) x !!do {
$::QSIGIL eq '$' 
})
}))} // do {die $@ if $@ and $@ !~ /ABORT/;1} 
or
eval { push @gather, Cursor::lazymap(sub { my $C=$_[0];
$C->before( sub { my $C=shift;
$C->after(sub { my $C=shift;
$C->_PATTERN(qr/\G(?<=[\]}>)])/)
})
})
}, $C->_PLUSg(sub { my $C=shift;
$C->_SUBSUME(['POST'], sub {
my $C = shift;
$C->POST
})
}))} // do {die $@ if $@ and $@ !~ /ABORT/;1} 
or
eval { push @gather, scalar(do {
$VAR = 0; 
}, $C)} or do { die $@ if $@ };
@gather;
}
})
}, $C->before( sub { my $C=shift;
(($C) x !!do {
$::QSIGIL 
})
}))} // do {die $@ if $@ and $@ !~ /ABORT/;1} 
or
eval { push @gather, Cursor::lazymap(sub { my $C=$_[0];
$C->_STARr(sub { my $C=shift;
$C->_SUBSUME(['POST'], sub {
my $C = shift;
$C->POST
})
})
}, $C->_NOTBEFORE( sub { my $C=shift;
(($C) x !!do {
$::QSIGIL 
})
}))} or do { die $@ if $@ };
@gather;
}
}))
}, $C->_BRACKET( sub { my $C=shift;
do {
my @result = eval {
my $trystate;
my ($tag, $try);
my @try;
my $relex;

my $fate;
if ($fate = $C->{'_fate'} and $fate->[1] eq 'termish_01') {
$C->deb("Fate passed to termish_01: ", ::fatestr($fate)) if $::DEBUG & DEBUG::fates;
($C->{'_fate'}, $tag, $try) = @$fate;
@try = ($try);
}

my @gather = ();
for (;;) {
if (not @try) {
$relex //= $C->cursor_fate('STD', 'termish_01', $retree);
@try = $relex->($C, $trystate);
}
last unless @try;
$try = shift(@try) // next;

if (ref $try eq 'ARRAY') {
($C->{'_fate'}, $tag, $try) = @$try;	# next candidate fate
}

$C->deb("termish_01 trying $tag $try") if $::DEBUG & DEBUG::try_processing;
push @gather, ((
sub { my $C=shift;
Cursor::lazymap(sub { my $C=$_[0];
Cursor::lazymap(sub { my $C=$_[0];
$C->_BRACKET( sub { my $C=shift;
do { my @gather;
eval { push @gather, $C->before( sub { my $C=shift;
(($C) x !!do {
my $M = $C;  $M->{'noun'} ;
})
})} // do {die $@ if $@ and $@ !~ /ABORT/;1} 
or
eval { push @gather, $C->_SUBSUME(['noun'], sub {
my $C = shift;
$C->noun
})} or do { die $@ if $@ };
@gather;
}
})
}, $C->_STARr(sub { my $C=shift;
$C->_BRACKET( sub { my $C=shift;
Cursor::lazymap(sub { my $C=$_[0];
$C->_SUBSUME(['PRE'], sub {
my $C = shift;
$C->PRE
})
}, $C->_NOTBEFORE( sub { my $C=shift;
(($C) x !!do {
my $M = $C;  my $p = $M->{'PRE'}; my @p = @$p; $p[-1]{'O'}{'noun'} and $M->{'noun'} = pop @$p ;
})
}))
})
}))
}, $C->_SUBSUME(['PRE'], sub {
my $C = shift;
$C->PRE
}))
},
sub { my $C=shift;
$C->_SUBSUME(['noun'], sub {
my $C = shift;
$C->noun
})
},
)[$try])->($C);
last if @gather;
}
@gather;
};
if (@result) {
@result;
}
elsif ($@) {
my ($first) = $@ =~ /(^.*)/;
$self->deb("CAUGHT $first") if $::DEBUG & DEBUG::trace_call;
die $@ if $@ !~ /^ABORTBRANCH/;
();
}
else {
();
}
}

}))
);
}

## token noun__S_112fatarrow (:$sym is context<rw> = 'fatarrow')
##      token noun:fatarrow           { <fatarrow> }

sub noun__S_112fatarrow__PEEK { $_[0]->_AUTOLEXpeek('noun__S_112fatarrow',$retree) }
sub noun__S_112fatarrow {
my $self = shift;
local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;
my %args = @_;
local $sym = $args{sym} // 'fatarrow';


my $C = $self;
my $S = $C->{'_pos'};
$C->{'sym'} = $sym;

$self->_MATCHIFYr($S, "noun__S_112fatarrow", 
$C->_SUBSUMEr(['fatarrow'], sub {
my $C = shift;
$C->fatarrow
})
);
}
## token noun__S_113variable (:$sym is context<rw> = 'variable')
##      token noun:variable           { <variable> { $*VAR = $<variable> } }

sub noun__S_113variable__PEEK { $_[0]->_AUTOLEXpeek('noun__S_113variable',$retree) }
sub noun__S_113variable {
my $self = shift;
local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;
my %args = @_;
local $sym = $args{sym} // 'variable';


my $C = $self;
my $S = $C->{'_pos'};
$C->{'sym'} = $sym;

$self->_MATCHIFYr($S, "noun__S_113variable", 
do {
if (my ($C) = ($C->_SUBSUMEr(['variable'], sub {
my $C = shift;
$C->variable
}))) {
scalar(do {
my $M = $C;  $::VAR = $M->{'variable'} ;
}, $C);
}
else {
();
}
}
);
}
## token noun__S_114package_declarator (:$sym is context<rw> = 'package_declarator')
##      token noun:package_declarator { <package_declarator> }

sub noun__S_114package_declarator__PEEK { $_[0]->_AUTOLEXpeek('noun__S_114package_declarator',$retree) }
sub noun__S_114package_declarator {
my $self = shift;
local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;
my %args = @_;
local $sym = $args{sym} // 'package_declarator';


my $C = $self;
my $S = $C->{'_pos'};
$C->{'sym'} = $sym;

$self->_MATCHIFYr($S, "noun__S_114package_declarator", 
$C->_SUBSUMEr(['package_declarator'], sub {
my $C = shift;
$C->package_declarator
})
);
}
## token noun__S_115scope_declarator (:$sym is context<rw> = 'scope_declarator')
##      token noun:scope_declarator   { <scope_declarator> }

sub noun__S_115scope_declarator__PEEK { $_[0]->_AUTOLEXpeek('noun__S_115scope_declarator',$retree) }
sub noun__S_115scope_declarator {
my $self = shift;
local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;
my %args = @_;
local $sym = $args{sym} // 'scope_declarator';


my $C = $self;
my $S = $C->{'_pos'};
$C->{'sym'} = $sym;

$self->_MATCHIFYr($S, "noun__S_115scope_declarator", 
$C->_SUBSUMEr(['scope_declarator'], sub {
my $C = shift;
$C->scope_declarator
})
);
}
## token noun__S_116multi_declarator (:$sym is context<rw> = 'multi_declarator')
##      token noun:multi_declarator   { <?before 'multi'|'proto'|'only'> <multi_declarator> }

sub noun__S_116multi_declarator__PEEK { $_[0]->_AUTOLEXpeek('noun__S_116multi_declarator',$retree) }
sub noun__S_116multi_declarator {
my $self = shift;
local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;
my %args = @_;
local $sym = $args{sym} // 'multi_declarator';


my $C = $self;
my $S = $C->{'_pos'};
$C->{'sym'} = $sym;

$self->_MATCHIFYr($S, "noun__S_116multi_declarator", 
do {
if (my ($C) = ($C->before(sub { my $C=shift;
do {
my @result = eval {
my $trystate;
my ($tag, $try);
my @try;
my $relex;

my $fate;
if ($fate = $C->{'_fate'} and $fate->[1] eq 'noun__S_116multi_declarator_01') {
$C->deb("Fate passed to noun__S_116multi_declarator_01: ", ::fatestr($fate)) if $::DEBUG & DEBUG::fates;
($C->{'_fate'}, $tag, $try) = @$fate;
@try = ($try);
}

my @gather = ();
for (;;) {
if (not @try) {
$relex //= $C->cursor_fate('STD', 'noun__S_116multi_declarator_01', $retree);
@try = $relex->($C, $trystate);
}
last unless @try;
$try = shift(@try) // next;

if (ref $try eq 'ARRAY') {
($C->{'_fate'}, $tag, $try) = @$try;	# next candidate fate
}

$C->deb("noun__S_116multi_declarator_01 trying $tag $try") if $::DEBUG & DEBUG::try_processing;
push @gather, ((
sub { my $C=shift;
$C->_EXACT('multi')
},
sub { my $C=shift;
$C->_EXACT('proto')
},
sub { my $C=shift;
$C->_EXACT('only')
},
)[$try])->($C);
last if @gather;
}
@gather;
};
if (@result) {
@result;
}
elsif ($@) {
my ($first) = $@ =~ /(^.*)/;
$self->deb("CAUGHT $first") if $::DEBUG & DEBUG::trace_call;
die $@ if $@ !~ /^ABORTBRANCH/;
();
}
else {
();
}
}

}))) {
$C->_SUBSUMEr(['multi_declarator'], sub {
my $C = shift;
$C->multi_declarator
});
}
else {
();
}
}
);
}
## token noun__S_117routine_declarator (:$sym is context<rw> = 'routine_declarator')
##      token noun:routine_declarator { <routine_declarator> }

sub noun__S_117routine_declarator__PEEK { $_[0]->_AUTOLEXpeek('noun__S_117routine_declarator',$retree) }
sub noun__S_117routine_declarator {
my $self = shift;
local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;
my %args = @_;
local $sym = $args{sym} // 'routine_declarator';


my $C = $self;
my $S = $C->{'_pos'};
$C->{'sym'} = $sym;

$self->_MATCHIFYr($S, "noun__S_117routine_declarator", 
$C->_SUBSUMEr(['routine_declarator'], sub {
my $C = shift;
$C->routine_declarator
})
);
}
## token noun__S_118regex_declarator (:$sym is context<rw> = 'regex_declarator')
##      token noun:regex_declarator   { <regex_declarator> }

sub noun__S_118regex_declarator__PEEK { $_[0]->_AUTOLEXpeek('noun__S_118regex_declarator',$retree) }
sub noun__S_118regex_declarator {
my $self = shift;
local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;
my %args = @_;
local $sym = $args{sym} // 'regex_declarator';


my $C = $self;
my $S = $C->{'_pos'};
$C->{'sym'} = $sym;

$self->_MATCHIFYr($S, "noun__S_118regex_declarator", 
$C->_SUBSUMEr(['regex_declarator'], sub {
my $C = shift;
$C->regex_declarator
})
);
}
## token noun__S_119type_declarator (:$sym is context<rw> = 'type_declarator')
##      token noun:type_declarator    { <type_declarator> }

sub noun__S_119type_declarator__PEEK { $_[0]->_AUTOLEXpeek('noun__S_119type_declarator',$retree) }
sub noun__S_119type_declarator {
my $self = shift;
local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;
my %args = @_;
local $sym = $args{sym} // 'type_declarator';


my $C = $self;
my $S = $C->{'_pos'};
$C->{'sym'} = $sym;

$self->_MATCHIFYr($S, "noun__S_119type_declarator", 
$C->_SUBSUMEr(['type_declarator'], sub {
my $C = shift;
$C->type_declarator
})
);
}
## token noun__S_120circumfix (:$sym is context<rw> = 'circumfix')
##      token noun:circumfix          { <circumfix> }

sub noun__S_120circumfix__PEEK { $_[0]->_AUTOLEXpeek('noun__S_120circumfix',$retree) }
sub noun__S_120circumfix {
my $self = shift;
local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;
my %args = @_;
local $sym = $args{sym} // 'circumfix';


my $C = $self;
my $S = $C->{'_pos'};
$C->{'sym'} = $sym;

$self->_MATCHIFYr($S, "noun__S_120circumfix", 
$C->_SUBSUMEr(['circumfix'], sub {
my $C = shift;
$C->circumfix
})
);
}
## token noun__S_121dotty (:$sym is context<rw> = 'dotty')
##      token noun:dotty              { <dotty> }

sub noun__S_121dotty__PEEK { $_[0]->_AUTOLEXpeek('noun__S_121dotty',$retree) }
sub noun__S_121dotty {
my $self = shift;
local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;
my %args = @_;
local $sym = $args{sym} // 'dotty';


my $C = $self;
my $S = $C->{'_pos'};
$C->{'sym'} = $sym;

$self->_MATCHIFYr($S, "noun__S_121dotty", 
$C->_SUBSUMEr(['dotty'], sub {
my $C = shift;
$C->dotty
})
);
}
## token noun__S_122value (:$sym is context<rw> = 'value')
##      token noun:value              { <value> }

sub noun__S_122value__PEEK { $_[0]->_AUTOLEXpeek('noun__S_122value',$retree) }
sub noun__S_122value {
my $self = shift;
local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;
my %args = @_;
local $sym = $args{sym} // 'value';


my $C = $self;
my $S = $C->{'_pos'};
$C->{'sym'} = $sym;

$self->_MATCHIFYr($S, "noun__S_122value", 
$C->_SUBSUMEr(['value'], sub {
my $C = shift;
$C->value
})
);
}
## token noun__S_123capterm (:$sym is context<rw> = 'capterm')
##      token noun:capterm            { <capterm> }

sub noun__S_123capterm__PEEK { $_[0]->_AUTOLEXpeek('noun__S_123capterm',$retree) }
sub noun__S_123capterm {
my $self = shift;
local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;
my %args = @_;
local $sym = $args{sym} // 'capterm';


my $C = $self;
my $S = $C->{'_pos'};
$C->{'sym'} = $sym;

$self->_MATCHIFYr($S, "noun__S_123capterm", 
$C->_SUBSUMEr(['capterm'], sub {
my $C = shift;
$C->capterm
})
);
}
## token noun__S_124sigterm (:$sym is context<rw> = 'sigterm')
##      token noun:sigterm            { <sigterm> }

sub noun__S_124sigterm__PEEK { $_[0]->_AUTOLEXpeek('noun__S_124sigterm',$retree) }
sub noun__S_124sigterm {
my $self = shift;
local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;
my %args = @_;
local $sym = $args{sym} // 'sigterm';


my $C = $self;
my $S = $C->{'_pos'};
$C->{'sym'} = $sym;

$self->_MATCHIFYr($S, "noun__S_124sigterm", 
$C->_SUBSUMEr(['sigterm'], sub {
my $C = shift;
$C->sigterm
})
);
}
## token noun__S_125term (:$sym is context<rw> = 'term')
##      token noun:term               { <term> }

sub noun__S_125term__PEEK { $_[0]->_AUTOLEXpeek('noun__S_125term',$retree) }
sub noun__S_125term {
my $self = shift;
local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;
my %args = @_;
local $sym = $args{sym} // 'term';


my $C = $self;
my $S = $C->{'_pos'};
$C->{'sym'} = $sym;

$self->_MATCHIFYr($S, "noun__S_125term", 
$C->_SUBSUMEr(['term'], sub {
my $C = shift;
$C->term
})
);
}
## token noun__S_126statement_prefix (:$sym is context<rw> = 'statement_prefix')
##      token noun:statement_prefix   { <statement_prefix> }

sub noun__S_126statement_prefix__PEEK { $_[0]->_AUTOLEXpeek('noun__S_126statement_prefix',$retree) }
sub noun__S_126statement_prefix {
my $self = shift;
local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;
my %args = @_;
local $sym = $args{sym} // 'statement_prefix';


my $C = $self;
my $S = $C->{'_pos'};
$C->{'sym'} = $sym;

$self->_MATCHIFYr($S, "noun__S_126statement_prefix", 
$C->_SUBSUMEr(['statement_prefix'], sub {
my $C = shift;
$C->statement_prefix
})
);
}
## token noun__S_127colonpair (:$sym is context<rw> = 'colonpair')
##      token noun:colonpair          { [ <colonpair> <.ws> ]+ }

sub noun__S_127colonpair__PEEK { $_[0]->_AUTOLEXpeek('noun__S_127colonpair',$retree) }
sub noun__S_127colonpair {
my $self = shift;
local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;
my %args = @_;
local $sym = $args{sym} // 'colonpair';


my $C = $self;
my $S = $C->{'_pos'};
$C->{'colonpair'} = [];
$C->{'sym'} = $sym;

$self->_MATCHIFYr($S, "noun__S_127colonpair", 
$C->_PLUSr(sub { my $C=shift;
$C->_BRACKETr( sub { my $C=shift;
do {
if (my ($C) = ($C->_SUBSUMEr(['colonpair'], sub {
my $C = shift;
$C->colonpair
}))) {
$C->ws;
}
else {
();
}
}
})
})
);
}

## token fatarrow
##      token fatarrow {
##          <key=identifier> \h* '=>' <.ws> <val=EXPR(item %item_assignment)>
##      }

sub fatarrow__PEEK { $_[0]->_AUTOLEXpeek('fatarrow',$retree) }
sub fatarrow {
my $self = shift;
local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;


my $C = $self;
my $S = $C->{'_pos'};

$self->_MATCHIFYr($S, "fatarrow", 
do {
if (my ($C) = (    $C->_SUBSUMEr(['key'], sub {
my $C = shift;
$C->identifier
}))) {
do {
if (my ($C) = ($C->_PATTERN(qr/\G((?:[\x20\t\r])*+)/))) {
do {
if (my ($C) = ($C->_EXACT('=>'))) {
do {
if (my ($C) = ($C->ws)) {
$C->_SUBSUMEr(['val'], sub {
my $C = shift;
$C->EXPR(\%item_assignment)
});
}
else {
();
}
};
}
else {
();
}
};
}
else {
();
}
};
}
else {
();
}
}
);
}

## token colonpair
##      token colonpair {
##          :my $key;
##          :my $value;
##      
##          ':'
##          :dba('colon pair')
##          [
##          | '!' <identifier>
##              { $key = $<identifier>.Str; $value = 0; }
##              {*}                                                     #= false
##          | $<num> = [\d+] <identifier>
##          | <identifier>
##              { $key = $<identifier>.Str; }
##              [
##              || <.unsp>? <circumfix> { $value = $<circumfix>; }
##              || { $value = 1; }
##              ]
##              {*}                                                     #= value
##          | :dba('signature') '(' ~ ')' <fakesignature>
##          | <circumfix>
##              { $key = ""; $value = $<circumfix>; }
##              {*}                                                     #= structural
##          | $<var> = (<sigil> {} <twigil>? <desigilname>)
##              { $key = $<var><desigilname>.Str; $value = $<var>; }
##              {*}                                                     #= varname
##          ]
##          { $<k> = $key; $<v> = $value; }
##      }

sub colonpair__PEEK { $_[0]->_AUTOLEXpeek('colonpair',$retree) }
sub colonpair {
my $self = shift;
local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;
my $key;
my $value;


my $C = $self;
my $S = $C->{'_pos'};

$self->_MATCHIFY($S, "colonpair", 
Cursor::lazymap(sub { my $C=$_[0];
Cursor::lazymap(sub { my $C=$_[0];
scalar(do {
my $M = $C;  $M->{'k'} = $key; $M->{'v'} = $value; ;
}, $C)
}, $C->_BRACKET( sub { my $C=shift;
do {
my @result = eval {
my $trystate;
my ($tag, $try);
my @try;
my $relex;

my $fate;
if ($fate = $C->{'_fate'} and $fate->[1] eq 'colonpair_01') {
$C->deb("Fate passed to colonpair_01: ", ::fatestr($fate)) if $::DEBUG & DEBUG::fates;
($C->{'_fate'}, $tag, $try) = @$fate;
@try = ($try);
}

my @gather = ();
for (;;) {
if (not @try) {
$relex //= $C->cursor_fate('STD', 'colonpair_01', $retree);
@try = $relex->($C, $trystate);
}
last unless @try;
$try = shift(@try) // next;

if (ref $try eq 'ARRAY') {
($C->{'_fate'}, $tag, $try) = @$try;	# next candidate fate
}

$C->deb("colonpair_01 trying $tag $try") if $::DEBUG & DEBUG::try_processing;
push @gather, ((
sub { my $C=shift;
do {
if (my ($C) = ($C->_EXACT('!'))) {
do {
if (my ($C) = ($C->_SUBSUMEr(['identifier'], sub {
my $C = shift;
$C->identifier
}))) {
do {
if (my ($C) = (scalar(do {
my $M = $C;  $key = $M->{'identifier'}->Str; $value = 0; ;
}, $C))) {
$C->_REDUCE($S, 'colonpair', 'false');
}
else {
();
}
};
}
else {
();
}
};
}
else {
();
}
}
},
sub { my $C=shift;
do {
if (my ($C) = (    $C->_SUBSUMEr(['num'], sub {
my $C = shift;
$C->_BRACKETr( sub { my $C=shift;
$C->_PATTERN(qr/\G((?:\d)++)/)
})
}))) {
$C->_SUBSUMEr(['identifier'], sub {
my $C = shift;
$C->identifier
});
}
else {
();
}
}
},
sub { my $C=shift;
do {
if (my ($C) = ($C->_SUBSUMEr(['identifier'], sub {
my $C = shift;
$C->identifier
}))) {
do {
if (my ($C) = (scalar(do {
my $M = $C;  $key = $M->{'identifier'}->Str; ;
}, $C))) {
do {
if (my ($C) = ($C->_BRACKETr( sub { my $C=shift;
do { my @gather;
eval { push @gather, do {
if (my ($C) = ($C->_OPTr(sub { my $C=shift;
$C->unsp
}))) {
do {
if (my ($C) = ($C->_SUBSUMEr(['circumfix'], sub {
my $C = shift;
$C->circumfix
}))) {
scalar(do {
my $M = $C;  $value = $M->{'circumfix'}; ;
}, $C);
}
else {
();
}
};
}
else {
();
}
}} // do {die $@ if $@ and $@ !~ /ABORT/;1} 
or
eval { push @gather, scalar(do {
$value = 1; 
}, $C)} or do { die $@ if $@ };
@gather;
}
}))) {
$C->_REDUCE($S, 'colonpair', 'value');
}
else {
();
}
};
}
else {
();
}
};
}
else {
();
}
}
},
sub { my $C=shift;
Cursor::lazymap(sub { my $C=$_[0];
Cursor::lazymap(sub { my $C=$_[0];
Cursor::lazymap(sub { my $C=$_[0];
$C->_BRACKET( sub { my $C=shift;
do { my @gather;
eval { push @gather, $C->_EXACT(')')} // do {die $@ if $@ and $@ !~ /ABORT/;1} 
or
eval { push @gather, $C->FAILGOAL(')' , 'signature')} or do { die $@ if $@ };
@gather;
}
})
}, $C->_SUBSUME(['fakesignature'], sub {
my $C = shift;
$C->fakesignature
}))
}, $C->_COMMITBRANCH(local $::GOAL = ')' ))
}, $C->_EXACT('('))
},
sub { my $C=shift;
Cursor::lazymap(sub { my $C=$_[0];
Cursor::lazymap(sub { my $C=$_[0];
$C->_REDUCE($S, 'colonpair', 'structural')
}, scalar(do {
my $M = $C;  $key = ""; $value = $M->{'circumfix'}; ;
}, $C))
}, $C->_SUBSUME(['circumfix'], sub {
my $C = shift;
$C->circumfix
}))
},
sub { my $C=shift;
Cursor::lazymap(sub { my $C=$_[0];
Cursor::lazymap(sub { my $C=$_[0];
$C->_REDUCE($S, 'colonpair', 'varname')
}, scalar(do {
my $M = $C;  $key = $M->{'var'}{'desigilname'}->Str; $value = $M->{'var'}; ;
}, $C))
},     $C->_SUBSUME(['var'], sub {
my $C = shift;
do { $C->_PAREN( sub { my $C=shift;
Cursor::lazymap(sub { my $C=$_[0];
Cursor::lazymap(sub { my $C=$_[0];
Cursor::lazymap(sub { my $C=$_[0];
$C->_SUBSUME(['desigilname'], sub {
my $C = shift;
$C->desigilname
})
}, $C->_OPTr(sub { my $C=shift;
$C->_SUBSUME(['twigil'], sub {
my $C = shift;
$C->twigil
})
}))
}, scalar(do {

}, $C))
}, $C->_SUBSUME(['sigil'], sub {
my $C = shift;
$C->sigil
}))
})}
}))
},
)[$try])->($C);
last if @gather;
}
@gather;
};
if (@result) {
@result;
}
elsif ($@) {
my ($first) = $@ =~ /(^.*)/;
$self->deb("CAUGHT $first") if $::DEBUG & DEBUG::trace_call;
die $@ if $@ !~ /^ABORTBRANCH/;
();
}
else {
();
}
}

}))
}, $C->_EXACT(':'))
);
}

## token quotepair
##      token quotepair {
##          :my $key;
##          :my $value;
##      
##          ':'
##          :dba('colon pair (restricted)')
##          [
##          | '!' <identifier>
##              { $key = $<identifier>.Str; $value = 0; }
##              {*}                                                     #= false
##          | <identifier>
##              { $key = $<identifier>.Str; }
##              [
##              || <.unsp>? <?before '('> <circumfix> { $value = $<circumfix>; }
##              || { $value = 1; }
##              ]
##              {*}                                                     #= value
##          | $<n>=(\d+) $<id>=(<[a..z]>+)
##              { $key = $<id>.Str; $value = $<n>.Str; }
##              {*}                                                     #= nth
##          ]
##          { $<k> = $key; $<v> = $value; }
##      }

sub quotepair__PEEK { $_[0]->_AUTOLEXpeek('quotepair',$retree) }
sub quotepair {
my $self = shift;
local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;
my $key;
my $value;


my $C = $self;
my $S = $C->{'_pos'};

$self->_MATCHIFYr($S, "quotepair", 
do {
if (my ($C) = ($C->_EXACT(':'))) {
do {
if (my ($C) = ($C->_BRACKETr( sub { my $C=shift;
do {
my @result = eval {
my $trystate;
my ($tag, $try);
my @try;
my $relex;

my $fate;
if ($fate = $C->{'_fate'} and $fate->[1] eq 'quotepair_01') {
$C->deb("Fate passed to quotepair_01: ", ::fatestr($fate)) if $::DEBUG & DEBUG::fates;
($C->{'_fate'}, $tag, $try) = @$fate;
@try = ($try);
}

my @gather = ();
for (;;) {
if (not @try) {
$relex //= $C->cursor_fate('STD', 'quotepair_01', $retree);
@try = $relex->($C, $trystate);
}
last unless @try;
$try = shift(@try) // next;

if (ref $try eq 'ARRAY') {
($C->{'_fate'}, $tag, $try) = @$try;	# next candidate fate
}

$C->deb("quotepair_01 trying $tag $try") if $::DEBUG & DEBUG::try_processing;
push @gather, ((
sub { my $C=shift;
do {
if (my ($C) = ($C->_EXACT('!'))) {
do {
if (my ($C) = ($C->_SUBSUMEr(['identifier'], sub {
my $C = shift;
$C->identifier
}))) {
do {
if (my ($C) = (scalar(do {
my $M = $C;  $key = $M->{'identifier'}->Str; $value = 0; ;
}, $C))) {
$C->_REDUCE($S, 'quotepair', 'false');
}
else {
();
}
};
}
else {
();
}
};
}
else {
();
}
}
},
sub { my $C=shift;
do {
if (my ($C) = ($C->_SUBSUMEr(['identifier'], sub {
my $C = shift;
$C->identifier
}))) {
do {
if (my ($C) = (scalar(do {
my $M = $C;  $key = $M->{'identifier'}->Str; ;
}, $C))) {
do {
if (my ($C) = ($C->_BRACKETr( sub { my $C=shift;
do { my @gather;
eval { push @gather, do {
if (my ($C) = ($C->_OPTr(sub { my $C=shift;
$C->unsp
}))) {
do {
if (my ($C) = ($C->before(sub { my $C=shift;
$C->_EXACT('(')
}))) {
do {
if (my ($C) = ($C->_SUBSUMEr(['circumfix'], sub {
my $C = shift;
$C->circumfix
}))) {
scalar(do {
my $M = $C;  $value = $M->{'circumfix'}; ;
}, $C);
}
else {
();
}
};
}
else {
();
}
};
}
else {
();
}
}} // do {die $@ if $@ and $@ !~ /ABORT/;1} 
or
eval { push @gather, scalar(do {
$value = 1; 
}, $C)} or do { die $@ if $@ };
@gather;
}
}))) {
$C->_REDUCE($S, 'quotepair', 'value');
}
else {
();
}
};
}
else {
();
}
};
}
else {
();
}
}
},
sub { my $C=shift;
do {
if (my ($C) = (    $C->_SUBSUMEr(['n'], sub {
my $C = shift;
do { $C->_PAREN( sub { my $C=shift;
$C->_PATTERN(qr/\G((?:\d)++)/)
})}
}))) {
do {
if (my ($C) = (    $C->_SUBSUMEr(['id'], sub {
my $C = shift;
do { $C->_PAREN( sub { my $C=shift;
$C->_PATTERN(qr/\G((?:[a-z])++)/)
})}
}))) {
do {
if (my ($C) = (scalar(do {
my $M = $C;  $key = $M->{'id'}->Str; $value = $M->{'n'}->Str; ;
}, $C))) {
$C->_REDUCE($S, 'quotepair', 'nth');
}
else {
();
}
};
}
else {
();
}
};
}
else {
();
}
}
},
)[$try])->($C);
last if @gather;
}
@gather;
};
if (@result) {
@result;
}
elsif ($@) {
my ($first) = $@ =~ /(^.*)/;
$self->deb("CAUGHT $first") if $::DEBUG & DEBUG::trace_call;
die $@ if $@ !~ /^ABORTBRANCH/;
();
}
else {
();
}
}

}))) {
scalar(do {
my $M = $C;  $M->{'k'} = $key; $M->{'v'} = $value; ;
}, $C);
}
else {
();
}
};
}
else {
();
}
}
);
}

# Most of these special variable rules are there simply to catch old p5 brainos

## token special_variable__S_128Dollar_a2_ (:$sym is context<rw> = <$¢>)
##      token special_variable:sym<$¢> { <sym> }

sub special_variable__S_128Dollar_a2___PEEK { $_[0]->_AUTOLEXpeek('special_variable__S_128Dollar_a2_',$retree) }
sub special_variable__S_128Dollar_a2_ {
my $self = shift;
local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;
my %args = @_;
local $sym = $args{sym} // q($¢);


my $C = $self;
my $S = $C->{'_pos'};
$C->{'sym'} = $sym;

$self->_MATCHIFYr($S, "special_variable__S_128Dollar_a2_", 
$C->_PATTERN(qr/\G\$¢/)
);
}

## token special_variable__S_129DollarBang (:$sym is context<rw> = <$!>)
##      token special_variable:sym<$!> { <sym> <!before \w> }

sub special_variable__S_129DollarBang__PEEK { $_[0]->_AUTOLEXpeek('special_variable__S_129DollarBang',$retree) }
sub special_variable__S_129DollarBang {
my $self = shift;
local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;
my %args = @_;
local $sym = $args{sym} // q($!);


my $C = $self;
my $S = $C->{'_pos'};
$C->{'sym'} = $sym;

$self->_MATCHIFYr($S, "special_variable__S_129DollarBang", 
do {
if (my ($C) = ($C->_PATTERN(qr/\G\$\!/))) {
$C->_NOTBEFORE( sub { my $C=shift;
$C->before(sub { my $C=shift;
$C->_PATTERN(qr/\G\w/)
})
});
}
else {
();
}
}
);
}

## token special_variable__S_130DollarBangCur_Ly (:$sym is context<rw> = <$!{ }>)
##      token special_variable:sym<$!{ }> {
##          ( '$!{' :: (.*?) '}' )
##          <.obs($0.Str ~ " variable", 'smart match against $!')>
##      }

sub special_variable__S_130DollarBangCur_Ly__PEEK { $_[0]->_AUTOLEXpeek('special_variable__S_130DollarBangCur_Ly',$retree) }
sub special_variable__S_130DollarBangCur_Ly {
my $self = shift;
local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;
my %args = @_;
local $sym = $args{sym} // [qw($!{ })];


my $C = $self;
my $S = $C->{'_pos'};
$C->{'sym'} = $sym;

$self->_MATCHIFY($S, "special_variable__S_130DollarBangCur_Ly", 
Cursor::lazymap(sub { my $C=$_[0];
$C->obs($C->{'0'}->Str . " variable", 'smart match against $!')
},     $C->_SUBSUME(['0'], sub {
my $C = shift;
do { $C->_PAREN( sub { my $C=shift;
Cursor::lazymap(sub { my $C=$_[0];
Cursor::lazymap(sub { my $C=$_[0];
Cursor::lazymap(sub { my $C=$_[0];
$C->_EXACT('}')
},     $C->_SUBSUME(['0'], sub {
my $C = shift;
do { $C->_PAREN( sub { my $C=shift;
$C->_SCANf()
})}
}))
}, $C->_COMMITBRANCH())
}, $C->_EXACT('$!{'))
})}
}))
);
}

## token special_variable__S_131DollarSlash (:$sym is context<rw> = <$/>)
##      token special_variable:sym<$/> {
##          <sym>
##          # XXX assuming nobody ever wants to assign $/ directly anymore...
##          [ <?before \h* '=' <![=]> >
##              <.obs('$/ variable as input record separator',
##                   "filehandle's :irs attribute")>
##          ]?
##      }

sub special_variable__S_131DollarSlash__PEEK { $_[0]->_AUTOLEXpeek('special_variable__S_131DollarSlash',$retree) }
sub special_variable__S_131DollarSlash {
my $self = shift;
local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;
my %args = @_;
local $sym = $args{sym} // q($/);


my $C = $self;
my $S = $C->{'_pos'};
$C->{'sym'} = $sym;

$self->_MATCHIFYr($S, "special_variable__S_131DollarSlash", 
do {
if (my ($C) = ($C->_PATTERN(qr/\G\$\//))) {
$C->_OPTr(sub { my $C=shift;
$C->_BRACKETr( sub { my $C=shift;
do {
if (my ($C) = ($C->before(sub { my $C=shift;
do {
if (my ($C) = ($C->_PATTERN(qr/\G((?:[\x20\t\r])*+)/))) {
do {
if (my ($C) = ($C->_EXACT('='))) {
$C->_NOTBEFORE( sub { my $C=shift;
$C->_PATTERN(qr/\G[=]/)
});
}
else {
();
}
};
}
else {
();
}
}
}))) {
$C->obs('$/ variable as input record separator',
"filehandle's :irs attribute");
}
else {
();
}
}
})
});
}
else {
();
}
}
);
}

## token special_variable__S_132DollarTilde (:$sym is context<rw> = <$~>)
##      token special_variable:sym<$~> {
##          <sym> :: <?before \s | ',' | '=' | <terminator> >
##          <.obs('$~ variable', 'Form module')>
##      }

sub special_variable__S_132DollarTilde__PEEK { $_[0]->_AUTOLEXpeek('special_variable__S_132DollarTilde',$retree) }
sub special_variable__S_132DollarTilde {
my $self = shift;
local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;
my %args = @_;
local $sym = $args{sym} // q($~);


my $C = $self;
my $S = $C->{'_pos'};
$C->{'sym'} = $sym;

$self->_MATCHIFY($S, "special_variable__S_132DollarTilde", 
Cursor::lazymap(sub { my $C=$_[0];
Cursor::lazymap(sub { my $C=$_[0];
Cursor::lazymap(sub { my $C=$_[0];
$C->obs('$~ variable', 'Form module')
}, $C->before(sub { my $C=shift;
do {
my @result = eval {
my $trystate;
my ($tag, $try);
my @try;
my $relex;

my $fate;
if ($fate = $C->{'_fate'} and $fate->[1] eq 'special_variable__S_132DollarTilde_01') {
$C->deb("Fate passed to special_variable__S_132DollarTilde_01: ", ::fatestr($fate)) if $::DEBUG & DEBUG::fates;
($C->{'_fate'}, $tag, $try) = @$fate;
@try = ($try);
}

my @gather = ();
for (;;) {
if (not @try) {
$relex //= $C->cursor_fate('STD', 'special_variable__S_132DollarTilde_01', $retree);
@try = $relex->($C, $trystate);
}
last unless @try;
$try = shift(@try) // next;

if (ref $try eq 'ARRAY') {
($C->{'_fate'}, $tag, $try) = @$try;	# next candidate fate
}

$C->deb("special_variable__S_132DollarTilde_01 trying $tag $try") if $::DEBUG & DEBUG::try_processing;
push @gather, ((
sub { my $C=shift;
$C->_PATTERN(qr/\G\s/)
},
sub { my $C=shift;
$C->_EXACT(',')
},
sub { my $C=shift;
$C->_EXACT('=')
},
sub { my $C=shift;
$C->_SUBSUME(['terminator'], sub {
my $C = shift;
$C->terminator
})
},
)[$try])->($C);
last if @gather;
}
@gather;
};
if (@result) {
@result;
}
elsif ($@) {
my ($first) = $@ =~ /(^.*)/;
$self->deb("CAUGHT $first") if $::DEBUG & DEBUG::trace_call;
die $@ if $@ !~ /^ABORTBRANCH/;
();
}
else {
();
}
}

}))
}, $C->_COMMITBRANCH())
}, $C->_PATTERN(qr/\G\$\~/))
);
}

## token special_variable__S_133DollarGrave (:$sym is context<rw> = <$`>)
##      token special_variable:sym<$`> {
##          <sym> :: <?before \s | ',' | <terminator> >
##          <.obs('$` variable', 'explicit pattern before <(')>
##      }

sub special_variable__S_133DollarGrave__PEEK { $_[0]->_AUTOLEXpeek('special_variable__S_133DollarGrave',$retree) }
sub special_variable__S_133DollarGrave {
my $self = shift;
local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;
my %args = @_;
local $sym = $args{sym} // q($`);


my $C = $self;
my $S = $C->{'_pos'};
$C->{'sym'} = $sym;

$self->_MATCHIFY($S, "special_variable__S_133DollarGrave", 
Cursor::lazymap(sub { my $C=$_[0];
Cursor::lazymap(sub { my $C=$_[0];
Cursor::lazymap(sub { my $C=$_[0];
$C->obs('$` variable', 'explicit pattern before <(')
}, $C->before(sub { my $C=shift;
do {
my @result = eval {
my $trystate;
my ($tag, $try);
my @try;
my $relex;

my $fate;
if ($fate = $C->{'_fate'} and $fate->[1] eq 'special_variable__S_133DollarGrave_01') {
$C->deb("Fate passed to special_variable__S_133DollarGrave_01: ", ::fatestr($fate)) if $::DEBUG & DEBUG::fates;
($C->{'_fate'}, $tag, $try) = @$fate;
@try = ($try);
}

my @gather = ();
for (;;) {
if (not @try) {
$relex //= $C->cursor_fate('STD', 'special_variable__S_133DollarGrave_01', $retree);
@try = $relex->($C, $trystate);
}
last unless @try;
$try = shift(@try) // next;

if (ref $try eq 'ARRAY') {
($C->{'_fate'}, $tag, $try) = @$try;	# next candidate fate
}

$C->deb("special_variable__S_133DollarGrave_01 trying $tag $try") if $::DEBUG & DEBUG::try_processing;
push @gather, ((
sub { my $C=shift;
$C->_PATTERN(qr/\G\s/)
},
sub { my $C=shift;
$C->_EXACT(',')
},
sub { my $C=shift;
$C->_SUBSUME(['terminator'], sub {
my $C = shift;
$C->terminator
})
},
)[$try])->($C);
last if @gather;
}
@gather;
};
if (@result) {
@result;
}
elsif ($@) {
my ($first) = $@ =~ /(^.*)/;
$self->deb("CAUGHT $first") if $::DEBUG & DEBUG::trace_call;
die $@ if $@ !~ /^ABORTBRANCH/;
();
}
else {
();
}
}

}))
}, $C->_COMMITBRANCH())
}, $C->_PATTERN(qr/\G\$\`/))
);
}

## token special_variable__S_134DollarAt (:$sym is context<rw> = <$@>)
##      token special_variable:sym<$@> {
##          <sym> ::
##          <.obs('$@ variable as eval error', '$!')>
##      }

sub special_variable__S_134DollarAt__PEEK { $_[0]->_AUTOLEXpeek('special_variable__S_134DollarAt',$retree) }
sub special_variable__S_134DollarAt {
my $self = shift;
local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;
my %args = @_;
local $sym = $args{sym} // q($@);


my $C = $self;
my $S = $C->{'_pos'};
$C->{'sym'} = $sym;

$self->_MATCHIFY($S, "special_variable__S_134DollarAt", 
Cursor::lazymap(sub { my $C=$_[0];
Cursor::lazymap(sub { my $C=$_[0];
$C->obs('$@ variable as eval error', '$!')
}, $C->_COMMITBRANCH())
}, $C->_PATTERN(qr/\G\$\@/))
);
}

## token special_variable__S_135DollarSharp (:$sym is context<rw> = <$#>)
##      token special_variable:sym<$#> {
##          <sym> ::
##          [
##          || (\w+) <.obs("\$#" ~ $0.Str ~ " variable", '@' ~ $0.Str ~ '.end')>
##          || <.obs('$# variable', '.fmt')>
##          ]
##      }

sub special_variable__S_135DollarSharp__PEEK { $_[0]->_AUTOLEXpeek('special_variable__S_135DollarSharp',$retree) }
sub special_variable__S_135DollarSharp {
my $self = shift;
local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;
my %args = @_;
local $sym = $args{sym} // q($#);


my $C = $self;
my $S = $C->{'_pos'};
$C->{'sym'} = $sym;

$self->_MATCHIFY($S, "special_variable__S_135DollarSharp", 
Cursor::lazymap(sub { my $C=$_[0];
Cursor::lazymap(sub { my $C=$_[0];
$C->_BRACKET( sub { my $C=shift;
do { my @gather;
eval { push @gather, Cursor::lazymap(sub { my $C=$_[0];
$C->obs("\$#" . $C->{'0'}->Str . " variable", '@' . $C->{'0'}->Str . '.end')
},     $C->_SUBSUME(['0'], sub {
my $C = shift;
do { $C->_PAREN( sub { my $C=shift;
$C->_PATTERN(qr/\G((?:\w)++)/)
})}
}))} // do {die $@ if $@ and $@ !~ /ABORT/;1} 
or
eval { push @gather, $C->obs('$# variable', '.fmt')} or do { die $@ if $@ };
@gather;
}
})
}, $C->_COMMITBRANCH())
}, $C->_PATTERN(qr/\G\$\#/))
);
}
## token special_variable__S_136DollarDollar (:$sym is context<rw> = <$$>)
##      token special_variable:sym<$$> {
##          <sym> <!alpha> :: <?before \s | ',' | <terminator> >
##          <.obs('$$ variable', '$*PID')>
##      }

sub special_variable__S_136DollarDollar__PEEK { $_[0]->_AUTOLEXpeek('special_variable__S_136DollarDollar',$retree) }
sub special_variable__S_136DollarDollar {
my $self = shift;
local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;
my %args = @_;
local $sym = $args{sym} // q($$);


my $C = $self;
my $S = $C->{'_pos'};
$C->{'sym'} = $sym;

$self->_MATCHIFY($S, "special_variable__S_136DollarDollar", 
Cursor::lazymap(sub { my $C=$_[0];
Cursor::lazymap(sub { my $C=$_[0];
Cursor::lazymap(sub { my $C=$_[0];
Cursor::lazymap(sub { my $C=$_[0];
$C->obs('$$ variable', '$::PID')
}, $C->before(sub { my $C=shift;
do {
my @result = eval {
my $trystate;
my ($tag, $try);
my @try;
my $relex;

my $fate;
if ($fate = $C->{'_fate'} and $fate->[1] eq 'special_variable__S_136DollarDollar_01') {
$C->deb("Fate passed to special_variable__S_136DollarDollar_01: ", ::fatestr($fate)) if $::DEBUG & DEBUG::fates;
($C->{'_fate'}, $tag, $try) = @$fate;
@try = ($try);
}

my @gather = ();
for (;;) {
if (not @try) {
$relex //= $C->cursor_fate('STD', 'special_variable__S_136DollarDollar_01', $retree);
@try = $relex->($C, $trystate);
}
last unless @try;
$try = shift(@try) // next;

if (ref $try eq 'ARRAY') {
($C->{'_fate'}, $tag, $try) = @$try;	# next candidate fate
}

$C->deb("special_variable__S_136DollarDollar_01 trying $tag $try") if $::DEBUG & DEBUG::try_processing;
push @gather, ((
sub { my $C=shift;
$C->_PATTERN(qr/\G\s/)
},
sub { my $C=shift;
$C->_EXACT(',')
},
sub { my $C=shift;
$C->_SUBSUME(['terminator'], sub {
my $C = shift;
$C->terminator
})
},
)[$try])->($C);
last if @gather;
}
@gather;
};
if (@result) {
@result;
}
elsif ($@) {
my ($first) = $@ =~ /(^.*)/;
$self->deb("CAUGHT $first") if $::DEBUG & DEBUG::trace_call;
die $@ if $@ !~ /^ABORTBRANCH/;
();
}
else {
();
}
}

}))
}, $C->_COMMITBRANCH())
}, $C->_NOTBEFORE( sub { my $C=shift;
$C->_PATTERN(qr/\G[_[:alpha:]]/)
}))
}, $C->_PATTERN(qr/\G\$\$/))
);
}
## token special_variable__S_137DollarPercent (:$sym is context<rw> = <$%>)
##      token special_variable:sym<$%> {
##          <sym> ::
##          <.obs('$% variable', 'Form module')>
##      }

sub special_variable__S_137DollarPercent__PEEK { $_[0]->_AUTOLEXpeek('special_variable__S_137DollarPercent',$retree) }
sub special_variable__S_137DollarPercent {
my $self = shift;
local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;
my %args = @_;
local $sym = $args{sym} // q($%);


my $C = $self;
my $S = $C->{'_pos'};
$C->{'sym'} = $sym;

$self->_MATCHIFY($S, "special_variable__S_137DollarPercent", 
Cursor::lazymap(sub { my $C=$_[0];
Cursor::lazymap(sub { my $C=$_[0];
$C->obs('$% variable', 'Form module')
}, $C->_COMMITBRANCH())
}, $C->_PATTERN(qr/\G\$\%/))
);
}

# Note: this works because placeholders are restricted to lowercase
## token special_variable__S_138DollarCaretX (:$sym is context<rw> = <$^X>)
##      token special_variable:sym<$^X> {
##          <sigil> '^' $<letter> = [<[A..Z]>] \W
##          <.obscaret($<sigil>.Str ~ '^' ~ $<letter>.Str, $<sigil>.Str, $<letter>.Str)>
##      }

sub special_variable__S_138DollarCaretX__PEEK { $_[0]->_AUTOLEXpeek('special_variable__S_138DollarCaretX',$retree) }
sub special_variable__S_138DollarCaretX {
my $self = shift;
local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;
my %args = @_;
local $sym = $args{sym} // q($^X);


my $C = $self;
my $S = $C->{'_pos'};
$C->{'sym'} = $sym;

$self->_MATCHIFYr($S, "special_variable__S_138DollarCaretX", 
do {
if (my ($C) = ($C->_SUBSUMEr(['sigil'], sub {
my $C = shift;
$C->sigil
}))) {
do {
if (my ($C) = ($C->_EXACT('^'))) {
do {
if (my ($C) = (    $C->_SUBSUMEr(['letter'], sub {
my $C = shift;
$C->_BRACKETr( sub { my $C=shift;
$C->_PATTERN(qr/\G[A-Z]/)
})
}))) {
do {
if (my ($C) = ($C->_NOTCHAR( sub { my $C=shift;
$C->_PATTERN(qr/\G\w/)
}))) {
do { my $M = $C;
$C->obscaret($M->{'sigil'}->Str . '^' . $M->{'letter'}->Str, $M->{'sigil'}->Str, $M->{'letter'}->Str)
; };
}
else {
();
}
};
}
else {
();
}
};
}
else {
();
}
};
}
else {
();
}
}
);
}

## token special_variable__S_139DollarCaret (:$sym is context<rw> = <$^>)
##      token special_variable:sym<$^> {
##          <sym> :: <?before \s | ',' | '=' | <terminator> >
##          <.obs('$^ variable', 'Form module')>
##      }

sub special_variable__S_139DollarCaret__PEEK { $_[0]->_AUTOLEXpeek('special_variable__S_139DollarCaret',$retree) }
sub special_variable__S_139DollarCaret {
my $self = shift;
local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;
my %args = @_;
local $sym = $args{sym} // q($^);


my $C = $self;
my $S = $C->{'_pos'};
$C->{'sym'} = $sym;

$self->_MATCHIFY($S, "special_variable__S_139DollarCaret", 
Cursor::lazymap(sub { my $C=$_[0];
Cursor::lazymap(sub { my $C=$_[0];
Cursor::lazymap(sub { my $C=$_[0];
$C->obs('$^ variable', 'Form module')
}, $C->before(sub { my $C=shift;
do {
my @result = eval {
my $trystate;
my ($tag, $try);
my @try;
my $relex;

my $fate;
if ($fate = $C->{'_fate'} and $fate->[1] eq 'special_variable__S_139DollarCaret_01') {
$C->deb("Fate passed to special_variable__S_139DollarCaret_01: ", ::fatestr($fate)) if $::DEBUG & DEBUG::fates;
($C->{'_fate'}, $tag, $try) = @$fate;
@try = ($try);
}

my @gather = ();
for (;;) {
if (not @try) {
$relex //= $C->cursor_fate('STD', 'special_variable__S_139DollarCaret_01', $retree);
@try = $relex->($C, $trystate);
}
last unless @try;
$try = shift(@try) // next;

if (ref $try eq 'ARRAY') {
($C->{'_fate'}, $tag, $try) = @$try;	# next candidate fate
}

$C->deb("special_variable__S_139DollarCaret_01 trying $tag $try") if $::DEBUG & DEBUG::try_processing;
push @gather, ((
sub { my $C=shift;
$C->_PATTERN(qr/\G\s/)
},
sub { my $C=shift;
$C->_EXACT(',')
},
sub { my $C=shift;
$C->_EXACT('=')
},
sub { my $C=shift;
$C->_SUBSUME(['terminator'], sub {
my $C = shift;
$C->terminator
})
},
)[$try])->($C);
last if @gather;
}
@gather;
};
if (@result) {
@result;
}
elsif ($@) {
my ($first) = $@ =~ /(^.*)/;
$self->deb("CAUGHT $first") if $::DEBUG & DEBUG::trace_call;
die $@ if $@ !~ /^ABORTBRANCH/;
();
}
else {
();
}
}

}))
}, $C->_COMMITBRANCH())
}, $C->_PATTERN(qr/\G\$\^/))
);
}

## token special_variable__S_140DollarAmp (:$sym is context<rw> = <$&>)
##      token special_variable:sym<$&> {
##          <sym> :: <?before \s | ',' | <terminator> >
##          <.obs('$& variable', '$/ or $()')>
##      }

sub special_variable__S_140DollarAmp__PEEK { $_[0]->_AUTOLEXpeek('special_variable__S_140DollarAmp',$retree) }
sub special_variable__S_140DollarAmp {
my $self = shift;
local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;
my %args = @_;
local $sym = $args{sym} // q($&);


my $C = $self;
my $S = $C->{'_pos'};
$C->{'sym'} = $sym;

$self->_MATCHIFY($S, "special_variable__S_140DollarAmp", 
Cursor::lazymap(sub { my $C=$_[0];
Cursor::lazymap(sub { my $C=$_[0];
Cursor::lazymap(sub { my $C=$_[0];
$C->obs('$& variable', '$/ or $()')
}, $C->before(sub { my $C=shift;
do {
my @result = eval {
my $trystate;
my ($tag, $try);
my @try;
my $relex;

my $fate;
if ($fate = $C->{'_fate'} and $fate->[1] eq 'special_variable__S_140DollarAmp_01') {
$C->deb("Fate passed to special_variable__S_140DollarAmp_01: ", ::fatestr($fate)) if $::DEBUG & DEBUG::fates;
($C->{'_fate'}, $tag, $try) = @$fate;
@try = ($try);
}

my @gather = ();
for (;;) {
if (not @try) {
$relex //= $C->cursor_fate('STD', 'special_variable__S_140DollarAmp_01', $retree);
@try = $relex->($C, $trystate);
}
last unless @try;
$try = shift(@try) // next;

if (ref $try eq 'ARRAY') {
($C->{'_fate'}, $tag, $try) = @$try;	# next candidate fate
}

$C->deb("special_variable__S_140DollarAmp_01 trying $tag $try") if $::DEBUG & DEBUG::try_processing;
push @gather, ((
sub { my $C=shift;
$C->_PATTERN(qr/\G\s/)
},
sub { my $C=shift;
$C->_EXACT(',')
},
sub { my $C=shift;
$C->_SUBSUME(['terminator'], sub {
my $C = shift;
$C->terminator
})
},
)[$try])->($C);
last if @gather;
}
@gather;
};
if (@result) {
@result;
}
elsif ($@) {
my ($first) = $@ =~ /(^.*)/;
$self->deb("CAUGHT $first") if $::DEBUG & DEBUG::trace_call;
die $@ if $@ !~ /^ABORTBRANCH/;
();
}
else {
();
}
}

}))
}, $C->_COMMITBRANCH())
}, $C->_PATTERN(qr/\G\$\&/))
);
}

## token special_variable__S_141DollarStar (:$sym is context<rw> = <$*>)
##      token special_variable:sym<$*> {
##          <sym> :: <?before \s | ',' | '=' | <terminator> >
##          <.obs('$* variable', '^^ and $$')>
##      }

sub special_variable__S_141DollarStar__PEEK { $_[0]->_AUTOLEXpeek('special_variable__S_141DollarStar',$retree) }
sub special_variable__S_141DollarStar {
my $self = shift;
local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;
my %args = @_;
local $sym = $args{sym} // q($*);


my $C = $self;
my $S = $C->{'_pos'};
$C->{'sym'} = $sym;

$self->_MATCHIFY($S, "special_variable__S_141DollarStar", 
Cursor::lazymap(sub { my $C=$_[0];
Cursor::lazymap(sub { my $C=$_[0];
Cursor::lazymap(sub { my $C=$_[0];
$C->obs('$* variable', '^^ and $$')
}, $C->before(sub { my $C=shift;
do {
my @result = eval {
my $trystate;
my ($tag, $try);
my @try;
my $relex;

my $fate;
if ($fate = $C->{'_fate'} and $fate->[1] eq 'special_variable__S_141DollarStar_01') {
$C->deb("Fate passed to special_variable__S_141DollarStar_01: ", ::fatestr($fate)) if $::DEBUG & DEBUG::fates;
($C->{'_fate'}, $tag, $try) = @$fate;
@try = ($try);
}

my @gather = ();
for (;;) {
if (not @try) {
$relex //= $C->cursor_fate('STD', 'special_variable__S_141DollarStar_01', $retree);
@try = $relex->($C, $trystate);
}
last unless @try;
$try = shift(@try) // next;

if (ref $try eq 'ARRAY') {
($C->{'_fate'}, $tag, $try) = @$try;	# next candidate fate
}

$C->deb("special_variable__S_141DollarStar_01 trying $tag $try") if $::DEBUG & DEBUG::try_processing;
push @gather, ((
sub { my $C=shift;
$C->_PATTERN(qr/\G\s/)
},
sub { my $C=shift;
$C->_EXACT(',')
},
sub { my $C=shift;
$C->_EXACT('=')
},
sub { my $C=shift;
$C->_SUBSUME(['terminator'], sub {
my $C = shift;
$C->terminator
})
},
)[$try])->($C);
last if @gather;
}
@gather;
};
if (@result) {
@result;
}
elsif ($@) {
my ($first) = $@ =~ /(^.*)/;
$self->deb("CAUGHT $first") if $::DEBUG & DEBUG::trace_call;
die $@ if $@ !~ /^ABORTBRANCH/;
();
}
else {
();
}
}

}))
}, $C->_COMMITBRANCH())
}, $C->_PATTERN(qr/\G\$\*/))
);
}

## token special_variable__S_142DollarThesis (:$sym is context<rw> = <$)>)
##      token special_variable:sym<$)> {
##          <sym> :: <?before \s | ',' | <terminator> >
##          <.obs('$) variable', '$*EGID')>
##      }

sub special_variable__S_142DollarThesis__PEEK { $_[0]->_AUTOLEXpeek('special_variable__S_142DollarThesis',$retree) }
sub special_variable__S_142DollarThesis {
my $self = shift;
local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;
my %args = @_;
local $sym = $args{sym} // q[$)];


my $C = $self;
my $S = $C->{'_pos'};
$C->{'sym'} = $sym;

$self->_MATCHIFY($S, "special_variable__S_142DollarThesis", 
Cursor::lazymap(sub { my $C=$_[0];
Cursor::lazymap(sub { my $C=$_[0];
Cursor::lazymap(sub { my $C=$_[0];
$C->obs('$) variable', '$::EGID')
}, $C->before(sub { my $C=shift;
do {
my @result = eval {
my $trystate;
my ($tag, $try);
my @try;
my $relex;

my $fate;
if ($fate = $C->{'_fate'} and $fate->[1] eq 'special_variable__S_142DollarThesis_01') {
$C->deb("Fate passed to special_variable__S_142DollarThesis_01: ", ::fatestr($fate)) if $::DEBUG & DEBUG::fates;
($C->{'_fate'}, $tag, $try) = @$fate;
@try = ($try);
}

my @gather = ();
for (;;) {
if (not @try) {
$relex //= $C->cursor_fate('STD', 'special_variable__S_142DollarThesis_01', $retree);
@try = $relex->($C, $trystate);
}
last unless @try;
$try = shift(@try) // next;

if (ref $try eq 'ARRAY') {
($C->{'_fate'}, $tag, $try) = @$try;	# next candidate fate
}

$C->deb("special_variable__S_142DollarThesis_01 trying $tag $try") if $::DEBUG & DEBUG::try_processing;
push @gather, ((
sub { my $C=shift;
$C->_PATTERN(qr/\G\s/)
},
sub { my $C=shift;
$C->_EXACT(',')
},
sub { my $C=shift;
$C->_SUBSUME(['terminator'], sub {
my $C = shift;
$C->terminator
})
},
)[$try])->($C);
last if @gather;
}
@gather;
};
if (@result) {
@result;
}
elsif ($@) {
my ($first) = $@ =~ /(^.*)/;
$self->deb("CAUGHT $first") if $::DEBUG & DEBUG::trace_call;
die $@ if $@ !~ /^ABORTBRANCH/;
();
}
else {
();
}
}

}))
}, $C->_COMMITBRANCH())
}, $C->_PATTERN(qr/\G\$\)/))
);
}

## token special_variable__S_143DollarMinus (:$sym is context<rw> = <$->)
##      token special_variable:sym<$-> {
##          <sym> :: <?before \s | ',' | '=' | <terminator> >
##          <.obs('$- variable', 'Form module')>
##      }

sub special_variable__S_143DollarMinus__PEEK { $_[0]->_AUTOLEXpeek('special_variable__S_143DollarMinus',$retree) }
sub special_variable__S_143DollarMinus {
my $self = shift;
local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;
my %args = @_;
local $sym = $args{sym} // q($-);


my $C = $self;
my $S = $C->{'_pos'};
$C->{'sym'} = $sym;

$self->_MATCHIFY($S, "special_variable__S_143DollarMinus", 
Cursor::lazymap(sub { my $C=$_[0];
Cursor::lazymap(sub { my $C=$_[0];
Cursor::lazymap(sub { my $C=$_[0];
$C->obs('$- variable', 'Form module')
}, $C->before(sub { my $C=shift;
do {
my @result = eval {
my $trystate;
my ($tag, $try);
my @try;
my $relex;

my $fate;
if ($fate = $C->{'_fate'} and $fate->[1] eq 'special_variable__S_143DollarMinus_01') {
$C->deb("Fate passed to special_variable__S_143DollarMinus_01: ", ::fatestr($fate)) if $::DEBUG & DEBUG::fates;
($C->{'_fate'}, $tag, $try) = @$fate;
@try = ($try);
}

my @gather = ();
for (;;) {
if (not @try) {
$relex //= $C->cursor_fate('STD', 'special_variable__S_143DollarMinus_01', $retree);
@try = $relex->($C, $trystate);
}
last unless @try;
$try = shift(@try) // next;

if (ref $try eq 'ARRAY') {
($C->{'_fate'}, $tag, $try) = @$try;	# next candidate fate
}

$C->deb("special_variable__S_143DollarMinus_01 trying $tag $try") if $::DEBUG & DEBUG::try_processing;
push @gather, ((
sub { my $C=shift;
$C->_PATTERN(qr/\G\s/)
},
sub { my $C=shift;
$C->_EXACT(',')
},
sub { my $C=shift;
$C->_EXACT('=')
},
sub { my $C=shift;
$C->_SUBSUME(['terminator'], sub {
my $C = shift;
$C->terminator
})
},
)[$try])->($C);
last if @gather;
}
@gather;
};
if (@result) {
@result;
}
elsif ($@) {
my ($first) = $@ =~ /(^.*)/;
$self->deb("CAUGHT $first") if $::DEBUG & DEBUG::trace_call;
die $@ if $@ !~ /^ABORTBRANCH/;
();
}
else {
();
}
}

}))
}, $C->_COMMITBRANCH())
}, $C->_PATTERN(qr/\G\$\-/))
);
}

## token special_variable__S_144DollarEqual (:$sym is context<rw> = <$=>)
##      token special_variable:sym<$=> {
##          <sym> :: <?before \s | ',' | '=' | <terminator> >
##          <.obs('$= variable', 'Form module')>
##      }

sub special_variable__S_144DollarEqual__PEEK { $_[0]->_AUTOLEXpeek('special_variable__S_144DollarEqual',$retree) }
sub special_variable__S_144DollarEqual {
my $self = shift;
local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;
my %args = @_;
local $sym = $args{sym} // q($=);


my $C = $self;
my $S = $C->{'_pos'};
$C->{'sym'} = $sym;

$self->_MATCHIFY($S, "special_variable__S_144DollarEqual", 
Cursor::lazymap(sub { my $C=$_[0];
Cursor::lazymap(sub { my $C=$_[0];
Cursor::lazymap(sub { my $C=$_[0];
$C->obs('$= variable', 'Form module')
}, $C->before(sub { my $C=shift;
do {
my @result = eval {
my $trystate;
my ($tag, $try);
my @try;
my $relex;

my $fate;
if ($fate = $C->{'_fate'} and $fate->[1] eq 'special_variable__S_144DollarEqual_01') {
$C->deb("Fate passed to special_variable__S_144DollarEqual_01: ", ::fatestr($fate)) if $::DEBUG & DEBUG::fates;
($C->{'_fate'}, $tag, $try) = @$fate;
@try = ($try);
}

my @gather = ();
for (;;) {
if (not @try) {
$relex //= $C->cursor_fate('STD', 'special_variable__S_144DollarEqual_01', $retree);
@try = $relex->($C, $trystate);
}
last unless @try;
$try = shift(@try) // next;

if (ref $try eq 'ARRAY') {
($C->{'_fate'}, $tag, $try) = @$try;	# next candidate fate
}

$C->deb("special_variable__S_144DollarEqual_01 trying $tag $try") if $::DEBUG & DEBUG::try_processing;
push @gather, ((
sub { my $C=shift;
$C->_PATTERN(qr/\G\s/)
},
sub { my $C=shift;
$C->_EXACT(',')
},
sub { my $C=shift;
$C->_EXACT('=')
},
sub { my $C=shift;
$C->_SUBSUME(['terminator'], sub {
my $C = shift;
$C->terminator
})
},
)[$try])->($C);
last if @gather;
}
@gather;
};
if (@result) {
@result;
}
elsif ($@) {
my ($first) = $@ =~ /(^.*)/;
$self->deb("CAUGHT $first") if $::DEBUG & DEBUG::trace_call;
die $@ if $@ !~ /^ABORTBRANCH/;
();
}
else {
();
}
}

}))
}, $C->_COMMITBRANCH())
}, $C->_PATTERN(qr/\G\$\=/))
);
}

## token special_variable__S_145AtPlus (:$sym is context<rw> = <@+>)
##      token special_variable:sym<@+> {
##          <sym> :: <?before \s | ',' | <terminator> >
##          <.obs('@+ variable', '.to method')>
##      }

sub special_variable__S_145AtPlus__PEEK { $_[0]->_AUTOLEXpeek('special_variable__S_145AtPlus',$retree) }
sub special_variable__S_145AtPlus {
my $self = shift;
local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;
my %args = @_;
local $sym = $args{sym} // q(@+);


my $C = $self;
my $S = $C->{'_pos'};
$C->{'sym'} = $sym;

$self->_MATCHIFY($S, "special_variable__S_145AtPlus", 
Cursor::lazymap(sub { my $C=$_[0];
Cursor::lazymap(sub { my $C=$_[0];
Cursor::lazymap(sub { my $C=$_[0];
$C->obs('@+ variable', '.to method')
}, $C->before(sub { my $C=shift;
do {
my @result = eval {
my $trystate;
my ($tag, $try);
my @try;
my $relex;

my $fate;
if ($fate = $C->{'_fate'} and $fate->[1] eq 'special_variable__S_145AtPlus_01') {
$C->deb("Fate passed to special_variable__S_145AtPlus_01: ", ::fatestr($fate)) if $::DEBUG & DEBUG::fates;
($C->{'_fate'}, $tag, $try) = @$fate;
@try = ($try);
}

my @gather = ();
for (;;) {
if (not @try) {
$relex //= $C->cursor_fate('STD', 'special_variable__S_145AtPlus_01', $retree);
@try = $relex->($C, $trystate);
}
last unless @try;
$try = shift(@try) // next;

if (ref $try eq 'ARRAY') {
($C->{'_fate'}, $tag, $try) = @$try;	# next candidate fate
}

$C->deb("special_variable__S_145AtPlus_01 trying $tag $try") if $::DEBUG & DEBUG::try_processing;
push @gather, ((
sub { my $C=shift;
$C->_PATTERN(qr/\G\s/)
},
sub { my $C=shift;
$C->_EXACT(',')
},
sub { my $C=shift;
$C->_SUBSUME(['terminator'], sub {
my $C = shift;
$C->terminator
})
},
)[$try])->($C);
last if @gather;
}
@gather;
};
if (@result) {
@result;
}
elsif ($@) {
my ($first) = $@ =~ /(^.*)/;
$self->deb("CAUGHT $first") if $::DEBUG & DEBUG::trace_call;
die $@ if $@ !~ /^ABORTBRANCH/;
();
}
else {
();
}
}

}))
}, $C->_COMMITBRANCH())
}, $C->_PATTERN(qr/\G\@\+/))
);
}

## token special_variable__S_146PercentPlus (:$sym is context<rw> = <%+>)
##      token special_variable:sym<%+> {
##          <sym> :: <?before \s | ',' | <terminator> >
##          <.obs('%+ variable', '.to method')>
##      }

sub special_variable__S_146PercentPlus__PEEK { $_[0]->_AUTOLEXpeek('special_variable__S_146PercentPlus',$retree) }
sub special_variable__S_146PercentPlus {
my $self = shift;
local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;
my %args = @_;
local $sym = $args{sym} // q(%+);


my $C = $self;
my $S = $C->{'_pos'};
$C->{'sym'} = $sym;

$self->_MATCHIFY($S, "special_variable__S_146PercentPlus", 
Cursor::lazymap(sub { my $C=$_[0];
Cursor::lazymap(sub { my $C=$_[0];
Cursor::lazymap(sub { my $C=$_[0];
$C->obs('%+ variable', '.to method')
}, $C->before(sub { my $C=shift;
do {
my @result = eval {
my $trystate;
my ($tag, $try);
my @try;
my $relex;

my $fate;
if ($fate = $C->{'_fate'} and $fate->[1] eq 'special_variable__S_146PercentPlus_01') {
$C->deb("Fate passed to special_variable__S_146PercentPlus_01: ", ::fatestr($fate)) if $::DEBUG & DEBUG::fates;
($C->{'_fate'}, $tag, $try) = @$fate;
@try = ($try);
}

my @gather = ();
for (;;) {
if (not @try) {
$relex //= $C->cursor_fate('STD', 'special_variable__S_146PercentPlus_01', $retree);
@try = $relex->($C, $trystate);
}
last unless @try;
$try = shift(@try) // next;

if (ref $try eq 'ARRAY') {
($C->{'_fate'}, $tag, $try) = @$try;	# next candidate fate
}

$C->deb("special_variable__S_146PercentPlus_01 trying $tag $try") if $::DEBUG & DEBUG::try_processing;
push @gather, ((
sub { my $C=shift;
$C->_PATTERN(qr/\G\s/)
},
sub { my $C=shift;
$C->_EXACT(',')
},
sub { my $C=shift;
$C->_SUBSUME(['terminator'], sub {
my $C = shift;
$C->terminator
})
},
)[$try])->($C);
last if @gather;
}
@gather;
};
if (@result) {
@result;
}
elsif ($@) {
my ($first) = $@ =~ /(^.*)/;
$self->deb("CAUGHT $first") if $::DEBUG & DEBUG::trace_call;
die $@ if $@ !~ /^ABORTBRANCH/;
();
}
else {
();
}
}

}))
}, $C->_COMMITBRANCH())
}, $C->_PATTERN(qr/\G\%\+/))
);
}

## token special_variable__S_147DollarPlusBra_Ket (:$sym is context<rw> = <$+[ ]>)
##      token special_variable:sym<$+[ ]> {
##          '$+['
##          <.obs('@+ variable', '.to method')>
##      }

sub special_variable__S_147DollarPlusBra_Ket__PEEK { $_[0]->_AUTOLEXpeek('special_variable__S_147DollarPlusBra_Ket',$retree) }
sub special_variable__S_147DollarPlusBra_Ket {
my $self = shift;
local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;
my %args = @_;
local $sym = $args{sym} // [qw($+[ ])];


my $C = $self;
my $S = $C->{'_pos'};
$C->{'sym'} = $sym;

$self->_MATCHIFYr($S, "special_variable__S_147DollarPlusBra_Ket", 
do {
if (my ($C) = ($C->_EXACT('$+['))) {
$C->obs('@+ variable', '.to method');
}
else {
();
}
}
);
}

## token special_variable__S_148AtPlusBra_Ket (:$sym is context<rw> = <@+[ ]>)
##      token special_variable:sym<@+[ ]> {
##          '@+['
##          <.obs('@+ variable', '.to method')>
##      }

sub special_variable__S_148AtPlusBra_Ket__PEEK { $_[0]->_AUTOLEXpeek('special_variable__S_148AtPlusBra_Ket',$retree) }
sub special_variable__S_148AtPlusBra_Ket {
my $self = shift;
local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;
my %args = @_;
local $sym = $args{sym} // [qw(@+[ ])];


my $C = $self;
my $S = $C->{'_pos'};
$C->{'sym'} = $sym;

$self->_MATCHIFYr($S, "special_variable__S_148AtPlusBra_Ket", 
do {
if (my ($C) = ($C->_EXACT('@+['))) {
$C->obs('@+ variable', '.to method');
}
else {
();
}
}
);
}

## token special_variable__S_149AtPlusCur_Ly (:$sym is context<rw> = <@+{ }>)
##      token special_variable:sym<@+{ }> {
##          '@+{'
##          <.obs('%+ variable', '.to method')>
##      }

sub special_variable__S_149AtPlusCur_Ly__PEEK { $_[0]->_AUTOLEXpeek('special_variable__S_149AtPlusCur_Ly',$retree) }
sub special_variable__S_149AtPlusCur_Ly {
my $self = shift;
local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;
my %args = @_;
local $sym = $args{sym} // [qw(@+{ })];


my $C = $self;
my $S = $C->{'_pos'};
$C->{'sym'} = $sym;

$self->_MATCHIFYr($S, "special_variable__S_149AtPlusCur_Ly", 
do {
if (my ($C) = ($C->_EXACT('@+{'))) {
$C->obs('%+ variable', '.to method');
}
else {
();
}
}
);
}

## token special_variable__S_150AtMinus (:$sym is context<rw> = <@->)
##      token special_variable:sym<@-> {
##          <sym> :: <?before \s | ',' | <terminator> >
##          <.obs('@- variable', '.from method')>
##      }

sub special_variable__S_150AtMinus__PEEK { $_[0]->_AUTOLEXpeek('special_variable__S_150AtMinus',$retree) }
sub special_variable__S_150AtMinus {
my $self = shift;
local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;
my %args = @_;
local $sym = $args{sym} // q(@-);


my $C = $self;
my $S = $C->{'_pos'};
$C->{'sym'} = $sym;

$self->_MATCHIFY($S, "special_variable__S_150AtMinus", 
Cursor::lazymap(sub { my $C=$_[0];
Cursor::lazymap(sub { my $C=$_[0];
Cursor::lazymap(sub { my $C=$_[0];
$C->obs('@- variable', '.from method')
}, $C->before(sub { my $C=shift;
do {
my @result = eval {
my $trystate;
my ($tag, $try);
my @try;
my $relex;

my $fate;
if ($fate = $C->{'_fate'} and $fate->[1] eq 'special_variable__S_150AtMinus_01') {
$C->deb("Fate passed to special_variable__S_150AtMinus_01: ", ::fatestr($fate)) if $::DEBUG & DEBUG::fates;
($C->{'_fate'}, $tag, $try) = @$fate;
@try = ($try);
}

my @gather = ();
for (;;) {
if (not @try) {
$relex //= $C->cursor_fate('STD', 'special_variable__S_150AtMinus_01', $retree);
@try = $relex->($C, $trystate);
}
last unless @try;
$try = shift(@try) // next;

if (ref $try eq 'ARRAY') {
($C->{'_fate'}, $tag, $try) = @$try;	# next candidate fate
}

$C->deb("special_variable__S_150AtMinus_01 trying $tag $try") if $::DEBUG & DEBUG::try_processing;
push @gather, ((
sub { my $C=shift;
$C->_PATTERN(qr/\G\s/)
},
sub { my $C=shift;
$C->_EXACT(',')
},
sub { my $C=shift;
$C->_SUBSUME(['terminator'], sub {
my $C = shift;
$C->terminator
})
},
)[$try])->($C);
last if @gather;
}
@gather;
};
if (@result) {
@result;
}
elsif ($@) {
my ($first) = $@ =~ /(^.*)/;
$self->deb("CAUGHT $first") if $::DEBUG & DEBUG::trace_call;
die $@ if $@ !~ /^ABORTBRANCH/;
();
}
else {
();
}
}

}))
}, $C->_COMMITBRANCH())
}, $C->_PATTERN(qr/\G\@\-/))
);
}

## token special_variable__S_151PercentMinus (:$sym is context<rw> = <%->)
##      token special_variable:sym<%-> {
##          <sym> :: <?before \s | ',' | <terminator> >
##          <.obs('%- variable', '.from method')>
##      }

sub special_variable__S_151PercentMinus__PEEK { $_[0]->_AUTOLEXpeek('special_variable__S_151PercentMinus',$retree) }
sub special_variable__S_151PercentMinus {
my $self = shift;
local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;
my %args = @_;
local $sym = $args{sym} // q(%-);


my $C = $self;
my $S = $C->{'_pos'};
$C->{'sym'} = $sym;

$self->_MATCHIFY($S, "special_variable__S_151PercentMinus", 
Cursor::lazymap(sub { my $C=$_[0];
Cursor::lazymap(sub { my $C=$_[0];
Cursor::lazymap(sub { my $C=$_[0];
$C->obs('%- variable', '.from method')
}, $C->before(sub { my $C=shift;
do {
my @result = eval {
my $trystate;
my ($tag, $try);
my @try;
my $relex;

my $fate;
if ($fate = $C->{'_fate'} and $fate->[1] eq 'special_variable__S_151PercentMinus_01') {
$C->deb("Fate passed to special_variable__S_151PercentMinus_01: ", ::fatestr($fate)) if $::DEBUG & DEBUG::fates;
($C->{'_fate'}, $tag, $try) = @$fate;
@try = ($try);
}

my @gather = ();
for (;;) {
if (not @try) {
$relex //= $C->cursor_fate('STD', 'special_variable__S_151PercentMinus_01', $retree);
@try = $relex->($C, $trystate);
}
last unless @try;
$try = shift(@try) // next;

if (ref $try eq 'ARRAY') {
($C->{'_fate'}, $tag, $try) = @$try;	# next candidate fate
}

$C->deb("special_variable__S_151PercentMinus_01 trying $tag $try") if $::DEBUG & DEBUG::try_processing;
push @gather, ((
sub { my $C=shift;
$C->_PATTERN(qr/\G\s/)
},
sub { my $C=shift;
$C->_EXACT(',')
},
sub { my $C=shift;
$C->_SUBSUME(['terminator'], sub {
my $C = shift;
$C->terminator
})
},
)[$try])->($C);
last if @gather;
}
@gather;
};
if (@result) {
@result;
}
elsif ($@) {
my ($first) = $@ =~ /(^.*)/;
$self->deb("CAUGHT $first") if $::DEBUG & DEBUG::trace_call;
die $@ if $@ !~ /^ABORTBRANCH/;
();
}
else {
();
}
}

}))
}, $C->_COMMITBRANCH())
}, $C->_PATTERN(qr/\G\%\-/))
);
}

## token special_variable__S_152DollarMinusBra_Ket (:$sym is context<rw> = <$-[ ]>)
##      token special_variable:sym<$-[ ]> {
##          '$-['
##          <.obs('@- variable', '.from method')>
##      }

sub special_variable__S_152DollarMinusBra_Ket__PEEK { $_[0]->_AUTOLEXpeek('special_variable__S_152DollarMinusBra_Ket',$retree) }
sub special_variable__S_152DollarMinusBra_Ket {
my $self = shift;
local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;
my %args = @_;
local $sym = $args{sym} // [qw($-[ ])];


my $C = $self;
my $S = $C->{'_pos'};
$C->{'sym'} = $sym;

$self->_MATCHIFYr($S, "special_variable__S_152DollarMinusBra_Ket", 
do {
if (my ($C) = ($C->_EXACT('$-['))) {
$C->obs('@- variable', '.from method');
}
else {
();
}
}
);
}

## token special_variable__S_153AtMinusBra_Ket (:$sym is context<rw> = <@-[ ]>)
##      token special_variable:sym<@-[ ]> {
##          '@-['
##          <.obs('@- variable', '.from method')>
##      }

sub special_variable__S_153AtMinusBra_Ket__PEEK { $_[0]->_AUTOLEXpeek('special_variable__S_153AtMinusBra_Ket',$retree) }
sub special_variable__S_153AtMinusBra_Ket {
my $self = shift;
local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;
my %args = @_;
local $sym = $args{sym} // [qw(@-[ ])];


my $C = $self;
my $S = $C->{'_pos'};
$C->{'sym'} = $sym;

$self->_MATCHIFYr($S, "special_variable__S_153AtMinusBra_Ket", 
do {
if (my ($C) = ($C->_EXACT('@-['))) {
$C->obs('@- variable', '.from method');
}
else {
();
}
}
);
}

## token special_variable__S_154PercentMinusCur_Ly (:$sym is context<rw> = <%-{ }>)
##      token special_variable:sym<%-{ }> {
##          '@-{'
##          <.obs('%- variable', '.from method')>
##      }

sub special_variable__S_154PercentMinusCur_Ly__PEEK { $_[0]->_AUTOLEXpeek('special_variable__S_154PercentMinusCur_Ly',$retree) }
sub special_variable__S_154PercentMinusCur_Ly {
my $self = shift;
local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;
my %args = @_;
local $sym = $args{sym} // [qw(%-{ })];


my $C = $self;
my $S = $C->{'_pos'};
$C->{'sym'} = $sym;

$self->_MATCHIFYr($S, "special_variable__S_154PercentMinusCur_Ly", 
do {
if (my ($C) = ($C->_EXACT('@-{'))) {
$C->obs('%- variable', '.from method');
}
else {
();
}
}
);
}

## token special_variable__S_155DollarPlus (:$sym is context<rw> = <$+>)
##      token special_variable:sym<$+> {
##          <sym> :: <?before \s | ',' | <terminator> >
##          <.obs('$+ variable', 'Form module')>
##      }

sub special_variable__S_155DollarPlus__PEEK { $_[0]->_AUTOLEXpeek('special_variable__S_155DollarPlus',$retree) }
sub special_variable__S_155DollarPlus {
my $self = shift;
local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;
my %args = @_;
local $sym = $args{sym} // q($+);


my $C = $self;
my $S = $C->{'_pos'};
$C->{'sym'} = $sym;

$self->_MATCHIFY($S, "special_variable__S_155DollarPlus", 
Cursor::lazymap(sub { my $C=$_[0];
Cursor::lazymap(sub { my $C=$_[0];
Cursor::lazymap(sub { my $C=$_[0];
$C->obs('$+ variable', 'Form module')
}, $C->before(sub { my $C=shift;
do {
my @result = eval {
my $trystate;
my ($tag, $try);
my @try;
my $relex;

my $fate;
if ($fate = $C->{'_fate'} and $fate->[1] eq 'special_variable__S_155DollarPlus_01') {
$C->deb("Fate passed to special_variable__S_155DollarPlus_01: ", ::fatestr($fate)) if $::DEBUG & DEBUG::fates;
($C->{'_fate'}, $tag, $try) = @$fate;
@try = ($try);
}

my @gather = ();
for (;;) {
if (not @try) {
$relex //= $C->cursor_fate('STD', 'special_variable__S_155DollarPlus_01', $retree);
@try = $relex->($C, $trystate);
}
last unless @try;
$try = shift(@try) // next;

if (ref $try eq 'ARRAY') {
($C->{'_fate'}, $tag, $try) = @$try;	# next candidate fate
}

$C->deb("special_variable__S_155DollarPlus_01 trying $tag $try") if $::DEBUG & DEBUG::try_processing;
push @gather, ((
sub { my $C=shift;
$C->_PATTERN(qr/\G\s/)
},
sub { my $C=shift;
$C->_EXACT(',')
},
sub { my $C=shift;
$C->_SUBSUME(['terminator'], sub {
my $C = shift;
$C->terminator
})
},
)[$try])->($C);
last if @gather;
}
@gather;
};
if (@result) {
@result;
}
elsif ($@) {
my ($first) = $@ =~ /(^.*)/;
$self->deb("CAUGHT $first") if $::DEBUG & DEBUG::trace_call;
die $@ if $@ !~ /^ABORTBRANCH/;
();
}
else {
();
}
}

}))
}, $C->_COMMITBRANCH())
}, $C->_PATTERN(qr/\G\$\+/))
);
}

## token special_variable__S_156DollarCurCaret_Ly (:$sym is context<rw> = <${^ }>)
##      token special_variable:sym<${^ }> {
##          <sigil> '{^' :: $<text>=[.*?] '}'
##          <.obscaret($<sigil>.Str ~ '{^' ~ $<text>.Str ~ '}', $<sigil>.Str, $<text>.Str)>
##      }

sub special_variable__S_156DollarCurCaret_Ly__PEEK { $_[0]->_AUTOLEXpeek('special_variable__S_156DollarCurCaret_Ly',$retree) }
sub special_variable__S_156DollarCurCaret_Ly {
my $self = shift;
local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;
my %args = @_;
local $sym = $args{sym} // [qw(${^ })];


my $C = $self;
my $S = $C->{'_pos'};
$C->{'sym'} = $sym;

$self->_MATCHIFY($S, "special_variable__S_156DollarCurCaret_Ly", 
Cursor::lazymap(sub { my $C=$_[0];
Cursor::lazymap(sub { my $C=$_[0];
Cursor::lazymap(sub { my $C=$_[0];
Cursor::lazymap(sub { my $C=$_[0];
Cursor::lazymap(sub { my $C=$_[0];
do { my $M = $C;
$C->obscaret($M->{'sigil'}->Str . '{^' . $M->{'text'}->Str . '}', $M->{'sigil'}->Str, $M->{'text'}->Str)
; }
}, $C->_EXACT('}'))
},     $C->_SUBSUME(['text'], sub {
my $C = shift;
$C->_BRACKET( sub { my $C=shift;
$C->_SCANf()
})
}))
}, $C->_COMMITBRANCH())
}, $C->_EXACT('{^'))
}, $C->_SUBSUMEr(['sigil'], sub {
my $C = shift;
$C->sigil
}))
);
}

# XXX should eventually rely on multi instead of nested cases here...
## method obscaret (Str $var, Str $sigil, Str $name)
sub obscaret {
my $self = shift;
my $var = shift;
my $sigil = shift;
my $name = shift;


my $repl;
given ($sigil) {
when ('$') {
given ($name) {
when ('MATCH')         { $repl = '$/' }
when ('PREMATCH')      { $repl = 'an explicit pattern before <(' }
when ('POSTMATCH')     { $repl = 'an explicit pattern after )>' }
when ('ENCODING')      { $repl = '$?ENCODING' }
when ('UNICODE')       { $repl = '$?UNICODE' }  # XXX ???
when ('TAINT')         { $repl = '$::TAINT' }
when ('OPEN')          { $repl = 'filehandle introspection' }
when ('N')             { $repl = '$-1' } # XXX ???
when ('L')             { $repl = 'Form module' }
when ('A')             { $repl = 'Form module' }
when ('E')             { $repl = '$!.extended_os_error' }
when ('C')             { $repl = 'COMPILING namespace' }
when ('D')             { $repl = '$::DEBUGGING' }
when ('F')             { $repl = '$::SYSTEM_FD_MAX' }
when ('H')             { $repl = '$?FOO variables' }
when ('I')             { $repl = '$::INPLACE' } # XXX ???
when ('O')             { $repl = '$?OS or $::OS' }
when ('P')             { $repl = 'whatever debugger Perl 6 comes with' }
when ('R')             { $repl = 'an explicit result variable' }
when ('S')             { $repl = 'the context function' } # XXX ???
when ('T')             { $repl = '$::BASETIME' }
when ('V')             { $repl = '$::PERL_VERSION' }
when ('W')             { $repl = '$::WARNING' }
when ('X')             { $repl = '$::EXECUTABLE_NAME' }
default { $repl = "a global form such as $sigil*$name" }
}
}
when ('%') {
given ($name) {
when ('H')             { $repl = '$?FOO variables' }
default { $repl = "a global form such as $sigil*$name" }
}
}
default { $repl = "a global form such as $sigil*$name" }
};
return $self->obs("$var variable", $repl);
}

## token special_variable__S_157ColonColonCur_Ly (:$sym is context<rw> = <::{ }>)
##      token special_variable:sym<::{ }> {
##          '::' <?before '{'>
##      }

sub special_variable__S_157ColonColonCur_Ly__PEEK { $_[0]->_AUTOLEXpeek('special_variable__S_157ColonColonCur_Ly',$retree) }
sub special_variable__S_157ColonColonCur_Ly {
my $self = shift;
local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;
my %args = @_;
local $sym = $args{sym} // [qw(::{ })];


my $C = $self;
my $S = $C->{'_pos'};
$C->{'sym'} = $sym;

$self->_MATCHIFYr($S, "special_variable__S_157ColonColonCur_Ly", 
do {
if (my ($C) = ($C->_EXACT('::'))) {
$C->before(sub { my $C=shift;
$C->_EXACT('{')
});
}
else {
();
}
}
);
}

## regex special_variable__S_158DollarCur_Ly (:$sym is context<rw> = <${ }>)
##      regex special_variable:sym<${ }> {
##          <sigil> '{' {} $<text>=[.*?] '}'
##          {{
##              my $sigil = $<sigil>.Str;
##              my $text = $<text>.Str;
##              my $bad = $sigil ~ '{' ~ $text ~ '}';
##              $text = $text - 1 if $text ~~ /^\d+$/;
##              if $text !~~ /^(\w|\:)+$/ {
##                  $¢.obs($bad, $sigil ~ '(' ~ $text ~ ')');
##              }
##              elsif $*QSIGIL {
##                  $¢.obs($bad, '{' ~ $sigil ~ $text ~ '}');
##              }
##              else {
##                  $¢.obs($bad, $sigil ~ $text);
##              }
##          }}
##      }

sub special_variable__S_158DollarCur_Ly__PEEK { $_[0]->_AUTOLEXpeek('special_variable__S_158DollarCur_Ly',$retree) }
sub special_variable__S_158DollarCur_Ly {
my $self = shift;
local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;
my %args = @_;
local $sym = $args{sym} // [qw(${ })];


my $C = $self;
my $S = $C->{'_pos'};
$C->{'sym'} = $sym;

$self->_MATCHIFY($S, "special_variable__S_158DollarCur_Ly", 
Cursor::lazymap(sub { my $C=$_[0];
Cursor::lazymap(sub { my $C=$_[0];
Cursor::lazymap(sub { my $C=$_[0];
Cursor::lazymap(sub { my $C=$_[0];
Cursor::lazymap(sub { my $C=$_[0];
scalar(do {
my $M = $C; 
my $sigil = $M->{'sigil'}->Str;
my $text = $M->{'text'}->Str;
my $bad = $sigil . '{' . $text . '}';
$text = $text - 1 if $text =~ qr/^\d+$/;
if ($text !~ qr/^(\w|\:)+$/) {
$C->obs($bad, $sigil . '(' . $text . ')');
}
elsif ($::QSIGIL) {
$C->obs($bad, '{' . $sigil . $text . '}');
}
else {
$C->obs($bad, $sigil . $text);
}
;
}, $C)
}, $C->_EXACT('}'))
},     $C->_SUBSUME(['text'], sub {
my $C = shift;
$C->_BRACKET( sub { my $C=shift;
$C->_SCANf()
})
}))
}, scalar(do {

}, $C))
}, $C->_EXACT('{'))
}, $C->_SUBSUME(['sigil'], sub {
my $C = shift;
$C->sigil
}))
);
}

## token special_variable__S_159DollarBra (:$sym is context<rw> = <$[>)
##      token special_variable:sym<$[> {
##          <sym> :: <?before \s | ',' | '=' | <terminator> >
##          <.obs('$[ variable', 'user-defined array indices')>
##      }

sub special_variable__S_159DollarBra__PEEK { $_[0]->_AUTOLEXpeek('special_variable__S_159DollarBra',$retree) }
sub special_variable__S_159DollarBra {
my $self = shift;
local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;
my %args = @_;
local $sym = $args{sym} // q($[);


my $C = $self;
my $S = $C->{'_pos'};
$C->{'sym'} = $sym;

$self->_MATCHIFY($S, "special_variable__S_159DollarBra", 
Cursor::lazymap(sub { my $C=$_[0];
Cursor::lazymap(sub { my $C=$_[0];
Cursor::lazymap(sub { my $C=$_[0];
$C->obs('$[ variable', 'user-defined array indices')
}, $C->before(sub { my $C=shift;
do {
my @result = eval {
my $trystate;
my ($tag, $try);
my @try;
my $relex;

my $fate;
if ($fate = $C->{'_fate'} and $fate->[1] eq 'special_variable__S_159DollarBra_01') {
$C->deb("Fate passed to special_variable__S_159DollarBra_01: ", ::fatestr($fate)) if $::DEBUG & DEBUG::fates;
($C->{'_fate'}, $tag, $try) = @$fate;
@try = ($try);
}

my @gather = ();
for (;;) {
if (not @try) {
$relex //= $C->cursor_fate('STD', 'special_variable__S_159DollarBra_01', $retree);
@try = $relex->($C, $trystate);
}
last unless @try;
$try = shift(@try) // next;

if (ref $try eq 'ARRAY') {
($C->{'_fate'}, $tag, $try) = @$try;	# next candidate fate
}

$C->deb("special_variable__S_159DollarBra_01 trying $tag $try") if $::DEBUG & DEBUG::try_processing;
push @gather, ((
sub { my $C=shift;
$C->_PATTERN(qr/\G\s/)
},
sub { my $C=shift;
$C->_EXACT(',')
},
sub { my $C=shift;
$C->_EXACT('=')
},
sub { my $C=shift;
$C->_SUBSUME(['terminator'], sub {
my $C = shift;
$C->terminator
})
},
)[$try])->($C);
last if @gather;
}
@gather;
};
if (@result) {
@result;
}
elsif ($@) {
my ($first) = $@ =~ /(^.*)/;
$self->deb("CAUGHT $first") if $::DEBUG & DEBUG::trace_call;
die $@ if $@ !~ /^ABORTBRANCH/;
();
}
else {
();
}
}

}))
}, $C->_COMMITBRANCH())
}, $C->_PATTERN(qr/\G\$\[/))
);
}

## token special_variable__S_160DollarKet (:$sym is context<rw> = <$]>)
##      token special_variable:sym<$]> {
##          <sym> :: <?before \s | ',' | <terminator> >
##          <.obs('$] variable', '$*PERL_VERSION')>
##      }

sub special_variable__S_160DollarKet__PEEK { $_[0]->_AUTOLEXpeek('special_variable__S_160DollarKet',$retree) }
sub special_variable__S_160DollarKet {
my $self = shift;
local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;
my %args = @_;
local $sym = $args{sym} // q($]);


my $C = $self;
my $S = $C->{'_pos'};
$C->{'sym'} = $sym;

$self->_MATCHIFY($S, "special_variable__S_160DollarKet", 
Cursor::lazymap(sub { my $C=$_[0];
Cursor::lazymap(sub { my $C=$_[0];
Cursor::lazymap(sub { my $C=$_[0];
$C->obs('$] variable', '$::PERL_VERSION')
}, $C->before(sub { my $C=shift;
do {
my @result = eval {
my $trystate;
my ($tag, $try);
my @try;
my $relex;

my $fate;
if ($fate = $C->{'_fate'} and $fate->[1] eq 'special_variable__S_160DollarKet_01') {
$C->deb("Fate passed to special_variable__S_160DollarKet_01: ", ::fatestr($fate)) if $::DEBUG & DEBUG::fates;
($C->{'_fate'}, $tag, $try) = @$fate;
@try = ($try);
}

my @gather = ();
for (;;) {
if (not @try) {
$relex //= $C->cursor_fate('STD', 'special_variable__S_160DollarKet_01', $retree);
@try = $relex->($C, $trystate);
}
last unless @try;
$try = shift(@try) // next;

if (ref $try eq 'ARRAY') {
($C->{'_fate'}, $tag, $try) = @$try;	# next candidate fate
}

$C->deb("special_variable__S_160DollarKet_01 trying $tag $try") if $::DEBUG & DEBUG::try_processing;
push @gather, ((
sub { my $C=shift;
$C->_PATTERN(qr/\G\s/)
},
sub { my $C=shift;
$C->_EXACT(',')
},
sub { my $C=shift;
$C->_SUBSUME(['terminator'], sub {
my $C = shift;
$C->terminator
})
},
)[$try])->($C);
last if @gather;
}
@gather;
};
if (@result) {
@result;
}
elsif ($@) {
my ($first) = $@ =~ /(^.*)/;
$self->deb("CAUGHT $first") if $::DEBUG & DEBUG::trace_call;
die $@ if $@ !~ /^ABORTBRANCH/;
();
}
else {
();
}
}

}))
}, $C->_COMMITBRANCH())
}, $C->_PATTERN(qr/\G\$\]/))
);
}

## token special_variable__S_161DollarBack (:$sym is context<rw> = <$\\>)
##      token special_variable:sym<$\\> {
##          <sym> :: <?before \s | ',' | '=' | <terminator> >
##          <.obs('$\\ variable', "the filehandle's :ors attribute")>
##      }

sub special_variable__S_161DollarBack__PEEK { $_[0]->_AUTOLEXpeek('special_variable__S_161DollarBack',$retree) }
sub special_variable__S_161DollarBack {
my $self = shift;
local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;
my %args = @_;
local $sym = $args{sym} // q($\\);


my $C = $self;
my $S = $C->{'_pos'};
$C->{'sym'} = $sym;

$self->_MATCHIFY($S, "special_variable__S_161DollarBack", 
Cursor::lazymap(sub { my $C=$_[0];
Cursor::lazymap(sub { my $C=$_[0];
Cursor::lazymap(sub { my $C=$_[0];
$C->obs('$\\ variable', "the filehandle's :ors attribute")
}, $C->before(sub { my $C=shift;
do {
my @result = eval {
my $trystate;
my ($tag, $try);
my @try;
my $relex;

my $fate;
if ($fate = $C->{'_fate'} and $fate->[1] eq 'special_variable__S_161DollarBack_01') {
$C->deb("Fate passed to special_variable__S_161DollarBack_01: ", ::fatestr($fate)) if $::DEBUG & DEBUG::fates;
($C->{'_fate'}, $tag, $try) = @$fate;
@try = ($try);
}

my @gather = ();
for (;;) {
if (not @try) {
$relex //= $C->cursor_fate('STD', 'special_variable__S_161DollarBack_01', $retree);
@try = $relex->($C, $trystate);
}
last unless @try;
$try = shift(@try) // next;

if (ref $try eq 'ARRAY') {
($C->{'_fate'}, $tag, $try) = @$try;	# next candidate fate
}

$C->deb("special_variable__S_161DollarBack_01 trying $tag $try") if $::DEBUG & DEBUG::try_processing;
push @gather, ((
sub { my $C=shift;
$C->_PATTERN(qr/\G\s/)
},
sub { my $C=shift;
$C->_EXACT(',')
},
sub { my $C=shift;
$C->_EXACT('=')
},
sub { my $C=shift;
$C->_SUBSUME(['terminator'], sub {
my $C = shift;
$C->terminator
})
},
)[$try])->($C);
last if @gather;
}
@gather;
};
if (@result) {
@result;
}
elsif ($@) {
my ($first) = $@ =~ /(^.*)/;
$self->deb("CAUGHT $first") if $::DEBUG & DEBUG::trace_call;
die $@ if $@ !~ /^ABORTBRANCH/;
();
}
else {
();
}
}

}))
}, $C->_COMMITBRANCH())
}, $C->_PATTERN(qr/\G\$\\/))
);
}

## token special_variable__S_162DollarVert (:$sym is context<rw> = <$|>)
##      token special_variable:sym<$|> {
##          <sym> :: <?before \s | ',' | '=' | <terminator> >
##          <.obs('$| variable', ':autoflush on open')>
##      }

sub special_variable__S_162DollarVert__PEEK { $_[0]->_AUTOLEXpeek('special_variable__S_162DollarVert',$retree) }
sub special_variable__S_162DollarVert {
my $self = shift;
local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;
my %args = @_;
local $sym = $args{sym} // q($|);


my $C = $self;
my $S = $C->{'_pos'};
$C->{'sym'} = $sym;

$self->_MATCHIFY($S, "special_variable__S_162DollarVert", 
Cursor::lazymap(sub { my $C=$_[0];
Cursor::lazymap(sub { my $C=$_[0];
Cursor::lazymap(sub { my $C=$_[0];
$C->obs('$| variable', ':autoflush on open')
}, $C->before(sub { my $C=shift;
do {
my @result = eval {
my $trystate;
my ($tag, $try);
my @try;
my $relex;

my $fate;
if ($fate = $C->{'_fate'} and $fate->[1] eq 'special_variable__S_162DollarVert_01') {
$C->deb("Fate passed to special_variable__S_162DollarVert_01: ", ::fatestr($fate)) if $::DEBUG & DEBUG::fates;
($C->{'_fate'}, $tag, $try) = @$fate;
@try = ($try);
}

my @gather = ();
for (;;) {
if (not @try) {
$relex //= $C->cursor_fate('STD', 'special_variable__S_162DollarVert_01', $retree);
@try = $relex->($C, $trystate);
}
last unless @try;
$try = shift(@try) // next;

if (ref $try eq 'ARRAY') {
($C->{'_fate'}, $tag, $try) = @$try;	# next candidate fate
}

$C->deb("special_variable__S_162DollarVert_01 trying $tag $try") if $::DEBUG & DEBUG::try_processing;
push @gather, ((
sub { my $C=shift;
$C->_PATTERN(qr/\G\s/)
},
sub { my $C=shift;
$C->_EXACT(',')
},
sub { my $C=shift;
$C->_EXACT('=')
},
sub { my $C=shift;
$C->_SUBSUME(['terminator'], sub {
my $C = shift;
$C->terminator
})
},
)[$try])->($C);
last if @gather;
}
@gather;
};
if (@result) {
@result;
}
elsif ($@) {
my ($first) = $@ =~ /(^.*)/;
$self->deb("CAUGHT $first") if $::DEBUG & DEBUG::trace_call;
die $@ if $@ !~ /^ABORTBRANCH/;
();
}
else {
();
}
}

}))
}, $C->_COMMITBRANCH())
}, $C->_PATTERN(qr/\G\$\|/))
);
}

## token special_variable__S_163DollarColon (:$sym is context<rw> = <$:>)
##      token special_variable:sym<$:> {
##          <sym> <?before <[\x20\t\n\],=)}]> >
##          <.obs('$: variable', 'Form module')>
##      }

sub special_variable__S_163DollarColon__PEEK { $_[0]->_AUTOLEXpeek('special_variable__S_163DollarColon',$retree) }
sub special_variable__S_163DollarColon {
my $self = shift;
local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;
my %args = @_;
local $sym = $args{sym} // q($:);


my $C = $self;
my $S = $C->{'_pos'};
$C->{'sym'} = $sym;

$self->_MATCHIFYr($S, "special_variable__S_163DollarColon", 
do {
if (my ($C) = ($C->_PATTERN(qr/\G\$\:/))) {
do {
if (my ($C) = ($C->before(sub { my $C=shift;
$C->_PATTERN(qr/\G[\x20\t\n\],=)}]/)
}))) {
$C->obs('$: variable', 'Form module');
}
else {
();
}
};
}
else {
();
}
}
);
}

## token special_variable__S_164DollarSemi (:$sym is context<rw> = <$;>)
##      token special_variable:sym<$;> {
##          <sym> :: <?before \s | ',' | '=' | <terminator> >
##          <.obs('$; variable', 'real multidimensional hashes')>
##      }

sub special_variable__S_164DollarSemi__PEEK { $_[0]->_AUTOLEXpeek('special_variable__S_164DollarSemi',$retree) }
sub special_variable__S_164DollarSemi {
my $self = shift;
local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;
my %args = @_;
local $sym = $args{sym} // q($;);


my $C = $self;
my $S = $C->{'_pos'};
$C->{'sym'} = $sym;

$self->_MATCHIFY($S, "special_variable__S_164DollarSemi", 
Cursor::lazymap(sub { my $C=$_[0];
Cursor::lazymap(sub { my $C=$_[0];
Cursor::lazymap(sub { my $C=$_[0];
$C->obs('$; variable', 'real multidimensional hashes')
}, $C->before(sub { my $C=shift;
do {
my @result = eval {
my $trystate;
my ($tag, $try);
my @try;
my $relex;

my $fate;
if ($fate = $C->{'_fate'} and $fate->[1] eq 'special_variable__S_164DollarSemi_01') {
$C->deb("Fate passed to special_variable__S_164DollarSemi_01: ", ::fatestr($fate)) if $::DEBUG & DEBUG::fates;
($C->{'_fate'}, $tag, $try) = @$fate;
@try = ($try);
}

my @gather = ();
for (;;) {
if (not @try) {
$relex //= $C->cursor_fate('STD', 'special_variable__S_164DollarSemi_01', $retree);
@try = $relex->($C, $trystate);
}
last unless @try;
$try = shift(@try) // next;

if (ref $try eq 'ARRAY') {
($C->{'_fate'}, $tag, $try) = @$try;	# next candidate fate
}

$C->deb("special_variable__S_164DollarSemi_01 trying $tag $try") if $::DEBUG & DEBUG::try_processing;
push @gather, ((
sub { my $C=shift;
$C->_PATTERN(qr/\G\s/)
},
sub { my $C=shift;
$C->_EXACT(',')
},
sub { my $C=shift;
$C->_EXACT('=')
},
sub { my $C=shift;
$C->_SUBSUME(['terminator'], sub {
my $C = shift;
$C->terminator
})
},
)[$try])->($C);
last if @gather;
}
@gather;
};
if (@result) {
@result;
}
elsif ($@) {
my ($first) = $@ =~ /(^.*)/;
$self->deb("CAUGHT $first") if $::DEBUG & DEBUG::trace_call;
die $@ if $@ !~ /^ABORTBRANCH/;
();
}
else {
();
}
}

}))
}, $C->_COMMITBRANCH())
}, $C->_PATTERN(qr/\G\$\;/))
);
}

## token special_variable__S_165DollarSingle (:$sym is context<rw> = <$'>)
##      token special_variable:sym<$'> { #'
##          <sym> :: <?before \s | ',' | <terminator> >
##          <.obs('$' ~ "'" ~ 'variable', "explicit pattern after )\x3E")>
##      }

sub special_variable__S_165DollarSingle__PEEK { $_[0]->_AUTOLEXpeek('special_variable__S_165DollarSingle',$retree) }
sub special_variable__S_165DollarSingle {
my $self = shift;
local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;
my %args = @_;
local $sym = $args{sym} // q($');


my $C = $self;
my $S = $C->{'_pos'};
$C->{'sym'} = $sym;

$self->_MATCHIFY($S, "special_variable__S_165DollarSingle", 
Cursor::lazymap(sub { my $C=$_[0];
Cursor::lazymap(sub { my $C=$_[0];
Cursor::lazymap(sub { my $C=$_[0];
$C->obs('$' . "'" . 'variable', "explicit pattern after )\x3E")
}, $C->before(sub { my $C=shift;
do {
my @result = eval {
my $trystate;
my ($tag, $try);
my @try;
my $relex;

my $fate;
if ($fate = $C->{'_fate'} and $fate->[1] eq 'special_variable__S_165DollarSingle_01') {
$C->deb("Fate passed to special_variable__S_165DollarSingle_01: ", ::fatestr($fate)) if $::DEBUG & DEBUG::fates;
($C->{'_fate'}, $tag, $try) = @$fate;
@try = ($try);
}

my @gather = ();
for (;;) {
if (not @try) {
$relex //= $C->cursor_fate('STD', 'special_variable__S_165DollarSingle_01', $retree);
@try = $relex->($C, $trystate);
}
last unless @try;
$try = shift(@try) // next;

if (ref $try eq 'ARRAY') {
($C->{'_fate'}, $tag, $try) = @$try;	# next candidate fate
}

$C->deb("special_variable__S_165DollarSingle_01 trying $tag $try") if $::DEBUG & DEBUG::try_processing;
push @gather, ((
sub { my $C=shift;
$C->_PATTERN(qr/\G\s/)
},
sub { my $C=shift;
$C->_EXACT(',')
},
sub { my $C=shift;
$C->_SUBSUME(['terminator'], sub {
my $C = shift;
$C->terminator
})
},
)[$try])->($C);
last if @gather;
}
@gather;
};
if (@result) {
@result;
}
elsif ($@) {
my ($first) = $@ =~ /(^.*)/;
$self->deb("CAUGHT $first") if $::DEBUG & DEBUG::trace_call;
die $@ if $@ !~ /^ABORTBRANCH/;
();
}
else {
();
}
}

}))
}, $C->_COMMITBRANCH())
}, $C->_PATTERN(qr/\G\$\'/))
);
}

## token special_variable__S_166DollarDouble (:$sym is context<rw> = <$">)
##      token special_variable:sym<$"> {
##          <sym> <!{ $*QSIGIL }>
##          :: <?before \s | ',' | '=' | <terminator> >
##          <.obs('$" variable', '.join() method')>
##      }

sub special_variable__S_166DollarDouble__PEEK { $_[0]->_AUTOLEXpeek('special_variable__S_166DollarDouble',$retree) }
sub special_variable__S_166DollarDouble {
my $self = shift;
local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;
my %args = @_;
local $sym = $args{sym} // q($");


my $C = $self;
my $S = $C->{'_pos'};
$C->{'sym'} = $sym;

$self->_MATCHIFY($S, "special_variable__S_166DollarDouble", 
Cursor::lazymap(sub { my $C=$_[0];
Cursor::lazymap(sub { my $C=$_[0];
Cursor::lazymap(sub { my $C=$_[0];
Cursor::lazymap(sub { my $C=$_[0];
$C->obs('$" variable', '.join() method')
}, $C->before(sub { my $C=shift;
do {
my @result = eval {
my $trystate;
my ($tag, $try);
my @try;
my $relex;

my $fate;
if ($fate = $C->{'_fate'} and $fate->[1] eq 'special_variable__S_166DollarDouble_01') {
$C->deb("Fate passed to special_variable__S_166DollarDouble_01: ", ::fatestr($fate)) if $::DEBUG & DEBUG::fates;
($C->{'_fate'}, $tag, $try) = @$fate;
@try = ($try);
}

my @gather = ();
for (;;) {
if (not @try) {
$relex //= $C->cursor_fate('STD', 'special_variable__S_166DollarDouble_01', $retree);
@try = $relex->($C, $trystate);
}
last unless @try;
$try = shift(@try) // next;

if (ref $try eq 'ARRAY') {
($C->{'_fate'}, $tag, $try) = @$try;	# next candidate fate
}

$C->deb("special_variable__S_166DollarDouble_01 trying $tag $try") if $::DEBUG & DEBUG::try_processing;
push @gather, ((
sub { my $C=shift;
$C->_PATTERN(qr/\G\s/)
},
sub { my $C=shift;
$C->_EXACT(',')
},
sub { my $C=shift;
$C->_EXACT('=')
},
sub { my $C=shift;
$C->_SUBSUME(['terminator'], sub {
my $C = shift;
$C->terminator
})
},
)[$try])->($C);
last if @gather;
}
@gather;
};
if (@result) {
@result;
}
elsif ($@) {
my ($first) = $@ =~ /(^.*)/;
$self->deb("CAUGHT $first") if $::DEBUG & DEBUG::trace_call;
die $@ if $@ !~ /^ABORTBRANCH/;
();
}
else {
();
}
}

}))
}, $C->_COMMITBRANCH())
}, $C->_NOTBEFORE( sub { my $C=shift;
(($C) x !!do {
$::QSIGIL 
})
}))
}, $C->_PATTERN(qr/\G\$\"/))
);
}

## token special_variable__S_167DollarComma (:$sym is context<rw> = <$,>)
##      token special_variable:sym<$,> {
##          <sym> :: <?before \s | ',' | <terminator> >
##          <.obs('$, variable', ".join() method")>
##      }

sub special_variable__S_167DollarComma__PEEK { $_[0]->_AUTOLEXpeek('special_variable__S_167DollarComma',$retree) }
sub special_variable__S_167DollarComma {
my $self = shift;
local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;
my %args = @_;
local $sym = $args{sym} // q[$,];


my $C = $self;
my $S = $C->{'_pos'};
$C->{'sym'} = $sym;

$self->_MATCHIFY($S, "special_variable__S_167DollarComma", 
Cursor::lazymap(sub { my $C=$_[0];
Cursor::lazymap(sub { my $C=$_[0];
Cursor::lazymap(sub { my $C=$_[0];
$C->obs('$, variable', ".join() method")
}, $C->before(sub { my $C=shift;
do {
my @result = eval {
my $trystate;
my ($tag, $try);
my @try;
my $relex;

my $fate;
if ($fate = $C->{'_fate'} and $fate->[1] eq 'special_variable__S_167DollarComma_01') {
$C->deb("Fate passed to special_variable__S_167DollarComma_01: ", ::fatestr($fate)) if $::DEBUG & DEBUG::fates;
($C->{'_fate'}, $tag, $try) = @$fate;
@try = ($try);
}

my @gather = ();
for (;;) {
if (not @try) {
$relex //= $C->cursor_fate('STD', 'special_variable__S_167DollarComma_01', $retree);
@try = $relex->($C, $trystate);
}
last unless @try;
$try = shift(@try) // next;

if (ref $try eq 'ARRAY') {
($C->{'_fate'}, $tag, $try) = @$try;	# next candidate fate
}

$C->deb("special_variable__S_167DollarComma_01 trying $tag $try") if $::DEBUG & DEBUG::try_processing;
push @gather, ((
sub { my $C=shift;
$C->_PATTERN(qr/\G\s/)
},
sub { my $C=shift;
$C->_EXACT(',')
},
sub { my $C=shift;
$C->_SUBSUME(['terminator'], sub {
my $C = shift;
$C->terminator
})
},
)[$try])->($C);
last if @gather;
}
@gather;
};
if (@result) {
@result;
}
elsif ($@) {
my ($first) = $@ =~ /(^.*)/;
$self->deb("CAUGHT $first") if $::DEBUG & DEBUG::trace_call;
die $@ if $@ !~ /^ABORTBRANCH/;
();
}
else {
();
}
}

}))
}, $C->_COMMITBRANCH())
}, $C->_PATTERN(qr/\G\$\,/))
);
}

## token special_variable__S_168DollarLt (:$sym is context<rw> = ['$<'])
##      token special_variable:sym['$<'] {
##          <sym> :: <!before \s* \w+ \s* '>' >
##          <.obs('$< variable', '$*UID')>
##      }

sub special_variable__S_168DollarLt__PEEK { $_[0]->_AUTOLEXpeek('special_variable__S_168DollarLt',$retree) }
sub special_variable__S_168DollarLt {
my $self = shift;
local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;
my %args = @_;
local $sym = $args{sym} // ['$<'];


my $C = $self;
my $S = $C->{'_pos'};
$C->{'sym'} = $sym;

$self->_MATCHIFY($S, "special_variable__S_168DollarLt", 
Cursor::lazymap(sub { my $C=$_[0];
Cursor::lazymap(sub { my $C=$_[0];
Cursor::lazymap(sub { my $C=$_[0];
$C->obs('$< variable', '$::UID')
}, $C->_NOTBEFORE( sub { my $C=shift;
$C->before(sub { my $C=shift;
Cursor::lazymap(sub { my $C=$_[0];
Cursor::lazymap(sub { my $C=$_[0];
Cursor::lazymap(sub { my $C=$_[0];
$C->_EXACT('>')
}, $C->_PATTERN(qr/\G((?:\s)*+)/))
}, $C->_PATTERN(qr/\G((?:\w)++)/))
}, $C->_PATTERN(qr/\G((?:\s)*+)/))
})
}))
}, $C->_COMMITBRANCH())
}, $C->_PATTERN(qr/\G\[\'\$\<\'\]/))
);
}

## token special_variable__S_169DollarGt (:$sym is context<rw> = «\$>»)
##      token special_variable:sym«\$>» {
##          <sym> :: <?before \s | ',' | <terminator> >
##          <.obs('$> variable', '$*EUID')>
##      }

sub special_variable__S_169DollarGt__PEEK { $_[0]->_AUTOLEXpeek('special_variable__S_169DollarGt',$retree) }
sub special_variable__S_169DollarGt {
my $self = shift;
local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;
my %args = @_;
local $sym = $args{sym} //['\$>'];


my $C = $self;
my $S = $C->{'_pos'};
$C->{'sym'} = $sym;

$self->_MATCHIFY($S, "special_variable__S_169DollarGt", 
Cursor::lazymap(sub { my $C=$_[0];
Cursor::lazymap(sub { my $C=$_[0];
Cursor::lazymap(sub { my $C=$_[0];
$C->obs('$> variable', '$::EUID')
}, $C->before(sub { my $C=shift;
do {
my @result = eval {
my $trystate;
my ($tag, $try);
my @try;
my $relex;

my $fate;
if ($fate = $C->{'_fate'} and $fate->[1] eq 'special_variable__S_169DollarGt_01') {
$C->deb("Fate passed to special_variable__S_169DollarGt_01: ", ::fatestr($fate)) if $::DEBUG & DEBUG::fates;
($C->{'_fate'}, $tag, $try) = @$fate;
@try = ($try);
}

my @gather = ();
for (;;) {
if (not @try) {
$relex //= $C->cursor_fate('STD', 'special_variable__S_169DollarGt_01', $retree);
@try = $relex->($C, $trystate);
}
last unless @try;
$try = shift(@try) // next;

if (ref $try eq 'ARRAY') {
($C->{'_fate'}, $tag, $try) = @$try;	# next candidate fate
}

$C->deb("special_variable__S_169DollarGt_01 trying $tag $try") if $::DEBUG & DEBUG::try_processing;
push @gather, ((
sub { my $C=shift;
$C->_PATTERN(qr/\G\s/)
},
sub { my $C=shift;
$C->_EXACT(',')
},
sub { my $C=shift;
$C->_SUBSUME(['terminator'], sub {
my $C = shift;
$C->terminator
})
},
)[$try])->($C);
last if @gather;
}
@gather;
};
if (@result) {
@result;
}
elsif ($@) {
my ($first) = $@ =~ /(^.*)/;
$self->deb("CAUGHT $first") if $::DEBUG & DEBUG::trace_call;
die $@ if $@ !~ /^ABORTBRANCH/;
();
}
else {
();
}
}

}))
}, $C->_COMMITBRANCH())
}, $C->_PATTERN(qr/\G\$\>/))
);
}

## token special_variable__S_170DollarDot (:$sym is context<rw> = <$.>)
##      token special_variable:sym<$.> {
##          <sym> :: <?before \s | ',' | <terminator> >
##          <.obs('$. variable', "filehandle's .line method")>
##      }

sub special_variable__S_170DollarDot__PEEK { $_[0]->_AUTOLEXpeek('special_variable__S_170DollarDot',$retree) }
sub special_variable__S_170DollarDot {
my $self = shift;
local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;
my %args = @_;
local $sym = $args{sym} // q($.);


my $C = $self;
my $S = $C->{'_pos'};
$C->{'sym'} = $sym;

$self->_MATCHIFY($S, "special_variable__S_170DollarDot", 
Cursor::lazymap(sub { my $C=$_[0];
Cursor::lazymap(sub { my $C=$_[0];
Cursor::lazymap(sub { my $C=$_[0];
$C->obs('$. variable', "filehandle's .line method")
}, $C->before(sub { my $C=shift;
do {
my @result = eval {
my $trystate;
my ($tag, $try);
my @try;
my $relex;

my $fate;
if ($fate = $C->{'_fate'} and $fate->[1] eq 'special_variable__S_170DollarDot_01') {
$C->deb("Fate passed to special_variable__S_170DollarDot_01: ", ::fatestr($fate)) if $::DEBUG & DEBUG::fates;
($C->{'_fate'}, $tag, $try) = @$fate;
@try = ($try);
}

my @gather = ();
for (;;) {
if (not @try) {
$relex //= $C->cursor_fate('STD', 'special_variable__S_170DollarDot_01', $retree);
@try = $relex->($C, $trystate);
}
last unless @try;
$try = shift(@try) // next;

if (ref $try eq 'ARRAY') {
($C->{'_fate'}, $tag, $try) = @$try;	# next candidate fate
}

$C->deb("special_variable__S_170DollarDot_01 trying $tag $try") if $::DEBUG & DEBUG::try_processing;
push @gather, ((
sub { my $C=shift;
$C->_PATTERN(qr/\G\s/)
},
sub { my $C=shift;
$C->_EXACT(',')
},
sub { my $C=shift;
$C->_SUBSUME(['terminator'], sub {
my $C = shift;
$C->terminator
})
},
)[$try])->($C);
last if @gather;
}
@gather;
};
if (@result) {
@result;
}
elsif ($@) {
my ($first) = $@ =~ /(^.*)/;
$self->deb("CAUGHT $first") if $::DEBUG & DEBUG::trace_call;
die $@ if $@ !~ /^ABORTBRANCH/;
();
}
else {
();
}
}

}))
}, $C->_COMMITBRANCH())
}, $C->_PATTERN(qr/\G\$\./))
);
}

## token special_variable__S_171DollarQuestion (:$sym is context<rw> = <$?>)
##      token special_variable:sym<$?> {
##          <sym> :: <?before \s | ',' | <terminator> >
##          <.obs('$? variable as child error', '$!')>
##      }

sub special_variable__S_171DollarQuestion__PEEK { $_[0]->_AUTOLEXpeek('special_variable__S_171DollarQuestion',$retree) }
sub special_variable__S_171DollarQuestion {
my $self = shift;
local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;
my %args = @_;
local $sym = $args{sym} // q($?);


my $C = $self;
my $S = $C->{'_pos'};
$C->{'sym'} = $sym;

$self->_MATCHIFY($S, "special_variable__S_171DollarQuestion", 
Cursor::lazymap(sub { my $C=$_[0];
Cursor::lazymap(sub { my $C=$_[0];
Cursor::lazymap(sub { my $C=$_[0];
$C->obs('$? variable as child error', '$!')
}, $C->before(sub { my $C=shift;
do {
my @result = eval {
my $trystate;
my ($tag, $try);
my @try;
my $relex;

my $fate;
if ($fate = $C->{'_fate'} and $fate->[1] eq 'special_variable__S_171DollarQuestion_01') {
$C->deb("Fate passed to special_variable__S_171DollarQuestion_01: ", ::fatestr($fate)) if $::DEBUG & DEBUG::fates;
($C->{'_fate'}, $tag, $try) = @$fate;
@try = ($try);
}

my @gather = ();
for (;;) {
if (not @try) {
$relex //= $C->cursor_fate('STD', 'special_variable__S_171DollarQuestion_01', $retree);
@try = $relex->($C, $trystate);
}
last unless @try;
$try = shift(@try) // next;

if (ref $try eq 'ARRAY') {
($C->{'_fate'}, $tag, $try) = @$try;	# next candidate fate
}

$C->deb("special_variable__S_171DollarQuestion_01 trying $tag $try") if $::DEBUG & DEBUG::try_processing;
push @gather, ((
sub { my $C=shift;
$C->_PATTERN(qr/\G\s/)
},
sub { my $C=shift;
$C->_EXACT(',')
},
sub { my $C=shift;
$C->_SUBSUME(['terminator'], sub {
my $C = shift;
$C->terminator
})
},
)[$try])->($C);
last if @gather;
}
@gather;
};
if (@result) {
@result;
}
elsif ($@) {
my ($first) = $@ =~ /(^.*)/;
$self->deb("CAUGHT $first") if $::DEBUG & DEBUG::trace_call;
die $@ if $@ !~ /^ABORTBRANCH/;
();
}
else {
();
}
}

}))
}, $C->_COMMITBRANCH())
}, $C->_PATTERN(qr/\G\$\?/))
);
}

# desigilname should only follow a sigil/twigil

## token desigilname
##      token desigilname {
##          [
##          | <?before '$' > <variable> { $*VAR = $<variable> }
##          | <longname>
##          ]
##      }

sub desigilname__PEEK { $_[0]->_AUTOLEXpeek('desigilname',$retree) }
sub desigilname {
my $self = shift;
local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;


my $C = $self;
my $S = $C->{'_pos'};

$self->_MATCHIFYr($S, "desigilname", 
$C->_BRACKETr( sub { my $C=shift;
do {
my @result = eval {
my $trystate;
my ($tag, $try);
my @try;
my $relex;

my $fate;
if ($fate = $C->{'_fate'} and $fate->[1] eq 'desigilname_01') {
$C->deb("Fate passed to desigilname_01: ", ::fatestr($fate)) if $::DEBUG & DEBUG::fates;
($C->{'_fate'}, $tag, $try) = @$fate;
@try = ($try);
}

my @gather = ();
for (;;) {
if (not @try) {
$relex //= $C->cursor_fate('STD', 'desigilname_01', $retree);
@try = $relex->($C, $trystate);
}
last unless @try;
$try = shift(@try) // next;

if (ref $try eq 'ARRAY') {
($C->{'_fate'}, $tag, $try) = @$try;	# next candidate fate
}

$C->deb("desigilname_01 trying $tag $try") if $::DEBUG & DEBUG::try_processing;
push @gather, ((
sub { my $C=shift;
do {
if (my ($C) = ($C->before(sub { my $C=shift;
$C->_EXACT('$')
}))) {
do {
if (my ($C) = ($C->_SUBSUMEr(['variable'], sub {
my $C = shift;
$C->variable
}))) {
scalar(do {
my $M = $C;  $::VAR = $M->{'variable'} ;
}, $C);
}
else {
();
}
};
}
else {
();
}
}
},
sub { my $C=shift;
$C->_SUBSUMEr(['longname'], sub {
my $C = shift;
$C->longname
})
},
)[$try])->($C);
last if @gather;
}
@gather;
};
if (@result) {
@result;
}
elsif ($@) {
my ($first) = $@ =~ /(^.*)/;
$self->deb("CAUGHT $first") if $::DEBUG & DEBUG::trace_call;
die $@ if $@ !~ /^ABORTBRANCH/;
();
}
else {
();
}
}

})
);
}

## token variable
##      token variable {
##          :my $IN_META is context<rw> = 0;
##          :my $sigil = '';
##          :my $twigil = '';
##          :my $name;
##          <?before <sigil> {
##              $sigil = $<sigil>.Str;
##              $*LEFTSIGIL ||= $sigil;
##          }> {}
##          [
##          || <sigil> <twigil>? <?before '::' [ '{' | '<' | '(' ]> <longname> # XXX
##          || '&'
##              [
##              | <twigil>? <sublongname> { $name = $<sublongname>.Str } {*}                                   #= subnoun
##              | :dba('infix noun') '[' ~ ']' <infixish(1)>
##              ]
##          || '$::' <name>? # XXX
##          || '$:' <name> # XXX
##          || [
##              | <sigil> <twigil>? <desigilname> { $name = $<desigilname>.Str } {*}                                    #= desigilname
##              | <special_variable> {*}                                    #= special
##              | <sigil> $<index>=[\d+] {*}                                #= $0
##              # Note: $() can also parse as contextualizer in an expression; should have same effect
##              | <sigil> <?before '<' | '('> <postcircumfix> {*}           #= $()
##              | <sigil> <?{ $*IN_DECL }> {*}                              #= anondecl
##              | <?> {{
##                  if $*QSIGIL {
##                      return ();
##                  }
##                  else {
##                      $¢.panic("Anonymous variable requires declarator");
##                  }
##                }}
##              ]
##          ]
##      
##          { my $t = $<twigil>; $twigil = $t.[0].Str if @$t; }
##          [ <?{ $twigil eq '.' }>
##              [<.unsp> | '\\' | <?> ] <?before '('> <postcircumfix> {*}          #= methcall
##          ]?
##      }

sub variable__PEEK { $_[0]->_AUTOLEXpeek('variable',$retree) }
sub variable {
my $self = shift;
local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;
local $::IN_META = 0;
my $sigil = '';
my $twigil = '';
my $name;


my $C = $self;
my $S = $C->{'_pos'};
$C->{'name'} = [];
$C->{'postcircumfix'} = [];
$C->{'twigil'} = [];

$self->_MATCHIFY($S, "variable", 
Cursor::lazymap(sub { my $C=$_[0];
Cursor::lazymap(sub { my $C=$_[0];
Cursor::lazymap(sub { my $C=$_[0];
Cursor::lazymap(sub { my $C=$_[0];
$C->_OPTr(sub { my $C=shift;
$C->_BRACKET( sub { my $C=shift;
Cursor::lazymap(sub { my $C=$_[0];
Cursor::lazymap(sub { my $C=$_[0];
Cursor::lazymap(sub { my $C=$_[0];
Cursor::lazymap(sub { my $C=$_[0];
$C->_REDUCE($S, 'variable', 'methcall')
}, $C->_SUBSUME(['postcircumfix'], sub {
my $C = shift;
$C->postcircumfix
}))
}, $C->before(sub { my $C=shift;
$C->_EXACT('(')
}))
}, $C->_BRACKET( sub { my $C=shift;
do {
my @result = eval {
my $trystate;
my ($tag, $try);
my @try;
my $relex;

my $fate;
if ($fate = $C->{'_fate'} and $fate->[1] eq 'variable_14') {
$C->deb("Fate passed to variable_14: ", ::fatestr($fate)) if $::DEBUG & DEBUG::fates;
($C->{'_fate'}, $tag, $try) = @$fate;
@try = ($try);
}

my @gather = ();
for (;;) {
if (not @try) {
$relex //= $C->cursor_fate('STD', 'variable_14', $retree);
@try = $relex->($C, $trystate);
}
last unless @try;
$try = shift(@try) // next;

if (ref $try eq 'ARRAY') {
($C->{'_fate'}, $tag, $try) = @$try;	# next candidate fate
}

$C->deb("variable_14 trying $tag $try") if $::DEBUG & DEBUG::try_processing;
push @gather, ((
sub { my $C=shift;
$C->unsp
},
sub { my $C=shift;
$C->_EXACT('\\')
},
sub { my $C=shift;
$C->before( sub { my $C=shift;
$C
})
},
)[$try])->($C);
last if @gather;
}
@gather;
};
if (@result) {
@result;
}
elsif ($@) {
my ($first) = $@ =~ /(^.*)/;
$self->deb("CAUGHT $first") if $::DEBUG & DEBUG::trace_call;
die $@ if $@ !~ /^ABORTBRANCH/;
();
}
else {
();
}
}

}))
}, $C->before( sub { my $C=shift;
(($C) x !!do {
$twigil eq '.' 
})
}))
})
})
}, scalar(do {
my $M = $C;  my $t = $M->{'twigil'}; $twigil = $t->[0]->Str if @$t; ;
}, $C))
}, $C->_BRACKET( sub { my $C=shift;
do { my @gather;
eval { push @gather, do {
if (my ($C) = ($C->_SUBSUMEr(['sigil'], sub {
my $C = shift;
$C->sigil
}))) {
do {
if (my ($C) = ($C->_OPTr(sub { my $C=shift;
$C->_SUBSUMEr(['twigil'], sub {
my $C = shift;
$C->twigil
})
}))) {
do {
if (my ($C) = ($C->before(sub { my $C=shift;
do {
if (my ($C) = ($C->_EXACT('::'))) {
$C->_BRACKETr( sub { my $C=shift;
do {
my @result = eval {
my $trystate;
my ($tag, $try);
my @try;
my $relex;

my $fate;
if ($fate = $C->{'_fate'} and $fate->[1] eq 'variable_04') {
$C->deb("Fate passed to variable_04: ", ::fatestr($fate)) if $::DEBUG & DEBUG::fates;
($C->{'_fate'}, $tag, $try) = @$fate;
@try = ($try);
}

my @gather = ();
for (;;) {
if (not @try) {
$relex //= $C->cursor_fate('STD', 'variable_04', $retree);
@try = $relex->($C, $trystate);
}
last unless @try;
$try = shift(@try) // next;

if (ref $try eq 'ARRAY') {
($C->{'_fate'}, $tag, $try) = @$try;	# next candidate fate
}

$C->deb("variable_04 trying $tag $try") if $::DEBUG & DEBUG::try_processing;
push @gather, ((
sub { my $C=shift;
$C->_EXACT('{')
},
sub { my $C=shift;
$C->_EXACT('<')
},
sub { my $C=shift;
$C->_EXACT('(')
},
)[$try])->($C);
last if @gather;
}
@gather;
};
if (@result) {
@result;
}
elsif ($@) {
my ($first) = $@ =~ /(^.*)/;
$self->deb("CAUGHT $first") if $::DEBUG & DEBUG::trace_call;
die $@ if $@ !~ /^ABORTBRANCH/;
();
}
else {
();
}
}

});
}
else {
();
}
}
}))) {
$C->_SUBSUMEr(['longname'], sub {
my $C = shift;
$C->longname
});
}
else {
();
}
};
}
else {
();
}
};
}
else {
();
}
}} // do {die $@ if $@ and $@ !~ /ABORT/;1} 
or
eval { push @gather, Cursor::lazymap(sub { my $C=$_[0];
$C->_BRACKET( sub { my $C=shift;
do {
my @result = eval {
my $trystate;
my ($tag, $try);
my @try;
my $relex;

my $fate;
if ($fate = $C->{'_fate'} and $fate->[1] eq 'variable_06') {
$C->deb("Fate passed to variable_06: ", ::fatestr($fate)) if $::DEBUG & DEBUG::fates;
($C->{'_fate'}, $tag, $try) = @$fate;
@try = ($try);
}

my @gather = ();
for (;;) {
if (not @try) {
$relex //= $C->cursor_fate('STD', 'variable_06', $retree);
@try = $relex->($C, $trystate);
}
last unless @try;
$try = shift(@try) // next;

if (ref $try eq 'ARRAY') {
($C->{'_fate'}, $tag, $try) = @$try;	# next candidate fate
}

$C->deb("variable_06 trying $tag $try") if $::DEBUG & DEBUG::try_processing;
push @gather, ((
sub { my $C=shift;
do {
if (my ($C) = ($C->_OPTr(sub { my $C=shift;
$C->_SUBSUMEr(['twigil'], sub {
my $C = shift;
$C->twigil
})
}))) {
do {
if (my ($C) = ($C->_SUBSUMEr(['sublongname'], sub {
my $C = shift;
$C->sublongname
}))) {
do {
if (my ($C) = (scalar(do {
my $M = $C;  $name = $M->{'sublongname'}->Str ;
}, $C))) {
$C->_REDUCE($S, 'variable', 'subnoun');
}
else {
();
}
};
}
else {
();
}
};
}
else {
();
}
}
},
sub { my $C=shift;
Cursor::lazymap(sub { my $C=$_[0];
Cursor::lazymap(sub { my $C=$_[0];
Cursor::lazymap(sub { my $C=$_[0];
$C->_BRACKET( sub { my $C=shift;
do { my @gather;
eval { push @gather, $C->_EXACT(']')} // do {die $@ if $@ and $@ !~ /ABORT/;1} 
or
eval { push @gather, $C->FAILGOAL(']' , 'infix noun')} or do { die $@ if $@ };
@gather;
}
})
}, $C->_SUBSUME(['infixish'], sub {
my $C = shift;
$C->infixish(1)
}))
}, $C->_COMMITBRANCH(local $::GOAL = ']' ))
}, $C->_EXACT('['))
},
)[$try])->($C);
last if @gather;
}
@gather;
};
if (@result) {
@result;
}
elsif ($@) {
my ($first) = $@ =~ /(^.*)/;
$self->deb("CAUGHT $first") if $::DEBUG & DEBUG::trace_call;
die $@ if $@ !~ /^ABORTBRANCH/;
();
}
else {
();
}
}

})
}, $C->_EXACT('&'))} // do {die $@ if $@ and $@ !~ /ABORT/;1} 
or
eval { push @gather, Cursor::lazymap(sub { my $C=$_[0];
$C->_OPTr(sub { my $C=shift;
$C->_SUBSUME(['name'], sub {
my $C = shift;
$C->name
})
})
}, $C->_EXACT('$::'))} // do {die $@ if $@ and $@ !~ /ABORT/;1} 
or
eval { push @gather, Cursor::lazymap(sub { my $C=$_[0];
$C->_SUBSUME(['name'], sub {
my $C = shift;
$C->name
})
}, $C->_EXACT('$:'))} // do {die $@ if $@ and $@ !~ /ABORT/;1} 
or
eval { push @gather, $C->_BRACKET( sub { my $C=shift;
do {
my @result = eval {
my $trystate;
my ($tag, $try);
my @try;
my $relex;

my $fate;
if ($fate = $C->{'_fate'} and $fate->[1] eq 'variable_10') {
$C->deb("Fate passed to variable_10: ", ::fatestr($fate)) if $::DEBUG & DEBUG::fates;
($C->{'_fate'}, $tag, $try) = @$fate;
@try = ($try);
}

my @gather = ();
for (;;) {
if (not @try) {
$relex //= $C->cursor_fate('STD', 'variable_10', $retree);
@try = $relex->($C, $trystate);
}
last unless @try;
$try = shift(@try) // next;

if (ref $try eq 'ARRAY') {
($C->{'_fate'}, $tag, $try) = @$try;	# next candidate fate
}

$C->deb("variable_10 trying $tag $try") if $::DEBUG & DEBUG::try_processing;
push @gather, ((
sub { my $C=shift;
Cursor::lazymap(sub { my $C=$_[0];
Cursor::lazymap(sub { my $C=$_[0];
Cursor::lazymap(sub { my $C=$_[0];
Cursor::lazymap(sub { my $C=$_[0];
$C->_REDUCE($S, 'variable', 'desigilname')
}, scalar(do {
my $M = $C;  $name = $M->{'desigilname'}->Str ;
}, $C))
}, $C->_SUBSUME(['desigilname'], sub {
my $C = shift;
$C->desigilname
}))
}, $C->_OPTr(sub { my $C=shift;
$C->_SUBSUME(['twigil'], sub {
my $C = shift;
$C->twigil
})
}))
}, $C->_SUBSUME(['sigil'], sub {
my $C = shift;
$C->sigil
}))
},
sub { my $C=shift;
Cursor::lazymap(sub { my $C=$_[0];
$C->_REDUCE($S, 'variable', 'special')
}, $C->_SUBSUME(['special_variable'], sub {
my $C = shift;
$C->special_variable
}))
},
sub { my $C=shift;
Cursor::lazymap(sub { my $C=$_[0];
Cursor::lazymap(sub { my $C=$_[0];
$C->_REDUCE($S, 'variable', '$C<0>')
},     $C->_SUBSUME(['index'], sub {
my $C = shift;
$C->_BRACKET( sub { my $C=shift;
$C->_PATTERN(qr/\G((?:\d)++)/)
})
}))
}, $C->_SUBSUME(['sigil'], sub {
my $C = shift;
$C->sigil
}))
},
sub { my $C=shift;
Cursor::lazymap(sub { my $C=$_[0];
Cursor::lazymap(sub { my $C=$_[0];
Cursor::lazymap(sub { my $C=$_[0];
$C->_REDUCE($S, 'variable', '$()')
}, $C->_SUBSUME(['postcircumfix'], sub {
my $C = shift;
$C->postcircumfix
}))
}, $C->before(sub { my $C=shift;
do {
my @result = eval {
my $trystate;
my ($tag, $try);
my @try;
my $relex;

my $fate;
if ($fate = $C->{'_fate'} and $fate->[1] eq 'variable_12') {
$C->deb("Fate passed to variable_12: ", ::fatestr($fate)) if $::DEBUG & DEBUG::fates;
($C->{'_fate'}, $tag, $try) = @$fate;
@try = ($try);
}

my @gather = ();
for (;;) {
if (not @try) {
$relex //= $C->cursor_fate('STD', 'variable_12', $retree);
@try = $relex->($C, $trystate);
}
last unless @try;
$try = shift(@try) // next;

if (ref $try eq 'ARRAY') {
($C->{'_fate'}, $tag, $try) = @$try;	# next candidate fate
}

$C->deb("variable_12 trying $tag $try") if $::DEBUG & DEBUG::try_processing;
push @gather, ((
sub { my $C=shift;
$C->_EXACT('<')
},
sub { my $C=shift;
$C->_EXACT('(')
},
)[$try])->($C);
last if @gather;
}
@gather;
};
if (@result) {
@result;
}
elsif ($@) {
my ($first) = $@ =~ /(^.*)/;
$self->deb("CAUGHT $first") if $::DEBUG & DEBUG::trace_call;
die $@ if $@ !~ /^ABORTBRANCH/;
();
}
else {
();
}
}

}))
}, $C->_SUBSUME(['sigil'], sub {
my $C = shift;
$C->sigil
}))
},
sub { my $C=shift;
Cursor::lazymap(sub { my $C=$_[0];
Cursor::lazymap(sub { my $C=$_[0];
$C->_REDUCE($S, 'variable', 'anondecl')
}, $C->before( sub { my $C=shift;
(($C) x !!do {
$::IN_DECL 
})
}))
}, $C->_SUBSUME(['sigil'], sub {
my $C = shift;
$C->sigil
}))
},
sub { my $C=shift;
Cursor::lazymap(sub { my $C=$_[0];
scalar(do {

if ($::QSIGIL) {
return ();
}
else {
$C->panic("Anonymous variable requires declarator");
}

}, $C)
}, $C->before( sub { my $C=shift;
$C
}))
},
)[$try])->($C);
last if @gather;
}
@gather;
};
if (@result) {
@result;
}
elsif ($@) {
my ($first) = $@ =~ /(^.*)/;
$self->deb("CAUGHT $first") if $::DEBUG & DEBUG::trace_call;
die $@ if $@ !~ /^ABORTBRANCH/;
();
}
else {
();
}
}

})} or do { die $@ if $@ };
@gather;
}
}))
}, scalar(do {

}, $C))
}, $C->before(sub { my $C=shift;
do {
if (my ($C) = ($C->_SUBSUMEr(['sigil'], sub {
my $C = shift;
$C->sigil
}))) {
scalar(do {
my $M = $C; 
$sigil = $M->{'sigil'}->Str;
$::LEFTSIGIL ||= $sigil;
;
}, $C);
}
else {
();
}
}
}))
);
}



# Note, don't reduce on a bare sigil unless you don't want a twigil or
# you otherwise don't care what the longest token is.

## token sigil__S_172Dollar (:$sym is context<rw> = <$>)
##      token sigil:sym<$>  { <sym> }

sub sigil__S_172Dollar__PEEK { $_[0]->_AUTOLEXpeek('sigil__S_172Dollar',$retree) }
sub sigil__S_172Dollar {
my $self = shift;
local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;
my %args = @_;
local $sym = $args{sym} // q($);


my $C = $self;
my $S = $C->{'_pos'};
$C->{'sym'} = $sym;

$self->_MATCHIFYr($S, "sigil__S_172Dollar", 
$C->_PATTERN(qr/\G\$/)
);
}
## token sigil__S_173AtAt (:$sym is context<rw> = <@@>)
##      token sigil:sym<@@> { <sym> }

sub sigil__S_173AtAt__PEEK { $_[0]->_AUTOLEXpeek('sigil__S_173AtAt',$retree) }
sub sigil__S_173AtAt {
my $self = shift;
local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;
my %args = @_;
local $sym = $args{sym} // q(@@);


my $C = $self;
my $S = $C->{'_pos'};
$C->{'sym'} = $sym;

$self->_MATCHIFYr($S, "sigil__S_173AtAt", 
$C->_PATTERN(qr/\G\@\@/)
);
}
## token sigil__S_174At (:$sym is context<rw> = <@>)
##      token sigil:sym<@>  { <sym> }

sub sigil__S_174At__PEEK { $_[0]->_AUTOLEXpeek('sigil__S_174At',$retree) }
sub sigil__S_174At {
my $self = shift;
local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;
my %args = @_;
local $sym = $args{sym} // q(@);


my $C = $self;
my $S = $C->{'_pos'};
$C->{'sym'} = $sym;

$self->_MATCHIFYr($S, "sigil__S_174At", 
$C->_PATTERN(qr/\G\@/)
);
}
## token sigil__S_175Percent (:$sym is context<rw> = <%>)
##      token sigil:sym<%>  { <sym> }

sub sigil__S_175Percent__PEEK { $_[0]->_AUTOLEXpeek('sigil__S_175Percent',$retree) }
sub sigil__S_175Percent {
my $self = shift;
local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;
my %args = @_;
local $sym = $args{sym} // q(%);


my $C = $self;
my $S = $C->{'_pos'};
$C->{'sym'} = $sym;

$self->_MATCHIFYr($S, "sigil__S_175Percent", 
$C->_PATTERN(qr/\G\%/)
);
}
## token sigil__S_176Amp (:$sym is context<rw> = <&>)
##      token sigil:sym<&>  { <sym> }

sub sigil__S_176Amp__PEEK { $_[0]->_AUTOLEXpeek('sigil__S_176Amp',$retree) }
sub sigil__S_176Amp {
my $self = shift;
local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;
my %args = @_;
local $sym = $args{sym} // q(&);


my $C = $self;
my $S = $C->{'_pos'};
$C->{'sym'} = $sym;

$self->_MATCHIFYr($S, "sigil__S_176Amp", 
$C->_PATTERN(qr/\G\&/)
);
}

## token twigil__S_177Dot (:$sym is context<rw> = <.>)
##      token twigil:sym<.> { <sym> }

sub twigil__S_177Dot__PEEK { $_[0]->_AUTOLEXpeek('twigil__S_177Dot',$retree) }
sub twigil__S_177Dot {
my $self = shift;
local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;
my %args = @_;
local $sym = $args{sym} // q(.);


my $C = $self;
my $S = $C->{'_pos'};
$C->{'sym'} = $sym;

$self->_MATCHIFYr($S, "twigil__S_177Dot", 
$C->_PATTERN(qr/\G\./)
);
}
## token twigil__S_178Bang (:$sym is context<rw> = <!>)
##      token twigil:sym<!> { <sym> }

sub twigil__S_178Bang__PEEK { $_[0]->_AUTOLEXpeek('twigil__S_178Bang',$retree) }
sub twigil__S_178Bang {
my $self = shift;
local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;
my %args = @_;
local $sym = $args{sym} // q(!);


my $C = $self;
my $S = $C->{'_pos'};
$C->{'sym'} = $sym;

$self->_MATCHIFYr($S, "twigil__S_178Bang", 
$C->_PATTERN(qr/\G\!/)
);
}
## token twigil__S_179Caret (:$sym is context<rw> = <^>)
##      token twigil:sym<^> { <sym> }

sub twigil__S_179Caret__PEEK { $_[0]->_AUTOLEXpeek('twigil__S_179Caret',$retree) }
sub twigil__S_179Caret {
my $self = shift;
local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;
my %args = @_;
local $sym = $args{sym} // q(^);


my $C = $self;
my $S = $C->{'_pos'};
$C->{'sym'} = $sym;

$self->_MATCHIFYr($S, "twigil__S_179Caret", 
$C->_PATTERN(qr/\G\^/)
);
}
## token twigil__S_180Colon (:$sym is context<rw> = <:>)
##      token twigil:sym<:> { <sym> <!before ':'> }

sub twigil__S_180Colon__PEEK { $_[0]->_AUTOLEXpeek('twigil__S_180Colon',$retree) }
sub twigil__S_180Colon {
my $self = shift;
local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;
my %args = @_;
local $sym = $args{sym} // q(:);


my $C = $self;
my $S = $C->{'_pos'};
$C->{'sym'} = $sym;

$self->_MATCHIFYr($S, "twigil__S_180Colon", 
do {
if (my ($C) = ($C->_PATTERN(qr/\G\:/))) {
$C->_NOTBEFORE( sub { my $C=shift;
$C->before(sub { my $C=shift;
$C->_EXACT(':')
})
});
}
else {
();
}
}
);
}
## token twigil__S_181Star (:$sym is context<rw> = <*>)
##      token twigil:sym<*> { <sym> }

sub twigil__S_181Star__PEEK { $_[0]->_AUTOLEXpeek('twigil__S_181Star',$retree) }
sub twigil__S_181Star {
my $self = shift;
local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;
my %args = @_;
local $sym = $args{sym} // q(*);


my $C = $self;
my $S = $C->{'_pos'};
$C->{'sym'} = $sym;

$self->_MATCHIFYr($S, "twigil__S_181Star", 
$C->_PATTERN(qr/\G\*/)
);
}
## token twigil__S_182Plus (:$sym is context<rw> = <+>)
##      token twigil:sym<+> { <sym> <!!worry: "The + twigil is deprecated, use the * twigil instead"> }

sub twigil__S_182Plus__PEEK { $_[0]->_AUTOLEXpeek('twigil__S_182Plus',$retree) }
sub twigil__S_182Plus {
my $self = shift;
local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;
my %args = @_;
local $sym = $args{sym} // q(+);


my $C = $self;
my $S = $C->{'_pos'};
$C->{'sym'} = $sym;

$self->_MATCHIFYr($S, "twigil__S_182Plus", 
do {
if (my ($C) = ($C->_PATTERN(qr/\G\+/))) {
$C->_NOTBEFORE( sub { my $C=shift;
$C->_NOTBEFORE( sub { my $C=shift;
$C->worry("The + twigil is deprecated, use the * twigil instead")
})
});
}
else {
();
}
}
);
}
## token twigil__S_183Question (:$sym is context<rw> = <?>)
##      token twigil:sym<?> { <sym> }

sub twigil__S_183Question__PEEK { $_[0]->_AUTOLEXpeek('twigil__S_183Question',$retree) }
sub twigil__S_183Question {
my $self = shift;
local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;
my %args = @_;
local $sym = $args{sym} // q(?);


my $C = $self;
my $S = $C->{'_pos'};
$C->{'sym'} = $sym;

$self->_MATCHIFYr($S, "twigil__S_183Question", 
$C->_PATTERN(qr/\G\?/)
);
}
## token twigil__S_184Equal (:$sym is context<rw> = <=>)
##      token twigil:sym<=> { <sym> }

sub twigil__S_184Equal__PEEK { $_[0]->_AUTOLEXpeek('twigil__S_184Equal',$retree) }
sub twigil__S_184Equal {
my $self = shift;
local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;
my %args = @_;
local $sym = $args{sym} // q(=);


my $C = $self;
my $S = $C->{'_pos'};
$C->{'sym'} = $sym;

$self->_MATCHIFYr($S, "twigil__S_184Equal", 
$C->_PATTERN(qr/\G\=/)
);
}
## token twigil__S_185Tilde (:$sym is context<rw> = <~>)
##      token twigil:sym<~> { <sym> }

sub twigil__S_185Tilde__PEEK { $_[0]->_AUTOLEXpeek('twigil__S_185Tilde',$retree) }
sub twigil__S_185Tilde {
my $self = shift;
local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;
my %args = @_;
local $sym = $args{sym} // q(~);


my $C = $self;
my $S = $C->{'_pos'};
$C->{'sym'} = $sym;

$self->_MATCHIFYr($S, "twigil__S_185Tilde", 
$C->_PATTERN(qr/\G\~/)
);
}

## token deflongname
##      token deflongname {
##          :dba('new name to be defined')
##          <name>
##          [
##          | <colonpair>+ { $¢.add_macro($<name>) if $*IN_DECL; }
##          | { $¢.add_routine($<name>.Str) if $*IN_DECL; }
##          ]
##      }

sub deflongname__PEEK { $_[0]->_AUTOLEXpeek('deflongname',$retree) }
sub deflongname {
my $self = shift;
local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;


my $C = $self;
my $S = $C->{'_pos'};
$C->{'colonpair'} = [];

$self->_MATCHIFYr($S, "deflongname", 
do {
if (my ($C) = ($C->_SUBSUMEr(['name'], sub {
my $C = shift;
$C->name
}))) {
$C->_BRACKETr( sub { my $C=shift;
do {
my @result = eval {
my $trystate;
my ($tag, $try);
my @try;
my $relex;

my $fate;
if ($fate = $C->{'_fate'} and $fate->[1] eq 'deflongname_01') {
$C->deb("Fate passed to deflongname_01: ", ::fatestr($fate)) if $::DEBUG & DEBUG::fates;
($C->{'_fate'}, $tag, $try) = @$fate;
@try = ($try);
}

my @gather = ();
for (;;) {
if (not @try) {
$relex //= $C->cursor_fate('STD', 'deflongname_01', $retree);
@try = $relex->($C, $trystate);
}
last unless @try;
$try = shift(@try) // next;

if (ref $try eq 'ARRAY') {
($C->{'_fate'}, $tag, $try) = @$try;	# next candidate fate
}

$C->deb("deflongname_01 trying $tag $try") if $::DEBUG & DEBUG::try_processing;
push @gather, ((
sub { my $C=shift;
do {
if (my ($C) = ($C->_PLUSr(sub { my $C=shift;
$C->_SUBSUMEr(['colonpair'], sub {
my $C = shift;
$C->colonpair
})
}))) {
scalar(do {
my $M = $C;  $C->add_macro($M->{'name'}) if $::IN_DECL; ;
}, $C);
}
else {
();
}
}
},
sub { my $C=shift;
scalar(do {
my $M = $C;  $C->add_routine($M->{'name'}->Str) if $::IN_DECL; ;
}, $C)
},
)[$try])->($C);
last if @gather;
}
@gather;
};
if (@result) {
@result;
}
elsif ($@) {
my ($first) = $@ =~ /(^.*)/;
$self->deb("CAUGHT $first") if $::DEBUG & DEBUG::trace_call;
die $@ if $@ !~ /^ABORTBRANCH/;
();
}
else {
();
}
}

});
}
else {
();
}
}
);
}

## token longname
##      token longname {
##          <name> <colonpair>*
##      }

sub longname__PEEK { $_[0]->_AUTOLEXpeek('longname',$retree) }
sub longname {
my $self = shift;
local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;


my $C = $self;
my $S = $C->{'_pos'};
$C->{'colonpair'} = [];

$self->_MATCHIFYr($S, "longname", 
do {
if (my ($C) = ($C->_SUBSUMEr(['name'], sub {
my $C = shift;
$C->name
}))) {
$C->_STARr(sub { my $C=shift;
$C->_SUBSUMEr(['colonpair'], sub {
my $C = shift;
$C->colonpair
})
});
}
else {
();
}
}
);
}

## token name
##      token name {
##          [
##          | <identifier> <morename>*
##          | <morename>+
##          ]
##      }

sub name__PEEK { $_[0]->_AUTOLEXpeek('name',$retree) }
sub name {
my $self = shift;
local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;


my $C = $self;
my $S = $C->{'_pos'};
$C->{'morename'} = [];

$self->_MATCHIFYr($S, "name", 
$C->_BRACKETr( sub { my $C=shift;
do {
my @result = eval {
my $trystate;
my ($tag, $try);
my @try;
my $relex;

my $fate;
if ($fate = $C->{'_fate'} and $fate->[1] eq 'name_01') {
$C->deb("Fate passed to name_01: ", ::fatestr($fate)) if $::DEBUG & DEBUG::fates;
($C->{'_fate'}, $tag, $try) = @$fate;
@try = ($try);
}

my @gather = ();
for (;;) {
if (not @try) {
$relex //= $C->cursor_fate('STD', 'name_01', $retree);
@try = $relex->($C, $trystate);
}
last unless @try;
$try = shift(@try) // next;

if (ref $try eq 'ARRAY') {
($C->{'_fate'}, $tag, $try) = @$try;	# next candidate fate
}

$C->deb("name_01 trying $tag $try") if $::DEBUG & DEBUG::try_processing;
push @gather, ((
sub { my $C=shift;
do {
if (my ($C) = ($C->_SUBSUMEr(['identifier'], sub {
my $C = shift;
$C->identifier
}))) {
$C->_STARr(sub { my $C=shift;
$C->_SUBSUMEr(['morename'], sub {
my $C = shift;
$C->morename
})
});
}
else {
();
}
}
},
sub { my $C=shift;
$C->_PLUSr(sub { my $C=shift;
$C->_SUBSUMEr(['morename'], sub {
my $C = shift;
$C->morename
})
})
},
)[$try])->($C);
last if @gather;
}
@gather;
};
if (@result) {
@result;
}
elsif ($@) {
my ($first) = $@ =~ /(^.*)/;
$self->deb("CAUGHT $first") if $::DEBUG & DEBUG::trace_call;
die $@ if $@ !~ /^ABORTBRANCH/;
();
}
else {
();
}
}

})
);
}

## token morename
##      token morename {
##          :my $QSIGIL is context<rw> = '';
##          '::'
##          [
##              <?before '(' | <alpha> >
##              [
##              | <identifier>
##              | :dba('indirect name') '(' ~ ')' <EXPR>
##              ]
##          ]?
##      }

sub morename__PEEK { $_[0]->_AUTOLEXpeek('morename',$retree) }
sub morename {
my $self = shift;
local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;
local $::QSIGIL = '';


my $C = $self;
my $S = $C->{'_pos'};
$C->{'identifier'} = [];
$C->{'EXPR'} = [];

$self->_MATCHIFY($S, "morename", 
Cursor::lazymap(sub { my $C=$_[0];
$C->_OPTr(sub { my $C=shift;
$C->_BRACKET( sub { my $C=shift;
Cursor::lazymap(sub { my $C=$_[0];
$C->_BRACKET( sub { my $C=shift;
do {
my @result = eval {
my $trystate;
my ($tag, $try);
my @try;
my $relex;

my $fate;
if ($fate = $C->{'_fate'} and $fate->[1] eq 'morename_03') {
$C->deb("Fate passed to morename_03: ", ::fatestr($fate)) if $::DEBUG & DEBUG::fates;
($C->{'_fate'}, $tag, $try) = @$fate;
@try = ($try);
}

my @gather = ();
for (;;) {
if (not @try) {
$relex //= $C->cursor_fate('STD', 'morename_03', $retree);
@try = $relex->($C, $trystate);
}
last unless @try;
$try = shift(@try) // next;

if (ref $try eq 'ARRAY') {
($C->{'_fate'}, $tag, $try) = @$try;	# next candidate fate
}

$C->deb("morename_03 trying $tag $try") if $::DEBUG & DEBUG::try_processing;
push @gather, ((
sub { my $C=shift;
$C->_SUBSUMEr(['identifier'], sub {
my $C = shift;
$C->identifier
})
},
sub { my $C=shift;
Cursor::lazymap(sub { my $C=$_[0];
Cursor::lazymap(sub { my $C=$_[0];
Cursor::lazymap(sub { my $C=$_[0];
$C->_BRACKET( sub { my $C=shift;
do { my @gather;
eval { push @gather, $C->_EXACT(')')} // do {die $@ if $@ and $@ !~ /ABORT/;1} 
or
eval { push @gather, $C->FAILGOAL(')' , 'indirect name')} or do { die $@ if $@ };
@gather;
}
})
}, $C->_SUBSUME(['EXPR'], sub {
my $C = shift;
$C->EXPR
}))
}, $C->_COMMITBRANCH(local $::GOAL = ')' ))
}, $C->_EXACT('('))
},
)[$try])->($C);
last if @gather;
}
@gather;
};
if (@result) {
@result;
}
elsif ($@) {
my ($first) = $@ =~ /(^.*)/;
$self->deb("CAUGHT $first") if $::DEBUG & DEBUG::trace_call;
die $@ if $@ !~ /^ABORTBRANCH/;
();
}
else {
();
}
}

})
}, $C->before(sub { my $C=shift;
do {
my @result = eval {
my $trystate;
my ($tag, $try);
my @try;
my $relex;

my $fate;
if ($fate = $C->{'_fate'} and $fate->[1] eq 'morename_02') {
$C->deb("Fate passed to morename_02: ", ::fatestr($fate)) if $::DEBUG & DEBUG::fates;
($C->{'_fate'}, $tag, $try) = @$fate;
@try = ($try);
}

my @gather = ();
for (;;) {
if (not @try) {
$relex //= $C->cursor_fate('STD', 'morename_02', $retree);
@try = $relex->($C, $trystate);
}
last unless @try;
$try = shift(@try) // next;

if (ref $try eq 'ARRAY') {
($C->{'_fate'}, $tag, $try) = @$try;	# next candidate fate
}

$C->deb("morename_02 trying $tag $try") if $::DEBUG & DEBUG::try_processing;
push @gather, ((
sub { my $C=shift;
$C->_EXACT('(')
},
sub { my $C=shift;
$C->_PATTERN(qr/\G[_[:alpha:]]/)
},
)[$try])->($C);
last if @gather;
}
@gather;
};
if (@result) {
@result;
}
elsif ($@) {
my ($first) = $@ =~ /(^.*)/;
$self->deb("CAUGHT $first") if $::DEBUG & DEBUG::trace_call;
die $@ if $@ !~ /^ABORTBRANCH/;
();
}
else {
();
}
}

}))
})
})
}, $C->_EXACT('::'))
);
}

## token subshortname
##      token subshortname {
##          [
##          | <category>
##              [ <colonpair>+ { $¢.add_macro($<category>) if $*IN_DECL; } ]?
##          | <desigilname>
##          ]
##      }

sub subshortname__PEEK { $_[0]->_AUTOLEXpeek('subshortname',$retree) }
sub subshortname {
my $self = shift;
local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;


my $C = $self;
my $S = $C->{'_pos'};
$C->{'colonpair'} = [];

$self->_MATCHIFYr($S, "subshortname", 
$C->_BRACKETr( sub { my $C=shift;
do {
my @result = eval {
my $trystate;
my ($tag, $try);
my @try;
my $relex;

my $fate;
if ($fate = $C->{'_fate'} and $fate->[1] eq 'subshortname_01') {
$C->deb("Fate passed to subshortname_01: ", ::fatestr($fate)) if $::DEBUG & DEBUG::fates;
($C->{'_fate'}, $tag, $try) = @$fate;
@try = ($try);
}

my @gather = ();
for (;;) {
if (not @try) {
$relex //= $C->cursor_fate('STD', 'subshortname_01', $retree);
@try = $relex->($C, $trystate);
}
last unless @try;
$try = shift(@try) // next;

if (ref $try eq 'ARRAY') {
($C->{'_fate'}, $tag, $try) = @$try;	# next candidate fate
}

$C->deb("subshortname_01 trying $tag $try") if $::DEBUG & DEBUG::try_processing;
push @gather, ((
sub { my $C=shift;
do {
if (my ($C) = ($C->_SUBSUMEr(['category'], sub {
my $C = shift;
$C->category
}))) {
$C->_OPTr(sub { my $C=shift;
$C->_BRACKETr( sub { my $C=shift;
do {
if (my ($C) = ($C->_PLUSr(sub { my $C=shift;
$C->_SUBSUMEr(['colonpair'], sub {
my $C = shift;
$C->colonpair
})
}))) {
scalar(do {
my $M = $C;  $C->add_macro($M->{'category'}) if $::IN_DECL; ;
}, $C);
}
else {
();
}
}
})
});
}
else {
();
}
}
},
sub { my $C=shift;
$C->_SUBSUMEr(['desigilname'], sub {
my $C = shift;
$C->desigilname
})
},
)[$try])->($C);
last if @gather;
}
@gather;
};
if (@result) {
@result;
}
elsif ($@) {
my ($first) = $@ =~ /(^.*)/;
$self->deb("CAUGHT $first") if $::DEBUG & DEBUG::trace_call;
die $@ if $@ !~ /^ABORTBRANCH/;
();
}
else {
();
}
}

})
);
}

## token sublongname
##      token sublongname {
##          <subshortname> <sigterm>?
##      }

sub sublongname__PEEK { $_[0]->_AUTOLEXpeek('sublongname',$retree) }
sub sublongname {
my $self = shift;
local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;


my $C = $self;
my $S = $C->{'_pos'};
$C->{'sigterm'} = [];

$self->_MATCHIFYr($S, "sublongname", 
do {
if (my ($C) = ($C->_SUBSUMEr(['subshortname'], sub {
my $C = shift;
$C->subshortname
}))) {
$C->_OPTr(sub { my $C=shift;
$C->_SUBSUMEr(['sigterm'], sub {
my $C = shift;
$C->sigterm
})
});
}
else {
();
}
}
);
}

## token value__S_186quote (:$sym is context<rw> = 'quote')
##      token value:quote   { <quote> }

sub value__S_186quote__PEEK { $_[0]->_AUTOLEXpeek('value__S_186quote',$retree) }
sub value__S_186quote {
my $self = shift;
local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;
my %args = @_;
local $sym = $args{sym} // 'quote';


my $C = $self;
my $S = $C->{'_pos'};
$C->{'sym'} = $sym;

$self->_MATCHIFYr($S, "value__S_186quote", 
$C->_SUBSUMEr(['quote'], sub {
my $C = shift;
$C->quote
})
);
}
## token value__S_187number (:$sym is context<rw> = 'number')
##      token value:number  { <number> }

sub value__S_187number__PEEK { $_[0]->_AUTOLEXpeek('value__S_187number',$retree) }
sub value__S_187number {
my $self = shift;
local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;
my %args = @_;
local $sym = $args{sym} // 'number';


my $C = $self;
my $S = $C->{'_pos'};
$C->{'sym'} = $sym;

$self->_MATCHIFYr($S, "value__S_187number", 
$C->_SUBSUMEr(['number'], sub {
my $C = shift;
$C->number
})
);
}
## token value__S_188version (:$sym is context<rw> = 'version')
##      token value:version { <version> }

sub value__S_188version__PEEK { $_[0]->_AUTOLEXpeek('value__S_188version',$retree) }
sub value__S_188version {
my $self = shift;
local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;
my %args = @_;
local $sym = $args{sym} // 'version';


my $C = $self;
my $S = $C->{'_pos'};
$C->{'sym'} = $sym;

$self->_MATCHIFYr($S, "value__S_188version", 
$C->_SUBSUMEr(['version'], sub {
my $C = shift;
$C->version
})
);
}

# Note: call this only to use existing type, not to declare type
## token typename
##      token typename {
##          [
##          | '::?'<identifier>                 # parse ::?CLASS as special case
##          | <longname>
##            <?{{
##              my $longname = $<longname>.Str;
##              if substr($longname, 0, 2) eq '::' {
##                  $¢.add_my_name(substr($longname, 2));
##              }
##              else {
##                  $¢.is_name($longname)
##              }
##            }}>
##          ]
##          # parametric type?
##          <.unsp>? [ <?before '['> <postcircumfix> ]?
##          <.ws> [ 'of' <.ws> <typename> ]?
##      }

sub typename__PEEK { $_[0]->_AUTOLEXpeek('typename',$retree) }
sub typename {
my $self = shift;
local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;


my $C = $self;
my $S = $C->{'_pos'};
$C->{'typename'} = [];
$C->{'postcircumfix'} = [];

$self->_MATCHIFYr($S, "typename", 
do {
if (my ($C) = ($C->_BRACKETr( sub { my $C=shift;
do {
my @result = eval {
my $trystate;
my ($tag, $try);
my @try;
my $relex;

my $fate;
if ($fate = $C->{'_fate'} and $fate->[1] eq 'typename_01') {
$C->deb("Fate passed to typename_01: ", ::fatestr($fate)) if $::DEBUG & DEBUG::fates;
($C->{'_fate'}, $tag, $try) = @$fate;
@try = ($try);
}

my @gather = ();
for (;;) {
if (not @try) {
$relex //= $C->cursor_fate('STD', 'typename_01', $retree);
@try = $relex->($C, $trystate);
}
last unless @try;
$try = shift(@try) // next;

if (ref $try eq 'ARRAY') {
($C->{'_fate'}, $tag, $try) = @$try;	# next candidate fate
}

$C->deb("typename_01 trying $tag $try") if $::DEBUG & DEBUG::try_processing;
push @gather, ((
sub { my $C=shift;
do {
if (my ($C) = ($C->_EXACT('::?'))) {
$C->_SUBSUMEr(['identifier'], sub {
my $C = shift;
$C->identifier
});
}
else {
();
}
}
},
sub { my $C=shift;
do {
if (my ($C) = ($C->_SUBSUMEr(['longname'], sub {
my $C = shift;
$C->longname
}))) {
$C->before( sub { my $C=shift;
(($C) x !!do {
my $M = $C; 
my $longname = $M->{'longname'}->Str;
if (substr($longname, 0, 2) eq '::') {
$C->add_my_name(substr($longname, 2));
}
else {
$C->is_name($longname)
}
;
})
});
}
else {
();
}
}
},
)[$try])->($C);
last if @gather;
}
@gather;
};
if (@result) {
@result;
}
elsif ($@) {
my ($first) = $@ =~ /(^.*)/;
$self->deb("CAUGHT $first") if $::DEBUG & DEBUG::trace_call;
die $@ if $@ !~ /^ABORTBRANCH/;
();
}
else {
();
}
}

}))) {
do {
if (my ($C) = ($C->_OPTr(sub { my $C=shift;
$C->unsp
}))) {
do {
if (my ($C) = ($C->_OPTr(sub { my $C=shift;
$C->_BRACKETr( sub { my $C=shift;
do {
if (my ($C) = ($C->before(sub { my $C=shift;
$C->_EXACT('[')
}))) {
$C->_SUBSUMEr(['postcircumfix'], sub {
my $C = shift;
$C->postcircumfix
});
}
else {
();
}
}
})
}))) {
do {
if (my ($C) = ($C->ws)) {
$C->_OPTr(sub { my $C=shift;
$C->_BRACKETr( sub { my $C=shift;
do {
if (my ($C) = ($C->_EXACT('of'))) {
do {
if (my ($C) = ($C->ws)) {
$C->_SUBSUMEr(['typename'], sub {
my $C = shift;
$C->typename
});
}
else {
();
}
};
}
else {
();
}
}
})
});
}
else {
();
}
};
}
else {
();
}
};
}
else {
();
}
};
}
else {
();
}
}
);
}

## token numish
##      token numish {
##          [
##          | <integer>
##          | <dec_number>
##          | <rad_number>
##          | 'NaN' »
##          | 'Inf' »
##          | '+Inf' »
##          | '-Inf' »
##          ]
##      }

sub numish__PEEK { $_[0]->_AUTOLEXpeek('numish',$retree) }
sub numish {
my $self = shift;
local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;


my $C = $self;
my $S = $C->{'_pos'};

$self->_MATCHIFYr($S, "numish", 
$C->_BRACKETr( sub { my $C=shift;
do {
my @result = eval {
my $trystate;
my ($tag, $try);
my @try;
my $relex;

my $fate;
if ($fate = $C->{'_fate'} and $fate->[1] eq 'numish_01') {
$C->deb("Fate passed to numish_01: ", ::fatestr($fate)) if $::DEBUG & DEBUG::fates;
($C->{'_fate'}, $tag, $try) = @$fate;
@try = ($try);
}

my @gather = ();
for (;;) {
if (not @try) {
$relex //= $C->cursor_fate('STD', 'numish_01', $retree);
@try = $relex->($C, $trystate);
}
last unless @try;
$try = shift(@try) // next;

if (ref $try eq 'ARRAY') {
($C->{'_fate'}, $tag, $try) = @$try;	# next candidate fate
}

$C->deb("numish_01 trying $tag $try") if $::DEBUG & DEBUG::try_processing;
push @gather, ((
sub { my $C=shift;
$C->_SUBSUMEr(['integer'], sub {
my $C = shift;
$C->integer
})
},
sub { my $C=shift;
$C->_SUBSUMEr(['dec_number'], sub {
my $C = shift;
$C->dec_number
})
},
sub { my $C=shift;
$C->_SUBSUMEr(['rad_number'], sub {
my $C = shift;
$C->rad_number
})
},
sub { my $C=shift;
do {
if (my ($C) = ($C->_EXACT('NaN'))) {
$C->_PATTERN(qr/\G\b/);
}
else {
();
}
}
},
sub { my $C=shift;
do {
if (my ($C) = ($C->_EXACT('Inf'))) {
$C->_PATTERN(qr/\G\b/);
}
else {
();
}
}
},
sub { my $C=shift;
do {
if (my ($C) = ($C->_EXACT('+Inf'))) {
$C->_PATTERN(qr/\G\b/);
}
else {
();
}
}
},
sub { my $C=shift;
do {
if (my ($C) = ($C->_EXACT('-Inf'))) {
$C->_PATTERN(qr/\G\b/);
}
else {
();
}
}
},
)[$try])->($C);
last if @gather;
}
@gather;
};
if (@result) {
@result;
}
elsif ($@) {
my ($first) = $@ =~ /(^.*)/;
$self->deb("CAUGHT $first") if $::DEBUG & DEBUG::trace_call;
die $@ if $@ !~ /^ABORTBRANCH/;
();
}
else {
();
}
}

})
);
}

## token number__S_189rational (:$sym is context<rw> = 'rational')
##      token number:rational { <nu=integer>'/'<de=integer> }

sub number__S_189rational__PEEK { $_[0]->_AUTOLEXpeek('number__S_189rational',$retree) }
sub number__S_189rational {
my $self = shift;
local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;
my %args = @_;
local $sym = $args{sym} // 'rational';


my $C = $self;
my $S = $C->{'_pos'};
$C->{'sym'} = $sym;

$self->_MATCHIFYr($S, "number__S_189rational", 
do {
if (my ($C) = (    $C->_SUBSUMEr(['nu'], sub {
my $C = shift;
$C->integer
}))) {
do {
if (my ($C) = ($C->_EXACT('/'))) {
$C->_SUBSUMEr(['de'], sub {
my $C = shift;
$C->integer
});
}
else {
();
}
};
}
else {
();
}
}
);
}
## token number__S_190complex (:$sym is context<rw> = 'complex')
##      token number:complex { <re=numish>'+'<im=numish>'\\'?'i' | <im=numish>'\\'?'i' }

sub number__S_190complex__PEEK { $_[0]->_AUTOLEXpeek('number__S_190complex',$retree) }
sub number__S_190complex {
my $self = shift;
local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;
my %args = @_;
local $sym = $args{sym} // 'complex';


my $C = $self;
my $S = $C->{'_pos'};
$C->{'sym'} = $sym;

$self->_MATCHIFYr($S, "number__S_190complex", 
do {
my @result = eval {
my $trystate;
my ($tag, $try);
my @try;
my $relex;

my $fate;
if ($fate = $C->{'_fate'} and $fate->[1] eq 'number__S_190complex_00') {
$C->deb("Fate passed to number__S_190complex_00: ", ::fatestr($fate)) if $::DEBUG & DEBUG::fates;
($C->{'_fate'}, $tag, $try) = @$fate;
@try = ($try);
}

my @gather = ();
for (;;) {
if (not @try) {
$relex //= $C->cursor_fate('STD', 'number__S_190complex_00', $retree);
@try = $relex->($C, $trystate);
}
last unless @try;
$try = shift(@try) // next;

if (ref $try eq 'ARRAY') {
($C->{'_fate'}, $tag, $try) = @$try;	# next candidate fate
}

$C->deb("number__S_190complex_00 trying $tag $try") if $::DEBUG & DEBUG::try_processing;
push @gather, ((
sub { my $C=shift;
do {
if (my ($C) = (    $C->_SUBSUMEr(['re'], sub {
my $C = shift;
$C->numish
}))) {
do {
if (my ($C) = ($C->_EXACT('+'))) {
do {
if (my ($C) = (    $C->_SUBSUMEr(['im'], sub {
my $C = shift;
$C->numish
}))) {
do {
if (my ($C) = ($C->_OPTr(sub { my $C=shift;
$C->_EXACT('\\')
}))) {
$C->_EXACT('i');
}
else {
();
}
};
}
else {
();
}
};
}
else {
();
}
};
}
else {
();
}
}
},
sub { my $C=shift;
do {
if (my ($C) = (    $C->_SUBSUMEr(['im'], sub {
my $C = shift;
$C->numish
}))) {
do {
if (my ($C) = ($C->_OPTr(sub { my $C=shift;
$C->_EXACT('\\')
}))) {
$C->_EXACT('i');
}
else {
();
}
};
}
else {
();
}
}
},
)[$try])->($C);
last if @gather;
}
@gather;
};
if (@result) {
@result;
}
elsif ($@) {
my ($first) = $@ =~ /(^.*)/;
$self->deb("CAUGHT $first") if $::DEBUG & DEBUG::trace_call;
die $@ if $@ !~ /^ABORTBRANCH/;
();
}
else {
();
}
}

);
}
## token number__S_191numish (:$sym is context<rw> = 'numish')
##      token number:numish { <numish> }

sub number__S_191numish__PEEK { $_[0]->_AUTOLEXpeek('number__S_191numish',$retree) }
sub number__S_191numish {
my $self = shift;
local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;
my %args = @_;
local $sym = $args{sym} // 'numish';


my $C = $self;
my $S = $C->{'_pos'};
$C->{'sym'} = $sym;

$self->_MATCHIFYr($S, "number__S_191numish", 
$C->_SUBSUMEr(['numish'], sub {
my $C = shift;
$C->numish
})
);
}

## token integer
##      token integer {
##          [
##          | 0 [ b <[01]>+           [ _ <[01]>+ ]*
##              | o <[0..7]>+         [ _ <[0..7]>+ ]*
##              | x <[0..9a..fA..F]>+ [ _ <[0..9a..fA..F]>+ ]*
##              | d \d+               [ _ \d+]*
##              | \d+[_\d+]*
##                  <!!{ $¢.worry("Leading 0 does not indicate octal in Perl 6") }>
##              ]
##          | \d+[_\d+]*
##          ]
##          <!!before ['.' <?before \s | ',' | '=' | <terminator> > <.panic: "Decimal point must be followed by digit">]? >
##      }

sub integer__PEEK { $_[0]->_AUTOLEXpeek('integer',$retree) }
sub integer {
my $self = shift;
local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;


my $C = $self;
my $S = $C->{'_pos'};

$self->_MATCHIFYr($S, "integer", 
do {
if (my ($C) = ($C->_BRACKETr( sub { my $C=shift;
do {
my @result = eval {
my $trystate;
my ($tag, $try);
my @try;
my $relex;

my $fate;
if ($fate = $C->{'_fate'} and $fate->[1] eq 'integer_01') {
$C->deb("Fate passed to integer_01: ", ::fatestr($fate)) if $::DEBUG & DEBUG::fates;
($C->{'_fate'}, $tag, $try) = @$fate;
@try = ($try);
}

my @gather = ();
for (;;) {
if (not @try) {
$relex //= $C->cursor_fate('STD', 'integer_01', $retree);
@try = $relex->($C, $trystate);
}
last unless @try;
$try = shift(@try) // next;

if (ref $try eq 'ARRAY') {
($C->{'_fate'}, $tag, $try) = @$try;	# next candidate fate
}

$C->deb("integer_01 trying $tag $try") if $::DEBUG & DEBUG::try_processing;
push @gather, ((
sub { my $C=shift;
do {
if (my ($C) = ($C->_EXACT('0'))) {
$C->_BRACKETr( sub { my $C=shift;
do {
my @result = eval {
my $trystate;
my ($tag, $try);
my @try;
my $relex;

my $fate;
if ($fate = $C->{'_fate'} and $fate->[1] eq 'integer_02') {
$C->deb("Fate passed to integer_02: ", ::fatestr($fate)) if $::DEBUG & DEBUG::fates;
($C->{'_fate'}, $tag, $try) = @$fate;
@try = ($try);
}

my @gather = ();
for (;;) {
if (not @try) {
$relex //= $C->cursor_fate('STD', 'integer_02', $retree);
@try = $relex->($C, $trystate);
}
last unless @try;
$try = shift(@try) // next;

if (ref $try eq 'ARRAY') {
($C->{'_fate'}, $tag, $try) = @$try;	# next candidate fate
}

$C->deb("integer_02 trying $tag $try") if $::DEBUG & DEBUG::try_processing;
push @gather, ((
sub { my $C=shift;
do {
if (my ($C) = ($C->_EXACT('b'))) {
do {
if (my ($C) = ($C->_PATTERN(qr/\G((?:[01])++)/))) {
$C->_STARr(sub { my $C=shift;
$C->_BRACKETr( sub { my $C=shift;
do {
if (my ($C) = ($C->_EXACT('_'))) {
$C->_PATTERN(qr/\G((?:[01])++)/);
}
else {
();
}
}
})
});
}
else {
();
}
};
}
else {
();
}
}
},
sub { my $C=shift;
do {
if (my ($C) = ($C->_EXACT('o'))) {
do {
if (my ($C) = ($C->_PATTERN(qr/\G((?:[0-7])++)/))) {
$C->_STARr(sub { my $C=shift;
$C->_BRACKETr( sub { my $C=shift;
do {
if (my ($C) = ($C->_EXACT('_'))) {
$C->_PATTERN(qr/\G((?:[0-7])++)/);
}
else {
();
}
}
})
});
}
else {
();
}
};
}
else {
();
}
}
},
sub { my $C=shift;
do {
if (my ($C) = ($C->_EXACT('x'))) {
do {
if (my ($C) = ($C->_PATTERN(qr/\G((?:[0-9a-fA-F])++)/))) {
$C->_STARr(sub { my $C=shift;
$C->_BRACKETr( sub { my $C=shift;
do {
if (my ($C) = ($C->_EXACT('_'))) {
$C->_PATTERN(qr/\G((?:[0-9a-fA-F])++)/);
}
else {
();
}
}
})
});
}
else {
();
}
};
}
else {
();
}
}
},
sub { my $C=shift;
do {
if (my ($C) = ($C->_EXACT('d'))) {
do {
if (my ($C) = ($C->_PATTERN(qr/\G((?:\d)++)/))) {
$C->_STARr(sub { my $C=shift;
$C->_BRACKETr( sub { my $C=shift;
do {
if (my ($C) = ($C->_EXACT('_'))) {
$C->_PATTERN(qr/\G((?:\d)++)/);
}
else {
();
}
}
})
});
}
else {
();
}
};
}
else {
();
}
}
},
sub { my $C=shift;
do {
if (my ($C) = ($C->_PATTERN(qr/\G((?:\d)++)/))) {
do {
if (my ($C) = ($C->_STARr(sub { my $C=shift;
$C->_BRACKETr( sub { my $C=shift;
do {
if (my ($C) = ($C->_EXACT('_'))) {
$C->_PATTERN(qr/\G((?:\d)++)/);
}
else {
();
}
}
})
}))) {
$C->_NOTBEFORE( sub { my $C=shift;
$C->_NOTBEFORE( sub { my $C=shift;
(($C) x !!do {
$C->worry("Leading 0 does not indicate octal in Perl 6") 
})
})
});
}
else {
();
}
};
}
else {
();
}
}
},
)[$try])->($C);
last if @gather;
}
@gather;
};
if (@result) {
@result;
}
elsif ($@) {
my ($first) = $@ =~ /(^.*)/;
$self->deb("CAUGHT $first") if $::DEBUG & DEBUG::trace_call;
die $@ if $@ !~ /^ABORTBRANCH/;
();
}
else {
();
}
}

});
}
else {
();
}
}
},
sub { my $C=shift;
do {
if (my ($C) = ($C->_PATTERN(qr/\G((?:\d)++)/))) {
$C->_STARr(sub { my $C=shift;
$C->_BRACKETr( sub { my $C=shift;
do {
if (my ($C) = ($C->_EXACT('_'))) {
$C->_PATTERN(qr/\G((?:\d)++)/);
}
else {
();
}
}
})
});
}
else {
();
}
}
},
)[$try])->($C);
last if @gather;
}
@gather;
};
if (@result) {
@result;
}
elsif ($@) {
my ($first) = $@ =~ /(^.*)/;
$self->deb("CAUGHT $first") if $::DEBUG & DEBUG::trace_call;
die $@ if $@ !~ /^ABORTBRANCH/;
();
}
else {
();
}
}

}))) {
$C->_NOTBEFORE( sub { my $C=shift;
$C->_NOTBEFORE( sub { my $C=shift;
$C->before(sub { my $C=shift;
$C->_OPTr(sub { my $C=shift;
$C->_BRACKETr( sub { my $C=shift;
do {
if (my ($C) = ($C->_EXACT('.'))) {
do {
if (my ($C) = ($C->before(sub { my $C=shift;
do {
my @result = eval {
my $trystate;
my ($tag, $try);
my @try;
my $relex;

my $fate;
if ($fate = $C->{'_fate'} and $fate->[1] eq 'integer_11') {
$C->deb("Fate passed to integer_11: ", ::fatestr($fate)) if $::DEBUG & DEBUG::fates;
($C->{'_fate'}, $tag, $try) = @$fate;
@try = ($try);
}

my @gather = ();
for (;;) {
if (not @try) {
$relex //= $C->cursor_fate('STD', 'integer_11', $retree);
@try = $relex->($C, $trystate);
}
last unless @try;
$try = shift(@try) // next;

if (ref $try eq 'ARRAY') {
($C->{'_fate'}, $tag, $try) = @$try;	# next candidate fate
}

$C->deb("integer_11 trying $tag $try") if $::DEBUG & DEBUG::try_processing;
push @gather, ((
sub { my $C=shift;
$C->_PATTERN(qr/\G\s/)
},
sub { my $C=shift;
$C->_EXACT(',')
},
sub { my $C=shift;
$C->_EXACT('=')
},
sub { my $C=shift;
$C->_SUBSUMEr(['terminator'], sub {
my $C = shift;
$C->terminator
})
},
)[$try])->($C);
last if @gather;
}
@gather;
};
if (@result) {
@result;
}
elsif ($@) {
my ($first) = $@ =~ /(^.*)/;
$self->deb("CAUGHT $first") if $::DEBUG & DEBUG::trace_call;
die $@ if $@ !~ /^ABORTBRANCH/;
();
}
else {
();
}
}

}))) {
$C->panic("Decimal point must be followed by digit");
}
else {
();
}
};
}
else {
();
}
}
})
})
})
})
});
}
else {
();
}
}
);
}

## token radint
##      token radint {
##          [
##          | <integer>
##          | <?before ':'> <rad_number> <?{
##                              defined $<rad_number><intpart>
##                              and
##                              not defined $<rad_number><fracpart>
##                          }>
##          ]
##      }

sub radint__PEEK { $_[0]->_AUTOLEXpeek('radint',$retree) }
sub radint {
my $self = shift;
local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;


my $C = $self;
my $S = $C->{'_pos'};

$self->_MATCHIFYr($S, "radint", 
$C->_BRACKETr( sub { my $C=shift;
do {
my @result = eval {
my $trystate;
my ($tag, $try);
my @try;
my $relex;

my $fate;
if ($fate = $C->{'_fate'} and $fate->[1] eq 'radint_01') {
$C->deb("Fate passed to radint_01: ", ::fatestr($fate)) if $::DEBUG & DEBUG::fates;
($C->{'_fate'}, $tag, $try) = @$fate;
@try = ($try);
}

my @gather = ();
for (;;) {
if (not @try) {
$relex //= $C->cursor_fate('STD', 'radint_01', $retree);
@try = $relex->($C, $trystate);
}
last unless @try;
$try = shift(@try) // next;

if (ref $try eq 'ARRAY') {
($C->{'_fate'}, $tag, $try) = @$try;	# next candidate fate
}

$C->deb("radint_01 trying $tag $try") if $::DEBUG & DEBUG::try_processing;
push @gather, ((
sub { my $C=shift;
$C->_SUBSUMEr(['integer'], sub {
my $C = shift;
$C->integer
})
},
sub { my $C=shift;
do {
if (my ($C) = ($C->before(sub { my $C=shift;
$C->_EXACT(':')
}))) {
do {
if (my ($C) = ($C->_SUBSUMEr(['rad_number'], sub {
my $C = shift;
$C->rad_number
}))) {
$C->before( sub { my $C=shift;
(($C) x !!do {
my $M = $C; 
defined $M->{'rad_number'}{'intpart'}
and
not defined $M->{'rad_number'}{'fracpart'}
;
})
});
}
else {
();
}
};
}
else {
();
}
}
},
)[$try])->($C);
last if @gather;
}
@gather;
};
if (@result) {
@result;
}
elsif ($@) {
my ($first) = $@ =~ /(^.*)/;
$self->deb("CAUGHT $first") if $::DEBUG & DEBUG::trace_call;
die $@ if $@ !~ /^ABORTBRANCH/;
();
}
else {
();
}
}

})
);
}

## token escale
##      token escale {
##          <[Ee]> <[+\-]>? \d+[_\d+]*
##      }

sub escale__PEEK { $_[0]->_AUTOLEXpeek('escale',$retree) }
sub escale {
my $self = shift;
local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;


my $C = $self;
my $S = $C->{'_pos'};

$self->_MATCHIFYr($S, "escale", 
do {
if (my ($C) = ($C->_PATTERN(qr/\G[Ee]/))) {
do {
if (my ($C) = ($C->_PATTERN(qr/\G((?:[+\-])?+)/))) {
do {
if (my ($C) = ($C->_PATTERN(qr/\G((?:\d)++)/))) {
$C->_STARr(sub { my $C=shift;
$C->_BRACKETr( sub { my $C=shift;
do {
if (my ($C) = ($C->_EXACT('_'))) {
$C->_PATTERN(qr/\G((?:\d)++)/);
}
else {
();
}
}
})
});
}
else {
();
}
};
}
else {
();
}
};
}
else {
();
}
}
);
}

# careful to distinguish from both integer and 42.method
## token dec_number
##      token dec_number {
##          :dba('decimal number')
##          [
##          | $<coeff> = [           '.' \d+[_\d+]* ] <escale>?
##          | $<coeff> = [\d+[_\d+]* '.' \d+[_\d+]* ] <escale>?
##          | $<coeff> = [\d+[_\d+]*                ] <escale>
##          ]
##          <!!before [ '.' <?before \d> <.panic: "Number contains two decimal points (missing 'v' for version number?)">]? >
##      }

sub dec_number__PEEK { $_[0]->_AUTOLEXpeek('dec_number',$retree) }
sub dec_number {
my $self = shift;
local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;


my $C = $self;
my $S = $C->{'_pos'};
$C->{'escale'} = [];

$self->_MATCHIFYr($S, "dec_number", 
do {
if (my ($C) = ($C->_BRACKETr( sub { my $C=shift;
do {
my @result = eval {
my $trystate;
my ($tag, $try);
my @try;
my $relex;

my $fate;
if ($fate = $C->{'_fate'} and $fate->[1] eq 'dec_number_01') {
$C->deb("Fate passed to dec_number_01: ", ::fatestr($fate)) if $::DEBUG & DEBUG::fates;
($C->{'_fate'}, $tag, $try) = @$fate;
@try = ($try);
}

my @gather = ();
for (;;) {
if (not @try) {
$relex //= $C->cursor_fate('STD', 'dec_number_01', $retree);
@try = $relex->($C, $trystate);
}
last unless @try;
$try = shift(@try) // next;

if (ref $try eq 'ARRAY') {
($C->{'_fate'}, $tag, $try) = @$try;	# next candidate fate
}

$C->deb("dec_number_01 trying $tag $try") if $::DEBUG & DEBUG::try_processing;
push @gather, ((
sub { my $C=shift;
do {
if (my ($C) = (    $C->_SUBSUMEr(['coeff'], sub {
my $C = shift;
$C->_BRACKETr( sub { my $C=shift;
do {
if (my ($C) = ($C->_EXACT('.'))) {
do {
if (my ($C) = ($C->_PATTERN(qr/\G((?:\d)++)/))) {
$C->_STARr(sub { my $C=shift;
$C->_BRACKETr( sub { my $C=shift;
do {
if (my ($C) = ($C->_EXACT('_'))) {
$C->_PATTERN(qr/\G((?:\d)++)/);
}
else {
();
}
}
})
});
}
else {
();
}
};
}
else {
();
}
}
})
}))) {
$C->_OPTr(sub { my $C=shift;
$C->_SUBSUMEr(['escale'], sub {
my $C = shift;
$C->escale
})
});
}
else {
();
}
}
},
sub { my $C=shift;
do {
if (my ($C) = (    $C->_SUBSUMEr(['coeff'], sub {
my $C = shift;
$C->_BRACKETr( sub { my $C=shift;
do {
if (my ($C) = ($C->_PATTERN(qr/\G((?:\d)++)/))) {
do {
if (my ($C) = ($C->_STARr(sub { my $C=shift;
$C->_BRACKETr( sub { my $C=shift;
do {
if (my ($C) = ($C->_EXACT('_'))) {
$C->_PATTERN(qr/\G((?:\d)++)/);
}
else {
();
}
}
})
}))) {
do {
if (my ($C) = ($C->_EXACT('.'))) {
do {
if (my ($C) = ($C->_PATTERN(qr/\G((?:\d)++)/))) {
$C->_STARr(sub { my $C=shift;
$C->_BRACKETr( sub { my $C=shift;
do {
if (my ($C) = ($C->_EXACT('_'))) {
$C->_PATTERN(qr/\G((?:\d)++)/);
}
else {
();
}
}
})
});
}
else {
();
}
};
}
else {
();
}
};
}
else {
();
}
};
}
else {
();
}
}
})
}))) {
$C->_OPTr(sub { my $C=shift;
$C->_SUBSUMEr(['escale'], sub {
my $C = shift;
$C->escale
})
});
}
else {
();
}
}
},
sub { my $C=shift;
do {
if (my ($C) = (    $C->_SUBSUMEr(['coeff'], sub {
my $C = shift;
$C->_BRACKETr( sub { my $C=shift;
do {
if (my ($C) = ($C->_PATTERN(qr/\G((?:\d)++)/))) {
$C->_STARr(sub { my $C=shift;
$C->_BRACKETr( sub { my $C=shift;
do {
if (my ($C) = ($C->_EXACT('_'))) {
$C->_PATTERN(qr/\G((?:\d)++)/);
}
else {
();
}
}
})
});
}
else {
();
}
}
})
}))) {
$C->_SUBSUMEr(['escale'], sub {
my $C = shift;
$C->escale
});
}
else {
();
}
}
},
)[$try])->($C);
last if @gather;
}
@gather;
};
if (@result) {
@result;
}
elsif ($@) {
my ($first) = $@ =~ /(^.*)/;
$self->deb("CAUGHT $first") if $::DEBUG & DEBUG::trace_call;
die $@ if $@ !~ /^ABORTBRANCH/;
();
}
else {
();
}
}

}))) {
$C->_NOTBEFORE( sub { my $C=shift;
$C->_NOTBEFORE( sub { my $C=shift;
$C->before(sub { my $C=shift;
$C->_OPTr(sub { my $C=shift;
$C->_BRACKETr( sub { my $C=shift;
do {
if (my ($C) = ($C->_EXACT('.'))) {
do {
if (my ($C) = ($C->before(sub { my $C=shift;
$C->_PATTERN(qr/\G\d/)
}))) {
$C->panic("Number contains two decimal points (missing 'v' for version number?)");
}
else {
();
}
};
}
else {
();
}
}
})
})
})
})
});
}
else {
();
}
}
);
}

## token rad_number
##      token rad_number {
##          ':' $<radix> = [\d+] <.unsp>?      # XXX optional dot here?
##          {}           # don't recurse in lexer
##          :dba('number in radix notation')
##          [
##          || '<'
##                  $<intpart> = [ <[ 0..9 a..z A..Z ]>+ [ _ <[ 0..9 a..z A..Z ]>+ ]* ]
##                  $<fracpart> = [ '.' <[ 0..9 a..z A..Z ]>+ [ _ <[ 0..9 a..z A..Z ]>+ ]* ]?
##                  [ '*' <base=radint> '**' <exp=radint> ]?
##             '>'
##      #      { make radcalc($<radix>, $<intpart>, $<fracpart>, $<base>, $<exp>) }
##          || <?before '['> <circumfix>
##          || <?before '('> <circumfix>
##          ]
##      }

sub rad_number__PEEK { $_[0]->_AUTOLEXpeek('rad_number',$retree) }
sub rad_number {
my $self = shift;
local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;


my $C = $self;
my $S = $C->{'_pos'};
$C->{'exp'} = [];
$C->{'base'} = [];

$self->_MATCHIFYr($S, "rad_number", 
do {
if (my ($C) = ($C->_EXACT(':'))) {
do {
if (my ($C) = (    $C->_SUBSUMEr(['radix'], sub {
my $C = shift;
$C->_BRACKETr( sub { my $C=shift;
$C->_PATTERN(qr/\G((?:\d)++)/)
})
}))) {
do {
if (my ($C) = ($C->_OPTr(sub { my $C=shift;
$C->unsp
}))) {
do {
if (my ($C) = (scalar(do {

}, $C))) {
$C->_BRACKETr( sub { my $C=shift;
do { my @gather;
eval { push @gather, do {
if (my ($C) = ($C->_EXACT('<'))) {
do {
if (my ($C) = (    $C->_SUBSUMEr(['intpart'], sub {
my $C = shift;
$C->_BRACKETr( sub { my $C=shift;
do {
if (my ($C) = ($C->_PATTERN(qr/\G((?:[0-9a-zA-Z])++)/))) {
$C->_STARr(sub { my $C=shift;
$C->_BRACKETr( sub { my $C=shift;
do {
if (my ($C) = ($C->_EXACT('_'))) {
$C->_PATTERN(qr/\G((?:[0-9a-zA-Z])++)/);
}
else {
();
}
}
})
});
}
else {
();
}
}
})
}))) {
do {
if (my ($C) = (    $C->_OPTr(sub { my $C=shift;
$C->_SUBSUMEr(['fracpart'], sub {
my $C = shift;
$C->_BRACKETr( sub { my $C=shift;
do {
if (my ($C) = ($C->_EXACT('.'))) {
do {
if (my ($C) = ($C->_PATTERN(qr/\G((?:[0-9a-zA-Z])++)/))) {
$C->_STARr(sub { my $C=shift;
$C->_BRACKETr( sub { my $C=shift;
do {
if (my ($C) = ($C->_EXACT('_'))) {
$C->_PATTERN(qr/\G((?:[0-9a-zA-Z])++)/);
}
else {
();
}
}
})
});
}
else {
();
}
};
}
else {
();
}
}
})
})
}))) {
do {
if (my ($C) = ($C->_OPTr(sub { my $C=shift;
$C->_BRACKETr( sub { my $C=shift;
do {
if (my ($C) = ($C->_EXACT('*'))) {
do {
if (my ($C) = (    $C->_SUBSUMEr(['base'], sub {
my $C = shift;
$C->radint
}))) {
do {
if (my ($C) = ($C->_EXACT('**'))) {
$C->_SUBSUMEr(['exp'], sub {
my $C = shift;
$C->radint
});
}
else {
();
}
};
}
else {
();
}
};
}
else {
();
}
}
})
}))) {
$C->_EXACT('>');
}
else {
();
}
};
}
else {
();
}
};
}
else {
();
}
};
}
else {
();
}
}} // do {die $@ if $@ and $@ !~ /ABORT/;1} 
or
eval { push @gather, do {
if (my ($C) = ($C->before(sub { my $C=shift;
$C->_EXACT('[')
}))) {
$C->_SUBSUMEr(['circumfix'], sub {
my $C = shift;
$C->circumfix
});
}
else {
();
}
}} // do {die $@ if $@ and $@ !~ /ABORT/;1} 
or
eval { push @gather, do {
if (my ($C) = ($C->before(sub { my $C=shift;
$C->_EXACT('(')
}))) {
$C->_SUBSUMEr(['circumfix'], sub {
my $C = shift;
$C->circumfix
});
}
else {
();
}
}} or do { die $@ if $@ };
@gather;
}
});
}
else {
();
}
};
}
else {
();
}
};
}
else {
();
}
};
}
else {
();
}
}
);
}

## token octints
##      token octints { [<.ws><octint><.ws>] ** ',' }

sub octints__PEEK { $_[0]->_AUTOLEXpeek('octints',$retree) }
sub octints {
my $self = shift;
local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;


my $C = $self;
my $S = $C->{'_pos'};
$C->{'octint'} = [];

$self->_MATCHIFYr($S, "octints", 
$C->_REPSEPr(  sub { my $C=shift;
$C->_EXACT(',')
}, sub { my $C=shift;
$C->_BRACKETr( sub { my $C=shift;
do {
if (my ($C) = ($C->ws)) {
do {
if (my ($C) = ($C->_SUBSUMEr(['octint'], sub {
my $C = shift;
$C->octint
}))) {
$C->ws;
}
else {
();
}
};
}
else {
();
}
}
})
})
);
}

## token octint
##      token octint {
##          <[ 0..7 ]>+ [ _ <[ 0..7 ]>+ ]*
##      }

sub octint__PEEK { $_[0]->_AUTOLEXpeek('octint',$retree) }
sub octint {
my $self = shift;
local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;


my $C = $self;
my $S = $C->{'_pos'};

$self->_MATCHIFYr($S, "octint", 
do {
if (my ($C) = ($C->_PATTERN(qr/\G((?:[0-7])++)/))) {
$C->_STARr(sub { my $C=shift;
$C->_BRACKETr( sub { my $C=shift;
do {
if (my ($C) = ($C->_EXACT('_'))) {
$C->_PATTERN(qr/\G((?:[0-7])++)/);
}
else {
();
}
}
})
});
}
else {
();
}
}
);
}

## token hexints
##      token hexints { [<.ws><hexint><.ws>] ** ',' }

sub hexints__PEEK { $_[0]->_AUTOLEXpeek('hexints',$retree) }
sub hexints {
my $self = shift;
local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;


my $C = $self;
my $S = $C->{'_pos'};
$C->{'hexint'} = [];

$self->_MATCHIFYr($S, "hexints", 
$C->_REPSEPr(  sub { my $C=shift;
$C->_EXACT(',')
}, sub { my $C=shift;
$C->_BRACKETr( sub { my $C=shift;
do {
if (my ($C) = ($C->ws)) {
do {
if (my ($C) = ($C->_SUBSUMEr(['hexint'], sub {
my $C = shift;
$C->hexint
}))) {
$C->ws;
}
else {
();
}
};
}
else {
();
}
}
})
})
);
}

## token hexint
##      token hexint {
##          <[ 0..9 a..f A..F ]>+ [ _ <[ 0..9 a..f A..F ]>+ ]*
##      }

sub hexint__PEEK { $_[0]->_AUTOLEXpeek('hexint',$retree) }
sub hexint {
my $self = shift;
local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;


my $C = $self;
my $S = $C->{'_pos'};

$self->_MATCHIFYr($S, "hexint", 
do {
if (my ($C) = ($C->_PATTERN(qr/\G((?:[0-9a-fA-F])++)/))) {
$C->_STARr(sub { my $C=shift;
$C->_BRACKETr( sub { my $C=shift;
do {
if (my ($C) = ($C->_EXACT('_'))) {
$C->_PATTERN(qr/\G((?:[0-9a-fA-F])++)/);
}
else {
();
}
}
})
});
}
else {
();
}
}
);
}

##########
# Quotes #
##########

our @herestub_queue;

{ package STD::Herestub;
use Moose ':all' => { -prefix => "moose_" };
my $retree;
moose_has 'delim' => (is => 'rw');    moose_has 'orignode' => (is => 'rw');    moose_has 'lang' => (is => 'rw');} ## end class

{ package STD::herestop;
use Moose::Role ':all' => { -prefix => "moose_" };
my $retree;
##     token stopper
##          token stopper { ^^ {*} $<ws>=(\h*?) $*DELIM \h* <.unv>?? $$ \v? }

sub stopper__PEEK { $_[0]->_AUTOLEXpeek('stopper',$retree) }
sub stopper {
my $self = shift;
local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;


my $C = $self;
my $S = $C->{'_pos'};

$self->_MATCHIFY($S, "stopper", 
Cursor::lazymap(sub { my $C=$_[0];
Cursor::lazymap(sub { my $C=$_[0];
Cursor::lazymap(sub { my $C=$_[0];
Cursor::lazymap(sub { my $C=$_[0];
Cursor::lazymap(sub { my $C=$_[0];
Cursor::lazymap(sub { my $C=$_[0];
Cursor::lazymap(sub { my $C=$_[0];
$C->_PATTERN(qr/\G((?:[\n])?+)/)
}, $C->_PATTERN(qr/\G(?m:$)/))
}, $C->_OPTf(sub { my $C=shift;
$C->unv
}))
}, $C->_PATTERN(qr/\G((?:[\x20\t\r])*+)/))
}, $C->_EXACT($::DELIM))
},     $C->_SUBSUME(['ws'], sub {
my $C = shift;
do { $C->_PAREN( sub { my $C=shift;
$C->_STARf(sub { my $C=shift;
$C->_PATTERN(qr/\G[\x20\t\r]/)
})
})}
}))
}, $C->_REDUCE($S, 'stopper'))
}, $C->_PATTERN(qr/\G(?m:^)/))
);
}
BEGIN {
$retree = YAML::Syck::Load(<<'RETREE_END');
--- 
stopper: !!perl/hash:RE 
  decl: []

  kind: token
  min: 0
  pkg: ~
  re: !!perl/hash:RE_sequence 
    a: 0
    dba: stopper
    i: 0
    min: 0
    r: 1
    s: 0
    zyg: 
      - !!perl/hash:RE_meta 
        a: 0
        dba: stopper
        i: 0
        min: 0
        r: 1
        s: 0
        text: "^^"
      - !!perl/hash:RE_method_internal 
        args: $S, 'stopper'
        max: 0
        min: 0
        name: _REDUCE
      - !!perl/hash:RE_bindnamed 
        a: 0
        atom: !!perl/hash:RE_paren 
          decl: []

          min: 0
          nobind: 1
          re: !!perl/hash:RE_quantified_atom 
            atom: !!perl/hash:RE_meta 
              a: 0
              dba: stopper
              i: 0
              min: 1
              r: 1
              s: 0
              text: \h
            min: 0
            quant: 
              - "*"
              - "?"
              - ''
              - 0
        dba: stopper
        i: 0
        min: 0
        r: 1
        s: 0
        var: ws
      - !!perl/hash:RE_var 
        a: 0
        dba: stopper
        i: 0
        min: 0
        r: 1
        s: 0
        var: $*DELIM
      - !!perl/hash:RE_quantified_atom 
        atom: !!perl/hash:RE_meta 
          a: 0
          dba: stopper
          i: 0
          min: 1
          r: 1
          s: 0
          text: \h
        min: 0
        quant: 
          - "*"
          - ":"
          - ''
          - 0
      - !!perl/hash:RE_quantified_atom 
        atom: !!perl/hash:RE_method 
          a: 0
          dba: stopper
          i: 0
          min: 12345
          name: unv
          nobind: 1
          r: 1
          rest: ''
          s: 0
        min: 0
        quant: 
          - "?"
          - "?"
          - ''
          - 0
      - !!perl/hash:RE_meta 
        a: 0
        dba: stopper
        i: 0
        min: 0
        r: 1
        s: 0
        text: $$
      - !!perl/hash:RE_quantified_atom 
        atom: !!perl/hash:RE_meta 
          a: 0
          dba: stopper
          i: 0
          min: 1
          r: 1
          s: 0
          text: \v
        min: 0
        quant: 
          - "?"
          - ":"
          - ''
          - 0
RETREE_END
}
} ## end role

# XXX be sure to temporize @herestub_queue on reentry to new line of heredocs

## method heredoc ()
sub heredoc {
my $self = shift;


local $::CTX = $self->callm if $::DEBUG & DEBUG::trace_call;
return if $self->peek;
my $here = $self;
while (my $herestub = shift @herestub_queue) {
local $::DELIM = $herestub->delim;
my $lang = $herestub->lang->mixin( 'STD::herestop' );
my $doc;
if (($doc) = $here->nibble($lang)) {
$here = $doc->trim_heredoc();
$herestub->orignode->{'doc'} = $doc;
}
else {
$self->panic("Ending delimiter $::DELIM not found");
}
}
return $self->cursor($here->{'_pos'});  # return to initial type
}

#proto token backslash { <...> }
sub backslash__PEEK { $_[0]->_AUTOLEXpeek('backslash:*',$retree); }
sub backslash {
my $self = shift;
my $subs;

local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;

my $C = $self;
my $S = $C->{'_pos'};

my @result = eval {
my $trystate;
my ($tag, $try);
my @try;
my $relex;
if (my $fate = $C->{'_fate'}) {
if ($fate->[1] eq 'backslash') {
$C->deb("Fate passed to backslash: ", ::fatestr($fate)) if $::DEBUG & DEBUG::fates;
($C->{'_fate'}, $tag, $try) = @$fate;
@try = ($try);
}
}

my @gather = ();
for (;;) {
if (not @try) {
$relex //= $C->cursor_fate('STD', 'backslash:*', $retree);
@try = $relex->($C, $trystate);
}
last unless @try;
$try = shift(@try) // next;

if (ref $try eq 'ARRAY') {
($C->{'_fate'}, $tag, $try) = @$try;	# next candidate fate
}

$C->deb("backslash trying $tag $try") if $::DEBUG & DEBUG::try_processing;
push @gather, $C->$try(@_);
last if @gather;
}
$self->_MATCHIFY($S, "backslash", @gather);
};
if ($@) {
return () if $@ =~ /^ABORTRULE/;
die $@;
}
@result;
}

#proto token escape { <...> }
sub escape__PEEK { $_[0]->_AUTOLEXpeek('escape:*',$retree); }
sub escape {
my $self = shift;
my $subs;

local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;

my $C = $self;
my $S = $C->{'_pos'};

my @result = eval {
my $trystate;
my ($tag, $try);
my @try;
my $relex;
if (my $fate = $C->{'_fate'}) {
if ($fate->[1] eq 'escape') {
$C->deb("Fate passed to escape: ", ::fatestr($fate)) if $::DEBUG & DEBUG::fates;
($C->{'_fate'}, $tag, $try) = @$fate;
@try = ($try);
}
}

my @gather = ();
for (;;) {
if (not @try) {
$relex //= $C->cursor_fate('STD', 'escape:*', $retree);
@try = $relex->($C, $trystate);
}
last unless @try;
$try = shift(@try) // next;

if (ref $try eq 'ARRAY') {
($C->{'_fate'}, $tag, $try) = @$try;	# next candidate fate
}

$C->deb("escape trying $tag $try") if $::DEBUG & DEBUG::try_processing;
push @gather, $C->$try(@_);
last if @gather;
}
$self->_MATCHIFY($S, "escape", @gather);
};
if ($@) {
return () if $@ =~ /^ABORTRULE/;
die $@;
}
@result;
}

## token starter
##      token starter { <!> }

sub starter__PEEK { $_[0]->_AUTOLEXpeek('starter',$retree) }
sub starter {
my $self = shift;
local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;


my $C = $self;
my $S = $C->{'_pos'};

$self->_MATCHIFYr($S, "starter", 
$C->_NOTBEFORE( sub { my $C=shift;
$C
})
);
}
## token escape__S_192none (:$sym is context<rw> = 'none')
##      token escape:none { <!> }

sub escape__S_192none__PEEK { $_[0]->_AUTOLEXpeek('escape__S_192none',$retree) }
sub escape__S_192none {
my $self = shift;
local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;
my %args = @_;
local $sym = $args{sym} // 'none';


my $C = $self;
my $S = $C->{'_pos'};
$C->{'sym'} = $sym;

$self->_MATCHIFYr($S, "escape__S_192none", 
$C->_NOTBEFORE( sub { my $C=shift;
$C
})
);
}

## token babble ($l)
##      token babble ($l) {
##          :my $lang = $l;
##          :my $start;
##          :my $stop;
##      
##          <.ws>
##          [ <quotepair> <.ws>
##              {
##                  my $kv = $<quotepair>[*-1];
##                  $lang = $lang.tweak($kv.<k>, $kv.<v>)
##                      or self.panic("Unrecognized adverb :" ~ $kv.<k> ~ '(' ~ $kv.<v> ~ ')');
##              }
##          ]*
##      
##          {
##              ($start,$stop) = $¢.peek_delimiters();
##              $lang = $start ne $stop ?? $lang.balanced($start,$stop)
##                                      !! $lang.unbalanced($stop);
##              $<B> = [$lang,$start,$stop];
##          }
##      }

sub babble__PEEK { $_[0]->_AUTOLEXpeek('babble',$retree) }
sub babble {
my $self = shift;
local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;
my $l = shift;
my $lang = $l;
my $start;
my $stop;


my $C = $self;
my $S = $C->{'_pos'};
$C->{'quotepair'} = [];

$self->_MATCHIFYr($S, "babble", 
do {
if (my ($C) = ($C->ws)) {
do {
if (my ($C) = ($C->_STARr(sub { my $C=shift;
$C->_BRACKETr( sub { my $C=shift;
do {
if (my ($C) = ($C->_SUBSUMEr(['quotepair'], sub {
my $C = shift;
$C->quotepair
}))) {
do {
if (my ($C) = ($C->ws)) {
scalar(do {
my $M = $C; 
my $kv = $M->{'quotepair'}[-1];
$lang = $lang->tweak($kv->{'k'}, $kv->{'v'})
or $self->panic("Unrecognized adverb :" . $kv->{'k'} . '(' . $kv->{'v'} . ')');
;
}, $C);
}
else {
();
}
};
}
else {
();
}
}
})
}))) {
scalar(do {
my $M = $C; 
($start,$stop) = $C->peek_delimiters();
$lang = $start ne $stop ? $lang->balanced($start,$stop)
: $lang->unbalanced($stop);
$M->{'B'} = [$lang,$start,$stop];
;
}, $C);
}
else {
();
}
};
}
else {
();
}
}
);
}

## token quibble ($l)
##      token quibble ($l) {
##          :my ($lang, $start, $stop);
##          <babble($l)>
##          { my $B = $<babble><B>; ($lang,$start,$stop) = @$B; }
##      
##          $start <nibble($lang)> [ $stop || <.panic: "Couldn't find terminator $stop"> ]
##      
##          {{
##              if $lang<_herelang> {
##                  push @herestub_queue,
##                      ::Herestub.new(
##                          delim => $<nibble><nibbles>[0]<TEXT>,
##                          orignode => $¢,
##                          lang => $lang<_herelang>,
##                      );
##              }
##          }}
##      }

sub quibble__PEEK { $_[0]->_AUTOLEXpeek('quibble',$retree) }
sub quibble {
my $self = shift;
local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;
my $l = shift;
my ($lang, $start, $stop);


my $C = $self;
my $S = $C->{'_pos'};

$self->_MATCHIFYr($S, "quibble", 
do {
if (my ($C) = ($C->_SUBSUMEr(['babble'], sub {
my $C = shift;
$C->babble($l)
}))) {
do {
if (my ($C) = (scalar(do {
my $M = $C;  my $B = $M->{'babble'}{'B'}; ($lang,$start,$stop) = @$B; ;
}, $C))) {
do {
if (my ($C) = ($C->_EXACT($start))) {
do {
if (my ($C) = ($C->_SUBSUMEr(['nibble'], sub {
my $C = shift;
$C->nibble($lang)
}))) {
do {
if (my ($C) = ($C->_BRACKETr( sub { my $C=shift;
do { my @gather;
eval { push @gather, $C->_EXACT($stop)} // do {die $@ if $@ and $@ !~ /ABORT/;1} 
or
eval { push @gather, $C->panic("Couldn't find terminator $stop")} or do { die $@ if $@ };
@gather;
}
}))) {
scalar(do {
my $M = $C; 
if ($lang->{'_herelang'}) {
push @herestub_queue,
'STD::Herestub'->new(
delim => $M->{'nibble'}{'nibbles'}[0]{'TEXT'},
orignode => $C,
lang => $lang->{'_herelang'},
);
}
;
}, $C);
}
else {
();
}
};
}
else {
();
}
};
}
else {
();
}
};
}
else {
();
}
};
}
else {
();
}
}
);
}

## token sibble ($l, $lang2)
##      token sibble ($l, $lang2) {
##          :my ($lang, $start, $stop);
##          <babble($l)>
##          { my $B = $<babble><B>; ($lang,$start,$stop) = @$B; }
##      
##          $start <left=nibble($lang)> [ $stop || <.panic: "Couldn't find terminator $stop"> ]
##          [ <?{ $start ne $stop }>
##              <.ws>
##              [ <infixish> || <panic: "Missing assignment operator"> ]
##              [ <?{ $<infixish>.Str eq '=' || $<infixish>.<infix_postfix_meta_operator> }> || <.panic: "Malformed assignment operator"> ]
##              <.ws>
##              <right=EXPR(item %item_assignment)>
##          || 
##              { $lang = $lang2.unbalanced($stop); }
##              <right=nibble($lang)> $stop
##          ]
##      }

sub sibble__PEEK { $_[0]->_AUTOLEXpeek('sibble',$retree) }
sub sibble {
my $self = shift;
local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;
my $l = shift;
my $lang2 = shift;
my ($lang, $start, $stop);


my $C = $self;
my $S = $C->{'_pos'};

$self->_MATCHIFYr($S, "sibble", 
do {
if (my ($C) = ($C->_SUBSUMEr(['babble'], sub {
my $C = shift;
$C->babble($l)
}))) {
do {
if (my ($C) = (scalar(do {
my $M = $C;  my $B = $M->{'babble'}{'B'}; ($lang,$start,$stop) = @$B; ;
}, $C))) {
do {
if (my ($C) = ($C->_EXACT($start))) {
do {
if (my ($C) = (    $C->_SUBSUMEr(['left'], sub {
my $C = shift;
$C->nibble($lang)
}))) {
do {
if (my ($C) = ($C->_BRACKETr( sub { my $C=shift;
do { my @gather;
eval { push @gather, $C->_EXACT($stop)} // do {die $@ if $@ and $@ !~ /ABORT/;1} 
or
eval { push @gather, $C->panic("Couldn't find terminator $stop")} or do { die $@ if $@ };
@gather;
}
}))) {
$C->_BRACKETr( sub { my $C=shift;
do { my @gather;
eval { push @gather, do {
if (my ($C) = ($C->before( sub { my $C=shift;
(($C) x !!do {
$start ne $stop 
})
}))) {
do {
if (my ($C) = ($C->ws)) {
do {
if (my ($C) = ($C->_BRACKETr( sub { my $C=shift;
do { my @gather;
eval { push @gather, $C->_SUBSUMEr(['infixish'], sub {
my $C = shift;
$C->infixish
})} // do {die $@ if $@ and $@ !~ /ABORT/;1} 
or
eval { push @gather, $C->_SUBSUMEr(['panic'], sub {
my $C = shift;
$C->panic("Missing assignment operator")
})} or do { die $@ if $@ };
@gather;
}
}))) {
do {
if (my ($C) = ($C->_BRACKETr( sub { my $C=shift;
do { my @gather;
eval { push @gather, $C->before( sub { my $C=shift;
(($C) x !!do {
my $M = $C;  $M->{'infixish'}->Str eq '=' || $M->{'infixish'}->{'infix_postfix_meta_operator'} ;
})
})} // do {die $@ if $@ and $@ !~ /ABORT/;1} 
or
eval { push @gather, $C->panic("Malformed assignment operator")} or do { die $@ if $@ };
@gather;
}
}))) {
do {
if (my ($C) = ($C->ws)) {
$C->_SUBSUMEr(['right'], sub {
my $C = shift;
$C->EXPR(\%item_assignment)
});
}
else {
();
}
};
}
else {
();
}
};
}
else {
();
}
};
}
else {
();
}
};
}
else {
();
}
}} // do {die $@ if $@ and $@ !~ /ABORT/;1} 
or
eval { push @gather, do {
if (my ($C) = (scalar(do {
$lang = $lang2->unbalanced($stop); 
}, $C))) {
do {
if (my ($C) = (    $C->_SUBSUMEr(['right'], sub {
my $C = shift;
$C->nibble($lang)
}))) {
$C->_EXACT($stop);
}
else {
();
}
};
}
else {
();
}
}} or do { die $@ if $@ };
@gather;
}
});
}
else {
();
}
};
}
else {
();
}
};
}
else {
();
}
};
}
else {
();
}
};
}
else {
();
}
}
);
}

## token tribble ($l, $lang2 = $l)
##      token tribble ($l, $lang2 = $l) {
##          :my ($lang, $start, $stop);
##          <babble($l)>
##          { my $B = $<babble><B>; ($lang,$start,$stop) = @$B; }
##      
##          $start <left=nibble($lang)> [ $stop || <.panic: "Couldn't find terminator $stop"> ]
##          [ <?{ $start ne $stop }>
##              <.ws> <quibble($lang2)>
##          || 
##              { $lang = $lang2.unbalanced($stop); }
##              <right=nibble($lang)> $stop
##          ]
##      }

sub tribble__PEEK { $_[0]->_AUTOLEXpeek('tribble',$retree) }
sub tribble {
my $self = shift;
local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;
my $l = shift;
my $lang2 = shift() // $l;
my ($lang, $start, $stop);


my $C = $self;
my $S = $C->{'_pos'};

$self->_MATCHIFYr($S, "tribble", 
do {
if (my ($C) = ($C->_SUBSUMEr(['babble'], sub {
my $C = shift;
$C->babble($l)
}))) {
do {
if (my ($C) = (scalar(do {
my $M = $C;  my $B = $M->{'babble'}{'B'}; ($lang,$start,$stop) = @$B; ;
}, $C))) {
do {
if (my ($C) = ($C->_EXACT($start))) {
do {
if (my ($C) = (    $C->_SUBSUMEr(['left'], sub {
my $C = shift;
$C->nibble($lang)
}))) {
do {
if (my ($C) = ($C->_BRACKETr( sub { my $C=shift;
do { my @gather;
eval { push @gather, $C->_EXACT($stop)} // do {die $@ if $@ and $@ !~ /ABORT/;1} 
or
eval { push @gather, $C->panic("Couldn't find terminator $stop")} or do { die $@ if $@ };
@gather;
}
}))) {
$C->_BRACKETr( sub { my $C=shift;
do { my @gather;
eval { push @gather, do {
if (my ($C) = ($C->before( sub { my $C=shift;
(($C) x !!do {
$start ne $stop 
})
}))) {
do {
if (my ($C) = ($C->ws)) {
$C->_SUBSUMEr(['quibble'], sub {
my $C = shift;
$C->quibble($lang2)
});
}
else {
();
}
};
}
else {
();
}
}} // do {die $@ if $@ and $@ !~ /ABORT/;1} 
or
eval { push @gather, do {
if (my ($C) = (scalar(do {
$lang = $lang2->unbalanced($stop); 
}, $C))) {
do {
if (my ($C) = (    $C->_SUBSUMEr(['right'], sub {
my $C = shift;
$C->nibble($lang)
}))) {
$C->_EXACT($stop);
}
else {
();
}
};
}
else {
();
}
}} or do { die $@ if $@ };
@gather;
}
});
}
else {
();
}
};
}
else {
();
}
};
}
else {
();
}
};
}
else {
();
}
};
}
else {
();
}
}
);
}

## token quasiquibble ($l)
##      token quasiquibble ($l) {
##          :my ($lang, $start, $stop);
##          :my $QUASIMODO is context = 0; # :COMPILING sets true
##          <babble($l)>
##          { my $B = $<babble><B>; ($lang,$start,$stop) = @$B; }
##      
##          [
##          || <?{ $start eq '{' }> [ :lang($lang) <block> ]
##          || $start [ :lang($lang) <statementlist> ] [$stop || <.panic: "Couldn't find terminator $stop"> ]
##          ]
##      }

sub quasiquibble__PEEK { $_[0]->_AUTOLEXpeek('quasiquibble',$retree) }
sub quasiquibble {
my $self = shift;
local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;
my $l = shift;
my ($lang, $start, $stop);
local $::QUASIMODO = 0;


my $C = $self;
my $S = $C->{'_pos'};

$self->_MATCHIFYr($S, "quasiquibble", 
do {
if (my ($C) = ($C->_SUBSUMEr(['babble'], sub {
my $C = shift;
$C->babble($l)
}))) {
do {
if (my ($C) = (scalar(do {
my $M = $C;  my $B = $M->{'babble'}{'B'}; ($lang,$start,$stop) = @$B; ;
}, $C))) {
$C->_BRACKETr( sub { my $C=shift;
do { my @gather;
eval { push @gather, do {
if (my ($C) = ($C->before( sub { my $C=shift;
(($C) x !!do {
$start eq '{' 
})
}))) {
$C->_BRACKETr( sub { my $C=shift;
my $newlang = ($lang);  $C = $C->cursor_fresh($newlang); ;$C->_SUBSUMEr(['block'], sub {
my $C = shift;
$C->block
})
});
}
else {
();
}
}} // do {die $@ if $@ and $@ !~ /ABORT/;1} 
or
eval { push @gather, do {
if (my ($C) = ($C->_EXACT($start))) {
do {
if (my ($C) = ($C->_BRACKETr( sub { my $C=shift;
my $newlang = ($lang);  $C = $C->cursor_fresh($newlang); ;$C->_SUBSUMEr(['statementlist'], sub {
my $C = shift;
$C->statementlist
})
}))) {
$C->_BRACKETr( sub { my $C=shift;
do { my @gather;
eval { push @gather, $C->_EXACT($stop)} // do {die $@ if $@ and $@ !~ /ABORT/;1} 
or
eval { push @gather, $C->panic("Couldn't find terminator $stop")} or do { die $@ if $@ };
@gather;
}
});
}
else {
();
}
};
}
else {
();
}
}} or do { die $@ if $@ };
@gather;
}
});
}
else {
();
}
};
}
else {
();
}
}
);
}

# note: polymorphic over many quote languages, we hope
## token nibbler
##      token nibbler {
##          :my $text = '';
##          :my $from = self.pos;
##          :my $to = $from;
##          :my @nibbles = ();
##          :my $multiline = 0;
##          :my $nibble;
##          { $<_from> = self.pos; }
##          [ <!before <stopper> >
##              [
##              || <starter> <nibbler> <stopper>
##                              {{
##                                  push @nibbles, $¢.cursor_singleton(TEXT => $text, _from => $from, _pos => $to );
##      
##                                  my $n = $<nibbler>[*-1]<nibbles>;
##                                  my @n = @$n;
##      
##                                  push @nibbles, $<starter>;
##                                  push @nibbles, @n;
##                                  push @nibbles, $<stopper>;
##      
##                                  $text = '';
##                                  $to = $from = $¢.pos;
##                              }}
##              || <escape>     {{
##                                  push @nibbles, $¢.cursor_singleton(TEXT => $text, _from => $from, _pos => $to ), $<escape>[*-1];
##                                  $text = '';
##                                  $to = $from = $¢.pos;
##                              }}
##              || .
##                              {{
##                                  my $ch = substr($*ORIG, $¢.pos-1, 1);
##                                  $text ~= $ch;
##                                  $to = $¢.pos;
##                                  if $ch ~~ "\n" {
##                                      $multiline++;
##                                  }
##                              }}
##              ]
##          ]*
##          {{
##              push @nibbles, $¢.cursor_singleton(TEXT => $text, _from => $from, _pos => $to );
##              $<nibbles> = \@nibbles;
##              $<_pos> = $¢.pos;
##              $<nibbler> :delete;
##              $<escape> :delete;
##              $<starter> :delete;
##              $<stopper> :delete;
##              $*LAST_NIBBLE = $¢;
##              $*LAST_NIBBLE_MULTILINE = $¢ if $multiline;
##          }}
##      }

sub nibbler__PEEK { $_[0]->_AUTOLEXpeek('nibbler',$retree) }
sub nibbler {
my $self = shift;
local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;
my $text = '';
my $from = $self->{'_pos'};
my $to = $from;
my @nibbles = ();
my $multiline = 0;
my $nibble;


my $C = $self;
my $S = $C->{'_pos'};
$C->{'nibbler'} = [];
$C->{'stopper'} = [];
$C->{'starter'} = [];
$C->{'escape'} = [];

$self->_MATCHIFYr($S, "nibbler", 
do {
if (my ($C) = (scalar(do {
my $M = $C;  $M->{'_from'} = $self->{'_pos'}; ;
}, $C))) {
do {
if (my ($C) = ($C->_STARr(sub { my $C=shift;
$C->_BRACKETr( sub { my $C=shift;
do {
if (my ($C) = ($C->_NOTBEFORE( sub { my $C=shift;
$C->before(sub { my $C=shift;
$C->_SUBSUMEr(['stopper'], sub {
my $C = shift;
$C->stopper
})
})
}))) {
$C->_BRACKETr( sub { my $C=shift;
do { my @gather;
eval { push @gather, do {
if (my ($C) = ($C->_SUBSUMEr(['starter'], sub {
my $C = shift;
$C->starter
}))) {
do {
if (my ($C) = ($C->_SUBSUMEr(['nibbler'], sub {
my $C = shift;
$C->nibbler
}))) {
do {
if (my ($C) = ($C->_SUBSUMEr(['stopper'], sub {
my $C = shift;
$C->stopper
}))) {
scalar(do {
my $M = $C; 
push @nibbles, $C->cursor_singleton(TEXT => $text, _from => $from, _pos => $to );

my $n = $M->{'nibbler'}[-1]{'nibbles'};
my @n = @$n;

push @nibbles, $M->{'starter'};
push @nibbles, @n;
push @nibbles, $M->{'stopper'};

$text = '';
$to = $from = $C->{'_pos'};
;
}, $C);
}
else {
();
}
};
}
else {
();
}
};
}
else {
();
}
}} // do {die $@ if $@ and $@ !~ /ABORT/;1} 
or
eval { push @gather, do {
if (my ($C) = ($C->_SUBSUMEr(['escape'], sub {
my $C = shift;
$C->escape
}))) {
scalar(do {
my $M = $C; 
push @nibbles, $C->cursor_singleton(TEXT => $text, _from => $from, _pos => $to ), $M->{'escape'}[-1];
$text = '';
$to = $from = $C->{'_pos'};
;
}, $C);
}
else {
();
}
}} // do {die $@ if $@ and $@ !~ /ABORT/;1} 
or
eval { push @gather, do {
if (my ($C) = ($C->_PATTERN(qr/\G(?s:.)/))) {
scalar(do {

my $ch = substr($::ORIG, $C->{'_pos'}-1, 1);
$text .= $ch;
$to = $C->{'_pos'};
if ($ch =~ "\n") {
$multiline++;
}

}, $C);
}
else {
();
}
}} or do { die $@ if $@ };
@gather;
}
});
}
else {
();
}
}
})
}))) {
scalar(do {
my $M = $C; 
push @nibbles, $C->cursor_singleton(TEXT => $text, _from => $from, _pos => $to );
$M->{'nibbles'} = \@nibbles;
$M->{'_pos'} = $C->{'_pos'};
delete $M->{'nibbler'};
delete $M->{'escape'};
delete $M->{'starter'};
delete $M->{'stopper'};
$::LAST_NIBBLE = $C;
$::LAST_NIBBLE_MULTILINE = $C if $multiline;
;
}, $C);
}
else {
();
}
};
}
else {
();
}
}
);
}

# and this is what makes nibbler polymorphic...
## method nibble ($lang)
sub nibble {
my $self = shift;
my $lang = shift;


$self->cursor_fresh($lang)->nibbler;
}

## token quote__S_193Single_Single (:$sym is context<rw> = <' '>)
##      token quote:sym<' '>   { "'" <nibble($¢.cursor_fresh( %*LANG<Q> ).tweak(:q).unbalanced("'"))> "'" }

sub quote__S_193Single_Single__PEEK { $_[0]->_AUTOLEXpeek('quote__S_193Single_Single',$retree) }
sub quote__S_193Single_Single {
my $self = shift;
local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;
my %args = @_;
local $sym = $args{sym} // [qw(' ')];


my $C = $self;
my $S = $C->{'_pos'};
$C->{'sym'} = $sym;

$self->_MATCHIFYr($S, "quote__S_193Single_Single", 
do {
if (my ($C) = ($C->_PATTERN(qr/\G'/))) {
do {
if (my ($C) = ($C->_SUBSUMEr(['nibble'], sub {
my $C = shift;
$C->nibble($C->cursor_fresh( $::LANG{'Q'} )->tweak('q' => 1)->unbalanced("'"))
}))) {
$C->_PATTERN(qr/\G'/);
}
else {
();
}
};
}
else {
();
}
}
);
}
## token quote__S_194Double_Double (:$sym is context<rw> = <" ">)
##      token quote:sym<" ">   { '"' <nibble($¢.cursor_fresh( %*LANG<Q> ).tweak(:qq).unbalanced('"'))> '"' }

sub quote__S_194Double_Double__PEEK { $_[0]->_AUTOLEXpeek('quote__S_194Double_Double',$retree) }
sub quote__S_194Double_Double {
my $self = shift;
local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;
my %args = @_;
local $sym = $args{sym} // [qw(" ")];


my $C = $self;
my $S = $C->{'_pos'};
$C->{'sym'} = $sym;

$self->_MATCHIFYr($S, "quote__S_194Double_Double", 
do {
if (my ($C) = ($C->_EXACT('"'))) {
do {
if (my ($C) = ($C->_SUBSUMEr(['nibble'], sub {
my $C = shift;
$C->nibble($C->cursor_fresh( $::LANG{'Q'} )->tweak('qq' => 1)->unbalanced('"'))
}))) {
$C->_EXACT('"');
}
else {
();
}
};
}
else {
();
}
}
);
}

## token circumfix__S_195Fre_Nch (:$sym is context<rw> = <« »>)
##      token circumfix:sym<« »>   { '«' <nibble($¢.cursor_fresh( %*LANG<Q> ).tweak(:qq).tweak(:ww).balanced('«','»'))> '»' }

sub circumfix__S_195Fre_Nch__PEEK { $_[0]->_AUTOLEXpeek('circumfix__S_195Fre_Nch',$retree) }
sub circumfix__S_195Fre_Nch {
my $self = shift;
local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;
my %args = @_;
local $sym = $args{sym} // [qw(« »)];


my $C = $self;
my $S = $C->{'_pos'};
$C->{'sym'} = $sym;

$self->_MATCHIFYr($S, "circumfix__S_195Fre_Nch", 
do {
if (my ($C) = ($C->_EXACT('«'))) {
do {
if (my ($C) = ($C->_SUBSUMEr(['nibble'], sub {
my $C = shift;
$C->nibble($C->cursor_fresh( $::LANG{'Q'} )->tweak('qq' => 1)->tweak('ww' => 1)->balanced('«','»'))
}))) {
$C->_EXACT('»');
}
else {
();
}
};
}
else {
();
}
}
);
}
## token circumfix__S_196LtLt_GtGt (:$sym is context<rw> = «<< >>»)
##      token circumfix:sym«<< >>» { '<<' <nibble($¢.cursor_fresh( %*LANG<Q> ).tweak(:qq).tweak(:ww).balanced('<<','>>'))> '>>' }

sub circumfix__S_196LtLt_GtGt__PEEK { $_[0]->_AUTOLEXpeek('circumfix__S_196LtLt_GtGt',$retree) }
sub circumfix__S_196LtLt_GtGt {
my $self = shift;
local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;
my %args = @_;
local $sym = $args{sym} //['<<','>>'];


my $C = $self;
my $S = $C->{'_pos'};
$C->{'sym'} = $sym;

$self->_MATCHIFYr($S, "circumfix__S_196LtLt_GtGt", 
do {
if (my ($C) = ($C->_EXACT('<<'))) {
do {
if (my ($C) = ($C->_SUBSUMEr(['nibble'], sub {
my $C = shift;
$C->nibble($C->cursor_fresh( $::LANG{'Q'} )->tweak('qq' => 1)->tweak('ww' => 1)->balanced('<<','>>'))
}))) {
$C->_EXACT('>>');
}
else {
();
}
};
}
else {
();
}
}
);
}
## token circumfix__S_197Lt_Gt (:$sym is context<rw> = «< >»)
##      token circumfix:sym«< >»   { '<'
##                                    [ <?before 'STDIN>' > <.obs('<STDIN>', '$' ~ '*IN.lines')> ]?  # XXX fake out gimme5
##                                    [ <?before '>' > <.obs('<>', 'lines() or ()')> ]?
##                                    <nibble($¢.cursor_fresh( %*LANG<Q> ).tweak(:q).tweak(:w).balanced('<','>'))> '>' }

sub circumfix__S_197Lt_Gt__PEEK { $_[0]->_AUTOLEXpeek('circumfix__S_197Lt_Gt',$retree) }
sub circumfix__S_197Lt_Gt {
my $self = shift;
local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;
my %args = @_;
local $sym = $args{sym} //['<','>'];


my $C = $self;
my $S = $C->{'_pos'};
$C->{'sym'} = $sym;

$self->_MATCHIFYr($S, "circumfix__S_197Lt_Gt", 
do {
if (my ($C) = ($C->_EXACT('<'))) {
do {
if (my ($C) = ($C->_OPTr(sub { my $C=shift;
$C->_BRACKETr( sub { my $C=shift;
do {
if (my ($C) = ($C->before(sub { my $C=shift;
$C->_EXACT('STDIN>')
}))) {
$C->obs('<STDIN>', '$' . '*IN.lines');
}
else {
();
}
}
})
}))) {
do {
if (my ($C) = ($C->_OPTr(sub { my $C=shift;
$C->_BRACKETr( sub { my $C=shift;
do {
if (my ($C) = ($C->before(sub { my $C=shift;
$C->_EXACT('>')
}))) {
$C->obs('<>', 'lines() or ()');
}
else {
();
}
}
})
}))) {
do {
if (my ($C) = ($C->_SUBSUMEr(['nibble'], sub {
my $C = shift;
$C->nibble($C->cursor_fresh( $::LANG{'Q'} )->tweak('q' => 1)->tweak('w' => 1)->balanced('<','>'))
}))) {
$C->_EXACT('>');
}
else {
();
}
};
}
else {
();
}
};
}
else {
();
}
};
}
else {
();
}
}
);
}

## token quote__S_198SlashSlash (:$sym is context<rw> = <//>)
##      token quote:sym<//>   {
##          '/'\s*'/' <.panic: "Null regex not allowed">
##      }

sub quote__S_198SlashSlash__PEEK { $_[0]->_AUTOLEXpeek('quote__S_198SlashSlash',$retree) }
sub quote__S_198SlashSlash {
my $self = shift;
local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;
my %args = @_;
local $sym = $args{sym} // q(//);


my $C = $self;
my $S = $C->{'_pos'};
$C->{'sym'} = $sym;

$self->_MATCHIFYr($S, "quote__S_198SlashSlash", 
do {
if (my ($C) = ($C->_EXACT('/'))) {
do {
if (my ($C) = ($C->_PATTERN(qr/\G((?:\s)*+)/))) {
do {
if (my ($C) = ($C->_EXACT('/'))) {
$C->panic("Null regex not allowed");
}
else {
();
}
};
}
else {
();
}
};
}
else {
();
}
}
);
}

## token quote__S_199Slash_Slash (:$sym is context<rw> = </ />)
##      token quote:sym</ />   {
##          '/' <nibble( $¢.cursor_fresh( %*LANG<Regex> ).unbalanced("/") )> [ '/' || <.panic: "Unable to parse regex; couldn't find final '/'"> ]
##          <.old_rx_mods>?
##      }

sub quote__S_199Slash_Slash__PEEK { $_[0]->_AUTOLEXpeek('quote__S_199Slash_Slash',$retree) }
sub quote__S_199Slash_Slash {
my $self = shift;
local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;
my %args = @_;
local $sym = $args{sym} // [qw(/ /)];


my $C = $self;
my $S = $C->{'_pos'};
$C->{'sym'} = $sym;

$self->_MATCHIFYr($S, "quote__S_199Slash_Slash", 
do {
if (my ($C) = ($C->_EXACT('/'))) {
do {
if (my ($C) = ($C->_SUBSUMEr(['nibble'], sub {
my $C = shift;
$C->nibble( $C->cursor_fresh( $::LANG{'Regex'} )->unbalanced("/") )
}))) {
do {
if (my ($C) = ($C->_BRACKETr( sub { my $C=shift;
do { my @gather;
eval { push @gather, $C->_EXACT('/')} // do {die $@ if $@ and $@ !~ /ABORT/;1} 
or
eval { push @gather, $C->panic("Unable to parse regex; couldn't find final '/'")} or do { die $@ if $@ };
@gather;
}
}))) {
$C->_OPTr(sub { my $C=shift;
$C->old_rx_mods
});
}
else {
();
}
};
}
else {
();
}
};
}
else {
();
}
}
);
}

# handle composite forms like qww
## token quote__S_200qq (:$sym is context<rw> = 'qq')
##      token quote:qq {
##          :my $qm;
##          'qq'
##          [
##          | <quote_mod> » <!before '('> { $qm = $<quote_mod>.Str } <.ws> <quibble($¢.cursor_fresh( %*LANG<Q> ).tweak(:qq).tweak($qm => 1))>
##          | » <!before '('> <.ws> <quibble($¢.cursor_fresh( %*LANG<Q> ).tweak(:qq))>
##          ]
##      }

sub quote__S_200qq__PEEK { $_[0]->_AUTOLEXpeek('quote__S_200qq',$retree) }
sub quote__S_200qq {
my $self = shift;
local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;
my %args = @_;
local $sym = $args{sym} // 'qq';
my $qm;


my $C = $self;
my $S = $C->{'_pos'};
$C->{'sym'} = $sym;

$self->_MATCHIFYr($S, "quote__S_200qq", 
do {
if (my ($C) = ($C->_EXACT('qq'))) {
$C->_BRACKETr( sub { my $C=shift;
do {
my @result = eval {
my $trystate;
my ($tag, $try);
my @try;
my $relex;

my $fate;
if ($fate = $C->{'_fate'} and $fate->[1] eq 'quote__S_200qq_01') {
$C->deb("Fate passed to quote__S_200qq_01: ", ::fatestr($fate)) if $::DEBUG & DEBUG::fates;
($C->{'_fate'}, $tag, $try) = @$fate;
@try = ($try);
}

my @gather = ();
for (;;) {
if (not @try) {
$relex //= $C->cursor_fate('STD', 'quote__S_200qq_01', $retree);
@try = $relex->($C, $trystate);
}
last unless @try;
$try = shift(@try) // next;

if (ref $try eq 'ARRAY') {
($C->{'_fate'}, $tag, $try) = @$try;	# next candidate fate
}

$C->deb("quote__S_200qq_01 trying $tag $try") if $::DEBUG & DEBUG::try_processing;
push @gather, ((
sub { my $C=shift;
do {
if (my ($C) = ($C->_SUBSUMEr(['quote_mod'], sub {
my $C = shift;
$C->quote_mod
}))) {
do {
if (my ($C) = ($C->_PATTERN(qr/\G\b/))) {
do {
if (my ($C) = ($C->_NOTBEFORE( sub { my $C=shift;
$C->before(sub { my $C=shift;
$C->_EXACT('(')
})
}))) {
do {
if (my ($C) = (scalar(do {
my $M = $C;  $qm = $M->{'quote_mod'}->Str ;
}, $C))) {
do {
if (my ($C) = ($C->ws)) {
$C->_SUBSUMEr(['quibble'], sub {
my $C = shift;
$C->quibble($C->cursor_fresh( $::LANG{'Q'} )->tweak('qq' => 1)->tweak($qm => 1))
});
}
else {
();
}
};
}
else {
();
}
};
}
else {
();
}
};
}
else {
();
}
};
}
else {
();
}
}
},
sub { my $C=shift;
do {
if (my ($C) = ($C->_PATTERN(qr/\G\b/))) {
do {
if (my ($C) = ($C->_NOTBEFORE( sub { my $C=shift;
$C->before(sub { my $C=shift;
$C->_EXACT('(')
})
}))) {
do {
if (my ($C) = ($C->ws)) {
$C->_SUBSUMEr(['quibble'], sub {
my $C = shift;
$C->quibble($C->cursor_fresh( $::LANG{'Q'} )->tweak('qq' => 1))
});
}
else {
();
}
};
}
else {
();
}
};
}
else {
();
}
}
},
)[$try])->($C);
last if @gather;
}
@gather;
};
if (@result) {
@result;
}
elsif ($@) {
my ($first) = $@ =~ /(^.*)/;
$self->deb("CAUGHT $first") if $::DEBUG & DEBUG::trace_call;
die $@ if $@ !~ /^ABORTBRANCH/;
();
}
else {
();
}
}

});
}
else {
();
}
}
);
}
## token quote__S_201q (:$sym is context<rw> = 'q')
##      token quote:q {
##          :my $qm;
##          'q'
##          [
##          | <quote_mod> » <!before '('> { $qm = $<quote_mod>.Str } <quibble($¢.cursor_fresh( %*LANG<Q> ).tweak(:q).tweak($qm => 1))>
##          | » <!before '('> <.ws> <quibble($¢.cursor_fresh( %*LANG<Q> ).tweak(:q))>
##          ]
##      }

sub quote__S_201q__PEEK { $_[0]->_AUTOLEXpeek('quote__S_201q',$retree) }
sub quote__S_201q {
my $self = shift;
local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;
my %args = @_;
local $sym = $args{sym} // 'q';
my $qm;


my $C = $self;
my $S = $C->{'_pos'};
$C->{'sym'} = $sym;

$self->_MATCHIFYr($S, "quote__S_201q", 
do {
if (my ($C) = ($C->_EXACT('q'))) {
$C->_BRACKETr( sub { my $C=shift;
do {
my @result = eval {
my $trystate;
my ($tag, $try);
my @try;
my $relex;

my $fate;
if ($fate = $C->{'_fate'} and $fate->[1] eq 'quote__S_201q_01') {
$C->deb("Fate passed to quote__S_201q_01: ", ::fatestr($fate)) if $::DEBUG & DEBUG::fates;
($C->{'_fate'}, $tag, $try) = @$fate;
@try = ($try);
}

my @gather = ();
for (;;) {
if (not @try) {
$relex //= $C->cursor_fate('STD', 'quote__S_201q_01', $retree);
@try = $relex->($C, $trystate);
}
last unless @try;
$try = shift(@try) // next;

if (ref $try eq 'ARRAY') {
($C->{'_fate'}, $tag, $try) = @$try;	# next candidate fate
}

$C->deb("quote__S_201q_01 trying $tag $try") if $::DEBUG & DEBUG::try_processing;
push @gather, ((
sub { my $C=shift;
do {
if (my ($C) = ($C->_SUBSUMEr(['quote_mod'], sub {
my $C = shift;
$C->quote_mod
}))) {
do {
if (my ($C) = ($C->_PATTERN(qr/\G\b/))) {
do {
if (my ($C) = ($C->_NOTBEFORE( sub { my $C=shift;
$C->before(sub { my $C=shift;
$C->_EXACT('(')
})
}))) {
do {
if (my ($C) = (scalar(do {
my $M = $C;  $qm = $M->{'quote_mod'}->Str ;
}, $C))) {
$C->_SUBSUMEr(['quibble'], sub {
my $C = shift;
$C->quibble($C->cursor_fresh( $::LANG{'Q'} )->tweak('q' => 1)->tweak($qm => 1))
});
}
else {
();
}
};
}
else {
();
}
};
}
else {
();
}
};
}
else {
();
}
}
},
sub { my $C=shift;
do {
if (my ($C) = ($C->_PATTERN(qr/\G\b/))) {
do {
if (my ($C) = ($C->_NOTBEFORE( sub { my $C=shift;
$C->before(sub { my $C=shift;
$C->_EXACT('(')
})
}))) {
do {
if (my ($C) = ($C->ws)) {
$C->_SUBSUMEr(['quibble'], sub {
my $C = shift;
$C->quibble($C->cursor_fresh( $::LANG{'Q'} )->tweak('q' => 1))
});
}
else {
();
}
};
}
else {
();
}
};
}
else {
();
}
}
},
)[$try])->($C);
last if @gather;
}
@gather;
};
if (@result) {
@result;
}
elsif ($@) {
my ($first) = $@ =~ /(^.*)/;
$self->deb("CAUGHT $first") if $::DEBUG & DEBUG::trace_call;
die $@ if $@ !~ /^ABORTBRANCH/;
();
}
else {
();
}
}

});
}
else {
();
}
}
);
}

## token quote__S_202Q (:$sym is context<rw> = 'Q')
##      token quote:Q {
##          :my $qm;
##          'Q'
##          [
##          | <quote_mod> » <!before '('> { $qm = $<quote_mod>.Str } <quibble($¢.cursor_fresh( %*LANG<Q> ).tweak($qm => 1))>
##          | » <!before '('> <.ws> <quibble($¢.cursor_fresh( %*LANG<Q> ))>
##          ]
##      }

sub quote__S_202Q__PEEK { $_[0]->_AUTOLEXpeek('quote__S_202Q',$retree) }
sub quote__S_202Q {
my $self = shift;
local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;
my %args = @_;
local $sym = $args{sym} // 'Q';
my $qm;


my $C = $self;
my $S = $C->{'_pos'};
$C->{'sym'} = $sym;

$self->_MATCHIFYr($S, "quote__S_202Q", 
do {
if (my ($C) = ($C->_EXACT('Q'))) {
$C->_BRACKETr( sub { my $C=shift;
do {
my @result = eval {
my $trystate;
my ($tag, $try);
my @try;
my $relex;

my $fate;
if ($fate = $C->{'_fate'} and $fate->[1] eq 'quote__S_202Q_01') {
$C->deb("Fate passed to quote__S_202Q_01: ", ::fatestr($fate)) if $::DEBUG & DEBUG::fates;
($C->{'_fate'}, $tag, $try) = @$fate;
@try = ($try);
}

my @gather = ();
for (;;) {
if (not @try) {
$relex //= $C->cursor_fate('STD', 'quote__S_202Q_01', $retree);
@try = $relex->($C, $trystate);
}
last unless @try;
$try = shift(@try) // next;

if (ref $try eq 'ARRAY') {
($C->{'_fate'}, $tag, $try) = @$try;	# next candidate fate
}

$C->deb("quote__S_202Q_01 trying $tag $try") if $::DEBUG & DEBUG::try_processing;
push @gather, ((
sub { my $C=shift;
do {
if (my ($C) = ($C->_SUBSUMEr(['quote_mod'], sub {
my $C = shift;
$C->quote_mod
}))) {
do {
if (my ($C) = ($C->_PATTERN(qr/\G\b/))) {
do {
if (my ($C) = ($C->_NOTBEFORE( sub { my $C=shift;
$C->before(sub { my $C=shift;
$C->_EXACT('(')
})
}))) {
do {
if (my ($C) = (scalar(do {
my $M = $C;  $qm = $M->{'quote_mod'}->Str ;
}, $C))) {
$C->_SUBSUMEr(['quibble'], sub {
my $C = shift;
$C->quibble($C->cursor_fresh( $::LANG{'Q'} )->tweak($qm => 1))
});
}
else {
();
}
};
}
else {
();
}
};
}
else {
();
}
};
}
else {
();
}
}
},
sub { my $C=shift;
do {
if (my ($C) = ($C->_PATTERN(qr/\G\b/))) {
do {
if (my ($C) = ($C->_NOTBEFORE( sub { my $C=shift;
$C->before(sub { my $C=shift;
$C->_EXACT('(')
})
}))) {
do {
if (my ($C) = ($C->ws)) {
$C->_SUBSUMEr(['quibble'], sub {
my $C = shift;
$C->quibble($C->cursor_fresh( $::LANG{'Q'} ))
});
}
else {
();
}
};
}
else {
();
}
};
}
else {
();
}
}
},
)[$try])->($C);
last if @gather;
}
@gather;
};
if (@result) {
@result;
}
elsif ($@) {
my ($first) = $@ =~ /(^.*)/;
$self->deb("CAUGHT $first") if $::DEBUG & DEBUG::trace_call;
die $@ if $@ !~ /^ABORTBRANCH/;
();
}
else {
();
}
}

});
}
else {
();
}
}
);
}

## token quote_mod__S_203w (:$sym is context<rw> = 'w')
##      token quote_mod:w  { <sym> }

sub quote_mod__S_203w__PEEK { $_[0]->_AUTOLEXpeek('quote_mod__S_203w',$retree) }
sub quote_mod__S_203w {
my $self = shift;
local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;
my %args = @_;
local $sym = $args{sym} // 'w';


my $C = $self;
my $S = $C->{'_pos'};
$C->{'sym'} = $sym;

$self->_MATCHIFYr($S, "quote_mod__S_203w", 
$C->_PATTERN(qr/\Gw/)
);
}
## token quote_mod__S_204ww (:$sym is context<rw> = 'ww')
##      token quote_mod:ww { <sym> }

sub quote_mod__S_204ww__PEEK { $_[0]->_AUTOLEXpeek('quote_mod__S_204ww',$retree) }
sub quote_mod__S_204ww {
my $self = shift;
local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;
my %args = @_;
local $sym = $args{sym} // 'ww';


my $C = $self;
my $S = $C->{'_pos'};
$C->{'sym'} = $sym;

$self->_MATCHIFYr($S, "quote_mod__S_204ww", 
$C->_PATTERN(qr/\Gww/)
);
}
## token quote_mod__S_205x (:$sym is context<rw> = 'x')
##      token quote_mod:x  { <sym> }

sub quote_mod__S_205x__PEEK { $_[0]->_AUTOLEXpeek('quote_mod__S_205x',$retree) }
sub quote_mod__S_205x {
my $self = shift;
local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;
my %args = @_;
local $sym = $args{sym} // 'x';


my $C = $self;
my $S = $C->{'_pos'};
$C->{'sym'} = $sym;

$self->_MATCHIFYr($S, "quote_mod__S_205x", 
$C->_PATTERN(qr/\Gx/)
);
}
## token quote_mod__S_206to (:$sym is context<rw> = 'to')
##      token quote_mod:to { <sym> }

sub quote_mod__S_206to__PEEK { $_[0]->_AUTOLEXpeek('quote_mod__S_206to',$retree) }
sub quote_mod__S_206to {
my $self = shift;
local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;
my %args = @_;
local $sym = $args{sym} // 'to';


my $C = $self;
my $S = $C->{'_pos'};
$C->{'sym'} = $sym;

$self->_MATCHIFYr($S, "quote_mod__S_206to", 
$C->_PATTERN(qr/\Gto/)
);
}
## token quote_mod__S_207s (:$sym is context<rw> = 's')
##      token quote_mod:s  { <sym> }

sub quote_mod__S_207s__PEEK { $_[0]->_AUTOLEXpeek('quote_mod__S_207s',$retree) }
sub quote_mod__S_207s {
my $self = shift;
local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;
my %args = @_;
local $sym = $args{sym} // 's';


my $C = $self;
my $S = $C->{'_pos'};
$C->{'sym'} = $sym;

$self->_MATCHIFYr($S, "quote_mod__S_207s", 
$C->_PATTERN(qr/\Gs/)
);
}
## token quote_mod__S_208a (:$sym is context<rw> = 'a')
##      token quote_mod:a  { <sym> }

sub quote_mod__S_208a__PEEK { $_[0]->_AUTOLEXpeek('quote_mod__S_208a',$retree) }
sub quote_mod__S_208a {
my $self = shift;
local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;
my %args = @_;
local $sym = $args{sym} // 'a';


my $C = $self;
my $S = $C->{'_pos'};
$C->{'sym'} = $sym;

$self->_MATCHIFYr($S, "quote_mod__S_208a", 
$C->_PATTERN(qr/\Ga/)
);
}
## token quote_mod__S_209h (:$sym is context<rw> = 'h')
##      token quote_mod:h  { <sym> }

sub quote_mod__S_209h__PEEK { $_[0]->_AUTOLEXpeek('quote_mod__S_209h',$retree) }
sub quote_mod__S_209h {
my $self = shift;
local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;
my %args = @_;
local $sym = $args{sym} // 'h';


my $C = $self;
my $S = $C->{'_pos'};
$C->{'sym'} = $sym;

$self->_MATCHIFYr($S, "quote_mod__S_209h", 
$C->_PATTERN(qr/\Gh/)
);
}
## token quote_mod__S_210f (:$sym is context<rw> = 'f')
##      token quote_mod:f  { <sym> }

sub quote_mod__S_210f__PEEK { $_[0]->_AUTOLEXpeek('quote_mod__S_210f',$retree) }
sub quote_mod__S_210f {
my $self = shift;
local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;
my %args = @_;
local $sym = $args{sym} // 'f';


my $C = $self;
my $S = $C->{'_pos'};
$C->{'sym'} = $sym;

$self->_MATCHIFYr($S, "quote_mod__S_210f", 
$C->_PATTERN(qr/\Gf/)
);
}
## token quote_mod__S_211c (:$sym is context<rw> = 'c')
##      token quote_mod:c  { <sym> }

sub quote_mod__S_211c__PEEK { $_[0]->_AUTOLEXpeek('quote_mod__S_211c',$retree) }
sub quote_mod__S_211c {
my $self = shift;
local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;
my %args = @_;
local $sym = $args{sym} // 'c';


my $C = $self;
my $S = $C->{'_pos'};
$C->{'sym'} = $sym;

$self->_MATCHIFYr($S, "quote_mod__S_211c", 
$C->_PATTERN(qr/\Gc/)
);
}
## token quote_mod__S_212b (:$sym is context<rw> = 'b')
##      token quote_mod:b  { <sym> }

sub quote_mod__S_212b__PEEK { $_[0]->_AUTOLEXpeek('quote_mod__S_212b',$retree) }
sub quote_mod__S_212b {
my $self = shift;
local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;
my %args = @_;
local $sym = $args{sym} // 'b';


my $C = $self;
my $S = $C->{'_pos'};
$C->{'sym'} = $sym;

$self->_MATCHIFYr($S, "quote_mod__S_212b", 
$C->_PATTERN(qr/\Gb/)
);
}

## token quote__S_213rx (:$sym is context<rw> = 'rx')
##      token quote:rx {
##          <sym> » <!before '('>
##          <quibble( $¢.cursor_fresh( %*LANG<Regex> ) )>
##          <!old_rx_mods>
##      }

sub quote__S_213rx__PEEK { $_[0]->_AUTOLEXpeek('quote__S_213rx',$retree) }
sub quote__S_213rx {
my $self = shift;
local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;
my %args = @_;
local $sym = $args{sym} // 'rx';


my $C = $self;
my $S = $C->{'_pos'};
$C->{'sym'} = $sym;

$self->_MATCHIFYr($S, "quote__S_213rx", 
do {
if (my ($C) = ($C->_PATTERN(qr/\Grx/))) {
do {
if (my ($C) = ($C->_PATTERN(qr/\G\b/))) {
do {
if (my ($C) = ($C->_NOTBEFORE( sub { my $C=shift;
$C->before(sub { my $C=shift;
$C->_EXACT('(')
})
}))) {
do {
if (my ($C) = ($C->_SUBSUMEr(['quibble'], sub {
my $C = shift;
$C->quibble( $C->cursor_fresh( $::LANG{'Regex'} ) )
}))) {
$C->_NOTBEFORE( sub { my $C=shift;
$C->old_rx_mods
});
}
else {
();
}
};
}
else {
();
}
};
}
else {
();
}
};
}
else {
();
}
}
);
}

## token quote__S_214m (:$sym is context<rw> = 'm')
##      token quote:m  {
##          <sym> » <!before '('>
##          <quibble( $¢.cursor_fresh( %*LANG<Regex> ) )>
##          <!old_rx_mods>
##      }

sub quote__S_214m__PEEK { $_[0]->_AUTOLEXpeek('quote__S_214m',$retree) }
sub quote__S_214m {
my $self = shift;
local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;
my %args = @_;
local $sym = $args{sym} // 'm';


my $C = $self;
my $S = $C->{'_pos'};
$C->{'sym'} = $sym;

$self->_MATCHIFYr($S, "quote__S_214m", 
do {
if (my ($C) = ($C->_PATTERN(qr/\Gm/))) {
do {
if (my ($C) = ($C->_PATTERN(qr/\G\b/))) {
do {
if (my ($C) = ($C->_NOTBEFORE( sub { my $C=shift;
$C->before(sub { my $C=shift;
$C->_EXACT('(')
})
}))) {
do {
if (my ($C) = ($C->_SUBSUMEr(['quibble'], sub {
my $C = shift;
$C->quibble( $C->cursor_fresh( $::LANG{'Regex'} ) )
}))) {
$C->_NOTBEFORE( sub { my $C=shift;
$C->old_rx_mods
});
}
else {
();
}
};
}
else {
();
}
};
}
else {
();
}
};
}
else {
();
}
}
);
}

## token quote__S_215mm (:$sym is context<rw> = 'mm')
##      token quote:mm {
##          <sym> » <!before '('>
##          <quibble( $¢.cursor_fresh( %*LANG<Regex> ).tweak(:s))>
##          <!old_rx_mods>
##      }

sub quote__S_215mm__PEEK { $_[0]->_AUTOLEXpeek('quote__S_215mm',$retree) }
sub quote__S_215mm {
my $self = shift;
local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;
my %args = @_;
local $sym = $args{sym} // 'mm';


my $C = $self;
my $S = $C->{'_pos'};
$C->{'sym'} = $sym;

$self->_MATCHIFYr($S, "quote__S_215mm", 
do {
if (my ($C) = ($C->_PATTERN(qr/\Gmm/))) {
do {
if (my ($C) = ($C->_PATTERN(qr/\G\b/))) {
do {
if (my ($C) = ($C->_NOTBEFORE( sub { my $C=shift;
$C->before(sub { my $C=shift;
$C->_EXACT('(')
})
}))) {
do {
if (my ($C) = ($C->_SUBSUMEr(['quibble'], sub {
my $C = shift;
$C->quibble( $C->cursor_fresh( $::LANG{'Regex'} )->tweak('s' => 1))
}))) {
$C->_NOTBEFORE( sub { my $C=shift;
$C->old_rx_mods
});
}
else {
();
}
};
}
else {
();
}
};
}
else {
();
}
};
}
else {
();
}
}
);
}

## token quote__S_216s (:$sym is context<rw> = 's')
##      token quote:s {
##          <sym> » <!before '('>
##          <pat=sibble( $¢.cursor_fresh( %*LANG<Regex> ), $¢.cursor_fresh( %*LANG<Q> ).tweak(:qq))>
##          <!old_rx_mods>
##      }

sub quote__S_216s__PEEK { $_[0]->_AUTOLEXpeek('quote__S_216s',$retree) }
sub quote__S_216s {
my $self = shift;
local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;
my %args = @_;
local $sym = $args{sym} // 's';


my $C = $self;
my $S = $C->{'_pos'};
$C->{'sym'} = $sym;

$self->_MATCHIFYr($S, "quote__S_216s", 
do {
if (my ($C) = ($C->_PATTERN(qr/\Gs/))) {
do {
if (my ($C) = ($C->_PATTERN(qr/\G\b/))) {
do {
if (my ($C) = ($C->_NOTBEFORE( sub { my $C=shift;
$C->before(sub { my $C=shift;
$C->_EXACT('(')
})
}))) {
do {
if (my ($C) = (    $C->_SUBSUMEr(['pat'], sub {
my $C = shift;
$C->sibble( $C->cursor_fresh( $::LANG{'Regex'} ), $C->cursor_fresh( $::LANG{'Q'} )->tweak('qq' => 1))
}))) {
$C->_NOTBEFORE( sub { my $C=shift;
$C->old_rx_mods
});
}
else {
();
}
};
}
else {
();
}
};
}
else {
();
}
};
}
else {
();
}
}
);
}

## token quote__S_217ss (:$sym is context<rw> = 'ss')
##      token quote:ss {
##          <sym> » <!before '('>
##          <pat=sibble( $¢.cursor_fresh( %*LANG<Regex> ).tweak(:s), $¢.cursor_fresh( %*LANG<Q> ).tweak(:qq))>
##          <!old_rx_mods>
##      }

sub quote__S_217ss__PEEK { $_[0]->_AUTOLEXpeek('quote__S_217ss',$retree) }
sub quote__S_217ss {
my $self = shift;
local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;
my %args = @_;
local $sym = $args{sym} // 'ss';


my $C = $self;
my $S = $C->{'_pos'};
$C->{'sym'} = $sym;

$self->_MATCHIFYr($S, "quote__S_217ss", 
do {
if (my ($C) = ($C->_PATTERN(qr/\Gss/))) {
do {
if (my ($C) = ($C->_PATTERN(qr/\G\b/))) {
do {
if (my ($C) = ($C->_NOTBEFORE( sub { my $C=shift;
$C->before(sub { my $C=shift;
$C->_EXACT('(')
})
}))) {
do {
if (my ($C) = (    $C->_SUBSUMEr(['pat'], sub {
my $C = shift;
$C->sibble( $C->cursor_fresh( $::LANG{'Regex'} )->tweak('s' => 1), $C->cursor_fresh( $::LANG{'Q'} )->tweak('qq' => 1))
}))) {
$C->_NOTBEFORE( sub { my $C=shift;
$C->old_rx_mods
});
}
else {
();
}
};
}
else {
();
}
};
}
else {
();
}
};
}
else {
();
}
}
);
}
## token quote__S_218tr (:$sym is context<rw> = 'tr')
##      token quote:tr {
##          <sym> » <!before '('> <pat=tribble( $¢.cursor_fresh( %*LANG<Q> ).tweak(:q))>
##          <!old_tr_mods>
##      }

sub quote__S_218tr__PEEK { $_[0]->_AUTOLEXpeek('quote__S_218tr',$retree) }
sub quote__S_218tr {
my $self = shift;
local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;
my %args = @_;
local $sym = $args{sym} // 'tr';


my $C = $self;
my $S = $C->{'_pos'};
$C->{'sym'} = $sym;

$self->_MATCHIFYr($S, "quote__S_218tr", 
do {
if (my ($C) = ($C->_PATTERN(qr/\Gtr/))) {
do {
if (my ($C) = ($C->_PATTERN(qr/\G\b/))) {
do {
if (my ($C) = ($C->_NOTBEFORE( sub { my $C=shift;
$C->before(sub { my $C=shift;
$C->_EXACT('(')
})
}))) {
do {
if (my ($C) = (    $C->_SUBSUMEr(['pat'], sub {
my $C = shift;
$C->tribble( $C->cursor_fresh( $::LANG{'Q'} )->tweak('q' => 1))
}))) {
$C->_NOTBEFORE( sub { my $C=shift;
$C->old_tr_mods
});
}
else {
();
}
};
}
else {
();
}
};
}
else {
();
}
};
}
else {
();
}
}
);
}

## token old_rx_mods
##      token old_rx_mods {
##          <!after \s>
##          (< i g s m x c e >+) 
##          {{
##              given $0.Str {
##                  $_ ~~ /i/ and $¢.worryobs('/i',':i');
##                  $_ ~~ /g/ and $¢.worryobs('/g',':g');
##                  $_ ~~ /s/ and $¢.worryobs('/s','^^ and $$ anchors');
##                  $_ ~~ /m/ and $¢.worryobs('/m','. or \N');
##                  $_ ~~ /x/ and $¢.worryobs('/x','normal default whitespace');
##                  $_ ~~ /c/ and $¢.worryobs('/c',':c or :p');
##                  $_ ~~ /e/ and $¢.worryobs('/e','interpolated {...} or s{} = ... form');
##                  $¢.obs('suffix regex modifiers','prefix adverbs');
##              }
##          }}
##      }

sub old_rx_mods__PEEK { $_[0]->_AUTOLEXpeek('old_rx_mods',$retree) }
sub old_rx_mods {
my $self = shift;
local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;


my $C = $self;
my $S = $C->{'_pos'};

$self->_MATCHIFYr($S, "old_rx_mods", 
do {
if (my ($C) = ($C->_NOTBEFORE( sub { my $C=shift;
$C->after(sub { my $C=shift;
$C->_PATTERN(qr/\G(?<=\s)/)
})
}))) {
do {
if (my ($C) = (    $C->_SUBSUMEr(['0'], sub {
my $C = shift;
do { $C->_PAREN( sub { my $C=shift;
$C->_PLUSr(sub { my $C=shift;
$C->_ARRAY( qw< i g s m x c e > )
})
})}
}))) {
scalar(do {

given ($C->{'0'}->Str) {
$_ =~ qr/i/ and $C->worryobs('/i',':i');
$_ =~ qr/g/ and $C->worryobs('/g',':g');
$_ =~ qr/s/ and $C->worryobs('/s','^^ and $$ anchors');
$_ =~ qr/m/ and $C->worryobs('/m','. or \N');
$_ =~ qr/x/ and $C->worryobs('/x','normal default whitespace');
$_ =~ qr/c/ and $C->worryobs('/c',':c or :p');
$_ =~ qr/e/ and $C->worryobs('/e','interpolated {...} or s{} = ... form');
$C->obs('suffix regex modifiers','prefix adverbs');
};

}, $C);
}
else {
();
}
};
}
else {
();
}
}
);
}

## token old_tr_mods
##      token old_tr_mods {
##          (< c d s ] >+) 
##          {{
##              given $0.Str {
##                  $_ ~~ /c/ and $¢.worryobs('/c',':c');
##                  $_ ~~ /d/ and $¢.worryobs('/g',':d');
##                  $_ ~~ /s/ and $¢.worryobs('/s',':s');
##                  $¢.obs('suffix transliteration modifiers','prefix adverbs');
##              }
##          }}
##      }

sub old_tr_mods__PEEK { $_[0]->_AUTOLEXpeek('old_tr_mods',$retree) }
sub old_tr_mods {
my $self = shift;
local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;


my $C = $self;
my $S = $C->{'_pos'};

$self->_MATCHIFYr($S, "old_tr_mods", 
do {
if (my ($C) = (    $C->_SUBSUMEr(['0'], sub {
my $C = shift;
do { $C->_PAREN( sub { my $C=shift;
$C->_PLUSr(sub { my $C=shift;
$C->_ARRAY( qw< c d s ] > )
})
})}
}))) {
scalar(do {

given ($C->{'0'}->Str) {
$_ =~ qr/c/ and $C->worryobs('/c',':c');
$_ =~ qr/d/ and $C->worryobs('/g',':d');
$_ =~ qr/s/ and $C->worryobs('/s',':s');
$C->obs('suffix transliteration modifiers','prefix adverbs');
};

}, $C);
}
else {
();
}
}
);
}

## token quote__S_219quasi (:$sym is context<rw> = 'quasi')
##      token quote:quasi {
##          <sym> » <!before '('> <quasiquibble($¢.cursor_fresh( %*LANG<Quasi> ))>
##      }

sub quote__S_219quasi__PEEK { $_[0]->_AUTOLEXpeek('quote__S_219quasi',$retree) }
sub quote__S_219quasi {
my $self = shift;
local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;
my %args = @_;
local $sym = $args{sym} // 'quasi';


my $C = $self;
my $S = $C->{'_pos'};
$C->{'sym'} = $sym;

$self->_MATCHIFYr($S, "quote__S_219quasi", 
do {
if (my ($C) = ($C->_PATTERN(qr/\Gquasi/))) {
do {
if (my ($C) = ($C->_PATTERN(qr/\G\b/))) {
do {
if (my ($C) = ($C->_NOTBEFORE( sub { my $C=shift;
$C->before(sub { my $C=shift;
$C->_EXACT('(')
})
}))) {
$C->_SUBSUMEr(['quasiquibble'], sub {
my $C = shift;
$C->quasiquibble($C->cursor_fresh( $::LANG{'Quasi'} ))
});
}
else {
();
}
};
}
else {
();
}
};
}
else {
();
}
}
);
}

# XXX should eventually be derived from current Unicode tables.
our %open2close = (
"\x{0028}" => "\x{0029}",
"\x{003C}" => "\x{003E}",
"\x{005B}" => "\x{005D}",
"\x{007B}" => "\x{007D}",
"\x{00AB}" => "\x{00BB}",
"\x{0F3A}" => "\x{0F3B}",
"\x{0F3C}" => "\x{0F3D}",
"\x{169B}" => "\x{169C}",
"\x{2018}" => "\x{2019}",
"\x{201A}" => "\x{2019}",
"\x{201B}" => "\x{2019}",
"\x{201C}" => "\x{201D}",
"\x{201E}" => "\x{201D}",
"\x{201F}" => "\x{201D}",
"\x{2039}" => "\x{203A}",
"\x{2045}" => "\x{2046}",
"\x{207D}" => "\x{207E}",
"\x{208D}" => "\x{208E}",
"\x{2208}" => "\x{220B}",
"\x{2209}" => "\x{220C}",
"\x{220A}" => "\x{220D}",
"\x{2215}" => "\x{29F5}",
"\x{223C}" => "\x{223D}",
"\x{2243}" => "\x{22CD}",
"\x{2252}" => "\x{2253}",
"\x{2254}" => "\x{2255}",
"\x{2264}" => "\x{2265}",
"\x{2266}" => "\x{2267}",
"\x{2268}" => "\x{2269}",
"\x{226A}" => "\x{226B}",
"\x{226E}" => "\x{226F}",
"\x{2270}" => "\x{2271}",
"\x{2272}" => "\x{2273}",
"\x{2274}" => "\x{2275}",
"\x{2276}" => "\x{2277}",
"\x{2278}" => "\x{2279}",
"\x{227A}" => "\x{227B}",
"\x{227C}" => "\x{227D}",
"\x{227E}" => "\x{227F}",
"\x{2280}" => "\x{2281}",
"\x{2282}" => "\x{2283}",
"\x{2284}" => "\x{2285}",
"\x{2286}" => "\x{2287}",
"\x{2288}" => "\x{2289}",
"\x{228A}" => "\x{228B}",
"\x{228F}" => "\x{2290}",
"\x{2291}" => "\x{2292}",
"\x{2298}" => "\x{29B8}",
"\x{22A2}" => "\x{22A3}",
"\x{22A6}" => "\x{2ADE}",
"\x{22A8}" => "\x{2AE4}",
"\x{22A9}" => "\x{2AE3}",
"\x{22AB}" => "\x{2AE5}",
"\x{22B0}" => "\x{22B1}",
"\x{22B2}" => "\x{22B3}",
"\x{22B4}" => "\x{22B5}",
"\x{22B6}" => "\x{22B7}",
"\x{22C9}" => "\x{22CA}",
"\x{22CB}" => "\x{22CC}",
"\x{22D0}" => "\x{22D1}",
"\x{22D6}" => "\x{22D7}",
"\x{22D8}" => "\x{22D9}",
"\x{22DA}" => "\x{22DB}",
"\x{22DC}" => "\x{22DD}",
"\x{22DE}" => "\x{22DF}",
"\x{22E0}" => "\x{22E1}",
"\x{22E2}" => "\x{22E3}",
"\x{22E4}" => "\x{22E5}",
"\x{22E6}" => "\x{22E7}",
"\x{22E8}" => "\x{22E9}",
"\x{22EA}" => "\x{22EB}",
"\x{22EC}" => "\x{22ED}",
"\x{22F0}" => "\x{22F1}",
"\x{22F2}" => "\x{22FA}",
"\x{22F3}" => "\x{22FB}",
"\x{22F4}" => "\x{22FC}",
"\x{22F6}" => "\x{22FD}",
"\x{22F7}" => "\x{22FE}",
"\x{2308}" => "\x{2309}",
"\x{230A}" => "\x{230B}",
"\x{2329}" => "\x{232A}",
"\x{23B4}" => "\x{23B5}",
"\x{2768}" => "\x{2769}",
"\x{276A}" => "\x{276B}",
"\x{276C}" => "\x{276D}",
"\x{276E}" => "\x{276F}",
"\x{2770}" => "\x{2771}",
"\x{2772}" => "\x{2773}",
"\x{2774}" => "\x{2775}",
"\x{27C3}" => "\x{27C4}",
"\x{27C5}" => "\x{27C6}",
"\x{27D5}" => "\x{27D6}",
"\x{27DD}" => "\x{27DE}",
"\x{27E2}" => "\x{27E3}",
"\x{27E4}" => "\x{27E5}",
"\x{27E6}" => "\x{27E7}",
"\x{27E8}" => "\x{27E9}",
"\x{27EA}" => "\x{27EB}",
"\x{2983}" => "\x{2984}",
"\x{2985}" => "\x{2986}",
"\x{2987}" => "\x{2988}",
"\x{2989}" => "\x{298A}",
"\x{298B}" => "\x{298C}",
"\x{298D}" => "\x{298E}",
"\x{298F}" => "\x{2990}",
"\x{2991}" => "\x{2992}",
"\x{2993}" => "\x{2994}",
"\x{2995}" => "\x{2996}",
"\x{2997}" => "\x{2998}",
"\x{29C0}" => "\x{29C1}",
"\x{29C4}" => "\x{29C5}",
"\x{29CF}" => "\x{29D0}",
"\x{29D1}" => "\x{29D2}",
"\x{29D4}" => "\x{29D5}",
"\x{29D8}" => "\x{29D9}",
"\x{29DA}" => "\x{29DB}",
"\x{29F8}" => "\x{29F9}",
"\x{29FC}" => "\x{29FD}",
"\x{2A2B}" => "\x{2A2C}",
"\x{2A2D}" => "\x{2A2E}",
"\x{2A34}" => "\x{2A35}",
"\x{2A3C}" => "\x{2A3D}",
"\x{2A64}" => "\x{2A65}",
"\x{2A79}" => "\x{2A7A}",
"\x{2A7D}" => "\x{2A7E}",
"\x{2A7F}" => "\x{2A80}",
"\x{2A81}" => "\x{2A82}",
"\x{2A83}" => "\x{2A84}",
"\x{2A8B}" => "\x{2A8C}",
"\x{2A91}" => "\x{2A92}",
"\x{2A93}" => "\x{2A94}",
"\x{2A95}" => "\x{2A96}",
"\x{2A97}" => "\x{2A98}",
"\x{2A99}" => "\x{2A9A}",
"\x{2A9B}" => "\x{2A9C}",
"\x{2AA1}" => "\x{2AA2}",
"\x{2AA6}" => "\x{2AA7}",
"\x{2AA8}" => "\x{2AA9}",
"\x{2AAA}" => "\x{2AAB}",
"\x{2AAC}" => "\x{2AAD}",
"\x{2AAF}" => "\x{2AB0}",
"\x{2AB3}" => "\x{2AB4}",
"\x{2ABB}" => "\x{2ABC}",
"\x{2ABD}" => "\x{2ABE}",
"\x{2ABF}" => "\x{2AC0}",
"\x{2AC1}" => "\x{2AC2}",
"\x{2AC3}" => "\x{2AC4}",
"\x{2AC5}" => "\x{2AC6}",
"\x{2ACD}" => "\x{2ACE}",
"\x{2ACF}" => "\x{2AD0}",
"\x{2AD1}" => "\x{2AD2}",
"\x{2AD3}" => "\x{2AD4}",
"\x{2AD5}" => "\x{2AD6}",
"\x{2AEC}" => "\x{2AED}",
"\x{2AF7}" => "\x{2AF8}",
"\x{2AF9}" => "\x{2AFA}",
"\x{2E02}" => "\x{2E03}",
"\x{2E04}" => "\x{2E05}",
"\x{2E09}" => "\x{2E0A}",
"\x{2E0C}" => "\x{2E0D}",
"\x{2E1C}" => "\x{2E1D}",
"\x{2E20}" => "\x{2E21}",
"\x{3008}" => "\x{3009}",
"\x{300A}" => "\x{300B}",
"\x{300C}" => "\x{300D}",
"\x{300E}" => "\x{300F}",
"\x{3010}" => "\x{3011}",
"\x{3014}" => "\x{3015}",
"\x{3016}" => "\x{3017}",
"\x{3018}" => "\x{3019}",
"\x{301A}" => "\x{301B}",
"\x{301D}" => "\x{301E}",
"\x{FD3E}" => "\x{FD3F}",
"\x{FE17}" => "\x{FE18}",
"\x{FE35}" => "\x{FE36}",
"\x{FE37}" => "\x{FE38}",
"\x{FE39}" => "\x{FE3A}",
"\x{FE3B}" => "\x{FE3C}",
"\x{FE3D}" => "\x{FE3E}",
"\x{FE3F}" => "\x{FE40}",
"\x{FE41}" => "\x{FE42}",
"\x{FE43}" => "\x{FE44}",
"\x{FE47}" => "\x{FE48}",
"\x{FE59}" => "\x{FE5A}",
"\x{FE5B}" => "\x{FE5C}",
"\x{FE5D}" => "\x{FE5E}",
"\x{FF08}" => "\x{FF09}",
"\x{FF1C}" => "\x{FF1E}",
"\x{FF3B}" => "\x{FF3D}",
"\x{FF5B}" => "\x{FF5D}",
"\x{FF5F}" => "\x{FF60}",
"\x{FF62}" => "\x{FF63}",
);

## token opener
##      token opener {
##        <[
##      \x0028
##      \x003C
##      \x005B
##      \x007B
##      \x00AB
##      \x0F3A
##      \x0F3C
##      \x169B
##      \x2018
##      \x201A
##      \x201B
##      \x201C
##      \x201E
##      \x201F
##      \x2039
##      \x2045
##      \x207D
##      \x208D
##      \x2208
##      \x2209
##      \x220A
##      \x2215
##      \x223C
##      \x2243
##      \x2252
##      \x2254
##      \x2264
##      \x2266
##      \x2268
##      \x226A
##      \x226E
##      \x2270
##      \x2272
##      \x2274
##      \x2276
##      \x2278
##      \x227A
##      \x227C
##      \x227E
##      \x2280
##      \x2282
##      \x2284
##      \x2286
##      \x2288
##      \x228A
##      \x228F
##      \x2291
##      \x2298
##      \x22A2
##      \x22A6
##      \x22A8
##      \x22A9
##      \x22AB
##      \x22B0
##      \x22B2
##      \x22B4
##      \x22B6
##      \x22C9
##      \x22CB
##      \x22D0
##      \x22D6
##      \x22D8
##      \x22DA
##      \x22DC
##      \x22DE
##      \x22E0
##      \x22E2
##      \x22E4
##      \x22E6
##      \x22E8
##      \x22EA
##      \x22EC
##      \x22F0
##      \x22F2
##      \x22F3
##      \x22F4
##      \x22F6
##      \x22F7
##      \x2308
##      \x230A
##      \x2329
##      \x23B4
##      \x2768
##      \x276A
##      \x276C
##      \x276E
##      \x2770
##      \x2772
##      \x2774
##      \x27C3
##      \x27C5
##      \x27D5
##      \x27DD
##      \x27E2
##      \x27E4
##      \x27E6
##      \x27E8
##      \x27EA
##      \x2983
##      \x2985
##      \x2987
##      \x2989
##      \x298B
##      \x298D
##      \x298F
##      \x2991
##      \x2993
##      \x2995
##      \x2997
##      \x29C0
##      \x29C4
##      \x29CF
##      \x29D1
##      \x29D4
##      \x29D8
##      \x29DA
##      \x29F8
##      \x29FC
##      \x2A2B
##      \x2A2D
##      \x2A34
##      \x2A3C
##      \x2A64
##      \x2A79
##      \x2A7D
##      \x2A7F
##      \x2A81
##      \x2A83
##      \x2A8B
##      \x2A91
##      \x2A93
##      \x2A95
##      \x2A97
##      \x2A99
##      \x2A9B
##      \x2AA1
##      \x2AA6
##      \x2AA8
##      \x2AAA
##      \x2AAC
##      \x2AAF
##      \x2AB3
##      \x2ABB
##      \x2ABD
##      \x2ABF
##      \x2AC1
##      \x2AC3
##      \x2AC5
##      \x2ACD
##      \x2ACF
##      \x2AD1
##      \x2AD3
##      \x2AD5
##      \x2AEC
##      \x2AF7
##      \x2AF9
##      \x2E02
##      \x2E04
##      \x2E09
##      \x2E0C
##      \x2E1C
##      \x2E20
##      \x3008
##      \x300A
##      \x300C
##      \x300E
##      \x3010
##      \x3014
##      \x3016
##      \x3018
##      \x301A
##      \x301D
##      \xFD3E
##      \xFE17
##      \xFE35
##      \xFE37
##      \xFE39
##      \xFE3B
##      \xFE3D
##      \xFE3F
##      \xFE41
##      \xFE43
##      \xFE47
##      \xFE59
##      \xFE5B
##      \xFE5D
##      \xFF08
##      \xFF1C
##      \xFF3B
##      \xFF5B
##      \xFF5F
##      \xFF62
##        ]>
##      }

sub opener__PEEK { $_[0]->_AUTOLEXpeek('opener',$retree) }
sub opener {
my $self = shift;
local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;


my $C = $self;
my $S = $C->{'_pos'};

$self->_MATCHIFYr($S, "opener", 
$C->_PATTERN(qr/\G[\x{0028}\x{003C}\x{005B}\x{007B}\x{00AB}\x{0F3A}\x{0F3C}\x{169B}\x{2018}\x{201A}\x{201B}\x{201C}\x{201E}\x{201F}\x{2039}\x{2045}\x{207D}\x{208D}\x{2208}\x{2209}\x{220A}\x{2215}\x{223C}\x{2243}\x{2252}\x{2254}\x{2264}\x{2266}\x{2268}\x{226A}\x{226E}\x{2270}\x{2272}\x{2274}\x{2276}\x{2278}\x{227A}\x{227C}\x{227E}\x{2280}\x{2282}\x{2284}\x{2286}\x{2288}\x{228A}\x{228F}\x{2291}\x{2298}\x{22A2}\x{22A6}\x{22A8}\x{22A9}\x{22AB}\x{22B0}\x{22B2}\x{22B4}\x{22B6}\x{22C9}\x{22CB}\x{22D0}\x{22D6}\x{22D8}\x{22DA}\x{22DC}\x{22DE}\x{22E0}\x{22E2}\x{22E4}\x{22E6}\x{22E8}\x{22EA}\x{22EC}\x{22F0}\x{22F2}\x{22F3}\x{22F4}\x{22F6}\x{22F7}\x{2308}\x{230A}\x{2329}\x{23B4}\x{2768}\x{276A}\x{276C}\x{276E}\x{2770}\x{2772}\x{2774}\x{27C3}\x{27C5}\x{27D5}\x{27DD}\x{27E2}\x{27E4}\x{27E6}\x{27E8}\x{27EA}\x{2983}\x{2985}\x{2987}\x{2989}\x{298B}\x{298D}\x{298F}\x{2991}\x{2993}\x{2995}\x{2997}\x{29C0}\x{29C4}\x{29CF}\x{29D1}\x{29D4}\x{29D8}\x{29DA}\x{29F8}\x{29FC}\x{2A2B}\x{2A2D}\x{2A34}\x{2A3C}\x{2A64}\x{2A79}\x{2A7D}\x{2A7F}\x{2A81}\x{2A83}\x{2A8B}\x{2A91}\x{2A93}\x{2A95}\x{2A97}\x{2A99}\x{2A9B}\x{2AA1}\x{2AA6}\x{2AA8}\x{2AAA}\x{2AAC}\x{2AAF}\x{2AB3}\x{2ABB}\x{2ABD}\x{2ABF}\x{2AC1}\x{2AC3}\x{2AC5}\x{2ACD}\x{2ACF}\x{2AD1}\x{2AD3}\x{2AD5}\x{2AEC}\x{2AF7}\x{2AF9}\x{2E02}\x{2E04}\x{2E09}\x{2E0C}\x{2E1C}\x{2E20}\x{3008}\x{300A}\x{300C}\x{300E}\x{3010}\x{3014}\x{3016}\x{3018}\x{301A}\x{301D}\x{FD3E}\x{FE17}\x{FE35}\x{FE37}\x{FE39}\x{FE3B}\x{FE3D}\x{FE3F}\x{FE41}\x{FE43}\x{FE47}\x{FE59}\x{FE5B}\x{FE5D}\x{FF08}\x{FF1C}\x{FF3B}\x{FF5B}\x{FF5F}\x{FF62}]/)
);
}

# assumes whitespace is eaten already

## method peek_delimiters
sub peek_delimiters {
my $self = shift;


my $pos = $self->{'_pos'};
my $startpos = $pos;
my $char = substr($::ORIG,$pos++,1);
if ($char =~ qr/^\s$/) {
$self->panic("Whitespace not allowed as delimiter");
}

# XXX not defined yet
#    <?before <+isPe> > {
#        self.panic("Use a closing delimiter for an opener is reserved");
#    }

my $rightbrack = $open2close{$char};
if (not defined $rightbrack) {
return $char, $char;
}
while (substr($::ORIG,$pos,1) eq $char) {
$pos++;
}
my $len = $pos - $startpos;
my $start = $char x $len;
my $stop = $rightbrack x $len;
return $start, $stop;
}

{ package STD::startstop;
sub __instantiate__ { my $self = shift;
my ($start,$stop) = @_;
my $mangle = ::mangle($start,$stop);
my $mixin = "STD::startstop::" . $mangle;
return $mixin if $INSTANTIATED{$mixin}++;
::deb("		instantiating $mixin") if $::DEBUG & DEBUG::mixins;
my $eval = "package $mixin" . q{;
use Moose::Role ':all' => { -prefix => "moose_" };
my $retree;
sub _PARAMS { { '$start' => $start,'$stop' => $stop } }
##     token starter
##          token starter { $start }

sub starter__PEEK { $_[0]->_AUTOLEXpeek('starter',$retree) }
sub starter {
my $self = shift;
local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;


my $C = $self;
my $S = $C->{'_pos'};

$self->_MATCHIFYr($S, "starter", 
$C->_EXACT($start)
);
}
##     token stopper
##          token stopper { $stop }

sub stopper__PEEK { $_[0]->_AUTOLEXpeek('stopper',$retree) }
sub stopper {
my $self = shift;
local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;


my $C = $self;
my $S = $C->{'_pos'};

$self->_MATCHIFYr($S, "stopper", 
$C->_EXACT($stop)
);
}
BEGIN {
$retree = YAML::Syck::Load(<<'RETREE_END');
--- 
starter: !!perl/hash:RE 
  decl: []

  kind: token
  min: 0
  pkg: ~
  re: !!perl/hash:RE_var 
    a: 0
    dba: starter
    i: 0
    min: 0
    r: 1
    s: 0
    var: $start
stopper: !!perl/hash:RE 
  decl: []

  kind: token
  min: 0
  pkg: ~
  re: !!perl/hash:RE_var 
    a: 0
    dba: stopper
    i: 0
    min: 0
    r: 1
    s: 0
    var: $stop
RETREE_END
}
};
eval $eval;
return $mixin;
}
}
## end role

{ package STD::stop;
sub __instantiate__ { my $self = shift;
my ($stop) = @_;
my $mangle = ::mangle($stop);
my $mixin = "STD::stop::" . $mangle;
return $mixin if $INSTANTIATED{$mixin}++;
::deb("		instantiating $mixin") if $::DEBUG & DEBUG::mixins;
my $eval = "package $mixin" . q{;
use Moose::Role ':all' => { -prefix => "moose_" };
my $retree;
sub _PARAMS { { '$stop' => $stop } }
##     token starter
##          token starter { <!> }

sub starter__PEEK { $_[0]->_AUTOLEXpeek('starter',$retree) }
sub starter {
my $self = shift;
local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;


my $C = $self;
my $S = $C->{'_pos'};

$self->_MATCHIFYr($S, "starter", 
$C->_NOTBEFORE( sub { my $C=shift;
$C
})
);
}
##     token stopper
##          token stopper { $stop }

sub stopper__PEEK { $_[0]->_AUTOLEXpeek('stopper',$retree) }
sub stopper {
my $self = shift;
local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;


my $C = $self;
my $S = $C->{'_pos'};

$self->_MATCHIFYr($S, "stopper", 
$C->_EXACT($stop)
);
}
BEGIN {
$retree = YAML::Syck::Load(<<'RETREE_END');
--- 
starter: !!perl/hash:RE 
  decl: []

  kind: token
  min: 0
  pkg: ~
  re: !!perl/hash:RE_assertion 
    assert: "!"
    min: 0
    re: !!perl/hash:RE_noop 
      a: 0
      dba: starter
      i: 0
      min: 0
      nobind: 1
      r: 1
      s: 0
stopper: !!perl/hash:RE 
  decl: []

  kind: token
  min: 0
  pkg: ~
  re: !!perl/hash:RE_var 
    a: 0
    dba: stopper
    i: 0
    min: 0
    r: 1
    s: 0
    var: $stop
RETREE_END
}
};
eval $eval;
return $mixin;
}
}
## end role

{ package STD::unitstop;
sub __instantiate__ { my $self = shift;
my ($stop) = @_;
my $mangle = ::mangle($stop);
my $mixin = "STD::unitstop::" . $mangle;
return $mixin if $INSTANTIATED{$mixin}++;
::deb("		instantiating $mixin") if $::DEBUG & DEBUG::mixins;
my $eval = "package $mixin" . q{;
use Moose::Role ':all' => { -prefix => "moose_" };
my $retree;
sub _PARAMS { { '$stop' => $stop } }
##     token unitstopper
##          token unitstopper { $stop }

sub unitstopper__PEEK { $_[0]->_AUTOLEXpeek('unitstopper',$retree) }
sub unitstopper {
my $self = shift;
local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;


my $C = $self;
my $S = $C->{'_pos'};

$self->_MATCHIFYr($S, "unitstopper", 
$C->_EXACT($stop)
);
}
BEGIN {
$retree = YAML::Syck::Load(<<'RETREE_END');
--- 
unitstopper: !!perl/hash:RE 
  decl: []

  kind: token
  min: 0
  pkg: ~
  re: !!perl/hash:RE_var 
    a: 0
    dba: unitstopper
    i: 0
    min: 0
    r: 1
    s: 0
    var: $stop
RETREE_END
}
};
eval $eval;
return $mixin;
}
}
## end role
## token unitstopper
##      } # end role
##      
##      token unitstopper { $ }

sub unitstopper__PEEK { $_[0]->_AUTOLEXpeek('unitstopper',$retree) }
sub unitstopper {
my $self = shift;
local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;


my $C = $self;
my $S = $C->{'_pos'};

$self->_MATCHIFYr($S, "unitstopper", 
$C->_PATTERN(qr/\G\z/)
);
}

## method balanced ($start,$stop)
sub balanced {
my $self = shift;
my $start = shift;
my $stop = shift;

$self->mixin( 'STD::startstop'->__instantiate__($start,$stop) ); }
## method unbalanced ($stop)
sub unbalanced {
my $self = shift;
my $stop = shift;

$self->mixin( 'STD::stop'->__instantiate__($stop) ); }
## method unitstop ($stop)
sub unitstop {
my $self = shift;
my $stop = shift;

$self->mixin( 'STD::unitstop'->__instantiate__($stop) ); }

## token charname
##      token charname {
##          [
##          | <radint>
##          | <[a..z A..Z]><-[ \] , # ]>*?<[a..z A..Z ) ]> <?before \s*<[ \] , # ]>>
##          ] || <.panic: "Unrecognized character name">
##      }

sub charname__PEEK { $_[0]->_AUTOLEXpeek('charname',$retree) }
sub charname {
my $self = shift;
local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;


my $C = $self;
my $S = $C->{'_pos'};

$self->_MATCHIFY($S, "charname", 
do { my @gather;
eval { push @gather, $C->_BRACKET( sub { my $C=shift;
do {
my @result = eval {
my $trystate;
my ($tag, $try);
my @try;
my $relex;

my $fate;
if ($fate = $C->{'_fate'} and $fate->[1] eq 'charname_01') {
$C->deb("Fate passed to charname_01: ", ::fatestr($fate)) if $::DEBUG & DEBUG::fates;
($C->{'_fate'}, $tag, $try) = @$fate;
@try = ($try);
}

my @gather = ();
for (;;) {
if (not @try) {
$relex //= $C->cursor_fate('STD', 'charname_01', $retree);
@try = $relex->($C, $trystate);
}
last unless @try;
$try = shift(@try) // next;

if (ref $try eq 'ARRAY') {
($C->{'_fate'}, $tag, $try) = @$try;	# next candidate fate
}

$C->deb("charname_01 trying $tag $try") if $::DEBUG & DEBUG::try_processing;
push @gather, ((
sub { my $C=shift;
$C->_SUBSUME(['radint'], sub {
my $C = shift;
$C->radint
})
},
sub { my $C=shift;
Cursor::lazymap(sub { my $C=$_[0];
Cursor::lazymap(sub { my $C=$_[0];
Cursor::lazymap(sub { my $C=$_[0];
$C->before(sub { my $C=shift;
Cursor::lazymap(sub { my $C=$_[0];
$C->_PATTERN(qr/\G[\],#]/)
}, $C->_PATTERN(qr/\G((?:\s)*+)/))
})
}, $C->_PATTERN(qr/\G[a-zA-Z)]/))
}, $C->_STARf(sub { my $C=shift;
$C->_PATTERN(qr/\G[^\],#]/)
}))
}, $C->_PATTERN(qr/\G[a-zA-Z]/))
},
)[$try])->($C);
last if @gather;
}
@gather;
};
if (@result) {
@result;
}
elsif ($@) {
my ($first) = $@ =~ /(^.*)/;
$self->deb("CAUGHT $first") if $::DEBUG & DEBUG::trace_call;
die $@ if $@ !~ /^ABORTBRANCH/;
();
}
else {
();
}
}

})} // do {die $@ if $@ and $@ !~ /ABORT/;1} 
or
eval { push @gather, $C->panic("Unrecognized character name")} or do { die $@ if $@ };
@gather;
}
);
}

## token charnames
##      token charnames { [<.ws><charname><.ws>] ** ',' }

sub charnames__PEEK { $_[0]->_AUTOLEXpeek('charnames',$retree) }
sub charnames {
my $self = shift;
local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;


my $C = $self;
my $S = $C->{'_pos'};
$C->{'charname'} = [];

$self->_MATCHIFYr($S, "charnames", 
$C->_REPSEPr(  sub { my $C=shift;
$C->_EXACT(',')
}, sub { my $C=shift;
$C->_BRACKETr( sub { my $C=shift;
do {
if (my ($C) = ($C->ws)) {
do {
if (my ($C) = ($C->_SUBSUMEr(['charname'], sub {
my $C = shift;
$C->charname
}))) {
$C->ws;
}
else {
();
}
};
}
else {
();
}
}
})
})
);
}

## token charspec
##      token charspec {
##          [
##          | :dba('character name') '[' ~ ']' <charnames>
##          | \d+
##          | <[ ?..Z \\.._ ]>
##          | <?> <.panic: "Unrecognized \\c character">
##          ]
##      }

sub charspec__PEEK { $_[0]->_AUTOLEXpeek('charspec',$retree) }
sub charspec {
my $self = shift;
local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;


my $C = $self;
my $S = $C->{'_pos'};

$self->_MATCHIFY($S, "charspec", 
$C->_BRACKET( sub { my $C=shift;
do {
my @result = eval {
my $trystate;
my ($tag, $try);
my @try;
my $relex;

my $fate;
if ($fate = $C->{'_fate'} and $fate->[1] eq 'charspec_01') {
$C->deb("Fate passed to charspec_01: ", ::fatestr($fate)) if $::DEBUG & DEBUG::fates;
($C->{'_fate'}, $tag, $try) = @$fate;
@try = ($try);
}

my @gather = ();
for (;;) {
if (not @try) {
$relex //= $C->cursor_fate('STD', 'charspec_01', $retree);
@try = $relex->($C, $trystate);
}
last unless @try;
$try = shift(@try) // next;

if (ref $try eq 'ARRAY') {
($C->{'_fate'}, $tag, $try) = @$try;	# next candidate fate
}

$C->deb("charspec_01 trying $tag $try") if $::DEBUG & DEBUG::try_processing;
push @gather, ((
sub { my $C=shift;
Cursor::lazymap(sub { my $C=$_[0];
Cursor::lazymap(sub { my $C=$_[0];
Cursor::lazymap(sub { my $C=$_[0];
$C->_BRACKET( sub { my $C=shift;
do { my @gather;
eval { push @gather, $C->_EXACT(']')} // do {die $@ if $@ and $@ !~ /ABORT/;1} 
or
eval { push @gather, $C->FAILGOAL(']' , 'character name')} or do { die $@ if $@ };
@gather;
}
})
}, $C->_SUBSUME(['charnames'], sub {
my $C = shift;
$C->charnames
}))
}, $C->_COMMITBRANCH(local $::GOAL = ']' ))
}, $C->_EXACT('['))
},
sub { my $C=shift;
$C->_PATTERN(qr/\G((?:\d)++)/)
},
sub { my $C=shift;
$C->_PATTERN(qr/\G[?-Z\\-_]/)
},
sub { my $C=shift;
Cursor::lazymap(sub { my $C=$_[0];
$C->panic("Unrecognized \\c character")
}, $C->before( sub { my $C=shift;
$C
}))
},
)[$try])->($C);
last if @gather;
}
@gather;
};
if (@result) {
@result;
}
elsif ($@) {
my ($first) = $@ =~ /(^.*)/;
$self->deb("CAUGHT $first") if $::DEBUG & DEBUG::trace_call;
die $@ if $@ !~ /^ABORTBRANCH/;
();
}
else {
();
}
}

})
);
}

## method truly ($bool,$opt)
sub truly {
my $self = shift;
my $bool = shift;
my $opt = shift;


return $self if $bool;
$self->panic("Can't negate $opt adverb");
}

{ package STD::Q;
use Moose ':all' => { -prefix => "moose_" };
my $retree;
moose_extends(qw(STD));
{ package STD::Q::b1;
use Moose::Role ':all' => { -prefix => "moose_" };
my $retree;
##         token escape__S_220Back (:$sym is context<rw> = <\\>)
##              token escape:sym<\\> { <sym> <item=backslash> }

sub escape__S_220Back__PEEK { $_[0]->_AUTOLEXpeek('escape__S_220Back',$retree) }
sub escape__S_220Back {
my $self = shift;
local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;
my %args = @_;
local $sym = $args{sym} // q(\\);


my $C = $self;
my $S = $C->{'_pos'};
$C->{'sym'} = $sym;

$self->_MATCHIFYr($S, "escape__S_220Back", 
do {
if (my ($C) = ($C->_PATTERN(qr/\G\\/))) {
$C->_SUBSUMEr(['item'], sub {
my $C = shift;
$C->backslash
});
}
else {
();
}
}
);
}
##         token backslash__S_221qq (:$sym is context<rw> = 'qq')
##              token backslash:qq { <?before 'q'> { $<quote> = $¢.cursor_fresh(%*LANG<MAIN>).quote(); } }

sub backslash__S_221qq__PEEK { $_[0]->_AUTOLEXpeek('backslash__S_221qq',$retree) }
sub backslash__S_221qq {
my $self = shift;
local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;
my %args = @_;
local $sym = $args{sym} // 'qq';


my $C = $self;
my $S = $C->{'_pos'};
$C->{'sym'} = $sym;

$self->_MATCHIFYr($S, "backslash__S_221qq", 
do {
if (my ($C) = ($C->before(sub { my $C=shift;
$C->_EXACT('q')
}))) {
scalar(do {
my $M = $C;  $M->{'quote'} = $C->cursor_fresh($::LANG{'MAIN'})->quote(); ;
}, $C);
}
else {
();
}
}
);
}
##         token backslash__S_222Back (:$sym is context<rw> = <\\>)
##              token backslash:sym<\\> { <text=sym> }

sub backslash__S_222Back__PEEK { $_[0]->_AUTOLEXpeek('backslash__S_222Back',$retree) }
sub backslash__S_222Back {
my $self = shift;
local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;
my %args = @_;
local $sym = $args{sym} // q(\\);


my $C = $self;
my $S = $C->{'_pos'};
$C->{'sym'} = $sym;

$self->_MATCHIFYr($S, "backslash__S_222Back", 
$C->_PATTERN(qr/\G\\/)
);
}
##         token backslash__S_223stopper (:$sym is context<rw> = 'stopper')
##              token backslash:stopper { <text=stopper> }

sub backslash__S_223stopper__PEEK { $_[0]->_AUTOLEXpeek('backslash__S_223stopper',$retree) }
sub backslash__S_223stopper {
my $self = shift;
local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;
my %args = @_;
local $sym = $args{sym} // 'stopper';


my $C = $self;
my $S = $C->{'_pos'};
$C->{'sym'} = $sym;

$self->_MATCHIFYr($S, "backslash__S_223stopper", 
$C->_SUBSUMEr(['text'], sub {
my $C = shift;
$C->stopper
})
);
}
##         token backslash__S_224a (:$sym is context<rw> = 'a')
##              token backslash:a { <sym> }

sub backslash__S_224a__PEEK { $_[0]->_AUTOLEXpeek('backslash__S_224a',$retree) }
sub backslash__S_224a {
my $self = shift;
local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;
my %args = @_;
local $sym = $args{sym} // 'a';


my $C = $self;
my $S = $C->{'_pos'};
$C->{'sym'} = $sym;

$self->_MATCHIFYr($S, "backslash__S_224a", 
$C->_PATTERN(qr/\Ga/)
);
}
##         token backslash__S_225b (:$sym is context<rw> = 'b')
##              token backslash:b { <sym> }

sub backslash__S_225b__PEEK { $_[0]->_AUTOLEXpeek('backslash__S_225b',$retree) }
sub backslash__S_225b {
my $self = shift;
local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;
my %args = @_;
local $sym = $args{sym} // 'b';


my $C = $self;
my $S = $C->{'_pos'};
$C->{'sym'} = $sym;

$self->_MATCHIFYr($S, "backslash__S_225b", 
$C->_PATTERN(qr/\Gb/)
);
}
##         token backslash__S_226c (:$sym is context<rw> = 'c')
##              token backslash:c { <sym> <charspec> }

sub backslash__S_226c__PEEK { $_[0]->_AUTOLEXpeek('backslash__S_226c',$retree) }
sub backslash__S_226c {
my $self = shift;
local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;
my %args = @_;
local $sym = $args{sym} // 'c';


my $C = $self;
my $S = $C->{'_pos'};
$C->{'sym'} = $sym;

$self->_MATCHIFYr($S, "backslash__S_226c", 
do {
if (my ($C) = ($C->_PATTERN(qr/\Gc/))) {
$C->_SUBSUMEr(['charspec'], sub {
my $C = shift;
$C->charspec
});
}
else {
();
}
}
);
}
##         token backslash__S_227e (:$sym is context<rw> = 'e')
##              token backslash:e { <sym> }

sub backslash__S_227e__PEEK { $_[0]->_AUTOLEXpeek('backslash__S_227e',$retree) }
sub backslash__S_227e {
my $self = shift;
local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;
my %args = @_;
local $sym = $args{sym} // 'e';


my $C = $self;
my $S = $C->{'_pos'};
$C->{'sym'} = $sym;

$self->_MATCHIFYr($S, "backslash__S_227e", 
$C->_PATTERN(qr/\Ge/)
);
}
##         token backslash__S_228f (:$sym is context<rw> = 'f')
##              token backslash:f { <sym> }

sub backslash__S_228f__PEEK { $_[0]->_AUTOLEXpeek('backslash__S_228f',$retree) }
sub backslash__S_228f {
my $self = shift;
local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;
my %args = @_;
local $sym = $args{sym} // 'f';


my $C = $self;
my $S = $C->{'_pos'};
$C->{'sym'} = $sym;

$self->_MATCHIFYr($S, "backslash__S_228f", 
$C->_PATTERN(qr/\Gf/)
);
}
##         token backslash__S_229n (:$sym is context<rw> = 'n')
##              token backslash:n { <sym> }

sub backslash__S_229n__PEEK { $_[0]->_AUTOLEXpeek('backslash__S_229n',$retree) }
sub backslash__S_229n {
my $self = shift;
local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;
my %args = @_;
local $sym = $args{sym} // 'n';


my $C = $self;
my $S = $C->{'_pos'};
$C->{'sym'} = $sym;

$self->_MATCHIFYr($S, "backslash__S_229n", 
$C->_PATTERN(qr/\Gn/)
);
}
##         token backslash__S_230o (:$sym is context<rw> = 'o')
##              token backslash:o { :dba('octal character') <sym> [ <octint> | '[' ~ ']' <octints> ] }

sub backslash__S_230o__PEEK { $_[0]->_AUTOLEXpeek('backslash__S_230o',$retree) }
sub backslash__S_230o {
my $self = shift;
local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;
my %args = @_;
local $sym = $args{sym} // 'o';


my $C = $self;
my $S = $C->{'_pos'};
$C->{'sym'} = $sym;

$self->_MATCHIFY($S, "backslash__S_230o", 
Cursor::lazymap(sub { my $C=$_[0];
$C->_BRACKET( sub { my $C=shift;
do {
my @result = eval {
my $trystate;
my ($tag, $try);
my @try;
my $relex;

my $fate;
if ($fate = $C->{'_fate'} and $fate->[1] eq 'backslash__S_230o_01') {
$C->deb("Fate passed to backslash__S_230o_01: ", ::fatestr($fate)) if $::DEBUG & DEBUG::fates;
($C->{'_fate'}, $tag, $try) = @$fate;
@try = ($try);
}

my @gather = ();
for (;;) {
if (not @try) {
$relex //= $C->cursor_fate('STD::Q::b1', 'backslash__S_230o_01', $retree);
@try = $relex->($C, $trystate);
}
last unless @try;
$try = shift(@try) // next;

if (ref $try eq 'ARRAY') {
($C->{'_fate'}, $tag, $try) = @$try;	# next candidate fate
}

$C->deb("backslash__S_230o_01 trying $tag $try") if $::DEBUG & DEBUG::try_processing;
push @gather, ((
sub { my $C=shift;
$C->_SUBSUMEr(['octint'], sub {
my $C = shift;
$C->octint
})
},
sub { my $C=shift;
Cursor::lazymap(sub { my $C=$_[0];
Cursor::lazymap(sub { my $C=$_[0];
Cursor::lazymap(sub { my $C=$_[0];
$C->_BRACKET( sub { my $C=shift;
do { my @gather;
eval { push @gather, $C->_EXACT(']')} // do {die $@ if $@ and $@ !~ /ABORT/;1} 
or
eval { push @gather, $C->FAILGOAL(']' , 'octal character')} or do { die $@ if $@ };
@gather;
}
})
}, $C->_SUBSUME(['octints'], sub {
my $C = shift;
$C->octints
}))
}, $C->_COMMITBRANCH(local $::GOAL = ']' ))
}, $C->_EXACT('['))
},
)[$try])->($C);
last if @gather;
}
@gather;
};
if (@result) {
@result;
}
elsif ($@) {
my ($first) = $@ =~ /(^.*)/;
$self->deb("CAUGHT $first") if $::DEBUG & DEBUG::trace_call;
die $@ if $@ !~ /^ABORTBRANCH/;
();
}
else {
();
}
}

})
}, $C->_PATTERN(qr/\Go/))
);
}
##         token backslash__S_231r (:$sym is context<rw> = 'r')
##              token backslash:r { <sym> }

sub backslash__S_231r__PEEK { $_[0]->_AUTOLEXpeek('backslash__S_231r',$retree) }
sub backslash__S_231r {
my $self = shift;
local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;
my %args = @_;
local $sym = $args{sym} // 'r';


my $C = $self;
my $S = $C->{'_pos'};
$C->{'sym'} = $sym;

$self->_MATCHIFYr($S, "backslash__S_231r", 
$C->_PATTERN(qr/\Gr/)
);
}
##         token backslash__S_232t (:$sym is context<rw> = 't')
##              token backslash:t { <sym> }

sub backslash__S_232t__PEEK { $_[0]->_AUTOLEXpeek('backslash__S_232t',$retree) }
sub backslash__S_232t {
my $self = shift;
local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;
my %args = @_;
local $sym = $args{sym} // 't';


my $C = $self;
my $S = $C->{'_pos'};
$C->{'sym'} = $sym;

$self->_MATCHIFYr($S, "backslash__S_232t", 
$C->_PATTERN(qr/\Gt/)
);
}
##         token backslash__S_233x (:$sym is context<rw> = 'x')
##              token backslash:x { :dba('hex character') <sym> [ <hexint> | '[' ~ ']' <hexints> ] }

sub backslash__S_233x__PEEK { $_[0]->_AUTOLEXpeek('backslash__S_233x',$retree) }
sub backslash__S_233x {
my $self = shift;
local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;
my %args = @_;
local $sym = $args{sym} // 'x';


my $C = $self;
my $S = $C->{'_pos'};
$C->{'sym'} = $sym;

$self->_MATCHIFY($S, "backslash__S_233x", 
Cursor::lazymap(sub { my $C=$_[0];
$C->_BRACKET( sub { my $C=shift;
do {
my @result = eval {
my $trystate;
my ($tag, $try);
my @try;
my $relex;

my $fate;
if ($fate = $C->{'_fate'} and $fate->[1] eq 'backslash__S_233x_01') {
$C->deb("Fate passed to backslash__S_233x_01: ", ::fatestr($fate)) if $::DEBUG & DEBUG::fates;
($C->{'_fate'}, $tag, $try) = @$fate;
@try = ($try);
}

my @gather = ();
for (;;) {
if (not @try) {
$relex //= $C->cursor_fate('STD::Q::b1', 'backslash__S_233x_01', $retree);
@try = $relex->($C, $trystate);
}
last unless @try;
$try = shift(@try) // next;

if (ref $try eq 'ARRAY') {
($C->{'_fate'}, $tag, $try) = @$try;	# next candidate fate
}

$C->deb("backslash__S_233x_01 trying $tag $try") if $::DEBUG & DEBUG::try_processing;
push @gather, ((
sub { my $C=shift;
$C->_SUBSUMEr(['hexint'], sub {
my $C = shift;
$C->hexint
})
},
sub { my $C=shift;
Cursor::lazymap(sub { my $C=$_[0];
Cursor::lazymap(sub { my $C=$_[0];
Cursor::lazymap(sub { my $C=$_[0];
$C->_BRACKET( sub { my $C=shift;
do { my @gather;
eval { push @gather, $C->_EXACT(']')} // do {die $@ if $@ and $@ !~ /ABORT/;1} 
or
eval { push @gather, $C->FAILGOAL(']' , 'hex character')} or do { die $@ if $@ };
@gather;
}
})
}, $C->_SUBSUME(['hexints'], sub {
my $C = shift;
$C->hexints
}))
}, $C->_COMMITBRANCH(local $::GOAL = ']' ))
}, $C->_EXACT('['))
},
)[$try])->($C);
last if @gather;
}
@gather;
};
if (@result) {
@result;
}
elsif ($@) {
my ($first) = $@ =~ /(^.*)/;
$self->deb("CAUGHT $first") if $::DEBUG & DEBUG::trace_call;
die $@ if $@ !~ /^ABORTBRANCH/;
();
}
else {
();
}
}

})
}, $C->_PATTERN(qr/\Gx/))
);
}
##         token backslash__S_2340 (:$sym is context<rw> = <0>)
##              token backslash:sym<0> { <sym> }

sub backslash__S_2340__PEEK { $_[0]->_AUTOLEXpeek('backslash__S_2340',$retree) }
sub backslash__S_2340 {
my $self = shift;
local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;
my %args = @_;
local $sym = $args{sym} // q(0);


my $C = $self;
my $S = $C->{'_pos'};

$self->_MATCHIFYr($S, "backslash__S_2340", 
$C->_PATTERN(qr/\G0/)
);
}
BEGIN {
$retree = YAML::Syck::Load(<<'RETREE_END');
--- 
backslash__S_221qq: !!perl/hash:RE 
  decl: []

  kind: token
  min: 0
  pkg: ~
  re: !!perl/hash:RE_sequence 
    a: 0
    dba: backslash__S_221qq
    i: 0
    min: 0
    r: 1
    s: 0
    zyg: 
      - !!perl/hash:RE_assertion 
        assert: "?"
        min: 0
        re: !!perl/hash:RE_method_re 
          a: 0
          dba: backslash__S_221qq
          i: 0
          min: 0
          name: before
          nobind: 1
          r: 1
          re: !!perl/hash:RE 
            decl: []

            min: 1
            re: !!perl/hash:RE_string 
              a: 0
              dba: backslash__S_221qq
              i: 0
              min: 1
              r: 1
              s: 0
              text: q
          s: 0
      - !!perl/hash:RE_block 
        a: 0
        context: void
        dba: backslash__S_221qq
        i: 0
        min: 0
        r: 1
        s: 0
        text: " $<quote> = $¢.cursor_fresh(%*LANG<MAIN>).quote(); "
backslash__S_222Back: !!perl/hash:RE 
  decl: []

  kind: token
  min: 12345
  pkg: ~
  re: !!perl/hash:RE_bindnamed 
    a: 0
    atom: !!perl/hash:RE_method 
      a: 0
      dba: backslash__S_222Back
      i: 0
      min: 12345
      name: sym
      nobind: 1
      r: 1
      rest: ''
      s: 0
      sym: \
    dba: backslash__S_222Back
    i: 0
    min: 12345
    r: 1
    s: 0
    var: text
backslash__S_223stopper: !!perl/hash:RE 
  decl: []

  kind: token
  min: 12345
  pkg: ~
  re: !!perl/hash:RE_bindnamed 
    a: 0
    atom: !!perl/hash:RE_method 
      a: 0
      dba: backslash__S_223stopper
      i: 0
      min: 12345
      name: stopper
      nobind: 1
      r: 1
      rest: ''
      s: 0
    dba: backslash__S_223stopper
    i: 0
    min: 12345
    r: 1
    s: 0
    var: text
backslash__S_224a: !!perl/hash:RE 
  decl: []

  kind: token
  min: 12345
  pkg: ~
  re: !!perl/hash:RE_method 
    a: 0
    dba: backslash__S_224a
    i: 0
    min: 12345
    name: sym
    r: 1
    rest: ''
    s: 0
    sym: a
backslash__S_225b: !!perl/hash:RE 
  decl: []

  kind: token
  min: 12345
  pkg: ~
  re: !!perl/hash:RE_method 
    a: 0
    dba: backslash__S_225b
    i: 0
    min: 12345
    name: sym
    r: 1
    rest: ''
    s: 0
    sym: b
backslash__S_226c: !!perl/hash:RE 
  decl: []

  kind: token
  min: 24690
  pkg: ~
  re: !!perl/hash:RE_sequence 
    a: 0
    dba: backslash__S_226c
    i: 0
    min: 24690
    r: 1
    s: 0
    zyg: 
      - !!perl/hash:RE_method 
        a: 0
        dba: backslash__S_226c
        i: 0
        min: 12345
        name: sym
        r: 1
        rest: ''
        s: 0
        sym: c
      - !!perl/hash:RE_method 
        a: 0
        dba: backslash__S_226c
        i: 0
        min: 12345
        name: charspec
        r: 1
        rest: ''
        s: 0
backslash__S_227e: !!perl/hash:RE 
  decl: []

  kind: token
  min: 12345
  pkg: ~
  re: !!perl/hash:RE_method 
    a: 0
    dba: backslash__S_227e
    i: 0
    min: 12345
    name: sym
    r: 1
    rest: ''
    s: 0
    sym: e
backslash__S_228f: !!perl/hash:RE 
  decl: []

  kind: token
  min: 12345
  pkg: ~
  re: !!perl/hash:RE_method 
    a: 0
    dba: backslash__S_228f
    i: 0
    min: 12345
    name: sym
    r: 1
    rest: ''
    s: 0
    sym: f
backslash__S_229n: !!perl/hash:RE 
  decl: []

  kind: token
  min: 12345
  pkg: ~
  re: !!perl/hash:RE_method 
    a: 0
    dba: backslash__S_229n
    i: 0
    min: 12345
    name: sym
    r: 1
    rest: ''
    s: 0
    sym: 'n'
backslash__S_230o: !!perl/hash:RE 
  decl: []

  kind: token
  min: 24690
  pkg: ~
  re: !!perl/hash:RE_sequence 
    a: 0
    dba: octal character
    i: 0
    min: 24690
    r: 1
    s: 0
    zyg: 
      - !!perl/hash:RE_method 
        a: 0
        dba: octal character
        i: 0
        min: 12345
        name: sym
        r: 1
        rest: ''
        s: 0
        sym: o
      - !!perl/hash:RE_bracket 
        decl: []

        min: 12345
        re: &1 !!perl/hash:RE_any 
          a: 0
          altname: backslash__S_230o_01
          dba: octal character
          i: 0
          min: 12345
          name: backslash__S_230o_01
          r: 1
          s: 0
          zyg: 
            - !!perl/hash:RE_method 
              a: 0
              alt: backslash__S_230o_01 0
              dba: octal character
              i: 0
              min: 12345
              name: octint
              r: 1
              rest: ''
              s: 0
            - !!perl/hash:RE_sequence 
              a: 0
              alt: backslash__S_230o_01 1
              dba: octal character
              i: 0
              min: 12347
              r: 1
              s: 0
              zyg: 
                - !!perl/hash:RE_string 
                  a: 0
                  dba: octal character
                  i: 0
                  min: 1
                  r: 1
                  s: 0
                  text: "["
                - !!perl/hash:RE_meta 
                  a: 0
                  dba: octal character
                  extra: "local $::GOAL = ']' "
                  i: 0
                  min: 0
                  r: 1
                  s: 0
                  text: "::"
                - !!perl/hash:RE_method 
                  a: 0
                  dba: octal character
                  i: 0
                  min: 12345
                  name: octints
                  r: 1
                  rest: ''
                  s: 0
                - !!perl/hash:RE_bracket 
                  decl: []

                  min: 1
                  re: !!perl/hash:RE_first 
                    a: 0
                    dba: octal character
                    i: 0
                    min: 1
                    r: 1
                    s: 0
                    zyg: 
                      - !!perl/hash:RE_string 
                        a: 0
                        dba: octal character
                        i: 0
                        min: 1
                        r: 1
                        s: 0
                        text: "]"
                      - !!perl/hash:RE_method 
                        min: 0
                        name: FAILGOAL
                        nobind: 1
                        rest: (']' , 'octal character')
backslash__S_230o_01: *1
backslash__S_231r: !!perl/hash:RE 
  decl: []

  kind: token
  min: 12345
  pkg: ~
  re: !!perl/hash:RE_method 
    a: 0
    dba: backslash__S_231r
    i: 0
    min: 12345
    name: sym
    r: 1
    rest: ''
    s: 0
    sym: r
backslash__S_232t: !!perl/hash:RE 
  decl: []

  kind: token
  min: 12345
  pkg: ~
  re: !!perl/hash:RE_method 
    a: 0
    dba: backslash__S_232t
    i: 0
    min: 12345
    name: sym
    r: 1
    rest: ''
    s: 0
    sym: t
backslash__S_233x: !!perl/hash:RE 
  decl: []

  kind: token
  min: 24690
  pkg: ~
  re: !!perl/hash:RE_sequence 
    a: 0
    dba: hex character
    i: 0
    min: 24690
    r: 1
    s: 0
    zyg: 
      - !!perl/hash:RE_method 
        a: 0
        dba: hex character
        i: 0
        min: 12345
        name: sym
        r: 1
        rest: ''
        s: 0
        sym: x
      - !!perl/hash:RE_bracket 
        decl: []

        min: 12345
        re: &2 !!perl/hash:RE_any 
          a: 0
          altname: backslash__S_233x_01
          dba: hex character
          i: 0
          min: 12345
          name: backslash__S_233x_01
          r: 1
          s: 0
          zyg: 
            - !!perl/hash:RE_method 
              a: 0
              alt: backslash__S_233x_01 0
              dba: hex character
              i: 0
              min: 12345
              name: hexint
              r: 1
              rest: ''
              s: 0
            - !!perl/hash:RE_sequence 
              a: 0
              alt: backslash__S_233x_01 1
              dba: hex character
              i: 0
              min: 12347
              r: 1
              s: 0
              zyg: 
                - !!perl/hash:RE_string 
                  a: 0
                  dba: hex character
                  i: 0
                  min: 1
                  r: 1
                  s: 0
                  text: "["
                - !!perl/hash:RE_meta 
                  a: 0
                  dba: hex character
                  extra: "local $::GOAL = ']' "
                  i: 0
                  min: 0
                  r: 1
                  s: 0
                  text: "::"
                - !!perl/hash:RE_method 
                  a: 0
                  dba: hex character
                  i: 0
                  min: 12345
                  name: hexints
                  r: 1
                  rest: ''
                  s: 0
                - !!perl/hash:RE_bracket 
                  decl: []

                  min: 1
                  re: !!perl/hash:RE_first 
                    a: 0
                    dba: hex character
                    i: 0
                    min: 1
                    r: 1
                    s: 0
                    zyg: 
                      - !!perl/hash:RE_string 
                        a: 0
                        dba: hex character
                        i: 0
                        min: 1
                        r: 1
                        s: 0
                        text: "]"
                      - !!perl/hash:RE_method 
                        min: 0
                        name: FAILGOAL
                        nobind: 1
                        rest: (']' , 'hex character')
backslash__S_233x_01: *2
backslash__S_2340: !!perl/hash:RE 
  decl: []

  kind: token
  min: 12345
  pkg: ~
  re: !!perl/hash:RE_method 
    a: 0
    dba: backslash__S_2340
    i: 0
    min: 12345
    name: sym
    r: 1
    rest: ''
    s: 0
    sym: 0
escape__S_220Back: !!perl/hash:RE 
  decl: []

  kind: token
  min: 24690
  pkg: ~
  re: !!perl/hash:RE_sequence 
    a: 0
    dba: escape__S_220Back
    i: 0
    min: 24690
    r: 1
    s: 0
    zyg: 
      - !!perl/hash:RE_method 
        a: 0
        dba: escape__S_220Back
        i: 0
        min: 12345
        name: sym
        r: 1
        rest: ''
        s: 0
        sym: \
      - !!perl/hash:RE_bindnamed 
        a: 0
        atom: !!perl/hash:RE_method 
          a: 0
          dba: escape__S_220Back
          i: 0
          min: 12345
          name: backslash
          nobind: 1
          r: 1
          rest: ''
          s: 0
        dba: escape__S_220Back
        i: 0
        min: 12345
        r: 1
        s: 0
        var: item
RETREE_END
}
} ## end role

{ package STD::Q::b0;
use Moose::Role ':all' => { -prefix => "moose_" };
my $retree;
##         token escape__S_235Back (:$sym is context<rw> = <\\>)
##              token escape:sym<\\> { <!> }

sub escape__S_235Back__PEEK { $_[0]->_AUTOLEXpeek('escape__S_235Back',$retree) }
sub escape__S_235Back {
my $self = shift;
local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;
my %args = @_;
local $sym = $args{sym} // q(\\);


my $C = $self;
my $S = $C->{'_pos'};
$C->{'sym'} = $sym;

$self->_MATCHIFYr($S, "escape__S_235Back", 
$C->_NOTBEFORE( sub { my $C=shift;
$C
})
);
}
BEGIN {
$retree = YAML::Syck::Load(<<'RETREE_END');
--- 
escape__S_235Back: !!perl/hash:RE 
  decl: []

  kind: token
  min: 0
  pkg: ~
  re: !!perl/hash:RE_assertion 
    assert: "!"
    min: 0
    re: !!perl/hash:RE_noop 
      a: 0
      dba: escape__S_235Back
      i: 0
      min: 0
      nobind: 1
      r: 1
      s: 0
RETREE_END
}
} ## end role

{ package STD::Q::c1;
use Moose::Role ':all' => { -prefix => "moose_" };
my $retree;
##         token escape__S_236Cur_Ly (:$sym is context<rw> = <{ }>)
##              token escape:sym<{ }> { <?before '{'> [ :lang(%*LANG<MAIN>) <block> ] }

sub escape__S_236Cur_Ly__PEEK { $_[0]->_AUTOLEXpeek('escape__S_236Cur_Ly',$retree) }
sub escape__S_236Cur_Ly {
my $self = shift;
local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;
my %args = @_;
local $sym = $args{sym} // [qw({ })];


my $C = $self;
my $S = $C->{'_pos'};
$C->{'sym'} = $sym;

$self->_MATCHIFYr($S, "escape__S_236Cur_Ly", 
do {
if (my ($C) = ($C->before(sub { my $C=shift;
$C->_EXACT('{')
}))) {
$C->_BRACKETr( sub { my $C=shift;
my $newlang = ($::LANG{'MAIN'});  $C = $C->cursor_fresh($newlang); ;$C->_SUBSUMEr(['block'], sub {
my $C = shift;
$C->block
})
});
}
else {
();
}
}
);
}
BEGIN {
$retree = YAML::Syck::Load(<<'RETREE_END');
--- 
escape__S_236Cur_Ly: !!perl/hash:RE 
  decl: []

  kind: token
  min: 12345
  pkg: ~
  re: !!perl/hash:RE_sequence 
    a: 0
    dba: escape__S_236Cur_Ly
    i: 0
    min: 12345
    r: 1
    s: 0
    zyg: 
      - !!perl/hash:RE_assertion 
        assert: "?"
        min: 0
        re: !!perl/hash:RE_method_re 
          a: 0
          dba: escape__S_236Cur_Ly
          i: 0
          min: 0
          name: before
          nobind: 1
          r: 1
          re: !!perl/hash:RE 
            decl: []

            min: 1
            re: !!perl/hash:RE_string 
              a: 0
              dba: escape__S_236Cur_Ly
              i: 0
              min: 1
              r: 1
              s: 0
              text: "{"
          s: 0
      - !!perl/hash:RE_bracket 
        decl: []

        min: 12345
        re: !!perl/hash:RE_sequence 
          a: 0
          dba: escape__S_236Cur_Ly
          i: 0
          lang: ($::LANG{'MAIN'})
          min: 12345
          r: 1
          s: 0
          zyg: 
            - !!perl/hash:RE_decl 
              a: 0
              dba: escape__S_236Cur_Ly
              i: 0
              lang: ($::LANG{'MAIN'})
              max: 0
              min: 0
              noquant: 1
              r: 1
              s: 0
              text: "my $newlang = ($::LANG{'MAIN'});  $C = $C->cursor_fresh($newlang); "
            - !!perl/hash:RE_method 
              a: 0
              dba: escape__S_236Cur_Ly
              i: 0
              lang: ($::LANG{'MAIN'})
              min: 12345
              name: block
              r: 1
              rest: ''
              s: 0
RETREE_END
}
} ## end role

{ package STD::Q::c0;
use Moose::Role ':all' => { -prefix => "moose_" };
my $retree;
##         token escape__S_237Cur_Ly (:$sym is context<rw> = <{ }>)
##              token escape:sym<{ }> { <!> }

sub escape__S_237Cur_Ly__PEEK { $_[0]->_AUTOLEXpeek('escape__S_237Cur_Ly',$retree) }
sub escape__S_237Cur_Ly {
my $self = shift;
local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;
my %args = @_;
local $sym = $args{sym} // [qw({ })];


my $C = $self;
my $S = $C->{'_pos'};
$C->{'sym'} = $sym;

$self->_MATCHIFYr($S, "escape__S_237Cur_Ly", 
$C->_NOTBEFORE( sub { my $C=shift;
$C
})
);
}
BEGIN {
$retree = YAML::Syck::Load(<<'RETREE_END');
--- 
escape__S_237Cur_Ly: !!perl/hash:RE 
  decl: []

  kind: token
  min: 0
  pkg: ~
  re: !!perl/hash:RE_assertion 
    assert: "!"
    min: 0
    re: !!perl/hash:RE_noop 
      a: 0
      dba: escape__S_237Cur_Ly
      i: 0
      min: 0
      nobind: 1
      r: 1
      s: 0
RETREE_END
}
} ## end role

{ package STD::Q::s1;
use Moose::Role ':all' => { -prefix => "moose_" };
my $retree;
##         token escape__S_238Dollar (:$sym is context<rw> = <$>)
##              token escape:sym<$> {
##                  :my $QSIGIL is context = '$';
##                  <?before '$'>
##                  [ :lang(%*LANG<MAIN>) <EXPR(item %methodcall)> ] || <.panic: "Non-variable \$ must be backslashed">
##              }

sub escape__S_238Dollar__PEEK { $_[0]->_AUTOLEXpeek('escape__S_238Dollar',$retree) }
sub escape__S_238Dollar {
my $self = shift;
local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;
my %args = @_;
local $sym = $args{sym} // q($);
local $::QSIGIL = '$';


my $C = $self;
my $S = $C->{'_pos'};
$C->{'sym'} = $sym;

$self->_MATCHIFYr($S, "escape__S_238Dollar", 
do { my @gather;
eval { push @gather, do {
if (my ($C) = ($C->before(sub { my $C=shift;
$C->_EXACT('$')
}))) {
$C->_BRACKETr( sub { my $C=shift;
my $newlang = ($::LANG{'MAIN'});  $C = $C->cursor_fresh($newlang); ;$C->_SUBSUMEr(['EXPR'], sub {
my $C = shift;
$C->EXPR(\%methodcall)
})
});
}
else {
();
}
}} // do {die $@ if $@ and $@ !~ /ABORT/;1} 
or
eval { push @gather, $C->panic("Non-variable \$ must be backslashed")} or do { die $@ if $@ };
@gather;
}
);
}
BEGIN {
$retree = YAML::Syck::Load(<<'RETREE_END');
--- 
escape__S_238Dollar: !!perl/hash:RE 
  decl: 
    - !!perl/hash:RE_decl 
      a: 0
      dba: escape__S_238Dollar
      i: 0
      max: 0
      min: 0
      r: 1
      s: 0
      text: my $QSIGIL is context = '$'
  kind: token
  min: 0
  pkg: ~
  re: !!perl/hash:RE_first 
    a: 0
    dba: escape__S_238Dollar
    i: 0
    min: 0
    r: 1
    s: 0
    zyg: 
      - !!perl/hash:RE_sequence 
        a: 0
        dba: escape__S_238Dollar
        i: 0
        min: 0
        r: 1
        s: 0
        zyg: 
          - !!perl/hash:RE_assertion 
            assert: "?"
            min: 0
            re: !!perl/hash:RE_method_re 
              a: 0
              dba: escape__S_238Dollar
              i: 0
              min: 0
              name: before
              nobind: 1
              r: 1
              re: !!perl/hash:RE 
                decl: []

                min: 1
                re: !!perl/hash:RE_string 
                  a: 0
                  dba: escape__S_238Dollar
                  i: 0
                  min: 1
                  r: 1
                  s: 0
                  text: $
              s: 0
          - !!perl/hash:RE_bracket 
            decl: []

            min: 0
            re: !!perl/hash:RE_sequence 
              a: 0
              dba: escape__S_238Dollar
              i: 0
              lang: ($::LANG{'MAIN'})
              min: 0
              r: 1
              s: 0
              zyg: 
                - !!perl/hash:RE_decl 
                  a: 0
                  dba: escape__S_238Dollar
                  i: 0
                  lang: ($::LANG{'MAIN'})
                  max: 0
                  min: 0
                  noquant: 1
                  r: 1
                  s: 0
                  text: "my $newlang = ($::LANG{'MAIN'});  $C = $C->cursor_fresh($newlang); "
                - !!perl/hash:RE_method 
                  min: 0
                  name: EXPR
                  rest: (item %methodcall)
      - !!perl/hash:RE_method 
        min: 0
        name: panic
        nobind: 1
        rest: ("Non-variable \$ must be backslashed")
RETREE_END
}
} ## end role

{ package STD::Q::s0;
use Moose::Role ':all' => { -prefix => "moose_" };
my $retree;
##         token escape__S_239Dollar (:$sym is context<rw> = <$>)
##              token escape:sym<$> { <!> }

sub escape__S_239Dollar__PEEK { $_[0]->_AUTOLEXpeek('escape__S_239Dollar',$retree) }
sub escape__S_239Dollar {
my $self = shift;
local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;
my %args = @_;
local $sym = $args{sym} // q($);


my $C = $self;
my $S = $C->{'_pos'};
$C->{'sym'} = $sym;

$self->_MATCHIFYr($S, "escape__S_239Dollar", 
$C->_NOTBEFORE( sub { my $C=shift;
$C
})
);
}
BEGIN {
$retree = YAML::Syck::Load(<<'RETREE_END');
--- 
escape__S_239Dollar: !!perl/hash:RE 
  decl: []

  kind: token
  min: 0
  pkg: ~
  re: !!perl/hash:RE_assertion 
    assert: "!"
    min: 0
    re: !!perl/hash:RE_noop 
      a: 0
      dba: escape__S_239Dollar
      i: 0
      min: 0
      nobind: 1
      r: 1
      s: 0
RETREE_END
}
} ## end role

{ package STD::Q::a1;
use Moose::Role ':all' => { -prefix => "moose_" };
my $retree;
##         token escape__S_240At (:$sym is context<rw> = <@>)
##              token escape:sym<@> {
##                  :my $QSIGIL is context<rw> = '@';
##                  <?before '@'>
##                  [ :lang(%*LANG<MAIN>) <EXPR(item %methodcall)> | <!> ] # trap ABORTBRANCH from variable's ::
##              }

sub escape__S_240At__PEEK { $_[0]->_AUTOLEXpeek('escape__S_240At',$retree) }
sub escape__S_240At {
my $self = shift;
local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;
my %args = @_;
local $sym = $args{sym} // q(@);
local $::QSIGIL = '@';


my $C = $self;
my $S = $C->{'_pos'};
$C->{'sym'} = $sym;

$self->_MATCHIFYr($S, "escape__S_240At", 
do {
if (my ($C) = ($C->before(sub { my $C=shift;
$C->_EXACT('@')
}))) {
$C->_BRACKETr( sub { my $C=shift;
do {
my @result = eval {
my $trystate;
my ($tag, $try);
my @try;
my $relex;

my $fate;
if ($fate = $C->{'_fate'} and $fate->[1] eq 'escape__S_240At_02') {
$C->deb("Fate passed to escape__S_240At_02: ", ::fatestr($fate)) if $::DEBUG & DEBUG::fates;
($C->{'_fate'}, $tag, $try) = @$fate;
@try = ($try);
}

my @gather = ();
for (;;) {
if (not @try) {
$relex //= $C->cursor_fate('STD::Q::a1', 'escape__S_240At_02', $retree);
@try = $relex->($C, $trystate);
}
last unless @try;
$try = shift(@try) // next;

if (ref $try eq 'ARRAY') {
($C->{'_fate'}, $tag, $try) = @$try;	# next candidate fate
}

$C->deb("escape__S_240At_02 trying $tag $try") if $::DEBUG & DEBUG::try_processing;
push @gather, ((
sub { my $C=shift;
my $newlang = ($::LANG{'MAIN'});  $C = $C->cursor_fresh($newlang); ;$C->_SUBSUMEr(['EXPR'], sub {
my $C = shift;
$C->EXPR(\%methodcall)
})
},
sub { my $C=shift;
$C->_NOTBEFORE( sub { my $C=shift;
$C
})
},
)[$try])->($C);
last if @gather;
}
@gather;
};
if (@result) {
@result;
}
elsif ($@) {
my ($first) = $@ =~ /(^.*)/;
$self->deb("CAUGHT $first") if $::DEBUG & DEBUG::trace_call;
die $@ if $@ !~ /^ABORTBRANCH/;
();
}
else {
();
}
}

});
}
else {
();
}
}
);
}
BEGIN {
$retree = YAML::Syck::Load(<<'RETREE_END');
--- 
escape__S_240At: !!perl/hash:RE 
  decl: 
    - !!perl/hash:RE_decl 
      a: 0
      dba: escape__S_240At
      i: 0
      max: 0
      min: 0
      r: 1
      s: 0
      text: my $QSIGIL is context<rw> = '@'
  kind: token
  min: 0
  pkg: ~
  re: !!perl/hash:RE_sequence 
    a: 0
    dba: escape__S_240At
    i: 0
    min: 0
    r: 1
    s: 0
    zyg: 
      - !!perl/hash:RE_assertion 
        assert: "?"
        min: 0
        re: !!perl/hash:RE_method_re 
          a: 0
          dba: escape__S_240At
          i: 0
          min: 0
          name: before
          nobind: 1
          r: 1
          re: !!perl/hash:RE 
            decl: []

            min: 1
            re: !!perl/hash:RE_string 
              a: 0
              dba: escape__S_240At
              i: 0
              min: 1
              r: 1
              s: 0
              text: "@"
          s: 0
      - !!perl/hash:RE_bracket 
        decl: []

        min: 0
        re: &1 !!perl/hash:RE_any 
          a: 0
          altname: escape__S_240At_02
          dba: escape__S_240At
          i: 0
          lang: ($::LANG{'MAIN'})
          min: 0
          name: escape__S_240At_02
          r: 1
          s: 0
          zyg: 
            - !!perl/hash:RE_sequence 
              a: 0
              alt: escape__S_240At_02 0
              dba: escape__S_240At
              i: 0
              lang: ($::LANG{'MAIN'})
              min: 0
              r: 1
              s: 0
              zyg: 
                - !!perl/hash:RE_decl 
                  a: 0
                  dba: escape__S_240At
                  i: 0
                  lang: ($::LANG{'MAIN'})
                  max: 0
                  min: 0
                  noquant: 1
                  r: 1
                  s: 0
                  text: "my $newlang = ($::LANG{'MAIN'});  $C = $C->cursor_fresh($newlang); "
                - !!perl/hash:RE_method 
                  min: 0
                  name: EXPR
                  rest: (item %methodcall)
            - !!perl/hash:RE_assertion 
              alt: escape__S_240At_02 1
              assert: "!"
              min: 0
              re: !!perl/hash:RE_noop 
                a: 0
                dba: escape__S_240At
                i: 0
                lang: ($::LANG{'MAIN'})
                min: 0
                nobind: 1
                r: 1
                s: 0
escape__S_240At_02: *1
RETREE_END
}
} ## end role

{ package STD::Q::a0;
use Moose::Role ':all' => { -prefix => "moose_" };
my $retree;
##         token escape__S_241At (:$sym is context<rw> = <@>)
##              token escape:sym<@> { <!> }

sub escape__S_241At__PEEK { $_[0]->_AUTOLEXpeek('escape__S_241At',$retree) }
sub escape__S_241At {
my $self = shift;
local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;
my %args = @_;
local $sym = $args{sym} // q(@);


my $C = $self;
my $S = $C->{'_pos'};
$C->{'sym'} = $sym;

$self->_MATCHIFYr($S, "escape__S_241At", 
$C->_NOTBEFORE( sub { my $C=shift;
$C
})
);
}
BEGIN {
$retree = YAML::Syck::Load(<<'RETREE_END');
--- 
escape__S_241At: !!perl/hash:RE 
  decl: []

  kind: token
  min: 0
  pkg: ~
  re: !!perl/hash:RE_assertion 
    assert: "!"
    min: 0
    re: !!perl/hash:RE_noop 
      a: 0
      dba: escape__S_241At
      i: 0
      min: 0
      nobind: 1
      r: 1
      s: 0
RETREE_END
}
} ## end role

{ package STD::Q::h1;
use Moose::Role ':all' => { -prefix => "moose_" };
my $retree;
##         token escape__S_242Percent (:$sym is context<rw> = <%>)
##              token escape:sym<%> {
##                  :my $QSIGIL is context<rw> = '%';
##                  <?before '%'>
##                  [ :lang(%*LANG<MAIN>) <EXPR(item %methodcall)> | <!> ]
##              }

sub escape__S_242Percent__PEEK { $_[0]->_AUTOLEXpeek('escape__S_242Percent',$retree) }
sub escape__S_242Percent {
my $self = shift;
local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;
my %args = @_;
local $sym = $args{sym} // q(%);
local $::QSIGIL = '%';


my $C = $self;
my $S = $C->{'_pos'};
$C->{'sym'} = $sym;

$self->_MATCHIFYr($S, "escape__S_242Percent", 
do {
if (my ($C) = ($C->before(sub { my $C=shift;
$C->_EXACT('%')
}))) {
$C->_BRACKETr( sub { my $C=shift;
do {
my @result = eval {
my $trystate;
my ($tag, $try);
my @try;
my $relex;

my $fate;
if ($fate = $C->{'_fate'} and $fate->[1] eq 'escape__S_242Percent_02') {
$C->deb("Fate passed to escape__S_242Percent_02: ", ::fatestr($fate)) if $::DEBUG & DEBUG::fates;
($C->{'_fate'}, $tag, $try) = @$fate;
@try = ($try);
}

my @gather = ();
for (;;) {
if (not @try) {
$relex //= $C->cursor_fate('STD::Q::h1', 'escape__S_242Percent_02', $retree);
@try = $relex->($C, $trystate);
}
last unless @try;
$try = shift(@try) // next;

if (ref $try eq 'ARRAY') {
($C->{'_fate'}, $tag, $try) = @$try;	# next candidate fate
}

$C->deb("escape__S_242Percent_02 trying $tag $try") if $::DEBUG & DEBUG::try_processing;
push @gather, ((
sub { my $C=shift;
my $newlang = ($::LANG{'MAIN'});  $C = $C->cursor_fresh($newlang); ;$C->_SUBSUMEr(['EXPR'], sub {
my $C = shift;
$C->EXPR(\%methodcall)
})
},
sub { my $C=shift;
$C->_NOTBEFORE( sub { my $C=shift;
$C
})
},
)[$try])->($C);
last if @gather;
}
@gather;
};
if (@result) {
@result;
}
elsif ($@) {
my ($first) = $@ =~ /(^.*)/;
$self->deb("CAUGHT $first") if $::DEBUG & DEBUG::trace_call;
die $@ if $@ !~ /^ABORTBRANCH/;
();
}
else {
();
}
}

});
}
else {
();
}
}
);
}
BEGIN {
$retree = YAML::Syck::Load(<<'RETREE_END');
--- 
escape__S_242Percent: !!perl/hash:RE 
  decl: 
    - !!perl/hash:RE_decl 
      a: 0
      dba: escape__S_242Percent
      i: 0
      max: 0
      min: 0
      r: 1
      s: 0
      text: my $QSIGIL is context<rw> = '%'
  kind: token
  min: 0
  pkg: ~
  re: !!perl/hash:RE_sequence 
    a: 0
    dba: escape__S_242Percent
    i: 0
    min: 0
    r: 1
    s: 0
    zyg: 
      - !!perl/hash:RE_assertion 
        assert: "?"
        min: 0
        re: !!perl/hash:RE_method_re 
          a: 0
          dba: escape__S_242Percent
          i: 0
          min: 0
          name: before
          nobind: 1
          r: 1
          re: !!perl/hash:RE 
            decl: []

            min: 1
            re: !!perl/hash:RE_string 
              a: 0
              dba: escape__S_242Percent
              i: 0
              min: 1
              r: 1
              s: 0
              text: "%"
          s: 0
      - !!perl/hash:RE_bracket 
        decl: []

        min: 0
        re: &1 !!perl/hash:RE_any 
          a: 0
          altname: escape__S_242Percent_02
          dba: escape__S_242Percent
          i: 0
          lang: ($::LANG{'MAIN'})
          min: 0
          name: escape__S_242Percent_02
          r: 1
          s: 0
          zyg: 
            - !!perl/hash:RE_sequence 
              a: 0
              alt: escape__S_242Percent_02 0
              dba: escape__S_242Percent
              i: 0
              lang: ($::LANG{'MAIN'})
              min: 0
              r: 1
              s: 0
              zyg: 
                - !!perl/hash:RE_decl 
                  a: 0
                  dba: escape__S_242Percent
                  i: 0
                  lang: ($::LANG{'MAIN'})
                  max: 0
                  min: 0
                  noquant: 1
                  r: 1
                  s: 0
                  text: "my $newlang = ($::LANG{'MAIN'});  $C = $C->cursor_fresh($newlang); "
                - !!perl/hash:RE_method 
                  min: 0
                  name: EXPR
                  rest: (item %methodcall)
            - !!perl/hash:RE_assertion 
              alt: escape__S_242Percent_02 1
              assert: "!"
              min: 0
              re: !!perl/hash:RE_noop 
                a: 0
                dba: escape__S_242Percent
                i: 0
                lang: ($::LANG{'MAIN'})
                min: 0
                nobind: 1
                r: 1
                s: 0
escape__S_242Percent_02: *1
RETREE_END
}
} ## end role

{ package STD::Q::h0;
use Moose::Role ':all' => { -prefix => "moose_" };
my $retree;
##         token escape__S_243Percent (:$sym is context<rw> = <%>)
##              token escape:sym<%> { <!> }

sub escape__S_243Percent__PEEK { $_[0]->_AUTOLEXpeek('escape__S_243Percent',$retree) }
sub escape__S_243Percent {
my $self = shift;
local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;
my %args = @_;
local $sym = $args{sym} // q(%);


my $C = $self;
my $S = $C->{'_pos'};
$C->{'sym'} = $sym;

$self->_MATCHIFYr($S, "escape__S_243Percent", 
$C->_NOTBEFORE( sub { my $C=shift;
$C
})
);
}
BEGIN {
$retree = YAML::Syck::Load(<<'RETREE_END');
--- 
escape__S_243Percent: !!perl/hash:RE 
  decl: []

  kind: token
  min: 0
  pkg: ~
  re: !!perl/hash:RE_assertion 
    assert: "!"
    min: 0
    re: !!perl/hash:RE_noop 
      a: 0
      dba: escape__S_243Percent
      i: 0
      min: 0
      nobind: 1
      r: 1
      s: 0
RETREE_END
}
} ## end role

{ package STD::Q::f1;
use Moose::Role ':all' => { -prefix => "moose_" };
my $retree;
##         token escape__S_244Amp (:$sym is context<rw> = <&>)
##              token escape:sym<&> {
##                  :my $QSIGIL is context<rw> = '&';
##                  <?before '&'>
##                  [ :lang(%*LANG<MAIN>) <EXPR(item %methodcall)> | <!> ]
##              }

sub escape__S_244Amp__PEEK { $_[0]->_AUTOLEXpeek('escape__S_244Amp',$retree) }
sub escape__S_244Amp {
my $self = shift;
local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;
my %args = @_;
local $sym = $args{sym} // q(&);
local $::QSIGIL = '&';


my $C = $self;
my $S = $C->{'_pos'};
$C->{'sym'} = $sym;

$self->_MATCHIFYr($S, "escape__S_244Amp", 
do {
if (my ($C) = ($C->before(sub { my $C=shift;
$C->_EXACT('&')
}))) {
$C->_BRACKETr( sub { my $C=shift;
do {
my @result = eval {
my $trystate;
my ($tag, $try);
my @try;
my $relex;

my $fate;
if ($fate = $C->{'_fate'} and $fate->[1] eq 'escape__S_244Amp_02') {
$C->deb("Fate passed to escape__S_244Amp_02: ", ::fatestr($fate)) if $::DEBUG & DEBUG::fates;
($C->{'_fate'}, $tag, $try) = @$fate;
@try = ($try);
}

my @gather = ();
for (;;) {
if (not @try) {
$relex //= $C->cursor_fate('STD::Q::f1', 'escape__S_244Amp_02', $retree);
@try = $relex->($C, $trystate);
}
last unless @try;
$try = shift(@try) // next;

if (ref $try eq 'ARRAY') {
($C->{'_fate'}, $tag, $try) = @$try;	# next candidate fate
}

$C->deb("escape__S_244Amp_02 trying $tag $try") if $::DEBUG & DEBUG::try_processing;
push @gather, ((
sub { my $C=shift;
my $newlang = ($::LANG{'MAIN'});  $C = $C->cursor_fresh($newlang); ;$C->_SUBSUMEr(['EXPR'], sub {
my $C = shift;
$C->EXPR(\%methodcall)
})
},
sub { my $C=shift;
$C->_NOTBEFORE( sub { my $C=shift;
$C
})
},
)[$try])->($C);
last if @gather;
}
@gather;
};
if (@result) {
@result;
}
elsif ($@) {
my ($first) = $@ =~ /(^.*)/;
$self->deb("CAUGHT $first") if $::DEBUG & DEBUG::trace_call;
die $@ if $@ !~ /^ABORTBRANCH/;
();
}
else {
();
}
}

});
}
else {
();
}
}
);
}
BEGIN {
$retree = YAML::Syck::Load(<<'RETREE_END');
--- 
escape__S_244Amp: !!perl/hash:RE 
  decl: 
    - !!perl/hash:RE_decl 
      a: 0
      dba: escape__S_244Amp
      i: 0
      max: 0
      min: 0
      r: 1
      s: 0
      text: my $QSIGIL is context<rw> = '&'
  kind: token
  min: 0
  pkg: ~
  re: !!perl/hash:RE_sequence 
    a: 0
    dba: escape__S_244Amp
    i: 0
    min: 0
    r: 1
    s: 0
    zyg: 
      - !!perl/hash:RE_assertion 
        assert: "?"
        min: 0
        re: !!perl/hash:RE_method_re 
          a: 0
          dba: escape__S_244Amp
          i: 0
          min: 0
          name: before
          nobind: 1
          r: 1
          re: !!perl/hash:RE 
            decl: []

            min: 1
            re: !!perl/hash:RE_string 
              a: 0
              dba: escape__S_244Amp
              i: 0
              min: 1
              r: 1
              s: 0
              text: "&"
          s: 0
      - !!perl/hash:RE_bracket 
        decl: []

        min: 0
        re: &1 !!perl/hash:RE_any 
          a: 0
          altname: escape__S_244Amp_02
          dba: escape__S_244Amp
          i: 0
          lang: ($::LANG{'MAIN'})
          min: 0
          name: escape__S_244Amp_02
          r: 1
          s: 0
          zyg: 
            - !!perl/hash:RE_sequence 
              a: 0
              alt: escape__S_244Amp_02 0
              dba: escape__S_244Amp
              i: 0
              lang: ($::LANG{'MAIN'})
              min: 0
              r: 1
              s: 0
              zyg: 
                - !!perl/hash:RE_decl 
                  a: 0
                  dba: escape__S_244Amp
                  i: 0
                  lang: ($::LANG{'MAIN'})
                  max: 0
                  min: 0
                  noquant: 1
                  r: 1
                  s: 0
                  text: "my $newlang = ($::LANG{'MAIN'});  $C = $C->cursor_fresh($newlang); "
                - !!perl/hash:RE_method 
                  min: 0
                  name: EXPR
                  rest: (item %methodcall)
            - !!perl/hash:RE_assertion 
              alt: escape__S_244Amp_02 1
              assert: "!"
              min: 0
              re: !!perl/hash:RE_noop 
                a: 0
                dba: escape__S_244Amp
                i: 0
                lang: ($::LANG{'MAIN'})
                min: 0
                nobind: 1
                r: 1
                s: 0
escape__S_244Amp_02: *1
RETREE_END
}
} ## end role

{ package STD::Q::f0;
use Moose::Role ':all' => { -prefix => "moose_" };
my $retree;
##         token escape__S_245Amp (:$sym is context<rw> = <&>)
##              token escape:sym<&> { <!> }

sub escape__S_245Amp__PEEK { $_[0]->_AUTOLEXpeek('escape__S_245Amp',$retree) }
sub escape__S_245Amp {
my $self = shift;
local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;
my %args = @_;
local $sym = $args{sym} // q(&);


my $C = $self;
my $S = $C->{'_pos'};
$C->{'sym'} = $sym;

$self->_MATCHIFYr($S, "escape__S_245Amp", 
$C->_NOTBEFORE( sub { my $C=shift;
$C
})
);
}
BEGIN {
$retree = YAML::Syck::Load(<<'RETREE_END');
--- 
escape__S_245Amp: !!perl/hash:RE 
  decl: []

  kind: token
  min: 0
  pkg: ~
  re: !!perl/hash:RE_assertion 
    assert: "!"
    min: 0
    re: !!perl/hash:RE_noop 
      a: 0
      dba: escape__S_245Amp
      i: 0
      min: 0
      nobind: 1
      r: 1
      s: 0
RETREE_END
}
} ## end role

{ package STD::Q::w1;
use Moose::Role ':all' => { -prefix => "moose_" };
my $retree;
##         method postprocess ($s)
sub postprocess {
my $self = shift;
my $s = shift;

$s->words }
} ## end role

{ package STD::Q::w0;
use Moose::Role ':all' => { -prefix => "moose_" };
my $retree;
##         method postprocess ($s)
sub postprocess {
my $self = shift;
my $s = shift;

$s }
} ## end role

{ package STD::Q::ww1;
use Moose::Role ':all' => { -prefix => "moose_" };
my $retree;
##         method postprocess ($s)
sub postprocess {
my $self = shift;
my $s = shift;

$s->words }
} ## end role

{ package STD::Q::ww0;
use Moose::Role ':all' => { -prefix => "moose_" };
my $retree;
##         method postprocess ($s)
sub postprocess {
my $self = shift;
my $s = shift;

$s }
} ## end role

{ package STD::Q::x1;
use Moose::Role ':all' => { -prefix => "moose_" };
my $retree;
##         method postprocess ($s)
sub postprocess {
my $self = shift;
my $s = shift;

$s->run }
} ## end role

{ package STD::Q::x0;
use Moose::Role ':all' => { -prefix => "moose_" };
my $retree;
##         method postprocess ($s)
sub postprocess {
my $self = shift;
my $s = shift;

$s }
} ## end role

{ package STD::Q::q;
use Moose::Role ':all' => { -prefix => "moose_" };
my $retree;
##         token stopper
##              token stopper { \' }

sub stopper__PEEK { $_[0]->_AUTOLEXpeek('stopper',$retree) }
sub stopper {
my $self = shift;
local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;


my $C = $self;
my $S = $C->{'_pos'};

$self->_MATCHIFYr($S, "stopper", 
$C->_EXACT('\'')
);
}

##         token escape__S_246Back (:$sym is context<rw> = <\\>)
##              token escape:sym<\\> { <sym> <item=backslash> }

sub escape__S_246Back__PEEK { $_[0]->_AUTOLEXpeek('escape__S_246Back',$retree) }
sub escape__S_246Back {
my $self = shift;
local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;
my %args = @_;
local $sym = $args{sym} // q(\\);


my $C = $self;
my $S = $C->{'_pos'};
$C->{'sym'} = $sym;

$self->_MATCHIFYr($S, "escape__S_246Back", 
do {
if (my ($C) = ($C->_PATTERN(qr/\G\\/))) {
$C->_SUBSUMEr(['item'], sub {
my $C = shift;
$C->backslash
});
}
else {
();
}
}
);
}

##         token backslash__S_247qq (:$sym is context<rw> = 'qq')
##              token backslash:qq { <?before 'q'> { $<quote> = $¢.cursor_fresh(%*LANG<MAIN>).quote(); } }

sub backslash__S_247qq__PEEK { $_[0]->_AUTOLEXpeek('backslash__S_247qq',$retree) }
sub backslash__S_247qq {
my $self = shift;
local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;
my %args = @_;
local $sym = $args{sym} // 'qq';


my $C = $self;
my $S = $C->{'_pos'};
$C->{'sym'} = $sym;

$self->_MATCHIFYr($S, "backslash__S_247qq", 
do {
if (my ($C) = ($C->before(sub { my $C=shift;
$C->_EXACT('q')
}))) {
scalar(do {
my $M = $C;  $M->{'quote'} = $C->cursor_fresh($::LANG{'MAIN'})->quote(); ;
}, $C);
}
else {
();
}
}
);
}
##         token backslash__S_248Back (:$sym is context<rw> = <\\>)
##              token backslash:sym<\\> { <text=sym> }

sub backslash__S_248Back__PEEK { $_[0]->_AUTOLEXpeek('backslash__S_248Back',$retree) }
sub backslash__S_248Back {
my $self = shift;
local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;
my %args = @_;
local $sym = $args{sym} // q(\\);


my $C = $self;
my $S = $C->{'_pos'};
$C->{'sym'} = $sym;

$self->_MATCHIFYr($S, "backslash__S_248Back", 
$C->_PATTERN(qr/\G\\/)
);
}
##         token backslash__S_249stopper (:$sym is context<rw> = 'stopper')
##              token backslash:stopper { <text=stopper> }

sub backslash__S_249stopper__PEEK { $_[0]->_AUTOLEXpeek('backslash__S_249stopper',$retree) }
sub backslash__S_249stopper {
my $self = shift;
local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;
my %args = @_;
local $sym = $args{sym} // 'stopper';


my $C = $self;
my $S = $C->{'_pos'};
$C->{'sym'} = $sym;

$self->_MATCHIFYr($S, "backslash__S_249stopper", 
$C->_SUBSUMEr(['text'], sub {
my $C = shift;
$C->stopper
})
);
}

# in single quotes, keep backslash on random character by default
##         token backslash__S_250misc (:$sym is context<rw> = 'misc')
##              token backslash:misc { {} (.) { $<text> = "\\" ~ $0.Str; } }

sub backslash__S_250misc__PEEK { $_[0]->_AUTOLEXpeek('backslash__S_250misc',$retree) }
sub backslash__S_250misc {
my $self = shift;
local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;
my %args = @_;
local $sym = $args{sym} // 'misc';


my $C = $self;
my $S = $C->{'_pos'};
$C->{'sym'} = $sym;

$self->_MATCHIFYr($S, "backslash__S_250misc", 
do {
if (my ($C) = (scalar(do {

}, $C))) {
do {
if (my ($C) = (    $C->_SUBSUMEr(['0'], sub {
my $C = shift;
do { $C->_PAREN( sub { my $C=shift;
$C->_PATTERN(qr/\G(?s:.)/)
})}
}))) {
scalar(do {
my $M = $C;  $M->{'text'} = "\\" . $C->{'0'}->Str; ;
}, $C);
}
else {
();
}
};
}
else {
();
}
}
);
}

sub multitweak { # begin tweaks
my $self = shift;
my ($k, $v) = @_;

if (0) {}
elsif ($k eq 'single' or $k eq 'q') {
my $q = $v;  $self->panic("Too late for :q") }
elsif ($k eq 'double' or $k eq 'qq') {
my $qq = $v;  $self->panic("Too late for :qq") }
else { die 'NOMATCH' }
} # end tweaks

BEGIN {
$retree = YAML::Syck::Load(<<'RETREE_END');
--- 
backslash__S_247qq: !!perl/hash:RE 
  decl: []

  kind: token
  min: 0
  pkg: ~
  re: !!perl/hash:RE_sequence 
    a: 0
    dba: backslash__S_247qq
    i: 0
    min: 0
    r: 1
    s: 0
    zyg: 
      - !!perl/hash:RE_assertion 
        assert: "?"
        min: 0
        re: !!perl/hash:RE_method_re 
          a: 0
          dba: backslash__S_247qq
          i: 0
          min: 0
          name: before
          nobind: 1
          r: 1
          re: !!perl/hash:RE 
            decl: []

            min: 1
            re: !!perl/hash:RE_string 
              a: 0
              dba: backslash__S_247qq
              i: 0
              min: 1
              r: 1
              s: 0
              text: q
          s: 0
      - !!perl/hash:RE_block 
        a: 0
        context: void
        dba: backslash__S_247qq
        i: 0
        min: 0
        r: 1
        s: 0
        text: " $<quote> = $¢.cursor_fresh(%*LANG<MAIN>).quote(); "
backslash__S_248Back: !!perl/hash:RE 
  decl: []

  kind: token
  min: 12345
  pkg: ~
  re: !!perl/hash:RE_bindnamed 
    a: 0
    atom: !!perl/hash:RE_method 
      a: 0
      dba: backslash__S_248Back
      i: 0
      min: 12345
      name: sym
      nobind: 1
      r: 1
      rest: ''
      s: 0
      sym: \
    dba: backslash__S_248Back
    i: 0
    min: 12345
    r: 1
    s: 0
    var: text
backslash__S_249stopper: !!perl/hash:RE 
  decl: []

  kind: token
  min: 12345
  pkg: ~
  re: !!perl/hash:RE_bindnamed 
    a: 0
    atom: !!perl/hash:RE_method 
      a: 0
      dba: backslash__S_249stopper
      i: 0
      min: 12345
      name: stopper
      nobind: 1
      r: 1
      rest: ''
      s: 0
    dba: backslash__S_249stopper
    i: 0
    min: 12345
    r: 1
    s: 0
    var: text
backslash__S_250misc: !!perl/hash:RE 
  decl: []

  kind: token
  min: 1
  pkg: ~
  re: !!perl/hash:RE_sequence 
    a: 0
    dba: backslash__S_250misc
    i: 0
    min: 1
    r: 1
    s: 0
    zyg: 
      - !!perl/hash:RE_block 
        a: 0
        context: void
        dba: backslash__S_250misc
        i: 0
        min: 0
        r: 1
        s: 0
        text: ''
      - !!perl/hash:RE_bindpos 
        atom: !!perl/hash:RE_paren 
          decl: []

          min: 1
          re: !!perl/hash:RE_meta 
            a: 0
            dba: backslash__S_250misc
            i: 0
            min: 1
            r: 1
            s: 0
            text: .
        min: 1
        var: 0
      - !!perl/hash:RE_block 
        a: 0
        context: void
        dba: backslash__S_250misc
        i: 0
        min: 0
        r: 1
        s: 0
        text: " $<text> = \"\\\\\" ~ $0.Str; "
escape__S_246Back: !!perl/hash:RE 
  decl: []

  kind: token
  min: 24690
  pkg: ~
  re: !!perl/hash:RE_sequence 
    a: 0
    dba: escape__S_246Back
    i: 0
    min: 24690
    r: 1
    s: 0
    zyg: 
      - !!perl/hash:RE_method 
        a: 0
        dba: escape__S_246Back
        i: 0
        min: 12345
        name: sym
        r: 1
        rest: ''
        s: 0
        sym: \
      - !!perl/hash:RE_bindnamed 
        a: 0
        atom: !!perl/hash:RE_method 
          a: 0
          dba: escape__S_246Back
          i: 0
          min: 12345
          name: backslash
          nobind: 1
          r: 1
          rest: ''
          s: 0
        dba: escape__S_246Back
        i: 0
        min: 12345
        r: 1
        s: 0
        var: item
stopper: !!perl/hash:RE 
  decl: []

  kind: token
  min: 1
  pkg: ~
  re: !!perl/hash:RE_string 
    a: 0
    dba: stopper
    i: 0
    min: 1
    r: 1
    s: 0
    text: "'"
RETREE_END
}
} ## end role

{ package STD::Q::qq;
use Moose::Role ':all' => { -prefix => "moose_" };
my $retree;
moose_with(qw(STD::Q::b1 STD::Q::c1 STD::Q::s1 STD::Q::a1 STD::Q::h1 STD::Q::f1));
##         token stopper
##              token stopper { \" }

sub stopper__PEEK { $_[0]->_AUTOLEXpeek('stopper',$retree) }
sub stopper {
my $self = shift;
local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;


my $C = $self;
my $S = $C->{'_pos'};

$self->_MATCHIFYr($S, "stopper", 
$C->_EXACT('"')
);
}
# in double quotes, omit backslash on random \W backslash by default
##         token backslash__S_251misc (:$sym is context<rw> = 'misc')
##              token backslash:misc { {} [ (\W) { $<text> = $0.Str; } | $<x>=(\w) <.panic("Unrecognized backslash sequence: '\\" ~ $<x>.Str ~ "'")> ] }

sub backslash__S_251misc__PEEK { $_[0]->_AUTOLEXpeek('backslash__S_251misc',$retree) }
sub backslash__S_251misc {
my $self = shift;
local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;
my %args = @_;
local $sym = $args{sym} // 'misc';


my $C = $self;
my $S = $C->{'_pos'};
$C->{'sym'} = $sym;

$self->_MATCHIFYr($S, "backslash__S_251misc", 
do {
if (my ($C) = (scalar(do {

}, $C))) {
$C->_BRACKETr( sub { my $C=shift;
do {
my @result = eval {
my $trystate;
my ($tag, $try);
my @try;
my $relex;

my $fate;
if ($fate = $C->{'_fate'} and $fate->[1] eq 'backslash__S_251misc_01') {
$C->deb("Fate passed to backslash__S_251misc_01: ", ::fatestr($fate)) if $::DEBUG & DEBUG::fates;
($C->{'_fate'}, $tag, $try) = @$fate;
@try = ($try);
}

my @gather = ();
for (;;) {
if (not @try) {
$relex //= $C->cursor_fate('STD::Q::qq', 'backslash__S_251misc_01', $retree);
@try = $relex->($C, $trystate);
}
last unless @try;
$try = shift(@try) // next;

if (ref $try eq 'ARRAY') {
($C->{'_fate'}, $tag, $try) = @$try;	# next candidate fate
}

$C->deb("backslash__S_251misc_01 trying $tag $try") if $::DEBUG & DEBUG::try_processing;
push @gather, ((
sub { my $C=shift;
do {
if (my ($C) = (    $C->_SUBSUMEr(['0'], sub {
my $C = shift;
do { $C->_PAREN( sub { my $C=shift;
$C->_NOTCHAR( sub { my $C=shift;
$C->_PATTERN(qr/\G\w/)
})
})}
}))) {
scalar(do {
my $M = $C;  $M->{'text'} = $C->{'0'}->Str; ;
}, $C);
}
else {
();
}
}
},
sub { my $C=shift;
do {
if (my ($C) = (    $C->_SUBSUMEr(['x'], sub {
my $C = shift;
do { $C->_PAREN( sub { my $C=shift;
$C->_PATTERN(qr/\G\w/)
})}
}))) {
do { my $M = $C;
$C->panic("Unrecognized backslash sequence: '\\" . $M->{'x'}->Str . "'")
; };
}
else {
();
}
}
},
)[$try])->($C);
last if @gather;
}
@gather;
};
if (@result) {
@result;
}
elsif ($@) {
my ($first) = $@ =~ /(^.*)/;
$self->deb("CAUGHT $first") if $::DEBUG & DEBUG::trace_call;
die $@ if $@ !~ /^ABORTBRANCH/;
();
}
else {
();
}
}

});
}
else {
();
}
}
);
}

sub multitweak { # begin tweaks
my $self = shift;
my ($k, $v) = @_;

if (0) {}
elsif ($k eq 'single' or $k eq 'q') {
my $q = $v;  $self->panic("Too late for :q") }
elsif ($k eq 'double' or $k eq 'qq') {
my $qq = $v;  $self->panic("Too late for :qq") }
else { die 'NOMATCH' }
} # end tweaks

BEGIN {
$retree = YAML::Syck::Load(<<'RETREE_END');
--- 
backslash__S_251misc: !!perl/hash:RE 
  decl: []

  kind: token
  min: 1
  pkg: ~
  re: !!perl/hash:RE_sequence 
    a: 0
    dba: backslash__S_251misc
    i: 0
    min: 1
    r: 1
    s: 0
    zyg: 
      - !!perl/hash:RE_block 
        a: 0
        context: void
        dba: backslash__S_251misc
        i: 0
        min: 0
        r: 1
        s: 0
        text: ''
      - !!perl/hash:RE_bracket 
        decl: []

        min: 1
        re: &1 !!perl/hash:RE_any 
          a: 0
          altname: backslash__S_251misc_01
          dba: backslash__S_251misc
          i: 0
          min: 1
          name: backslash__S_251misc_01
          r: 1
          s: 0
          zyg: 
            - !!perl/hash:RE_sequence 
              a: 0
              alt: backslash__S_251misc_01 0
              dba: backslash__S_251misc
              i: 0
              min: 1
              r: 1
              s: 0
              zyg: 
                - !!perl/hash:RE_bindpos 
                  atom: !!perl/hash:RE_paren 
                    decl: []

                    min: 1
                    re: !!perl/hash:RE_meta 
                      a: 0
                      dba: backslash__S_251misc
                      i: 0
                      min: 1
                      r: 1
                      s: 0
                      text: \W
                  min: 1
                  var: 0
                - !!perl/hash:RE_block 
                  a: 0
                  context: void
                  dba: backslash__S_251misc
                  i: 0
                  min: 0
                  r: 1
                  s: 0
                  text: " $<text> = $0.Str; "
            - !!perl/hash:RE_sequence 
              a: 0
              alt: backslash__S_251misc_01 1
              dba: backslash__S_251misc
              i: 0
              min: 1
              r: 1
              s: 0
              zyg: 
                - !!perl/hash:RE_bindnamed 
                  a: 0
                  atom: !!perl/hash:RE_paren 
                    decl: []

                    min: 1
                    nobind: 1
                    re: !!perl/hash:RE_meta 
                      a: 0
                      dba: backslash__S_251misc
                      i: 0
                      min: 1
                      r: 1
                      s: 0
                      text: \w
                  dba: backslash__S_251misc
                  i: 0
                  min: 1
                  r: 1
                  s: 0
                  var: x
                - !!perl/hash:RE_method 
                  min: 0
                  name: panic
                  nobind: 1
                  rest: "(\"Unrecognized backslash sequence: '\\\\\" ~ $<x>.Str ~ \"'\")"
backslash__S_251misc_01: *1
stopper: !!perl/hash:RE 
  decl: []

  kind: token
  min: 1
  pkg: ~
  re: !!perl/hash:RE_string 
    a: 0
    dba: stopper
    i: 0
    min: 1
    r: 1
    s: 0
    text: "\""
RETREE_END
}
} ## end role

{ package STD::Q::p5;
use Moose::Role ':all' => { -prefix => "moose_" };
my $retree;
sub multitweak { # begin tweaks
my $self = shift;
my ($k, $v) = @_;

if (0) {}
elsif ($k eq 'g') {
my $g = $v;  $self }
elsif ($k eq 'i') {
my $i = $v;  $self }
elsif ($k eq 'm') {
my $m = $v;  $self }
elsif ($k eq 's') {
my $s = $v;  $self }
elsif ($k eq 'x') {
my $x = $v;  $self }
elsif ($k eq 'p') {
my $p = $v;  $self }
elsif ($k eq 'c') {
my $c = $v;  $self }
else { die 'NOMATCH' }
} # end tweaks
} ## end role

sub multitweak { # begin tweaks
my $self = shift;
my ($k, $v) = @_;

if (0) {}

elsif ($k eq 'single' or $k eq 'q') {
my $q = $v;  $self->truly($q,':q'); $self->mixin( 'STD::Q::q' ); }

elsif ($k eq 'double' or $k eq 'qq') {
my $qq = $v;  $self->truly($qq, ':qq'); $self->mixin( 'STD::Q::qq' ); }

elsif ($k eq 'backslash' or $k eq 'b') {
my $b = $v;  $self->mixin($b ? 'STD::Q::b1' : 'STD::Q::b0') }
elsif ($k eq 'scalar' or $k eq 's') {
my $s = $v;  $self->mixin($s ? 'STD::Q::s1' : 'STD::Q::s0') }
elsif ($k eq 'array' or $k eq 'a') {
my $a = $v;  $self->mixin($a ? 'STD::Q::a1' : 'STD::Q::a0') }
elsif ($k eq 'hash' or $k eq 'h') {
my $h = $v;  $self->mixin($h ? 'STD::Q::h1' : 'STD::Q::h0') }
elsif ($k eq 'function' or $k eq 'f') {
my $f = $v;  $self->mixin($f ? 'STD::Q::f1' : 'STD::Q::f0') }
elsif ($k eq 'closure' or $k eq 'c') {
my $c = $v;  $self->mixin($c ? 'STD::Q::c1' : 'STD::Q::c0') }

elsif ($k eq 'exec' or $k eq 'x') {
my $x = $v;  $self->mixin($x ? 'STD::Q::x1' : 'STD::Q::x0') }
elsif ($k eq 'words' or $k eq 'w') {
my $w = $v;  $self->mixin($w ? 'STD::Q::w1' : 'STD::Q::w0') }
elsif ($k eq 'quotewords' or $k eq 'ww') {
my $ww = $v;  $self->mixin($ww ? 'STD::Q::ww1' : 'STD::Q::ww0') }

elsif ($k eq 'heredoc' or $k eq 'to') {
my $to = $v;  $self->truly($to, ':to'); $self->cursor_herelang; }

elsif ($k eq 'regex') {
my $regex = $v; 
return $::LANG{'Regex'};
}

elsif ($k eq 'trans') {
my $trans = $v; 
return $::LANG{'Trans'};
}

elsif (1) {
my %x = ($k, $v); 
my @k = keys(%x);
$self->panic("Unrecognized quote modifier: " . join('',@k));
}
else { die 'NOMATCH' }
} # end tweaks


} ## end grammar

{ package STD::Quasi;
use Moose ':all' => { -prefix => "moose_" };
my $retree;
moose_extends(qw(STD));##     token term__S_252unquote (:$sym is context<rw> = 'unquote')
##          token term:unquote {
##              :my $QUASIMODO is context = 0;
##              <starter><starter><starter> <EXPR> <stopper><stopper><stopper>
##          }

sub term__S_252unquote__PEEK { $_[0]->_AUTOLEXpeek('term__S_252unquote',$retree) }
sub term__S_252unquote {
my $self = shift;
local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;
my %args = @_;
local $sym = $args{sym} // 'unquote';
local $::QUASIMODO = 0;


my $C = $self;
my $S = $C->{'_pos'};
$C->{'stopper'} = [];
$C->{'starter'} = [];
$C->{'sym'} = $sym;

$self->_MATCHIFYr($S, "term__S_252unquote", 
do {
if (my ($C) = ($C->_SUBSUMEr(['starter'], sub {
my $C = shift;
$C->starter
}))) {
do {
if (my ($C) = ($C->_SUBSUMEr(['starter'], sub {
my $C = shift;
$C->starter
}))) {
do {
if (my ($C) = ($C->_SUBSUMEr(['starter'], sub {
my $C = shift;
$C->starter
}))) {
do {
if (my ($C) = ($C->_SUBSUMEr(['EXPR'], sub {
my $C = shift;
$C->EXPR
}))) {
do {
if (my ($C) = ($C->_SUBSUMEr(['stopper'], sub {
my $C = shift;
$C->stopper
}))) {
do {
if (my ($C) = ($C->_SUBSUMEr(['stopper'], sub {
my $C = shift;
$C->stopper
}))) {
$C->_SUBSUMEr(['stopper'], sub {
my $C = shift;
$C->stopper
});
}
else {
();
}
};
}
else {
();
}
};
}
else {
();
}
};
}
else {
();
}
};
}
else {
();
}
};
}
else {
();
}
}
);
}

sub multitweak { # begin tweaks
my $self = shift;
my ($k, $v) = @_;

if (0) {}
elsif ($k eq 'ast') {
my $ast = $v;  $self; } # XXX some transformer operating on the normal AST?
elsif ($k eq 'lang') {
my $lang = $v;  $self->cursor_fresh( $lang ); }
elsif ($k eq 'unquote') {
my $unquote = $v;  $self; } # XXX needs to override unquote
elsif ($k eq 'COMPILING') {
my $COMPILING = $v;  $::QUASIMODO = 1; $self; } # XXX needs to lazify the lexical lookups somehow

elsif (1) {
my %x = ($k, $v); 
my @k = keys(%x);
$self->panic("Unrecognized quasiquote modifier: " . join('',@k));
}
else { die 'NOMATCH' }
} # end tweaks

BEGIN {
$retree = YAML::Syck::Load(<<'RETREE_END');
--- 
term__S_252unquote: !!perl/hash:RE 
  decl: 
    - !!perl/hash:RE_decl 
      a: 0
      dba: term__S_252unquote
      i: 0
      max: 0
      min: 0
      r: 1
      s: 0
      text: my $QUASIMODO is context = 0
  kind: token
  min: 86415
  pkg: ~
  re: !!perl/hash:RE_sequence 
    a: 0
    dba: term__S_252unquote
    i: 0
    min: 86415
    r: 1
    s: 0
    zyg: 
      - !!perl/hash:RE_method 
        a: 0
        dba: term__S_252unquote
        i: 0
        min: 12345
        name: starter
        r: 1
        rest: ''
        s: 0
      - !!perl/hash:RE_method 
        a: 0
        dba: term__S_252unquote
        i: 0
        min: 12345
        name: starter
        r: 1
        rest: ''
        s: 0
      - !!perl/hash:RE_method 
        a: 0
        dba: term__S_252unquote
        i: 0
        min: 12345
        name: starter
        r: 1
        rest: ''
        s: 0
      - !!perl/hash:RE_method 
        a: 0
        dba: term__S_252unquote
        i: 0
        min: 12345
        name: EXPR
        r: 1
        rest: ''
        s: 0
      - !!perl/hash:RE_method 
        a: 0
        dba: term__S_252unquote
        i: 0
        min: 12345
        name: stopper
        r: 1
        rest: ''
        s: 0
      - !!perl/hash:RE_method 
        a: 0
        dba: term__S_252unquote
        i: 0
        min: 12345
        name: stopper
        r: 1
        rest: ''
        s: 0
      - !!perl/hash:RE_method 
        a: 0
        dba: term__S_252unquote
        i: 0
        min: 12345
        name: stopper
        r: 1
        rest: ''
        s: 0
RETREE_END
}
} ## end grammar

###########################
# Captures and Signatures #
###########################

## token capterm
##      token capterm {
##          '\\'
##          [
##          | '(' <capture>? ')'
##          | <?before \S> <termish>
##          ]
##      }

sub capterm__PEEK { $_[0]->_AUTOLEXpeek('capterm',$retree) }
sub capterm {
my $self = shift;
local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;


my $C = $self;
my $S = $C->{'_pos'};
$C->{'capture'} = [];

$self->_MATCHIFYr($S, "capterm", 
do {
if (my ($C) = ($C->_EXACT('\\'))) {
$C->_BRACKETr( sub { my $C=shift;
do {
my @result = eval {
my $trystate;
my ($tag, $try);
my @try;
my $relex;

my $fate;
if ($fate = $C->{'_fate'} and $fate->[1] eq 'capterm_01') {
$C->deb("Fate passed to capterm_01: ", ::fatestr($fate)) if $::DEBUG & DEBUG::fates;
($C->{'_fate'}, $tag, $try) = @$fate;
@try = ($try);
}

my @gather = ();
for (;;) {
if (not @try) {
$relex //= $C->cursor_fate('STD', 'capterm_01', $retree);
@try = $relex->($C, $trystate);
}
last unless @try;
$try = shift(@try) // next;

if (ref $try eq 'ARRAY') {
($C->{'_fate'}, $tag, $try) = @$try;	# next candidate fate
}

$C->deb("capterm_01 trying $tag $try") if $::DEBUG & DEBUG::try_processing;
push @gather, ((
sub { my $C=shift;
do {
if (my ($C) = ($C->_EXACT('('))) {
do {
if (my ($C) = ($C->_OPTr(sub { my $C=shift;
$C->_SUBSUMEr(['capture'], sub {
my $C = shift;
$C->capture
})
}))) {
$C->_EXACT(')');
}
else {
();
}
};
}
else {
();
}
}
},
sub { my $C=shift;
do {
if (my ($C) = ($C->before(sub { my $C=shift;
$C->_NOTCHAR( sub { my $C=shift;
$C->_PATTERN(qr/\G\s/)
})
}))) {
$C->_SUBSUMEr(['termish'], sub {
my $C = shift;
$C->termish
});
}
else {
();
}
}
},
)[$try])->($C);
last if @gather;
}
@gather;
};
if (@result) {
@result;
}
elsif ($@) {
my ($first) = $@ =~ /(^.*)/;
$self->deb("CAUGHT $first") if $::DEBUG & DEBUG::trace_call;
die $@ if $@ !~ /^ABORTBRANCH/;
();
}
else {
();
}
}

});
}
else {
();
}
}
);
}

## rule capture
##      rule capture {
##          :my $INVOCANT_OK is context<rw> = 1;
##          <EXPR>
##      }

sub capture__PEEK { $_[0]->_AUTOLEXpeek('capture',$retree) }
sub capture {
my $self = shift;
local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;
local $::INVOCANT_OK = 1;


my $C = $self;
my $S = $C->{'_pos'};

$self->_MATCHIFYr($S, "capture", 
do {
if (my ($C) = ($C->ws)) {
do {
if (my ($C) = ($C->_SUBSUMEr(['EXPR'], sub {
my $C = shift;
$C->EXPR
}))) {
$C->ws;
}
else {
();
}
};
}
else {
();
}
}
);
}

## token sigterm
##      token sigterm {
##          :dba('signature')
##          ':(' ~ ')' <fakesignature>
##      }

sub sigterm__PEEK { $_[0]->_AUTOLEXpeek('sigterm',$retree) }
sub sigterm {
my $self = shift;
local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;


my $C = $self;
my $S = $C->{'_pos'};

$self->_MATCHIFY($S, "sigterm", 
Cursor::lazymap(sub { my $C=$_[0];
Cursor::lazymap(sub { my $C=$_[0];
Cursor::lazymap(sub { my $C=$_[0];
$C->_BRACKET( sub { my $C=shift;
do { my @gather;
eval { push @gather, $C->_EXACT(')')} // do {die $@ if $@ and $@ !~ /ABORT/;1} 
or
eval { push @gather, $C->FAILGOAL(')' , 'signature')} or do { die $@ if $@ };
@gather;
}
})
}, $C->_SUBSUME(['fakesignature'], sub {
my $C = shift;
$C->fakesignature
}))
}, $C->_COMMITBRANCH(local $::GOAL = ')' ))
}, $C->_EXACT(':('))
);
}

## rule param_sep
##      rule param_sep { [','|':'|';'|';;'] }

sub param_sep__PEEK { $_[0]->_AUTOLEXpeek('param_sep',$retree) }
sub param_sep {
my $self = shift;
local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;


my $C = $self;
my $S = $C->{'_pos'};

$self->_MATCHIFYr($S, "param_sep", 
do {
if (my ($C) = ($C->ws)) {
do {
if (my ($C) = ($C->_BRACKETr( sub { my $C=shift;
do {
my @result = eval {
my $trystate;
my ($tag, $try);
my @try;
my $relex;

my $fate;
if ($fate = $C->{'_fate'} and $fate->[1] eq 'param_sep_01') {
$C->deb("Fate passed to param_sep_01: ", ::fatestr($fate)) if $::DEBUG & DEBUG::fates;
($C->{'_fate'}, $tag, $try) = @$fate;
@try = ($try);
}

my @gather = ();
for (;;) {
if (not @try) {
$relex //= $C->cursor_fate('STD', 'param_sep_01', $retree);
@try = $relex->($C, $trystate);
}
last unless @try;
$try = shift(@try) // next;

if (ref $try eq 'ARRAY') {
($C->{'_fate'}, $tag, $try) = @$try;	# next candidate fate
}

$C->deb("param_sep_01 trying $tag $try") if $::DEBUG & DEBUG::try_processing;
push @gather, ((
sub { my $C=shift;
$C->_EXACT(',')
},
sub { my $C=shift;
$C->_EXACT(':')
},
sub { my $C=shift;
$C->_EXACT(';')
},
sub { my $C=shift;
$C->_EXACT(';;')
},
)[$try])->($C);
last if @gather;
}
@gather;
};
if (@result) {
@result;
}
elsif ($@) {
my ($first) = $@ =~ /(^.*)/;
$self->deb("CAUGHT $first") if $::DEBUG & DEBUG::trace_call;
die $@ if $@ !~ /^ABORTBRANCH/;
();
}
else {
();
}
}

}))) {
$C->ws;
}
else {
();
}
};
}
else {
();
}
}
);
}

## token fakesignature($CURPAD is context<rw> = $*CURPAD)
##      token fakesignature($CURPAD is context<rw> = $*CURPAD) {
##          <.newpad>
##          <signature>
##      }

sub fakesignature__PEEK { $_[0]->_AUTOLEXpeek('fakesignature',$retree) }
sub fakesignature {
my $self = shift;
local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;
local $CURPAD = shift() // $::CURPAD;


my $C = $self;
my $S = $C->{'_pos'};

$self->_MATCHIFYr($S, "fakesignature", 
do {
if (my ($C) = ($C->newpad)) {
$C->_SUBSUMEr(['signature'], sub {
my $C = shift;
$C->signature
});
}
else {
();
}
}
);
}

## token signature
##      token signature {
##          # XXX incorrectly scopes &infix:<x> parameters to outside following block
##          :my $IN_DECL is context<rw> = 1;
##          :my $zone is context<rw> = 'posreq';
##          :my $startpos = self.pos;
##          <.ws>
##          [
##          | <?before '-->' | ')' | ']' | '{' | ':'\s >
##          | <parameter>
##          ] ** <param_sep>
##          <.ws>
##          { $*IN_DECL = 0; }
##          [ '-->' <.ws> <typename> ]?
##          {{ $*LEFTSIGIL = '@'; $*CURPAD.{'$?GOTSIG'} ~= '(' ~ substr($*ORIG, $startpos, $¢.pos - $startpos) ~ ')'; }}
##      }

sub signature__PEEK { $_[0]->_AUTOLEXpeek('signature',$retree) }
sub signature {
my $self = shift;
local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;
local $::IN_DECL = 1;
local $::zone = 'posreq';
my $startpos = $self->{'_pos'};


my $C = $self;
my $S = $C->{'_pos'};
$C->{'typename'} = [];
$C->{'parameter'} = [];
$C->{'param_sep'} = [];

$self->_MATCHIFYr($S, "signature", 
do {
if (my ($C) = ($C->ws)) {
do {
if (my ($C) = ($C->_REPSEPr(  sub { my $C=shift;
$C->_SUBSUMEr(['param_sep'], sub {
my $C = shift;
$C->param_sep
})
}, sub { my $C=shift;
$C->_BRACKETr( sub { my $C=shift;
do {
my @result = eval {
my $trystate;
my ($tag, $try);
my @try;
my $relex;

my $fate;
if ($fate = $C->{'_fate'} and $fate->[1] eq 'signature_01') {
$C->deb("Fate passed to signature_01: ", ::fatestr($fate)) if $::DEBUG & DEBUG::fates;
($C->{'_fate'}, $tag, $try) = @$fate;
@try = ($try);
}

my @gather = ();
for (;;) {
if (not @try) {
$relex //= $C->cursor_fate('STD', 'signature_01', $retree);
@try = $relex->($C, $trystate);
}
last unless @try;
$try = shift(@try) // next;

if (ref $try eq 'ARRAY') {
($C->{'_fate'}, $tag, $try) = @$try;	# next candidate fate
}

$C->deb("signature_01 trying $tag $try") if $::DEBUG & DEBUG::try_processing;
push @gather, ((
sub { my $C=shift;
$C->before(sub { my $C=shift;
do {
my @result = eval {
my $trystate;
my ($tag, $try);
my @try;
my $relex;

my $fate;
if ($fate = $C->{'_fate'} and $fate->[1] eq 'signature_02') {
$C->deb("Fate passed to signature_02: ", ::fatestr($fate)) if $::DEBUG & DEBUG::fates;
($C->{'_fate'}, $tag, $try) = @$fate;
@try = ($try);
}

my @gather = ();
for (;;) {
if (not @try) {
$relex //= $C->cursor_fate('STD', 'signature_02', $retree);
@try = $relex->($C, $trystate);
}
last unless @try;
$try = shift(@try) // next;

if (ref $try eq 'ARRAY') {
($C->{'_fate'}, $tag, $try) = @$try;	# next candidate fate
}

$C->deb("signature_02 trying $tag $try") if $::DEBUG & DEBUG::try_processing;
push @gather, ((
sub { my $C=shift;
$C->_EXACT('-->')
},
sub { my $C=shift;
$C->_EXACT(')')
},
sub { my $C=shift;
$C->_EXACT(']')
},
sub { my $C=shift;
$C->_EXACT('{')
},
sub { my $C=shift;
do {
if (my ($C) = ($C->_EXACT(':'))) {
$C->_PATTERN(qr/\G\s/);
}
else {
();
}
}
},
)[$try])->($C);
last if @gather;
}
@gather;
};
if (@result) {
@result;
}
elsif ($@) {
my ($first) = $@ =~ /(^.*)/;
$self->deb("CAUGHT $first") if $::DEBUG & DEBUG::trace_call;
die $@ if $@ !~ /^ABORTBRANCH/;
();
}
else {
();
}
}

})
},
sub { my $C=shift;
$C->_SUBSUMEr(['parameter'], sub {
my $C = shift;
$C->parameter
})
},
)[$try])->($C);
last if @gather;
}
@gather;
};
if (@result) {
@result;
}
elsif ($@) {
my ($first) = $@ =~ /(^.*)/;
$self->deb("CAUGHT $first") if $::DEBUG & DEBUG::trace_call;
die $@ if $@ !~ /^ABORTBRANCH/;
();
}
else {
();
}
}

})
}))) {
do {
if (my ($C) = ($C->ws)) {
do {
if (my ($C) = (scalar(do {
$::IN_DECL = 0; 
}, $C))) {
do {
if (my ($C) = ($C->_OPTr(sub { my $C=shift;
$C->_BRACKETr( sub { my $C=shift;
do {
if (my ($C) = ($C->_EXACT('-->'))) {
do {
if (my ($C) = ($C->ws)) {
$C->_SUBSUMEr(['typename'], sub {
my $C = shift;
$C->typename
});
}
else {
();
}
};
}
else {
();
}
}
})
}))) {
scalar(do {
$::LEFTSIGIL = '@'; $::CURPAD->{'$?GOTSIG'} .= '(' . substr($::ORIG, $startpos, $C->{'_pos'} - $startpos) . ')'; 
}, $C);
}
else {
();
}
};
}
else {
();
}
};
}
else {
();
}
};
}
else {
();
}
};
}
else {
();
}
}
);
}

## token type_declarator__S_253subset (:$endsym is context = 'spacey', :$sym is context<rw> = 'subset')
##      token type_declarator:subset {
##          <sym> :s
##          [
##              <longname> { $¢.add_name($<longname>.Str); }
##              [ of <.ws> <typename> ]?
##              <trait>*
##              [where <EXPR(item %chaining)> ]?    # (EXPR can parse multiple where clauses)
##          ] || <.panic: "Malformed subset">
##      }

sub type_declarator__S_253subset__PEEK { $_[0]->_AUTOLEXpeek('type_declarator__S_253subset',$retree) }
sub type_declarator__S_253subset {
my $self = shift;
local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;
my %args = @_;
local $endsym = $args{endsym} // 'spacey';
local $sym = $args{sym} // 'subset';


my $C = $self;
my $S = $C->{'_pos'};
$C->{'typename'} = [];
$C->{'trait'} = [];
$C->{'EXPR'} = [];
$C->{'sym'} = $sym;

$self->_MATCHIFYr($S, "type_declarator__S_253subset", 
do { my @gather;
eval { push @gather, do {
if (my ($C) = ($C->_PATTERN(qr/\Gsubset/))) {
do {
if (my ($C) = ($C->spacey)) {
do {
if (my ($C) = ($C->ws)) {
do {
if (my ($C) = ($C->_BRACKETr( sub { my $C=shift;
do {
if (my ($C) = ($C->_SUBSUMEr(['longname'], sub {
my $C = shift;
$C->longname
}))) {
do {
if (my ($C) = ($C->ws)) {
do {
if (my ($C) = (scalar(do {
my $M = $C;  $C->add_name($M->{'longname'}->Str); ;
}, $C))) {
do {
if (my ($C) = ($C->ws)) {
do {
if (my ($C) = ($C->_OPTr(sub { my $C=shift;
$C->_BRACKETr( sub { my $C=shift;
do {
if (my ($C) = ($C->ws)) {
do {
if (my ($C) = ($C->_EXACT('of'))) {
do {
if (my ($C) = ($C->ws)) {
do {
if (my ($C) = ($C->ws)) {
do {
if (my ($C) = ($C->ws)) {
do {
if (my ($C) = ($C->_SUBSUMEr(['typename'], sub {
my $C = shift;
$C->typename
}))) {
$C->ws;
}
else {
();
}
};
}
else {
();
}
};
}
else {
();
}
};
}
else {
();
}
};
}
else {
();
}
};
}
else {
();
}
}
})
}))) {
do {
if (my ($C) = ($C->ws)) {
do {
if (my ($C) = ($C->_STARr(sub { my $C=shift;
$C->_SUBSUMEr(['trait'], sub {
my $C = shift;
$C->trait
})
}))) {
do {
if (my ($C) = ($C->ws)) {
do {
if (my ($C) = ($C->_OPTr(sub { my $C=shift;
$C->_BRACKETr( sub { my $C=shift;
do {
if (my ($C) = ($C->_EXACT('where'))) {
do {
if (my ($C) = ($C->ws)) {
do {
if (my ($C) = ($C->_SUBSUMEr(['EXPR'], sub {
my $C = shift;
$C->EXPR(\%chaining)
}))) {
$C->ws;
}
else {
();
}
};
}
else {
();
}
};
}
else {
();
}
}
})
}))) {
$C->ws;
}
else {
();
}
};
}
else {
();
}
};
}
else {
();
}
};
}
else {
();
}
};
}
else {
();
}
};
}
else {
();
}
};
}
else {
();
}
};
}
else {
();
}
};
}
else {
();
}
}
}))) {
$C->ws;
}
else {
();
}
};
}
else {
();
}
};
}
else {
();
}
};
}
else {
();
}
}} // do {die $@ if $@ and $@ !~ /ABORT/;1} 
or
eval { push @gather, do {
if (my ($C) = ($C->ws)) {
do {
if (my ($C) = ($C->panic("Malformed subset"))) {
$C->ws;
}
else {
();
}
};
}
else {
();
}
}} or do { die $@ if $@ };
@gather;
}
);
}

## token type_declarator__S_254enum (:$endsym is context = 'spacey', :$sym is context<rw> = 'enum')
##      token type_declarator:enum {
##          <sym> <.ws>
##          <longname> <.ws> <trait>* <?before <[ < ( « ]> > <noun> <.ws>
##              { $¢.add_name($<longname>.Str); $¢.add_enum($<longname>.Str, $<noun>.Str); }
##      }

sub type_declarator__S_254enum__PEEK { $_[0]->_AUTOLEXpeek('type_declarator__S_254enum',$retree) }
sub type_declarator__S_254enum {
my $self = shift;
local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;
my %args = @_;
local $endsym = $args{endsym} // 'spacey';
local $sym = $args{sym} // 'enum';


my $C = $self;
my $S = $C->{'_pos'};
$C->{'trait'} = [];
$C->{'sym'} = $sym;

$self->_MATCHIFYr($S, "type_declarator__S_254enum", 
do {
if (my ($C) = ($C->_PATTERN(qr/\Genum/))) {
do {
if (my ($C) = ($C->spacey)) {
do {
if (my ($C) = ($C->ws)) {
do {
if (my ($C) = ($C->_SUBSUMEr(['longname'], sub {
my $C = shift;
$C->longname
}))) {
do {
if (my ($C) = ($C->ws)) {
do {
if (my ($C) = ($C->_STARr(sub { my $C=shift;
$C->_SUBSUMEr(['trait'], sub {
my $C = shift;
$C->trait
})
}))) {
do {
if (my ($C) = ($C->before(sub { my $C=shift;
$C->_PATTERN(qr/\G[<(«]/)
}))) {
do {
if (my ($C) = ($C->_SUBSUMEr(['noun'], sub {
my $C = shift;
$C->noun
}))) {
do {
if (my ($C) = ($C->ws)) {
scalar(do {
my $M = $C;  $C->add_name($M->{'longname'}->Str); $C->add_enum($M->{'longname'}->Str, $M->{'noun'}->Str); ;
}, $C);
}
else {
();
}
};
}
else {
();
}
};
}
else {
();
}
};
}
else {
();
}
};
}
else {
();
}
};
}
else {
();
}
};
}
else {
();
}
};
}
else {
();
}
};
}
else {
();
}
}
);
}

## token type_constraint
##      token type_constraint {
##          [
##          | <value>
##          | <typename>
##          | where <.ws> <EXPR(item %chaining)>
##          ]
##          <.ws>
##      }

sub type_constraint__PEEK { $_[0]->_AUTOLEXpeek('type_constraint',$retree) }
sub type_constraint {
my $self = shift;
local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;


my $C = $self;
my $S = $C->{'_pos'};

$self->_MATCHIFYr($S, "type_constraint", 
do {
if (my ($C) = ($C->_BRACKETr( sub { my $C=shift;
do {
my @result = eval {
my $trystate;
my ($tag, $try);
my @try;
my $relex;

my $fate;
if ($fate = $C->{'_fate'} and $fate->[1] eq 'type_constraint_01') {
$C->deb("Fate passed to type_constraint_01: ", ::fatestr($fate)) if $::DEBUG & DEBUG::fates;
($C->{'_fate'}, $tag, $try) = @$fate;
@try = ($try);
}

my @gather = ();
for (;;) {
if (not @try) {
$relex //= $C->cursor_fate('STD', 'type_constraint_01', $retree);
@try = $relex->($C, $trystate);
}
last unless @try;
$try = shift(@try) // next;

if (ref $try eq 'ARRAY') {
($C->{'_fate'}, $tag, $try) = @$try;	# next candidate fate
}

$C->deb("type_constraint_01 trying $tag $try") if $::DEBUG & DEBUG::try_processing;
push @gather, ((
sub { my $C=shift;
$C->_SUBSUMEr(['value'], sub {
my $C = shift;
$C->value
})
},
sub { my $C=shift;
$C->_SUBSUMEr(['typename'], sub {
my $C = shift;
$C->typename
})
},
sub { my $C=shift;
do {
if (my ($C) = ($C->_EXACT('where'))) {
do {
if (my ($C) = ($C->ws)) {
$C->_SUBSUMEr(['EXPR'], sub {
my $C = shift;
$C->EXPR(\%chaining)
});
}
else {
();
}
};
}
else {
();
}
}
},
)[$try])->($C);
last if @gather;
}
@gather;
};
if (@result) {
@result;
}
elsif ($@) {
my ($first) = $@ =~ /(^.*)/;
$self->deb("CAUGHT $first") if $::DEBUG & DEBUG::trace_call;
die $@ if $@ !~ /^ABORTBRANCH/;
();
}
else {
();
}
}

}))) {
$C->ws;
}
else {
();
}
}
);
}

## rule post_constraint
##      rule post_constraint {
##          :dba('constraint')
##          [
##          | '[' ~ ']' <signature>
##          | '(' ~ ')' <signature>
##          | where <EXPR(item %chaining)>
##          ]
##      }

sub post_constraint__PEEK { $_[0]->_AUTOLEXpeek('post_constraint',$retree) }
sub post_constraint {
my $self = shift;
local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;


my $C = $self;
my $S = $C->{'_pos'};

$self->_MATCHIFY($S, "post_constraint", 
Cursor::lazymap(sub { my $C=$_[0];
Cursor::lazymap(sub { my $C=$_[0];
Cursor::lazymap(sub { my $C=$_[0];
$C->ws
}, $C->_BRACKET( sub { my $C=shift;
do {
my @result = eval {
my $trystate;
my ($tag, $try);
my @try;
my $relex;

my $fate;
if ($fate = $C->{'_fate'} and $fate->[1] eq 'post_constraint_01') {
$C->deb("Fate passed to post_constraint_01: ", ::fatestr($fate)) if $::DEBUG & DEBUG::fates;
($C->{'_fate'}, $tag, $try) = @$fate;
@try = ($try);
}

my @gather = ();
for (;;) {
if (not @try) {
$relex //= $C->cursor_fate('STD', 'post_constraint_01', $retree);
@try = $relex->($C, $trystate);
}
last unless @try;
$try = shift(@try) // next;

if (ref $try eq 'ARRAY') {
($C->{'_fate'}, $tag, $try) = @$try;	# next candidate fate
}

$C->deb("post_constraint_01 trying $tag $try") if $::DEBUG & DEBUG::try_processing;
push @gather, ((
sub { my $C=shift;
Cursor::lazymap(sub { my $C=$_[0];
Cursor::lazymap(sub { my $C=$_[0];
Cursor::lazymap(sub { my $C=$_[0];
Cursor::lazymap(sub { my $C=$_[0];
Cursor::lazymap(sub { my $C=$_[0];
$C->ws
}, $C->_BRACKET( sub { my $C=shift;
do { my @gather;
eval { push @gather, $C->_EXACT(']')} // do {die $@ if $@ and $@ !~ /ABORT/;1} 
or
eval { push @gather, $C->FAILGOAL(']', 'constraint')} or do { die $@ if $@ };
@gather;
}
}))
}, $C->_SUBSUME(['signature'], sub {
my $C = shift;
$C->signature
}))
}, $C->_COMMITBRANCH(local $::GOAL = ']'))
}, $C->ws)
}, $C->_EXACT('['))
},
sub { my $C=shift;
Cursor::lazymap(sub { my $C=$_[0];
Cursor::lazymap(sub { my $C=$_[0];
Cursor::lazymap(sub { my $C=$_[0];
Cursor::lazymap(sub { my $C=$_[0];
Cursor::lazymap(sub { my $C=$_[0];
$C->ws
}, $C->_BRACKET( sub { my $C=shift;
do { my @gather;
eval { push @gather, $C->_EXACT(')')} // do {die $@ if $@ and $@ !~ /ABORT/;1} 
or
eval { push @gather, $C->FAILGOAL(')', 'constraint')} or do { die $@ if $@ };
@gather;
}
}))
}, $C->_SUBSUME(['signature'], sub {
my $C = shift;
$C->signature
}))
}, $C->_COMMITBRANCH(local $::GOAL = ')'))
}, $C->ws)
}, $C->_EXACT('('))
},
sub { my $C=shift;
Cursor::lazymap(sub { my $C=$_[0];
Cursor::lazymap(sub { my $C=$_[0];
Cursor::lazymap(sub { my $C=$_[0];
$C->ws
}, $C->_SUBSUME(['EXPR'], sub {
my $C = shift;
$C->EXPR(\%chaining)
}))
}, $C->ws)
}, $C->_EXACT('where'))
},
)[$try])->($C);
last if @gather;
}
@gather;
};
if (@result) {
@result;
}
elsif ($@) {
my ($first) = $@ =~ /(^.*)/;
$self->deb("CAUGHT $first") if $::DEBUG & DEBUG::trace_call;
die $@ if $@ !~ /^ABORTBRANCH/;
();
}
else {
();
}
}

}))
}, $C->ws)
}, $C->ws)
);
}

## token named_param
##      token named_param {
##          :my $GOAL is context = ')';
##          ':'
##          [
##          | <name=identifier> '(' <.ws>
##              [ <named_param> | <param_var> <.ws> ]
##              [ ')' || <.panic: "Unable to parse named parameter; couldn't find right parenthesis"> ]
##          | <param_var>
##          ]
##      }

sub named_param__PEEK { $_[0]->_AUTOLEXpeek('named_param',$retree) }
sub named_param {
my $self = shift;
local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;
local $::GOAL = ')';


my $C = $self;
my $S = $C->{'_pos'};

$self->_MATCHIFYr($S, "named_param", 
do {
if (my ($C) = ($C->_EXACT(':'))) {
$C->_BRACKETr( sub { my $C=shift;
do {
my @result = eval {
my $trystate;
my ($tag, $try);
my @try;
my $relex;

my $fate;
if ($fate = $C->{'_fate'} and $fate->[1] eq 'named_param_01') {
$C->deb("Fate passed to named_param_01: ", ::fatestr($fate)) if $::DEBUG & DEBUG::fates;
($C->{'_fate'}, $tag, $try) = @$fate;
@try = ($try);
}

my @gather = ();
for (;;) {
if (not @try) {
$relex //= $C->cursor_fate('STD', 'named_param_01', $retree);
@try = $relex->($C, $trystate);
}
last unless @try;
$try = shift(@try) // next;

if (ref $try eq 'ARRAY') {
($C->{'_fate'}, $tag, $try) = @$try;	# next candidate fate
}

$C->deb("named_param_01 trying $tag $try") if $::DEBUG & DEBUG::try_processing;
push @gather, ((
sub { my $C=shift;
do {
if (my ($C) = (    $C->_SUBSUMEr(['name'], sub {
my $C = shift;
$C->identifier
}))) {
do {
if (my ($C) = ($C->_EXACT('('))) {
do {
if (my ($C) = ($C->ws)) {
do {
if (my ($C) = ($C->_BRACKETr( sub { my $C=shift;
do {
my @result = eval {
my $trystate;
my ($tag, $try);
my @try;
my $relex;

my $fate;
if ($fate = $C->{'_fate'} and $fate->[1] eq 'named_param_02') {
$C->deb("Fate passed to named_param_02: ", ::fatestr($fate)) if $::DEBUG & DEBUG::fates;
($C->{'_fate'}, $tag, $try) = @$fate;
@try = ($try);
}

my @gather = ();
for (;;) {
if (not @try) {
$relex //= $C->cursor_fate('STD', 'named_param_02', $retree);
@try = $relex->($C, $trystate);
}
last unless @try;
$try = shift(@try) // next;

if (ref $try eq 'ARRAY') {
($C->{'_fate'}, $tag, $try) = @$try;	# next candidate fate
}

$C->deb("named_param_02 trying $tag $try") if $::DEBUG & DEBUG::try_processing;
push @gather, ((
sub { my $C=shift;
$C->_SUBSUMEr(['named_param'], sub {
my $C = shift;
$C->named_param
})
},
sub { my $C=shift;
do {
if (my ($C) = ($C->_SUBSUMEr(['param_var'], sub {
my $C = shift;
$C->param_var
}))) {
$C->ws;
}
else {
();
}
}
},
)[$try])->($C);
last if @gather;
}
@gather;
};
if (@result) {
@result;
}
elsif ($@) {
my ($first) = $@ =~ /(^.*)/;
$self->deb("CAUGHT $first") if $::DEBUG & DEBUG::trace_call;
die $@ if $@ !~ /^ABORTBRANCH/;
();
}
else {
();
}
}

}))) {
$C->_BRACKETr( sub { my $C=shift;
do { my @gather;
eval { push @gather, $C->_EXACT(')')} // do {die $@ if $@ and $@ !~ /ABORT/;1} 
or
eval { push @gather, $C->panic("Unable to parse named parameter; couldn't find right parenthesis")} or do { die $@ if $@ };
@gather;
}
});
}
else {
();
}
};
}
else {
();
}
};
}
else {
();
}
};
}
else {
();
}
}
},
sub { my $C=shift;
$C->_SUBSUMEr(['param_var'], sub {
my $C = shift;
$C->param_var
})
},
)[$try])->($C);
last if @gather;
}
@gather;
};
if (@result) {
@result;
}
elsif ($@) {
my ($first) = $@ =~ /(^.*)/;
$self->deb("CAUGHT $first") if $::DEBUG & DEBUG::trace_call;
die $@ if $@ !~ /^ABORTBRANCH/;
();
}
else {
();
}
}

});
}
else {
();
}
}
);
}

## token param_var
##      token param_var {
##          :dba('formal parameter')
##          [
##          | '[' ~ ']' <signature>
##          | '(' ~ ')' <signature>
##          | <sigil> [<?before <.twigil>\w> <twigil>]?
##              [
##                  # Is it a longname declaration?
##              || <?{ $<sigil>.Str eq '&' }> <?ident> {}
##                  <name=sublongname>
##      
##              ||  # Is it a shaped array or hash declaration?
##                  <?{ $<sigil>.Str eq '@' || $<sigil>.Str eq '%' }>
##                  <name=identifier>?
##                  <?before <[ \< \( \[ \{ ]> >
##                  <postcircumfix>
##      
##                  # ordinary parameter name
##              || <name=identifier>
##              || $<name> = [<[/!]>]
##      
##                  # bare sigil?
##              ]?
##              {{
##                  my $vname = $<sigil>.Str;
##                  my $t = $<twigil>;
##                  my $twigil = '';
##                  $twigil = $t.[0].Str if @$t;
##                  $vname ~= $twigil;
##                  my $n = try { $<name>[0].Str } // '';
##                  $vname ~= $n;
##                  given $twigil {
##                      when '' {
##                          self.add_my_variable($vname) if $n ne '';
##                      }
##                      when '.' {
##                      }
##                      when '!' {
##                      }
##                      default {
##                          self.worry("Illegal to use $twigil twigil in signature");
##                      }
##                  }
##              }}
##          ]
##      }

sub param_var__PEEK { $_[0]->_AUTOLEXpeek('param_var',$retree) }
sub param_var {
my $self = shift;
local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;


my $C = $self;
my $S = $C->{'_pos'};
$C->{'identifier'} = [];
$C->{'name'} = [];
$C->{'twigil'} = [];
$C->{'postcircumfix'} = [];

$self->_MATCHIFY($S, "param_var", 
$C->_BRACKET( sub { my $C=shift;
do {
my @result = eval {
my $trystate;
my ($tag, $try);
my @try;
my $relex;

my $fate;
if ($fate = $C->{'_fate'} and $fate->[1] eq 'param_var_01') {
$C->deb("Fate passed to param_var_01: ", ::fatestr($fate)) if $::DEBUG & DEBUG::fates;
($C->{'_fate'}, $tag, $try) = @$fate;
@try = ($try);
}

my @gather = ();
for (;;) {
if (not @try) {
$relex //= $C->cursor_fate('STD', 'param_var_01', $retree);
@try = $relex->($C, $trystate);
}
last unless @try;
$try = shift(@try) // next;

if (ref $try eq 'ARRAY') {
($C->{'_fate'}, $tag, $try) = @$try;	# next candidate fate
}

$C->deb("param_var_01 trying $tag $try") if $::DEBUG & DEBUG::try_processing;
push @gather, ((
sub { my $C=shift;
Cursor::lazymap(sub { my $C=$_[0];
Cursor::lazymap(sub { my $C=$_[0];
Cursor::lazymap(sub { my $C=$_[0];
$C->_BRACKET( sub { my $C=shift;
do { my @gather;
eval { push @gather, $C->_EXACT(']')} // do {die $@ if $@ and $@ !~ /ABORT/;1} 
or
eval { push @gather, $C->FAILGOAL(']' , 'formal parameter')} or do { die $@ if $@ };
@gather;
}
})
}, $C->_SUBSUME(['signature'], sub {
my $C = shift;
$C->signature
}))
}, $C->_COMMITBRANCH(local $::GOAL = ']' ))
}, $C->_EXACT('['))
},
sub { my $C=shift;
Cursor::lazymap(sub { my $C=$_[0];
Cursor::lazymap(sub { my $C=$_[0];
Cursor::lazymap(sub { my $C=$_[0];
$C->_BRACKET( sub { my $C=shift;
do { my @gather;
eval { push @gather, $C->_EXACT(')')} // do {die $@ if $@ and $@ !~ /ABORT/;1} 
or
eval { push @gather, $C->FAILGOAL(')' , 'formal parameter')} or do { die $@ if $@ };
@gather;
}
})
}, $C->_SUBSUME(['signature'], sub {
my $C = shift;
$C->signature
}))
}, $C->_COMMITBRANCH(local $::GOAL = ')' ))
}, $C->_EXACT('('))
},
sub { my $C=shift;
Cursor::lazymap(sub { my $C=$_[0];
Cursor::lazymap(sub { my $C=$_[0];
Cursor::lazymap(sub { my $C=$_[0];
scalar(do {
my $M = $C; 
my $vname = $M->{'sigil'}->Str;
my $t = $M->{'twigil'};
my $twigil = '';
$twigil = $t->[0]->Str if @$t;
$vname .= $twigil;
my $n = eval { $M->{'name'}[0]->Str } // '';
$vname .= $n;
given ($twigil) {
when ('') {
$self->add_my_variable($vname) if $n ne '';
}
when ('.') {
}
when ('!') {
}
default {
$self->worry("Illegal to use $twigil twigil in signature");
}
};
;
}, $C)
}, $C->_OPTr(sub { my $C=shift;
$C->_BRACKET( sub { my $C=shift;
do { my @gather;
eval { push @gather, Cursor::lazymap(sub { my $C=$_[0];
Cursor::lazymap(sub { my $C=$_[0];
Cursor::lazymap(sub { my $C=$_[0];
$C->_SUBSUME(['name'], sub {
my $C = shift;
$C->sublongname
})
}, scalar(do {

}, $C))
}, $C->before( sub { my $C=shift;
$C->ident
}))
}, $C->before( sub { my $C=shift;
(($C) x !!do {
my $M = $C;  $M->{'sigil'}->Str eq '&' ;
})
}))} // do {die $@ if $@ and $@ !~ /ABORT/;1} 
or
eval { push @gather, Cursor::lazymap(sub { my $C=$_[0];
Cursor::lazymap(sub { my $C=$_[0];
Cursor::lazymap(sub { my $C=$_[0];
$C->_SUBSUME(['postcircumfix'], sub {
my $C = shift;
$C->postcircumfix
})
}, $C->before(sub { my $C=shift;
$C->_PATTERN(qr/\G[\<\(\[\{]/)
}))
},     $C->_OPTr(sub { my $C=shift;
$C->_SUBSUME(['name','identifier'], sub {
my $C = shift;
$C->identifier
})
}))
}, $C->before( sub { my $C=shift;
(($C) x !!do {
my $M = $C;  $M->{'sigil'}->Str eq '@' || $M->{'sigil'}->Str eq '%' ;
})
}))} // do {die $@ if $@ and $@ !~ /ABORT/;1} 
or
eval { push @gather,     $C->_SUBSUME(['name'], sub {
my $C = shift;
$C->identifier
})} // do {die $@ if $@ and $@ !~ /ABORT/;1} 
or
eval { push @gather,     $C->_SUBSUME(['name'], sub {
my $C = shift;
$C->_BRACKET( sub { my $C=shift;
$C->_PATTERN(qr/\G[\/!]/)
})
})} or do { die $@ if $@ };
@gather;
}
})
}))
}, $C->_OPTr(sub { my $C=shift;
$C->_BRACKET( sub { my $C=shift;
Cursor::lazymap(sub { my $C=$_[0];
$C->_SUBSUME(['twigil'], sub {
my $C = shift;
$C->twigil
})
}, $C->before(sub { my $C=shift;
Cursor::lazymap(sub { my $C=$_[0];
$C->_PATTERN(qr/\G\w/)
}, $C->twigil)
}))
})
}))
}, $C->_SUBSUME(['sigil'], sub {
my $C = shift;
$C->sigil
}))
},
)[$try])->($C);
last if @gather;
}
@gather;
};
if (@result) {
@result;
}
elsif ($@) {
my ($first) = $@ =~ /(^.*)/;
$self->deb("CAUGHT $first") if $::DEBUG & DEBUG::trace_call;
die $@ if $@ !~ /^ABORTBRANCH/;
();
}
else {
();
}
}

})
);
}

## token parameter
##      token parameter {
##          :my $kind;
##          :my $quant = '';
##          :my $q;
##      
##      
##          [
##          | <type_constraint>+
##              {
##                  my $t = $<type_constraint>;
##                  @$t > 1 and $¢.panic("Multiple prefix constraints not yet supported")
##              }
##              [
##              | '*' <param_var>   { $quant = '*'; $kind = '*'; }
##              | '|' <param_var>   { $quant = '|'; $kind = '*'; }
##              | '\\' <param_var>  { $quant = '\\'; $kind = '!'; }
##              |   [
##                  | <param_var>   { $quant = ''; $kind = '!'; }
##                  | <named_param> { $quant = ''; $kind = '*'; }
##                  ]
##                  [
##                  | '?'           { $quant = '?'; $kind = '?' }
##                  | '!'           { $quant = '!'; $kind //= '!' }
##                  | <?>
##                  ]
##              | <?> { $quant = ''; $kind = '!' }
##              ]
##      
##          | '*' <param_var>   { $quant = '*'; $kind = '*'; }
##          | '|' <param_var>   { $quant = '|'; $kind = '*'; }
##          | '\\' <param_var>  { $quant = '\\'; $kind = '!'; }
##          |   [
##              | <param_var>   { $quant = ''; $kind = '!'; }
##              | <named_param> { $quant = ''; $kind = '*'; }
##              ]
##              [
##              | '?'           { $quant = '?'; $kind = '?' }
##              | '!'           { $quant = '!'; $kind //= '!' }
##              | <?>
##              ]
##          ]
##      
##          <trait>*
##      
##          <post_constraint>*
##      
##          [
##              <default_value> {{
##                  given $quant {
##                    when '!' { $¢.panic("Can't put a default on a required parameter") }
##                    when '*' { $¢.panic("Can't put a default on a slurpy parameter") }
##                    when '|' { $¢.panic("Can't put a default on an slurpy capture parameter") }
##                    when '\\' { $¢.panic("Can't put a default on a capture parameter") }
##                  }
##                  $kind = '?' if $kind eq '!';
##              }}
##          ]?
##      
##          {
##              $<quant> = $quant;
##              $<kind> = $kind;
##          }
##      
##          # enforce zone constraints
##          {{
##              given $kind {
##                  when '!' {
##                      given $*zone {
##                          when 'posopt' {
##      $¢.panic("Can't put required parameter after optional parameters");
##                          }
##                          when 'var' {
##      $¢.panic("Can't put required parameter after variadic parameters");
##                          }
##                      }
##                  }
##                  when '?' {
##                      given $*zone {
##                          when 'posreq' { $*zone = 'posopt' }
##                          when 'var' {
##      $¢.panic("Can't put optional positional parameter after variadic parameters");
##                          }
##                      }
##                  }
##                  when '*' {
##                      $*zone = 'var';
##                  }
##              }
##          }}
##      }

sub parameter__PEEK { $_[0]->_AUTOLEXpeek('parameter',$retree) }
sub parameter {
my $self = shift;
local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;
my $kind;
my $quant = '';
my $q;


my $C = $self;
my $S = $C->{'_pos'};
$C->{'trait'} = [];
$C->{'default_value'} = [];
$C->{'post_constraint'} = [];
$C->{'type_constraint'} = [];

$self->_MATCHIFYr($S, "parameter", 
do {
if (my ($C) = ($C->_BRACKETr( sub { my $C=shift;
do {
my @result = eval {
my $trystate;
my ($tag, $try);
my @try;
my $relex;

my $fate;
if ($fate = $C->{'_fate'} and $fate->[1] eq 'parameter_01') {
$C->deb("Fate passed to parameter_01: ", ::fatestr($fate)) if $::DEBUG & DEBUG::fates;
($C->{'_fate'}, $tag, $try) = @$fate;
@try = ($try);
}

my @gather = ();
for (;;) {
if (not @try) {
$relex //= $C->cursor_fate('STD', 'parameter_01', $retree);
@try = $relex->($C, $trystate);
}
last unless @try;
$try = shift(@try) // next;

if (ref $try eq 'ARRAY') {
($C->{'_fate'}, $tag, $try) = @$try;	# next candidate fate
}

$C->deb("parameter_01 trying $tag $try") if $::DEBUG & DEBUG::try_processing;
push @gather, ((
sub { my $C=shift;
do {
if (my ($C) = ($C->_PLUSr(sub { my $C=shift;
$C->_SUBSUMEr(['type_constraint'], sub {
my $C = shift;
$C->type_constraint
})
}))) {
do {
if (my ($C) = (scalar(do {
my $M = $C; 
my $t = $M->{'type_constraint'};
@$t > 1 and $C->panic("Multiple prefix constraints not yet supported")
;
}, $C))) {
$C->_BRACKETr( sub { my $C=shift;
do {
my @result = eval {
my $trystate;
my ($tag, $try);
my @try;
my $relex;

my $fate;
if ($fate = $C->{'_fate'} and $fate->[1] eq 'parameter_02') {
$C->deb("Fate passed to parameter_02: ", ::fatestr($fate)) if $::DEBUG & DEBUG::fates;
($C->{'_fate'}, $tag, $try) = @$fate;
@try = ($try);
}

my @gather = ();
for (;;) {
if (not @try) {
$relex //= $C->cursor_fate('STD', 'parameter_02', $retree);
@try = $relex->($C, $trystate);
}
last unless @try;
$try = shift(@try) // next;

if (ref $try eq 'ARRAY') {
($C->{'_fate'}, $tag, $try) = @$try;	# next candidate fate
}

$C->deb("parameter_02 trying $tag $try") if $::DEBUG & DEBUG::try_processing;
push @gather, ((
sub { my $C=shift;
do {
if (my ($C) = ($C->_EXACT('*'))) {
do {
if (my ($C) = ($C->_SUBSUMEr(['param_var'], sub {
my $C = shift;
$C->param_var
}))) {
scalar(do {
$quant = '*'; $kind = '*'; 
}, $C);
}
else {
();
}
};
}
else {
();
}
}
},
sub { my $C=shift;
do {
if (my ($C) = ($C->_EXACT('|'))) {
do {
if (my ($C) = ($C->_SUBSUMEr(['param_var'], sub {
my $C = shift;
$C->param_var
}))) {
scalar(do {
$quant = '|'; $kind = '*'; 
}, $C);
}
else {
();
}
};
}
else {
();
}
}
},
sub { my $C=shift;
do {
if (my ($C) = ($C->_EXACT('\\'))) {
do {
if (my ($C) = ($C->_SUBSUMEr(['param_var'], sub {
my $C = shift;
$C->param_var
}))) {
scalar(do {
$quant = '\\'; $kind = '!'; 
}, $C);
}
else {
();
}
};
}
else {
();
}
}
},
sub { my $C=shift;
do {
if (my ($C) = ($C->_BRACKETr( sub { my $C=shift;
do {
my @result = eval {
my $trystate;
my ($tag, $try);
my @try;
my $relex;

my $fate;
if ($fate = $C->{'_fate'} and $fate->[1] eq 'parameter_03') {
$C->deb("Fate passed to parameter_03: ", ::fatestr($fate)) if $::DEBUG & DEBUG::fates;
($C->{'_fate'}, $tag, $try) = @$fate;
@try = ($try);
}

my @gather = ();
for (;;) {
if (not @try) {
$relex //= $C->cursor_fate('STD', 'parameter_03', $retree);
@try = $relex->($C, $trystate);
}
last unless @try;
$try = shift(@try) // next;

if (ref $try eq 'ARRAY') {
($C->{'_fate'}, $tag, $try) = @$try;	# next candidate fate
}

$C->deb("parameter_03 trying $tag $try") if $::DEBUG & DEBUG::try_processing;
push @gather, ((
sub { my $C=shift;
do {
if (my ($C) = ($C->_SUBSUMEr(['param_var'], sub {
my $C = shift;
$C->param_var
}))) {
scalar(do {
$quant = ''; $kind = '!'; 
}, $C);
}
else {
();
}
}
},
sub { my $C=shift;
do {
if (my ($C) = ($C->_SUBSUMEr(['named_param'], sub {
my $C = shift;
$C->named_param
}))) {
scalar(do {
$quant = ''; $kind = '*'; 
}, $C);
}
else {
();
}
}
},
)[$try])->($C);
last if @gather;
}
@gather;
};
if (@result) {
@result;
}
elsif ($@) {
my ($first) = $@ =~ /(^.*)/;
$self->deb("CAUGHT $first") if $::DEBUG & DEBUG::trace_call;
die $@ if $@ !~ /^ABORTBRANCH/;
();
}
else {
();
}
}

}))) {
$C->_BRACKETr( sub { my $C=shift;
do {
my @result = eval {
my $trystate;
my ($tag, $try);
my @try;
my $relex;

my $fate;
if ($fate = $C->{'_fate'} and $fate->[1] eq 'parameter_04') {
$C->deb("Fate passed to parameter_04: ", ::fatestr($fate)) if $::DEBUG & DEBUG::fates;
($C->{'_fate'}, $tag, $try) = @$fate;
@try = ($try);
}

my @gather = ();
for (;;) {
if (not @try) {
$relex //= $C->cursor_fate('STD', 'parameter_04', $retree);
@try = $relex->($C, $trystate);
}
last unless @try;
$try = shift(@try) // next;

if (ref $try eq 'ARRAY') {
($C->{'_fate'}, $tag, $try) = @$try;	# next candidate fate
}

$C->deb("parameter_04 trying $tag $try") if $::DEBUG & DEBUG::try_processing;
push @gather, ((
sub { my $C=shift;
do {
if (my ($C) = ($C->_EXACT('?'))) {
scalar(do {
$quant = '?'; $kind = '?' 
}, $C);
}
else {
();
}
}
},
sub { my $C=shift;
do {
if (my ($C) = ($C->_EXACT('!'))) {
scalar(do {
$quant = '!'; $kind //= '!' 
}, $C);
}
else {
();
}
}
},
sub { my $C=shift;
$C->before( sub { my $C=shift;
$C
})
},
)[$try])->($C);
last if @gather;
}
@gather;
};
if (@result) {
@result;
}
elsif ($@) {
my ($first) = $@ =~ /(^.*)/;
$self->deb("CAUGHT $first") if $::DEBUG & DEBUG::trace_call;
die $@ if $@ !~ /^ABORTBRANCH/;
();
}
else {
();
}
}

});
}
else {
();
}
}
},
sub { my $C=shift;
do {
if (my ($C) = ($C->before( sub { my $C=shift;
$C
}))) {
scalar(do {
$quant = ''; $kind = '!' 
}, $C);
}
else {
();
}
}
},
)[$try])->($C);
last if @gather;
}
@gather;
};
if (@result) {
@result;
}
elsif ($@) {
my ($first) = $@ =~ /(^.*)/;
$self->deb("CAUGHT $first") if $::DEBUG & DEBUG::trace_call;
die $@ if $@ !~ /^ABORTBRANCH/;
();
}
else {
();
}
}

});
}
else {
();
}
};
}
else {
();
}
}
},
sub { my $C=shift;
do {
if (my ($C) = ($C->_EXACT('*'))) {
do {
if (my ($C) = ($C->_SUBSUMEr(['param_var'], sub {
my $C = shift;
$C->param_var
}))) {
scalar(do {
$quant = '*'; $kind = '*'; 
}, $C);
}
else {
();
}
};
}
else {
();
}
}
},
sub { my $C=shift;
do {
if (my ($C) = ($C->_EXACT('|'))) {
do {
if (my ($C) = ($C->_SUBSUMEr(['param_var'], sub {
my $C = shift;
$C->param_var
}))) {
scalar(do {
$quant = '|'; $kind = '*'; 
}, $C);
}
else {
();
}
};
}
else {
();
}
}
},
sub { my $C=shift;
do {
if (my ($C) = ($C->_EXACT('\\'))) {
do {
if (my ($C) = ($C->_SUBSUMEr(['param_var'], sub {
my $C = shift;
$C->param_var
}))) {
scalar(do {
$quant = '\\'; $kind = '!'; 
}, $C);
}
else {
();
}
};
}
else {
();
}
}
},
sub { my $C=shift;
do {
if (my ($C) = ($C->_BRACKETr( sub { my $C=shift;
do {
my @result = eval {
my $trystate;
my ($tag, $try);
my @try;
my $relex;

my $fate;
if ($fate = $C->{'_fate'} and $fate->[1] eq 'parameter_05') {
$C->deb("Fate passed to parameter_05: ", ::fatestr($fate)) if $::DEBUG & DEBUG::fates;
($C->{'_fate'}, $tag, $try) = @$fate;
@try = ($try);
}

my @gather = ();
for (;;) {
if (not @try) {
$relex //= $C->cursor_fate('STD', 'parameter_05', $retree);
@try = $relex->($C, $trystate);
}
last unless @try;
$try = shift(@try) // next;

if (ref $try eq 'ARRAY') {
($C->{'_fate'}, $tag, $try) = @$try;	# next candidate fate
}

$C->deb("parameter_05 trying $tag $try") if $::DEBUG & DEBUG::try_processing;
push @gather, ((
sub { my $C=shift;
do {
if (my ($C) = ($C->_SUBSUMEr(['param_var'], sub {
my $C = shift;
$C->param_var
}))) {
scalar(do {
$quant = ''; $kind = '!'; 
}, $C);
}
else {
();
}
}
},
sub { my $C=shift;
do {
if (my ($C) = ($C->_SUBSUMEr(['named_param'], sub {
my $C = shift;
$C->named_param
}))) {
scalar(do {
$quant = ''; $kind = '*'; 
}, $C);
}
else {
();
}
}
},
)[$try])->($C);
last if @gather;
}
@gather;
};
if (@result) {
@result;
}
elsif ($@) {
my ($first) = $@ =~ /(^.*)/;
$self->deb("CAUGHT $first") if $::DEBUG & DEBUG::trace_call;
die $@ if $@ !~ /^ABORTBRANCH/;
();
}
else {
();
}
}

}))) {
$C->_BRACKETr( sub { my $C=shift;
do {
my @result = eval {
my $trystate;
my ($tag, $try);
my @try;
my $relex;

my $fate;
if ($fate = $C->{'_fate'} and $fate->[1] eq 'parameter_06') {
$C->deb("Fate passed to parameter_06: ", ::fatestr($fate)) if $::DEBUG & DEBUG::fates;
($C->{'_fate'}, $tag, $try) = @$fate;
@try = ($try);
}

my @gather = ();
for (;;) {
if (not @try) {
$relex //= $C->cursor_fate('STD', 'parameter_06', $retree);
@try = $relex->($C, $trystate);
}
last unless @try;
$try = shift(@try) // next;

if (ref $try eq 'ARRAY') {
($C->{'_fate'}, $tag, $try) = @$try;	# next candidate fate
}

$C->deb("parameter_06 trying $tag $try") if $::DEBUG & DEBUG::try_processing;
push @gather, ((
sub { my $C=shift;
do {
if (my ($C) = ($C->_EXACT('?'))) {
scalar(do {
$quant = '?'; $kind = '?' 
}, $C);
}
else {
();
}
}
},
sub { my $C=shift;
do {
if (my ($C) = ($C->_EXACT('!'))) {
scalar(do {
$quant = '!'; $kind //= '!' 
}, $C);
}
else {
();
}
}
},
sub { my $C=shift;
$C->before( sub { my $C=shift;
$C
})
},
)[$try])->($C);
last if @gather;
}
@gather;
};
if (@result) {
@result;
}
elsif ($@) {
my ($first) = $@ =~ /(^.*)/;
$self->deb("CAUGHT $first") if $::DEBUG & DEBUG::trace_call;
die $@ if $@ !~ /^ABORTBRANCH/;
();
}
else {
();
}
}

});
}
else {
();
}
}
},
)[$try])->($C);
last if @gather;
}
@gather;
};
if (@result) {
@result;
}
elsif ($@) {
my ($first) = $@ =~ /(^.*)/;
$self->deb("CAUGHT $first") if $::DEBUG & DEBUG::trace_call;
die $@ if $@ !~ /^ABORTBRANCH/;
();
}
else {
();
}
}

}))) {
do {
if (my ($C) = ($C->_STARr(sub { my $C=shift;
$C->_SUBSUMEr(['trait'], sub {
my $C = shift;
$C->trait
})
}))) {
do {
if (my ($C) = ($C->_STARr(sub { my $C=shift;
$C->_SUBSUMEr(['post_constraint'], sub {
my $C = shift;
$C->post_constraint
})
}))) {
do {
if (my ($C) = ($C->_OPTr(sub { my $C=shift;
$C->_BRACKETr( sub { my $C=shift;
do {
if (my ($C) = ($C->_SUBSUMEr(['default_value'], sub {
my $C = shift;
$C->default_value
}))) {
scalar(do {

given ($quant) {
when ('!') { $C->panic("Can't put a default on a required parameter") }
when ('*') { $C->panic("Can't put a default on a slurpy parameter") }
when ('|') { $C->panic("Can't put a default on an slurpy capture parameter") }
when ('\\') { $C->panic("Can't put a default on a capture parameter") }
};
$kind = '?' if $kind eq '!';

}, $C);
}
else {
();
}
}
})
}))) {
do {
if (my ($C) = (scalar(do {
my $M = $C; 
$M->{'quant'} = $quant;
$M->{'kind'} = $kind;
;
}, $C))) {
scalar(do {

given ($kind) {
when ('!') {
given ($::zone) {
when ('posopt') {
$C->panic("Can't put required parameter after optional parameters");
}
when ('var') {
$C->panic("Can't put required parameter after variadic parameters");
}
};
}
when ('?') {
given ($::zone) {
when ('posreq') { $::zone = 'posopt' }
when ('var') {
$C->panic("Can't put optional positional parameter after variadic parameters");
}
};
}
when ('*') {
$::zone = 'var';
}
};

}, $C);
}
else {
();
}
};
}
else {
();
}
};
}
else {
();
}
};
}
else {
();
}
};
}
else {
();
}
}
);
}

## rule default_value
##      rule default_value {
##          '=' <EXPR(item %item_assignment)>
##      }

sub default_value__PEEK { $_[0]->_AUTOLEXpeek('default_value',$retree) }
sub default_value {
my $self = shift;
local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;


my $C = $self;
my $S = $C->{'_pos'};

$self->_MATCHIFYr($S, "default_value", 
do {
if (my ($C) = ($C->ws)) {
do {
if (my ($C) = ($C->_EXACT('='))) {
do {
if (my ($C) = ($C->ws)) {
do {
if (my ($C) = ($C->_SUBSUMEr(['EXPR'], sub {
my $C = shift;
$C->EXPR(\%item_assignment)
}))) {
$C->ws;
}
else {
();
}
};
}
else {
();
}
};
}
else {
();
}
};
}
else {
();
}
}
);
}

## token statement_prefix__S_255try (:$sym is context<rw> = 'try')
##      token statement_prefix:try     { <sym> <blorst> }

sub statement_prefix__S_255try__PEEK { $_[0]->_AUTOLEXpeek('statement_prefix__S_255try',$retree) }
sub statement_prefix__S_255try {
my $self = shift;
local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;
my %args = @_;
local $sym = $args{sym} // 'try';


my $C = $self;
my $S = $C->{'_pos'};
$C->{'sym'} = $sym;

$self->_MATCHIFYr($S, "statement_prefix__S_255try", 
do {
if (my ($C) = ($C->_PATTERN(qr/\Gtry/))) {
$C->_SUBSUMEr(['blorst'], sub {
my $C = shift;
$C->blorst
});
}
else {
();
}
}
);
}
## token statement_prefix__S_256gather (:$sym is context<rw> = 'gather')
##      token statement_prefix:gather  { <sym> <blorst> }

sub statement_prefix__S_256gather__PEEK { $_[0]->_AUTOLEXpeek('statement_prefix__S_256gather',$retree) }
sub statement_prefix__S_256gather {
my $self = shift;
local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;
my %args = @_;
local $sym = $args{sym} // 'gather';


my $C = $self;
my $S = $C->{'_pos'};
$C->{'sym'} = $sym;

$self->_MATCHIFYr($S, "statement_prefix__S_256gather", 
do {
if (my ($C) = ($C->_PATTERN(qr/\Ggather/))) {
$C->_SUBSUMEr(['blorst'], sub {
my $C = shift;
$C->blorst
});
}
else {
();
}
}
);
}
## token statement_prefix__S_257contend (:$sym is context<rw> = 'contend')
##      token statement_prefix:contend { <sym> <blorst> }

sub statement_prefix__S_257contend__PEEK { $_[0]->_AUTOLEXpeek('statement_prefix__S_257contend',$retree) }
sub statement_prefix__S_257contend {
my $self = shift;
local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;
my %args = @_;
local $sym = $args{sym} // 'contend';


my $C = $self;
my $S = $C->{'_pos'};
$C->{'sym'} = $sym;

$self->_MATCHIFYr($S, "statement_prefix__S_257contend", 
do {
if (my ($C) = ($C->_PATTERN(qr/\Gcontend/))) {
$C->_SUBSUMEr(['blorst'], sub {
my $C = shift;
$C->blorst
});
}
else {
();
}
}
);
}
## token statement_prefix__S_258async (:$sym is context<rw> = 'async')
##      token statement_prefix:async   { <sym> <blorst> }

sub statement_prefix__S_258async__PEEK { $_[0]->_AUTOLEXpeek('statement_prefix__S_258async',$retree) }
sub statement_prefix__S_258async {
my $self = shift;
local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;
my %args = @_;
local $sym = $args{sym} // 'async';


my $C = $self;
my $S = $C->{'_pos'};
$C->{'sym'} = $sym;

$self->_MATCHIFYr($S, "statement_prefix__S_258async", 
do {
if (my ($C) = ($C->_PATTERN(qr/\Gasync/))) {
$C->_SUBSUMEr(['blorst'], sub {
my $C = shift;
$C->blorst
});
}
else {
();
}
}
);
}
## token statement_prefix__S_259maybe (:$sym is context<rw> = 'maybe')
##      token statement_prefix:maybe   { <sym> <blorst> }

sub statement_prefix__S_259maybe__PEEK { $_[0]->_AUTOLEXpeek('statement_prefix__S_259maybe',$retree) }
sub statement_prefix__S_259maybe {
my $self = shift;
local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;
my %args = @_;
local $sym = $args{sym} // 'maybe';


my $C = $self;
my $S = $C->{'_pos'};
$C->{'sym'} = $sym;

$self->_MATCHIFYr($S, "statement_prefix__S_259maybe", 
do {
if (my ($C) = ($C->_PATTERN(qr/\Gmaybe/))) {
$C->_SUBSUMEr(['blorst'], sub {
my $C = shift;
$C->blorst
});
}
else {
();
}
}
);
}
## token statement_prefix__S_260lazy (:$sym is context<rw> = 'lazy')
##      token statement_prefix:lazy    { <sym> <blorst> }

sub statement_prefix__S_260lazy__PEEK { $_[0]->_AUTOLEXpeek('statement_prefix__S_260lazy',$retree) }
sub statement_prefix__S_260lazy {
my $self = shift;
local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;
my %args = @_;
local $sym = $args{sym} // 'lazy';


my $C = $self;
my $S = $C->{'_pos'};
$C->{'sym'} = $sym;

$self->_MATCHIFYr($S, "statement_prefix__S_260lazy", 
do {
if (my ($C) = ($C->_PATTERN(qr/\Glazy/))) {
$C->_SUBSUMEr(['blorst'], sub {
my $C = shift;
$C->blorst
});
}
else {
();
}
}
);
}
## token statement_prefix__S_261do (:$sym is context<rw> = 'do')
##      token statement_prefix:do      { <sym> <blorst> }

sub statement_prefix__S_261do__PEEK { $_[0]->_AUTOLEXpeek('statement_prefix__S_261do',$retree) }
sub statement_prefix__S_261do {
my $self = shift;
local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;
my %args = @_;
local $sym = $args{sym} // 'do';


my $C = $self;
my $S = $C->{'_pos'};
$C->{'sym'} = $sym;

$self->_MATCHIFYr($S, "statement_prefix__S_261do", 
do {
if (my ($C) = ($C->_PATTERN(qr/\Gdo/))) {
$C->_SUBSUMEr(['blorst'], sub {
my $C = shift;
$C->blorst
});
}
else {
();
}
}
);
}

## token statement_prefix__S_262lift (:$sym is context<rw> = 'lift')
##      token statement_prefix:lift    {
##          :my $QUASIMODO is context = 1;
##          <sym> <blorst>
##      }

sub statement_prefix__S_262lift__PEEK { $_[0]->_AUTOLEXpeek('statement_prefix__S_262lift',$retree) }
sub statement_prefix__S_262lift {
my $self = shift;
local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;
my %args = @_;
local $sym = $args{sym} // 'lift';
local $::QUASIMODO = 1;


my $C = $self;
my $S = $C->{'_pos'};
$C->{'sym'} = $sym;

$self->_MATCHIFYr($S, "statement_prefix__S_262lift", 
do {
if (my ($C) = ($C->_PATTERN(qr/\Glift/))) {
$C->_SUBSUMEr(['blorst'], sub {
my $C = shift;
$C->blorst
});
}
else {
();
}
}
);
}

## token blorst
##      token blorst {
##          <?before \s> <.ws>
##          [
##          | <block>
##          | <statement>
##          ]
##      }

sub blorst__PEEK { $_[0]->_AUTOLEXpeek('blorst',$retree) }
sub blorst {
my $self = shift;
local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;


my $C = $self;
my $S = $C->{'_pos'};

$self->_MATCHIFYr($S, "blorst", 
do {
if (my ($C) = ($C->before(sub { my $C=shift;
$C->_PATTERN(qr/\G\s/)
}))) {
do {
if (my ($C) = ($C->ws)) {
$C->_BRACKETr( sub { my $C=shift;
do {
my @result = eval {
my $trystate;
my ($tag, $try);
my @try;
my $relex;

my $fate;
if ($fate = $C->{'_fate'} and $fate->[1] eq 'blorst_02') {
$C->deb("Fate passed to blorst_02: ", ::fatestr($fate)) if $::DEBUG & DEBUG::fates;
($C->{'_fate'}, $tag, $try) = @$fate;
@try = ($try);
}

my @gather = ();
for (;;) {
if (not @try) {
$relex //= $C->cursor_fate('STD', 'blorst_02', $retree);
@try = $relex->($C, $trystate);
}
last unless @try;
$try = shift(@try) // next;

if (ref $try eq 'ARRAY') {
($C->{'_fate'}, $tag, $try) = @$try;	# next candidate fate
}

$C->deb("blorst_02 trying $tag $try") if $::DEBUG & DEBUG::try_processing;
push @gather, ((
sub { my $C=shift;
$C->_SUBSUMEr(['block'], sub {
my $C = shift;
$C->block
})
},
sub { my $C=shift;
$C->_SUBSUMEr(['statement'], sub {
my $C = shift;
$C->statement
})
},
)[$try])->($C);
last if @gather;
}
@gather;
};
if (@result) {
@result;
}
elsif ($@) {
my ($first) = $@ =~ /(^.*)/;
$self->deb("CAUGHT $first") if $::DEBUG & DEBUG::trace_call;
die $@ if $@ !~ /^ABORTBRANCH/;
();
}
else {
();
}
}

});
}
else {
();
}
};
}
else {
();
}
}
);
}

#########
# Terms #
#########

# start playing with the setting stubber
## token term__S_263YOU_ARE_HERE (  :$sym is context<rw> = 'YOU_ARE_HERE' --> Term)
##      token term:YOU_ARE_HERE ( --> Term) {
##          <sym> <.you_are_here>
##      }

sub term__S_263YOU_ARE_HERE__PEEK { $_[0]->_AUTOLEXpeek('term__S_263YOU_ARE_HERE',$retree) }
sub term__S_263YOU_ARE_HERE {
my $self = shift;
local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;
my %args = @_;
local $sym = $args{sym} // 'YOU_ARE_HERE';


my $C = $self;
my $S = $C->{'_pos'};
$C->{'sym'} = $sym;

$self->_MATCHIFYr($S, "term__S_263YOU_ARE_HERE",  map { STD::Term->coerce($_) } 
do {
if (my ($C) = ($C->_PATTERN(qr/\GYOU_ARE_HERE/))) {
$C->you_are_here;
}
else {
();
}
}
);
}

## token term__S_264new (  :$sym is context<rw> = 'new' --> Term)
##      token term:new ( --> Term) {
##          'new' \h+ <longname> \h* <!before ':'> <.obs("C++ constructor syntax", "method call syntax")>
##      }

sub term__S_264new__PEEK { $_[0]->_AUTOLEXpeek('term__S_264new',$retree) }
sub term__S_264new {
my $self = shift;
local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;
my %args = @_;
local $sym = $args{sym} // 'new';


my $C = $self;
my $S = $C->{'_pos'};
$C->{'sym'} = $sym;

$self->_MATCHIFYr($S, "term__S_264new",  map { STD::Term->coerce($_) } 
do {
if (my ($C) = ($C->_EXACT('new'))) {
do {
if (my ($C) = ($C->_PATTERN(qr/\G((?:[\x20\t\r])++)/))) {
do {
if (my ($C) = ($C->_SUBSUMEr(['longname'], sub {
my $C = shift;
$C->longname
}))) {
do {
if (my ($C) = ($C->_PATTERN(qr/\G((?:[\x20\t\r])*+)/))) {
do {
if (my ($C) = ($C->_NOTBEFORE( sub { my $C=shift;
$C->before(sub { my $C=shift;
$C->_EXACT(':')
})
}))) {
$C->obs("C++ constructor syntax", "method call syntax");
}
else {
();
}
};
}
else {
();
}
};
}
else {
();
}
};
}
else {
();
}
};
}
else {
();
}
}
);
}

## token term__S_265ColonColonQuestionIDENT (  :$sym is context<rw> = <::?IDENT> --> Term)
##      token term:sym<::?IDENT> ( --> Term) {
##          $<sym> = [ '::?' <identifier> ] »
##      }

sub term__S_265ColonColonQuestionIDENT__PEEK { $_[0]->_AUTOLEXpeek('term__S_265ColonColonQuestionIDENT',$retree) }
sub term__S_265ColonColonQuestionIDENT {
my $self = shift;
local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;
my %args = @_;
local $sym = $args{sym} // q(::?IDENT);


my $C = $self;
my $S = $C->{'_pos'};
$C->{'sym'} = $sym;

$self->_MATCHIFYr($S, "term__S_265ColonColonQuestionIDENT",  map { STD::Term->coerce($_) } 
do {
if (my ($C) = (    $C->_SUBSUMEr(['sym'], sub {
my $C = shift;
$C->_BRACKETr( sub { my $C=shift;
do {
if (my ($C) = ($C->_EXACT('::?'))) {
$C->_SUBSUMEr(['identifier'], sub {
my $C = shift;
$C->identifier
});
}
else {
();
}
}
})
}))) {
$C->_PATTERN(qr/\G\b/);
}
else {
();
}
}
);
}

## token term__S_266undef (  :$sym is context<rw> = <undef> --> Term)
##      token term:sym<undef> ( --> Term) {
##          <sym> »
##          [ <?before \h*'$/' >
##              <.obs('$/ variable as input record separator',
##                   "the filehandle's .slurp method")>
##          ]?
##          [ <?before \h*<sigil><twigil>?\w >
##              <.obs('undef as a verb', 'undefine function')>
##          ]?
##      }

sub term__S_266undef__PEEK { $_[0]->_AUTOLEXpeek('term__S_266undef',$retree) }
sub term__S_266undef {
my $self = shift;
local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;
my %args = @_;
local $sym = $args{sym} // q(undef);


my $C = $self;
my $S = $C->{'_pos'};
$C->{'sym'} = $sym;

$self->_MATCHIFYr($S, "term__S_266undef",  map { STD::Term->coerce($_) } 
do {
if (my ($C) = ($C->_PATTERN(qr/\Gundef/))) {
do {
if (my ($C) = ($C->_PATTERN(qr/\G\b/))) {
do {
if (my ($C) = ($C->_OPTr(sub { my $C=shift;
$C->_BRACKETr( sub { my $C=shift;
do {
if (my ($C) = ($C->before(sub { my $C=shift;
do {
if (my ($C) = ($C->_PATTERN(qr/\G((?:[\x20\t\r])*+)/))) {
$C->_EXACT('$/');
}
else {
();
}
}
}))) {
$C->obs('$/ variable as input record separator',
"the filehandle's .slurp method");
}
else {
();
}
}
})
}))) {
$C->_OPTr(sub { my $C=shift;
$C->_BRACKETr( sub { my $C=shift;
do {
if (my ($C) = ($C->before(sub { my $C=shift;
do {
if (my ($C) = ($C->_PATTERN(qr/\G((?:[\x20\t\r])*+)/))) {
do {
if (my ($C) = ($C->_SUBSUMEr(['sigil'], sub {
my $C = shift;
$C->sigil
}))) {
do {
if (my ($C) = ($C->_OPTr(sub { my $C=shift;
$C->_SUBSUMEr(['twigil'], sub {
my $C = shift;
$C->twigil
})
}))) {
$C->_PATTERN(qr/\G\w/);
}
else {
();
}
};
}
else {
();
}
};
}
else {
();
}
}
}))) {
$C->obs('undef as a verb', 'undefine function');
}
else {
();
}
}
})
});
}
else {
();
}
};
}
else {
();
}
};
}
else {
();
}
}
);
}

## token term__S_267continue (  :$sym is context<rw> = <continue> --> Term)
##      token term:sym<continue> ( --> Term)
##          { <sym> » }

sub term__S_267continue__PEEK { $_[0]->_AUTOLEXpeek('term__S_267continue',$retree) }
sub term__S_267continue {
my $self = shift;
local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;
my %args = @_;
local $sym = $args{sym} // q(continue);


my $C = $self;
my $S = $C->{'_pos'};
$C->{'sym'} = $sym;

$self->_MATCHIFYr($S, "term__S_267continue",  map { STD::Term->coerce($_) } 
$C->_PATTERN(qr/\Gcontinue\b/)
);
}

## token term__S_268self (  :$sym is context<rw> = <self> --> Term)
##      token term:sym<self> ( --> Term)
##          { <sym> » }

sub term__S_268self__PEEK { $_[0]->_AUTOLEXpeek('term__S_268self',$retree) }
sub term__S_268self {
my $self = shift;
local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;
my %args = @_;
local $sym = $args{sym} // q(self);


my $C = $self;
my $S = $C->{'_pos'};
$C->{'sym'} = $sym;

$self->_MATCHIFYr($S, "term__S_268self",  map { STD::Term->coerce($_) } 
$C->_PATTERN(qr/\Gself\b/)
);
}

## token term__S_269defer (  :$sym is context<rw> = <defer> --> Term)
##      token term:sym<defer> ( --> Term)
##          { <sym> » }

sub term__S_269defer__PEEK { $_[0]->_AUTOLEXpeek('term__S_269defer',$retree) }
sub term__S_269defer {
my $self = shift;
local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;
my %args = @_;
local $sym = $args{sym} // q(defer);


my $C = $self;
my $S = $C->{'_pos'};
$C->{'sym'} = $sym;

$self->_MATCHIFYr($S, "term__S_269defer",  map { STD::Term->coerce($_) } 
$C->_PATTERN(qr/\Gdefer\b/)
);
}

## token term__S_270rand (  :$sym is context<rw> = 'rand' --> Term)
##      token term:rand ( --> Term) {
##          <sym> »
##          [ <?before '('? \h* [\d|'$']> <.obs('rand(N)', 'N.rand or (1..N).pick')> ]?
##          [ <?before '()'> <.obs('rand()', 'rand')> ]?
##      }

sub term__S_270rand__PEEK { $_[0]->_AUTOLEXpeek('term__S_270rand',$retree) }
sub term__S_270rand {
my $self = shift;
local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;
my %args = @_;
local $sym = $args{sym} // 'rand';


my $C = $self;
my $S = $C->{'_pos'};
$C->{'sym'} = $sym;

$self->_MATCHIFYr($S, "term__S_270rand",  map { STD::Term->coerce($_) } 
do {
if (my ($C) = ($C->_PATTERN(qr/\Grand/))) {
do {
if (my ($C) = ($C->_PATTERN(qr/\G\b/))) {
do {
if (my ($C) = ($C->_OPTr(sub { my $C=shift;
$C->_BRACKETr( sub { my $C=shift;
do {
if (my ($C) = ($C->before(sub { my $C=shift;
do {
if (my ($C) = ($C->_OPTr(sub { my $C=shift;
$C->_EXACT('(')
}))) {
do {
if (my ($C) = ($C->_PATTERN(qr/\G((?:[\x20\t\r])*+)/))) {
$C->_BRACKETr( sub { my $C=shift;
do {
my @result = eval {
my $trystate;
my ($tag, $try);
my @try;
my $relex;

my $fate;
if ($fate = $C->{'_fate'} and $fate->[1] eq 'term__S_270rand_03') {
$C->deb("Fate passed to term__S_270rand_03: ", ::fatestr($fate)) if $::DEBUG & DEBUG::fates;
($C->{'_fate'}, $tag, $try) = @$fate;
@try = ($try);
}

my @gather = ();
for (;;) {
if (not @try) {
$relex //= $C->cursor_fate('STD', 'term__S_270rand_03', $retree);
@try = $relex->($C, $trystate);
}
last unless @try;
$try = shift(@try) // next;

if (ref $try eq 'ARRAY') {
($C->{'_fate'}, $tag, $try) = @$try;	# next candidate fate
}

$C->deb("term__S_270rand_03 trying $tag $try") if $::DEBUG & DEBUG::try_processing;
push @gather, ((
sub { my $C=shift;
$C->_PATTERN(qr/\G\d/)
},
sub { my $C=shift;
$C->_EXACT('$')
},
)[$try])->($C);
last if @gather;
}
@gather;
};
if (@result) {
@result;
}
elsif ($@) {
my ($first) = $@ =~ /(^.*)/;
$self->deb("CAUGHT $first") if $::DEBUG & DEBUG::trace_call;
die $@ if $@ !~ /^ABORTBRANCH/;
();
}
else {
();
}
}

});
}
else {
();
}
};
}
else {
();
}
}
}))) {
$C->obs('rand(N)', 'N.rand or (1..N).pick');
}
else {
();
}
}
})
}))) {
$C->_OPTr(sub { my $C=shift;
$C->_BRACKETr( sub { my $C=shift;
do {
if (my ($C) = ($C->before(sub { my $C=shift;
$C->_EXACT('()')
}))) {
$C->obs('rand()', 'rand');
}
else {
();
}
}
})
});
}
else {
();
}
};
}
else {
();
}
};
}
else {
();
}
}
);
}

## token term__S_271e (  :$sym is context<rw> = 'e' --> Term)
##      token term:e ( --> Term)
##          { <sym> » }

sub term__S_271e__PEEK { $_[0]->_AUTOLEXpeek('term__S_271e',$retree) }
sub term__S_271e {
my $self = shift;
local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;
my %args = @_;
local $sym = $args{sym} // 'e';


my $C = $self;
my $S = $C->{'_pos'};
$C->{'sym'} = $sym;

$self->_MATCHIFYr($S, "term__S_271e",  map { STD::Term->coerce($_) } 
$C->_PATTERN(qr/\Ge\b/)
);
}

## token term__S_272i (  :$sym is context<rw> = 'i' --> Term)
##      token term:i ( --> Term)
##          { <sym> » }

sub term__S_272i__PEEK { $_[0]->_AUTOLEXpeek('term__S_272i',$retree) }
sub term__S_272i {
my $self = shift;
local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;
my %args = @_;
local $sym = $args{sym} // 'i';


my $C = $self;
my $S = $C->{'_pos'};
$C->{'sym'} = $sym;

$self->_MATCHIFYr($S, "term__S_272i",  map { STD::Term->coerce($_) } 
$C->_PATTERN(qr/\Gi\b/)
);
}

## token term__S_273pi (  :$sym is context<rw> = 'pi' --> Term)
##      token term:pi ( --> Term)
##          { <sym> » }

sub term__S_273pi__PEEK { $_[0]->_AUTOLEXpeek('term__S_273pi',$retree) }
sub term__S_273pi {
my $self = shift;
local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;
my %args = @_;
local $sym = $args{sym} // 'pi';


my $C = $self;
my $S = $C->{'_pos'};
$C->{'sym'} = $sym;

$self->_MATCHIFYr($S, "term__S_273pi",  map { STD::Term->coerce($_) } 
$C->_PATTERN(qr/\Gpi\b/)
);
}

## token term__S_274Inf (  :$sym is context<rw> = 'Inf' --> Term)
##      token term:Inf ( --> Term)
##          { <sym> » }

sub term__S_274Inf__PEEK { $_[0]->_AUTOLEXpeek('term__S_274Inf',$retree) }
sub term__S_274Inf {
my $self = shift;
local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;
my %args = @_;
local $sym = $args{sym} // 'Inf';


my $C = $self;
my $S = $C->{'_pos'};
$C->{'sym'} = $sym;

$self->_MATCHIFYr($S, "term__S_274Inf",  map { STD::Term->coerce($_) } 
$C->_PATTERN(qr/\GInf\b/)
);
}

## token term__S_275NaN (  :$sym is context<rw> = 'NaN' --> Term)
##      token term:NaN ( --> Term)
##          { <sym> » }

sub term__S_275NaN__PEEK { $_[0]->_AUTOLEXpeek('term__S_275NaN',$retree) }
sub term__S_275NaN {
my $self = shift;
local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;
my %args = @_;
local $sym = $args{sym} // 'NaN';


my $C = $self;
my $S = $C->{'_pos'};
$C->{'sym'} = $sym;

$self->_MATCHIFYr($S, "term__S_275NaN",  map { STD::Term->coerce($_) } 
$C->_PATTERN(qr/\GNaN\b/)
);
}

## token term__S_276Star (  :$sym is context<rw> = <*> --> Term)
##      token term:sym<*> ( --> Term)
##          { <sym> }

sub term__S_276Star__PEEK { $_[0]->_AUTOLEXpeek('term__S_276Star',$retree) }
sub term__S_276Star {
my $self = shift;
local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;
my %args = @_;
local $sym = $args{sym} // q(*);


my $C = $self;
my $S = $C->{'_pos'};
$C->{'sym'} = $sym;

$self->_MATCHIFYr($S, "term__S_276Star",  map { STD::Term->coerce($_) } 
$C->_PATTERN(qr/\G\*/)
);
}

## token term__S_277StarStar (  :$sym is context<rw> = <**> --> Term)
##      token term:sym<**> ( --> Term)
##          { <sym> }

sub term__S_277StarStar__PEEK { $_[0]->_AUTOLEXpeek('term__S_277StarStar',$retree) }
sub term__S_277StarStar {
my $self = shift;
local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;
my %args = @_;
local $sym = $args{sym} // q(**);


my $C = $self;
my $S = $C->{'_pos'};
$C->{'sym'} = $sym;

$self->_MATCHIFYr($S, "term__S_277StarStar",  map { STD::Term->coerce($_) } 
$C->_PATTERN(qr/\G\*\*/)
);
}

## token infix__S_278lambda (  :$sym is context<rw> = 'lambda' --> Term)
##      token infix:lambda ( --> Term) {
##          <?before '{' | '->' > {{
##              my $line = $¢.lineof($¢.pos);
##              for 'if', 'unless', 'while', 'until', 'for', 'loop', 'given', 'when' {
##                  my $m = %*MYSTERY{$_};
##                  next unless $m;
##                  if $line - ($m.<line>//-123) < 5 {
##                      $¢.panic("$_() interpreted as function call at line " ~ $m.<line> ~
##                      "; please use whitespace instead of parens\nUnexpected block in infix position (two terms in a row)");
##                  }
##              }
##              return () if $*IN_REDUCE;
##              $¢.panic("Unexpected block in infix position (two terms in a row, or previous statement missing semicolon?)");
##          }}
##      }

sub infix__S_278lambda__PEEK { $_[0]->_AUTOLEXpeek('infix__S_278lambda',$retree) }
sub infix__S_278lambda {
my $self = shift;
local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;
my %args = @_;
local $sym = $args{sym} // 'lambda';


my $C = $self;
my $S = $C->{'_pos'};
$C->{'sym'} = $sym;

$self->_MATCHIFYr($S, "infix__S_278lambda",  map { STD::Term->coerce($_) } 
do {
if (my ($C) = ($C->before(sub { my $C=shift;
do {
my @result = eval {
my $trystate;
my ($tag, $try);
my @try;
my $relex;

my $fate;
if ($fate = $C->{'_fate'} and $fate->[1] eq 'infix__S_278lambda_01') {
$C->deb("Fate passed to infix__S_278lambda_01: ", ::fatestr($fate)) if $::DEBUG & DEBUG::fates;
($C->{'_fate'}, $tag, $try) = @$fate;
@try = ($try);
}

my @gather = ();
for (;;) {
if (not @try) {
$relex //= $C->cursor_fate('STD', 'infix__S_278lambda_01', $retree);
@try = $relex->($C, $trystate);
}
last unless @try;
$try = shift(@try) // next;

if (ref $try eq 'ARRAY') {
($C->{'_fate'}, $tag, $try) = @$try;	# next candidate fate
}

$C->deb("infix__S_278lambda_01 trying $tag $try") if $::DEBUG & DEBUG::try_processing;
push @gather, ((
sub { my $C=shift;
$C->_EXACT('{')
},
sub { my $C=shift;
$C->_EXACT('->')
},
)[$try])->($C);
last if @gather;
}
@gather;
};
if (@result) {
@result;
}
elsif ($@) {
my ($first) = $@ =~ /(^.*)/;
$self->deb("CAUGHT $first") if $::DEBUG & DEBUG::trace_call;
die $@ if $@ !~ /^ABORTBRANCH/;
();
}
else {
();
}
}

}))) {
scalar(do {

my $line = $C->lineof($C->{'_pos'});
for ('if', 'unless', 'while', 'until', 'for', 'loop', 'given', 'when') {
my $m = $::MYSTERY{$_};
next unless $m;
if ($line - ($m->{'line'}//-123) < 5) {
$C->panic("$_() interpreted as function call at line " . $m->{'line'} .
"; please use whitespace instead of parens\nUnexpected block in infix position (two terms in a row)");
}
};
return () if $::IN_REDUCE;
$C->panic("Unexpected block in infix position (two terms in a row, or previous statement missing semicolon?)");

}, $C);
}
else {
();
}
}
);
}

## token circumfix__S_279sigil (  :$sym is context<rw> = 'sigil' --> Term)
##      token circumfix:sigil ( --> Term)
##          { :dba('contextualizer') <sigil> '(' ~ ')' <semilist> { $*LEFTSIGIL ||= $<sigil>.Str } }

sub circumfix__S_279sigil__PEEK { $_[0]->_AUTOLEXpeek('circumfix__S_279sigil',$retree) }
sub circumfix__S_279sigil {
my $self = shift;
local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;
my %args = @_;
local $sym = $args{sym} // 'sigil';


my $C = $self;
my $S = $C->{'_pos'};
$C->{'sym'} = $sym;

$self->_MATCHIFY($S, "circumfix__S_279sigil",  Cursor::lazymap sub { STD::Term->coerce($_[0]) }, 
Cursor::lazymap(sub { my $C=$_[0];
Cursor::lazymap(sub { my $C=$_[0];
Cursor::lazymap(sub { my $C=$_[0];
Cursor::lazymap(sub { my $C=$_[0];
Cursor::lazymap(sub { my $C=$_[0];
scalar(do {
my $M = $C;  $::LEFTSIGIL ||= $M->{'sigil'}->Str ;
}, $C)
}, $C->_BRACKET( sub { my $C=shift;
do { my @gather;
eval { push @gather, $C->_EXACT(')')} // do {die $@ if $@ and $@ !~ /ABORT/;1} 
or
eval { push @gather, $C->FAILGOAL(')' , 'contextualizer')} or do { die $@ if $@ };
@gather;
}
}))
}, $C->_SUBSUME(['semilist'], sub {
my $C = shift;
$C->semilist
}))
}, $C->_COMMITBRANCH(local $::GOAL = ')' ))
}, $C->_EXACT('('))
}, $C->_SUBSUMEr(['sigil'], sub {
my $C = shift;
$C->sigil
}))
);
}

## token circumfix__S_280Paren_Thesis (  :$sym is context<rw> = <( )> --> Term)
##      token circumfix:sym<( )> ( --> Term)
##          { :dba('parenthesized expression') '(' ~ ')' <semilist> }

sub circumfix__S_280Paren_Thesis__PEEK { $_[0]->_AUTOLEXpeek('circumfix__S_280Paren_Thesis',$retree) }
sub circumfix__S_280Paren_Thesis {
my $self = shift;
local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;
my %args = @_;
local $sym = $args{sym} // [qw[( )]];


my $C = $self;
my $S = $C->{'_pos'};
$C->{'sym'} = $sym;

$self->_MATCHIFY($S, "circumfix__S_280Paren_Thesis",  Cursor::lazymap sub { STD::Term->coerce($_[0]) }, 
Cursor::lazymap(sub { my $C=$_[0];
Cursor::lazymap(sub { my $C=$_[0];
Cursor::lazymap(sub { my $C=$_[0];
$C->_BRACKET( sub { my $C=shift;
do { my @gather;
eval { push @gather, $C->_EXACT(')')} // do {die $@ if $@ and $@ !~ /ABORT/;1} 
or
eval { push @gather, $C->FAILGOAL(')' , 'parenthesized expression')} or do { die $@ if $@ };
@gather;
}
})
}, $C->_SUBSUME(['semilist'], sub {
my $C = shift;
$C->semilist
}))
}, $C->_COMMITBRANCH(local $::GOAL = ')' ))
}, $C->_EXACT('('))
);
}

## token circumfix__S_281Bra_Ket (  :$sym is context<rw> = <[ ]> --> Term)
##      token circumfix:sym<[ ]> ( --> Term)
##          { :dba('array composer') '[' ~ ']' <semilist> }

sub circumfix__S_281Bra_Ket__PEEK { $_[0]->_AUTOLEXpeek('circumfix__S_281Bra_Ket',$retree) }
sub circumfix__S_281Bra_Ket {
my $self = shift;
local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;
my %args = @_;
local $sym = $args{sym} // [qw([ ])];


my $C = $self;
my $S = $C->{'_pos'};
$C->{'sym'} = $sym;

$self->_MATCHIFY($S, "circumfix__S_281Bra_Ket",  Cursor::lazymap sub { STD::Term->coerce($_[0]) }, 
Cursor::lazymap(sub { my $C=$_[0];
Cursor::lazymap(sub { my $C=$_[0];
Cursor::lazymap(sub { my $C=$_[0];
$C->_BRACKET( sub { my $C=shift;
do { my @gather;
eval { push @gather, $C->_EXACT(']')} // do {die $@ if $@ and $@ !~ /ABORT/;1} 
or
eval { push @gather, $C->FAILGOAL(']' , 'array composer')} or do { die $@ if $@ };
@gather;
}
})
}, $C->_SUBSUME(['semilist'], sub {
my $C = shift;
$C->semilist
}))
}, $C->_COMMITBRANCH(local $::GOAL = ']' ))
}, $C->_EXACT('['))
);
}

#############
# Operators #
#############

## token PRE
##      token PRE {
##          :dba('prefix or meta-prefix')
##          [
##          | <prefix>
##              { $<O> = $<prefix><O>; $<sym> = $<prefix><sym> }
##                                                          {*}         #= prefix
##          | <prefix_circumfix_meta_operator>
##              { $<O> = $<prefix_circumfix_meta_operator><O>; $<sym> = $<prefix_circumfix_meta_operator>.Str }
##                                                          {*}         #= precircum
##          ]
##          # XXX assuming no precedence change
##          
##          <prefix_postfix_meta_operator>*                 {*}         #= prepost
##          <.ws>
##      }

sub PRE__PEEK { $_[0]->_AUTOLEXpeek('PRE',$retree) }
sub PRE {
my $self = shift;
local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;


my $C = $self;
my $S = $C->{'_pos'};
$C->{'prefix_postfix_meta_operator'} = [];

$self->_MATCHIFYr($S, "PRE", 
do {
if (my ($C) = ($C->_BRACKETr( sub { my $C=shift;
do {
my @result = eval {
my $trystate;
my ($tag, $try);
my @try;
my $relex;

my $fate;
if ($fate = $C->{'_fate'} and $fate->[1] eq 'PRE_01') {
$C->deb("Fate passed to PRE_01: ", ::fatestr($fate)) if $::DEBUG & DEBUG::fates;
($C->{'_fate'}, $tag, $try) = @$fate;
@try = ($try);
}

my @gather = ();
for (;;) {
if (not @try) {
$relex //= $C->cursor_fate('STD', 'PRE_01', $retree);
@try = $relex->($C, $trystate);
}
last unless @try;
$try = shift(@try) // next;

if (ref $try eq 'ARRAY') {
($C->{'_fate'}, $tag, $try) = @$try;	# next candidate fate
}

$C->deb("PRE_01 trying $tag $try") if $::DEBUG & DEBUG::try_processing;
push @gather, ((
sub { my $C=shift;
do {
if (my ($C) = ($C->_SUBSUMEr(['prefix'], sub {
my $C = shift;
$C->prefix
}))) {
do {
if (my ($C) = (scalar(do {
my $M = $C;  $M->{'O'} = $M->{'prefix'}{'O'}; $M->{'sym'} = $M->{'prefix'}{'sym'} ;
}, $C))) {
$C->_REDUCE($S, 'PRE', 'prefix');
}
else {
();
}
};
}
else {
();
}
}
},
sub { my $C=shift;
do {
if (my ($C) = ($C->_SUBSUMEr(['prefix_circumfix_meta_operator'], sub {
my $C = shift;
$C->prefix_circumfix_meta_operator
}))) {
do {
if (my ($C) = (scalar(do {
my $M = $C;  $M->{'O'} = $M->{'prefix_circumfix_meta_operator'}{'O'}; $M->{'sym'} = $M->{'prefix_circumfix_meta_operator'}->Str ;
}, $C))) {
$C->_REDUCE($S, 'PRE', 'precircum');
}
else {
();
}
};
}
else {
();
}
}
},
)[$try])->($C);
last if @gather;
}
@gather;
};
if (@result) {
@result;
}
elsif ($@) {
my ($first) = $@ =~ /(^.*)/;
$self->deb("CAUGHT $first") if $::DEBUG & DEBUG::trace_call;
die $@ if $@ !~ /^ABORTBRANCH/;
();
}
else {
();
}
}

}))) {
do {
if (my ($C) = ($C->_STARr(sub { my $C=shift;
$C->_SUBSUMEr(['prefix_postfix_meta_operator'], sub {
my $C = shift;
$C->prefix_postfix_meta_operator
})
}))) {
do {
if (my ($C) = ($C->_REDUCE($S, 'PRE', 'prepost'))) {
$C->ws;
}
else {
();
}
};
}
else {
();
}
};
}
else {
();
}
}
);
}

## token infixish ($in_meta = $*IN_META)
##      token infixish ($in_meta = $*IN_META) {
##          :my $infix;
##          :my $IN_META is context<rw> = $in_meta;
##          <!stdstopper>
##          <!infixstopper>
##          :dba('infix or meta-infix')
##          [
##          | <colonpair> {
##                  $<fake> = 1;
##                  $<sym> = ':';
##                  %<O><prec> = %item_assignment<prec>;  # actual test is non-inclusive!
##                  %<O><assoc> = 'unary';
##                  %<O><kind> = 'ADVERB';
##              }
##          | :dba('bracketed infix') '[' ~ ']' <infixish(1)> { $<O> = $<infixish><O>; $<sym> = $<infixish><sym>; }
##          | <infix_circumfix_meta_operator>
##              { $<O> = $<infix_circumfix_meta_operator><O>;
##                $<sym> = $<infix_circumfix_meta_operator><sym>; }
##          | <infix_prefix_meta_operator>
##              { $<O> = $<infix_prefix_meta_operator><O>;
##                $<sym> = $<infix_prefix_meta_operator><sym>; }
##          | <infix> <!before '='>
##                 { $<O> = $<infix>.<O>; $<sym> = $<infix>.<sym>; }
##          | <infix> <?before '='> <?{ $infix = $<infix>; }> <infix_postfix_meta_operator($infix)>
##                 { $<O> = $<infix_postfix_meta_operator>.<O>; $<sym> = $<infix_postfix_meta_operator>.<sym>; }
##          ]
##      }

sub infixish__PEEK { $_[0]->_AUTOLEXpeek('infixish',$retree) }
sub infixish {
my $self = shift;
local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;
my $in_meta = shift() // $::IN_META;
my $infix;
local $::IN_META = $in_meta;


my $C = $self;
my $S = $C->{'_pos'};

$self->_MATCHIFY($S, "infixish", 
Cursor::lazymap(sub { my $C=$_[0];
Cursor::lazymap(sub { my $C=$_[0];
$C->_BRACKET( sub { my $C=shift;
do {
my @result = eval {
my $trystate;
my ($tag, $try);
my @try;
my $relex;

my $fate;
if ($fate = $C->{'_fate'} and $fate->[1] eq 'infixish_01') {
$C->deb("Fate passed to infixish_01: ", ::fatestr($fate)) if $::DEBUG & DEBUG::fates;
($C->{'_fate'}, $tag, $try) = @$fate;
@try = ($try);
}

my @gather = ();
for (;;) {
if (not @try) {
$relex //= $C->cursor_fate('STD', 'infixish_01', $retree);
@try = $relex->($C, $trystate);
}
last unless @try;
$try = shift(@try) // next;

if (ref $try eq 'ARRAY') {
($C->{'_fate'}, $tag, $try) = @$try;	# next candidate fate
}

$C->deb("infixish_01 trying $tag $try") if $::DEBUG & DEBUG::try_processing;
push @gather, ((
sub { my $C=shift;
do {
if (my ($C) = ($C->_SUBSUMEr(['colonpair'], sub {
my $C = shift;
$C->colonpair
}))) {
scalar(do {
my $M = $C; 
$M->{'fake'} = 1;
$M->{'sym'} = ':';
$M->{'O'}{'prec'} = $item_assignment{'prec'};  # actual test is non-inclusive!
$M->{'O'}{'assoc'} = 'unary';
$M->{'O'}{'kind'} = 'ADVERB';
;
}, $C);
}
else {
();
}
}
},
sub { my $C=shift;
Cursor::lazymap(sub { my $C=$_[0];
Cursor::lazymap(sub { my $C=$_[0];
Cursor::lazymap(sub { my $C=$_[0];
Cursor::lazymap(sub { my $C=$_[0];
scalar(do {
my $M = $C;  $M->{'O'} = $M->{'infixish'}{'O'}; $M->{'sym'} = $M->{'infixish'}{'sym'}; ;
}, $C)
}, $C->_BRACKET( sub { my $C=shift;
do { my @gather;
eval { push @gather, $C->_EXACT(']')} // do {die $@ if $@ and $@ !~ /ABORT/;1} 
or
eval { push @gather, $C->FAILGOAL(']' , 'bracketed infix')} or do { die $@ if $@ };
@gather;
}
}))
}, $C->_SUBSUME(['infixish'], sub {
my $C = shift;
$C->infixish(1)
}))
}, $C->_COMMITBRANCH(local $::GOAL = ']' ))
}, $C->_EXACT('['))
},
sub { my $C=shift;
Cursor::lazymap(sub { my $C=$_[0];
scalar(do {
my $M = $C;  $M->{'O'} = $M->{'infix_circumfix_meta_operator'}{'O'};
$M->{'sym'} = $M->{'infix_circumfix_meta_operator'}{'sym'}; ;
}, $C)
}, $C->_SUBSUME(['infix_circumfix_meta_operator'], sub {
my $C = shift;
$C->infix_circumfix_meta_operator
}))
},
sub { my $C=shift;
Cursor::lazymap(sub { my $C=$_[0];
scalar(do {
my $M = $C;  $M->{'O'} = $M->{'infix_prefix_meta_operator'}{'O'};
$M->{'sym'} = $M->{'infix_prefix_meta_operator'}{'sym'}; ;
}, $C)
}, $C->_SUBSUME(['infix_prefix_meta_operator'], sub {
my $C = shift;
$C->infix_prefix_meta_operator
}))
},
sub { my $C=shift;
Cursor::lazymap(sub { my $C=$_[0];
Cursor::lazymap(sub { my $C=$_[0];
scalar(do {
my $M = $C;  $M->{'O'} = $M->{'infix'}->{'O'}; $M->{'sym'} = $M->{'infix'}->{'sym'}; ;
}, $C)
}, $C->_NOTBEFORE( sub { my $C=shift;
$C->before(sub { my $C=shift;
$C->_EXACT('=')
})
}))
}, $C->_SUBSUME(['infix'], sub {
my $C = shift;
$C->infix
}))
},
sub { my $C=shift;
Cursor::lazymap(sub { my $C=$_[0];
Cursor::lazymap(sub { my $C=$_[0];
Cursor::lazymap(sub { my $C=$_[0];
Cursor::lazymap(sub { my $C=$_[0];
scalar(do {
my $M = $C;  $M->{'O'} = $M->{'infix_postfix_meta_operator'}->{'O'}; $M->{'sym'} = $M->{'infix_postfix_meta_operator'}->{'sym'}; ;
}, $C)
}, $C->_SUBSUME(['infix_postfix_meta_operator'], sub {
my $C = shift;
$C->infix_postfix_meta_operator($infix)
}))
}, $C->before( sub { my $C=shift;
(($C) x !!do {
my $M = $C;  $infix = $M->{'infix'}; ;
})
}))
}, $C->before(sub { my $C=shift;
$C->_EXACT('=')
}))
}, $C->_SUBSUME(['infix'], sub {
my $C = shift;
$C->infix
}))
},
)[$try])->($C);
last if @gather;
}
@gather;
};
if (@result) {
@result;
}
elsif ($@) {
my ($first) = $@ =~ /(^.*)/;
$self->deb("CAUGHT $first") if $::DEBUG & DEBUG::trace_call;
die $@ if $@ !~ /^ABORTBRANCH/;
();
}
else {
();
}
}

})
}, $C->_NOTBEFORE( sub { my $C=shift;
$C->infixstopper
}))
}, $C->_NOTBEFORE( sub { my $C=shift;
$C->stdstopper
}))
);
}

# doing fancy as one rule simplifies LTM
## token dotty__S_282DotStar (:$endsym is context = 'unspacey'  , :$sym is context<rw> = <.*> --> Methodcall)
##      token dotty:sym<.*> ( --> Methodcall) {
##          ('.' [ <[+*?=]> | '^' '!'? ]) :: <.unspacey> <dottyop>
##          { $<sym> = $0.Str; }
##      }

sub dotty__S_282DotStar__PEEK { $_[0]->_AUTOLEXpeek('dotty__S_282DotStar',$retree) }
sub dotty__S_282DotStar {
my $self = shift;
local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;
my %args = @_;
local $endsym = $args{endsym} // 'unspacey'  ;
local $sym = $args{sym} // q(.*);


my $C = $self;
my $S = $C->{'_pos'};
$C->{'sym'} = $sym;

$self->_MATCHIFY($S, "dotty__S_282DotStar",  Cursor::lazymap sub { STD::Methodcall->coerce($_[0]) }, 
Cursor::lazymap(sub { my $C=$_[0];
Cursor::lazymap(sub { my $C=$_[0];
Cursor::lazymap(sub { my $C=$_[0];
Cursor::lazymap(sub { my $C=$_[0];
scalar(do {
my $M = $C;  $M->{'sym'} = $C->{'0'}->Str; ;
}, $C)
}, $C->_SUBSUME(['dottyop'], sub {
my $C = shift;
$C->dottyop
}))
}, $C->unspacey)
}, $C->_COMMITBRANCH())
},     $C->_SUBSUMEr(['0'], sub {
my $C = shift;
do { $C->_PAREN( sub { my $C=shift;
do {
if (my ($C) = ($C->_EXACT('.'))) {
$C->_BRACKETr( sub { my $C=shift;
do {
my @result = eval {
my $trystate;
my ($tag, $try);
my @try;
my $relex;

my $fate;
if ($fate = $C->{'_fate'} and $fate->[1] eq 'dotty__S_282DotStar_02') {
$C->deb("Fate passed to dotty__S_282DotStar_02: ", ::fatestr($fate)) if $::DEBUG & DEBUG::fates;
($C->{'_fate'}, $tag, $try) = @$fate;
@try = ($try);
}

my @gather = ();
for (;;) {
if (not @try) {
$relex //= $C->cursor_fate('STD', 'dotty__S_282DotStar_02', $retree);
@try = $relex->($C, $trystate);
}
last unless @try;
$try = shift(@try) // next;

if (ref $try eq 'ARRAY') {
($C->{'_fate'}, $tag, $try) = @$try;	# next candidate fate
}

$C->deb("dotty__S_282DotStar_02 trying $tag $try") if $::DEBUG & DEBUG::try_processing;
push @gather, ((
sub { my $C=shift;
$C->_PATTERN(qr/\G[+*?=]/)
},
sub { my $C=shift;
do {
if (my ($C) = ($C->_EXACT('^'))) {
$C->_OPTr(sub { my $C=shift;
$C->_EXACT('!')
});
}
else {
();
}
}
},
)[$try])->($C);
last if @gather;
}
@gather;
};
if (@result) {
@result;
}
elsif ($@) {
my ($first) = $@ =~ /(^.*)/;
$self->deb("CAUGHT $first") if $::DEBUG & DEBUG::trace_call;
die $@ if $@ !~ /^ABORTBRANCH/;
();
}
else {
();
}
}

});
}
else {
();
}
}
})}
}))
);
}

## token dotty__S_283Dot (:$endsym is context = 'unspacey'  , :$sym is context<rw> = <.> --> Methodcall)
##      token dotty:sym<.> ( --> Methodcall) {
##          <sym> <dottyop>
##      }

sub dotty__S_283Dot__PEEK { $_[0]->_AUTOLEXpeek('dotty__S_283Dot',$retree) }
sub dotty__S_283Dot {
my $self = shift;
local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;
my %args = @_;
local $endsym = $args{endsym} // 'unspacey'  ;
local $sym = $args{sym} // q(.);


my $C = $self;
my $S = $C->{'_pos'};
$C->{'sym'} = $sym;

$self->_MATCHIFYr($S, "dotty__S_283Dot",  map { STD::Methodcall->coerce($_) } 
do {
if (my ($C) = ($C->_PATTERN(qr/\G\./))) {
do {
if (my ($C) = ($C->unspacey)) {
$C->_SUBSUMEr(['dottyop'], sub {
my $C = shift;
$C->dottyop
});
}
else {
();
}
};
}
else {
();
}
}
);
}

## token privop ( --> Methodcall)
##      token privop ( --> Methodcall) {
##          '!' <methodop>
##      }

sub privop__PEEK { $_[0]->_AUTOLEXpeek('privop',$retree) }
sub privop {
my $self = shift;
local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;


my $C = $self;
my $S = $C->{'_pos'};

$self->_MATCHIFYr($S, "privop",  map { STD::Methodcall->coerce($_) } 
do {
if (my ($C) = ($C->_EXACT('!'))) {
$C->_SUBSUMEr(['methodop'], sub {
my $C = shift;
$C->methodop
});
}
else {
();
}
}
);
}

## token dottyopish
##      token dottyopish {
##          <noun=dottyop>
##      }

sub dottyopish__PEEK { $_[0]->_AUTOLEXpeek('dottyopish',$retree) }
sub dottyopish {
my $self = shift;
local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;


my $C = $self;
my $S = $C->{'_pos'};

$self->_MATCHIFYr($S, "dottyopish", 
$C->_SUBSUMEr(['noun'], sub {
my $C = shift;
$C->dottyop
})
);
}

## token dottyop
##      token dottyop {
##          :dba('dotty method or postfix')
##          [
##          | <methodop>
##          | <colonpair>
##          | <!alpha> <postop> { $<O> = $<postop><O>; $<sym> = $<postop><sym>; }  # only non-alpha postfixes have dotty form
##          ]
##      }

sub dottyop__PEEK { $_[0]->_AUTOLEXpeek('dottyop',$retree) }
sub dottyop {
my $self = shift;
local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;


my $C = $self;
my $S = $C->{'_pos'};

$self->_MATCHIFYr($S, "dottyop", 
$C->_BRACKETr( sub { my $C=shift;
do {
my @result = eval {
my $trystate;
my ($tag, $try);
my @try;
my $relex;

my $fate;
if ($fate = $C->{'_fate'} and $fate->[1] eq 'dottyop_01') {
$C->deb("Fate passed to dottyop_01: ", ::fatestr($fate)) if $::DEBUG & DEBUG::fates;
($C->{'_fate'}, $tag, $try) = @$fate;
@try = ($try);
}

my @gather = ();
for (;;) {
if (not @try) {
$relex //= $C->cursor_fate('STD', 'dottyop_01', $retree);
@try = $relex->($C, $trystate);
}
last unless @try;
$try = shift(@try) // next;

if (ref $try eq 'ARRAY') {
($C->{'_fate'}, $tag, $try) = @$try;	# next candidate fate
}

$C->deb("dottyop_01 trying $tag $try") if $::DEBUG & DEBUG::try_processing;
push @gather, ((
sub { my $C=shift;
$C->_SUBSUMEr(['methodop'], sub {
my $C = shift;
$C->methodop
})
},
sub { my $C=shift;
$C->_SUBSUMEr(['colonpair'], sub {
my $C = shift;
$C->colonpair
})
},
sub { my $C=shift;
do {
if (my ($C) = ($C->_NOTBEFORE( sub { my $C=shift;
$C->_PATTERN(qr/\G[_[:alpha:]]/)
}))) {
do {
if (my ($C) = ($C->_SUBSUMEr(['postop'], sub {
my $C = shift;
$C->postop
}))) {
scalar(do {
my $M = $C;  $M->{'O'} = $M->{'postop'}{'O'}; $M->{'sym'} = $M->{'postop'}{'sym'}; ;
}, $C);
}
else {
();
}
};
}
else {
();
}
}
},
)[$try])->($C);
last if @gather;
}
@gather;
};
if (@result) {
@result;
}
elsif ($@) {
my ($first) = $@ =~ /(^.*)/;
$self->deb("CAUGHT $first") if $::DEBUG & DEBUG::trace_call;
die $@ if $@ !~ /^ABORTBRANCH/;
();
}
else {
();
}
}

})
);
}

# Note, this rule mustn't do anything irreversible because it's used
# as a lookahead by the quote interpolator.

## token POST
##      token POST {
##          <!stdstopper>
##      
##          # last whitespace didn't end here
##          <!{ @*MEMOS[$¢.pos]<ws> }>
##      
##          [ <.unsp> | '\\' ]?
##      
##          [ ['.' <.unsp>?]? <postfix_prefix_meta_operator> <.unsp>? ]*
##      
##          :dba('postfix')
##          [
##          | <dotty>  { $<O> = $<dotty><O>;  $<sym> = $<dotty><sym>;  $<~CAPS> = $<dotty><~CAPS>; }
##          | <privop> { $<O> = $<privop><O>; $<sym> = $<privop><sym>; $<~CAPS> = $<privop><~CAPS>; }
##          | <postop> { $<O> = $<postop><O>; $<sym> = $<postop><sym>; $<~CAPS> = $<postop><~CAPS>; }
##          ]
##          { $*LEFTSIGIL = '@'; }
##      }

sub POST__PEEK { $_[0]->_AUTOLEXpeek('POST',$retree) }
sub POST {
my $self = shift;
local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;


my $C = $self;
my $S = $C->{'_pos'};
$C->{'postfix_prefix_meta_operator'} = [];

$self->_MATCHIFYr($S, "POST", 
do {
if (my ($C) = ($C->_NOTBEFORE( sub { my $C=shift;
$C->stdstopper
}))) {
do {
if (my ($C) = ($C->_NOTBEFORE( sub { my $C=shift;
(($C) x !!do {
$::MEMOS[$C->{'_pos'}]{'ws'} 
})
}))) {
do {
if (my ($C) = ($C->_OPTr(sub { my $C=shift;
$C->_BRACKETr( sub { my $C=shift;
do {
my @result = eval {
my $trystate;
my ($tag, $try);
my @try;
my $relex;

my $fate;
if ($fate = $C->{'_fate'} and $fate->[1] eq 'POST_01') {
$C->deb("Fate passed to POST_01: ", ::fatestr($fate)) if $::DEBUG & DEBUG::fates;
($C->{'_fate'}, $tag, $try) = @$fate;
@try = ($try);
}

my @gather = ();
for (;;) {
if (not @try) {
$relex //= $C->cursor_fate('STD', 'POST_01', $retree);
@try = $relex->($C, $trystate);
}
last unless @try;
$try = shift(@try) // next;

if (ref $try eq 'ARRAY') {
($C->{'_fate'}, $tag, $try) = @$try;	# next candidate fate
}

$C->deb("POST_01 trying $tag $try") if $::DEBUG & DEBUG::try_processing;
push @gather, ((
sub { my $C=shift;
$C->unsp
},
sub { my $C=shift;
$C->_EXACT('\\')
},
)[$try])->($C);
last if @gather;
}
@gather;
};
if (@result) {
@result;
}
elsif ($@) {
my ($first) = $@ =~ /(^.*)/;
$self->deb("CAUGHT $first") if $::DEBUG & DEBUG::trace_call;
die $@ if $@ !~ /^ABORTBRANCH/;
();
}
else {
();
}
}

})
}))) {
do {
if (my ($C) = ($C->_STARr(sub { my $C=shift;
$C->_BRACKETr( sub { my $C=shift;
do {
if (my ($C) = ($C->_OPTr(sub { my $C=shift;
$C->_BRACKETr( sub { my $C=shift;
do {
if (my ($C) = ($C->_EXACT('.'))) {
$C->_OPTr(sub { my $C=shift;
$C->unsp
});
}
else {
();
}
}
})
}))) {
do {
if (my ($C) = ($C->_SUBSUMEr(['postfix_prefix_meta_operator'], sub {
my $C = shift;
$C->postfix_prefix_meta_operator
}))) {
$C->_OPTr(sub { my $C=shift;
$C->unsp
});
}
else {
();
}
};
}
else {
();
}
}
})
}))) {
do {
if (my ($C) = ($C->_BRACKETr( sub { my $C=shift;
do {
my @result = eval {
my $trystate;
my ($tag, $try);
my @try;
my $relex;

my $fate;
if ($fate = $C->{'_fate'} and $fate->[1] eq 'POST_04') {
$C->deb("Fate passed to POST_04: ", ::fatestr($fate)) if $::DEBUG & DEBUG::fates;
($C->{'_fate'}, $tag, $try) = @$fate;
@try = ($try);
}

my @gather = ();
for (;;) {
if (not @try) {
$relex //= $C->cursor_fate('STD', 'POST_04', $retree);
@try = $relex->($C, $trystate);
}
last unless @try;
$try = shift(@try) // next;

if (ref $try eq 'ARRAY') {
($C->{'_fate'}, $tag, $try) = @$try;	# next candidate fate
}

$C->deb("POST_04 trying $tag $try") if $::DEBUG & DEBUG::try_processing;
push @gather, ((
sub { my $C=shift;
do {
if (my ($C) = ($C->_SUBSUMEr(['dotty'], sub {
my $C = shift;
$C->dotty
}))) {
scalar(do {
my $M = $C;  $M->{'O'} = $M->{'dotty'}{'O'};  $M->{'sym'} = $M->{'dotty'}{'sym'};  $M->{'~CAPS'} = $M->{'dotty'}{'~CAPS'}; ;
}, $C);
}
else {
();
}
}
},
sub { my $C=shift;
do {
if (my ($C) = ($C->_SUBSUMEr(['privop'], sub {
my $C = shift;
$C->privop
}))) {
scalar(do {
my $M = $C;  $M->{'O'} = $M->{'privop'}{'O'}; $M->{'sym'} = $M->{'privop'}{'sym'}; $M->{'~CAPS'} = $M->{'privop'}{'~CAPS'}; ;
}, $C);
}
else {
();
}
}
},
sub { my $C=shift;
do {
if (my ($C) = ($C->_SUBSUMEr(['postop'], sub {
my $C = shift;
$C->postop
}))) {
scalar(do {
my $M = $C;  $M->{'O'} = $M->{'postop'}{'O'}; $M->{'sym'} = $M->{'postop'}{'sym'}; $M->{'~CAPS'} = $M->{'postop'}{'~CAPS'}; ;
}, $C);
}
else {
();
}
}
},
)[$try])->($C);
last if @gather;
}
@gather;
};
if (@result) {
@result;
}
elsif ($@) {
my ($first) = $@ =~ /(^.*)/;
$self->deb("CAUGHT $first") if $::DEBUG & DEBUG::trace_call;
die $@ if $@ !~ /^ABORTBRANCH/;
();
}
else {
();
}
}

}))) {
scalar(do {
$::LEFTSIGIL = '@'; 
}, $C);
}
else {
();
}
};
}
else {
();
}
};
}
else {
();
}
};
}
else {
();
}
};
}
else {
();
}
}
);
}

## method can_meta ($op, $meta)
sub can_meta {
my $self = shift;
my $op = shift;
my $meta = shift;


!$op->{'O'}{'fiddly'} ||
$self->panic("Can't " . $meta . " " . $op->{'sym'} . " because " . $op->{'O'}{'dba'} . " operators are too fiddly");
$self;
}

## regex prefix_circumfix_meta_operator__S_284reduce ( :$sym is context<rw> = 'reduce' --> List_prefix)
##      regex prefix_circumfix_meta_operator:reduce (--> List_prefix) {
##          :my $IN_REDUCE is context<rw> = 1;
##          <?before '['\S+']'>
##          $<s> = (
##              '['
##              [
##              || <op=infixish(1)> <?before ']'>
##              || \\<op=infixish(1)> <?before ']'>
##              || <!>
##              ]
##          )
##          [ <?> || <.worry: "Malformed reduce"> <!> ] ']' ['«'|<?>]
##      
##          <.can_meta($<s><op>, "reduce")>
##      
##          [
##          || <!{ $<s><op><O><diffy> }>
##          || <?{ $<s><op><O><assoc> eq 'chain' }>
##          || <.panic("Can't reduce " ~ $<s><op><sym> ~ " because " ~ $<s><op><O><dba> ~ " operators are diffy and not chaining")>
##          ]
##      
##          { $<O> = $<s><op><O>; $<O><prec>:delete; $<O><assoc> = 'unary'; $<O><uassoc> = 'left'; }
##          { $<sym> = $<s>.Str; }
##      
##          [ <?before '('> || <?before \s+ [ <?stdstopper> { $<O><noun> = 1 } ]? > || { $<O><noun> = 1 } ]
##      }

sub prefix_circumfix_meta_operator__S_284reduce__PEEK { $_[0]->_AUTOLEXpeek('prefix_circumfix_meta_operator__S_284reduce',$retree) }
sub prefix_circumfix_meta_operator__S_284reduce {
my $self = shift;
local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;
my %args = @_;
local $sym = $args{sym} // 'reduce';
local $::IN_REDUCE = 1;


my $C = $self;
my $S = $C->{'_pos'};
$C->{'sym'} = $sym;

$self->_MATCHIFY($S, "prefix_circumfix_meta_operator__S_284reduce",  Cursor::lazymap sub { STD::List_prefix->coerce($_[0]) }, 
Cursor::lazymap(sub { my $C=$_[0];
Cursor::lazymap(sub { my $C=$_[0];
Cursor::lazymap(sub { my $C=$_[0];
Cursor::lazymap(sub { my $C=$_[0];
Cursor::lazymap(sub { my $C=$_[0];
Cursor::lazymap(sub { my $C=$_[0];
Cursor::lazymap(sub { my $C=$_[0];
Cursor::lazymap(sub { my $C=$_[0];
Cursor::lazymap(sub { my $C=$_[0];
$C->_BRACKET( sub { my $C=shift;
do { my @gather;
eval { push @gather, $C->before(sub { my $C=shift;
$C->_EXACT('(')
})} // do {die $@ if $@ and $@ !~ /ABORT/;1} 
or
eval { push @gather, $C->before(sub { my $C=shift;
Cursor::lazymap(sub { my $C=$_[0];
$C->_OPTg(sub { my $C=shift;
$C->_BRACKET( sub { my $C=shift;
Cursor::lazymap(sub { my $C=$_[0];
scalar(do {
my $M = $C;  $M->{'O'}{'noun'} = 1 ;
}, $C)
}, $C->before( sub { my $C=shift;
$C->stdstopper
}))
})
})
}, $C->_PATTERN(qr/\G((?:\s)+)/))
})} // do {die $@ if $@ and $@ !~ /ABORT/;1} 
or
eval { push @gather, scalar(do {
my $M = $C;  $M->{'O'}{'noun'} = 1 ;
}, $C)} or do { die $@ if $@ };
@gather;
}
})
}, scalar(do {
my $M = $C;  $M->{'sym'} = $M->{'s'}->Str; ;
}, $C))
}, scalar(do {
my $M = $C;  $M->{'O'} = $M->{'s'}{'op'}{'O'}; delete $M->{'O'}{'prec'}; $M->{'O'}{'assoc'} = 'unary'; $M->{'O'}{'uassoc'} = 'left'; ;
}, $C))
}, $C->_BRACKET( sub { my $C=shift;
do { my @gather;
eval { push @gather, $C->_NOTBEFORE( sub { my $C=shift;
(($C) x !!do {
my $M = $C;  $M->{'s'}{'op'}{'O'}{'diffy'} ;
})
})} // do {die $@ if $@ and $@ !~ /ABORT/;1} 
or
eval { push @gather, $C->before( sub { my $C=shift;
(($C) x !!do {
my $M = $C;  $M->{'s'}{'op'}{'O'}{'assoc'} eq 'chain' ;
})
})} // do {die $@ if $@ and $@ !~ /ABORT/;1} 
or
eval { push @gather, do { my $M = $C;
$C->panic("Can't reduce " . $M->{'s'}{'op'}{'sym'} . " because " . $M->{'s'}{'op'}{'O'}{'dba'} . " operators are diffy and not chaining")
; }} or do { die $@ if $@ };
@gather;
}
}))
}, do { my $M = $C;
$C->can_meta($M->{'s'}{'op'}, "reduce")
; })
}, $C->_BRACKET( sub { my $C=shift;
do {
my @result = eval {
my $trystate;
my ($tag, $try);
my @try;
my $relex;

my $fate;
if ($fate = $C->{'_fate'} and $fate->[1] eq 'prefix_circumfix_meta_operator__S_284reduce_10') {
$C->deb("Fate passed to prefix_circumfix_meta_operator__S_284reduce_10: ", ::fatestr($fate)) if $::DEBUG & DEBUG::fates;
($C->{'_fate'}, $tag, $try) = @$fate;
@try = ($try);
}

my @gather = ();
for (;;) {
if (not @try) {
$relex //= $C->cursor_fate('STD', 'prefix_circumfix_meta_operator__S_284reduce_10', $retree);
@try = $relex->($C, $trystate);
}
last unless @try;
$try = shift(@try) // next;

if (ref $try eq 'ARRAY') {
($C->{'_fate'}, $tag, $try) = @$try;	# next candidate fate
}

$C->deb("prefix_circumfix_meta_operator__S_284reduce_10 trying $tag $try") if $::DEBUG & DEBUG::try_processing;
push @gather, ((
sub { my $C=shift;
$C->_EXACT('«')
},
sub { my $C=shift;
$C->before( sub { my $C=shift;
$C
})
},
)[$try])->($C);
last if @gather;
}
@gather;
};
if (@result) {
@result;
}
elsif ($@) {
my ($first) = $@ =~ /(^.*)/;
$self->deb("CAUGHT $first") if $::DEBUG & DEBUG::trace_call;
die $@ if $@ !~ /^ABORTBRANCH/;
();
}
else {
();
}
}

}))
}, $C->_EXACT(']'))
}, $C->_BRACKET( sub { my $C=shift;
do { my @gather;
eval { push @gather, $C->before( sub { my $C=shift;
$C
})} // do {die $@ if $@ and $@ !~ /ABORT/;1} 
or
eval { push @gather, Cursor::lazymap(sub { my $C=$_[0];
$C->_NOTBEFORE( sub { my $C=shift;
$C
})
}, $C->worry("Malformed reduce"))} or do { die $@ if $@ };
@gather;
}
}))
},     $C->_SUBSUME(['s'], sub {
my $C = shift;
do { $C->_PAREN( sub { my $C=shift;
Cursor::lazymap(sub { my $C=$_[0];
$C->_BRACKET( sub { my $C=shift;
do { my @gather;
eval { push @gather, Cursor::lazymap(sub { my $C=$_[0];
$C->before(sub { my $C=shift;
$C->_EXACT(']')
})
},     $C->_SUBSUME(['op'], sub {
my $C = shift;
$C->infixish(1)
}))} // do {die $@ if $@ and $@ !~ /ABORT/;1} 
or
eval { push @gather, Cursor::lazymap(sub { my $C=$_[0];
Cursor::lazymap(sub { my $C=$_[0];
$C->before(sub { my $C=shift;
$C->_EXACT(']')
})
},     $C->_SUBSUME(['op'], sub {
my $C = shift;
$C->infixish(1)
}))
}, $C->_EXACT('\\'))} // do {die $@ if $@ and $@ !~ /ABORT/;1} 
or
eval { push @gather, $C->_NOTBEFORE( sub { my $C=shift;
$C
})} or do { die $@ if $@ };
@gather;
}
})
}, $C->_EXACT('['))
})}
}))
}, $C->before(sub { my $C=shift;
Cursor::lazymap(sub { my $C=$_[0];
Cursor::lazymap(sub { my $C=$_[0];
$C->_EXACT(']')
}, $C->_PLUSg(sub { my $C=shift;
$C->_NOTCHAR( sub { my $C=shift;
$C->_PATTERN(qr/\G\s/)
})
}))
}, $C->_EXACT('['))
}))
);
}

## token prefix_postfix_meta_operator__S_285Fre (:$sym is context<rw> = < « >)
##      token prefix_postfix_meta_operator:sym< « >    { <sym> | '<<' }

sub prefix_postfix_meta_operator__S_285Fre__PEEK { $_[0]->_AUTOLEXpeek('prefix_postfix_meta_operator__S_285Fre',$retree) }
sub prefix_postfix_meta_operator__S_285Fre {
my $self = shift;
local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;
my %args = @_;
local $sym = $args{sym} // [qw( « )];


my $C = $self;
my $S = $C->{'_pos'};
$C->{'sym'} = $sym;

$self->_MATCHIFYr($S, "prefix_postfix_meta_operator__S_285Fre", 
do {
my @result = eval {
my $trystate;
my ($tag, $try);
my @try;
my $relex;

my $fate;
if ($fate = $C->{'_fate'} and $fate->[1] eq 'prefix_postfix_meta_operator__S_285Fre_00') {
$C->deb("Fate passed to prefix_postfix_meta_operator__S_285Fre_00: ", ::fatestr($fate)) if $::DEBUG & DEBUG::fates;
($C->{'_fate'}, $tag, $try) = @$fate;
@try = ($try);
}

my @gather = ();
for (;;) {
if (not @try) {
$relex //= $C->cursor_fate('STD', 'prefix_postfix_meta_operator__S_285Fre_00', $retree);
@try = $relex->($C, $trystate);
}
last unless @try;
$try = shift(@try) // next;

if (ref $try eq 'ARRAY') {
($C->{'_fate'}, $tag, $try) = @$try;	# next candidate fate
}

$C->deb("prefix_postfix_meta_operator__S_285Fre_00 trying $tag $try") if $::DEBUG & DEBUG::try_processing;
push @gather, ((
sub { my $C=shift;
$C->_PATTERN(qr/\G«/)
},
sub { my $C=shift;
$C->_EXACT('<<')
},
)[$try])->($C);
last if @gather;
}
@gather;
};
if (@result) {
@result;
}
elsif ($@) {
my ($first) = $@ =~ /(^.*)/;
$self->deb("CAUGHT $first") if $::DEBUG & DEBUG::trace_call;
die $@ if $@ !~ /^ABORTBRANCH/;
();
}
else {
();
}
}

);
}

## token postfix_prefix_meta_operator__S_286Nch (:$sym is context<rw> = < » >)
##      token postfix_prefix_meta_operator:sym< » >    {
##          [ <sym> | '>>' ]
##          # require >>.( on interpolated hypercall so infix:«$s»($a,$b) {...} dwims
##          [<!{ $*QSIGIL }> || <!before '('> ]
##      }

sub postfix_prefix_meta_operator__S_286Nch__PEEK { $_[0]->_AUTOLEXpeek('postfix_prefix_meta_operator__S_286Nch',$retree) }
sub postfix_prefix_meta_operator__S_286Nch {
my $self = shift;
local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;
my %args = @_;
local $sym = $args{sym} // [qw( » )];


my $C = $self;
my $S = $C->{'_pos'};
$C->{'sym'} = $sym;

$self->_MATCHIFYr($S, "postfix_prefix_meta_operator__S_286Nch", 
do {
if (my ($C) = ($C->_BRACKETr( sub { my $C=shift;
do {
my @result = eval {
my $trystate;
my ($tag, $try);
my @try;
my $relex;

my $fate;
if ($fate = $C->{'_fate'} and $fate->[1] eq 'postfix_prefix_meta_operator__S_286Nch_01') {
$C->deb("Fate passed to postfix_prefix_meta_operator__S_286Nch_01: ", ::fatestr($fate)) if $::DEBUG & DEBUG::fates;
($C->{'_fate'}, $tag, $try) = @$fate;
@try = ($try);
}

my @gather = ();
for (;;) {
if (not @try) {
$relex //= $C->cursor_fate('STD', 'postfix_prefix_meta_operator__S_286Nch_01', $retree);
@try = $relex->($C, $trystate);
}
last unless @try;
$try = shift(@try) // next;

if (ref $try eq 'ARRAY') {
($C->{'_fate'}, $tag, $try) = @$try;	# next candidate fate
}

$C->deb("postfix_prefix_meta_operator__S_286Nch_01 trying $tag $try") if $::DEBUG & DEBUG::try_processing;
push @gather, ((
sub { my $C=shift;
$C->_PATTERN(qr/\G»/)
},
sub { my $C=shift;
$C->_EXACT('>>')
},
)[$try])->($C);
last if @gather;
}
@gather;
};
if (@result) {
@result;
}
elsif ($@) {
my ($first) = $@ =~ /(^.*)/;
$self->deb("CAUGHT $first") if $::DEBUG & DEBUG::trace_call;
die $@ if $@ !~ /^ABORTBRANCH/;
();
}
else {
();
}
}

}))) {
$C->_BRACKETr( sub { my $C=shift;
do { my @gather;
eval { push @gather, $C->_NOTBEFORE( sub { my $C=shift;
(($C) x !!do {
$::QSIGIL 
})
})} // do {die $@ if $@ and $@ !~ /ABORT/;1} 
or
eval { push @gather, $C->_NOTBEFORE( sub { my $C=shift;
$C->before(sub { my $C=shift;
$C->_EXACT('(')
})
})} or do { die $@ if $@ };
@gather;
}
});
}
else {
();
}
}
);
}

## token infix_prefix_meta_operator__S_287Bang (  :$sym is context<rw> = <!> --> Transparent)
##      token infix_prefix_meta_operator:sym<!> ( --> Transparent) {
##          <sym> <!before '!'> {} <infixish(1)>
##      
##          [
##          || <?{ $<infixish>.Str eq '=' }>
##             { $¢ = ::Chaining.coerce($¢); }
##             
##          || <.can_meta($<infixish>, "negate")>    
##             <?{ $<infixish><O><iffy> }>
##             <?{ $<O> = $<infixish><O>; }>
##              
##          || <.panic("Can't negate " ~ $<infixish>.Str ~ " because " ~ $<infixish><O><dba> ~ " operators are not iffy enough")>
##          ]
##      }

sub infix_prefix_meta_operator__S_287Bang__PEEK { $_[0]->_AUTOLEXpeek('infix_prefix_meta_operator__S_287Bang',$retree) }
sub infix_prefix_meta_operator__S_287Bang {
my $self = shift;
local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;
my %args = @_;
local $sym = $args{sym} // q(!);


my $C = $self;
my $S = $C->{'_pos'};
$C->{'sym'} = $sym;

$self->_MATCHIFYr($S, "infix_prefix_meta_operator__S_287Bang",  map { STD::Transparent->coerce($_) } 
do {
if (my ($C) = ($C->_PATTERN(qr/\G\!/))) {
do {
if (my ($C) = ($C->_NOTBEFORE( sub { my $C=shift;
$C->before(sub { my $C=shift;
$C->_EXACT('!')
})
}))) {
do {
if (my ($C) = (scalar(do {

}, $C))) {
do {
if (my ($C) = ($C->_SUBSUMEr(['infixish'], sub {
my $C = shift;
$C->infixish(1)
}))) {
$C->_BRACKETr( sub { my $C=shift;
do { my @gather;
eval { push @gather, do {
if (my ($C) = ($C->before( sub { my $C=shift;
(($C) x !!do {
my $M = $C;  $M->{'infixish'}->Str eq '=' ;
})
}))) {
scalar(do {
$C = 'STD::Chaining'->coerce($C); 
}, $C);
}
else {
();
}
}} // do {die $@ if $@ and $@ !~ /ABORT/;1} 
or
eval { push @gather, do {
if (my ($C) = (do { my $M = $C;
$C->can_meta($M->{'infixish'}, "negate")
; })) {
do {
if (my ($C) = ($C->before( sub { my $C=shift;
(($C) x !!do {
my $M = $C;  $M->{'infixish'}{'O'}{'iffy'} ;
})
}))) {
$C->before( sub { my $C=shift;
(($C) x !!do {
my $M = $C;  $M->{'O'} = $M->{'infixish'}{'O'}; ;
})
});
}
else {
();
}
};
}
else {
();
}
}} // do {die $@ if $@ and $@ !~ /ABORT/;1} 
or
eval { push @gather, do { my $M = $C;
$C->panic("Can't negate " . $M->{'infixish'}->Str . " because " . $M->{'infixish'}{'O'}{'dba'} . " operators are not iffy enough")
; }} or do { die $@ if $@ };
@gather;
}
});
}
else {
();
}
};
}
else {
();
}
};
}
else {
();
}
};
}
else {
();
}
}
);
}

## token infix_prefix_meta_operator__S_288R (  :$sym is context<rw> = <R> --> Transparent)
##      token infix_prefix_meta_operator:sym<R> ( --> Transparent) {
##          <sym> {} <infixish(1)>
##          <.can_meta($<infixish>, "reverse")>
##          <?{ $<O> = $<infixish><O>; }>
##      }

sub infix_prefix_meta_operator__S_288R__PEEK { $_[0]->_AUTOLEXpeek('infix_prefix_meta_operator__S_288R',$retree) }
sub infix_prefix_meta_operator__S_288R {
my $self = shift;
local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;
my %args = @_;
local $sym = $args{sym} // q(R);


my $C = $self;
my $S = $C->{'_pos'};
$C->{'sym'} = $sym;

$self->_MATCHIFYr($S, "infix_prefix_meta_operator__S_288R",  map { STD::Transparent->coerce($_) } 
do {
if (my ($C) = ($C->_PATTERN(qr/\GR/))) {
do {
if (my ($C) = (scalar(do {

}, $C))) {
do {
if (my ($C) = ($C->_SUBSUMEr(['infixish'], sub {
my $C = shift;
$C->infixish(1)
}))) {
do {
if (my ($C) = (do { my $M = $C;
$C->can_meta($M->{'infixish'}, "reverse")
; })) {
$C->before( sub { my $C=shift;
(($C) x !!do {
my $M = $C;  $M->{'O'} = $M->{'infixish'}{'O'}; ;
})
});
}
else {
();
}
};
}
else {
();
}
};
}
else {
();
}
};
}
else {
();
}
}
);
}

#method lex1 (Str $s) {
#    self.<O>{$s}++ and self.panic("Nested $s metaoperators not allowed");
#    self;
#}

## token infix_prefix_meta_operator__S_289X (  :$sym is context<rw> = <X> --> List_infix)
##      token infix_prefix_meta_operator:sym<X> ( --> List_infix) {
##          <sym> {}
##          [ <infixish(1)>
##              [X <.panic: "Old form of XopX found">]?
##              <.can_meta($<infixish>[0], "cross")>
##              <?{ $<O> = $<infixish>[0]<O>; $<O><prec>:delete; $<sym> ~= $<infixish>[0].Str }>
##          ]?
##      }

sub infix_prefix_meta_operator__S_289X__PEEK { $_[0]->_AUTOLEXpeek('infix_prefix_meta_operator__S_289X',$retree) }
sub infix_prefix_meta_operator__S_289X {
my $self = shift;
local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;
my %args = @_;
local $sym = $args{sym} // q(X);


my $C = $self;
my $S = $C->{'_pos'};
$C->{'infixish'} = [];
$C->{'sym'} = $sym;

$self->_MATCHIFYr($S, "infix_prefix_meta_operator__S_289X",  map { STD::List_infix->coerce($_) } 
do {
if (my ($C) = ($C->_PATTERN(qr/\GX/))) {
do {
if (my ($C) = (scalar(do {

}, $C))) {
$C->_OPTr(sub { my $C=shift;
$C->_BRACKETr( sub { my $C=shift;
do {
if (my ($C) = ($C->_SUBSUMEr(['infixish'], sub {
my $C = shift;
$C->infixish(1)
}))) {
do {
if (my ($C) = ($C->_OPTr(sub { my $C=shift;
$C->_BRACKETr( sub { my $C=shift;
do {
if (my ($C) = ($C->_EXACT('X'))) {
$C->panic("Old form of XopX found");
}
else {
();
}
}
})
}))) {
do {
if (my ($C) = (do { my $M = $C;
$C->can_meta($M->{'infixish'}[0], "cross")
; })) {
$C->before( sub { my $C=shift;
(($C) x !!do {
my $M = $C;  $M->{'O'} = $M->{'infixish'}[0]{'O'}; delete $M->{'O'}{'prec'}; $M->{'sym'} .= $M->{'infixish'}[0]->Str ;
})
});
}
else {
();
}
};
}
else {
();
}
};
}
else {
();
}
}
})
});
}
else {
();
}
};
}
else {
();
}
}
);
}

## token infix_circumfix_meta_operator__S_290Fre_Nch (  :$sym is context<rw> = <« »> --> Transparent)
##      token infix_circumfix_meta_operator:sym<« »> ( --> Transparent) {
##          [
##          | '«'
##          | '»'
##          ]
##          {} <infixish(1)> [ '«' | '»' || <.panic: "Missing « or »"> ]
##          <.can_meta($<infixish>, "hyper")>
##          <?{ $<O> := $<infixish><O>; }>
##      }

sub infix_circumfix_meta_operator__S_290Fre_Nch__PEEK { $_[0]->_AUTOLEXpeek('infix_circumfix_meta_operator__S_290Fre_Nch',$retree) }
sub infix_circumfix_meta_operator__S_290Fre_Nch {
my $self = shift;
local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;
my %args = @_;
local $sym = $args{sym} // [qw(« »)];


my $C = $self;
my $S = $C->{'_pos'};
$C->{'sym'} = $sym;

$self->_MATCHIFYr($S, "infix_circumfix_meta_operator__S_290Fre_Nch",  map { STD::Transparent->coerce($_) } 
do {
if (my ($C) = ($C->_BRACKETr( sub { my $C=shift;
do {
my @result = eval {
my $trystate;
my ($tag, $try);
my @try;
my $relex;

my $fate;
if ($fate = $C->{'_fate'} and $fate->[1] eq 'infix_circumfix_meta_operator__S_290Fre_Nch_01') {
$C->deb("Fate passed to infix_circumfix_meta_operator__S_290Fre_Nch_01: ", ::fatestr($fate)) if $::DEBUG & DEBUG::fates;
($C->{'_fate'}, $tag, $try) = @$fate;
@try = ($try);
}

my @gather = ();
for (;;) {
if (not @try) {
$relex //= $C->cursor_fate('STD', 'infix_circumfix_meta_operator__S_290Fre_Nch_01', $retree);
@try = $relex->($C, $trystate);
}
last unless @try;
$try = shift(@try) // next;

if (ref $try eq 'ARRAY') {
($C->{'_fate'}, $tag, $try) = @$try;	# next candidate fate
}

$C->deb("infix_circumfix_meta_operator__S_290Fre_Nch_01 trying $tag $try") if $::DEBUG & DEBUG::try_processing;
push @gather, ((
sub { my $C=shift;
$C->_EXACT('«')
},
sub { my $C=shift;
$C->_EXACT('»')
},
)[$try])->($C);
last if @gather;
}
@gather;
};
if (@result) {
@result;
}
elsif ($@) {
my ($first) = $@ =~ /(^.*)/;
$self->deb("CAUGHT $first") if $::DEBUG & DEBUG::trace_call;
die $@ if $@ !~ /^ABORTBRANCH/;
();
}
else {
();
}
}

}))) {
do {
if (my ($C) = (scalar(do {

}, $C))) {
do {
if (my ($C) = ($C->_SUBSUMEr(['infixish'], sub {
my $C = shift;
$C->infixish(1)
}))) {
do {
if (my ($C) = ($C->_BRACKETr( sub { my $C=shift;
do { my @gather;
eval { push @gather, do {
my @result = eval {
my $trystate;
my ($tag, $try);
my @try;
my $relex;

my $fate;
if ($fate = $C->{'_fate'} and $fate->[1] eq 'infix_circumfix_meta_operator__S_290Fre_Nch_02') {
$C->deb("Fate passed to infix_circumfix_meta_operator__S_290Fre_Nch_02: ", ::fatestr($fate)) if $::DEBUG & DEBUG::fates;
($C->{'_fate'}, $tag, $try) = @$fate;
@try = ($try);
}

my @gather = ();
for (;;) {
if (not @try) {
$relex //= $C->cursor_fate('STD', 'infix_circumfix_meta_operator__S_290Fre_Nch_02', $retree);
@try = $relex->($C, $trystate);
}
last unless @try;
$try = shift(@try) // next;

if (ref $try eq 'ARRAY') {
($C->{'_fate'}, $tag, $try) = @$try;	# next candidate fate
}

$C->deb("infix_circumfix_meta_operator__S_290Fre_Nch_02 trying $tag $try") if $::DEBUG & DEBUG::try_processing;
push @gather, ((
sub { my $C=shift;
$C->_EXACT('«')
},
sub { my $C=shift;
$C->_EXACT('»')
},
)[$try])->($C);
last if @gather;
}
@gather;
};
if (@result) {
@result;
}
elsif ($@) {
my ($first) = $@ =~ /(^.*)/;
$self->deb("CAUGHT $first") if $::DEBUG & DEBUG::trace_call;
die $@ if $@ !~ /^ABORTBRANCH/;
();
}
else {
();
}
}
} // do {die $@ if $@ and $@ !~ /ABORT/;1} 
or
eval { push @gather, $C->panic("Missing « or »")} or do { die $@ if $@ };
@gather;
}
}))) {
do {
if (my ($C) = (do { my $M = $C;
$C->can_meta($M->{'infixish'}, "hyper")
; })) {
$C->before( sub { my $C=shift;
(($C) x !!do {
my $M = $C;  $M->{'O'} = $M->{'infixish'}{'O'}; ;
})
});
}
else {
();
}
};
}
else {
();
}
};
}
else {
();
}
};
}
else {
();
}
};
}
else {
();
}
}
);
}

## token infix_circumfix_meta_operator__S_291LtLt_GtGt (  :$sym is context<rw> = «<< >>» --> Transparent)
##      token infix_circumfix_meta_operator:sym«<< >>» ( --> Transparent) {
##          [
##          | '<<'
##          | '>>'
##          ]
##          {} <infixish(1)> [ '<<' | '>>' || <.panic("Missing << or >>")> ]
##          <.can_meta($<infixish>, "hyper")>
##          <?{ $<O> := $<infixish><O>; }>
##      }

sub infix_circumfix_meta_operator__S_291LtLt_GtGt__PEEK { $_[0]->_AUTOLEXpeek('infix_circumfix_meta_operator__S_291LtLt_GtGt',$retree) }
sub infix_circumfix_meta_operator__S_291LtLt_GtGt {
my $self = shift;
local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;
my %args = @_;
local $sym = $args{sym} //['<<','>>'];


my $C = $self;
my $S = $C->{'_pos'};
$C->{'sym'} = $sym;

$self->_MATCHIFYr($S, "infix_circumfix_meta_operator__S_291LtLt_GtGt",  map { STD::Transparent->coerce($_) } 
do {
if (my ($C) = ($C->_BRACKETr( sub { my $C=shift;
do {
my @result = eval {
my $trystate;
my ($tag, $try);
my @try;
my $relex;

my $fate;
if ($fate = $C->{'_fate'} and $fate->[1] eq 'infix_circumfix_meta_operator__S_291LtLt_GtGt_01') {
$C->deb("Fate passed to infix_circumfix_meta_operator__S_291LtLt_GtGt_01: ", ::fatestr($fate)) if $::DEBUG & DEBUG::fates;
($C->{'_fate'}, $tag, $try) = @$fate;
@try = ($try);
}

my @gather = ();
for (;;) {
if (not @try) {
$relex //= $C->cursor_fate('STD', 'infix_circumfix_meta_operator__S_291LtLt_GtGt_01', $retree);
@try = $relex->($C, $trystate);
}
last unless @try;
$try = shift(@try) // next;

if (ref $try eq 'ARRAY') {
($C->{'_fate'}, $tag, $try) = @$try;	# next candidate fate
}

$C->deb("infix_circumfix_meta_operator__S_291LtLt_GtGt_01 trying $tag $try") if $::DEBUG & DEBUG::try_processing;
push @gather, ((
sub { my $C=shift;
$C->_EXACT('<<')
},
sub { my $C=shift;
$C->_EXACT('>>')
},
)[$try])->($C);
last if @gather;
}
@gather;
};
if (@result) {
@result;
}
elsif ($@) {
my ($first) = $@ =~ /(^.*)/;
$self->deb("CAUGHT $first") if $::DEBUG & DEBUG::trace_call;
die $@ if $@ !~ /^ABORTBRANCH/;
();
}
else {
();
}
}

}))) {
do {
if (my ($C) = (scalar(do {

}, $C))) {
do {
if (my ($C) = ($C->_SUBSUMEr(['infixish'], sub {
my $C = shift;
$C->infixish(1)
}))) {
do {
if (my ($C) = ($C->_BRACKETr( sub { my $C=shift;
do { my @gather;
eval { push @gather, do {
my @result = eval {
my $trystate;
my ($tag, $try);
my @try;
my $relex;

my $fate;
if ($fate = $C->{'_fate'} and $fate->[1] eq 'infix_circumfix_meta_operator__S_291LtLt_GtGt_02') {
$C->deb("Fate passed to infix_circumfix_meta_operator__S_291LtLt_GtGt_02: ", ::fatestr($fate)) if $::DEBUG & DEBUG::fates;
($C->{'_fate'}, $tag, $try) = @$fate;
@try = ($try);
}

my @gather = ();
for (;;) {
if (not @try) {
$relex //= $C->cursor_fate('STD', 'infix_circumfix_meta_operator__S_291LtLt_GtGt_02', $retree);
@try = $relex->($C, $trystate);
}
last unless @try;
$try = shift(@try) // next;

if (ref $try eq 'ARRAY') {
($C->{'_fate'}, $tag, $try) = @$try;	# next candidate fate
}

$C->deb("infix_circumfix_meta_operator__S_291LtLt_GtGt_02 trying $tag $try") if $::DEBUG & DEBUG::try_processing;
push @gather, ((
sub { my $C=shift;
$C->_EXACT('<<')
},
sub { my $C=shift;
$C->_EXACT('>>')
},
)[$try])->($C);
last if @gather;
}
@gather;
};
if (@result) {
@result;
}
elsif ($@) {
my ($first) = $@ =~ /(^.*)/;
$self->deb("CAUGHT $first") if $::DEBUG & DEBUG::trace_call;
die $@ if $@ !~ /^ABORTBRANCH/;
();
}
else {
();
}
}
} // do {die $@ if $@ and $@ !~ /ABORT/;1} 
or
eval { push @gather, $C->panic("Missing << or >>")} or do { die $@ if $@ };
@gather;
}
}))) {
do {
if (my ($C) = (do { my $M = $C;
$C->can_meta($M->{'infixish'}, "hyper")
; })) {
$C->before( sub { my $C=shift;
(($C) x !!do {
my $M = $C;  $M->{'O'} = $M->{'infixish'}{'O'}; ;
})
});
}
else {
();
}
};
}
else {
();
}
};
}
else {
();
}
};
}
else {
();
}
};
}
else {
();
}
}
);
}

## token infix_postfix_meta_operator__S_292Equal ($op  , :$sym is context<rw> = <=> --> Item_assignment)
##      token infix_postfix_meta_operator:sym<=> ($op --> Item_assignment) {
##          '='
##          <.can_meta($op, "make assignment out of")>
##          [ <!{ $op<O><diffy> }> || <.panic("Can't make assignment out of " ~ $op<sym> ~ " because " ~ $op<O><dba> ~ " operators are diffy")> ]
##          { $<O> = $op<O>; $<sym> = $op<sym> ~ '='; $<O><dba> = "assignment"; $<O><prec>:delete; $<O><iffy> = 0; }
##      }

sub infix_postfix_meta_operator__S_292Equal__PEEK { $_[0]->_AUTOLEXpeek('infix_postfix_meta_operator__S_292Equal',$retree) }
sub infix_postfix_meta_operator__S_292Equal {
my $self = shift;
local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;
my $op = shift;
my %args = @_;
local $sym = $args{sym} // q(=);


my $C = $self;
my $S = $C->{'_pos'};
$C->{'sym'} = $sym;

$self->_MATCHIFYr($S, "infix_postfix_meta_operator__S_292Equal",  map { STD::Item_assignment->coerce($_) } 
do {
if (my ($C) = ($C->_EXACT('='))) {
do {
if (my ($C) = ($C->can_meta($op, "make assignment out of"))) {
do {
if (my ($C) = ($C->_BRACKETr( sub { my $C=shift;
do { my @gather;
eval { push @gather, $C->_NOTBEFORE( sub { my $C=shift;
(($C) x !!do {
$op->{'O'}{'diffy'} 
})
})} // do {die $@ if $@ and $@ !~ /ABORT/;1} 
or
eval { push @gather, $C->panic("Can't make assignment out of " . $op->{'sym'} . " because " . $op->{'O'}{'dba'} . " operators are diffy")} or do { die $@ if $@ };
@gather;
}
}))) {
scalar(do {
my $M = $C;  $M->{'O'} = $op->{'O'}; $M->{'sym'} = $op->{'sym'} . '='; $M->{'O'}{'dba'} = "assignment"; delete $M->{'O'}{'prec'}; $M->{'O'}{'iffy'} = 0; ;
}, $C);
}
else {
();
}
};
}
else {
();
}
};
}
else {
();
}
}
);
}

## token postcircumfix__S_293Paren_Thesis (  :$sym is context<rw> = <( )> --> Methodcall)
##      token postcircumfix:sym<( )> ( --> Methodcall)
##          { :dba('argument list') '(' ~ ')' <semiarglist> }

sub postcircumfix__S_293Paren_Thesis__PEEK { $_[0]->_AUTOLEXpeek('postcircumfix__S_293Paren_Thesis',$retree) }
sub postcircumfix__S_293Paren_Thesis {
my $self = shift;
local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;
my %args = @_;
local $sym = $args{sym} // [qw[( )]];


my $C = $self;
my $S = $C->{'_pos'};
$C->{'sym'} = $sym;

$self->_MATCHIFY($S, "postcircumfix__S_293Paren_Thesis",  Cursor::lazymap sub { STD::Methodcall->coerce($_[0]) }, 
Cursor::lazymap(sub { my $C=$_[0];
Cursor::lazymap(sub { my $C=$_[0];
Cursor::lazymap(sub { my $C=$_[0];
$C->_BRACKET( sub { my $C=shift;
do { my @gather;
eval { push @gather, $C->_EXACT(')')} // do {die $@ if $@ and $@ !~ /ABORT/;1} 
or
eval { push @gather, $C->FAILGOAL(')' , 'argument list')} or do { die $@ if $@ };
@gather;
}
})
}, $C->_SUBSUME(['semiarglist'], sub {
my $C = shift;
$C->semiarglist
}))
}, $C->_COMMITBRANCH(local $::GOAL = ')' ))
}, $C->_EXACT('('))
);
}

## token postcircumfix__S_294Bra_Ket (  :$sym is context<rw> = <[ ]> --> Methodcall)
##      token postcircumfix:sym<[ ]> ( --> Methodcall)
##          { :dba('subscript') '[' ~ ']' <semilist> { $<semilist>.Str ~~ /^\s*\-[1]\s*$/ and $¢.obs("[-1] subscript to access final element","[*-1]") } }

sub postcircumfix__S_294Bra_Ket__PEEK { $_[0]->_AUTOLEXpeek('postcircumfix__S_294Bra_Ket',$retree) }
sub postcircumfix__S_294Bra_Ket {
my $self = shift;
local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;
my %args = @_;
local $sym = $args{sym} // [qw([ ])];


my $C = $self;
my $S = $C->{'_pos'};
$C->{'sym'} = $sym;

$self->_MATCHIFY($S, "postcircumfix__S_294Bra_Ket",  Cursor::lazymap sub { STD::Methodcall->coerce($_[0]) }, 
Cursor::lazymap(sub { my $C=$_[0];
Cursor::lazymap(sub { my $C=$_[0];
Cursor::lazymap(sub { my $C=$_[0];
Cursor::lazymap(sub { my $C=$_[0];
scalar(do {
my $M = $C;  $M->{'semilist'}->Str =~ qr/^\s*\-[1]\s*$/ and $C->obs("[-1] subscript to access final element","[*-1]") ;
}, $C)
}, $C->_BRACKET( sub { my $C=shift;
do { my @gather;
eval { push @gather, $C->_EXACT(']')} // do {die $@ if $@ and $@ !~ /ABORT/;1} 
or
eval { push @gather, $C->FAILGOAL(']' , 'subscript')} or do { die $@ if $@ };
@gather;
}
}))
}, $C->_SUBSUME(['semilist'], sub {
my $C = shift;
$C->semilist
}))
}, $C->_COMMITBRANCH(local $::GOAL = ']' ))
}, $C->_EXACT('['))
);
}

## token postcircumfix__S_295Cur_Ly (  :$sym is context<rw> = <{ }> --> Methodcall)
##      token postcircumfix:sym<{ }> ( --> Methodcall)
##          { :dba('subscript') '{' ~ '}' <semilist> }

sub postcircumfix__S_295Cur_Ly__PEEK { $_[0]->_AUTOLEXpeek('postcircumfix__S_295Cur_Ly',$retree) }
sub postcircumfix__S_295Cur_Ly {
my $self = shift;
local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;
my %args = @_;
local $sym = $args{sym} // [qw({ })];


my $C = $self;
my $S = $C->{'_pos'};
$C->{'sym'} = $sym;

$self->_MATCHIFY($S, "postcircumfix__S_295Cur_Ly",  Cursor::lazymap sub { STD::Methodcall->coerce($_[0]) }, 
Cursor::lazymap(sub { my $C=$_[0];
Cursor::lazymap(sub { my $C=$_[0];
Cursor::lazymap(sub { my $C=$_[0];
$C->_BRACKET( sub { my $C=shift;
do { my @gather;
eval { push @gather, $C->_EXACT('}')} // do {die $@ if $@ and $@ !~ /ABORT/;1} 
or
eval { push @gather, $C->FAILGOAL('}' , 'subscript')} or do { die $@ if $@ };
@gather;
}
})
}, $C->_SUBSUME(['semilist'], sub {
my $C = shift;
$C->semilist
}))
}, $C->_COMMITBRANCH(local $::GOAL = '}' ))
}, $C->_EXACT('{'))
);
}

## token postcircumfix__S_296Lt_Gt (  :$sym is context<rw> = «< >» --> Methodcall)
##      token postcircumfix:sym«< >» ( --> Methodcall)
##          { '<' <nibble($¢.cursor_fresh( %*LANG<Q> ).tweak(:q).tweak(:w).balanced('<','>'))> [ '>' || <.panic: "Unable to parse quote-words subscript; couldn't find right angle quote"> ] }

sub postcircumfix__S_296Lt_Gt__PEEK { $_[0]->_AUTOLEXpeek('postcircumfix__S_296Lt_Gt',$retree) }
sub postcircumfix__S_296Lt_Gt {
my $self = shift;
local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;
my %args = @_;
local $sym = $args{sym} //['<','>'];


my $C = $self;
my $S = $C->{'_pos'};
$C->{'sym'} = $sym;

$self->_MATCHIFYr($S, "postcircumfix__S_296Lt_Gt",  map { STD::Methodcall->coerce($_) } 
do {
if (my ($C) = ($C->_EXACT('<'))) {
do {
if (my ($C) = ($C->_SUBSUMEr(['nibble'], sub {
my $C = shift;
$C->nibble($C->cursor_fresh( $::LANG{'Q'} )->tweak('q' => 1)->tweak('w' => 1)->balanced('<','>'))
}))) {
$C->_BRACKETr( sub { my $C=shift;
do { my @gather;
eval { push @gather, $C->_EXACT('>')} // do {die $@ if $@ and $@ !~ /ABORT/;1} 
or
eval { push @gather, $C->panic("Unable to parse quote-words subscript; couldn't find right angle quote")} or do { die $@ if $@ };
@gather;
}
});
}
else {
();
}
};
}
else {
();
}
}
);
}

## token postcircumfix__S_297LtLt_GtGt (  :$sym is context<rw> = «<< >>» --> Methodcall)
##      token postcircumfix:sym«<< >>» ( --> Methodcall)
##          { '<<' <nibble($¢.cursor_fresh( %*LANG<Q> ).tweak(:qq).tweak(:ww).balanced('<<','>>'))> [ '>>' || <.panic: "Unable to parse quote-words subscript; couldn't find right double-angle quote"> ] }

sub postcircumfix__S_297LtLt_GtGt__PEEK { $_[0]->_AUTOLEXpeek('postcircumfix__S_297LtLt_GtGt',$retree) }
sub postcircumfix__S_297LtLt_GtGt {
my $self = shift;
local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;
my %args = @_;
local $sym = $args{sym} //['<<','>>'];


my $C = $self;
my $S = $C->{'_pos'};
$C->{'sym'} = $sym;

$self->_MATCHIFYr($S, "postcircumfix__S_297LtLt_GtGt",  map { STD::Methodcall->coerce($_) } 
do {
if (my ($C) = ($C->_EXACT('<<'))) {
do {
if (my ($C) = ($C->_SUBSUMEr(['nibble'], sub {
my $C = shift;
$C->nibble($C->cursor_fresh( $::LANG{'Q'} )->tweak('qq' => 1)->tweak('ww' => 1)->balanced('<<','>>'))
}))) {
$C->_BRACKETr( sub { my $C=shift;
do { my @gather;
eval { push @gather, $C->_EXACT('>>')} // do {die $@ if $@ and $@ !~ /ABORT/;1} 
or
eval { push @gather, $C->panic("Unable to parse quote-words subscript; couldn't find right double-angle quote")} or do { die $@ if $@ };
@gather;
}
});
}
else {
();
}
};
}
else {
();
}
}
);
}

## token postcircumfix__S_298Fre_Nch (  :$sym is context<rw> = <« »> --> Methodcall)
##      token postcircumfix:sym<« »> ( --> Methodcall)
##          { '«' <nibble($¢.cursor_fresh( %*LANG<Q> ).tweak(:qq).tweak(:ww).balanced('«','»'))> [ '»' || <.panic: "Unable to parse quote-words subscript; couldn't find right double-angle quote"> ] }

sub postcircumfix__S_298Fre_Nch__PEEK { $_[0]->_AUTOLEXpeek('postcircumfix__S_298Fre_Nch',$retree) }
sub postcircumfix__S_298Fre_Nch {
my $self = shift;
local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;
my %args = @_;
local $sym = $args{sym} // [qw(« »)];


my $C = $self;
my $S = $C->{'_pos'};
$C->{'sym'} = $sym;

$self->_MATCHIFYr($S, "postcircumfix__S_298Fre_Nch",  map { STD::Methodcall->coerce($_) } 
do {
if (my ($C) = ($C->_EXACT('«'))) {
do {
if (my ($C) = ($C->_SUBSUMEr(['nibble'], sub {
my $C = shift;
$C->nibble($C->cursor_fresh( $::LANG{'Q'} )->tweak('qq' => 1)->tweak('ww' => 1)->balanced('«','»'))
}))) {
$C->_BRACKETr( sub { my $C=shift;
do { my @gather;
eval { push @gather, $C->_EXACT('»')} // do {die $@ if $@ and $@ !~ /ABORT/;1} 
or
eval { push @gather, $C->panic("Unable to parse quote-words subscript; couldn't find right double-angle quote")} or do { die $@ if $@ };
@gather;
}
});
}
else {
();
}
};
}
else {
();
}
}
);
}

## token postop
##      token postop {
##          | <postfix>         { $<O> := $<postfix><O>; $<sym> := $<postfix><sym>; }
##          | <postcircumfix>   { $<O> := $<postcircumfix><O>; $<sym> := $<postcircumfix><sym>; }
##      }

sub postop__PEEK { $_[0]->_AUTOLEXpeek('postop',$retree) }
sub postop {
my $self = shift;
local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;


my $C = $self;
my $S = $C->{'_pos'};

$self->_MATCHIFYr($S, "postop", 
do {
my @result = eval {
my $trystate;
my ($tag, $try);
my @try;
my $relex;

my $fate;
if ($fate = $C->{'_fate'} and $fate->[1] eq 'postop_00') {
$C->deb("Fate passed to postop_00: ", ::fatestr($fate)) if $::DEBUG & DEBUG::fates;
($C->{'_fate'}, $tag, $try) = @$fate;
@try = ($try);
}

my @gather = ();
for (;;) {
if (not @try) {
$relex //= $C->cursor_fate('STD', 'postop_00', $retree);
@try = $relex->($C, $trystate);
}
last unless @try;
$try = shift(@try) // next;

if (ref $try eq 'ARRAY') {
($C->{'_fate'}, $tag, $try) = @$try;	# next candidate fate
}

$C->deb("postop_00 trying $tag $try") if $::DEBUG & DEBUG::try_processing;
push @gather, ((
sub { my $C=shift;
do {
if (my ($C) = ($C->_SUBSUMEr(['postfix'], sub {
my $C = shift;
$C->postfix
}))) {
scalar(do {
my $M = $C;  $M->{'O'} = $M->{'postfix'}{'O'}; $M->{'sym'} = $M->{'postfix'}{'sym'}; ;
}, $C);
}
else {
();
}
}
},
sub { my $C=shift;
do {
if (my ($C) = ($C->_SUBSUMEr(['postcircumfix'], sub {
my $C = shift;
$C->postcircumfix
}))) {
scalar(do {
my $M = $C;  $M->{'O'} = $M->{'postcircumfix'}{'O'}; $M->{'sym'} = $M->{'postcircumfix'}{'sym'}; ;
}, $C);
}
else {
();
}
}
},
)[$try])->($C);
last if @gather;
}
@gather;
};
if (@result) {
@result;
}
elsif ($@) {
my ($first) = $@ =~ /(^.*)/;
$self->deb("CAUGHT $first") if $::DEBUG & DEBUG::trace_call;
die $@ if $@ !~ /^ABORTBRANCH/;
();
}
else {
();
}
}

);
}

## token methodop
##      token methodop {
##          [
##          | <longname>
##          | <?before '$' | '@' | '&' > <variable> { $*VAR = $<variable> }
##          | <?before <[ ' " ]> >
##              [ <!{$*QSIGIL}> || <!before '"' <-["]>*? \s > ] # dwim on "$foo."
##              <quote>
##              { my $t = $<quote><nibble>.Str; $t ~~ /\W/ or $t ~~ /^(WHO|WHAT|WHERE|WHEN|WHY|HOW)$/ or $¢.worry("Useless use of quotes") }
##          ] <.unsp>? 
##      
##          :dba('method arguments')
##          [
##          | ':' <?before \s> <!{ $*QSIGIL }> <arglist>
##          | <?[\\(]> <args>
##          ]?
##      }

sub methodop__PEEK { $_[0]->_AUTOLEXpeek('methodop',$retree) }
sub methodop {
my $self = shift;
local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;


my $C = $self;
my $S = $C->{'_pos'};
$C->{'arglist'} = [];
$C->{'args'} = [];

$self->_MATCHIFY($S, "methodop", 
Cursor::lazymap(sub { my $C=$_[0];
Cursor::lazymap(sub { my $C=$_[0];
$C->_OPTr(sub { my $C=shift;
$C->_BRACKET( sub { my $C=shift;
do {
my @result = eval {
my $trystate;
my ($tag, $try);
my @try;
my $relex;

my $fate;
if ($fate = $C->{'_fate'} and $fate->[1] eq 'methodop_07') {
$C->deb("Fate passed to methodop_07: ", ::fatestr($fate)) if $::DEBUG & DEBUG::fates;
($C->{'_fate'}, $tag, $try) = @$fate;
@try = ($try);
}

my @gather = ();
for (;;) {
if (not @try) {
$relex //= $C->cursor_fate('STD', 'methodop_07', $retree);
@try = $relex->($C, $trystate);
}
last unless @try;
$try = shift(@try) // next;

if (ref $try eq 'ARRAY') {
($C->{'_fate'}, $tag, $try) = @$try;	# next candidate fate
}

$C->deb("methodop_07 trying $tag $try") if $::DEBUG & DEBUG::try_processing;
push @gather, ((
sub { my $C=shift;
Cursor::lazymap(sub { my $C=$_[0];
Cursor::lazymap(sub { my $C=$_[0];
Cursor::lazymap(sub { my $C=$_[0];
$C->_SUBSUME(['arglist'], sub {
my $C = shift;
$C->arglist
})
}, $C->_NOTBEFORE( sub { my $C=shift;
(($C) x !!do {
$::QSIGIL 
})
}))
}, $C->before(sub { my $C=shift;
$C->_PATTERN(qr/\G\s/)
}))
}, $C->_EXACT(':'))
},
sub { my $C=shift;
Cursor::lazymap(sub { my $C=$_[0];
$C->_SUBSUME(['args'], sub {
my $C = shift;
$C->args
})
}, $C->before( sub { my $C=shift;
$C->_PATTERN(qr/\G[\\(]/)
}))
},
)[$try])->($C);
last if @gather;
}
@gather;
};
if (@result) {
@result;
}
elsif ($@) {
my ($first) = $@ =~ /(^.*)/;
$self->deb("CAUGHT $first") if $::DEBUG & DEBUG::trace_call;
die $@ if $@ !~ /^ABORTBRANCH/;
();
}
else {
();
}
}

})
})
}, $C->_OPTr(sub { my $C=shift;
$C->unsp
}))
}, $C->_BRACKET( sub { my $C=shift;
do {
my @result = eval {
my $trystate;
my ($tag, $try);
my @try;
my $relex;

my $fate;
if ($fate = $C->{'_fate'} and $fate->[1] eq 'methodop_01') {
$C->deb("Fate passed to methodop_01: ", ::fatestr($fate)) if $::DEBUG & DEBUG::fates;
($C->{'_fate'}, $tag, $try) = @$fate;
@try = ($try);
}

my @gather = ();
for (;;) {
if (not @try) {
$relex //= $C->cursor_fate('STD', 'methodop_01', $retree);
@try = $relex->($C, $trystate);
}
last unless @try;
$try = shift(@try) // next;

if (ref $try eq 'ARRAY') {
($C->{'_fate'}, $tag, $try) = @$try;	# next candidate fate
}

$C->deb("methodop_01 trying $tag $try") if $::DEBUG & DEBUG::try_processing;
push @gather, ((
sub { my $C=shift;
$C->_SUBSUME(['longname'], sub {
my $C = shift;
$C->longname
})
},
sub { my $C=shift;
Cursor::lazymap(sub { my $C=$_[0];
Cursor::lazymap(sub { my $C=$_[0];
scalar(do {
my $M = $C;  $::VAR = $M->{'variable'} ;
}, $C)
}, $C->_SUBSUME(['variable'], sub {
my $C = shift;
$C->variable
}))
}, $C->before(sub { my $C=shift;
do {
my @result = eval {
my $trystate;
my ($tag, $try);
my @try;
my $relex;

my $fate;
if ($fate = $C->{'_fate'} and $fate->[1] eq 'methodop_02') {
$C->deb("Fate passed to methodop_02: ", ::fatestr($fate)) if $::DEBUG & DEBUG::fates;
($C->{'_fate'}, $tag, $try) = @$fate;
@try = ($try);
}

my @gather = ();
for (;;) {
if (not @try) {
$relex //= $C->cursor_fate('STD', 'methodop_02', $retree);
@try = $relex->($C, $trystate);
}
last unless @try;
$try = shift(@try) // next;

if (ref $try eq 'ARRAY') {
($C->{'_fate'}, $tag, $try) = @$try;	# next candidate fate
}

$C->deb("methodop_02 trying $tag $try") if $::DEBUG & DEBUG::try_processing;
push @gather, ((
sub { my $C=shift;
$C->_EXACT('$')
},
sub { my $C=shift;
$C->_EXACT('@')
},
sub { my $C=shift;
$C->_EXACT('&')
},
)[$try])->($C);
last if @gather;
}
@gather;
};
if (@result) {
@result;
}
elsif ($@) {
my ($first) = $@ =~ /(^.*)/;
$self->deb("CAUGHT $first") if $::DEBUG & DEBUG::trace_call;
die $@ if $@ !~ /^ABORTBRANCH/;
();
}
else {
();
}
}

}))
},
sub { my $C=shift;
Cursor::lazymap(sub { my $C=$_[0];
Cursor::lazymap(sub { my $C=$_[0];
Cursor::lazymap(sub { my $C=$_[0];
scalar(do {
my $M = $C;  my $t = $M->{'quote'}{'nibble'}->Str; $t =~ qr/\W/ or $t =~ qr/^(WHO|WHAT|WHERE|WHEN|WHY|HOW)$/ or $C->worry("Useless use of quotes") ;
}, $C)
}, $C->_SUBSUME(['quote'], sub {
my $C = shift;
$C->quote
}))
}, $C->_BRACKET( sub { my $C=shift;
do { my @gather;
eval { push @gather, $C->_NOTBEFORE( sub { my $C=shift;
(($C) x !!do {
$::QSIGIL
})
})} // do {die $@ if $@ and $@ !~ /ABORT/;1} 
or
eval { push @gather, $C->_NOTBEFORE( sub { my $C=shift;
$C->before(sub { my $C=shift;
Cursor::lazymap(sub { my $C=$_[0];
Cursor::lazymap(sub { my $C=$_[0];
$C->_PATTERN(qr/\G\s/)
}, $C->_STARf(sub { my $C=shift;
$C->_PATTERN(qr/\G[^"]/)
}))
}, $C->_EXACT('"'))
})
})} or do { die $@ if $@ };
@gather;
}
}))
}, $C->before(sub { my $C=shift;
$C->_PATTERN(qr/\G['"]/)
}))
},
)[$try])->($C);
last if @gather;
}
@gather;
};
if (@result) {
@result;
}
elsif ($@) {
my ($first) = $@ =~ /(^.*)/;
$self->deb("CAUGHT $first") if $::DEBUG & DEBUG::trace_call;
die $@ if $@ !~ /^ABORTBRANCH/;
();
}
else {
();
}
}

}))
);
}

## token semiarglist
##      token semiarglist {
##          <arglist> ** ';'
##          <.ws>
##      }

sub semiarglist__PEEK { $_[0]->_AUTOLEXpeek('semiarglist',$retree) }
sub semiarglist {
my $self = shift;
local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;


my $C = $self;
my $S = $C->{'_pos'};
$C->{'arglist'} = [];

$self->_MATCHIFYr($S, "semiarglist", 
do {
if (my ($C) = ($C->_REPSEPr(  sub { my $C=shift;
$C->_EXACT(';')
}, sub { my $C=shift;
$C->_SUBSUMEr(['arglist'], sub {
my $C = shift;
$C->arglist
})
}))) {
$C->ws;
}
else {
();
}
}
);
}

## token arglist
##      token arglist {
##          :my $inv_ok = $*INVOCANT_OK;
##          :my StrPos $endargs is context<rw> = 0;
##          :my $GOAL is context = 'endargs';
##          :my $QSIGIL is context<rw> = '';
##          <.ws>
##          :dba('argument list')
##          [
##          | <?stdstopper>
##          | <EXPR(item %list_infix)> {{
##                  my $delims = $<EXPR><delims>;
##                  for @$delims {
##                      if ($_.<sym> // '') eq ':' {
##                          if $inv_ok {
##                              $*INVOCANT_IS = $<EXPR><list>[0];
##                          }
##                      }
##                  }
##              }}
##          ]
##      }

sub arglist__PEEK { $_[0]->_AUTOLEXpeek('arglist',$retree) }
sub arglist {
my $self = shift;
local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;
my $inv_ok = $::INVOCANT_OK;
local $::endargs = 0;
local $::GOAL = 'endargs';
local $::QSIGIL = '';


my $C = $self;
my $S = $C->{'_pos'};

$self->_MATCHIFYr($S, "arglist", 
do {
if (my ($C) = ($C->ws)) {
$C->_BRACKETr( sub { my $C=shift;
do {
my @result = eval {
my $trystate;
my ($tag, $try);
my @try;
my $relex;

my $fate;
if ($fate = $C->{'_fate'} and $fate->[1] eq 'arglist_01') {
$C->deb("Fate passed to arglist_01: ", ::fatestr($fate)) if $::DEBUG & DEBUG::fates;
($C->{'_fate'}, $tag, $try) = @$fate;
@try = ($try);
}

my @gather = ();
for (;;) {
if (not @try) {
$relex //= $C->cursor_fate('STD', 'arglist_01', $retree);
@try = $relex->($C, $trystate);
}
last unless @try;
$try = shift(@try) // next;

if (ref $try eq 'ARRAY') {
($C->{'_fate'}, $tag, $try) = @$try;	# next candidate fate
}

$C->deb("arglist_01 trying $tag $try") if $::DEBUG & DEBUG::try_processing;
push @gather, ((
sub { my $C=shift;
$C->before( sub { my $C=shift;
$C->stdstopper
})
},
sub { my $C=shift;
do {
if (my ($C) = ($C->_SUBSUMEr(['EXPR'], sub {
my $C = shift;
$C->EXPR(\%list_infix)
}))) {
scalar(do {
my $M = $C; 
my $delims = $M->{'EXPR'}{'delims'};
for (@$delims) {
if (($_->{'sym'} // '') eq ':') {
if ($inv_ok) {
$::INVOCANT_IS = $M->{'EXPR'}{'list'}[0];
}
}
}
;
}, $C);
}
else {
();
}
}
},
)[$try])->($C);
last if @gather;
}
@gather;
};
if (@result) {
@result;
}
elsif ($@) {
my ($first) = $@ =~ /(^.*)/;
$self->deb("CAUGHT $first") if $::DEBUG & DEBUG::trace_call;
die $@ if $@ !~ /^ABORTBRANCH/;
();
}
else {
();
}
}

});
}
else {
();
}
}
);
}

## token term__S_299lambda (  :$sym is context<rw> = 'lambda' --> Term)
##      token term:lambda ( --> Term) {
##          <?before <.lambda> >
##          <pblock>
##          {{
##              if $*BORG {
##                  $*BORG.<block> = $<pblock>;
##              }
##          }}
##      }

sub term__S_299lambda__PEEK { $_[0]->_AUTOLEXpeek('term__S_299lambda',$retree) }
sub term__S_299lambda {
my $self = shift;
local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;
my %args = @_;
local $sym = $args{sym} // 'lambda';


my $C = $self;
my $S = $C->{'_pos'};
$C->{'sym'} = $sym;

$self->_MATCHIFYr($S, "term__S_299lambda",  map { STD::Term->coerce($_) } 
do {
if (my ($C) = ($C->before(sub { my $C=shift;
$C->lambda
}))) {
do {
if (my ($C) = ($C->_SUBSUMEr(['pblock'], sub {
my $C = shift;
$C->pblock
}))) {
scalar(do {
my $M = $C; 
if ($::BORG) {
$::BORG->{'block'} = $M->{'pblock'};
}
;
}, $C);
}
else {
();
}
};
}
else {
();
}
}
);
}

## token circumfix__S_300Cur_Ly (  :$sym is context<rw> = <{ }> --> Term)
##      token circumfix:sym<{ }> ( --> Term) {
##          <?before '{' >
##          <pblock>
##          {{
##              if $*BORG {
##                  $*BORG.<block> = $<pblock>;
##              }
##          }}
##      }

sub circumfix__S_300Cur_Ly__PEEK { $_[0]->_AUTOLEXpeek('circumfix__S_300Cur_Ly',$retree) }
sub circumfix__S_300Cur_Ly {
my $self = shift;
local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;
my %args = @_;
local $sym = $args{sym} // [qw({ })];


my $C = $self;
my $S = $C->{'_pos'};
$C->{'sym'} = $sym;

$self->_MATCHIFYr($S, "circumfix__S_300Cur_Ly",  map { STD::Term->coerce($_) } 
do {
if (my ($C) = ($C->before(sub { my $C=shift;
$C->_EXACT('{')
}))) {
do {
if (my ($C) = ($C->_SUBSUMEr(['pblock'], sub {
my $C = shift;
$C->pblock
}))) {
scalar(do {
my $M = $C; 
if ($::BORG) {
$::BORG->{'block'} = $M->{'pblock'};
}
;
}, $C);
}
else {
();
}
};
}
else {
();
}
}
);
}

## methodcall

## token postfix__S_301i (  :$sym is context<rw> = <i> --> Methodcall)
##      token postfix:sym<i> ( --> Methodcall)
##          { <sym> » }

sub postfix__S_301i__PEEK { $_[0]->_AUTOLEXpeek('postfix__S_301i',$retree) }
sub postfix__S_301i {
my $self = shift;
local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;
my %args = @_;
local $sym = $args{sym} // q(i);


my $C = $self;
my $S = $C->{'_pos'};
$C->{'sym'} = $sym;

$self->_MATCHIFYr($S, "postfix__S_301i",  map { STD::Methodcall->coerce($_) } 
$C->_PATTERN(qr/\Gi\b/)
);
}

## token infix__S_302Dot (:$sym is context<rw> = <.>)
##      token infix:sym<.> ()
##          { '.' <[\]\)\},:\s\$"']> <.obs('. to concatenate strings', '~')> }

sub infix__S_302Dot__PEEK { $_[0]->_AUTOLEXpeek('infix__S_302Dot',$retree) }
sub infix__S_302Dot {
my $self = shift;
local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;
my %args = @_;
local $sym = $args{sym} // q(.);


my $C = $self;
my $S = $C->{'_pos'};
$C->{'sym'} = $sym;

$self->_MATCHIFYr($S, "infix__S_302Dot", 
do {
if (my ($C) = ($C->_EXACT('.'))) {
do {
if (my ($C) = ($C->_PATTERN(qr/\G[\]\)\},:\s\$"']/))) {
$C->obs('. to concatenate strings', '~');
}
else {
();
}
};
}
else {
();
}
}
);
}

## token postfix__S_303MinusGt (:$sym is context<rw> = ['->'])
##      token postfix:sym['->'] ()
##          { '->' <.obs('-> to call a method', '.')> }

sub postfix__S_303MinusGt__PEEK { $_[0]->_AUTOLEXpeek('postfix__S_303MinusGt',$retree) }
sub postfix__S_303MinusGt {
my $self = shift;
local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;
my %args = @_;
local $sym = $args{sym} // ['->'];


my $C = $self;
my $S = $C->{'_pos'};
$C->{'sym'} = $sym;

$self->_MATCHIFYr($S, "postfix__S_303MinusGt", 
do {
if (my ($C) = ($C->_EXACT('->'))) {
$C->obs('-> to call a method', '.');
}
else {
();
}
}
);
}

## autoincrement
## token postfix__S_304PlusPlus (  :$sym is context<rw> = <++> --> Autoincrement)
##      token postfix:sym<++> ( --> Autoincrement)
##          { <sym> }

sub postfix__S_304PlusPlus__PEEK { $_[0]->_AUTOLEXpeek('postfix__S_304PlusPlus',$retree) }
sub postfix__S_304PlusPlus {
my $self = shift;
local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;
my %args = @_;
local $sym = $args{sym} // q(++);


my $C = $self;
my $S = $C->{'_pos'};
$C->{'sym'} = $sym;

$self->_MATCHIFYr($S, "postfix__S_304PlusPlus",  map { STD::Autoincrement->coerce($_) } 
$C->_PATTERN(qr/\G\+\+/)
);
}

## token postfix__S_305MinusMinus (  :$sym is context<rw> = <--> --> Autoincrement)
##      token postfix:sym<--> ( --> Autoincrement)
##          { <sym> }

sub postfix__S_305MinusMinus__PEEK { $_[0]->_AUTOLEXpeek('postfix__S_305MinusMinus',$retree) }
sub postfix__S_305MinusMinus {
my $self = shift;
local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;
my %args = @_;
local $sym = $args{sym} // q(--);


my $C = $self;
my $S = $C->{'_pos'};
$C->{'sym'} = $sym;

$self->_MATCHIFYr($S, "postfix__S_305MinusMinus",  map { STD::Autoincrement->coerce($_) } 
$C->_PATTERN(qr/\G\-\-/)
);
}

## token prefix__S_306PlusPlus (  :$sym is context<rw> = <++> --> Autoincrement)
##      token prefix:sym<++> ( --> Autoincrement)
##          { <sym> }

sub prefix__S_306PlusPlus__PEEK { $_[0]->_AUTOLEXpeek('prefix__S_306PlusPlus',$retree) }
sub prefix__S_306PlusPlus {
my $self = shift;
local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;
my %args = @_;
local $sym = $args{sym} // q(++);


my $C = $self;
my $S = $C->{'_pos'};
$C->{'sym'} = $sym;

$self->_MATCHIFYr($S, "prefix__S_306PlusPlus",  map { STD::Autoincrement->coerce($_) } 
$C->_PATTERN(qr/\G\+\+/)
);
}

## token prefix__S_307MinusMinus (  :$sym is context<rw> = <--> --> Autoincrement)
##      token prefix:sym<--> ( --> Autoincrement)
##          { <sym> }

sub prefix__S_307MinusMinus__PEEK { $_[0]->_AUTOLEXpeek('prefix__S_307MinusMinus',$retree) }
sub prefix__S_307MinusMinus {
my $self = shift;
local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;
my %args = @_;
local $sym = $args{sym} // q(--);


my $C = $self;
my $S = $C->{'_pos'};
$C->{'sym'} = $sym;

$self->_MATCHIFYr($S, "prefix__S_307MinusMinus",  map { STD::Autoincrement->coerce($_) } 
$C->_PATTERN(qr/\G\-\-/)
);
}

## exponentiation
## token infix__S_308StarStar (  :$sym is context<rw> = <**> --> Exponentiation)
##      token infix:sym<**> ( --> Exponentiation)
##          { <sym> }

sub infix__S_308StarStar__PEEK { $_[0]->_AUTOLEXpeek('infix__S_308StarStar',$retree) }
sub infix__S_308StarStar {
my $self = shift;
local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;
my %args = @_;
local $sym = $args{sym} // q(**);


my $C = $self;
my $S = $C->{'_pos'};
$C->{'sym'} = $sym;

$self->_MATCHIFYr($S, "infix__S_308StarStar",  map { STD::Exponentiation->coerce($_) } 
$C->_PATTERN(qr/\G\*\*/)
);
}

## symbolic unary
## token prefix__S_309Bang (  :$sym is context<rw> = <!> --> Symbolic_unary)
##      token prefix:sym<!> ( --> Symbolic_unary)
##          { <sym> }

sub prefix__S_309Bang__PEEK { $_[0]->_AUTOLEXpeek('prefix__S_309Bang',$retree) }
sub prefix__S_309Bang {
my $self = shift;
local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;
my %args = @_;
local $sym = $args{sym} // q(!);


my $C = $self;
my $S = $C->{'_pos'};
$C->{'sym'} = $sym;

$self->_MATCHIFYr($S, "prefix__S_309Bang",  map { STD::Symbolic_unary->coerce($_) } 
$C->_PATTERN(qr/\G\!/)
);
}

## token prefix__S_310Plus (  :$sym is context<rw> = <+> --> Symbolic_unary)
##      token prefix:sym<+> ( --> Symbolic_unary)
##          { <sym> }

sub prefix__S_310Plus__PEEK { $_[0]->_AUTOLEXpeek('prefix__S_310Plus',$retree) }
sub prefix__S_310Plus {
my $self = shift;
local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;
my %args = @_;
local $sym = $args{sym} // q(+);


my $C = $self;
my $S = $C->{'_pos'};
$C->{'sym'} = $sym;

$self->_MATCHIFYr($S, "prefix__S_310Plus",  map { STD::Symbolic_unary->coerce($_) } 
$C->_PATTERN(qr/\G\+/)
);
}

## token prefix__S_311Minus (  :$sym is context<rw> = <-> --> Symbolic_unary)
##      token prefix:sym<-> ( --> Symbolic_unary)
##          { <sym> }

sub prefix__S_311Minus__PEEK { $_[0]->_AUTOLEXpeek('prefix__S_311Minus',$retree) }
sub prefix__S_311Minus {
my $self = shift;
local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;
my %args = @_;
local $sym = $args{sym} // q(-);


my $C = $self;
my $S = $C->{'_pos'};
$C->{'sym'} = $sym;

$self->_MATCHIFYr($S, "prefix__S_311Minus",  map { STD::Symbolic_unary->coerce($_) } 
$C->_PATTERN(qr/\G\-/)
);
}

## token prefix__S_312TildeTilde (  :$sym is context<rw> = <~~> --> Symbolic_unary)
##      token prefix:sym<~~> ( --> Symbolic_unary)
##          { <sym> <.badinfix> }

sub prefix__S_312TildeTilde__PEEK { $_[0]->_AUTOLEXpeek('prefix__S_312TildeTilde',$retree) }
sub prefix__S_312TildeTilde {
my $self = shift;
local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;
my %args = @_;
local $sym = $args{sym} // q(~~);


my $C = $self;
my $S = $C->{'_pos'};
$C->{'sym'} = $sym;

$self->_MATCHIFYr($S, "prefix__S_312TildeTilde",  map { STD::Symbolic_unary->coerce($_) } 
do {
if (my ($C) = ($C->_PATTERN(qr/\G\~\~/))) {
$C->badinfix;
}
else {
();
}
}
);
}

## token prefix__S_313Tilde (  :$sym is context<rw> = <~> --> Symbolic_unary)
##      token prefix:sym<~> ( --> Symbolic_unary)
##          { <sym> }

sub prefix__S_313Tilde__PEEK { $_[0]->_AUTOLEXpeek('prefix__S_313Tilde',$retree) }
sub prefix__S_313Tilde {
my $self = shift;
local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;
my %args = @_;
local $sym = $args{sym} // q(~);


my $C = $self;
my $S = $C->{'_pos'};
$C->{'sym'} = $sym;

$self->_MATCHIFYr($S, "prefix__S_313Tilde",  map { STD::Symbolic_unary->coerce($_) } 
$C->_PATTERN(qr/\G\~/)
);
}

## token prefix__S_314QuestionQuestion (  :$sym is context<rw> = <??> --> Symbolic_unary)
##      token prefix:sym<??> ( --> Symbolic_unary)
##          { <sym> <.badinfix> }

sub prefix__S_314QuestionQuestion__PEEK { $_[0]->_AUTOLEXpeek('prefix__S_314QuestionQuestion',$retree) }
sub prefix__S_314QuestionQuestion {
my $self = shift;
local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;
my %args = @_;
local $sym = $args{sym} // q(??);


my $C = $self;
my $S = $C->{'_pos'};
$C->{'sym'} = $sym;

$self->_MATCHIFYr($S, "prefix__S_314QuestionQuestion",  map { STD::Symbolic_unary->coerce($_) } 
do {
if (my ($C) = ($C->_PATTERN(qr/\G\?\?/))) {
$C->badinfix;
}
else {
();
}
}
);
}

## token prefix__S_315Question (  :$sym is context<rw> = <?> --> Symbolic_unary)
##      token prefix:sym<?> ( --> Symbolic_unary)
##          { <sym> }

sub prefix__S_315Question__PEEK { $_[0]->_AUTOLEXpeek('prefix__S_315Question',$retree) }
sub prefix__S_315Question {
my $self = shift;
local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;
my %args = @_;
local $sym = $args{sym} // q(?);


my $C = $self;
my $S = $C->{'_pos'};
$C->{'sym'} = $sym;

$self->_MATCHIFYr($S, "prefix__S_315Question",  map { STD::Symbolic_unary->coerce($_) } 
$C->_PATTERN(qr/\G\?/)
);
}

## token prefix__S_316TildeCaret (  :$sym is context<rw> = <~^> --> Symbolic_unary)
##      token prefix:sym<~^> ( --> Symbolic_unary)
##          { <sym> }

sub prefix__S_316TildeCaret__PEEK { $_[0]->_AUTOLEXpeek('prefix__S_316TildeCaret',$retree) }
sub prefix__S_316TildeCaret {
my $self = shift;
local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;
my %args = @_;
local $sym = $args{sym} // q(~^);


my $C = $self;
my $S = $C->{'_pos'};
$C->{'sym'} = $sym;

$self->_MATCHIFYr($S, "prefix__S_316TildeCaret",  map { STD::Symbolic_unary->coerce($_) } 
$C->_PATTERN(qr/\G\~\^/)
);
}

## token prefix__S_317PlusCaret (  :$sym is context<rw> = <+^> --> Symbolic_unary)
##      token prefix:sym<+^> ( --> Symbolic_unary)
##          { <sym> }

sub prefix__S_317PlusCaret__PEEK { $_[0]->_AUTOLEXpeek('prefix__S_317PlusCaret',$retree) }
sub prefix__S_317PlusCaret {
my $self = shift;
local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;
my %args = @_;
local $sym = $args{sym} // q(+^);


my $C = $self;
my $S = $C->{'_pos'};
$C->{'sym'} = $sym;

$self->_MATCHIFYr($S, "prefix__S_317PlusCaret",  map { STD::Symbolic_unary->coerce($_) } 
$C->_PATTERN(qr/\G\+\^/)
);
}

## token prefix__S_318QuestionCaret (  :$sym is context<rw> = <?^> --> Symbolic_unary)
##      token prefix:sym<?^> ( --> Symbolic_unary)
##          { <sym> }

sub prefix__S_318QuestionCaret__PEEK { $_[0]->_AUTOLEXpeek('prefix__S_318QuestionCaret',$retree) }
sub prefix__S_318QuestionCaret {
my $self = shift;
local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;
my %args = @_;
local $sym = $args{sym} // q(?^);


my $C = $self;
my $S = $C->{'_pos'};
$C->{'sym'} = $sym;

$self->_MATCHIFYr($S, "prefix__S_318QuestionCaret",  map { STD::Symbolic_unary->coerce($_) } 
$C->_PATTERN(qr/\G\?\^/)
);
}

## token prefix__S_319CaretCaret (  :$sym is context<rw> = <^^> --> Symbolic_unary)
##      token prefix:sym<^^> ( --> Symbolic_unary)
##          { <sym> <.badinfix> }

sub prefix__S_319CaretCaret__PEEK { $_[0]->_AUTOLEXpeek('prefix__S_319CaretCaret',$retree) }
sub prefix__S_319CaretCaret {
my $self = shift;
local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;
my %args = @_;
local $sym = $args{sym} // q(^^);


my $C = $self;
my $S = $C->{'_pos'};
$C->{'sym'} = $sym;

$self->_MATCHIFYr($S, "prefix__S_319CaretCaret",  map { STD::Symbolic_unary->coerce($_) } 
do {
if (my ($C) = ($C->_PATTERN(qr/\G\^\^/))) {
$C->badinfix;
}
else {
();
}
}
);
}

## token prefix__S_320Caret (  :$sym is context<rw> = <^> --> Symbolic_unary)
##      token prefix:sym<^> ( --> Symbolic_unary)
##          { <sym> }

sub prefix__S_320Caret__PEEK { $_[0]->_AUTOLEXpeek('prefix__S_320Caret',$retree) }
sub prefix__S_320Caret {
my $self = shift;
local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;
my %args = @_;
local $sym = $args{sym} // q(^);


my $C = $self;
my $S = $C->{'_pos'};
$C->{'sym'} = $sym;

$self->_MATCHIFYr($S, "prefix__S_320Caret",  map { STD::Symbolic_unary->coerce($_) } 
$C->_PATTERN(qr/\G\^/)
);
}

## token prefix__S_321VertVert (  :$sym is context<rw> = <||> --> Symbolic_unary)
##      token prefix:sym<||> ( --> Symbolic_unary)
##          { <sym> <.badinfix> }

sub prefix__S_321VertVert__PEEK { $_[0]->_AUTOLEXpeek('prefix__S_321VertVert',$retree) }
sub prefix__S_321VertVert {
my $self = shift;
local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;
my %args = @_;
local $sym = $args{sym} // q(||);


my $C = $self;
my $S = $C->{'_pos'};
$C->{'sym'} = $sym;

$self->_MATCHIFYr($S, "prefix__S_321VertVert",  map { STD::Symbolic_unary->coerce($_) } 
do {
if (my ($C) = ($C->_PATTERN(qr/\G\|\|/))) {
$C->badinfix;
}
else {
();
}
}
);
}

## token prefix__S_322Vert (  :$sym is context<rw> = <|> --> Symbolic_unary)
##      token prefix:sym<|> ( --> Symbolic_unary)
##          { <sym> }

sub prefix__S_322Vert__PEEK { $_[0]->_AUTOLEXpeek('prefix__S_322Vert',$retree) }
sub prefix__S_322Vert {
my $self = shift;
local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;
my %args = @_;
local $sym = $args{sym} // q(|);


my $C = $self;
my $S = $C->{'_pos'};
$C->{'sym'} = $sym;

$self->_MATCHIFYr($S, "prefix__S_322Vert",  map { STD::Symbolic_unary->coerce($_) } 
$C->_PATTERN(qr/\G\|/)
);
}


## multiplicative
## token infix__S_323Star (  :$sym is context<rw> = <*> --> Multiplicative)
##      token infix:sym<*> ( --> Multiplicative)
##          { <sym> }

sub infix__S_323Star__PEEK { $_[0]->_AUTOLEXpeek('infix__S_323Star',$retree) }
sub infix__S_323Star {
my $self = shift;
local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;
my %args = @_;
local $sym = $args{sym} // q(*);


my $C = $self;
my $S = $C->{'_pos'};
$C->{'sym'} = $sym;

$self->_MATCHIFYr($S, "infix__S_323Star",  map { STD::Multiplicative->coerce($_) } 
$C->_PATTERN(qr/\G\*/)
);
}

## token infix__S_324Slash (  :$sym is context<rw> = </> --> Multiplicative)
##      token infix:sym</> ( --> Multiplicative)
##          { <sym> }

sub infix__S_324Slash__PEEK { $_[0]->_AUTOLEXpeek('infix__S_324Slash',$retree) }
sub infix__S_324Slash {
my $self = shift;
local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;
my %args = @_;
local $sym = $args{sym} // q(/);


my $C = $self;
my $S = $C->{'_pos'};
$C->{'sym'} = $sym;

$self->_MATCHIFYr($S, "infix__S_324Slash",  map { STD::Multiplicative->coerce($_) } 
$C->_PATTERN(qr/\G\//)
);
}

## token infix__S_325div (  :$sym is context<rw> = <div> --> Multiplicative)
##      token infix:sym<div> ( --> Multiplicative)
##          { <sym> }

sub infix__S_325div__PEEK { $_[0]->_AUTOLEXpeek('infix__S_325div',$retree) }
sub infix__S_325div {
my $self = shift;
local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;
my %args = @_;
local $sym = $args{sym} // q(div);


my $C = $self;
my $S = $C->{'_pos'};
$C->{'sym'} = $sym;

$self->_MATCHIFYr($S, "infix__S_325div",  map { STD::Multiplicative->coerce($_) } 
$C->_PATTERN(qr/\Gdiv/)
);
}

## token infix__S_326Percent (  :$sym is context<rw> = <%> --> Multiplicative)
##      token infix:sym<%> ( --> Multiplicative)
##          { <sym> <?{ $<O><iffy> = 1; }> }

sub infix__S_326Percent__PEEK { $_[0]->_AUTOLEXpeek('infix__S_326Percent',$retree) }
sub infix__S_326Percent {
my $self = shift;
local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;
my %args = @_;
local $sym = $args{sym} // q(%);


my $C = $self;
my $S = $C->{'_pos'};
$C->{'sym'} = $sym;

$self->_MATCHIFYr($S, "infix__S_326Percent",  map { STD::Multiplicative->coerce($_) } 
do {
if (my ($C) = ($C->_PATTERN(qr/\G\%/))) {
$C->before( sub { my $C=shift;
(($C) x !!do {
my $M = $C;  $M->{'O'}{'iffy'} = 1; ;
})
});
}
else {
();
}
}
);
}   # Allow !% operator

## token infix__S_327mod (  :$sym is context<rw> = <mod> --> Multiplicative)
##      token infix:sym<mod> ( --> Multiplicative)
##          { <sym> }

sub infix__S_327mod__PEEK { $_[0]->_AUTOLEXpeek('infix__S_327mod',$retree) }
sub infix__S_327mod {
my $self = shift;
local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;
my %args = @_;
local $sym = $args{sym} // q(mod);


my $C = $self;
my $S = $C->{'_pos'};
$C->{'sym'} = $sym;

$self->_MATCHIFYr($S, "infix__S_327mod",  map { STD::Multiplicative->coerce($_) } 
$C->_PATTERN(qr/\Gmod/)
);
}

## token infix__S_328PlusAmp (  :$sym is context<rw> = <+&> --> Multiplicative)
##      token infix:sym<+&> ( --> Multiplicative)
##          { <sym> }

sub infix__S_328PlusAmp__PEEK { $_[0]->_AUTOLEXpeek('infix__S_328PlusAmp',$retree) }
sub infix__S_328PlusAmp {
my $self = shift;
local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;
my %args = @_;
local $sym = $args{sym} // q(+&);


my $C = $self;
my $S = $C->{'_pos'};
$C->{'sym'} = $sym;

$self->_MATCHIFYr($S, "infix__S_328PlusAmp",  map { STD::Multiplicative->coerce($_) } 
$C->_PATTERN(qr/\G\+\&/)
);
}

## token infix__S_329PlusLt (  :$sym is context<rw> = « +< » --> Multiplicative)
##      token infix:sym« +< » ( --> Multiplicative)
##          { <sym> <!before '<'> }

sub infix__S_329PlusLt__PEEK { $_[0]->_AUTOLEXpeek('infix__S_329PlusLt',$retree) }
sub infix__S_329PlusLt {
my $self = shift;
local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;
my %args = @_;
local $sym = $args{sym} //['+<'];


my $C = $self;
my $S = $C->{'_pos'};
$C->{'sym'} = $sym;

$self->_MATCHIFYr($S, "infix__S_329PlusLt",  map { STD::Multiplicative->coerce($_) } 
do {
if (my ($C) = ($C->_PATTERN(qr/\G\+\</))) {
$C->_NOTBEFORE( sub { my $C=shift;
$C->before(sub { my $C=shift;
$C->_EXACT('<')
})
});
}
else {
();
}
}
);
}

## token infix__S_330LtLt (  :$sym is context<rw> = « << » --> Multiplicative)
##      token infix:sym« << » ( --> Multiplicative)
##          { <sym> \s <.obs('<< to do left shift', '+< or ~<')> }

sub infix__S_330LtLt__PEEK { $_[0]->_AUTOLEXpeek('infix__S_330LtLt',$retree) }
sub infix__S_330LtLt {
my $self = shift;
local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;
my %args = @_;
local $sym = $args{sym} //['<<'];


my $C = $self;
my $S = $C->{'_pos'};
$C->{'sym'} = $sym;

$self->_MATCHIFYr($S, "infix__S_330LtLt",  map { STD::Multiplicative->coerce($_) } 
do {
if (my ($C) = ($C->_PATTERN(qr/\G\<\</))) {
do {
if (my ($C) = ($C->_PATTERN(qr/\G\s/))) {
$C->obs('<< to do left shift', '+< or ~<');
}
else {
();
}
};
}
else {
();
}
}
);
}

## token infix__S_331GtGt (  :$sym is context<rw> = « >> » --> Multiplicative)
##      token infix:sym« >> » ( --> Multiplicative)
##          { <sym> \s <.obs('>> to do right shift', '+> or ~>')> }

sub infix__S_331GtGt__PEEK { $_[0]->_AUTOLEXpeek('infix__S_331GtGt',$retree) }
sub infix__S_331GtGt {
my $self = shift;
local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;
my %args = @_;
local $sym = $args{sym} //['>>'];


my $C = $self;
my $S = $C->{'_pos'};
$C->{'sym'} = $sym;

$self->_MATCHIFYr($S, "infix__S_331GtGt",  map { STD::Multiplicative->coerce($_) } 
do {
if (my ($C) = ($C->_PATTERN(qr/\G\>\>/))) {
do {
if (my ($C) = ($C->_PATTERN(qr/\G\s/))) {
$C->obs('>> to do right shift', '+> or ~>');
}
else {
();
}
};
}
else {
();
}
}
);
}

## token infix__S_332PlusGt (  :$sym is context<rw> = « +> » --> Multiplicative)
##      token infix:sym« +> » ( --> Multiplicative)
##          { <sym> <!before '>'> }

sub infix__S_332PlusGt__PEEK { $_[0]->_AUTOLEXpeek('infix__S_332PlusGt',$retree) }
sub infix__S_332PlusGt {
my $self = shift;
local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;
my %args = @_;
local $sym = $args{sym} //['+>'];


my $C = $self;
my $S = $C->{'_pos'};
$C->{'sym'} = $sym;

$self->_MATCHIFYr($S, "infix__S_332PlusGt",  map { STD::Multiplicative->coerce($_) } 
do {
if (my ($C) = ($C->_PATTERN(qr/\G\+\>/))) {
$C->_NOTBEFORE( sub { my $C=shift;
$C->before(sub { my $C=shift;
$C->_EXACT('>')
})
});
}
else {
();
}
}
);
}

## token infix__S_333TildeAmp (  :$sym is context<rw> = <~&> --> Multiplicative)
##      token infix:sym<~&> ( --> Multiplicative)
##          { <sym> }

sub infix__S_333TildeAmp__PEEK { $_[0]->_AUTOLEXpeek('infix__S_333TildeAmp',$retree) }
sub infix__S_333TildeAmp {
my $self = shift;
local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;
my %args = @_;
local $sym = $args{sym} // q(~&);


my $C = $self;
my $S = $C->{'_pos'};
$C->{'sym'} = $sym;

$self->_MATCHIFYr($S, "infix__S_333TildeAmp",  map { STD::Multiplicative->coerce($_) } 
$C->_PATTERN(qr/\G\~\&/)
);
}

## token infix__S_334QuestionAmp (  :$sym is context<rw> = <?&> --> Multiplicative)
##      token infix:sym<?&> ( --> Multiplicative)
##          { <sym> }

sub infix__S_334QuestionAmp__PEEK { $_[0]->_AUTOLEXpeek('infix__S_334QuestionAmp',$retree) }
sub infix__S_334QuestionAmp {
my $self = shift;
local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;
my %args = @_;
local $sym = $args{sym} // q(?&);


my $C = $self;
my $S = $C->{'_pos'};
$C->{'sym'} = $sym;

$self->_MATCHIFYr($S, "infix__S_334QuestionAmp",  map { STD::Multiplicative->coerce($_) } 
$C->_PATTERN(qr/\G\?\&/)
);
}

## token infix__S_335TildeLt (  :$sym is context<rw> = « ~< » --> Multiplicative)
##      token infix:sym« ~< » ( --> Multiplicative)
##          { <sym> <!before '<'> }

sub infix__S_335TildeLt__PEEK { $_[0]->_AUTOLEXpeek('infix__S_335TildeLt',$retree) }
sub infix__S_335TildeLt {
my $self = shift;
local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;
my %args = @_;
local $sym = $args{sym} //['~<'];


my $C = $self;
my $S = $C->{'_pos'};
$C->{'sym'} = $sym;

$self->_MATCHIFYr($S, "infix__S_335TildeLt",  map { STD::Multiplicative->coerce($_) } 
do {
if (my ($C) = ($C->_PATTERN(qr/\G\~\</))) {
$C->_NOTBEFORE( sub { my $C=shift;
$C->before(sub { my $C=shift;
$C->_EXACT('<')
})
});
}
else {
();
}
}
);
}

## token infix__S_336TildeGt (  :$sym is context<rw> = « ~> » --> Multiplicative)
##      token infix:sym« ~> » ( --> Multiplicative)
##          { <sym> <!before '>'> }

sub infix__S_336TildeGt__PEEK { $_[0]->_AUTOLEXpeek('infix__S_336TildeGt',$retree) }
sub infix__S_336TildeGt {
my $self = shift;
local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;
my %args = @_;
local $sym = $args{sym} //['~>'];


my $C = $self;
my $S = $C->{'_pos'};
$C->{'sym'} = $sym;

$self->_MATCHIFYr($S, "infix__S_336TildeGt",  map { STD::Multiplicative->coerce($_) } 
do {
if (my ($C) = ($C->_PATTERN(qr/\G\~\>/))) {
$C->_NOTBEFORE( sub { my $C=shift;
$C->before(sub { my $C=shift;
$C->_EXACT('>')
})
});
}
else {
();
}
}
);
}


## additive
## token infix__S_337Plus (  :$sym is context<rw> = <+> --> Additive)
##      token infix:sym<+> ( --> Additive)
##          { <sym> }

sub infix__S_337Plus__PEEK { $_[0]->_AUTOLEXpeek('infix__S_337Plus',$retree) }
sub infix__S_337Plus {
my $self = shift;
local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;
my %args = @_;
local $sym = $args{sym} // q(+);


my $C = $self;
my $S = $C->{'_pos'};
$C->{'sym'} = $sym;

$self->_MATCHIFYr($S, "infix__S_337Plus",  map { STD::Additive->coerce($_) } 
$C->_PATTERN(qr/\G\+/)
);
}

## token infix__S_338Minus (  :$sym is context<rw> = <-> --> Additive)
##      token infix:sym<-> ( --> Additive)
##          { <sym> }

sub infix__S_338Minus__PEEK { $_[0]->_AUTOLEXpeek('infix__S_338Minus',$retree) }
sub infix__S_338Minus {
my $self = shift;
local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;
my %args = @_;
local $sym = $args{sym} // q(-);


my $C = $self;
my $S = $C->{'_pos'};
$C->{'sym'} = $sym;

$self->_MATCHIFYr($S, "infix__S_338Minus",  map { STD::Additive->coerce($_) } 
$C->_PATTERN(qr/\G\-/)
);
}

## token infix__S_339PlusVert (  :$sym is context<rw> = <+|> --> Additive)
##      token infix:sym<+|> ( --> Additive)
##          { <sym> }

sub infix__S_339PlusVert__PEEK { $_[0]->_AUTOLEXpeek('infix__S_339PlusVert',$retree) }
sub infix__S_339PlusVert {
my $self = shift;
local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;
my %args = @_;
local $sym = $args{sym} // q(+|);


my $C = $self;
my $S = $C->{'_pos'};
$C->{'sym'} = $sym;

$self->_MATCHIFYr($S, "infix__S_339PlusVert",  map { STD::Additive->coerce($_) } 
$C->_PATTERN(qr/\G\+\|/)
);
}

## token infix__S_340PlusCaret (  :$sym is context<rw> = <+^> --> Additive)
##      token infix:sym<+^> ( --> Additive)
##          { <sym> }

sub infix__S_340PlusCaret__PEEK { $_[0]->_AUTOLEXpeek('infix__S_340PlusCaret',$retree) }
sub infix__S_340PlusCaret {
my $self = shift;
local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;
my %args = @_;
local $sym = $args{sym} // q(+^);


my $C = $self;
my $S = $C->{'_pos'};
$C->{'sym'} = $sym;

$self->_MATCHIFYr($S, "infix__S_340PlusCaret",  map { STD::Additive->coerce($_) } 
$C->_PATTERN(qr/\G\+\^/)
);
}

## token infix__S_341TildeVert (  :$sym is context<rw> = <~|> --> Additive)
##      token infix:sym<~|> ( --> Additive)
##          { <sym> }

sub infix__S_341TildeVert__PEEK { $_[0]->_AUTOLEXpeek('infix__S_341TildeVert',$retree) }
sub infix__S_341TildeVert {
my $self = shift;
local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;
my %args = @_;
local $sym = $args{sym} // q(~|);


my $C = $self;
my $S = $C->{'_pos'};
$C->{'sym'} = $sym;

$self->_MATCHIFYr($S, "infix__S_341TildeVert",  map { STD::Additive->coerce($_) } 
$C->_PATTERN(qr/\G\~\|/)
);
}

## token infix__S_342TildeCaret (  :$sym is context<rw> = <~^> --> Additive)
##      token infix:sym<~^> ( --> Additive)
##          { <sym> }

sub infix__S_342TildeCaret__PEEK { $_[0]->_AUTOLEXpeek('infix__S_342TildeCaret',$retree) }
sub infix__S_342TildeCaret {
my $self = shift;
local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;
my %args = @_;
local $sym = $args{sym} // q(~^);


my $C = $self;
my $S = $C->{'_pos'};
$C->{'sym'} = $sym;

$self->_MATCHIFYr($S, "infix__S_342TildeCaret",  map { STD::Additive->coerce($_) } 
$C->_PATTERN(qr/\G\~\^/)
);
}

## token infix__S_343QuestionVert (  :$sym is context<rw> = <?|> --> Additive)
##      token infix:sym<?|> ( --> Additive)
##          { <sym> }

sub infix__S_343QuestionVert__PEEK { $_[0]->_AUTOLEXpeek('infix__S_343QuestionVert',$retree) }
sub infix__S_343QuestionVert {
my $self = shift;
local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;
my %args = @_;
local $sym = $args{sym} // q(?|);


my $C = $self;
my $S = $C->{'_pos'};
$C->{'sym'} = $sym;

$self->_MATCHIFYr($S, "infix__S_343QuestionVert",  map { STD::Additive->coerce($_) } 
$C->_PATTERN(qr/\G\?\|/)
);
}

## token infix__S_344QuestionCaret (  :$sym is context<rw> = <?^> --> Additive)
##      token infix:sym<?^> ( --> Additive)
##          { <sym> }

sub infix__S_344QuestionCaret__PEEK { $_[0]->_AUTOLEXpeek('infix__S_344QuestionCaret',$retree) }
sub infix__S_344QuestionCaret {
my $self = shift;
local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;
my %args = @_;
local $sym = $args{sym} // q(?^);


my $C = $self;
my $S = $C->{'_pos'};
$C->{'sym'} = $sym;

$self->_MATCHIFYr($S, "infix__S_344QuestionCaret",  map { STD::Additive->coerce($_) } 
$C->_PATTERN(qr/\G\?\^/)
);
}

## replication
# Note: no word boundary check after x, relies on longest token for x2 xx2 etc
## token infix__S_345x (  :$sym is context<rw> = <x> --> Replication)
##      token infix:sym<x> ( --> Replication)
##          { <sym> }

sub infix__S_345x__PEEK { $_[0]->_AUTOLEXpeek('infix__S_345x',$retree) }
sub infix__S_345x {
my $self = shift;
local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;
my %args = @_;
local $sym = $args{sym} // q(x);


my $C = $self;
my $S = $C->{'_pos'};
$C->{'sym'} = $sym;

$self->_MATCHIFYr($S, "infix__S_345x",  map { STD::Replication->coerce($_) } 
$C->_PATTERN(qr/\Gx/)
);
}

## token infix__S_346xx (  :$sym is context<rw> = <xx> --> Replication)
##      token infix:sym<xx> ( --> Replication)
##          { <sym> }

sub infix__S_346xx__PEEK { $_[0]->_AUTOLEXpeek('infix__S_346xx',$retree) }
sub infix__S_346xx {
my $self = shift;
local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;
my %args = @_;
local $sym = $args{sym} // q(xx);


my $C = $self;
my $S = $C->{'_pos'};
$C->{'sym'} = $sym;

$self->_MATCHIFYr($S, "infix__S_346xx",  map { STD::Replication->coerce($_) } 
$C->_PATTERN(qr/\Gxx/)
);
}

## concatenation
## token infix__S_347Tilde (  :$sym is context<rw> = <~> --> Concatenation)
##      token infix:sym<~> ( --> Concatenation)
##          { <sym> }

sub infix__S_347Tilde__PEEK { $_[0]->_AUTOLEXpeek('infix__S_347Tilde',$retree) }
sub infix__S_347Tilde {
my $self = shift;
local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;
my %args = @_;
local $sym = $args{sym} // q(~);


my $C = $self;
my $S = $C->{'_pos'};
$C->{'sym'} = $sym;

$self->_MATCHIFYr($S, "infix__S_347Tilde",  map { STD::Concatenation->coerce($_) } 
$C->_PATTERN(qr/\G\~/)
);
}


## junctive and (all)
## token infix__S_348Amp (  :$sym is context<rw> = <&> --> Junctive_and)
##      token infix:sym<&> ( --> Junctive_and)
##          { <sym> }

sub infix__S_348Amp__PEEK { $_[0]->_AUTOLEXpeek('infix__S_348Amp',$retree) }
sub infix__S_348Amp {
my $self = shift;
local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;
my %args = @_;
local $sym = $args{sym} // q(&);


my $C = $self;
my $S = $C->{'_pos'};
$C->{'sym'} = $sym;

$self->_MATCHIFYr($S, "infix__S_348Amp",  map { STD::Junctive_and->coerce($_) } 
$C->_PATTERN(qr/\G\&/)
);
}

## token infix__S_349also (  :$sym is context<rw> = <also> --> Junctive_and)
##      token infix:sym<also> ( --> Junctive_and)
##          { <sym> }

sub infix__S_349also__PEEK { $_[0]->_AUTOLEXpeek('infix__S_349also',$retree) }
sub infix__S_349also {
my $self = shift;
local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;
my %args = @_;
local $sym = $args{sym} // q(also);


my $C = $self;
my $S = $C->{'_pos'};
$C->{'sym'} = $sym;

$self->_MATCHIFYr($S, "infix__S_349also",  map { STD::Junctive_and->coerce($_) } 
$C->_PATTERN(qr/\Galso/)
);
}


## junctive or (any)
## token infix__S_350Vert (  :$sym is context<rw> = <|> --> Junctive_or)
##      token infix:sym<|> ( --> Junctive_or)
##          { <sym> }

sub infix__S_350Vert__PEEK { $_[0]->_AUTOLEXpeek('infix__S_350Vert',$retree) }
sub infix__S_350Vert {
my $self = shift;
local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;
my %args = @_;
local $sym = $args{sym} // q(|);


my $C = $self;
my $S = $C->{'_pos'};
$C->{'sym'} = $sym;

$self->_MATCHIFYr($S, "infix__S_350Vert",  map { STD::Junctive_or->coerce($_) } 
$C->_PATTERN(qr/\G\|/)
);
}

## token infix__S_351Caret (  :$sym is context<rw> = <^> --> Junctive_or)
##      token infix:sym<^> ( --> Junctive_or)
##          { <sym> }

sub infix__S_351Caret__PEEK { $_[0]->_AUTOLEXpeek('infix__S_351Caret',$retree) }
sub infix__S_351Caret {
my $self = shift;
local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;
my %args = @_;
local $sym = $args{sym} // q(^);


my $C = $self;
my $S = $C->{'_pos'};
$C->{'sym'} = $sym;

$self->_MATCHIFYr($S, "infix__S_351Caret",  map { STD::Junctive_or->coerce($_) } 
$C->_PATTERN(qr/\G\^/)
);
}


## named unary examples
# (need \s* to win LTM battle with listops)
## token prefix__S_352sleep (  :$sym is context<rw> = 'sleep' --> Named_unary)
##      token prefix:sleep ( --> Named_unary)
##          { <sym> » <?before \s*> }

sub prefix__S_352sleep__PEEK { $_[0]->_AUTOLEXpeek('prefix__S_352sleep',$retree) }
sub prefix__S_352sleep {
my $self = shift;
local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;
my %args = @_;
local $sym = $args{sym} // 'sleep';


my $C = $self;
my $S = $C->{'_pos'};
$C->{'sym'} = $sym;

$self->_MATCHIFYr($S, "prefix__S_352sleep",  map { STD::Named_unary->coerce($_) } 
do {
if (my ($C) = ($C->_PATTERN(qr/\Gsleep/))) {
do {
if (my ($C) = ($C->_PATTERN(qr/\G\b/))) {
$C->before(sub { my $C=shift;
$C->_PATTERN(qr/\G((?:\s)*+)/)
});
}
else {
();
}
};
}
else {
();
}
}
);
}

## token prefix__S_353abs (  :$sym is context<rw> = 'abs' --> Named_unary)
##      token prefix:abs ( --> Named_unary)
##          { <sym> » <?before \s*> }

sub prefix__S_353abs__PEEK { $_[0]->_AUTOLEXpeek('prefix__S_353abs',$retree) }
sub prefix__S_353abs {
my $self = shift;
local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;
my %args = @_;
local $sym = $args{sym} // 'abs';


my $C = $self;
my $S = $C->{'_pos'};
$C->{'sym'} = $sym;

$self->_MATCHIFYr($S, "prefix__S_353abs",  map { STD::Named_unary->coerce($_) } 
do {
if (my ($C) = ($C->_PATTERN(qr/\Gabs/))) {
do {
if (my ($C) = ($C->_PATTERN(qr/\G\b/))) {
$C->before(sub { my $C=shift;
$C->_PATTERN(qr/\G((?:\s)*+)/)
});
}
else {
();
}
};
}
else {
();
}
}
);
}

## token prefix__S_354let (  :$sym is context<rw> = 'let' --> Named_unary)
##      token prefix:let ( --> Named_unary)
##          { <sym> » <?before \s*> }

sub prefix__S_354let__PEEK { $_[0]->_AUTOLEXpeek('prefix__S_354let',$retree) }
sub prefix__S_354let {
my $self = shift;
local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;
my %args = @_;
local $sym = $args{sym} // 'let';


my $C = $self;
my $S = $C->{'_pos'};
$C->{'sym'} = $sym;

$self->_MATCHIFYr($S, "prefix__S_354let",  map { STD::Named_unary->coerce($_) } 
do {
if (my ($C) = ($C->_PATTERN(qr/\Glet/))) {
do {
if (my ($C) = ($C->_PATTERN(qr/\G\b/))) {
$C->before(sub { my $C=shift;
$C->_PATTERN(qr/\G((?:\s)*+)/)
});
}
else {
();
}
};
}
else {
();
}
}
);
}

## token prefix__S_355temp (  :$sym is context<rw> = 'temp' --> Named_unary)
##      token prefix:temp ( --> Named_unary)
##          { <sym> » <?before \s*> }

sub prefix__S_355temp__PEEK { $_[0]->_AUTOLEXpeek('prefix__S_355temp',$retree) }
sub prefix__S_355temp {
my $self = shift;
local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;
my %args = @_;
local $sym = $args{sym} // 'temp';


my $C = $self;
my $S = $C->{'_pos'};
$C->{'sym'} = $sym;

$self->_MATCHIFYr($S, "prefix__S_355temp",  map { STD::Named_unary->coerce($_) } 
do {
if (my ($C) = ($C->_PATTERN(qr/\Gtemp/))) {
do {
if (my ($C) = ($C->_PATTERN(qr/\G\b/))) {
$C->before(sub { my $C=shift;
$C->_PATTERN(qr/\G((?:\s)*+)/)
});
}
else {
();
}
};
}
else {
();
}
}
);
}


## structural infix
## token infix__S_356LtEqualGt (  :$sym is context<rw> = « <=> » --> Structural)
##      token infix:sym« <=> » ( --> Structural)
##          { <sym> <?{ $<O><returns> = "Order"; }> }

sub infix__S_356LtEqualGt__PEEK { $_[0]->_AUTOLEXpeek('infix__S_356LtEqualGt',$retree) }
sub infix__S_356LtEqualGt {
my $self = shift;
local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;
my %args = @_;
local $sym = $args{sym} //['<=>'];


my $C = $self;
my $S = $C->{'_pos'};
$C->{'sym'} = $sym;

$self->_MATCHIFYr($S, "infix__S_356LtEqualGt",  map { STD::Structural->coerce($_) } 
do {
if (my ($C) = ($C->_PATTERN(qr/\G\<\=\>/))) {
$C->before( sub { my $C=shift;
(($C) x !!do {
my $M = $C;  $M->{'O'}{'returns'} = "Order"; ;
})
});
}
else {
();
}
}
);
}

## token infix__S_357cmp (  :$sym is context<rw> = 'cmp' --> Structural)
##      token infix:cmp ( --> Structural)
##          { <sym> <?{ $<O><returns> = "Order"; }> }

sub infix__S_357cmp__PEEK { $_[0]->_AUTOLEXpeek('infix__S_357cmp',$retree) }
sub infix__S_357cmp {
my $self = shift;
local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;
my %args = @_;
local $sym = $args{sym} // 'cmp';


my $C = $self;
my $S = $C->{'_pos'};
$C->{'sym'} = $sym;

$self->_MATCHIFYr($S, "infix__S_357cmp",  map { STD::Structural->coerce($_) } 
do {
if (my ($C) = ($C->_PATTERN(qr/\Gcmp/))) {
$C->before( sub { my $C=shift;
(($C) x !!do {
my $M = $C;  $M->{'O'}{'returns'} = "Order"; ;
})
});
}
else {
();
}
}
);
}

## token infix__S_358leg (  :$sym is context<rw> = 'leg' --> Structural)
##      token infix:leg ( --> Structural)
##          { <sym> <?{ $<O><returns> = "Order"; }> }

sub infix__S_358leg__PEEK { $_[0]->_AUTOLEXpeek('infix__S_358leg',$retree) }
sub infix__S_358leg {
my $self = shift;
local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;
my %args = @_;
local $sym = $args{sym} // 'leg';


my $C = $self;
my $S = $C->{'_pos'};
$C->{'sym'} = $sym;

$self->_MATCHIFYr($S, "infix__S_358leg",  map { STD::Structural->coerce($_) } 
do {
if (my ($C) = ($C->_PATTERN(qr/\Gleg/))) {
$C->before( sub { my $C=shift;
(($C) x !!do {
my $M = $C;  $M->{'O'}{'returns'} = "Order"; ;
})
});
}
else {
();
}
}
);
}

## token infix__S_359but (  :$sym is context<rw> = 'but' --> Structural)
##      token infix:but ( --> Structural)
##          { <sym> }

sub infix__S_359but__PEEK { $_[0]->_AUTOLEXpeek('infix__S_359but',$retree) }
sub infix__S_359but {
my $self = shift;
local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;
my %args = @_;
local $sym = $args{sym} // 'but';


my $C = $self;
my $S = $C->{'_pos'};
$C->{'sym'} = $sym;

$self->_MATCHIFYr($S, "infix__S_359but",  map { STD::Structural->coerce($_) } 
$C->_PATTERN(qr/\Gbut/)
);
}

## token infix__S_360does (  :$sym is context<rw> = 'does' --> Structural)
##      token infix:does ( --> Structural)
##          { <sym> }

sub infix__S_360does__PEEK { $_[0]->_AUTOLEXpeek('infix__S_360does',$retree) }
sub infix__S_360does {
my $self = shift;
local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;
my %args = @_;
local $sym = $args{sym} // 'does';


my $C = $self;
my $S = $C->{'_pos'};
$C->{'sym'} = $sym;

$self->_MATCHIFYr($S, "infix__S_360does",  map { STD::Structural->coerce($_) } 
$C->_PATTERN(qr/\Gdoes/)
);
}

## token infix__S_361DotDot (  :$sym is context<rw> = <..> --> Structural)
##      token infix:sym<..> ( --> Structural)
##          { <sym> [<!{ $*IN_META }> <?before ')' | ']'> <.panic: "Please use ..* for indefinite range">]? }

sub infix__S_361DotDot__PEEK { $_[0]->_AUTOLEXpeek('infix__S_361DotDot',$retree) }
sub infix__S_361DotDot {
my $self = shift;
local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;
my %args = @_;
local $sym = $args{sym} // q(..);


my $C = $self;
my $S = $C->{'_pos'};
$C->{'sym'} = $sym;

$self->_MATCHIFYr($S, "infix__S_361DotDot",  map { STD::Structural->coerce($_) } 
do {
if (my ($C) = ($C->_PATTERN(qr/\G\.\./))) {
$C->_OPTr(sub { my $C=shift;
$C->_BRACKETr( sub { my $C=shift;
do {
if (my ($C) = ($C->_NOTBEFORE( sub { my $C=shift;
(($C) x !!do {
$::IN_META 
})
}))) {
do {
if (my ($C) = ($C->before(sub { my $C=shift;
do {
my @result = eval {
my $trystate;
my ($tag, $try);
my @try;
my $relex;

my $fate;
if ($fate = $C->{'_fate'} and $fate->[1] eq 'infix__S_361DotDot_02') {
$C->deb("Fate passed to infix__S_361DotDot_02: ", ::fatestr($fate)) if $::DEBUG & DEBUG::fates;
($C->{'_fate'}, $tag, $try) = @$fate;
@try = ($try);
}

my @gather = ();
for (;;) {
if (not @try) {
$relex //= $C->cursor_fate('STD', 'infix__S_361DotDot_02', $retree);
@try = $relex->($C, $trystate);
}
last unless @try;
$try = shift(@try) // next;

if (ref $try eq 'ARRAY') {
($C->{'_fate'}, $tag, $try) = @$try;	# next candidate fate
}

$C->deb("infix__S_361DotDot_02 trying $tag $try") if $::DEBUG & DEBUG::try_processing;
push @gather, ((
sub { my $C=shift;
$C->_EXACT(')')
},
sub { my $C=shift;
$C->_EXACT(']')
},
)[$try])->($C);
last if @gather;
}
@gather;
};
if (@result) {
@result;
}
elsif ($@) {
my ($first) = $@ =~ /(^.*)/;
$self->deb("CAUGHT $first") if $::DEBUG & DEBUG::trace_call;
die $@ if $@ !~ /^ABORTBRANCH/;
();
}
else {
();
}
}

}))) {
$C->panic("Please use ..* for indefinite range");
}
else {
();
}
};
}
else {
();
}
}
})
});
}
else {
();
}
}
);
}

## token infix__S_362CaretDotDot (  :$sym is context<rw> = <^..> --> Structural)
##      token infix:sym<^..> ( --> Structural)
##          { <sym> }

sub infix__S_362CaretDotDot__PEEK { $_[0]->_AUTOLEXpeek('infix__S_362CaretDotDot',$retree) }
sub infix__S_362CaretDotDot {
my $self = shift;
local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;
my %args = @_;
local $sym = $args{sym} // q(^..);


my $C = $self;
my $S = $C->{'_pos'};
$C->{'sym'} = $sym;

$self->_MATCHIFYr($S, "infix__S_362CaretDotDot",  map { STD::Structural->coerce($_) } 
$C->_PATTERN(qr/\G\^\.\./)
);
}

## token infix__S_363DotDotCaret (  :$sym is context<rw> = <..^> --> Structural)
##      token infix:sym<..^> ( --> Structural)
##          { <sym> }

sub infix__S_363DotDotCaret__PEEK { $_[0]->_AUTOLEXpeek('infix__S_363DotDotCaret',$retree) }
sub infix__S_363DotDotCaret {
my $self = shift;
local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;
my %args = @_;
local $sym = $args{sym} // q(..^);


my $C = $self;
my $S = $C->{'_pos'};
$C->{'sym'} = $sym;

$self->_MATCHIFYr($S, "infix__S_363DotDotCaret",  map { STD::Structural->coerce($_) } 
$C->_PATTERN(qr/\G\.\.\^/)
);
}

## token infix__S_364CaretDotDotCaret (  :$sym is context<rw> = <^..^> --> Structural)
##      token infix:sym<^..^> ( --> Structural)
##          { <sym> }

sub infix__S_364CaretDotDotCaret__PEEK { $_[0]->_AUTOLEXpeek('infix__S_364CaretDotDotCaret',$retree) }
sub infix__S_364CaretDotDotCaret {
my $self = shift;
local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;
my %args = @_;
local $sym = $args{sym} // q(^..^);


my $C = $self;
my $S = $C->{'_pos'};
$C->{'sym'} = $sym;

$self->_MATCHIFYr($S, "infix__S_364CaretDotDotCaret",  map { STD::Structural->coerce($_) } 
$C->_PATTERN(qr/\G\^\.\.\^/)
);
}


## chaining binary
## token infix__S_365EqualEqual (  :$sym is context<rw> = <==> --> Chaining)
##      token infix:sym<==> ( --> Chaining)
##          { <sym> <!before '=' > }

sub infix__S_365EqualEqual__PEEK { $_[0]->_AUTOLEXpeek('infix__S_365EqualEqual',$retree) }
sub infix__S_365EqualEqual {
my $self = shift;
local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;
my %args = @_;
local $sym = $args{sym} // q(==);


my $C = $self;
my $S = $C->{'_pos'};
$C->{'sym'} = $sym;

$self->_MATCHIFYr($S, "infix__S_365EqualEqual",  map { STD::Chaining->coerce($_) } 
do {
if (my ($C) = ($C->_PATTERN(qr/\G\=\=/))) {
$C->_NOTBEFORE( sub { my $C=shift;
$C->before(sub { my $C=shift;
$C->_EXACT('=')
})
});
}
else {
();
}
}
);
}

## token infix__S_366BangEqual (  :$sym is context<rw> = <!=> --> Chaining)
##      token infix:sym<!=> ( --> Chaining)
##          { <sym> <?before \s> }

sub infix__S_366BangEqual__PEEK { $_[0]->_AUTOLEXpeek('infix__S_366BangEqual',$retree) }
sub infix__S_366BangEqual {
my $self = shift;
local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;
my %args = @_;
local $sym = $args{sym} // q(!=);


my $C = $self;
my $S = $C->{'_pos'};
$C->{'sym'} = $sym;

$self->_MATCHIFYr($S, "infix__S_366BangEqual",  map { STD::Chaining->coerce($_) } 
do {
if (my ($C) = ($C->_PATTERN(qr/\G\!\=/))) {
$C->before(sub { my $C=shift;
$C->_PATTERN(qr/\G\s/)
});
}
else {
();
}
}
);
}

## token infix__S_367Lt (  :$sym is context<rw> = « < » --> Chaining)
##      token infix:sym« < » ( --> Chaining)
##          { <sym> }

sub infix__S_367Lt__PEEK { $_[0]->_AUTOLEXpeek('infix__S_367Lt',$retree) }
sub infix__S_367Lt {
my $self = shift;
local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;
my %args = @_;
local $sym = $args{sym} //['<'];


my $C = $self;
my $S = $C->{'_pos'};
$C->{'sym'} = $sym;

$self->_MATCHIFYr($S, "infix__S_367Lt",  map { STD::Chaining->coerce($_) } 
$C->_PATTERN(qr/\G\</)
);
}

## token infix__S_368LtEqual (  :$sym is context<rw> = « <= » --> Chaining)
##      token infix:sym« <= » ( --> Chaining)
##          { <sym> }

sub infix__S_368LtEqual__PEEK { $_[0]->_AUTOLEXpeek('infix__S_368LtEqual',$retree) }
sub infix__S_368LtEqual {
my $self = shift;
local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;
my %args = @_;
local $sym = $args{sym} //['<='];


my $C = $self;
my $S = $C->{'_pos'};
$C->{'sym'} = $sym;

$self->_MATCHIFYr($S, "infix__S_368LtEqual",  map { STD::Chaining->coerce($_) } 
$C->_PATTERN(qr/\G\<\=/)
);
}

## token infix__S_369Gt (  :$sym is context<rw> = « > » --> Chaining)
##      token infix:sym« > » ( --> Chaining)
##          { <sym> }

sub infix__S_369Gt__PEEK { $_[0]->_AUTOLEXpeek('infix__S_369Gt',$retree) }
sub infix__S_369Gt {
my $self = shift;
local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;
my %args = @_;
local $sym = $args{sym} //['>'];


my $C = $self;
my $S = $C->{'_pos'};
$C->{'sym'} = $sym;

$self->_MATCHIFYr($S, "infix__S_369Gt",  map { STD::Chaining->coerce($_) } 
$C->_PATTERN(qr/\G\>/)
);
}

## token infix__S_370GtEqual (  :$sym is context<rw> = « >= » --> Chaining)
##      token infix:sym« >= » ( --> Chaining)
##          { <sym> }

sub infix__S_370GtEqual__PEEK { $_[0]->_AUTOLEXpeek('infix__S_370GtEqual',$retree) }
sub infix__S_370GtEqual {
my $self = shift;
local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;
my %args = @_;
local $sym = $args{sym} //['>='];


my $C = $self;
my $S = $C->{'_pos'};
$C->{'sym'} = $sym;

$self->_MATCHIFYr($S, "infix__S_370GtEqual",  map { STD::Chaining->coerce($_) } 
$C->_PATTERN(qr/\G\>\=/)
);
}

## token infix__S_371TildeTilde (  :$sym is context<rw> = <~~> --> Chaining)
##      token infix:sym<~~> ( --> Chaining)
##          { <sym> }

sub infix__S_371TildeTilde__PEEK { $_[0]->_AUTOLEXpeek('infix__S_371TildeTilde',$retree) }
sub infix__S_371TildeTilde {
my $self = shift;
local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;
my %args = @_;
local $sym = $args{sym} // q(~~);


my $C = $self;
my $S = $C->{'_pos'};
$C->{'sym'} = $sym;

$self->_MATCHIFYr($S, "infix__S_371TildeTilde",  map { STD::Chaining->coerce($_) } 
$C->_PATTERN(qr/\G\~\~/)
);
}

# XXX should move to inside meta !
## token infix__S_372BangTilde (  :$sym is context<rw> = <!~> --> Chaining)
##      token infix:sym<!~> ( --> Chaining)
##          { <sym> \s <.obs('!~ to do negated pattern matching', '!~~')> }

sub infix__S_372BangTilde__PEEK { $_[0]->_AUTOLEXpeek('infix__S_372BangTilde',$retree) }
sub infix__S_372BangTilde {
my $self = shift;
local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;
my %args = @_;
local $sym = $args{sym} // q(!~);


my $C = $self;
my $S = $C->{'_pos'};
$C->{'sym'} = $sym;

$self->_MATCHIFYr($S, "infix__S_372BangTilde",  map { STD::Chaining->coerce($_) } 
do {
if (my ($C) = ($C->_PATTERN(qr/\G\!\~/))) {
do {
if (my ($C) = ($C->_PATTERN(qr/\G\s/))) {
$C->obs('!~ to do negated pattern matching', '!~~');
}
else {
();
}
};
}
else {
();
}
}
);
}

## token infix__S_373EqualTilde (  :$sym is context<rw> = <=~> --> Chaining)
##      token infix:sym<=~> ( --> Chaining)
##          { <sym> <.obs('=~ to do pattern matching', '~~')> }

sub infix__S_373EqualTilde__PEEK { $_[0]->_AUTOLEXpeek('infix__S_373EqualTilde',$retree) }
sub infix__S_373EqualTilde {
my $self = shift;
local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;
my %args = @_;
local $sym = $args{sym} // q(=~);


my $C = $self;
my $S = $C->{'_pos'};
$C->{'sym'} = $sym;

$self->_MATCHIFYr($S, "infix__S_373EqualTilde",  map { STD::Chaining->coerce($_) } 
do {
if (my ($C) = ($C->_PATTERN(qr/\G\=\~/))) {
$C->obs('=~ to do pattern matching', '~~');
}
else {
();
}
}
);
}

## token infix__S_374eq (  :$sym is context<rw> = <eq> --> Chaining)
##      token infix:sym<eq> ( --> Chaining)
##          { <sym> }

sub infix__S_374eq__PEEK { $_[0]->_AUTOLEXpeek('infix__S_374eq',$retree) }
sub infix__S_374eq {
my $self = shift;
local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;
my %args = @_;
local $sym = $args{sym} // q(eq);


my $C = $self;
my $S = $C->{'_pos'};
$C->{'sym'} = $sym;

$self->_MATCHIFYr($S, "infix__S_374eq",  map { STD::Chaining->coerce($_) } 
$C->_PATTERN(qr/\Geq/)
);
}

## token infix__S_375ne (  :$sym is context<rw> = <ne> --> Chaining)
##      token infix:sym<ne> ( --> Chaining)
##          { <sym> }

sub infix__S_375ne__PEEK { $_[0]->_AUTOLEXpeek('infix__S_375ne',$retree) }
sub infix__S_375ne {
my $self = shift;
local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;
my %args = @_;
local $sym = $args{sym} // q(ne);


my $C = $self;
my $S = $C->{'_pos'};
$C->{'sym'} = $sym;

$self->_MATCHIFYr($S, "infix__S_375ne",  map { STD::Chaining->coerce($_) } 
$C->_PATTERN(qr/\Gne/)
);
}

## token infix__S_376lt (  :$sym is context<rw> = <lt> --> Chaining)
##      token infix:sym<lt> ( --> Chaining)
##          { <sym> }

sub infix__S_376lt__PEEK { $_[0]->_AUTOLEXpeek('infix__S_376lt',$retree) }
sub infix__S_376lt {
my $self = shift;
local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;
my %args = @_;
local $sym = $args{sym} // q(lt);


my $C = $self;
my $S = $C->{'_pos'};
$C->{'sym'} = $sym;

$self->_MATCHIFYr($S, "infix__S_376lt",  map { STD::Chaining->coerce($_) } 
$C->_PATTERN(qr/\Glt/)
);
}

## token infix__S_377le (  :$sym is context<rw> = <le> --> Chaining)
##      token infix:sym<le> ( --> Chaining)
##          { <sym> }

sub infix__S_377le__PEEK { $_[0]->_AUTOLEXpeek('infix__S_377le',$retree) }
sub infix__S_377le {
my $self = shift;
local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;
my %args = @_;
local $sym = $args{sym} // q(le);


my $C = $self;
my $S = $C->{'_pos'};
$C->{'sym'} = $sym;

$self->_MATCHIFYr($S, "infix__S_377le",  map { STD::Chaining->coerce($_) } 
$C->_PATTERN(qr/\Gle/)
);
}

## token infix__S_378gt (  :$sym is context<rw> = <gt> --> Chaining)
##      token infix:sym<gt> ( --> Chaining)
##          { <sym> }

sub infix__S_378gt__PEEK { $_[0]->_AUTOLEXpeek('infix__S_378gt',$retree) }
sub infix__S_378gt {
my $self = shift;
local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;
my %args = @_;
local $sym = $args{sym} // q(gt);


my $C = $self;
my $S = $C->{'_pos'};
$C->{'sym'} = $sym;

$self->_MATCHIFYr($S, "infix__S_378gt",  map { STD::Chaining->coerce($_) } 
$C->_PATTERN(qr/\Ggt/)
);
}

## token infix__S_379ge (  :$sym is context<rw> = <ge> --> Chaining)
##      token infix:sym<ge> ( --> Chaining)
##          { <sym> }

sub infix__S_379ge__PEEK { $_[0]->_AUTOLEXpeek('infix__S_379ge',$retree) }
sub infix__S_379ge {
my $self = shift;
local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;
my %args = @_;
local $sym = $args{sym} // q(ge);


my $C = $self;
my $S = $C->{'_pos'};
$C->{'sym'} = $sym;

$self->_MATCHIFYr($S, "infix__S_379ge",  map { STD::Chaining->coerce($_) } 
$C->_PATTERN(qr/\Gge/)
);
}

## token infix__S_380EqualColonEqual (  :$sym is context<rw> = <=:=> --> Chaining)
##      token infix:sym<=:=> ( --> Chaining)
##          { <sym> }

sub infix__S_380EqualColonEqual__PEEK { $_[0]->_AUTOLEXpeek('infix__S_380EqualColonEqual',$retree) }
sub infix__S_380EqualColonEqual {
my $self = shift;
local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;
my %args = @_;
local $sym = $args{sym} // q(=:=);


my $C = $self;
my $S = $C->{'_pos'};
$C->{'sym'} = $sym;

$self->_MATCHIFYr($S, "infix__S_380EqualColonEqual",  map { STD::Chaining->coerce($_) } 
$C->_PATTERN(qr/\G\=\:\=/)
);
}

## token infix__S_381EqualEqualEqual (  :$sym is context<rw> = <===> --> Chaining)
##      token infix:sym<===> ( --> Chaining)
##          { <sym> }

sub infix__S_381EqualEqualEqual__PEEK { $_[0]->_AUTOLEXpeek('infix__S_381EqualEqualEqual',$retree) }
sub infix__S_381EqualEqualEqual {
my $self = shift;
local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;
my %args = @_;
local $sym = $args{sym} // q(===);


my $C = $self;
my $S = $C->{'_pos'};
$C->{'sym'} = $sym;

$self->_MATCHIFYr($S, "infix__S_381EqualEqualEqual",  map { STD::Chaining->coerce($_) } 
$C->_PATTERN(qr/\G\=\=\=/)
);
}

## token infix__S_382eqv (  :$sym is context<rw> = <eqv> --> Chaining)
##      token infix:sym<eqv> ( --> Chaining)
##          { <sym> }

sub infix__S_382eqv__PEEK { $_[0]->_AUTOLEXpeek('infix__S_382eqv',$retree) }
sub infix__S_382eqv {
my $self = shift;
local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;
my %args = @_;
local $sym = $args{sym} // q(eqv);


my $C = $self;
my $S = $C->{'_pos'};
$C->{'sym'} = $sym;

$self->_MATCHIFYr($S, "infix__S_382eqv",  map { STD::Chaining->coerce($_) } 
$C->_PATTERN(qr/\Geqv/)
);
}

## token infix__S_383before (  :$sym is context<rw> = <before> --> Chaining)
##      token infix:sym<before> ( --> Chaining)
##          { <sym> }

sub infix__S_383before__PEEK { $_[0]->_AUTOLEXpeek('infix__S_383before',$retree) }
sub infix__S_383before {
my $self = shift;
local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;
my %args = @_;
local $sym = $args{sym} // q(before);


my $C = $self;
my $S = $C->{'_pos'};
$C->{'sym'} = $sym;

$self->_MATCHIFYr($S, "infix__S_383before",  map { STD::Chaining->coerce($_) } 
$C->_PATTERN(qr/\Gbefore/)
);
}

## token infix__S_384after (  :$sym is context<rw> = <after> --> Chaining)
##      token infix:sym<after> ( --> Chaining)
##          { <sym> }

sub infix__S_384after__PEEK { $_[0]->_AUTOLEXpeek('infix__S_384after',$retree) }
sub infix__S_384after {
my $self = shift;
local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;
my %args = @_;
local $sym = $args{sym} // q(after);


my $C = $self;
my $S = $C->{'_pos'};
$C->{'sym'} = $sym;

$self->_MATCHIFYr($S, "infix__S_384after",  map { STD::Chaining->coerce($_) } 
$C->_PATTERN(qr/\Gafter/)
);
}


## tight and
## token infix__S_385AmpAmp (  :$sym is context<rw> = <&&> --> Tight_and)
##      token infix:sym<&&> ( --> Tight_and)
##          { <sym> }

sub infix__S_385AmpAmp__PEEK { $_[0]->_AUTOLEXpeek('infix__S_385AmpAmp',$retree) }
sub infix__S_385AmpAmp {
my $self = shift;
local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;
my %args = @_;
local $sym = $args{sym} // q(&&);


my $C = $self;
my $S = $C->{'_pos'};
$C->{'sym'} = $sym;

$self->_MATCHIFYr($S, "infix__S_385AmpAmp",  map { STD::Tight_and->coerce($_) } 
$C->_PATTERN(qr/\G\&\&/)
);
}


## tight or
## token infix__S_386VertVert (  :$sym is context<rw> = <||> --> Tight_or)
##      token infix:sym<||> ( --> Tight_or)
##          { <sym> }

sub infix__S_386VertVert__PEEK { $_[0]->_AUTOLEXpeek('infix__S_386VertVert',$retree) }
sub infix__S_386VertVert {
my $self = shift;
local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;
my %args = @_;
local $sym = $args{sym} // q(||);


my $C = $self;
my $S = $C->{'_pos'};
$C->{'sym'} = $sym;

$self->_MATCHIFYr($S, "infix__S_386VertVert",  map { STD::Tight_or->coerce($_) } 
$C->_PATTERN(qr/\G\|\|/)
);
}

## token infix__S_387CaretCaret (  :$sym is context<rw> = <^^> --> Tight_or)
##      token infix:sym<^^> ( --> Tight_or)
##          { <sym> }

sub infix__S_387CaretCaret__PEEK { $_[0]->_AUTOLEXpeek('infix__S_387CaretCaret',$retree) }
sub infix__S_387CaretCaret {
my $self = shift;
local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;
my %args = @_;
local $sym = $args{sym} // q(^^);


my $C = $self;
my $S = $C->{'_pos'};
$C->{'sym'} = $sym;

$self->_MATCHIFYr($S, "infix__S_387CaretCaret",  map { STD::Tight_or->coerce($_) } 
$C->_PATTERN(qr/\G\^\^/)
);
}

## token infix__S_388SlashSlash (  :$sym is context<rw> = <//> --> Tight_or)
##      token infix:sym<//> ( --> Tight_or)
##          { <sym> }

sub infix__S_388SlashSlash__PEEK { $_[0]->_AUTOLEXpeek('infix__S_388SlashSlash',$retree) }
sub infix__S_388SlashSlash {
my $self = shift;
local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;
my %args = @_;
local $sym = $args{sym} // q(//);


my $C = $self;
my $S = $C->{'_pos'};
$C->{'sym'} = $sym;

$self->_MATCHIFYr($S, "infix__S_388SlashSlash",  map { STD::Tight_or->coerce($_) } 
$C->_PATTERN(qr/\G\/\//)
);
}

## token infix__S_389min (  :$sym is context<rw> = <min> --> Tight_or)
##      token infix:sym<min> ( --> Tight_or)
##          { <sym> }

sub infix__S_389min__PEEK { $_[0]->_AUTOLEXpeek('infix__S_389min',$retree) }
sub infix__S_389min {
my $self = shift;
local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;
my %args = @_;
local $sym = $args{sym} // q(min);


my $C = $self;
my $S = $C->{'_pos'};
$C->{'sym'} = $sym;

$self->_MATCHIFYr($S, "infix__S_389min",  map { STD::Tight_or->coerce($_) } 
$C->_PATTERN(qr/\Gmin/)
);
}

## token infix__S_390max (  :$sym is context<rw> = <max> --> Tight_or)
##      token infix:sym<max> ( --> Tight_or)
##          { <sym> }

sub infix__S_390max__PEEK { $_[0]->_AUTOLEXpeek('infix__S_390max',$retree) }
sub infix__S_390max {
my $self = shift;
local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;
my %args = @_;
local $sym = $args{sym} // q(max);


my $C = $self;
my $S = $C->{'_pos'};
$C->{'sym'} = $sym;

$self->_MATCHIFYr($S, "infix__S_390max",  map { STD::Tight_or->coerce($_) } 
$C->_PATTERN(qr/\Gmax/)
);
}


## conditional
## token infix__S_391QuestionQuestion_BangBang (  :$sym is context<rw> = <?? !!> --> Conditional)
##      token infix:sym<?? !!> ( --> Conditional) {
##          :my $GOAL is context = '!!';
##          '??'
##          <.ws>
##          <EXPR(item %item_assignment)>
##          [ '!!' ||
##              [
##              || <?before '='> <.panic: "Assignment not allowed within ??!!">
##              || <?before '::'> <.panic: "Please use !! rather than ::">
##              || <?before <infixish>>    # Note: a tight infix would have parsed right
##                  <.panic: "Precedence too loose within ??!!; use ??()!! instead ">
##              || <.panic: "Found ?? but no !!; possible precedence problem">
##              ]
##          ]
##      }

sub infix__S_391QuestionQuestion_BangBang__PEEK { $_[0]->_AUTOLEXpeek('infix__S_391QuestionQuestion_BangBang',$retree) }
sub infix__S_391QuestionQuestion_BangBang {
my $self = shift;
local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;
my %args = @_;
local $sym = $args{sym} // [qw(?? !!)];
local $::GOAL = '!!';


my $C = $self;
my $S = $C->{'_pos'};
$C->{'sym'} = $sym;

$self->_MATCHIFYr($S, "infix__S_391QuestionQuestion_BangBang",  map { STD::Conditional->coerce($_) } 
do {
if (my ($C) = ($C->_EXACT('??'))) {
do {
if (my ($C) = ($C->ws)) {
do {
if (my ($C) = ($C->_SUBSUMEr(['EXPR'], sub {
my $C = shift;
$C->EXPR(\%item_assignment)
}))) {
$C->_BRACKETr( sub { my $C=shift;
do { my @gather;
eval { push @gather, $C->_EXACT('!!')} // do {die $@ if $@ and $@ !~ /ABORT/;1} 
or
eval { push @gather, $C->_BRACKETr( sub { my $C=shift;
do { my @gather;
eval { push @gather, do {
if (my ($C) = ($C->before(sub { my $C=shift;
$C->_EXACT('=')
}))) {
$C->panic("Assignment not allowed within ??!!");
}
else {
();
}
}} // do {die $@ if $@ and $@ !~ /ABORT/;1} 
or
eval { push @gather, do {
if (my ($C) = ($C->before(sub { my $C=shift;
$C->_EXACT('::')
}))) {
$C->panic("Please use !! rather than ::");
}
else {
();
}
}} // do {die $@ if $@ and $@ !~ /ABORT/;1} 
or
eval { push @gather, do {
if (my ($C) = ($C->before(sub { my $C=shift;
$C->_SUBSUMEr(['infixish'], sub {
my $C = shift;
$C->infixish
})
}))) {
$C->panic("Precedence too loose within ??!!; use ??()!! instead ");
}
else {
();
}
}} // do {die $@ if $@ and $@ !~ /ABORT/;1} 
or
eval { push @gather, $C->panic("Found ?? but no !!; possible precedence problem")} or do { die $@ if $@ };
@gather;
}
})} or do { die $@ if $@ };
@gather;
}
});
}
else {
();
}
};
}
else {
();
}
};
}
else {
();
}
}
);
}

## token infix__S_392Question (  :$sym is context<rw> = <?> --> Conditional)
##      token infix:sym<?> ( --> Conditional)
##          { <sym> <.obs('?: for the conditional operator', '??!!')> }

sub infix__S_392Question__PEEK { $_[0]->_AUTOLEXpeek('infix__S_392Question',$retree) }
sub infix__S_392Question {
my $self = shift;
local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;
my %args = @_;
local $sym = $args{sym} // q(?);


my $C = $self;
my $S = $C->{'_pos'};
$C->{'sym'} = $sym;

$self->_MATCHIFYr($S, "infix__S_392Question",  map { STD::Conditional->coerce($_) } 
do {
if (my ($C) = ($C->_PATTERN(qr/\G\?/))) {
$C->obs('?: for the conditional operator', '??!!');
}
else {
();
}
}
);
}

## token infix__S_393ff (  :$sym is context<rw> = <ff> --> Conditional)
##      token infix:sym<ff> ( --> Conditional)
##          { <sym> }

sub infix__S_393ff__PEEK { $_[0]->_AUTOLEXpeek('infix__S_393ff',$retree) }
sub infix__S_393ff {
my $self = shift;
local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;
my %args = @_;
local $sym = $args{sym} // q(ff);


my $C = $self;
my $S = $C->{'_pos'};
$C->{'sym'} = $sym;

$self->_MATCHIFYr($S, "infix__S_393ff",  map { STD::Conditional->coerce($_) } 
$C->_PATTERN(qr/\Gff/)
);
}

## token infix__S_394Caretff (  :$sym is context<rw> = <^ff> --> Conditional)
##      token infix:sym<^ff> ( --> Conditional)
##          { <sym> }

sub infix__S_394Caretff__PEEK { $_[0]->_AUTOLEXpeek('infix__S_394Caretff',$retree) }
sub infix__S_394Caretff {
my $self = shift;
local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;
my %args = @_;
local $sym = $args{sym} // q(^ff);


my $C = $self;
my $S = $C->{'_pos'};
$C->{'sym'} = $sym;

$self->_MATCHIFYr($S, "infix__S_394Caretff",  map { STD::Conditional->coerce($_) } 
$C->_PATTERN(qr/\G\^ff/)
);
}

## token infix__S_395ffCaret (  :$sym is context<rw> = <ff^> --> Conditional)
##      token infix:sym<ff^> ( --> Conditional)
##          { <sym> }

sub infix__S_395ffCaret__PEEK { $_[0]->_AUTOLEXpeek('infix__S_395ffCaret',$retree) }
sub infix__S_395ffCaret {
my $self = shift;
local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;
my %args = @_;
local $sym = $args{sym} // q(ff^);


my $C = $self;
my $S = $C->{'_pos'};
$C->{'sym'} = $sym;

$self->_MATCHIFYr($S, "infix__S_395ffCaret",  map { STD::Conditional->coerce($_) } 
$C->_PATTERN(qr/\Gff\^/)
);
}

## token infix__S_396CaretffCaret (  :$sym is context<rw> = <^ff^> --> Conditional)
##      token infix:sym<^ff^> ( --> Conditional)
##          { <sym> }

sub infix__S_396CaretffCaret__PEEK { $_[0]->_AUTOLEXpeek('infix__S_396CaretffCaret',$retree) }
sub infix__S_396CaretffCaret {
my $self = shift;
local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;
my %args = @_;
local $sym = $args{sym} // q(^ff^);


my $C = $self;
my $S = $C->{'_pos'};
$C->{'sym'} = $sym;

$self->_MATCHIFYr($S, "infix__S_396CaretffCaret",  map { STD::Conditional->coerce($_) } 
$C->_PATTERN(qr/\G\^ff\^/)
);
}

## token infix__S_397fff (  :$sym is context<rw> = <fff> --> Conditional)
##      token infix:sym<fff> ( --> Conditional)
##          { <sym> }

sub infix__S_397fff__PEEK { $_[0]->_AUTOLEXpeek('infix__S_397fff',$retree) }
sub infix__S_397fff {
my $self = shift;
local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;
my %args = @_;
local $sym = $args{sym} // q(fff);


my $C = $self;
my $S = $C->{'_pos'};
$C->{'sym'} = $sym;

$self->_MATCHIFYr($S, "infix__S_397fff",  map { STD::Conditional->coerce($_) } 
$C->_PATTERN(qr/\Gfff/)
);
}

## token infix__S_398Caretfff (  :$sym is context<rw> = <^fff> --> Conditional)
##      token infix:sym<^fff> ( --> Conditional)
##          { <sym> }

sub infix__S_398Caretfff__PEEK { $_[0]->_AUTOLEXpeek('infix__S_398Caretfff',$retree) }
sub infix__S_398Caretfff {
my $self = shift;
local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;
my %args = @_;
local $sym = $args{sym} // q(^fff);


my $C = $self;
my $S = $C->{'_pos'};
$C->{'sym'} = $sym;

$self->_MATCHIFYr($S, "infix__S_398Caretfff",  map { STD::Conditional->coerce($_) } 
$C->_PATTERN(qr/\G\^fff/)
);
}

## token infix__S_399fffCaret (  :$sym is context<rw> = <fff^> --> Conditional)
##      token infix:sym<fff^> ( --> Conditional)
##          { <sym> }

sub infix__S_399fffCaret__PEEK { $_[0]->_AUTOLEXpeek('infix__S_399fffCaret',$retree) }
sub infix__S_399fffCaret {
my $self = shift;
local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;
my %args = @_;
local $sym = $args{sym} // q(fff^);


my $C = $self;
my $S = $C->{'_pos'};
$C->{'sym'} = $sym;

$self->_MATCHIFYr($S, "infix__S_399fffCaret",  map { STD::Conditional->coerce($_) } 
$C->_PATTERN(qr/\Gfff\^/)
);
}

## token infix__S_400CaretfffCaret (  :$sym is context<rw> = <^fff^> --> Conditional)
##      token infix:sym<^fff^> ( --> Conditional)
##          { <sym> }

sub infix__S_400CaretfffCaret__PEEK { $_[0]->_AUTOLEXpeek('infix__S_400CaretfffCaret',$retree) }
sub infix__S_400CaretfffCaret {
my $self = shift;
local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;
my %args = @_;
local $sym = $args{sym} // q(^fff^);


my $C = $self;
my $S = $C->{'_pos'};
$C->{'sym'} = $sym;

$self->_MATCHIFYr($S, "infix__S_400CaretfffCaret",  map { STD::Conditional->coerce($_) } 
$C->_PATTERN(qr/\G\^fff\^/)
);
}

## assignment
# There is no "--> type" because assignment may be coerced to either
# item assignment or list assignment at "make" time.

## token infix__S_401Equal (:$sym is context<rw> = <=>)
##      token infix:sym<=> ()
##      {
##          <sym>
##          { $¢ = $*LEFTSIGIL eq '$' 
##              ?? ::Item_assignment.coerce($¢)
##              !! ::List_assignment.coerce($¢);
##          }
##      }

sub infix__S_401Equal__PEEK { $_[0]->_AUTOLEXpeek('infix__S_401Equal',$retree) }
sub infix__S_401Equal {
my $self = shift;
local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;
my %args = @_;
local $sym = $args{sym} // q(=);


my $C = $self;
my $S = $C->{'_pos'};
$C->{'sym'} = $sym;

$self->_MATCHIFYr($S, "infix__S_401Equal", 
do {
if (my ($C) = ($C->_PATTERN(qr/\G\=/))) {
scalar(do {
$C = $::LEFTSIGIL eq '$' 
? 'STD::Item_assignment'->coerce($C)
: 'STD::List_assignment'->coerce($C);

}, $C);
}
else {
();
}
}
);
}

## token infix__S_402ColonEqual (  :$sym is context<rw> = <:=> --> Item_assignment)
##      token infix:sym<:=> ( --> Item_assignment)
##          { <sym> }

sub infix__S_402ColonEqual__PEEK { $_[0]->_AUTOLEXpeek('infix__S_402ColonEqual',$retree) }
sub infix__S_402ColonEqual {
my $self = shift;
local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;
my %args = @_;
local $sym = $args{sym} // q(:=);


my $C = $self;
my $S = $C->{'_pos'};
$C->{'sym'} = $sym;

$self->_MATCHIFYr($S, "infix__S_402ColonEqual",  map { STD::Item_assignment->coerce($_) } 
$C->_PATTERN(qr/\G\:\=/)
);
}

## token infix__S_403ColonColonEqual (  :$sym is context<rw> = <::=> --> Item_assignment)
##      token infix:sym<::=> ( --> Item_assignment)
##          { <sym> }

sub infix__S_403ColonColonEqual__PEEK { $_[0]->_AUTOLEXpeek('infix__S_403ColonColonEqual',$retree) }
sub infix__S_403ColonColonEqual {
my $self = shift;
local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;
my %args = @_;
local $sym = $args{sym} // q(::=);


my $C = $self;
my $S = $C->{'_pos'};
$C->{'sym'} = $sym;

$self->_MATCHIFYr($S, "infix__S_403ColonColonEqual",  map { STD::Item_assignment->coerce($_) } 
$C->_PATTERN(qr/\G\:\:\=/)
);
}

## token infix__S_404DotEqual (  :$sym is context<rw> = <.=> --> Item_assignment)
##      token infix:sym<.=> ( --> Item_assignment) {
##          <sym> <.ws>
##          [ <?before \w+';' | 'new'|'sort'|'subst'|'trans'|'reverse'|'uniq'|'map'|'samecase'|'substr'|'flip'|'fmt' > || <worryobs('.= as append operator', '~=')> ]
##          { $<O><nextterm> = 'dottyopish' }
##      }

sub infix__S_404DotEqual__PEEK { $_[0]->_AUTOLEXpeek('infix__S_404DotEqual',$retree) }
sub infix__S_404DotEqual {
my $self = shift;
local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;
my %args = @_;
local $sym = $args{sym} // q(.=);


my $C = $self;
my $S = $C->{'_pos'};
$C->{'sym'} = $sym;

$self->_MATCHIFYr($S, "infix__S_404DotEqual",  map { STD::Item_assignment->coerce($_) } 
do {
if (my ($C) = ($C->_PATTERN(qr/\G\.\=/))) {
do {
if (my ($C) = ($C->ws)) {
do {
if (my ($C) = ($C->_BRACKETr( sub { my $C=shift;
do { my @gather;
eval { push @gather, $C->before(sub { my $C=shift;
do {
my @result = eval {
my $trystate;
my ($tag, $try);
my @try;
my $relex;

my $fate;
if ($fate = $C->{'_fate'} and $fate->[1] eq 'infix__S_404DotEqual_02') {
$C->deb("Fate passed to infix__S_404DotEqual_02: ", ::fatestr($fate)) if $::DEBUG & DEBUG::fates;
($C->{'_fate'}, $tag, $try) = @$fate;
@try = ($try);
}

my @gather = ();
for (;;) {
if (not @try) {
$relex //= $C->cursor_fate('STD', 'infix__S_404DotEqual_02', $retree);
@try = $relex->($C, $trystate);
}
last unless @try;
$try = shift(@try) // next;

if (ref $try eq 'ARRAY') {
($C->{'_fate'}, $tag, $try) = @$try;	# next candidate fate
}

$C->deb("infix__S_404DotEqual_02 trying $tag $try") if $::DEBUG & DEBUG::try_processing;
push @gather, ((
sub { my $C=shift;
do {
if (my ($C) = ($C->_PATTERN(qr/\G((?:\w)++)/))) {
$C->_EXACT(';');
}
else {
();
}
}
},
sub { my $C=shift;
$C->_EXACT('new')
},
sub { my $C=shift;
$C->_EXACT('sort')
},
sub { my $C=shift;
$C->_EXACT('subst')
},
sub { my $C=shift;
$C->_EXACT('trans')
},
sub { my $C=shift;
$C->_EXACT('reverse')
},
sub { my $C=shift;
$C->_EXACT('uniq')
},
sub { my $C=shift;
$C->_EXACT('map')
},
sub { my $C=shift;
$C->_EXACT('samecase')
},
sub { my $C=shift;
$C->_EXACT('substr')
},
sub { my $C=shift;
$C->_EXACT('flip')
},
sub { my $C=shift;
$C->_EXACT('fmt')
},
)[$try])->($C);
last if @gather;
}
@gather;
};
if (@result) {
@result;
}
elsif ($@) {
my ($first) = $@ =~ /(^.*)/;
$self->deb("CAUGHT $first") if $::DEBUG & DEBUG::trace_call;
die $@ if $@ !~ /^ABORTBRANCH/;
();
}
else {
();
}
}

})} // do {die $@ if $@ and $@ !~ /ABORT/;1} 
or
eval { push @gather, $C->_SUBSUMEr(['worryobs'], sub {
my $C = shift;
$C->worryobs('.= as append operator', '~=')
})} or do { die $@ if $@ };
@gather;
}
}))) {
scalar(do {
my $M = $C;  $M->{'O'}{'nextterm'} = 'dottyopish' ;
}, $C);
}
else {
();
}
};
}
else {
();
}
};
}
else {
();
}
}
);
}

## token infix__S_405EqualGt (  :$sym is context<rw> = « => » --> Item_assignment)
##      token infix:sym« => » ( --> Item_assignment)
##          { <sym> { $<O><fiddly> = 0; } }

sub infix__S_405EqualGt__PEEK { $_[0]->_AUTOLEXpeek('infix__S_405EqualGt',$retree) }
sub infix__S_405EqualGt {
my $self = shift;
local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;
my %args = @_;
local $sym = $args{sym} //['=>'];


my $C = $self;
my $S = $C->{'_pos'};
$C->{'sym'} = $sym;

$self->_MATCHIFYr($S, "infix__S_405EqualGt",  map { STD::Item_assignment->coerce($_) } 
do {
if (my ($C) = ($C->_PATTERN(qr/\G\=\>/))) {
scalar(do {
my $M = $C;  $M->{'O'}{'fiddly'} = 0; ;
}, $C);
}
else {
();
}
}
);
}

# Note, other assignment ops generated by infix_postfix_meta_operator rule

## loose unary
## token prefix__S_406true (  :$sym is context<rw> = <true> --> Loose_unary)
##      token prefix:sym<true> ( --> Loose_unary)
##          { <sym> » }

sub prefix__S_406true__PEEK { $_[0]->_AUTOLEXpeek('prefix__S_406true',$retree) }
sub prefix__S_406true {
my $self = shift;
local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;
my %args = @_;
local $sym = $args{sym} // q(true);


my $C = $self;
my $S = $C->{'_pos'};
$C->{'sym'} = $sym;

$self->_MATCHIFYr($S, "prefix__S_406true",  map { STD::Loose_unary->coerce($_) } 
$C->_PATTERN(qr/\Gtrue\b/)
);
}

## token prefix__S_407not (  :$sym is context<rw> = <not> --> Loose_unary)
##      token prefix:sym<not> ( --> Loose_unary)
##          { <sym> » }

sub prefix__S_407not__PEEK { $_[0]->_AUTOLEXpeek('prefix__S_407not',$retree) }
sub prefix__S_407not {
my $self = shift;
local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;
my %args = @_;
local $sym = $args{sym} // q(not);


my $C = $self;
my $S = $C->{'_pos'};
$C->{'sym'} = $sym;

$self->_MATCHIFYr($S, "prefix__S_407not",  map { STD::Loose_unary->coerce($_) } 
$C->_PATTERN(qr/\Gnot\b/)
);
}

## list item separator
## token infix__S_408Comma (  :$sym is context<rw> = <,> --> Comma)
##      token infix:sym<,> ( --> Comma)
##          { <sym> { $<O><fiddly> = 0; } }

sub infix__S_408Comma__PEEK { $_[0]->_AUTOLEXpeek('infix__S_408Comma',$retree) }
sub infix__S_408Comma {
my $self = shift;
local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;
my %args = @_;
local $sym = $args{sym} // q[,];


my $C = $self;
my $S = $C->{'_pos'};
$C->{'sym'} = $sym;

$self->_MATCHIFYr($S, "infix__S_408Comma",  map { STD::Comma->coerce($_) } 
do {
if (my ($C) = ($C->_PATTERN(qr/\G\,/))) {
scalar(do {
my $M = $C;  $M->{'O'}{'fiddly'} = 0; ;
}, $C);
}
else {
();
}
}
);
}

## token infix__S_409Colon (  :$sym is context<rw> = <:> --> Comma)
##      token infix:sym<:> ( --> Comma)
##          { <sym> <?before \s | <terminator> >
##              { $¢.panic("Illegal use of colon as invocant marker") unless $*INVOCANT_OK--; }
##          }

sub infix__S_409Colon__PEEK { $_[0]->_AUTOLEXpeek('infix__S_409Colon',$retree) }
sub infix__S_409Colon {
my $self = shift;
local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;
my %args = @_;
local $sym = $args{sym} // q(:);


my $C = $self;
my $S = $C->{'_pos'};
$C->{'sym'} = $sym;

$self->_MATCHIFYr($S, "infix__S_409Colon",  map { STD::Comma->coerce($_) } 
do {
if (my ($C) = ($C->_PATTERN(qr/\G\:/))) {
do {
if (my ($C) = ($C->before(sub { my $C=shift;
do {
my @result = eval {
my $trystate;
my ($tag, $try);
my @try;
my $relex;

my $fate;
if ($fate = $C->{'_fate'} and $fate->[1] eq 'infix__S_409Colon_01') {
$C->deb("Fate passed to infix__S_409Colon_01: ", ::fatestr($fate)) if $::DEBUG & DEBUG::fates;
($C->{'_fate'}, $tag, $try) = @$fate;
@try = ($try);
}

my @gather = ();
for (;;) {
if (not @try) {
$relex //= $C->cursor_fate('STD', 'infix__S_409Colon_01', $retree);
@try = $relex->($C, $trystate);
}
last unless @try;
$try = shift(@try) // next;

if (ref $try eq 'ARRAY') {
($C->{'_fate'}, $tag, $try) = @$try;	# next candidate fate
}

$C->deb("infix__S_409Colon_01 trying $tag $try") if $::DEBUG & DEBUG::try_processing;
push @gather, ((
sub { my $C=shift;
$C->_PATTERN(qr/\G\s/)
},
sub { my $C=shift;
$C->_SUBSUMEr(['terminator'], sub {
my $C = shift;
$C->terminator
})
},
)[$try])->($C);
last if @gather;
}
@gather;
};
if (@result) {
@result;
}
elsif ($@) {
my ($first) = $@ =~ /(^.*)/;
$self->deb("CAUGHT $first") if $::DEBUG & DEBUG::trace_call;
die $@ if $@ !~ /^ABORTBRANCH/;
();
}
else {
();
}
}

}))) {
scalar(do {
$C->panic("Illegal use of colon as invocant marker") unless $::INVOCANT_OK--; 
}, $C);
}
else {
();
}
};
}
else {
();
}
}
);
}

## token infix__S_410p5EqualGt (  :$sym is context<rw> = « p5=> » --> Comma)
##      token infix:sym« p5=> » ( --> Comma)
##          { <sym> }

sub infix__S_410p5EqualGt__PEEK { $_[0]->_AUTOLEXpeek('infix__S_410p5EqualGt',$retree) }
sub infix__S_410p5EqualGt {
my $self = shift;
local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;
my %args = @_;
local $sym = $args{sym} //['p5=>'];


my $C = $self;
my $S = $C->{'_pos'};
$C->{'sym'} = $sym;

$self->_MATCHIFYr($S, "infix__S_410p5EqualGt",  map { STD::Comma->coerce($_) } 
$C->_PATTERN(qr/\Gp5\=\>/)
);
}

## token infix__S_411Z (  :$sym is context<rw> = <Z> --> List_infix)
##      token infix:sym<Z> ( --> List_infix)
##          { <sym> }

sub infix__S_411Z__PEEK { $_[0]->_AUTOLEXpeek('infix__S_411Z',$retree) }
sub infix__S_411Z {
my $self = shift;
local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;
my %args = @_;
local $sym = $args{sym} // q(Z);


my $C = $self;
my $S = $C->{'_pos'};
$C->{'sym'} = $sym;

$self->_MATCHIFYr($S, "infix__S_411Z",  map { STD::List_infix->coerce($_) } 
$C->_PATTERN(qr/\GZ/)
);
}

## token infix__S_412minmax (  :$sym is context<rw> = <minmax> --> List_infix)
##      token infix:sym<minmax> ( --> List_infix)
##          { <sym> }

sub infix__S_412minmax__PEEK { $_[0]->_AUTOLEXpeek('infix__S_412minmax',$retree) }
sub infix__S_412minmax {
my $self = shift;
local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;
my %args = @_;
local $sym = $args{sym} // q(minmax);


my $C = $self;
my $S = $C->{'_pos'};
$C->{'sym'} = $sym;

$self->_MATCHIFYr($S, "infix__S_412minmax",  map { STD::List_infix->coerce($_) } 
$C->_PATTERN(qr/\Gminmax/)
);
}

## token infix__S_413DotDotDot (  :$sym is context<rw> = <...> --> List_infix)
##      token infix:sym<...> ( --> List_infix)
##          { <sym> }

sub infix__S_413DotDotDot__PEEK { $_[0]->_AUTOLEXpeek('infix__S_413DotDotDot',$retree) }
sub infix__S_413DotDotDot {
my $self = shift;
local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;
my %args = @_;
local $sym = $args{sym} // q(...);


my $C = $self;
my $S = $C->{'_pos'};
$C->{'sym'} = $sym;

$self->_MATCHIFYr($S, "infix__S_413DotDotDot",  map { STD::List_infix->coerce($_) } 
$C->_PATTERN(qr/\G\.\.\./)
);
}

## token term__S_414DotDotDot (  :$sym is context<rw> = <...> --> List_prefix)
##      token term:sym<...> ( --> List_prefix)
##          { <sym> <args>? }

sub term__S_414DotDotDot__PEEK { $_[0]->_AUTOLEXpeek('term__S_414DotDotDot',$retree) }
sub term__S_414DotDotDot {
my $self = shift;
local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;
my %args = @_;
local $sym = $args{sym} // q(...);


my $C = $self;
my $S = $C->{'_pos'};
$C->{'args'} = [];
$C->{'sym'} = $sym;

$self->_MATCHIFYr($S, "term__S_414DotDotDot",  map { STD::List_prefix->coerce($_) } 
do {
if (my ($C) = ($C->_PATTERN(qr/\G\.\.\./))) {
$C->_OPTr(sub { my $C=shift;
$C->_SUBSUMEr(['args'], sub {
my $C = shift;
$C->args
})
});
}
else {
();
}
}
);
}

## token term__S_415QuestionQuestionQuestion (  :$sym is context<rw> = <???> --> List_prefix)
##      token term:sym<???> ( --> List_prefix)
##          { <sym> <args>? }

sub term__S_415QuestionQuestionQuestion__PEEK { $_[0]->_AUTOLEXpeek('term__S_415QuestionQuestionQuestion',$retree) }
sub term__S_415QuestionQuestionQuestion {
my $self = shift;
local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;
my %args = @_;
local $sym = $args{sym} // q(???);


my $C = $self;
my $S = $C->{'_pos'};
$C->{'args'} = [];
$C->{'sym'} = $sym;

$self->_MATCHIFYr($S, "term__S_415QuestionQuestionQuestion",  map { STD::List_prefix->coerce($_) } 
do {
if (my ($C) = ($C->_PATTERN(qr/\G\?\?\?/))) {
$C->_OPTr(sub { my $C=shift;
$C->_SUBSUMEr(['args'], sub {
my $C = shift;
$C->args
})
});
}
else {
();
}
}
);
}

## token term__S_416BangBangBang (  :$sym is context<rw> = <!!!> --> List_prefix)
##      token term:sym<!!!> ( --> List_prefix)
##          { <sym> <args>? }

sub term__S_416BangBangBang__PEEK { $_[0]->_AUTOLEXpeek('term__S_416BangBangBang',$retree) }
sub term__S_416BangBangBang {
my $self = shift;
local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;
my %args = @_;
local $sym = $args{sym} // q(!!!);


my $C = $self;
my $S = $C->{'_pos'};
$C->{'args'} = [];
$C->{'sym'} = $sym;

$self->_MATCHIFYr($S, "term__S_416BangBangBang",  map { STD::List_prefix->coerce($_) } 
do {
if (my ($C) = ($C->_PATTERN(qr/\G\!\!\!/))) {
$C->_OPTr(sub { my $C=shift;
$C->_SUBSUMEr(['args'], sub {
my $C = shift;
$C->args
})
});
}
else {
();
}
}
);
}

# force identifier(), identifier.(), etc. to be a function call always
## token term__S_417identifier (  :$sym is context<rw> = 'identifier' --> Term )
##      token term:identifier ( --> Term )
##      {
##          :my $name;
##          :my $pos;
##          <identifier> <?before [<unsp>|'(']? >
##          { $name = $<identifier>.Str; $pos = $¢.pos; }
##          <args( $¢.is_name($name) )>
##          { self.add_mystery($name,$pos) unless $<args><invocant>; }
##          {{
##              if $*BORG and $*BORG.<block> {
##                  if not $*BORG.<name> {
##                      $*BORG.<culprit> = $<identifier>.cursor($pos);
##                      $*BORG.<name> = $name;
##                  }
##              }
##          }}
##      }

sub term__S_417identifier__PEEK { $_[0]->_AUTOLEXpeek('term__S_417identifier',$retree) }
sub term__S_417identifier {
my $self = shift;
local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;
my %args = @_;
local $sym = $args{sym} // 'identifier';
my $name;
my $pos;


my $C = $self;
my $S = $C->{'_pos'};
$C->{'sym'} = $sym;

$self->_MATCHIFYr($S, "term__S_417identifier",  map { STD::Term->coerce($_) } 
do {
if (my ($C) = ($C->_SUBSUMEr(['identifier'], sub {
my $C = shift;
$C->identifier
}))) {
do {
if (my ($C) = ($C->before(sub { my $C=shift;
$C->_OPTr(sub { my $C=shift;
$C->_BRACKETr( sub { my $C=shift;
do {
my @result = eval {
my $trystate;
my ($tag, $try);
my @try;
my $relex;

my $fate;
if ($fate = $C->{'_fate'} and $fate->[1] eq 'term__S_417identifier_02') {
$C->deb("Fate passed to term__S_417identifier_02: ", ::fatestr($fate)) if $::DEBUG & DEBUG::fates;
($C->{'_fate'}, $tag, $try) = @$fate;
@try = ($try);
}

my @gather = ();
for (;;) {
if (not @try) {
$relex //= $C->cursor_fate('STD', 'term__S_417identifier_02', $retree);
@try = $relex->($C, $trystate);
}
last unless @try;
$try = shift(@try) // next;

if (ref $try eq 'ARRAY') {
($C->{'_fate'}, $tag, $try) = @$try;	# next candidate fate
}

$C->deb("term__S_417identifier_02 trying $tag $try") if $::DEBUG & DEBUG::try_processing;
push @gather, ((
sub { my $C=shift;
$C->_SUBSUMEr(['unsp'], sub {
my $C = shift;
$C->unsp
})
},
sub { my $C=shift;
$C->_EXACT('(')
},
)[$try])->($C);
last if @gather;
}
@gather;
};
if (@result) {
@result;
}
elsif ($@) {
my ($first) = $@ =~ /(^.*)/;
$self->deb("CAUGHT $first") if $::DEBUG & DEBUG::trace_call;
die $@ if $@ !~ /^ABORTBRANCH/;
();
}
else {
();
}
}

})
})
}))) {
do {
if (my ($C) = (scalar(do {
my $M = $C;  $name = $M->{'identifier'}->Str; $pos = $C->{'_pos'}; ;
}, $C))) {
do {
if (my ($C) = ($C->_SUBSUMEr(['args'], sub {
my $C = shift;
$C->args( $C->is_name($name) )
}))) {
do {
if (my ($C) = (scalar(do {
my $M = $C;  $self->add_mystery($name,$pos) unless $M->{'args'}{'invocant'}; ;
}, $C))) {
scalar(do {
my $M = $C; 
if ($::BORG and $::BORG->{'block'}) {
if (not $::BORG->{'name'}) {
$::BORG->{'culprit'} = $M->{'identifier'}->cursor($pos);
$::BORG->{'name'} = $name;
}
}
;
}, $C);
}
else {
();
}
};
}
else {
();
}
};
}
else {
();
}
};
}
else {
();
}
};
}
else {
();
}
}
);
}

## token term__S_418opfunc (  :$sym is context<rw> = 'opfunc' --> Term )
##      token term:opfunc ( --> Term )
##      {
##          <category> <colonpair>+ <args>
##      }

sub term__S_418opfunc__PEEK { $_[0]->_AUTOLEXpeek('term__S_418opfunc',$retree) }
sub term__S_418opfunc {
my $self = shift;
local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;
my %args = @_;
local $sym = $args{sym} // 'opfunc';


my $C = $self;
my $S = $C->{'_pos'};
$C->{'colonpair'} = [];
$C->{'sym'} = $sym;

$self->_MATCHIFYr($S, "term__S_418opfunc",  map { STD::Term->coerce($_) } 
do {
if (my ($C) = ($C->_SUBSUMEr(['category'], sub {
my $C = shift;
$C->category
}))) {
do {
if (my ($C) = ($C->_PLUSr(sub { my $C=shift;
$C->_SUBSUMEr(['colonpair'], sub {
my $C = shift;
$C->colonpair
})
}))) {
$C->_SUBSUMEr(['args'], sub {
my $C = shift;
$C->args
});
}
else {
();
}
};
}
else {
();
}
}
);
}

## token args ($istype = 0)
##      token args ($istype = 0) {
##          :my $listopish = 0;
##          :my $GOAL is context = '';
##          :my $INVOCANT_OK is context<rw> = 1;
##          :my $INVOCANT_IS is context<rw>;
##          [
##      #    | :dba('argument list') '.(' ~ ')' <semiarglist> {*}             #= func args
##          | :dba('argument list') '(' ~ ')' <semiarglist> {*}              #= func args
##          | :dba('argument list') <.unsp> '(' ~ ')' <semiarglist> {*} #= func args
##          |  { $listopish = 1 } [<?before \s> <!{ $istype }> <.ws> <!infixstopper> <arglist>]?
##          ]
##          { $<invocant> = $*INVOCANT_IS; }
##      
##          :dba('extra arglist after (...):')
##          [
##          || <?{ $listopish }>
##          || ':' <?before \s> <moreargs=arglist>    # either switch to listopiness
##          || {{ $<O> = {}; }}   # or allow adverbs (XXX needs hoisting?)
##          ]
##      }

sub args__PEEK { $_[0]->_AUTOLEXpeek('args',$retree) }
sub args {
my $self = shift;
local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;
my $istype = shift() // 0;
my $listopish = 0;
local $::GOAL = '';
local $::INVOCANT_OK = 1;
local $::INVOCANT_IS;


my $C = $self;
my $S = $C->{'_pos'};
$C->{'arglist'} = [];

$self->_MATCHIFY($S, "args", 
Cursor::lazymap(sub { my $C=$_[0];
Cursor::lazymap(sub { my $C=$_[0];
$C->_BRACKET( sub { my $C=shift;
do { my @gather;
eval { push @gather, $C->before( sub { my $C=shift;
(($C) x !!do {
$listopish 
})
})} // do {die $@ if $@ and $@ !~ /ABORT/;1} 
or
eval { push @gather, Cursor::lazymap(sub { my $C=$_[0];
Cursor::lazymap(sub { my $C=$_[0];
$C->_SUBSUME(['moreargs'], sub {
my $C = shift;
$C->arglist
})
}, $C->before(sub { my $C=shift;
$C->_PATTERN(qr/\G\s/)
}))
}, $C->_EXACT(':'))} // do {die $@ if $@ and $@ !~ /ABORT/;1} 
or
eval { push @gather, scalar(do {
my $M = $C;  $M->{'O'} = {}; ;
}, $C)} or do { die $@ if $@ };
@gather;
}
})
}, scalar(do {
my $M = $C;  $M->{'invocant'} = $::INVOCANT_IS; ;
}, $C))
}, $C->_BRACKET( sub { my $C=shift;
do {
my @result = eval {
my $trystate;
my ($tag, $try);
my @try;
my $relex;

my $fate;
if ($fate = $C->{'_fate'} and $fate->[1] eq 'args_01') {
$C->deb("Fate passed to args_01: ", ::fatestr($fate)) if $::DEBUG & DEBUG::fates;
($C->{'_fate'}, $tag, $try) = @$fate;
@try = ($try);
}

my @gather = ();
for (;;) {
if (not @try) {
$relex //= $C->cursor_fate('STD', 'args_01', $retree);
@try = $relex->($C, $trystate);
}
last unless @try;
$try = shift(@try) // next;

if (ref $try eq 'ARRAY') {
($C->{'_fate'}, $tag, $try) = @$try;	# next candidate fate
}

$C->deb("args_01 trying $tag $try") if $::DEBUG & DEBUG::try_processing;
push @gather, ((
sub { my $C=shift;
Cursor::lazymap(sub { my $C=$_[0];
Cursor::lazymap(sub { my $C=$_[0];
Cursor::lazymap(sub { my $C=$_[0];
Cursor::lazymap(sub { my $C=$_[0];
$C->_REDUCE($S, 'args', 'func args')
}, $C->_BRACKET( sub { my $C=shift;
do { my @gather;
eval { push @gather, $C->_EXACT(')')} // do {die $@ if $@ and $@ !~ /ABORT/;1} 
or
eval { push @gather, $C->FAILGOAL(')' , 'argument list')} or do { die $@ if $@ };
@gather;
}
}))
}, $C->_SUBSUME(['semiarglist'], sub {
my $C = shift;
$C->semiarglist
}))
}, $C->_COMMITBRANCH(local $::GOAL = ')' ))
}, $C->_EXACT('('))
},
sub { my $C=shift;
Cursor::lazymap(sub { my $C=$_[0];
Cursor::lazymap(sub { my $C=$_[0];
Cursor::lazymap(sub { my $C=$_[0];
Cursor::lazymap(sub { my $C=$_[0];
Cursor::lazymap(sub { my $C=$_[0];
$C->_REDUCE($S, 'args', 'func args')
}, $C->_BRACKET( sub { my $C=shift;
do { my @gather;
eval { push @gather, $C->_EXACT(')')} // do {die $@ if $@ and $@ !~ /ABORT/;1} 
or
eval { push @gather, $C->FAILGOAL(')' , 'argument list')} or do { die $@ if $@ };
@gather;
}
}))
}, $C->_SUBSUME(['semiarglist'], sub {
my $C = shift;
$C->semiarglist
}))
}, $C->_COMMITBRANCH(local $::GOAL = ')' ))
}, $C->_EXACT('('))
}, $C->unsp)
},
sub { my $C=shift;
Cursor::lazymap(sub { my $C=$_[0];
$C->_OPTr(sub { my $C=shift;
$C->_BRACKET( sub { my $C=shift;
Cursor::lazymap(sub { my $C=$_[0];
Cursor::lazymap(sub { my $C=$_[0];
Cursor::lazymap(sub { my $C=$_[0];
Cursor::lazymap(sub { my $C=$_[0];
$C->_SUBSUME(['arglist'], sub {
my $C = shift;
$C->arglist
})
}, $C->_NOTBEFORE( sub { my $C=shift;
$C->infixstopper
}))
}, $C->ws)
}, $C->_NOTBEFORE( sub { my $C=shift;
(($C) x !!do {
$istype 
})
}))
}, $C->before(sub { my $C=shift;
$C->_PATTERN(qr/\G\s/)
}))
})
})
}, scalar(do {
$listopish = 1 
}, $C))
},
)[$try])->($C);
last if @gather;
}
@gather;
};
if (@result) {
@result;
}
elsif ($@) {
my ($first) = $@ =~ /(^.*)/;
$self->deb("CAUGHT $first") if $::DEBUG & DEBUG::trace_call;
die $@ if $@ !~ /^ABORTBRANCH/;
();
}
else {
();
}
}

}))
);
}

# names containing :: may or may not be function calls
# bare identifier without parens also handled here if no other rule parses it
## token term__S_419name (  :$sym is context<rw> = 'name' --> Term)
##      token term:name ( --> Term)
##      {
##          :my $name;
##          :my $pos;
##          <longname>
##          {
##              $name = $<longname>.Str;
##              $pos = $¢.pos;
##          }
##          [
##          ||  <?{
##                  $¢.is_name($<longname>.Str) or substr($<longname>.Str,0,2) eq '::'
##              }>
##              # parametric type?
##              <.unsp>? [ <?before '['> <postcircumfix> ]?
##              :dba('type parameter')
##              [
##                  '::'
##                  <?before [ '«' | '<' | '{' | '<<' ] > <postcircumfix>
##                  {*}                                                 #= packagevar 
##              ]?
##              {*}                                                     #= typename
##      
##          # unrecognized names are assumed to be post-declared listops.
##          || <args> { self.add_mystery($name,$pos) unless $<args><invocant>; }
##              {{
##                  if $*BORG and $*BORG.<block> {
##                      if not $*BORG.<name> {
##                          $*BORG.<culprit> = $<longname>.cursor($pos);
##                          $*BORG.<name> //= $name;
##                      }
##                  }
##              }}
##          ]
##      }

sub term__S_419name__PEEK { $_[0]->_AUTOLEXpeek('term__S_419name',$retree) }
sub term__S_419name {
my $self = shift;
local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;
my %args = @_;
local $sym = $args{sym} // 'name';
my $name;
my $pos;


my $C = $self;
my $S = $C->{'_pos'};
$C->{'postcircumfix'} = [];
$C->{'sym'} = $sym;

$self->_MATCHIFYr($S, "term__S_419name",  map { STD::Term->coerce($_) } 
do {
if (my ($C) = ($C->_SUBSUMEr(['longname'], sub {
my $C = shift;
$C->longname
}))) {
do {
if (my ($C) = (scalar(do {
my $M = $C; 
$name = $M->{'longname'}->Str;
$pos = $C->{'_pos'};
;
}, $C))) {
$C->_BRACKETr( sub { my $C=shift;
do { my @gather;
eval { push @gather, do {
if (my ($C) = ($C->before( sub { my $C=shift;
(($C) x !!do {
my $M = $C; 
$C->is_name($M->{'longname'}->Str) or substr($M->{'longname'}->Str,0,2) eq '::'
;
})
}))) {
do {
if (my ($C) = ($C->_OPTr(sub { my $C=shift;
$C->unsp
}))) {
do {
if (my ($C) = ($C->_OPTr(sub { my $C=shift;
$C->_BRACKETr( sub { my $C=shift;
do {
if (my ($C) = ($C->before(sub { my $C=shift;
$C->_EXACT('[')
}))) {
$C->_SUBSUMEr(['postcircumfix'], sub {
my $C = shift;
$C->postcircumfix
});
}
else {
();
}
}
})
}))) {
do {
if (my ($C) = ($C->_OPTr(sub { my $C=shift;
$C->_BRACKETr( sub { my $C=shift;
do {
if (my ($C) = ($C->_EXACT('::'))) {
do {
if (my ($C) = ($C->before(sub { my $C=shift;
$C->_BRACKETr( sub { my $C=shift;
do {
my @result = eval {
my $trystate;
my ($tag, $try);
my @try;
my $relex;

my $fate;
if ($fate = $C->{'_fate'} and $fate->[1] eq 'term__S_419name_06') {
$C->deb("Fate passed to term__S_419name_06: ", ::fatestr($fate)) if $::DEBUG & DEBUG::fates;
($C->{'_fate'}, $tag, $try) = @$fate;
@try = ($try);
}

my @gather = ();
for (;;) {
if (not @try) {
$relex //= $C->cursor_fate('STD', 'term__S_419name_06', $retree);
@try = $relex->($C, $trystate);
}
last unless @try;
$try = shift(@try) // next;

if (ref $try eq 'ARRAY') {
($C->{'_fate'}, $tag, $try) = @$try;	# next candidate fate
}

$C->deb("term__S_419name_06 trying $tag $try") if $::DEBUG & DEBUG::try_processing;
push @gather, ((
sub { my $C=shift;
$C->_EXACT('«')
},
sub { my $C=shift;
$C->_EXACT('<')
},
sub { my $C=shift;
$C->_EXACT('{')
},
sub { my $C=shift;
$C->_EXACT('<<')
},
)[$try])->($C);
last if @gather;
}
@gather;
};
if (@result) {
@result;
}
elsif ($@) {
my ($first) = $@ =~ /(^.*)/;
$self->deb("CAUGHT $first") if $::DEBUG & DEBUG::trace_call;
die $@ if $@ !~ /^ABORTBRANCH/;
();
}
else {
();
}
}

})
}))) {
do {
if (my ($C) = ($C->_SUBSUMEr(['postcircumfix'], sub {
my $C = shift;
$C->postcircumfix
}))) {
$C->_REDUCE($S, 'term__S_419name', 'packagevar ');
}
else {
();
}
};
}
else {
();
}
};
}
else {
();
}
}
})
}))) {
$C->_REDUCE($S, 'term__S_419name', 'typename');
}
else {
();
}
};
}
else {
();
}
};
}
else {
();
}
};
}
else {
();
}
}} // do {die $@ if $@ and $@ !~ /ABORT/;1} 
or
eval { push @gather, do {
if (my ($C) = ($C->_SUBSUMEr(['args'], sub {
my $C = shift;
$C->args
}))) {
do {
if (my ($C) = (scalar(do {
my $M = $C;  $self->add_mystery($name,$pos) unless $M->{'args'}{'invocant'}; ;
}, $C))) {
scalar(do {
my $M = $C; 
if ($::BORG and $::BORG->{'block'}) {
if (not $::BORG->{'name'}) {
$::BORG->{'culprit'} = $M->{'longname'}->cursor($pos);
$::BORG->{'name'} //= $name;
}
}
;
}, $C);
}
else {
();
}
};
}
else {
();
}
}} or do { die $@ if $@ };
@gather;
}
});
}
else {
();
}
};
}
else {
();
}
}
);
}

## loose and
## token infix__S_420and (  :$sym is context<rw> = <and> --> Loose_and)
##      token infix:sym<and> ( --> Loose_and)
##          { <sym> }

sub infix__S_420and__PEEK { $_[0]->_AUTOLEXpeek('infix__S_420and',$retree) }
sub infix__S_420and {
my $self = shift;
local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;
my %args = @_;
local $sym = $args{sym} // q(and);


my $C = $self;
my $S = $C->{'_pos'};
$C->{'sym'} = $sym;

$self->_MATCHIFYr($S, "infix__S_420and",  map { STD::Loose_and->coerce($_) } 
$C->_PATTERN(qr/\Gand/)
);
}

## token infix__S_421andthen (  :$sym is context<rw> = <andthen> --> Loose_and)
##      token infix:sym<andthen> ( --> Loose_and)
##          { <sym> }

sub infix__S_421andthen__PEEK { $_[0]->_AUTOLEXpeek('infix__S_421andthen',$retree) }
sub infix__S_421andthen {
my $self = shift;
local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;
my %args = @_;
local $sym = $args{sym} // q(andthen);


my $C = $self;
my $S = $C->{'_pos'};
$C->{'sym'} = $sym;

$self->_MATCHIFYr($S, "infix__S_421andthen",  map { STD::Loose_and->coerce($_) } 
$C->_PATTERN(qr/\Gandthen/)
);
}

## loose or
## token infix__S_422or (  :$sym is context<rw> = <or> --> Loose_or)
##      token infix:sym<or> ( --> Loose_or)
##          { <sym> }

sub infix__S_422or__PEEK { $_[0]->_AUTOLEXpeek('infix__S_422or',$retree) }
sub infix__S_422or {
my $self = shift;
local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;
my %args = @_;
local $sym = $args{sym} // q(or);


my $C = $self;
my $S = $C->{'_pos'};
$C->{'sym'} = $sym;

$self->_MATCHIFYr($S, "infix__S_422or",  map { STD::Loose_or->coerce($_) } 
$C->_PATTERN(qr/\Gor/)
);
}

## token infix__S_423orelse (  :$sym is context<rw> = <orelse> --> Loose_or)
##      token infix:sym<orelse> ( --> Loose_or)
##          { <sym> }

sub infix__S_423orelse__PEEK { $_[0]->_AUTOLEXpeek('infix__S_423orelse',$retree) }
sub infix__S_423orelse {
my $self = shift;
local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;
my %args = @_;
local $sym = $args{sym} // q(orelse);


my $C = $self;
my $S = $C->{'_pos'};
$C->{'sym'} = $sym;

$self->_MATCHIFYr($S, "infix__S_423orelse",  map { STD::Loose_or->coerce($_) } 
$C->_PATTERN(qr/\Gorelse/)
);
}

## token infix__S_424xor (  :$sym is context<rw> = <xor> --> Loose_or)
##      token infix:sym<xor> ( --> Loose_or)
##          { <sym> }

sub infix__S_424xor__PEEK { $_[0]->_AUTOLEXpeek('infix__S_424xor',$retree) }
sub infix__S_424xor {
my $self = shift;
local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;
my %args = @_;
local $sym = $args{sym} // q(xor);


my $C = $self;
my $S = $C->{'_pos'};
$C->{'sym'} = $sym;

$self->_MATCHIFYr($S, "infix__S_424xor",  map { STD::Loose_or->coerce($_) } 
$C->_PATTERN(qr/\Gxor/)
);
}

## sequencer
## token infix__S_425LtEqualEqual (  :$sym is context<rw> = « <== » --> Sequencer)
##      token infix:sym« <== » ( --> Sequencer)
##          { <sym> }

sub infix__S_425LtEqualEqual__PEEK { $_[0]->_AUTOLEXpeek('infix__S_425LtEqualEqual',$retree) }
sub infix__S_425LtEqualEqual {
my $self = shift;
local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;
my %args = @_;
local $sym = $args{sym} //['<=='];


my $C = $self;
my $S = $C->{'_pos'};
$C->{'sym'} = $sym;

$self->_MATCHIFYr($S, "infix__S_425LtEqualEqual",  map { STD::Sequencer->coerce($_) } 
$C->_PATTERN(qr/\G\<\=\=/)
);
}

## token infix__S_426EqualEqualGt (  :$sym is context<rw> = « ==> » --> Sequencer)
##      token infix:sym« ==> » ( --> Sequencer)
##          { <sym> {*} }

sub infix__S_426EqualEqualGt__PEEK { $_[0]->_AUTOLEXpeek('infix__S_426EqualEqualGt',$retree) }
sub infix__S_426EqualEqualGt {
my $self = shift;
local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;
my %args = @_;
local $sym = $args{sym} //['==>'];


my $C = $self;
my $S = $C->{'_pos'};
$C->{'sym'} = $sym;

$self->_MATCHIFYr($S, "infix__S_426EqualEqualGt",  map { STD::Sequencer->coerce($_) } 
do {
if (my ($C) = ($C->_PATTERN(qr/\G\=\=\>/))) {
$C->_REDUCE($S, 'infix__S_426EqualEqualGt');
}
else {
();
}
}
);
}              #'

## token infix__S_427LtLtEqualEqual (  :$sym is context<rw> = « <<== » --> Sequencer)
##      token infix:sym« <<== » ( --> Sequencer)
##          { <sym> }

sub infix__S_427LtLtEqualEqual__PEEK { $_[0]->_AUTOLEXpeek('infix__S_427LtLtEqualEqual',$retree) }
sub infix__S_427LtLtEqualEqual {
my $self = shift;
local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;
my %args = @_;
local $sym = $args{sym} //['<<=='];


my $C = $self;
my $S = $C->{'_pos'};
$C->{'sym'} = $sym;

$self->_MATCHIFYr($S, "infix__S_427LtLtEqualEqual",  map { STD::Sequencer->coerce($_) } 
$C->_PATTERN(qr/\G\<\<\=\=/)
);
}

## token infix__S_428EqualEqualGtGt (  :$sym is context<rw> = « ==>> » --> Sequencer)
##      token infix:sym« ==>> » ( --> Sequencer)
##          { <sym> {*} }

sub infix__S_428EqualEqualGtGt__PEEK { $_[0]->_AUTOLEXpeek('infix__S_428EqualEqualGtGt',$retree) }
sub infix__S_428EqualEqualGtGt {
my $self = shift;
local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;
my %args = @_;
local $sym = $args{sym} //['==>>'];


my $C = $self;
my $S = $C->{'_pos'};
$C->{'sym'} = $sym;

$self->_MATCHIFYr($S, "infix__S_428EqualEqualGtGt",  map { STD::Sequencer->coerce($_) } 
do {
if (my ($C) = ($C->_PATTERN(qr/\G\=\=\>\>/))) {
$C->_REDUCE($S, 'infix__S_428EqualEqualGtGt');
}
else {
();
}
}
);
}              #'

## expression terminator
# Note: must always be called as <?terminator> or <?before ...<terminator>...>

## token terminator__S_429Semi (  :$sym is context<rw> = <;> --> Terminator)
##      token terminator:sym<;> ( --> Terminator)
##          { ';' }

sub terminator__S_429Semi__PEEK { $_[0]->_AUTOLEXpeek('terminator__S_429Semi',$retree) }
sub terminator__S_429Semi {
my $self = shift;
local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;
my %args = @_;
local $sym = $args{sym} // q(;);


my $C = $self;
my $S = $C->{'_pos'};
$C->{'sym'} = $sym;

$self->_MATCHIFYr($S, "terminator__S_429Semi",  map { STD::Terminator->coerce($_) } 
$C->_EXACT(';')
);
}

## token terminator__S_430if (  :$sym is context<rw> = <if> --> Terminator)
##      token terminator:sym<if> ( --> Terminator)
##          { 'if' » <.nofun> }

sub terminator__S_430if__PEEK { $_[0]->_AUTOLEXpeek('terminator__S_430if',$retree) }
sub terminator__S_430if {
my $self = shift;
local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;
my %args = @_;
local $sym = $args{sym} // q(if);


my $C = $self;
my $S = $C->{'_pos'};
$C->{'sym'} = $sym;

$self->_MATCHIFYr($S, "terminator__S_430if",  map { STD::Terminator->coerce($_) } 
do {
if (my ($C) = ($C->_EXACT('if'))) {
do {
if (my ($C) = ($C->_PATTERN(qr/\G\b/))) {
$C->nofun;
}
else {
();
}
};
}
else {
();
}
}
);
}

## token terminator__S_431unless (  :$sym is context<rw> = <unless> --> Terminator)
##      token terminator:sym<unless> ( --> Terminator)
##          { 'unless' » <.nofun> }

sub terminator__S_431unless__PEEK { $_[0]->_AUTOLEXpeek('terminator__S_431unless',$retree) }
sub terminator__S_431unless {
my $self = shift;
local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;
my %args = @_;
local $sym = $args{sym} // q(unless);


my $C = $self;
my $S = $C->{'_pos'};
$C->{'sym'} = $sym;

$self->_MATCHIFYr($S, "terminator__S_431unless",  map { STD::Terminator->coerce($_) } 
do {
if (my ($C) = ($C->_EXACT('unless'))) {
do {
if (my ($C) = ($C->_PATTERN(qr/\G\b/))) {
$C->nofun;
}
else {
();
}
};
}
else {
();
}
}
);
}

## token terminator__S_432while (  :$sym is context<rw> = <while> --> Terminator)
##      token terminator:sym<while> ( --> Terminator)
##          { 'while' » <.nofun> }

sub terminator__S_432while__PEEK { $_[0]->_AUTOLEXpeek('terminator__S_432while',$retree) }
sub terminator__S_432while {
my $self = shift;
local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;
my %args = @_;
local $sym = $args{sym} // q(while);


my $C = $self;
my $S = $C->{'_pos'};
$C->{'sym'} = $sym;

$self->_MATCHIFYr($S, "terminator__S_432while",  map { STD::Terminator->coerce($_) } 
do {
if (my ($C) = ($C->_EXACT('while'))) {
do {
if (my ($C) = ($C->_PATTERN(qr/\G\b/))) {
$C->nofun;
}
else {
();
}
};
}
else {
();
}
}
);
}

## token terminator__S_433until (  :$sym is context<rw> = <until> --> Terminator)
##      token terminator:sym<until> ( --> Terminator)
##          { 'until' » <.nofun> }

sub terminator__S_433until__PEEK { $_[0]->_AUTOLEXpeek('terminator__S_433until',$retree) }
sub terminator__S_433until {
my $self = shift;
local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;
my %args = @_;
local $sym = $args{sym} // q(until);


my $C = $self;
my $S = $C->{'_pos'};
$C->{'sym'} = $sym;

$self->_MATCHIFYr($S, "terminator__S_433until",  map { STD::Terminator->coerce($_) } 
do {
if (my ($C) = ($C->_EXACT('until'))) {
do {
if (my ($C) = ($C->_PATTERN(qr/\G\b/))) {
$C->nofun;
}
else {
();
}
};
}
else {
();
}
}
);
}

## token terminator__S_434for (  :$sym is context<rw> = <for> --> Terminator)
##      token terminator:sym<for> ( --> Terminator)
##          { 'for' » <.nofun> }

sub terminator__S_434for__PEEK { $_[0]->_AUTOLEXpeek('terminator__S_434for',$retree) }
sub terminator__S_434for {
my $self = shift;
local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;
my %args = @_;
local $sym = $args{sym} // q(for);


my $C = $self;
my $S = $C->{'_pos'};
$C->{'sym'} = $sym;

$self->_MATCHIFYr($S, "terminator__S_434for",  map { STD::Terminator->coerce($_) } 
do {
if (my ($C) = ($C->_EXACT('for'))) {
do {
if (my ($C) = ($C->_PATTERN(qr/\G\b/))) {
$C->nofun;
}
else {
();
}
};
}
else {
();
}
}
);
}

## token terminator__S_435given (  :$sym is context<rw> = <given> --> Terminator)
##      token terminator:sym<given> ( --> Terminator)
##          { 'given' » <.nofun> }

sub terminator__S_435given__PEEK { $_[0]->_AUTOLEXpeek('terminator__S_435given',$retree) }
sub terminator__S_435given {
my $self = shift;
local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;
my %args = @_;
local $sym = $args{sym} // q(given);


my $C = $self;
my $S = $C->{'_pos'};
$C->{'sym'} = $sym;

$self->_MATCHIFYr($S, "terminator__S_435given",  map { STD::Terminator->coerce($_) } 
do {
if (my ($C) = ($C->_EXACT('given'))) {
do {
if (my ($C) = ($C->_PATTERN(qr/\G\b/))) {
$C->nofun;
}
else {
();
}
};
}
else {
();
}
}
);
}

## token terminator__S_436when (  :$sym is context<rw> = <when> --> Terminator)
##      token terminator:sym<when> ( --> Terminator)
##          { 'when' » <.nofun> }

sub terminator__S_436when__PEEK { $_[0]->_AUTOLEXpeek('terminator__S_436when',$retree) }
sub terminator__S_436when {
my $self = shift;
local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;
my %args = @_;
local $sym = $args{sym} // q(when);


my $C = $self;
my $S = $C->{'_pos'};
$C->{'sym'} = $sym;

$self->_MATCHIFYr($S, "terminator__S_436when",  map { STD::Terminator->coerce($_) } 
do {
if (my ($C) = ($C->_EXACT('when'))) {
do {
if (my ($C) = ($C->_PATTERN(qr/\G\b/))) {
$C->nofun;
}
else {
();
}
};
}
else {
();
}
}
);
}

## token terminator__S_437MinusMinusGt (  :$sym is context<rw> = « --> » --> Terminator)
##      token terminator:sym« --> » ( --> Terminator)
##          { '-->' {*} }

sub terminator__S_437MinusMinusGt__PEEK { $_[0]->_AUTOLEXpeek('terminator__S_437MinusMinusGt',$retree) }
sub terminator__S_437MinusMinusGt {
my $self = shift;
local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;
my %args = @_;
local $sym = $args{sym} //['-->'];


my $C = $self;
my $S = $C->{'_pos'};
$C->{'sym'} = $sym;

$self->_MATCHIFYr($S, "terminator__S_437MinusMinusGt",  map { STD::Terminator->coerce($_) } 
do {
if (my ($C) = ($C->_EXACT('-->'))) {
$C->_REDUCE($S, 'terminator__S_437MinusMinusGt');
}
else {
();
}
}
);
}              #'

## token terminator__S_438Thesis (  :$sym is context<rw> = <)> --> Terminator)
##      token terminator:sym<)> ( --> Terminator)
##          { <sym> }

sub terminator__S_438Thesis__PEEK { $_[0]->_AUTOLEXpeek('terminator__S_438Thesis',$retree) }
sub terminator__S_438Thesis {
my $self = shift;
local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;
my %args = @_;
local $sym = $args{sym} // q[)];


my $C = $self;
my $S = $C->{'_pos'};
$C->{'sym'} = $sym;

$self->_MATCHIFYr($S, "terminator__S_438Thesis",  map { STD::Terminator->coerce($_) } 
$C->_PATTERN(qr/\G\)/)
);
}

## token terminator__S_439Ket (  :$sym is context<rw> = <]> --> Terminator)
##      token terminator:sym<]> ( --> Terminator)
##          { ']' }

sub terminator__S_439Ket__PEEK { $_[0]->_AUTOLEXpeek('terminator__S_439Ket',$retree) }
sub terminator__S_439Ket {
my $self = shift;
local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;
my %args = @_;
local $sym = $args{sym} // q(]);


my $C = $self;
my $S = $C->{'_pos'};
$C->{'sym'} = $sym;

$self->_MATCHIFYr($S, "terminator__S_439Ket",  map { STD::Terminator->coerce($_) } 
$C->_EXACT(']')
);
}

## token terminator__S_440Ly (  :$sym is context<rw> = <}> --> Terminator)
##      token terminator:sym<}> ( --> Terminator)
##          { '}' }

sub terminator__S_440Ly__PEEK { $_[0]->_AUTOLEXpeek('terminator__S_440Ly',$retree) }
sub terminator__S_440Ly {
my $self = shift;
local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;
my %args = @_;
local $sym = $args{sym} // q(});


my $C = $self;
my $S = $C->{'_pos'};
$C->{'sym'} = $sym;

$self->_MATCHIFYr($S, "terminator__S_440Ly",  map { STD::Terminator->coerce($_) } 
$C->_EXACT('}')
);
}

## token terminator__S_441BangBang (  :$sym is context<rw> = <!!> --> Terminator)
##      token terminator:sym<!!> ( --> Terminator)
##          { '!!' <?{ $*GOAL eq '!!' }> }

sub terminator__S_441BangBang__PEEK { $_[0]->_AUTOLEXpeek('terminator__S_441BangBang',$retree) }
sub terminator__S_441BangBang {
my $self = shift;
local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;
my %args = @_;
local $sym = $args{sym} // q(!!);


my $C = $self;
my $S = $C->{'_pos'};
$C->{'sym'} = $sym;

$self->_MATCHIFYr($S, "terminator__S_441BangBang",  map { STD::Terminator->coerce($_) } 
do {
if (my ($C) = ($C->_EXACT('!!'))) {
$C->before( sub { my $C=shift;
(($C) x !!do {
$::GOAL eq '!!' 
})
});
}
else {
();
}
}
);
}

# disallow &[] and such as infix
# token infix:sigil ( --> Term )
#     { <sigil><-[&]> <.worry: "Sigiled form not allowed where infix expected"> <!> }

## regex infixstopper
##      regex infixstopper {
##          :dba('infix stopper')
##          [
##          | <?before <stopper> >
##          | <?before '!!' > <?{ $*GOAL eq '!!' }>
##          | <?before '{' | <lambda> > <?{ ($*GOAL eq '{' or $*GOAL eq 'endargs') and @*MEMOS[$¢.pos]<ws> }>
##          | <?{ $*GOAL eq 'endargs' and @*MEMOS[$¢.pos]<endargs> }>
##          ]
##      }

sub infixstopper__PEEK { $_[0]->_AUTOLEXpeek('infixstopper',$retree) }
sub infixstopper {
my $self = shift;
local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;


my $C = $self;
my $S = $C->{'_pos'};

$self->_MATCHIFY($S, "infixstopper", 
$C->_BRACKET( sub { my $C=shift;
do {
my @result = eval {
my $trystate;
my ($tag, $try);
my @try;
my $relex;

my $fate;
if ($fate = $C->{'_fate'} and $fate->[1] eq 'infixstopper_01') {
$C->deb("Fate passed to infixstopper_01: ", ::fatestr($fate)) if $::DEBUG & DEBUG::fates;
($C->{'_fate'}, $tag, $try) = @$fate;
@try = ($try);
}

my @gather = ();
for (;;) {
if (not @try) {
$relex //= $C->cursor_fate('STD', 'infixstopper_01', $retree);
@try = $relex->($C, $trystate);
}
last unless @try;
$try = shift(@try) // next;

if (ref $try eq 'ARRAY') {
($C->{'_fate'}, $tag, $try) = @$try;	# next candidate fate
}

$C->deb("infixstopper_01 trying $tag $try") if $::DEBUG & DEBUG::try_processing;
push @gather, ((
sub { my $C=shift;
$C->before(sub { my $C=shift;
$C->_SUBSUME(['stopper'], sub {
my $C = shift;
$C->stopper
})
})
},
sub { my $C=shift;
Cursor::lazymap(sub { my $C=$_[0];
$C->before( sub { my $C=shift;
(($C) x !!do {
$::GOAL eq '!!' 
})
})
}, $C->before(sub { my $C=shift;
$C->_EXACT('!!')
}))
},
sub { my $C=shift;
Cursor::lazymap(sub { my $C=$_[0];
$C->before( sub { my $C=shift;
(($C) x !!do {
($::GOAL eq '{' or $::GOAL eq 'endargs') and $::MEMOS[$C->{'_pos'}]{'ws'} 
})
})
}, $C->before(sub { my $C=shift;
do {
my @result = eval {
my $trystate;
my ($tag, $try);
my @try;
my $relex;

my $fate;
if ($fate = $C->{'_fate'} and $fate->[1] eq 'infixstopper_04') {
$C->deb("Fate passed to infixstopper_04: ", ::fatestr($fate)) if $::DEBUG & DEBUG::fates;
($C->{'_fate'}, $tag, $try) = @$fate;
@try = ($try);
}

my @gather = ();
for (;;) {
if (not @try) {
$relex //= $C->cursor_fate('STD', 'infixstopper_04', $retree);
@try = $relex->($C, $trystate);
}
last unless @try;
$try = shift(@try) // next;

if (ref $try eq 'ARRAY') {
($C->{'_fate'}, $tag, $try) = @$try;	# next candidate fate
}

$C->deb("infixstopper_04 trying $tag $try") if $::DEBUG & DEBUG::try_processing;
push @gather, ((
sub { my $C=shift;
$C->_EXACT('{')
},
sub { my $C=shift;
$C->_SUBSUME(['lambda'], sub {
my $C = shift;
$C->lambda
})
},
)[$try])->($C);
last if @gather;
}
@gather;
};
if (@result) {
@result;
}
elsif ($@) {
my ($first) = $@ =~ /(^.*)/;
$self->deb("CAUGHT $first") if $::DEBUG & DEBUG::trace_call;
die $@ if $@ !~ /^ABORTBRANCH/;
();
}
else {
();
}
}

}))
},
sub { my $C=shift;
$C->before( sub { my $C=shift;
(($C) x !!do {
$::GOAL eq 'endargs' and $::MEMOS[$C->{'_pos'}]{'endargs'} 
})
})
},
)[$try])->($C);
last if @gather;
}
@gather;
};
if (@result) {
@result;
}
elsif ($@) {
my ($first) = $@ =~ /(^.*)/;
$self->deb("CAUGHT $first") if $::DEBUG & DEBUG::trace_call;
die $@ if $@ !~ /^ABORTBRANCH/;
();
}
else {
();
}
}

})
);
}

# overridden in subgrammars
## token stopper
##      token stopper { <!> }

sub stopper__PEEK { $_[0]->_AUTOLEXpeek('stopper',$retree) }
sub stopper {
my $self = shift;
local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;


my $C = $self;
my $S = $C->{'_pos'};

$self->_MATCHIFYr($S, "stopper", 
$C->_NOTBEFORE( sub { my $C=shift;
$C
})
);
}

# hopefully we can include these tokens in any outer LTM matcher
## regex stdstopper
##      regex stdstopper {
##          :my @stub = return self if @*MEMOS[self.pos]<endstmt> :exists;
##          :dba('standard stopper')
##          [
##          | <?terminator>
##          | <?unitstopper>
##          | $                                 # unlikely, check last (normal LTM behavior)
##          ]
##          { @*MEMOS[$¢.pos]<endstmt> ||= 1; }
##      }

sub stdstopper__PEEK { $_[0]->_AUTOLEXpeek('stdstopper',$retree) }
sub stdstopper {
my $self = shift;
local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;
my @stub = return $self if exists $::MEMOS[$self->{'_pos'}]{'endstmt'};


my $C = $self;
my $S = $C->{'_pos'};

$self->_MATCHIFY($S, "stdstopper", 
Cursor::lazymap(sub { my $C=$_[0];
scalar(do {
$::MEMOS[$C->{'_pos'}]{'endstmt'} ||= 1; 
}, $C)
}, $C->_BRACKET( sub { my $C=shift;
do {
my @result = eval {
my $trystate;
my ($tag, $try);
my @try;
my $relex;

my $fate;
if ($fate = $C->{'_fate'} and $fate->[1] eq 'stdstopper_01') {
$C->deb("Fate passed to stdstopper_01: ", ::fatestr($fate)) if $::DEBUG & DEBUG::fates;
($C->{'_fate'}, $tag, $try) = @$fate;
@try = ($try);
}

my @gather = ();
for (;;) {
if (not @try) {
$relex //= $C->cursor_fate('STD', 'stdstopper_01', $retree);
@try = $relex->($C, $trystate);
}
last unless @try;
$try = shift(@try) // next;

if (ref $try eq 'ARRAY') {
($C->{'_fate'}, $tag, $try) = @$try;	# next candidate fate
}

$C->deb("stdstopper_01 trying $tag $try") if $::DEBUG & DEBUG::try_processing;
push @gather, ((
sub { my $C=shift;
$C->before( sub { my $C=shift;
$C->terminator
})
},
sub { my $C=shift;
$C->before( sub { my $C=shift;
$C->unitstopper
})
},
sub { my $C=shift;
$C->_PATTERN(qr/\G\z/)
},
)[$try])->($C);
last if @gather;
}
@gather;
};
if (@result) {
@result;
}
elsif ($@) {
my ($first) = $@ =~ /(^.*)/;
$self->deb("CAUGHT $first") if $::DEBUG & DEBUG::trace_call;
die $@ if $@ !~ /^ABORTBRANCH/;
();
}
else {
();
}
}

}))
);
}

##############################
# Operator Precedence Parser #
##############################

## method EXPR ($preclvl)
sub EXPR {
my $self = shift;
my $preclvl = shift;


local $::CTX = $self->callm if $::DEBUG & DEBUG::trace_call;
if ($self->peek) {
return $self->_AUTOLEXpeek('EXPR');
}
my $preclim = $preclvl ? $preclvl->{'prec'} // $LOOSEST : $LOOSEST;
local $::LEFTSIGIL = '';
my @termstack;
my @opstack;
my $termish = 'termish';

push @opstack, { 'O' => \%terminator, 'sym' => '' };         # (just a sentinel value)

my $here = $self;
my $S = $here->{'_pos'};
$self->deb("In EXPR, at $S") if $::DEBUG & DEBUG::EXPR;

my $reduce = sub {
$self->deb("entering reduce, termstack == ", 0+@termstack, " opstack == ", 0+@opstack) if $::DEBUG & DEBUG::EXPR;
my $op = pop @opstack;
my $sym = $op->{'sym'};
given ($op->{'O'}{'assoc'} // 'unary') {
when ('chain') {
$self->deb("reducing chain") if $::DEBUG & DEBUG::EXPR;
my @chain;
push @chain, pop(@termstack);
push @chain, $op;
while (@opstack) {
last if $op->{'O'}{'prec'} ne $opstack[-1]{'O'}{'prec'};
push @chain, pop(@termstack);
push @chain, pop(@opstack);
}
push @chain, pop(@termstack);
my $endpos = $chain[0]{'_pos'};
@chain = reverse @chain if @chain > 1;
my $startpos = $chain[0]{'_from'};
my $nop = $op->cursor_fresh();
$nop->{'chain'} = [@chain];
$nop->{'_arity'} = 'CHAIN';
$nop->{'_from'} = $startpos;
$nop->{'_pos'} = $endpos;
$nop->{'~CAPS'} = \@chain;
push @termstack, $nop->_REDUCE($startpos, 'CHAIN');
delete $termstack[-1]->{'PRE'};
delete $termstack[-1]->{'POST'};
}
when ('list') {
$self->deb("reducing list") if $::DEBUG & DEBUG::EXPR;
my @list;
my @delims = $op;
push @list, pop(@termstack);
while (@opstack) {
$self->deb($sym . " vs " . $opstack[-1]{'sym'}) if $::DEBUG & DEBUG::EXPR;
last if $sym ne $opstack[-1]{'sym'};
if (@termstack and defined $termstack[0]) {
push @list, pop(@termstack);
}
else {
$self->worry("Missing term in " . $sym . " list");
}
push @delims, pop(@opstack);
}
if (@termstack and defined $termstack[0]) {
push @list, pop(@termstack);
}
else {
$self->worry("Missing final term in '" . $sym . "' list");
}
my $endpos = $list[0]{'_pos'};
@list = reverse @list if @list > 1;
my $startpos = $list[0]{'_from'};
@delims = reverse @delims if @delims > 1;
my $nop = $op->cursor_fresh();
$nop->{'sym'} = $sym;
$nop->{'O'} = $op->{'O'};
$nop->{'list'} = [@list];
$nop->{'delims'} = [@delims];
$nop->{'_arity'} = 'LIST';
$nop->{'_from'} = $startpos;
$nop->{'_pos'} = $endpos;
if (@list) {
my @caps;
push @caps, $list[0]->caps if $list[0];
for (0..@delims-1) {
my $d = $delims[$_];
my $l = $list[$_+1];
push @caps, $d;
push @caps, $l;  # nullterm?
}
$nop->{'~CAPS'} = \@caps;
}
push @termstack, $nop->_REDUCE($startpos, 'LIST');
delete $termstack[-1]->{'PRE'};
delete $termstack[-1]->{'POST'};
}
when ('unary') {
$self->deb("reducing") if $::DEBUG & DEBUG::EXPR;
$self->deb("Termstack size: ", 0+@termstack) if $::DEBUG & DEBUG::EXPR;

$self->deb($op->dump) if $::DEBUG & DEBUG::EXPR;
my $nop = $op->cursor_fresh();
my $arg = pop @termstack;
$op->{'arg'} = $arg;
my $a = $op->{'~CAPS'};
$op->{'_arity'} = 'UNARY';
if ($arg->{'_from'} < $op->{'_from'}) { # postfix
$op->{'_from'} = $arg->{'_from'};   # extend from to include arg
#                    warn "OOPS ", $arg.Str, "\n" if @acaps > 1;
unshift @$a, $arg;
push @termstack, $op->_REDUCE($op->{'_from'}, 'POSTFIX');
delete $termstack[-1]->{'PRE'};
delete $termstack[-1]->{'POST'};
}
elsif ($arg->{'_pos'} > $op->{'_pos'}) {   # prefix
$op->{'_pos'} = $arg->{'_pos'};     # extend pos to include arg
#                    warn "OOPS ", $arg.Str, "\n" if @acaps > 1;
push @$a, $arg;
push @termstack, $op->_REDUCE($op->{'_from'}, 'PREFIX');
delete $termstack[-1]->{'PRE'};
delete $termstack[-1]->{'POST'};
}
}
default {
$self->deb("reducing") if $::DEBUG & DEBUG::EXPR;
$self->deb("Termstack size: ", 0+@termstack) if $::DEBUG & DEBUG::EXPR;

my $right = pop @termstack;
my $left = pop @termstack;
$op->{'right'} = $right;
$op->{'left'} = $left;
$op->{'_from'} = $left->{'_from'};
$op->{'_pos'} = $right->{'_pos'};
$op->{'_arity'} = 'BINARY';

my $a = $op->{'~CAPS'};
unshift @$a, $left;
push @$a, $right;

$self->deb($op->dump) if $::DEBUG & DEBUG::EXPR;
push @termstack, $op->_REDUCE($op->{'_from'}, 'INFIX');
delete $termstack[-1]->{'PRE'};
delete $termstack[-1]->{'POST'};
}
}
};

TERM:
for (;;) {
$self->deb("In loop, at ", $here->{'_pos'}) if $::DEBUG & DEBUG::EXPR;
my $oldpos = $here->{'_pos'};
$here = $here->cursor_fresh();
$::LEFTSIGIL = $opstack[-1]{'O'}{'prec'} gt $item_assignment_prec ? '@' : '';
my @t = $here->$termish;

if (not @t or not $here = $t[0] or ($here->{'_pos'} == $oldpos and $termish eq 'termish')) {
return ();
# $here.panic("Failed to parse a required term");
}
$termish = 'termish';
my $PRE = delete $here->{'PRE'} // [];
my $POST = delete $here->{'POST'} // [];
my @PRE = @$PRE;
my @POST = reverse @$POST;

# interleave prefix and postfix, pretend they're infixish
my $M = $here;

# note that we push loose stuff onto opstack before tight stuff
while (@PRE and @POST) {
my $postO = $POST[0]{'O'};
my $preO = $PRE[0]{'O'};
if ($postO->{'prec'} lt $preO->{'prec'}) {
push @opstack, shift @POST;
}
elsif ($postO->{'prec'} gt $preO->{'prec'}) {
push @opstack, shift @PRE;
}
elsif ($postO->{'uassoc'} eq 'left') {
push @opstack, shift @POST;
}
elsif ($postO->{'uassoc'} eq 'right') {
push @opstack, shift @PRE;
}
else {
$here->panic('"' . $PRE[0]{'sym'} . '" and "' . $POST[0]{'sym'} . '" are not associative');
}
}
push @opstack, @PRE,@POST;

push @termstack, $here->{'noun'};
delete $termstack[-1]->{'POST'};
$self->deb("after push: " . (0+@termstack)) if $::DEBUG & DEBUG::EXPR;

last TERM if $preclim eq $methodcall_prec; # in interpolation, probably

for (;;) {     # while we see adverbs
$oldpos = $here->{'_pos'};
last TERM if ($::MEMOS[$oldpos]{'endstmt'} // 0) == 2;
$here = $here->cursor_fresh->ws;
my @infix = $here->cursor_fresh->infixish();
last TERM unless @infix;
my $infix = $infix[0];
last TERM unless $infix->{'_pos'} > $oldpos;

if (not $infix->{'sym'}) {
die $infix->dump if $::DEBUG & DEBUG::EXPR;
}

my $inO = $infix->{'O'};
my $inprec = $inO->{'prec'};
if (not defined $inprec) {
$self->deb("No prec given in infix!") if $::DEBUG & DEBUG::EXPR;
die $infix->dump if $::DEBUG & DEBUG::EXPR;
$inprec = $terminator{'prec'};
}

if ($inprec le $preclim) {
if ($preclim ne $LOOSEST) {
my $dba = $preclvl->{'dba'};
my $h = $::HIGHEXPECT;
my $k = 'infix or meta-infix';
delete $h->{$k};
$h->{"infix or meta-infix (with precedence tighter than $dba)"} = 1;
}
last TERM;
}

$here = $infix->cursor_fresh->ws();

# substitute precedence for listops
$inO->{'prec'} = $inO->{'sub'} if $inO->{'sub'};

# Does new infix (or terminator) force any reductions?
while ($opstack[-1]{'O'}{'prec'} gt $inprec) {
$reduce->();
}

# Not much point in reducing the sentinels...
last if $inprec lt $LOOSEST;

if ($infix->{'fake'}) {
push @opstack, $infix;
$reduce->();
next;  # not really an infix, so keep trying
}

# Equal precedence, so use associativity to decide.
if ($opstack[-1]{'O'}{'prec'} eq $inprec) {
given ($inO->{'assoc'}) {
when ('non')   { $here->panic('"' . $infix->Str . '" is not associative') }
when ('left')  { $reduce->() }   # reduce immediately
when ('right') { }            # just shift
when ('chain') { }            # just shift
when ('unary') { }            # just shift
when ('list')  {              # if op differs reduce else shift
# &reduce() if $infix<sym> !eqv @opstack[*-1]<sym>;
}
default { $here->panic('Unknown associativity "' . $_ . '" for "' . $infix->{'sym'} . '"') }
}
}

$termish = $inO->{'nextterm'} if $inO->{'nextterm'};
push @opstack, $infix;              # The Shift
last;
}
}
$reduce->() while 0+@opstack > 1;
if (@termstack) {
0+@termstack == 1 or $here->panic("Internal operator parser error, termstack == " . (0+@termstack));
$termstack[0]{'_from'} = $self->{'_pos'};
$termstack[0]{'_pos'} = $here->{'_pos'};
}
$self->_MATCHIFYr($S, "EXPR", @termstack);
}

##########
## Regex #
##########

{ package STD::Regex;
use Moose ':all' => { -prefix => "moose_" };
my $retree;
moose_extends(qw(STD));
sub multitweak { # begin tweaks
my $self = shift;
my ($k, $v) = @_;

if (0) {}
elsif ($k eq 'Perl5' or $k eq 'P5') {
my $P5 = $v;  $self->cursor_fresh( $::LANG{'Q'} )->mixin( 'STD::Q::q' )->mixin( 'STD::Q::p5' ) }
elsif ($k eq 'overlap' or $k eq 'ov') {
my $ov = $v;  $self }
elsif ($k eq 'exhaustive' or $k eq 'ex') {
my $ex = $v;  $self }
elsif ($k eq 'continue' or $k eq 'c') {
my $c = $v;  $self }
elsif ($k eq 'pos' or $k eq 'p') {
my $p = $v;  $self }
elsif ($k eq 'sigspace' or $k eq 's') {
my $s = $v;  $self }
elsif ($k eq 'ratchet' or $k eq 'r') {
my $r = $v;  $self }
elsif ($k eq 'global' or $k eq 'g') {
my $g = $v;  $self }
elsif ($k eq 'ignorecase' or $k eq 'i') {
my $i = $v;  $self }
elsif ($k eq 'ignoreaccent' or $k eq 'a') {
my $a = $v;  $self }
elsif ($k eq 'samecase' or $k eq 'ii') {
my $ii = $v;  $self }
elsif ($k eq 'sameaccent' or $k eq 'aa') {
my $aa = $v;  $self }
elsif ($k eq 'nth') {
my $nth = $v;  $self }
elsif ($k eq 'st' or $k eq 'nd') {
my $nd = $v;  $self }
elsif ($k eq 'rd' or $k eq 'th') {
my $th = $v;  $self }
elsif ($k eq 'x') {
my $x = $v;  $self }
elsif ($k eq 'bytes') {
my $bytes = $v;  $self }
elsif ($k eq 'codes') {
my $codes = $v;  $self }
elsif ($k eq 'graphs') {
my $graphs = $v;  $self }
elsif ($k eq 'chars') {
my $chars = $v;  $self }
elsif ($k eq 'rw') {
my $rw = $v;  $self }
elsif ($k eq 'keepall') {
my $keepall = $v;  $self }
elsif ($k eq 'panic') {
my $panic = $v;  $self }
else { die 'NOMATCH' }
} # end tweaks

##     token category__S_442metachar (:$sym is context<rw> = 'metachar')
##          token category:metachar { <sym> }

sub category__S_442metachar__PEEK { $_[0]->_AUTOLEXpeek('category__S_442metachar',$retree) }
sub category__S_442metachar {
my $self = shift;
local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;
my %args = @_;
local $sym = $args{sym} // 'metachar';


my $C = $self;
my $S = $C->{'_pos'};
$C->{'sym'} = $sym;

$self->_MATCHIFYr($S, "category__S_442metachar", 
$C->_PATTERN(qr/\Gmetachar/)
);
}
#proto token metachar { <...> }
sub metachar__PEEK { $_[0]->_AUTOLEXpeek('metachar:*',$retree); }
sub metachar {
my $self = shift;
my $subs;

local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;

my $C = $self;
my $S = $C->{'_pos'};

my @result = eval {
my $trystate;
my ($tag, $try);
my @try;
my $relex;
if (my $fate = $C->{'_fate'}) {
if ($fate->[1] eq 'metachar') {
$C->deb("Fate passed to metachar: ", ::fatestr($fate)) if $::DEBUG & DEBUG::fates;
($C->{'_fate'}, $tag, $try) = @$fate;
@try = ($try);
}
}

my @gather = ();
for (;;) {
if (not @try) {
$relex //= $C->cursor_fate('STD::Regex', 'metachar:*', $retree);
@try = $relex->($C, $trystate);
}
last unless @try;
$try = shift(@try) // next;

if (ref $try eq 'ARRAY') {
($C->{'_fate'}, $tag, $try) = @$try;	# next candidate fate
}

$C->deb("metachar trying $tag $try") if $::DEBUG & DEBUG::try_processing;
push @gather, $C->$try(@_);
last if @gather;
}
$self->_MATCHIFY($S, "metachar", @gather);
};
if ($@) {
return () if $@ =~ /^ABORTRULE/;
die $@;
}
@result;
}


##     token category__S_443backslash (:$sym is context<rw> = 'backslash')
##          token category:backslash { <sym> }

sub category__S_443backslash__PEEK { $_[0]->_AUTOLEXpeek('category__S_443backslash',$retree) }
sub category__S_443backslash {
my $self = shift;
local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;
my %args = @_;
local $sym = $args{sym} // 'backslash';


my $C = $self;
my $S = $C->{'_pos'};
$C->{'sym'} = $sym;

$self->_MATCHIFYr($S, "category__S_443backslash", 
$C->_PATTERN(qr/\Gbackslash/)
);
}
#proto token backslash { <...> }
sub backslash__PEEK { $_[0]->_AUTOLEXpeek('backslash:*',$retree); }
sub backslash {
my $self = shift;
my $subs;

local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;

my $C = $self;
my $S = $C->{'_pos'};

my @result = eval {
my $trystate;
my ($tag, $try);
my @try;
my $relex;
if (my $fate = $C->{'_fate'}) {
if ($fate->[1] eq 'backslash') {
$C->deb("Fate passed to backslash: ", ::fatestr($fate)) if $::DEBUG & DEBUG::fates;
($C->{'_fate'}, $tag, $try) = @$fate;
@try = ($try);
}
}

my @gather = ();
for (;;) {
if (not @try) {
$relex //= $C->cursor_fate('STD::Regex', 'backslash:*', $retree);
@try = $relex->($C, $trystate);
}
last unless @try;
$try = shift(@try) // next;

if (ref $try eq 'ARRAY') {
($C->{'_fate'}, $tag, $try) = @$try;	# next candidate fate
}

$C->deb("backslash trying $tag $try") if $::DEBUG & DEBUG::try_processing;
push @gather, $C->$try(@_);
last if @gather;
}
$self->_MATCHIFY($S, "backslash", @gather);
};
if ($@) {
return () if $@ =~ /^ABORTRULE/;
die $@;
}
@result;
}


##     token category__S_444assertion (:$sym is context<rw> = 'assertion')
##          token category:assertion { <sym> }

sub category__S_444assertion__PEEK { $_[0]->_AUTOLEXpeek('category__S_444assertion',$retree) }
sub category__S_444assertion {
my $self = shift;
local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;
my %args = @_;
local $sym = $args{sym} // 'assertion';


my $C = $self;
my $S = $C->{'_pos'};
$C->{'sym'} = $sym;

$self->_MATCHIFYr($S, "category__S_444assertion", 
$C->_PATTERN(qr/\Gassertion/)
);
}
#proto token assertion { <...> }
sub assertion__PEEK { $_[0]->_AUTOLEXpeek('assertion:*',$retree); }
sub assertion {
my $self = shift;
my $subs;

local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;

my $C = $self;
my $S = $C->{'_pos'};

my @result = eval {
my $trystate;
my ($tag, $try);
my @try;
my $relex;
if (my $fate = $C->{'_fate'}) {
if ($fate->[1] eq 'assertion') {
$C->deb("Fate passed to assertion: ", ::fatestr($fate)) if $::DEBUG & DEBUG::fates;
($C->{'_fate'}, $tag, $try) = @$fate;
@try = ($try);
}
}

my @gather = ();
for (;;) {
if (not @try) {
$relex //= $C->cursor_fate('STD::Regex', 'assertion:*', $retree);
@try = $relex->($C, $trystate);
}
last unless @try;
$try = shift(@try) // next;

if (ref $try eq 'ARRAY') {
($C->{'_fate'}, $tag, $try) = @$try;	# next candidate fate
}

$C->deb("assertion trying $tag $try") if $::DEBUG & DEBUG::try_processing;
push @gather, $C->$try(@_);
last if @gather;
}
$self->_MATCHIFY($S, "assertion", @gather);
};
if ($@) {
return () if $@ =~ /^ABORTRULE/;
die $@;
}
@result;
}


##     token category__S_445quantifier (:$sym is context<rw> = 'quantifier')
##          token category:quantifier { <sym> }

sub category__S_445quantifier__PEEK { $_[0]->_AUTOLEXpeek('category__S_445quantifier',$retree) }
sub category__S_445quantifier {
my $self = shift;
local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;
my %args = @_;
local $sym = $args{sym} // 'quantifier';


my $C = $self;
my $S = $C->{'_pos'};
$C->{'sym'} = $sym;

$self->_MATCHIFYr($S, "category__S_445quantifier", 
$C->_PATTERN(qr/\Gquantifier/)
);
}
#proto token quantifier { <...> }
sub quantifier__PEEK { $_[0]->_AUTOLEXpeek('quantifier:*',$retree); }
sub quantifier {
my $self = shift;
my $subs;

local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;

my $C = $self;
my $S = $C->{'_pos'};

my @result = eval {
my $trystate;
my ($tag, $try);
my @try;
my $relex;
if (my $fate = $C->{'_fate'}) {
if ($fate->[1] eq 'quantifier') {
$C->deb("Fate passed to quantifier: ", ::fatestr($fate)) if $::DEBUG & DEBUG::fates;
($C->{'_fate'}, $tag, $try) = @$fate;
@try = ($try);
}
}

my @gather = ();
for (;;) {
if (not @try) {
$relex //= $C->cursor_fate('STD::Regex', 'quantifier:*', $retree);
@try = $relex->($C, $trystate);
}
last unless @try;
$try = shift(@try) // next;

if (ref $try eq 'ARRAY') {
($C->{'_fate'}, $tag, $try) = @$try;	# next candidate fate
}

$C->deb("quantifier trying $tag $try") if $::DEBUG & DEBUG::try_processing;
push @gather, $C->$try(@_);
last if @gather;
}
$self->_MATCHIFY($S, "quantifier", @gather);
};
if ($@) {
return () if $@ =~ /^ABORTRULE/;
die $@;
}
@result;
}


##     token category__S_446mod_internal (:$sym is context<rw> = 'mod_internal')
##          token category:mod_internal { <sym> }

sub category__S_446mod_internal__PEEK { $_[0]->_AUTOLEXpeek('category__S_446mod_internal',$retree) }
sub category__S_446mod_internal {
my $self = shift;
local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;
my %args = @_;
local $sym = $args{sym} // 'mod_internal';


my $C = $self;
my $S = $C->{'_pos'};
$C->{'sym'} = $sym;

$self->_MATCHIFYr($S, "category__S_446mod_internal", 
$C->_PATTERN(qr/\Gmod_internal/)
);
}
#proto token mod_internal { <...> }
sub mod_internal__PEEK { $_[0]->_AUTOLEXpeek('mod_internal:*',$retree); }
sub mod_internal {
my $self = shift;
my $subs;

local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;

my $C = $self;
my $S = $C->{'_pos'};

my @result = eval {
my $trystate;
my ($tag, $try);
my @try;
my $relex;
if (my $fate = $C->{'_fate'}) {
if ($fate->[1] eq 'mod_internal') {
$C->deb("Fate passed to mod_internal: ", ::fatestr($fate)) if $::DEBUG & DEBUG::fates;
($C->{'_fate'}, $tag, $try) = @$fate;
@try = ($try);
}
}

my @gather = ();
for (;;) {
if (not @try) {
$relex //= $C->cursor_fate('STD::Regex', 'mod_internal:*', $retree);
@try = $relex->($C, $trystate);
}
last unless @try;
$try = shift(@try) // next;

if (ref $try eq 'ARRAY') {
($C->{'_fate'}, $tag, $try) = @$try;	# next candidate fate
}

$C->deb("mod_internal trying $tag $try") if $::DEBUG & DEBUG::try_processing;
push @gather, $C->$try(@_);
last if @gather;
}
$self->_MATCHIFY($S, "mod_internal", @gather);
};
if ($@) {
return () if $@ =~ /^ABORTRULE/;
die $@;
}
@result;
}


#proto token regex_infix { <...> }
sub regex_infix__PEEK { $_[0]->_AUTOLEXpeek('regex_infix:*',$retree); }
sub regex_infix {
my $self = shift;
my $subs;

local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;

my $C = $self;
my $S = $C->{'_pos'};

my @result = eval {
my $trystate;
my ($tag, $try);
my @try;
my $relex;
if (my $fate = $C->{'_fate'}) {
if ($fate->[1] eq 'regex_infix') {
$C->deb("Fate passed to regex_infix: ", ::fatestr($fate)) if $::DEBUG & DEBUG::fates;
($C->{'_fate'}, $tag, $try) = @$fate;
@try = ($try);
}
}

my @gather = ();
for (;;) {
if (not @try) {
$relex //= $C->cursor_fate('STD::Regex', 'regex_infix:*', $retree);
@try = $relex->($C, $trystate);
}
last unless @try;
$try = shift(@try) // next;

if (ref $try eq 'ARRAY') {
($C->{'_fate'}, $tag, $try) = @$try;	# next candidate fate
}

$C->deb("regex_infix trying $tag $try") if $::DEBUG & DEBUG::try_processing;
push @gather, $C->$try(@_);
last if @gather;
}
$self->_MATCHIFY($S, "regex_infix", @gather);
};
if ($@) {
return () if $@ =~ /^ABORTRULE/;
die $@;
}
@result;
}


##     token ws
##          token ws {
##              <?{ $*sigspace }>
##              || [ <?before \s | '#'> <.nextsame> ]?   # still get all the pod goodness, hopefully
##          }

sub ws__PEEK { '' }
sub ws {
my $self = shift;
my @origargs = @_;
local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;


my $C = $self;
my $S = $C->{'_pos'};

$self->_MATCHIFYr($S, "ws", 
do { my @gather;
eval { push @gather, $C->before( sub { my $C=shift;
(($C) x !!do {
$::sigspace 
})
})} // do {die $@ if $@ and $@ !~ /ABORT/;1} 
or
eval { push @gather, $C->_OPTr(sub { my $C=shift;
$C->_BRACKETr( sub { my $C=shift;
do {
if (my ($C) = ($C->before(sub { my $C=shift;
do {
my @result = eval {
my $trystate;
my ($tag, $try);
my @try;
my $relex;

my $fate;
if ($fate = $C->{'_fate'} and $fate->[1] eq 'ws_03') {
$C->deb("Fate passed to ws_03: ", ::fatestr($fate)) if $::DEBUG & DEBUG::fates;
($C->{'_fate'}, $tag, $try) = @$fate;
@try = ($try);
}

my @gather = ();
for (;;) {
if (not @try) {
$relex //= $C->cursor_fate('STD::Regex', 'ws_03', $retree);
@try = $relex->($C, $trystate);
}
last unless @try;
$try = shift(@try) // next;

if (ref $try eq 'ARRAY') {
($C->{'_fate'}, $tag, $try) = @$try;	# next candidate fate
}

$C->deb("ws_03 trying $tag $try") if $::DEBUG & DEBUG::try_processing;
push @gather, ((
sub { my $C=shift;
$C->_PATTERN(qr/\G\s/)
},
sub { my $C=shift;
$C->_EXACT('#')
},
)[$try])->($C);
last if @gather;
}
@gather;
};
if (@result) {
@result;
}
elsif ($@) {
my ($first) = $@ =~ /(^.*)/;
$self->deb("CAUGHT $first") if $::DEBUG & DEBUG::trace_call;
die $@ if $@ !~ /^ABORTBRANCH/;
();
}
else {
();
}
}

}))) {
$self->SUPER::ws(@origargs);
}
else {
();
}
}
})
})} or do { die $@ if $@ };
@gather;
}
);
}

##     token normspace
##          token normspace {
##              <?before \s | '#'> [ :lang($¢.cursor_fresh(%*LANG<MAIN>)) <.ws> ]
##          }

sub normspace__PEEK { $_[0]->_AUTOLEXpeek('normspace',$retree) }
sub normspace {
my $self = shift;
local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;


my $C = $self;
my $S = $C->{'_pos'};

$self->_MATCHIFYr($S, "normspace", 
do {
if (my ($C) = ($C->before(sub { my $C=shift;
do {
my @result = eval {
my $trystate;
my ($tag, $try);
my @try;
my $relex;

my $fate;
if ($fate = $C->{'_fate'} and $fate->[1] eq 'normspace_01') {
$C->deb("Fate passed to normspace_01: ", ::fatestr($fate)) if $::DEBUG & DEBUG::fates;
($C->{'_fate'}, $tag, $try) = @$fate;
@try = ($try);
}

my @gather = ();
for (;;) {
if (not @try) {
$relex //= $C->cursor_fate('STD::Regex', 'normspace_01', $retree);
@try = $relex->($C, $trystate);
}
last unless @try;
$try = shift(@try) // next;

if (ref $try eq 'ARRAY') {
($C->{'_fate'}, $tag, $try) = @$try;	# next candidate fate
}

$C->deb("normspace_01 trying $tag $try") if $::DEBUG & DEBUG::try_processing;
push @gather, ((
sub { my $C=shift;
$C->_PATTERN(qr/\G\s/)
},
sub { my $C=shift;
$C->_EXACT('#')
},
)[$try])->($C);
last if @gather;
}
@gather;
};
if (@result) {
@result;
}
elsif ($@) {
my ($first) = $@ =~ /(^.*)/;
$self->deb("CAUGHT $first") if $::DEBUG & DEBUG::trace_call;
die $@ if $@ !~ /^ABORTBRANCH/;
();
}
else {
();
}
}

}))) {
$C->_BRACKETr( sub { my $C=shift;
my $newlang = ($C->cursor_fresh($::LANG{'MAIN'}));  $C = $C->cursor_fresh($newlang); ;$C->ws
});
}
else {
();
}
}
);
}

##     token unsp
##          token unsp { '\\' <?before \s | '#'> <.panic: "No unspace allowed in regex (for literal please quote with single quotes)"> }

sub unsp__PEEK { $_[0]->_AUTOLEXpeek('unsp',$retree) }
sub unsp {
my $self = shift;
local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;


my $C = $self;
my $S = $C->{'_pos'};

$self->_MATCHIFYr($S, "unsp", 
do {
if (my ($C) = ($C->_EXACT('\\'))) {
do {
if (my ($C) = ($C->before(sub { my $C=shift;
do {
my @result = eval {
my $trystate;
my ($tag, $try);
my @try;
my $relex;

my $fate;
if ($fate = $C->{'_fate'} and $fate->[1] eq 'unsp_01') {
$C->deb("Fate passed to unsp_01: ", ::fatestr($fate)) if $::DEBUG & DEBUG::fates;
($C->{'_fate'}, $tag, $try) = @$fate;
@try = ($try);
}

my @gather = ();
for (;;) {
if (not @try) {
$relex //= $C->cursor_fate('STD::Regex', 'unsp_01', $retree);
@try = $relex->($C, $trystate);
}
last unless @try;
$try = shift(@try) // next;

if (ref $try eq 'ARRAY') {
($C->{'_fate'}, $tag, $try) = @$try;	# next candidate fate
}

$C->deb("unsp_01 trying $tag $try") if $::DEBUG & DEBUG::try_processing;
push @gather, ((
sub { my $C=shift;
$C->_PATTERN(qr/\G\s/)
},
sub { my $C=shift;
$C->_EXACT('#')
},
)[$try])->($C);
last if @gather;
}
@gather;
};
if (@result) {
@result;
}
elsif ($@) {
my ($first) = $@ =~ /(^.*)/;
$self->deb("CAUGHT $first") if $::DEBUG & DEBUG::trace_call;
die $@ if $@ !~ /^ABORTBRANCH/;
();
}
else {
();
}
}

}))) {
$C->panic("No unspace allowed in regex (for literal please quote with single quotes)");
}
else {
();
}
};
}
else {
();
}
}
);
}  # no unspace in regexen

# suppress fancy end-of-line checking
##     token codeblock
##          token codeblock {
##              :my $GOAL is context = '}';
##              '{' :: [ :lang($¢.cursor_fresh(%*LANG<MAIN>)) <statementlist> ]
##              [ '}' || <.panic: "Unable to parse statement list; couldn't find right brace"> ]
##          }

sub codeblock__PEEK { $_[0]->_AUTOLEXpeek('codeblock',$retree) }
sub codeblock {
my $self = shift;
local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;
local $::GOAL = '}';


my $C = $self;
my $S = $C->{'_pos'};

$self->_MATCHIFY($S, "codeblock", 
Cursor::lazymap(sub { my $C=$_[0];
Cursor::lazymap(sub { my $C=$_[0];
Cursor::lazymap(sub { my $C=$_[0];
$C->_BRACKET( sub { my $C=shift;
do { my @gather;
eval { push @gather, $C->_EXACT('}')} // do {die $@ if $@ and $@ !~ /ABORT/;1} 
or
eval { push @gather, $C->panic("Unable to parse statement list; couldn't find right brace")} or do { die $@ if $@ };
@gather;
}
})
}, $C->_BRACKET( sub { my $C=shift;
my $newlang = ($C->cursor_fresh($::LANG{'MAIN'}));  $C = $C->cursor_fresh($newlang); ;$C->_SUBSUME(['statementlist'], sub {
my $C = shift;
$C->statementlist
})
}))
}, $C->_COMMITBRANCH())
}, $C->_EXACT('{'))
);
}

##     rule nibbler
##          rule nibbler {
##              :my $sigspace    is context<rw> = $*sigspace    // 0;
##              :my $ratchet     is context<rw> = $*ratchet     // 0;
##              :my $ignorecase is context<rw> = $*ignorecase // 0;
##              :my $ignoreaccent    is context<rw> = $*ignoreaccent    // 0;
##              [ \s* < || | && & > ]?
##              <EXPR>
##          }

sub nibbler__PEEK { $_[0]->_AUTOLEXpeek('nibbler',$retree) }
sub nibbler {
my $self = shift;
local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;
local $::sigspace = $::sigspace    // 0;
local $::ratchet = $::ratchet     // 0;
local $::ignorecase = $::ignorecase // 0;
local $::ignoreaccent = $::ignoreaccent    // 0;


my $C = $self;
my $S = $C->{'_pos'};

$self->_MATCHIFYr($S, "nibbler", 
do {
if (my ($C) = ($C->ws)) {
do {
if (my ($C) = ($C->_OPTr(sub { my $C=shift;
$C->_BRACKETr( sub { my $C=shift;
do {
if (my ($C) = ($C->ws)) {
do {
if (my ($C) = ($C->_PATTERN(qr/\G((?:\s)*+)/))) {
do {
if (my ($C) = ($C->ws)) {
do {
if (my ($C) = ($C->_ARRAY( qw< || | && & > ))) {
$C->ws;
}
else {
();
}
};
}
else {
();
}
};
}
else {
();
}
};
}
else {
();
}
}
})
}))) {
do {
if (my ($C) = ($C->ws)) {
do {
if (my ($C) = ($C->_SUBSUMEr(['EXPR'], sub {
my $C = shift;
$C->EXPR
}))) {
$C->ws;
}
else {
();
}
};
}
else {
();
}
};
}
else {
();
}
};
}
else {
();
}
}
);
}

##     token termish
##          token termish {
##              <.ws>
##              [
##              || <noun=quantified_atom>+
##              || <?before <stopper> | <[&|~]>  >  <.panic: "Null pattern not allowed">
##              || <?before <[ \] \) \> ]> > <.panic: "Unmatched closing bracket">
##              || <.panic: "Unrecognized regex metacharacter (must be quoted to match literally)">
##              ]
##          }

sub termish__PEEK { $_[0]->_AUTOLEXpeek('termish',$retree) }
sub termish {
my $self = shift;
local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;


my $C = $self;
my $S = $C->{'_pos'};
$C->{'quantified_atom'} = [];

$self->_MATCHIFYr($S, "termish", 
do {
if (my ($C) = ($C->ws)) {
$C->_BRACKETr( sub { my $C=shift;
do { my @gather;
eval { push @gather,     $C->_PLUSr(sub { my $C=shift;
$C->_SUBSUMEr(['noun','quantified_atom'], sub {
my $C = shift;
$C->quantified_atom
})
})} // do {die $@ if $@ and $@ !~ /ABORT/;1} 
or
eval { push @gather, do {
if (my ($C) = ($C->before(sub { my $C=shift;
do {
my @result = eval {
my $trystate;
my ($tag, $try);
my @try;
my $relex;

my $fate;
if ($fate = $C->{'_fate'} and $fate->[1] eq 'termish_03') {
$C->deb("Fate passed to termish_03: ", ::fatestr($fate)) if $::DEBUG & DEBUG::fates;
($C->{'_fate'}, $tag, $try) = @$fate;
@try = ($try);
}

my @gather = ();
for (;;) {
if (not @try) {
$relex //= $C->cursor_fate('STD::Regex', 'termish_03', $retree);
@try = $relex->($C, $trystate);
}
last unless @try;
$try = shift(@try) // next;

if (ref $try eq 'ARRAY') {
($C->{'_fate'}, $tag, $try) = @$try;	# next candidate fate
}

$C->deb("termish_03 trying $tag $try") if $::DEBUG & DEBUG::try_processing;
push @gather, ((
sub { my $C=shift;
$C->_SUBSUMEr(['stopper'], sub {
my $C = shift;
$C->stopper
})
},
sub { my $C=shift;
$C->_PATTERN(qr/\G[&|~]/)
},
)[$try])->($C);
last if @gather;
}
@gather;
};
if (@result) {
@result;
}
elsif ($@) {
my ($first) = $@ =~ /(^.*)/;
$self->deb("CAUGHT $first") if $::DEBUG & DEBUG::trace_call;
die $@ if $@ !~ /^ABORTBRANCH/;
();
}
else {
();
}
}

}))) {
$C->panic("Null pattern not allowed");
}
else {
();
}
}} // do {die $@ if $@ and $@ !~ /ABORT/;1} 
or
eval { push @gather, do {
if (my ($C) = ($C->before(sub { my $C=shift;
$C->_PATTERN(qr/\G[\]\)\>]/)
}))) {
$C->panic("Unmatched closing bracket");
}
else {
();
}
}} // do {die $@ if $@ and $@ !~ /ABORT/;1} 
or
eval { push @gather, $C->panic("Unrecognized regex metacharacter (must be quoted to match literally)")} or do { die $@ if $@ };
@gather;
}
});
}
else {
();
}
}
);
}
##     token infixish
##          token infixish {
##              <!infixstopper>
##              <!stdstopper>
##              <regex_infix>
##              {
##                  $<O> = $<regex_infix><O>;
##                  $<sym> = $<regex_infix><sym>;
##              }
##          }

sub infixish__PEEK { $_[0]->_AUTOLEXpeek('infixish',$retree) }
sub infixish {
my $self = shift;
local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;


my $C = $self;
my $S = $C->{'_pos'};

$self->_MATCHIFYr($S, "infixish", 
do {
if (my ($C) = ($C->_NOTBEFORE( sub { my $C=shift;
$C->infixstopper
}))) {
do {
if (my ($C) = ($C->_NOTBEFORE( sub { my $C=shift;
$C->stdstopper
}))) {
do {
if (my ($C) = ($C->_SUBSUMEr(['regex_infix'], sub {
my $C = shift;
$C->regex_infix
}))) {
scalar(do {
my $M = $C; 
$M->{'O'} = $M->{'regex_infix'}{'O'};
$M->{'sym'} = $M->{'regex_infix'}{'sym'};
;
}, $C);
}
else {
();
}
};
}
else {
();
}
};
}
else {
();
}
}
);
}

##     token regex_infix__S_447VertVert (  :$sym is context<rw> = <||> --> Tight_or )
##          token regex_infix:sym<||> ( --> Tight_or ) { <sym> }

sub regex_infix__S_447VertVert__PEEK { $_[0]->_AUTOLEXpeek('regex_infix__S_447VertVert',$retree) }
sub regex_infix__S_447VertVert {
my $self = shift;
local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;
my %args = @_;
local $sym = $args{sym} // q(||);


my $C = $self;
my $S = $C->{'_pos'};
$C->{'sym'} = $sym;

$self->_MATCHIFYr($S, "regex_infix__S_447VertVert",  map { STD::Tight_or->coerce($_) } 
$C->_PATTERN(qr/\G\|\|/)
);
}
##     token regex_infix__S_448AmpAmp (  :$sym is context<rw> = <&&> --> Tight_and )
##          token regex_infix:sym<&&> ( --> Tight_and ) { <sym> }

sub regex_infix__S_448AmpAmp__PEEK { $_[0]->_AUTOLEXpeek('regex_infix__S_448AmpAmp',$retree) }
sub regex_infix__S_448AmpAmp {
my $self = shift;
local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;
my %args = @_;
local $sym = $args{sym} // q(&&);


my $C = $self;
my $S = $C->{'_pos'};
$C->{'sym'} = $sym;

$self->_MATCHIFYr($S, "regex_infix__S_448AmpAmp",  map { STD::Tight_and->coerce($_) } 
$C->_PATTERN(qr/\G\&\&/)
);
}
##     token regex_infix__S_449Vert (  :$sym is context<rw> = <|> --> Junctive_or )
##          token regex_infix:sym<|> ( --> Junctive_or ) { <sym> }

sub regex_infix__S_449Vert__PEEK { $_[0]->_AUTOLEXpeek('regex_infix__S_449Vert',$retree) }
sub regex_infix__S_449Vert {
my $self = shift;
local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;
my %args = @_;
local $sym = $args{sym} // q(|);


my $C = $self;
my $S = $C->{'_pos'};
$C->{'sym'} = $sym;

$self->_MATCHIFYr($S, "regex_infix__S_449Vert",  map { STD::Junctive_or->coerce($_) } 
$C->_PATTERN(qr/\G\|/)
);
}
##     token regex_infix__S_450Amp (  :$sym is context<rw> = <&> --> Junctive_and )
##          token regex_infix:sym<&> ( --> Junctive_and ) { <sym> }

sub regex_infix__S_450Amp__PEEK { $_[0]->_AUTOLEXpeek('regex_infix__S_450Amp',$retree) }
sub regex_infix__S_450Amp {
my $self = shift;
local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;
my %args = @_;
local $sym = $args{sym} // q(&);


my $C = $self;
my $S = $C->{'_pos'};
$C->{'sym'} = $sym;

$self->_MATCHIFYr($S, "regex_infix__S_450Amp",  map { STD::Junctive_and->coerce($_) } 
$C->_PATTERN(qr/\G\&/)
);
}
##     token regex_infix__S_451Tilde (  :$sym is context<rw> = <~> --> Additive )
##          token regex_infix:sym<~> ( --> Additive ) { <sym> }

sub regex_infix__S_451Tilde__PEEK { $_[0]->_AUTOLEXpeek('regex_infix__S_451Tilde',$retree) }
sub regex_infix__S_451Tilde {
my $self = shift;
local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;
my %args = @_;
local $sym = $args{sym} // q(~);


my $C = $self;
my $S = $C->{'_pos'};
$C->{'sym'} = $sym;

$self->_MATCHIFYr($S, "regex_infix__S_451Tilde",  map { STD::Additive->coerce($_) } 
$C->_PATTERN(qr/\G\~/)
);
}

##     token quantified_atom
##          token quantified_atom {
##              <!stopper>
##              <!regex_infix>
##              <atom>
##              <.ws>
##              [ <quantifier> <.ws> ]?
##      #            <?{ $<atom>.max_width }>
##      #                || <.panic: "Can't quantify zero-width atom">
##          }

sub quantified_atom__PEEK { $_[0]->_AUTOLEXpeek('quantified_atom',$retree) }
sub quantified_atom {
my $self = shift;
local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;


my $C = $self;
my $S = $C->{'_pos'};
$C->{'quantifier'} = [];

$self->_MATCHIFYr($S, "quantified_atom", 
do {
if (my ($C) = ($C->_NOTBEFORE( sub { my $C=shift;
$C->stopper
}))) {
do {
if (my ($C) = ($C->_NOTBEFORE( sub { my $C=shift;
$C->regex_infix
}))) {
do {
if (my ($C) = ($C->_SUBSUMEr(['atom'], sub {
my $C = shift;
$C->atom
}))) {
do {
if (my ($C) = ($C->ws)) {
$C->_OPTr(sub { my $C=shift;
$C->_BRACKETr( sub { my $C=shift;
do {
if (my ($C) = ($C->_SUBSUMEr(['quantifier'], sub {
my $C = shift;
$C->quantifier
}))) {
$C->ws;
}
else {
();
}
}
})
});
}
else {
();
}
};
}
else {
();
}
};
}
else {
();
}
};
}
else {
();
}
}
);
}

##     token atom
##          token atom {
##              :dba('regex atom')
##              [
##              | \w
##              | <metachar> ::
##              ]
##          }

sub atom__PEEK { $_[0]->_AUTOLEXpeek('atom',$retree) }
sub atom {
my $self = shift;
local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;


my $C = $self;
my $S = $C->{'_pos'};

$self->_MATCHIFY($S, "atom", 
$C->_BRACKET( sub { my $C=shift;
do {
my @result = eval {
my $trystate;
my ($tag, $try);
my @try;
my $relex;

my $fate;
if ($fate = $C->{'_fate'} and $fate->[1] eq 'atom_01') {
$C->deb("Fate passed to atom_01: ", ::fatestr($fate)) if $::DEBUG & DEBUG::fates;
($C->{'_fate'}, $tag, $try) = @$fate;
@try = ($try);
}

my @gather = ();
for (;;) {
if (not @try) {
$relex //= $C->cursor_fate('STD::Regex', 'atom_01', $retree);
@try = $relex->($C, $trystate);
}
last unless @try;
$try = shift(@try) // next;

if (ref $try eq 'ARRAY') {
($C->{'_fate'}, $tag, $try) = @$try;	# next candidate fate
}

$C->deb("atom_01 trying $tag $try") if $::DEBUG & DEBUG::try_processing;
push @gather, ((
sub { my $C=shift;
$C->_PATTERN(qr/\G\w/)
},
sub { my $C=shift;
Cursor::lazymap(sub { my $C=$_[0];
$C->_COMMITBRANCH()
}, $C->_SUBSUMEr(['metachar'], sub {
my $C = shift;
$C->metachar
}))
},
)[$try])->($C);
last if @gather;
}
@gather;
};
if (@result) {
@result;
}
elsif ($@) {
my ($first) = $@ =~ /(^.*)/;
$self->deb("CAUGHT $first") if $::DEBUG & DEBUG::trace_call;
die $@ if $@ !~ /^ABORTBRANCH/;
();
}
else {
();
}
}

})
);
}

# sequence stoppers
##     token metachar__S_452Gt (:$sym is context<rw> = « > »)
##          token metachar:sym« > » { '>'  :: <fail> }

sub metachar__S_452Gt__PEEK { $_[0]->_AUTOLEXpeek('metachar__S_452Gt',$retree) }
sub metachar__S_452Gt {
my $self = shift;
local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;
my %args = @_;
local $sym = $args{sym} //['>'];


my $C = $self;
my $S = $C->{'_pos'};
$C->{'sym'} = $sym;

$self->_MATCHIFY($S, "metachar__S_452Gt", 
Cursor::lazymap(sub { my $C=$_[0];
Cursor::lazymap(sub { my $C=$_[0];
$C->_SUBSUME(['fail'], sub {
my $C = shift;
$C->fail
})
}, $C->_COMMITBRANCH())
}, $C->_EXACT('>'))
);
}
##     token metachar__S_453AmpAmp (:$sym is context<rw> = <&&>)
##          token metachar:sym<&&>  { '&&' :: <fail> }

sub metachar__S_453AmpAmp__PEEK { $_[0]->_AUTOLEXpeek('metachar__S_453AmpAmp',$retree) }
sub metachar__S_453AmpAmp {
my $self = shift;
local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;
my %args = @_;
local $sym = $args{sym} // q(&&);


my $C = $self;
my $S = $C->{'_pos'};
$C->{'sym'} = $sym;

$self->_MATCHIFY($S, "metachar__S_453AmpAmp", 
Cursor::lazymap(sub { my $C=$_[0];
Cursor::lazymap(sub { my $C=$_[0];
$C->_SUBSUME(['fail'], sub {
my $C = shift;
$C->fail
})
}, $C->_COMMITBRANCH())
}, $C->_EXACT('&&'))
);
}
##     token metachar__S_454Amp (:$sym is context<rw> = <&>)
##          token metachar:sym<&>   { '&'  :: <fail> }

sub metachar__S_454Amp__PEEK { $_[0]->_AUTOLEXpeek('metachar__S_454Amp',$retree) }
sub metachar__S_454Amp {
my $self = shift;
local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;
my %args = @_;
local $sym = $args{sym} // q(&);


my $C = $self;
my $S = $C->{'_pos'};
$C->{'sym'} = $sym;

$self->_MATCHIFY($S, "metachar__S_454Amp", 
Cursor::lazymap(sub { my $C=$_[0];
Cursor::lazymap(sub { my $C=$_[0];
$C->_SUBSUME(['fail'], sub {
my $C = shift;
$C->fail
})
}, $C->_COMMITBRANCH())
}, $C->_EXACT('&'))
);
}
##     token metachar__S_455VertVert (:$sym is context<rw> = <||>)
##          token metachar:sym<||>  { '||' :: <fail> }

sub metachar__S_455VertVert__PEEK { $_[0]->_AUTOLEXpeek('metachar__S_455VertVert',$retree) }
sub metachar__S_455VertVert {
my $self = shift;
local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;
my %args = @_;
local $sym = $args{sym} // q(||);


my $C = $self;
my $S = $C->{'_pos'};
$C->{'sym'} = $sym;

$self->_MATCHIFY($S, "metachar__S_455VertVert", 
Cursor::lazymap(sub { my $C=$_[0];
Cursor::lazymap(sub { my $C=$_[0];
$C->_SUBSUME(['fail'], sub {
my $C = shift;
$C->fail
})
}, $C->_COMMITBRANCH())
}, $C->_EXACT('||'))
);
}
##     token metachar__S_456Vert (:$sym is context<rw> = <|>)
##          token metachar:sym<|>   { '|'  :: <fail> }

sub metachar__S_456Vert__PEEK { $_[0]->_AUTOLEXpeek('metachar__S_456Vert',$retree) }
sub metachar__S_456Vert {
my $self = shift;
local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;
my %args = @_;
local $sym = $args{sym} // q(|);


my $C = $self;
my $S = $C->{'_pos'};
$C->{'sym'} = $sym;

$self->_MATCHIFY($S, "metachar__S_456Vert", 
Cursor::lazymap(sub { my $C=$_[0];
Cursor::lazymap(sub { my $C=$_[0];
$C->_SUBSUME(['fail'], sub {
my $C = shift;
$C->fail
})
}, $C->_COMMITBRANCH())
}, $C->_EXACT('|'))
);
}
##     token metachar__S_457Ket (:$sym is context<rw> = <]>)
##          token metachar:sym<]>   { ']'  :: <fail> }

sub metachar__S_457Ket__PEEK { $_[0]->_AUTOLEXpeek('metachar__S_457Ket',$retree) }
sub metachar__S_457Ket {
my $self = shift;
local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;
my %args = @_;
local $sym = $args{sym} // q(]);


my $C = $self;
my $S = $C->{'_pos'};
$C->{'sym'} = $sym;

$self->_MATCHIFY($S, "metachar__S_457Ket", 
Cursor::lazymap(sub { my $C=$_[0];
Cursor::lazymap(sub { my $C=$_[0];
$C->_SUBSUME(['fail'], sub {
my $C = shift;
$C->fail
})
}, $C->_COMMITBRANCH())
}, $C->_EXACT(']'))
);
}
##     token metachar__S_458Thesis (:$sym is context<rw> = <)>)
##          token metachar:sym<)>   { ')'  :: <fail> }

sub metachar__S_458Thesis__PEEK { $_[0]->_AUTOLEXpeek('metachar__S_458Thesis',$retree) }
sub metachar__S_458Thesis {
my $self = shift;
local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;
my %args = @_;
local $sym = $args{sym} // q[)];


my $C = $self;
my $S = $C->{'_pos'};
$C->{'sym'} = $sym;

$self->_MATCHIFY($S, "metachar__S_458Thesis", 
Cursor::lazymap(sub { my $C=$_[0];
Cursor::lazymap(sub { my $C=$_[0];
$C->_SUBSUME(['fail'], sub {
my $C = shift;
$C->fail
})
}, $C->_COMMITBRANCH())
}, $C->_EXACT(')'))
);
}
##     token metachar__S_459Semi (:$sym is context<rw> = <;>)
##          token metachar:sym<;>   {
##              ';' {}
##              [
##              || <?before \N*? <stopper> > <.panic: "Semicolon must be quoted">
##              || <?before .> <.panic: "Regex missing terminator (or semicolon must be quoted?)">
##              || <.panic: "Regex missing terminator">   # the final fake ;
##              ]
##          }

sub metachar__S_459Semi__PEEK { $_[0]->_AUTOLEXpeek('metachar__S_459Semi',$retree) }
sub metachar__S_459Semi {
my $self = shift;
local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;
my %args = @_;
local $sym = $args{sym} // q(;);


my $C = $self;
my $S = $C->{'_pos'};
$C->{'sym'} = $sym;

$self->_MATCHIFY($S, "metachar__S_459Semi", 
Cursor::lazymap(sub { my $C=$_[0];
Cursor::lazymap(sub { my $C=$_[0];
$C->_BRACKET( sub { my $C=shift;
do { my @gather;
eval { push @gather, Cursor::lazymap(sub { my $C=$_[0];
$C->panic("Semicolon must be quoted")
}, $C->before(sub { my $C=shift;
Cursor::lazymap(sub { my $C=$_[0];
$C->_SUBSUME(['stopper'], sub {
my $C = shift;
$C->stopper
})
}, $C->_STARf(sub { my $C=shift;
$C->_NOTCHAR( sub { my $C=shift;
$C->_EXACT("\n")
})
}))
}))} // do {die $@ if $@ and $@ !~ /ABORT/;1} 
or
eval { push @gather, Cursor::lazymap(sub { my $C=$_[0];
$C->panic("Regex missing terminator (or semicolon must be quoted?)")
}, $C->before(sub { my $C=shift;
$C->_PATTERN(qr/\G(?s:.)/)
}))} // do {die $@ if $@ and $@ !~ /ABORT/;1} 
or
eval { push @gather, $C->panic("Regex missing terminator")} or do { die $@ if $@ };
@gather;
}
})
}, scalar(do {

}, $C))
}, $C->_EXACT(';'))
);
}

##     token metachar__S_460quant (:$sym is context<rw> = 'quant')
##          token metachar:quant { <quantifier> <.panic: "quantifier quantifies nothing"> }

sub metachar__S_460quant__PEEK { $_[0]->_AUTOLEXpeek('metachar__S_460quant',$retree) }
sub metachar__S_460quant {
my $self = shift;
local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;
my %args = @_;
local $sym = $args{sym} // 'quant';


my $C = $self;
my $S = $C->{'_pos'};
$C->{'sym'} = $sym;

$self->_MATCHIFYr($S, "metachar__S_460quant", 
do {
if (my ($C) = ($C->_SUBSUMEr(['quantifier'], sub {
my $C = shift;
$C->quantifier
}))) {
$C->panic("quantifier quantifies nothing");
}
else {
();
}
}
);
}

# "normal" metachars

##     token metachar__S_461sigwhite (:$sym is context<rw> = 'sigwhite')
##          token metachar:sigwhite {
##              <normspace>
##          }

sub metachar__S_461sigwhite__PEEK { $_[0]->_AUTOLEXpeek('metachar__S_461sigwhite',$retree) }
sub metachar__S_461sigwhite {
my $self = shift;
local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;
my %args = @_;
local $sym = $args{sym} // 'sigwhite';


my $C = $self;
my $S = $C->{'_pos'};
$C->{'sym'} = $sym;

$self->_MATCHIFYr($S, "metachar__S_461sigwhite", 
$C->_SUBSUMEr(['normspace'], sub {
my $C = shift;
$C->normspace
})
);
}
##     token metachar__S_462unsp (:$sym is context<rw> = 'unsp')
##          token metachar:unsp   { <unsp> }

sub metachar__S_462unsp__PEEK { $_[0]->_AUTOLEXpeek('metachar__S_462unsp',$retree) }
sub metachar__S_462unsp {
my $self = shift;
local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;
my %args = @_;
local $sym = $args{sym} // 'unsp';


my $C = $self;
my $S = $C->{'_pos'};
$C->{'sym'} = $sym;

$self->_MATCHIFYr($S, "metachar__S_462unsp", 
$C->_SUBSUMEr(['unsp'], sub {
my $C = shift;
$C->unsp
})
);
}

##     token metachar__S_463Cur_Ly (:$sym is context<rw> = <{ }>)
##          token metachar:sym<{ }> {
##              <?before '{'>
##              <codeblock>
##              {{ $/<sym> := <{ }> }}
##          }

sub metachar__S_463Cur_Ly__PEEK { $_[0]->_AUTOLEXpeek('metachar__S_463Cur_Ly',$retree) }
sub metachar__S_463Cur_Ly {
my $self = shift;
local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;
my %args = @_;
local $sym = $args{sym} // [qw({ })];


my $C = $self;
my $S = $C->{'_pos'};
$C->{'sym'} = $sym;

$self->_MATCHIFYr($S, "metachar__S_463Cur_Ly", 
do {
if (my ($C) = ($C->before(sub { my $C=shift;
$C->_EXACT('{')
}))) {
do {
if (my ($C) = ($C->_SUBSUMEr(['codeblock'], sub {
my $C = shift;
$C->codeblock
}))) {
scalar(do {
my $M = $C;  $M->{'sym'} = [qw({ })] ;
}, $C);
}
else {
();
}
};
}
else {
();
}
}
);
}

##     token metachar__S_464mod (:$sym is context<rw> = 'mod')
##          token metachar:mod {
##              <mod_internal>
##              { $/<sym> := $<mod_internal><sym> }
##          }

sub metachar__S_464mod__PEEK { $_[0]->_AUTOLEXpeek('metachar__S_464mod',$retree) }
sub metachar__S_464mod {
my $self = shift;
local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;
my %args = @_;
local $sym = $args{sym} // 'mod';


my $C = $self;
my $S = $C->{'_pos'};
$C->{'sym'} = $sym;

$self->_MATCHIFYr($S, "metachar__S_464mod", 
do {
if (my ($C) = ($C->_SUBSUMEr(['mod_internal'], sub {
my $C = shift;
$C->mod_internal
}))) {
scalar(do {
my $M = $C;  $M->{'sym'} = $M->{'mod_internal'}{'sym'} ;
}, $C);
}
else {
();
}
}
);
}

##     token metachar__S_465Colon (:$sym is context<rw> = <:>)
##          token metachar:sym<:> {
##              <sym>
##          }

sub metachar__S_465Colon__PEEK { $_[0]->_AUTOLEXpeek('metachar__S_465Colon',$retree) }
sub metachar__S_465Colon {
my $self = shift;
local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;
my %args = @_;
local $sym = $args{sym} // q(:);


my $C = $self;
my $S = $C->{'_pos'};
$C->{'sym'} = $sym;

$self->_MATCHIFYr($S, "metachar__S_465Colon", 
$C->_PATTERN(qr/\G\:/)
);
}

##     token metachar__S_466ColonColon (:$sym is context<rw> = <::>)
##          token metachar:sym<::> {
##              <sym>
##          }

sub metachar__S_466ColonColon__PEEK { $_[0]->_AUTOLEXpeek('metachar__S_466ColonColon',$retree) }
sub metachar__S_466ColonColon {
my $self = shift;
local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;
my %args = @_;
local $sym = $args{sym} // q(::);


my $C = $self;
my $S = $C->{'_pos'};
$C->{'sym'} = $sym;

$self->_MATCHIFYr($S, "metachar__S_466ColonColon", 
$C->_PATTERN(qr/\G\:\:/)
);
}

##     token metachar__S_467ColonColonColon (:$sym is context<rw> = <:::>)
##          token metachar:sym<:::> {
##              <sym>
##          }

sub metachar__S_467ColonColonColon__PEEK { $_[0]->_AUTOLEXpeek('metachar__S_467ColonColonColon',$retree) }
sub metachar__S_467ColonColonColon {
my $self = shift;
local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;
my %args = @_;
local $sym = $args{sym} // q(:::);


my $C = $self;
my $S = $C->{'_pos'};
$C->{'sym'} = $sym;

$self->_MATCHIFYr($S, "metachar__S_467ColonColonColon", 
$C->_PATTERN(qr/\G\:\:\:/)
);
}

##     token metachar__S_468Bra_Ket (:$sym is context<rw> = <[ ]>)
##          token metachar:sym<[ ]> {
##              '[' {} [:lang(self.unbalanced(']')) <nibbler>]
##              [ ']' || <.panic: "Unable to parse regex; couldn't find right bracket"> ]
##              { $/<sym> := <[ ]> }
##          }

sub metachar__S_468Bra_Ket__PEEK { $_[0]->_AUTOLEXpeek('metachar__S_468Bra_Ket',$retree) }
sub metachar__S_468Bra_Ket {
my $self = shift;
local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;
my %args = @_;
local $sym = $args{sym} // [qw([ ])];


my $C = $self;
my $S = $C->{'_pos'};
$C->{'sym'} = $sym;

$self->_MATCHIFYr($S, "metachar__S_468Bra_Ket", 
do {
if (my ($C) = ($C->_EXACT('['))) {
do {
if (my ($C) = (scalar(do {

}, $C))) {
do {
if (my ($C) = ($C->_BRACKETr( sub { my $C=shift;
my $newlang = ($self->unbalanced(']'));  $C = $C->cursor_fresh($newlang); ;$C->_SUBSUMEr(['nibbler'], sub {
my $C = shift;
$C->nibbler
})
}))) {
do {
if (my ($C) = ($C->_BRACKETr( sub { my $C=shift;
do { my @gather;
eval { push @gather, $C->_EXACT(']')} // do {die $@ if $@ and $@ !~ /ABORT/;1} 
or
eval { push @gather, $C->panic("Unable to parse regex; couldn't find right bracket")} or do { die $@ if $@ };
@gather;
}
}))) {
scalar(do {
my $M = $C;  $M->{'sym'} = [qw([ ])] ;
}, $C);
}
else {
();
}
};
}
else {
();
}
};
}
else {
();
}
};
}
else {
();
}
}
);
}

##     token metachar__S_469Paren_Thesis (:$sym is context<rw> = <( )>)
##          token metachar:sym<( )> {
##              '(' {} [:lang(self.unbalanced(')')) <nibbler>]
##              [ ')' || <.panic: "Unable to parse regex; couldn't find right parenthesis"> ]
##              { $/<sym> := <( )> }
##          }

sub metachar__S_469Paren_Thesis__PEEK { $_[0]->_AUTOLEXpeek('metachar__S_469Paren_Thesis',$retree) }
sub metachar__S_469Paren_Thesis {
my $self = shift;
local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;
my %args = @_;
local $sym = $args{sym} // [qw[( )]];


my $C = $self;
my $S = $C->{'_pos'};
$C->{'sym'} = $sym;

$self->_MATCHIFYr($S, "metachar__S_469Paren_Thesis", 
do {
if (my ($C) = ($C->_EXACT('('))) {
do {
if (my ($C) = (scalar(do {

}, $C))) {
do {
if (my ($C) = ($C->_BRACKETr( sub { my $C=shift;
my $newlang = ($self->unbalanced(')'));  $C = $C->cursor_fresh($newlang); ;$C->_SUBSUMEr(['nibbler'], sub {
my $C = shift;
$C->nibbler
})
}))) {
do {
if (my ($C) = ($C->_BRACKETr( sub { my $C=shift;
do { my @gather;
eval { push @gather, $C->_EXACT(')')} // do {die $@ if $@ and $@ !~ /ABORT/;1} 
or
eval { push @gather, $C->panic("Unable to parse regex; couldn't find right parenthesis")} or do { die $@ if $@ };
@gather;
}
}))) {
scalar(do {
my $M = $C;  $M->{'sym'} = [qw[( )]] ;
}, $C);
}
else {
();
}
};
}
else {
();
}
};
}
else {
();
}
};
}
else {
();
}
}
);
}

##     token metachar__S_470LtParen (:$sym is context<rw> = « <( »)
##          token metachar:sym« <( » { '<(' }

sub metachar__S_470LtParen__PEEK { $_[0]->_AUTOLEXpeek('metachar__S_470LtParen',$retree) }
sub metachar__S_470LtParen {
my $self = shift;
local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;
my %args = @_;
local $sym = $args{sym} //['<('];


my $C = $self;
my $S = $C->{'_pos'};
$C->{'sym'} = $sym;

$self->_MATCHIFYr($S, "metachar__S_470LtParen", 
$C->_EXACT('<(')
);
}
##     token metachar__S_471ThesisGt (:$sym is context<rw> = « )> »)
##          token metachar:sym« )> » { ')>' }

sub metachar__S_471ThesisGt__PEEK { $_[0]->_AUTOLEXpeek('metachar__S_471ThesisGt',$retree) }
sub metachar__S_471ThesisGt {
my $self = shift;
local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;
my %args = @_;
local $sym = $args{sym} //[')>'];


my $C = $self;
my $S = $C->{'_pos'};
$C->{'sym'} = $sym;

$self->_MATCHIFYr($S, "metachar__S_471ThesisGt", 
$C->_EXACT(')>')
);
}

##     token metachar__S_472LtLt (:$sym is context<rw> = « << »)
##          token metachar:sym« << » { '<<' }

sub metachar__S_472LtLt__PEEK { $_[0]->_AUTOLEXpeek('metachar__S_472LtLt',$retree) }
sub metachar__S_472LtLt {
my $self = shift;
local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;
my %args = @_;
local $sym = $args{sym} //['<<'];


my $C = $self;
my $S = $C->{'_pos'};
$C->{'sym'} = $sym;

$self->_MATCHIFYr($S, "metachar__S_472LtLt", 
$C->_EXACT('<<')
);
}
##     token metachar__S_473GtGt (:$sym is context<rw> = « >> »)
##          token metachar:sym« >> » { '>>' }

sub metachar__S_473GtGt__PEEK { $_[0]->_AUTOLEXpeek('metachar__S_473GtGt',$retree) }
sub metachar__S_473GtGt {
my $self = shift;
local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;
my %args = @_;
local $sym = $args{sym} //['>>'];


my $C = $self;
my $S = $C->{'_pos'};
$C->{'sym'} = $sym;

$self->_MATCHIFYr($S, "metachar__S_473GtGt", 
$C->_EXACT('>>')
);
}
##     token metachar__S_474Fre (:$sym is context<rw> = < « >)
##          token metachar:sym< « > { '«' }

sub metachar__S_474Fre__PEEK { $_[0]->_AUTOLEXpeek('metachar__S_474Fre',$retree) }
sub metachar__S_474Fre {
my $self = shift;
local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;
my %args = @_;
local $sym = $args{sym} // [qw( « )];


my $C = $self;
my $S = $C->{'_pos'};
$C->{'sym'} = $sym;

$self->_MATCHIFYr($S, "metachar__S_474Fre", 
$C->_EXACT('«')
);
}
##     token metachar__S_475Nch (:$sym is context<rw> = < » >)
##          token metachar:sym< » > { '»' }

sub metachar__S_475Nch__PEEK { $_[0]->_AUTOLEXpeek('metachar__S_475Nch',$retree) }
sub metachar__S_475Nch {
my $self = shift;
local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;
my %args = @_;
local $sym = $args{sym} // [qw( » )];


my $C = $self;
my $S = $C->{'_pos'};
$C->{'sym'} = $sym;

$self->_MATCHIFYr($S, "metachar__S_475Nch", 
$C->_EXACT('»')
);
}

##     token metachar__S_476qw (:$sym is context<rw> = 'qw')
##          token metachar:qw {
##              <?before '<' \s >  # (note required whitespace)
##              <circumfix>
##          }

sub metachar__S_476qw__PEEK { $_[0]->_AUTOLEXpeek('metachar__S_476qw',$retree) }
sub metachar__S_476qw {
my $self = shift;
local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;
my %args = @_;
local $sym = $args{sym} // 'qw';


my $C = $self;
my $S = $C->{'_pos'};
$C->{'sym'} = $sym;

$self->_MATCHIFYr($S, "metachar__S_476qw", 
do {
if (my ($C) = ($C->before(sub { my $C=shift;
do {
if (my ($C) = ($C->_EXACT('<'))) {
$C->_PATTERN(qr/\G\s/);
}
else {
();
}
}
}))) {
$C->_SUBSUMEr(['circumfix'], sub {
my $C = shift;
$C->circumfix
});
}
else {
();
}
}
);
}

##     token metachar__S_477Lt_Gt (:$sym is context<rw> = «< >»)
##          token metachar:sym«< >» {
##              '<' <unsp>? {} <assertion>
##              [ '>' || <.panic: "regex assertion not terminated by angle bracket"> ]
##          }

sub metachar__S_477Lt_Gt__PEEK { $_[0]->_AUTOLEXpeek('metachar__S_477Lt_Gt',$retree) }
sub metachar__S_477Lt_Gt {
my $self = shift;
local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;
my %args = @_;
local $sym = $args{sym} //['<','>'];


my $C = $self;
my $S = $C->{'_pos'};
$C->{'unsp'} = [];
$C->{'sym'} = $sym;

$self->_MATCHIFYr($S, "metachar__S_477Lt_Gt", 
do {
if (my ($C) = ($C->_EXACT('<'))) {
do {
if (my ($C) = ($C->_OPTr(sub { my $C=shift;
$C->_SUBSUMEr(['unsp'], sub {
my $C = shift;
$C->unsp
})
}))) {
do {
if (my ($C) = (scalar(do {

}, $C))) {
do {
if (my ($C) = ($C->_SUBSUMEr(['assertion'], sub {
my $C = shift;
$C->assertion
}))) {
$C->_BRACKETr( sub { my $C=shift;
do { my @gather;
eval { push @gather, $C->_EXACT('>')} // do {die $@ if $@ and $@ !~ /ABORT/;1} 
or
eval { push @gather, $C->panic("regex assertion not terminated by angle bracket")} or do { die $@ if $@ };
@gather;
}
});
}
else {
();
}
};
}
else {
();
}
};
}
else {
();
}
};
}
else {
();
}
}
);
}

##     token metachar__S_478Back (:$sym is context<rw> = <\\>)
##          token metachar:sym<\\> { <sym> <backslash> }

sub metachar__S_478Back__PEEK { $_[0]->_AUTOLEXpeek('metachar__S_478Back',$retree) }
sub metachar__S_478Back {
my $self = shift;
local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;
my %args = @_;
local $sym = $args{sym} // q(\\);


my $C = $self;
my $S = $C->{'_pos'};
$C->{'sym'} = $sym;

$self->_MATCHIFYr($S, "metachar__S_478Back", 
do {
if (my ($C) = ($C->_PATTERN(qr/\G\\/))) {
$C->_SUBSUMEr(['backslash'], sub {
my $C = shift;
$C->backslash
});
}
else {
();
}
}
);
}
##     token metachar__S_479Dot (:$sym is context<rw> = <.>)
##          token metachar:sym<.>  { <sym> }

sub metachar__S_479Dot__PEEK { $_[0]->_AUTOLEXpeek('metachar__S_479Dot',$retree) }
sub metachar__S_479Dot {
my $self = shift;
local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;
my %args = @_;
local $sym = $args{sym} // q(.);


my $C = $self;
my $S = $C->{'_pos'};
$C->{'sym'} = $sym;

$self->_MATCHIFYr($S, "metachar__S_479Dot", 
$C->_PATTERN(qr/\G\./)
);
}
##     token metachar__S_480CaretCaret (:$sym is context<rw> = <^^>)
##          token metachar:sym<^^> { <sym> }

sub metachar__S_480CaretCaret__PEEK { $_[0]->_AUTOLEXpeek('metachar__S_480CaretCaret',$retree) }
sub metachar__S_480CaretCaret {
my $self = shift;
local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;
my %args = @_;
local $sym = $args{sym} // q(^^);


my $C = $self;
my $S = $C->{'_pos'};
$C->{'sym'} = $sym;

$self->_MATCHIFYr($S, "metachar__S_480CaretCaret", 
$C->_PATTERN(qr/\G\^\^/)
);
}
##     token metachar__S_481Caret (:$sym is context<rw> = <^>)
##          token metachar:sym<^>  { <sym> }

sub metachar__S_481Caret__PEEK { $_[0]->_AUTOLEXpeek('metachar__S_481Caret',$retree) }
sub metachar__S_481Caret {
my $self = shift;
local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;
my %args = @_;
local $sym = $args{sym} // q(^);


my $C = $self;
my $S = $C->{'_pos'};
$C->{'sym'} = $sym;

$self->_MATCHIFYr($S, "metachar__S_481Caret", 
$C->_PATTERN(qr/\G\^/)
);
}
##     token metachar__S_482DollarDollar (:$sym is context<rw> = <$$>)
##          token metachar:sym<$$> {
##              <sym>
##              [ (\w+) <.obs("\$\$" ~ $0.Str ~ " to deref var inside a regex", "\$(\$" ~ $0.Str ~ ")")> ]?
##          }

sub metachar__S_482DollarDollar__PEEK { $_[0]->_AUTOLEXpeek('metachar__S_482DollarDollar',$retree) }
sub metachar__S_482DollarDollar {
my $self = shift;
local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;
my %args = @_;
local $sym = $args{sym} // q($$);


my $C = $self;
my $S = $C->{'_pos'};
$C->{'0'} = [];
$C->{'sym'} = $sym;

$self->_MATCHIFYr($S, "metachar__S_482DollarDollar", 
do {
if (my ($C) = ($C->_PATTERN(qr/\G\$\$/))) {
$C->_OPTr(sub { my $C=shift;
$C->_BRACKETr( sub { my $C=shift;
do {
if (my ($C) = (    $C->_SUBSUMEr(['0'], sub {
my $C = shift;
do { $C->_PAREN( sub { my $C=shift;
$C->_PATTERN(qr/\G((?:\w)++)/)
})}
}))) {
$C->obs("\$\$" . $C->{'0'}->Str . " to deref var inside a regex", "\$(\$" . $C->{'0'}->Str . ")");
}
else {
();
}
}
})
});
}
else {
();
}
}
);
}
##     token metachar__S_483Dollar (:$sym is context<rw> = <$>)
##          token metachar:sym<$>  {
##              '$'
##              <?before
##              | \s
##              | '|'
##              | '&'
##              | ')'
##              | ']'
##              | '>'
##              | $
##              | <.stopper>
##              >
##          }

sub metachar__S_483Dollar__PEEK { $_[0]->_AUTOLEXpeek('metachar__S_483Dollar',$retree) }
sub metachar__S_483Dollar {
my $self = shift;
local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;
my %args = @_;
local $sym = $args{sym} // q($);


my $C = $self;
my $S = $C->{'_pos'};
$C->{'sym'} = $sym;

$self->_MATCHIFYr($S, "metachar__S_483Dollar", 
do {
if (my ($C) = ($C->_EXACT('$'))) {
$C->before(sub { my $C=shift;
do {
my @result = eval {
my $trystate;
my ($tag, $try);
my @try;
my $relex;

my $fate;
if ($fate = $C->{'_fate'} and $fate->[1] eq 'metachar__S_483Dollar_01') {
$C->deb("Fate passed to metachar__S_483Dollar_01: ", ::fatestr($fate)) if $::DEBUG & DEBUG::fates;
($C->{'_fate'}, $tag, $try) = @$fate;
@try = ($try);
}

my @gather = ();
for (;;) {
if (not @try) {
$relex //= $C->cursor_fate('STD::Regex', 'metachar__S_483Dollar_01', $retree);
@try = $relex->($C, $trystate);
}
last unless @try;
$try = shift(@try) // next;

if (ref $try eq 'ARRAY') {
($C->{'_fate'}, $tag, $try) = @$try;	# next candidate fate
}

$C->deb("metachar__S_483Dollar_01 trying $tag $try") if $::DEBUG & DEBUG::try_processing;
push @gather, ((
sub { my $C=shift;
$C->_PATTERN(qr/\G\s/)
},
sub { my $C=shift;
$C->_EXACT('|')
},
sub { my $C=shift;
$C->_EXACT('&')
},
sub { my $C=shift;
$C->_EXACT(')')
},
sub { my $C=shift;
$C->_EXACT(']')
},
sub { my $C=shift;
$C->_EXACT('>')
},
sub { my $C=shift;
$C->_PATTERN(qr/\G\z/)
},
sub { my $C=shift;
$C->stopper
},
)[$try])->($C);
last if @gather;
}
@gather;
};
if (@result) {
@result;
}
elsif ($@) {
my ($first) = $@ =~ /(^.*)/;
$self->deb("CAUGHT $first") if $::DEBUG & DEBUG::trace_call;
die $@ if $@ !~ /^ABORTBRANCH/;
();
}
else {
();
}
}

});
}
else {
();
}
}
);
}

##     token metachar__S_484Single_Single (:$sym is context<rw> = <' '>)
##          token metachar:sym<' '> { <?before "'"> [:lang($¢.cursor_fresh(%*LANG<MAIN>)) <quote>] }

sub metachar__S_484Single_Single__PEEK { $_[0]->_AUTOLEXpeek('metachar__S_484Single_Single',$retree) }
sub metachar__S_484Single_Single {
my $self = shift;
local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;
my %args = @_;
local $sym = $args{sym} // [qw(' ')];


my $C = $self;
my $S = $C->{'_pos'};
$C->{'sym'} = $sym;

$self->_MATCHIFYr($S, "metachar__S_484Single_Single", 
do {
if (my ($C) = ($C->before(sub { my $C=shift;
$C->_PATTERN(qr/\G'/)
}))) {
$C->_BRACKETr( sub { my $C=shift;
my $newlang = ($C->cursor_fresh($::LANG{'MAIN'}));  $C = $C->cursor_fresh($newlang); ;$C->_SUBSUMEr(['quote'], sub {
my $C = shift;
$C->quote
})
});
}
else {
();
}
}
);
}
##     token metachar__S_485Double_Double (:$sym is context<rw> = <" ">)
##          token metachar:sym<" "> { <?before '"'> [:lang($¢.cursor_fresh(%*LANG<MAIN>)) <quote>] }

sub metachar__S_485Double_Double__PEEK { $_[0]->_AUTOLEXpeek('metachar__S_485Double_Double',$retree) }
sub metachar__S_485Double_Double {
my $self = shift;
local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;
my %args = @_;
local $sym = $args{sym} // [qw(" ")];


my $C = $self;
my $S = $C->{'_pos'};
$C->{'sym'} = $sym;

$self->_MATCHIFYr($S, "metachar__S_485Double_Double", 
do {
if (my ($C) = ($C->before(sub { my $C=shift;
$C->_EXACT('"')
}))) {
$C->_BRACKETr( sub { my $C=shift;
my $newlang = ($C->cursor_fresh($::LANG{'MAIN'}));  $C = $C->cursor_fresh($newlang); ;$C->_SUBSUMEr(['quote'], sub {
my $C = shift;
$C->quote
})
});
}
else {
();
}
}
);
}

##     token metachar__S_486var (:$sym is context<rw> = 'var')
##          token metachar:var {
##              <!before '$$'>
##              <?before <sigil>>
##              [:lang($¢.cursor_fresh(%*LANG<MAIN>)) <variable> <.ws> <.check_variable($<variable>)> ]
##              $<binding> = ( <.ws> '=' <.ws> <quantified_atom> )?
##              { $<sym> = $<variable>.Str; }
##          }

sub metachar__S_486var__PEEK { $_[0]->_AUTOLEXpeek('metachar__S_486var',$retree) }
sub metachar__S_486var {
my $self = shift;
local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;
my %args = @_;
local $sym = $args{sym} // 'var';


my $C = $self;
my $S = $C->{'_pos'};
$C->{'sym'} = $sym;

$self->_MATCHIFYr($S, "metachar__S_486var", 
do {
if (my ($C) = ($C->_NOTBEFORE( sub { my $C=shift;
$C->before(sub { my $C=shift;
$C->_EXACT('$$')
})
}))) {
do {
if (my ($C) = ($C->before(sub { my $C=shift;
$C->_SUBSUMEr(['sigil'], sub {
my $C = shift;
$C->sigil
})
}))) {
do {
if (my ($C) = ($C->_BRACKETr( sub { my $C=shift;
my $newlang = ($C->cursor_fresh($::LANG{'MAIN'}));  $C = $C->cursor_fresh($newlang); ;do {
if (my ($C) = ($C->_SUBSUMEr(['variable'], sub {
my $C = shift;
$C->variable
}))) {
do {
if (my ($C) = ($C->ws)) {
do { my $M = $C;
$C->check_variable($M->{'variable'})
; };
}
else {
();
}
};
}
else {
();
}
}
}))) {
do {
if (my ($C) = (    $C->_OPTr(sub { my $C=shift;
$C->_SUBSUMEr(['binding'], sub {
my $C = shift;
do { $C->_PAREN( sub { my $C=shift;
do {
if (my ($C) = ($C->ws)) {
do {
if (my ($C) = ($C->_EXACT('='))) {
do {
if (my ($C) = ($C->ws)) {
$C->_SUBSUMEr(['quantified_atom'], sub {
my $C = shift;
$C->quantified_atom
});
}
else {
();
}
};
}
else {
();
}
};
}
else {
();
}
}
})}
})
}))) {
scalar(do {
my $M = $C;  $M->{'sym'} = $M->{'variable'}->Str; ;
}, $C);
}
else {
();
}
};
}
else {
();
}
};
}
else {
();
}
};
}
else {
();
}
}
);
}

##     token backslash__S_487unspace (:$sym is context<rw> = 'unspace')
##          token backslash:unspace { <?before \s> <.SUPER::ws> }

sub backslash__S_487unspace__PEEK { $_[0]->_AUTOLEXpeek('backslash__S_487unspace',$retree) }
sub backslash__S_487unspace {
my $self = shift;
local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;
my %args = @_;
local $sym = $args{sym} // 'unspace';


my $C = $self;
my $S = $C->{'_pos'};
$C->{'sym'} = $sym;

$self->_MATCHIFYr($S, "backslash__S_487unspace", 
do {
if (my ($C) = ($C->before(sub { my $C=shift;
$C->_PATTERN(qr/\G\s/)
}))) {
$C->SUPER::ws;
}
else {
();
}
}
);
}

##     token backslash__S_4880 (:$sym is context<rw> = <0>)
##          token backslash:sym<0> { '0' <!before <[0..7]> > }

sub backslash__S_4880__PEEK { $_[0]->_AUTOLEXpeek('backslash__S_4880',$retree) }
sub backslash__S_4880 {
my $self = shift;
local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;
my %args = @_;
local $sym = $args{sym} // q(0);


my $C = $self;
my $S = $C->{'_pos'};

$self->_MATCHIFYr($S, "backslash__S_4880", 
do {
if (my ($C) = ($C->_EXACT('0'))) {
$C->_NOTBEFORE( sub { my $C=shift;
$C->before(sub { my $C=shift;
$C->_PATTERN(qr/\G[0-7]/)
})
});
}
else {
();
}
}
);
}

##     token backslash__S_489A (:$sym is context<rw> = 'A')
##          token backslash:A { <sym> <.obs('\\A as beginning-of-string matcher', '^')> }

sub backslash__S_489A__PEEK { $_[0]->_AUTOLEXpeek('backslash__S_489A',$retree) }
sub backslash__S_489A {
my $self = shift;
local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;
my %args = @_;
local $sym = $args{sym} // 'A';


my $C = $self;
my $S = $C->{'_pos'};
$C->{'sym'} = $sym;

$self->_MATCHIFYr($S, "backslash__S_489A", 
do {
if (my ($C) = ($C->_PATTERN(qr/\GA/))) {
$C->obs('\\A as beginning-of-string matcher', '^');
}
else {
();
}
}
);
}
##     token backslash__S_490a (:$sym is context<rw> = 'a')
##          token backslash:a { <sym> <.panic: "\\a is allowed only in strings, not regexes"> }

sub backslash__S_490a__PEEK { $_[0]->_AUTOLEXpeek('backslash__S_490a',$retree) }
sub backslash__S_490a {
my $self = shift;
local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;
my %args = @_;
local $sym = $args{sym} // 'a';


my $C = $self;
my $S = $C->{'_pos'};
$C->{'sym'} = $sym;

$self->_MATCHIFYr($S, "backslash__S_490a", 
do {
if (my ($C) = ($C->_PATTERN(qr/\Ga/))) {
$C->panic("\\a is allowed only in strings, not regexes");
}
else {
();
}
}
);
}
##     token backslash__S_491b (:$sym is context<rw> = 'b')
##          token backslash:b { :i <sym> }

sub backslash__S_491b__PEEK { $_[0]->_AUTOLEXpeek('backslash__S_491b',$retree) }
sub backslash__S_491b {
my $self = shift;
local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;
my %args = @_;
local $sym = $args{sym} // 'b';


my $C = $self;
my $S = $C->{'_pos'};
$C->{'sym'} = $sym;

$self->_MATCHIFYr($S, "backslash__S_491b", 
$C->_PATTERN(qr/\G(?i:b)/)
);
}
##     token backslash__S_492c (:$sym is context<rw> = 'c')
##          token backslash:c { :i <sym> <charspec> }

sub backslash__S_492c__PEEK { $_[0]->_AUTOLEXpeek('backslash__S_492c',$retree) }
sub backslash__S_492c {
my $self = shift;
local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;
my %args = @_;
local $sym = $args{sym} // 'c';


my $C = $self;
my $S = $C->{'_pos'};
$C->{'sym'} = $sym;

$self->_MATCHIFYr($S, "backslash__S_492c", 
do {
if (my ($C) = ($C->_PATTERN(qr/\G(?i:c)/))) {
$C->_SUBSUMEr(['charspec'], sub {
my $C = shift;
$C->charspec
});
}
else {
();
}
}
);
}
##     token backslash__S_493d (:$sym is context<rw> = 'd')
##          token backslash:d { :i <sym> }

sub backslash__S_493d__PEEK { $_[0]->_AUTOLEXpeek('backslash__S_493d',$retree) }
sub backslash__S_493d {
my $self = shift;
local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;
my %args = @_;
local $sym = $args{sym} // 'd';


my $C = $self;
my $S = $C->{'_pos'};
$C->{'sym'} = $sym;

$self->_MATCHIFYr($S, "backslash__S_493d", 
$C->_PATTERN(qr/\G(?i:d)/)
);
}
##     token backslash__S_494e (:$sym is context<rw> = 'e')
##          token backslash:e { :i <sym> }

sub backslash__S_494e__PEEK { $_[0]->_AUTOLEXpeek('backslash__S_494e',$retree) }
sub backslash__S_494e {
my $self = shift;
local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;
my %args = @_;
local $sym = $args{sym} // 'e';


my $C = $self;
my $S = $C->{'_pos'};
$C->{'sym'} = $sym;

$self->_MATCHIFYr($S, "backslash__S_494e", 
$C->_PATTERN(qr/\G(?i:e)/)
);
}
##     token backslash__S_495f (:$sym is context<rw> = 'f')
##          token backslash:f { :i <sym> }

sub backslash__S_495f__PEEK { $_[0]->_AUTOLEXpeek('backslash__S_495f',$retree) }
sub backslash__S_495f {
my $self = shift;
local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;
my %args = @_;
local $sym = $args{sym} // 'f';


my $C = $self;
my $S = $C->{'_pos'};
$C->{'sym'} = $sym;

$self->_MATCHIFYr($S, "backslash__S_495f", 
$C->_PATTERN(qr/\G(?i:f)/)
);
}
##     token backslash__S_496h (:$sym is context<rw> = 'h')
##          token backslash:h { :i <sym> }

sub backslash__S_496h__PEEK { $_[0]->_AUTOLEXpeek('backslash__S_496h',$retree) }
sub backslash__S_496h {
my $self = shift;
local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;
my %args = @_;
local $sym = $args{sym} // 'h';


my $C = $self;
my $S = $C->{'_pos'};
$C->{'sym'} = $sym;

$self->_MATCHIFYr($S, "backslash__S_496h", 
$C->_PATTERN(qr/\G(?i:h)/)
);
}
##     token backslash__S_497n (:$sym is context<rw> = 'n')
##          token backslash:n { :i <sym> }

sub backslash__S_497n__PEEK { $_[0]->_AUTOLEXpeek('backslash__S_497n',$retree) }
sub backslash__S_497n {
my $self = shift;
local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;
my %args = @_;
local $sym = $args{sym} // 'n';


my $C = $self;
my $S = $C->{'_pos'};
$C->{'sym'} = $sym;

$self->_MATCHIFYr($S, "backslash__S_497n", 
$C->_PATTERN(qr/\G(?i:n)/)
);
}
##     token backslash__S_498o (:$sym is context<rw> = 'o')
##          token backslash:o { :i :dba('octal character') <sym> [ <octint> | '[' ~ ']' <octints> ] }

sub backslash__S_498o__PEEK { $_[0]->_AUTOLEXpeek('backslash__S_498o',$retree) }
sub backslash__S_498o {
my $self = shift;
local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;
my %args = @_;
local $sym = $args{sym} // 'o';


my $C = $self;
my $S = $C->{'_pos'};
$C->{'sym'} = $sym;

$self->_MATCHIFY($S, "backslash__S_498o", 
Cursor::lazymap(sub { my $C=$_[0];
$C->_BRACKET( sub { my $C=shift;
do {
my @result = eval {
my $trystate;
my ($tag, $try);
my @try;
my $relex;

my $fate;
if ($fate = $C->{'_fate'} and $fate->[1] eq 'backslash__S_498o_01') {
$C->deb("Fate passed to backslash__S_498o_01: ", ::fatestr($fate)) if $::DEBUG & DEBUG::fates;
($C->{'_fate'}, $tag, $try) = @$fate;
@try = ($try);
}

my @gather = ();
for (;;) {
if (not @try) {
$relex //= $C->cursor_fate('STD::Regex', 'backslash__S_498o_01', $retree);
@try = $relex->($C, $trystate);
}
last unless @try;
$try = shift(@try) // next;

if (ref $try eq 'ARRAY') {
($C->{'_fate'}, $tag, $try) = @$try;	# next candidate fate
}

$C->deb("backslash__S_498o_01 trying $tag $try") if $::DEBUG & DEBUG::try_processing;
push @gather, ((
sub { my $C=shift;
$C->_SUBSUMEr(['octint'], sub {
my $C = shift;
$C->octint
})
},
sub { my $C=shift;
Cursor::lazymap(sub { my $C=$_[0];
Cursor::lazymap(sub { my $C=$_[0];
Cursor::lazymap(sub { my $C=$_[0];
$C->_BRACKET( sub { my $C=shift;
do { my @gather;
eval { push @gather, $C->_PATTERN(qr/\G(?i:\])/)} // do {die $@ if $@ and $@ !~ /ABORT/;1} 
or
eval { push @gather, $C->FAILGOAL(']' , 'octal character')} or do { die $@ if $@ };
@gather;
}
})
}, $C->_SUBSUME(['octints'], sub {
my $C = shift;
$C->octints
}))
}, $C->_COMMITBRANCH(local $::GOAL = ']' ))
}, $C->_PATTERN(qr/\G(?i:\[)/))
},
)[$try])->($C);
last if @gather;
}
@gather;
};
if (@result) {
@result;
}
elsif ($@) {
my ($first) = $@ =~ /(^.*)/;
$self->deb("CAUGHT $first") if $::DEBUG & DEBUG::trace_call;
die $@ if $@ !~ /^ABORTBRANCH/;
();
}
else {
();
}
}

})
}, $C->_PATTERN(qr/\G(?i:o)/))
);
}
##     token backslash__S_499Q (:$sym is context<rw> = 'Q')
##          token backslash:Q { <sym> <.obs('\\Q as quotemeta', 'quotes or literal variable match')> }

sub backslash__S_499Q__PEEK { $_[0]->_AUTOLEXpeek('backslash__S_499Q',$retree) }
sub backslash__S_499Q {
my $self = shift;
local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;
my %args = @_;
local $sym = $args{sym} // 'Q';


my $C = $self;
my $S = $C->{'_pos'};
$C->{'sym'} = $sym;

$self->_MATCHIFYr($S, "backslash__S_499Q", 
do {
if (my ($C) = ($C->_PATTERN(qr/\GQ/))) {
$C->obs('\\Q as quotemeta', 'quotes or literal variable match');
}
else {
();
}
}
);
}
##     token backslash__S_500r (:$sym is context<rw> = 'r')
##          token backslash:r { :i <sym> }

sub backslash__S_500r__PEEK { $_[0]->_AUTOLEXpeek('backslash__S_500r',$retree) }
sub backslash__S_500r {
my $self = shift;
local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;
my %args = @_;
local $sym = $args{sym} // 'r';


my $C = $self;
my $S = $C->{'_pos'};
$C->{'sym'} = $sym;

$self->_MATCHIFYr($S, "backslash__S_500r", 
$C->_PATTERN(qr/\G(?i:r)/)
);
}
##     token backslash__S_501s (:$sym is context<rw> = 's')
##          token backslash:s { :i <sym> }

sub backslash__S_501s__PEEK { $_[0]->_AUTOLEXpeek('backslash__S_501s',$retree) }
sub backslash__S_501s {
my $self = shift;
local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;
my %args = @_;
local $sym = $args{sym} // 's';


my $C = $self;
my $S = $C->{'_pos'};
$C->{'sym'} = $sym;

$self->_MATCHIFYr($S, "backslash__S_501s", 
$C->_PATTERN(qr/\G(?i:s)/)
);
}
##     token backslash__S_502t (:$sym is context<rw> = 't')
##          token backslash:t { :i <sym> }

sub backslash__S_502t__PEEK { $_[0]->_AUTOLEXpeek('backslash__S_502t',$retree) }
sub backslash__S_502t {
my $self = shift;
local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;
my %args = @_;
local $sym = $args{sym} // 't';


my $C = $self;
my $S = $C->{'_pos'};
$C->{'sym'} = $sym;

$self->_MATCHIFYr($S, "backslash__S_502t", 
$C->_PATTERN(qr/\G(?i:t)/)
);
}
##     token backslash__S_503v (:$sym is context<rw> = 'v')
##          token backslash:v { :i <sym> }

sub backslash__S_503v__PEEK { $_[0]->_AUTOLEXpeek('backslash__S_503v',$retree) }
sub backslash__S_503v {
my $self = shift;
local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;
my %args = @_;
local $sym = $args{sym} // 'v';


my $C = $self;
my $S = $C->{'_pos'};
$C->{'sym'} = $sym;

$self->_MATCHIFYr($S, "backslash__S_503v", 
$C->_PATTERN(qr/\G(?i:v)/)
);
}
##     token backslash__S_504w (:$sym is context<rw> = 'w')
##          token backslash:w { :i <sym> }

sub backslash__S_504w__PEEK { $_[0]->_AUTOLEXpeek('backslash__S_504w',$retree) }
sub backslash__S_504w {
my $self = shift;
local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;
my %args = @_;
local $sym = $args{sym} // 'w';


my $C = $self;
my $S = $C->{'_pos'};
$C->{'sym'} = $sym;

$self->_MATCHIFYr($S, "backslash__S_504w", 
$C->_PATTERN(qr/\G(?i:w)/)
);
}
##     token backslash__S_505x (:$sym is context<rw> = 'x')
##          token backslash:x { :i :dba('hex character') <sym> [ <hexint> | '[' ~ ']' <hexints> ] }

sub backslash__S_505x__PEEK { $_[0]->_AUTOLEXpeek('backslash__S_505x',$retree) }
sub backslash__S_505x {
my $self = shift;
local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;
my %args = @_;
local $sym = $args{sym} // 'x';


my $C = $self;
my $S = $C->{'_pos'};
$C->{'sym'} = $sym;

$self->_MATCHIFY($S, "backslash__S_505x", 
Cursor::lazymap(sub { my $C=$_[0];
$C->_BRACKET( sub { my $C=shift;
do {
my @result = eval {
my $trystate;
my ($tag, $try);
my @try;
my $relex;

my $fate;
if ($fate = $C->{'_fate'} and $fate->[1] eq 'backslash__S_505x_01') {
$C->deb("Fate passed to backslash__S_505x_01: ", ::fatestr($fate)) if $::DEBUG & DEBUG::fates;
($C->{'_fate'}, $tag, $try) = @$fate;
@try = ($try);
}

my @gather = ();
for (;;) {
if (not @try) {
$relex //= $C->cursor_fate('STD::Regex', 'backslash__S_505x_01', $retree);
@try = $relex->($C, $trystate);
}
last unless @try;
$try = shift(@try) // next;

if (ref $try eq 'ARRAY') {
($C->{'_fate'}, $tag, $try) = @$try;	# next candidate fate
}

$C->deb("backslash__S_505x_01 trying $tag $try") if $::DEBUG & DEBUG::try_processing;
push @gather, ((
sub { my $C=shift;
$C->_SUBSUMEr(['hexint'], sub {
my $C = shift;
$C->hexint
})
},
sub { my $C=shift;
Cursor::lazymap(sub { my $C=$_[0];
Cursor::lazymap(sub { my $C=$_[0];
Cursor::lazymap(sub { my $C=$_[0];
$C->_BRACKET( sub { my $C=shift;
do { my @gather;
eval { push @gather, $C->_PATTERN(qr/\G(?i:\])/)} // do {die $@ if $@ and $@ !~ /ABORT/;1} 
or
eval { push @gather, $C->FAILGOAL(']' , 'hex character')} or do { die $@ if $@ };
@gather;
}
})
}, $C->_SUBSUME(['hexints'], sub {
my $C = shift;
$C->hexints
}))
}, $C->_COMMITBRANCH(local $::GOAL = ']' ))
}, $C->_PATTERN(qr/\G(?i:\[)/))
},
)[$try])->($C);
last if @gather;
}
@gather;
};
if (@result) {
@result;
}
elsif ($@) {
my ($first) = $@ =~ /(^.*)/;
$self->deb("CAUGHT $first") if $::DEBUG & DEBUG::trace_call;
die $@ if $@ !~ /^ABORTBRANCH/;
();
}
else {
();
}
}

})
}, $C->_PATTERN(qr/\G(?i:x)/))
);
}
##     token backslash__S_506z (:$sym is context<rw> = 'z')
##          token backslash:z { <sym> <.obs('\\z as end-of-string matcher', '$')> }

sub backslash__S_506z__PEEK { $_[0]->_AUTOLEXpeek('backslash__S_506z',$retree) }
sub backslash__S_506z {
my $self = shift;
local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;
my %args = @_;
local $sym = $args{sym} // 'z';


my $C = $self;
my $S = $C->{'_pos'};
$C->{'sym'} = $sym;

$self->_MATCHIFYr($S, "backslash__S_506z", 
do {
if (my ($C) = ($C->_PATTERN(qr/\Gz/))) {
$C->obs('\\z as end-of-string matcher', '$');
}
else {
();
}
}
);
}
##     token backslash__S_507Z (:$sym is context<rw> = 'Z')
##          token backslash:Z { <sym> <.obs('\\Z as end-of-string matcher', '\\n?$')> }

sub backslash__S_507Z__PEEK { $_[0]->_AUTOLEXpeek('backslash__S_507Z',$retree) }
sub backslash__S_507Z {
my $self = shift;
local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;
my %args = @_;
local $sym = $args{sym} // 'Z';


my $C = $self;
my $S = $C->{'_pos'};
$C->{'sym'} = $sym;

$self->_MATCHIFYr($S, "backslash__S_507Z", 
do {
if (my ($C) = ($C->_PATTERN(qr/\GZ/))) {
$C->obs('\\Z as end-of-string matcher', '\\n?$');
}
else {
();
}
}
);
}
##     token backslash__S_508misc (:$sym is context<rw> = 'misc')
##          token backslash:misc { $<litchar>=(\W) }

sub backslash__S_508misc__PEEK { $_[0]->_AUTOLEXpeek('backslash__S_508misc',$retree) }
sub backslash__S_508misc {
my $self = shift;
local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;
my %args = @_;
local $sym = $args{sym} // 'misc';


my $C = $self;
my $S = $C->{'_pos'};
$C->{'sym'} = $sym;

$self->_MATCHIFYr($S, "backslash__S_508misc", 
$C->_SUBSUMEr(['litchar'], sub {
my $C = shift;
do { $C->_PAREN( sub { my $C=shift;
$C->_NOTCHAR( sub { my $C=shift;
$C->_PATTERN(qr/\G\w/)
})
})}
})
);
}
##     token backslash__S_509oops (:$sym is context<rw> = 'oops')
##          token backslash:oops { <.panic: "Unrecognized regex backslash sequence"> }

sub backslash__S_509oops__PEEK { $_[0]->_AUTOLEXpeek('backslash__S_509oops',$retree) }
sub backslash__S_509oops {
my $self = shift;
local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;
my %args = @_;
local $sym = $args{sym} // 'oops';


my $C = $self;
my $S = $C->{'_pos'};
$C->{'sym'} = $sym;

$self->_MATCHIFYr($S, "backslash__S_509oops", 
$C->panic("Unrecognized regex backslash sequence")
);
}

##     token assertion__S_510DotDotDot (:$sym is context<rw> = <...>)
##          token assertion:sym<...> { <sym> }

sub assertion__S_510DotDotDot__PEEK { $_[0]->_AUTOLEXpeek('assertion__S_510DotDotDot',$retree) }
sub assertion__S_510DotDotDot {
my $self = shift;
local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;
my %args = @_;
local $sym = $args{sym} // q(...);


my $C = $self;
my $S = $C->{'_pos'};
$C->{'sym'} = $sym;

$self->_MATCHIFYr($S, "assertion__S_510DotDotDot", 
$C->_PATTERN(qr/\G\.\.\./)
);
}
##     token assertion__S_511QuestionQuestionQuestion (:$sym is context<rw> = <???>)
##          token assertion:sym<???> { <sym> }

sub assertion__S_511QuestionQuestionQuestion__PEEK { $_[0]->_AUTOLEXpeek('assertion__S_511QuestionQuestionQuestion',$retree) }
sub assertion__S_511QuestionQuestionQuestion {
my $self = shift;
local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;
my %args = @_;
local $sym = $args{sym} // q(???);


my $C = $self;
my $S = $C->{'_pos'};
$C->{'sym'} = $sym;

$self->_MATCHIFYr($S, "assertion__S_511QuestionQuestionQuestion", 
$C->_PATTERN(qr/\G\?\?\?/)
);
}
##     token assertion__S_512BangBangBang (:$sym is context<rw> = <!!!>)
##          token assertion:sym<!!!> { <sym> }

sub assertion__S_512BangBangBang__PEEK { $_[0]->_AUTOLEXpeek('assertion__S_512BangBangBang',$retree) }
sub assertion__S_512BangBangBang {
my $self = shift;
local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;
my %args = @_;
local $sym = $args{sym} // q(!!!);


my $C = $self;
my $S = $C->{'_pos'};
$C->{'sym'} = $sym;

$self->_MATCHIFYr($S, "assertion__S_512BangBangBang", 
$C->_PATTERN(qr/\G\!\!\!/)
);
}

##     token assertion__S_513Question (:$sym is context<rw> = <?>)
##          token assertion:sym<?> { <sym> [ <?before '>'> | <assertion> ] }

sub assertion__S_513Question__PEEK { $_[0]->_AUTOLEXpeek('assertion__S_513Question',$retree) }
sub assertion__S_513Question {
my $self = shift;
local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;
my %args = @_;
local $sym = $args{sym} // q(?);


my $C = $self;
my $S = $C->{'_pos'};
$C->{'sym'} = $sym;

$self->_MATCHIFYr($S, "assertion__S_513Question", 
do {
if (my ($C) = ($C->_PATTERN(qr/\G\?/))) {
$C->_BRACKETr( sub { my $C=shift;
do {
my @result = eval {
my $trystate;
my ($tag, $try);
my @try;
my $relex;

my $fate;
if ($fate = $C->{'_fate'} and $fate->[1] eq 'assertion__S_513Question_01') {
$C->deb("Fate passed to assertion__S_513Question_01: ", ::fatestr($fate)) if $::DEBUG & DEBUG::fates;
($C->{'_fate'}, $tag, $try) = @$fate;
@try = ($try);
}

my @gather = ();
for (;;) {
if (not @try) {
$relex //= $C->cursor_fate('STD::Regex', 'assertion__S_513Question_01', $retree);
@try = $relex->($C, $trystate);
}
last unless @try;
$try = shift(@try) // next;

if (ref $try eq 'ARRAY') {
($C->{'_fate'}, $tag, $try) = @$try;	# next candidate fate
}

$C->deb("assertion__S_513Question_01 trying $tag $try") if $::DEBUG & DEBUG::try_processing;
push @gather, ((
sub { my $C=shift;
$C->before(sub { my $C=shift;
$C->_EXACT('>')
})
},
sub { my $C=shift;
$C->_SUBSUMEr(['assertion'], sub {
my $C = shift;
$C->assertion
})
},
)[$try])->($C);
last if @gather;
}
@gather;
};
if (@result) {
@result;
}
elsif ($@) {
my ($first) = $@ =~ /(^.*)/;
$self->deb("CAUGHT $first") if $::DEBUG & DEBUG::trace_call;
die $@ if $@ !~ /^ABORTBRANCH/;
();
}
else {
();
}
}

});
}
else {
();
}
}
);
}
##     token assertion__S_514Bang (:$sym is context<rw> = <!>)
##          token assertion:sym<!> { <sym> [ <?before '>'> | <assertion> ] }

sub assertion__S_514Bang__PEEK { $_[0]->_AUTOLEXpeek('assertion__S_514Bang',$retree) }
sub assertion__S_514Bang {
my $self = shift;
local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;
my %args = @_;
local $sym = $args{sym} // q(!);


my $C = $self;
my $S = $C->{'_pos'};
$C->{'sym'} = $sym;

$self->_MATCHIFYr($S, "assertion__S_514Bang", 
do {
if (my ($C) = ($C->_PATTERN(qr/\G\!/))) {
$C->_BRACKETr( sub { my $C=shift;
do {
my @result = eval {
my $trystate;
my ($tag, $try);
my @try;
my $relex;

my $fate;
if ($fate = $C->{'_fate'} and $fate->[1] eq 'assertion__S_514Bang_01') {
$C->deb("Fate passed to assertion__S_514Bang_01: ", ::fatestr($fate)) if $::DEBUG & DEBUG::fates;
($C->{'_fate'}, $tag, $try) = @$fate;
@try = ($try);
}

my @gather = ();
for (;;) {
if (not @try) {
$relex //= $C->cursor_fate('STD::Regex', 'assertion__S_514Bang_01', $retree);
@try = $relex->($C, $trystate);
}
last unless @try;
$try = shift(@try) // next;

if (ref $try eq 'ARRAY') {
($C->{'_fate'}, $tag, $try) = @$try;	# next candidate fate
}

$C->deb("assertion__S_514Bang_01 trying $tag $try") if $::DEBUG & DEBUG::try_processing;
push @gather, ((
sub { my $C=shift;
$C->before(sub { my $C=shift;
$C->_EXACT('>')
})
},
sub { my $C=shift;
$C->_SUBSUMEr(['assertion'], sub {
my $C = shift;
$C->assertion
})
},
)[$try])->($C);
last if @gather;
}
@gather;
};
if (@result) {
@result;
}
elsif ($@) {
my ($first) = $@ =~ /(^.*)/;
$self->deb("CAUGHT $first") if $::DEBUG & DEBUG::trace_call;
die $@ if $@ !~ /^ABORTBRANCH/;
();
}
else {
();
}
}

});
}
else {
();
}
}
);
}
##     token assertion__S_515Star (:$sym is context<rw> = <*>)
##          token assertion:sym<*> { <sym> [ <?before '>'> | <.ws> <nibbler> ] }

sub assertion__S_515Star__PEEK { $_[0]->_AUTOLEXpeek('assertion__S_515Star',$retree) }
sub assertion__S_515Star {
my $self = shift;
local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;
my %args = @_;
local $sym = $args{sym} // q(*);


my $C = $self;
my $S = $C->{'_pos'};
$C->{'sym'} = $sym;

$self->_MATCHIFYr($S, "assertion__S_515Star", 
do {
if (my ($C) = ($C->_PATTERN(qr/\G\*/))) {
$C->_BRACKETr( sub { my $C=shift;
do {
my @result = eval {
my $trystate;
my ($tag, $try);
my @try;
my $relex;

my $fate;
if ($fate = $C->{'_fate'} and $fate->[1] eq 'assertion__S_515Star_01') {
$C->deb("Fate passed to assertion__S_515Star_01: ", ::fatestr($fate)) if $::DEBUG & DEBUG::fates;
($C->{'_fate'}, $tag, $try) = @$fate;
@try = ($try);
}

my @gather = ();
for (;;) {
if (not @try) {
$relex //= $C->cursor_fate('STD::Regex', 'assertion__S_515Star_01', $retree);
@try = $relex->($C, $trystate);
}
last unless @try;
$try = shift(@try) // next;

if (ref $try eq 'ARRAY') {
($C->{'_fate'}, $tag, $try) = @$try;	# next candidate fate
}

$C->deb("assertion__S_515Star_01 trying $tag $try") if $::DEBUG & DEBUG::try_processing;
push @gather, ((
sub { my $C=shift;
$C->before(sub { my $C=shift;
$C->_EXACT('>')
})
},
sub { my $C=shift;
do {
if (my ($C) = ($C->ws)) {
$C->_SUBSUMEr(['nibbler'], sub {
my $C = shift;
$C->nibbler
});
}
else {
();
}
}
},
)[$try])->($C);
last if @gather;
}
@gather;
};
if (@result) {
@result;
}
elsif ($@) {
my ($first) = $@ =~ /(^.*)/;
$self->deb("CAUGHT $first") if $::DEBUG & DEBUG::trace_call;
die $@ if $@ !~ /^ABORTBRANCH/;
();
}
else {
();
}
}

});
}
else {
();
}
}
);
}

##     token assertion__S_516Cur_Ly (:$sym is context<rw> = <{ }>)
##          token assertion:sym<{ }> { <codeblock> }

sub assertion__S_516Cur_Ly__PEEK { $_[0]->_AUTOLEXpeek('assertion__S_516Cur_Ly',$retree) }
sub assertion__S_516Cur_Ly {
my $self = shift;
local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;
my %args = @_;
local $sym = $args{sym} // [qw({ })];


my $C = $self;
my $S = $C->{'_pos'};
$C->{'sym'} = $sym;

$self->_MATCHIFYr($S, "assertion__S_516Cur_Ly", 
$C->_SUBSUMEr(['codeblock'], sub {
my $C = shift;
$C->codeblock
})
);
}

##     token assertion__S_517variable (:$sym is context<rw> = 'variable')
##          token assertion:variable {
##              <?before <sigil>>  # note: semantics must be determined per-sigil
##              [:lang($¢.cursor_fresh(%*LANG<MAIN>).unbalanced('>')) <variable=EXPR(item %LOOSEST)>]
##          }

sub assertion__S_517variable__PEEK { $_[0]->_AUTOLEXpeek('assertion__S_517variable',$retree) }
sub assertion__S_517variable {
my $self = shift;
local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;
my %args = @_;
local $sym = $args{sym} // 'variable';


my $C = $self;
my $S = $C->{'_pos'};
$C->{'sym'} = $sym;

$self->_MATCHIFYr($S, "assertion__S_517variable", 
do {
if (my ($C) = ($C->before(sub { my $C=shift;
$C->_SUBSUMEr(['sigil'], sub {
my $C = shift;
$C->sigil
})
}))) {
$C->_BRACKETr( sub { my $C=shift;
my $newlang = ($C->cursor_fresh($::LANG{'MAIN'})->unbalanced('>'));  $C = $C->cursor_fresh($newlang); ;    $C->_SUBSUMEr(['variable'], sub {
my $C = shift;
$C->EXPR(\%LOOSEST)
})
});
}
else {
();
}
}
);
}

##     token assertion__S_518method (:$sym is context<rw> = 'method')
##          token assertion:method {
##              '.' [
##                  | <?before <alpha> > <assertion>
##                  | [ :lang($¢.cursor_fresh(%*LANG<MAIN>).unbalanced('>')) <dottyop> ]
##                  ]
##          }

sub assertion__S_518method__PEEK { $_[0]->_AUTOLEXpeek('assertion__S_518method',$retree) }
sub assertion__S_518method {
my $self = shift;
local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;
my %args = @_;
local $sym = $args{sym} // 'method';


my $C = $self;
my $S = $C->{'_pos'};
$C->{'sym'} = $sym;

$self->_MATCHIFYr($S, "assertion__S_518method", 
do {
if (my ($C) = ($C->_EXACT('.'))) {
$C->_BRACKETr( sub { my $C=shift;
do {
my @result = eval {
my $trystate;
my ($tag, $try);
my @try;
my $relex;

my $fate;
if ($fate = $C->{'_fate'} and $fate->[1] eq 'assertion__S_518method_01') {
$C->deb("Fate passed to assertion__S_518method_01: ", ::fatestr($fate)) if $::DEBUG & DEBUG::fates;
($C->{'_fate'}, $tag, $try) = @$fate;
@try = ($try);
}

my @gather = ();
for (;;) {
if (not @try) {
$relex //= $C->cursor_fate('STD::Regex', 'assertion__S_518method_01', $retree);
@try = $relex->($C, $trystate);
}
last unless @try;
$try = shift(@try) // next;

if (ref $try eq 'ARRAY') {
($C->{'_fate'}, $tag, $try) = @$try;	# next candidate fate
}

$C->deb("assertion__S_518method_01 trying $tag $try") if $::DEBUG & DEBUG::try_processing;
push @gather, ((
sub { my $C=shift;
do {
if (my ($C) = ($C->before(sub { my $C=shift;
$C->_PATTERN(qr/\G[_[:alpha:]]/)
}))) {
$C->_SUBSUMEr(['assertion'], sub {
my $C = shift;
$C->assertion
});
}
else {
();
}
}
},
sub { my $C=shift;
$C->_BRACKETr( sub { my $C=shift;
my $newlang = ($C->cursor_fresh($::LANG{'MAIN'})->unbalanced('>'));  $C = $C->cursor_fresh($newlang); ;$C->_SUBSUMEr(['dottyop'], sub {
my $C = shift;
$C->dottyop
})
})
},
)[$try])->($C);
last if @gather;
}
@gather;
};
if (@result) {
@result;
}
elsif ($@) {
my ($first) = $@ =~ /(^.*)/;
$self->deb("CAUGHT $first") if $::DEBUG & DEBUG::trace_call;
die $@ if $@ !~ /^ABORTBRANCH/;
();
}
else {
();
}
}

});
}
else {
();
}
}
);
}

##     token assertion__S_519name (:$sym is context<rw> = 'name')
##          token assertion:name { [ :lang($¢.cursor_fresh(%*LANG<MAIN>).unbalanced('>')) <longname> ]
##                                          [
##                                          | <?before '>' >
##                                          | <.ws> <nibbler>
##                                          | '=' <assertion>
##                                          | ':' <.ws>
##                                              [ :lang($¢.cursor_fresh(%*LANG<MAIN>).unbalanced('>')) <arglist> ]
##                                          | '(' {}
##                                              [ :lang($¢.cursor_fresh(%*LANG<MAIN>)) <arglist> ]
##                                              [ ')' || <.panic: "Assertion call missing right parenthesis"> ]
##                                          ]?
##          }

sub assertion__S_519name__PEEK { $_[0]->_AUTOLEXpeek('assertion__S_519name',$retree) }
sub assertion__S_519name {
my $self = shift;
local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;
my %args = @_;
local $sym = $args{sym} // 'name';


my $C = $self;
my $S = $C->{'_pos'};
$C->{'arglist'} = [];
$C->{'nibbler'} = [];
$C->{'assertion'} = [];
$C->{'sym'} = $sym;

$self->_MATCHIFYr($S, "assertion__S_519name", 
do {
if (my ($C) = ($C->_BRACKETr( sub { my $C=shift;
my $newlang = ($C->cursor_fresh($::LANG{'MAIN'})->unbalanced('>'));  $C = $C->cursor_fresh($newlang); ;$C->_SUBSUMEr(['longname'], sub {
my $C = shift;
$C->longname
})
}))) {
$C->_OPTr(sub { my $C=shift;
$C->_BRACKETr( sub { my $C=shift;
do {
my @result = eval {
my $trystate;
my ($tag, $try);
my @try;
my $relex;

my $fate;
if ($fate = $C->{'_fate'} and $fate->[1] eq 'assertion__S_519name_02') {
$C->deb("Fate passed to assertion__S_519name_02: ", ::fatestr($fate)) if $::DEBUG & DEBUG::fates;
($C->{'_fate'}, $tag, $try) = @$fate;
@try = ($try);
}

my @gather = ();
for (;;) {
if (not @try) {
$relex //= $C->cursor_fate('STD::Regex', 'assertion__S_519name_02', $retree);
@try = $relex->($C, $trystate);
}
last unless @try;
$try = shift(@try) // next;

if (ref $try eq 'ARRAY') {
($C->{'_fate'}, $tag, $try) = @$try;	# next candidate fate
}

$C->deb("assertion__S_519name_02 trying $tag $try") if $::DEBUG & DEBUG::try_processing;
push @gather, ((
sub { my $C=shift;
$C->before(sub { my $C=shift;
$C->_EXACT('>')
})
},
sub { my $C=shift;
do {
if (my ($C) = ($C->ws)) {
$C->_SUBSUMEr(['nibbler'], sub {
my $C = shift;
$C->nibbler
});
}
else {
();
}
}
},
sub { my $C=shift;
do {
if (my ($C) = ($C->_EXACT('='))) {
$C->_SUBSUMEr(['assertion'], sub {
my $C = shift;
$C->assertion
});
}
else {
();
}
}
},
sub { my $C=shift;
do {
if (my ($C) = ($C->_EXACT(':'))) {
do {
if (my ($C) = ($C->ws)) {
$C->_BRACKETr( sub { my $C=shift;
my $newlang = ($C->cursor_fresh($::LANG{'MAIN'})->unbalanced('>'));  $C = $C->cursor_fresh($newlang); ;$C->_SUBSUMEr(['arglist'], sub {
my $C = shift;
$C->arglist
})
});
}
else {
();
}
};
}
else {
();
}
}
},
sub { my $C=shift;
do {
if (my ($C) = ($C->_EXACT('('))) {
do {
if (my ($C) = (scalar(do {

}, $C))) {
do {
if (my ($C) = ($C->_BRACKETr( sub { my $C=shift;
my $newlang = ($C->cursor_fresh($::LANG{'MAIN'}));  $C = $C->cursor_fresh($newlang); ;$C->_SUBSUMEr(['arglist'], sub {
my $C = shift;
$C->arglist
})
}))) {
$C->_BRACKETr( sub { my $C=shift;
do { my @gather;
eval { push @gather, $C->_EXACT(')')} // do {die $@ if $@ and $@ !~ /ABORT/;1} 
or
eval { push @gather, $C->panic("Assertion call missing right parenthesis")} or do { die $@ if $@ };
@gather;
}
});
}
else {
();
}
};
}
else {
();
}
};
}
else {
();
}
}
},
)[$try])->($C);
last if @gather;
}
@gather;
};
if (@result) {
@result;
}
elsif ($@) {
my ($first) = $@ =~ /(^.*)/;
$self->deb("CAUGHT $first") if $::DEBUG & DEBUG::trace_call;
die $@ if $@ !~ /^ABORTBRANCH/;
();
}
else {
();
}
}

})
});
}
else {
();
}
}
);
}

##     token assertion__S_520Bra (:$sym is context<rw> = <[>)
##          token assertion:sym<[> { <?before '['> <cclass_elem>+ }

sub assertion__S_520Bra__PEEK { $_[0]->_AUTOLEXpeek('assertion__S_520Bra',$retree) }
sub assertion__S_520Bra {
my $self = shift;
local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;
my %args = @_;
local $sym = $args{sym} // q([);


my $C = $self;
my $S = $C->{'_pos'};
$C->{'cclass_elem'} = [];
$C->{'sym'} = $sym;

$self->_MATCHIFYr($S, "assertion__S_520Bra", 
do {
if (my ($C) = ($C->before(sub { my $C=shift;
$C->_EXACT('[')
}))) {
$C->_PLUSr(sub { my $C=shift;
$C->_SUBSUMEr(['cclass_elem'], sub {
my $C = shift;
$C->cclass_elem
})
});
}
else {
();
}
}
);
}
##     token assertion__S_521Plus (:$sym is context<rw> = <+>)
##          token assertion:sym<+> { <?before '+'> <cclass_elem>+ }

sub assertion__S_521Plus__PEEK { $_[0]->_AUTOLEXpeek('assertion__S_521Plus',$retree) }
sub assertion__S_521Plus {
my $self = shift;
local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;
my %args = @_;
local $sym = $args{sym} // q(+);


my $C = $self;
my $S = $C->{'_pos'};
$C->{'cclass_elem'} = [];
$C->{'sym'} = $sym;

$self->_MATCHIFYr($S, "assertion__S_521Plus", 
do {
if (my ($C) = ($C->before(sub { my $C=shift;
$C->_EXACT('+')
}))) {
$C->_PLUSr(sub { my $C=shift;
$C->_SUBSUMEr(['cclass_elem'], sub {
my $C = shift;
$C->cclass_elem
})
});
}
else {
();
}
}
);
}
##     token assertion__S_522Minus (:$sym is context<rw> = <->)
##          token assertion:sym<-> { <?before '-'> <cclass_elem>+ }

sub assertion__S_522Minus__PEEK { $_[0]->_AUTOLEXpeek('assertion__S_522Minus',$retree) }
sub assertion__S_522Minus {
my $self = shift;
local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;
my %args = @_;
local $sym = $args{sym} // q(-);


my $C = $self;
my $S = $C->{'_pos'};
$C->{'cclass_elem'} = [];
$C->{'sym'} = $sym;

$self->_MATCHIFYr($S, "assertion__S_522Minus", 
do {
if (my ($C) = ($C->before(sub { my $C=shift;
$C->_EXACT('-')
}))) {
$C->_PLUSr(sub { my $C=shift;
$C->_SUBSUMEr(['cclass_elem'], sub {
my $C = shift;
$C->cclass_elem
})
});
}
else {
();
}
}
);
}
##     token assertion__S_523Dot (:$sym is context<rw> = <.>)
##          token assertion:sym<.> { <sym> }

sub assertion__S_523Dot__PEEK { $_[0]->_AUTOLEXpeek('assertion__S_523Dot',$retree) }
sub assertion__S_523Dot {
my $self = shift;
local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;
my %args = @_;
local $sym = $args{sym} // q(.);


my $C = $self;
my $S = $C->{'_pos'};
$C->{'sym'} = $sym;

$self->_MATCHIFYr($S, "assertion__S_523Dot", 
$C->_PATTERN(qr/\G\./)
);
}
##     token assertion__S_524Comma (:$sym is context<rw> = <,>)
##          token assertion:sym<,> { <sym> }

sub assertion__S_524Comma__PEEK { $_[0]->_AUTOLEXpeek('assertion__S_524Comma',$retree) }
sub assertion__S_524Comma {
my $self = shift;
local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;
my %args = @_;
local $sym = $args{sym} // q[,];


my $C = $self;
my $S = $C->{'_pos'};
$C->{'sym'} = $sym;

$self->_MATCHIFYr($S, "assertion__S_524Comma", 
$C->_PATTERN(qr/\G\,/)
);
}
##     token assertion__S_525TildeTilde (:$sym is context<rw> = <~~>)
##          token assertion:sym<~~> { <sym> [ <?before '>'> | \d+ | <desigilname> ] }

sub assertion__S_525TildeTilde__PEEK { $_[0]->_AUTOLEXpeek('assertion__S_525TildeTilde',$retree) }
sub assertion__S_525TildeTilde {
my $self = shift;
local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;
my %args = @_;
local $sym = $args{sym} // q(~~);


my $C = $self;
my $S = $C->{'_pos'};
$C->{'sym'} = $sym;

$self->_MATCHIFYr($S, "assertion__S_525TildeTilde", 
do {
if (my ($C) = ($C->_PATTERN(qr/\G\~\~/))) {
$C->_BRACKETr( sub { my $C=shift;
do {
my @result = eval {
my $trystate;
my ($tag, $try);
my @try;
my $relex;

my $fate;
if ($fate = $C->{'_fate'} and $fate->[1] eq 'assertion__S_525TildeTilde_01') {
$C->deb("Fate passed to assertion__S_525TildeTilde_01: ", ::fatestr($fate)) if $::DEBUG & DEBUG::fates;
($C->{'_fate'}, $tag, $try) = @$fate;
@try = ($try);
}

my @gather = ();
for (;;) {
if (not @try) {
$relex //= $C->cursor_fate('STD::Regex', 'assertion__S_525TildeTilde_01', $retree);
@try = $relex->($C, $trystate);
}
last unless @try;
$try = shift(@try) // next;

if (ref $try eq 'ARRAY') {
($C->{'_fate'}, $tag, $try) = @$try;	# next candidate fate
}

$C->deb("assertion__S_525TildeTilde_01 trying $tag $try") if $::DEBUG & DEBUG::try_processing;
push @gather, ((
sub { my $C=shift;
$C->before(sub { my $C=shift;
$C->_EXACT('>')
})
},
sub { my $C=shift;
$C->_PATTERN(qr/\G((?:\d)++)/)
},
sub { my $C=shift;
$C->_SUBSUMEr(['desigilname'], sub {
my $C = shift;
$C->desigilname
})
},
)[$try])->($C);
last if @gather;
}
@gather;
};
if (@result) {
@result;
}
elsif ($@) {
my ($first) = $@ =~ /(^.*)/;
$self->deb("CAUGHT $first") if $::DEBUG & DEBUG::trace_call;
die $@ if $@ !~ /^ABORTBRANCH/;
();
}
else {
();
}
}

});
}
else {
();
}
}
);
}

##     token assertion__S_526bogus (:$sym is context<rw> = 'bogus')
##          token assertion:bogus { <.panic: "Unrecognized regex assertion"> }

sub assertion__S_526bogus__PEEK { $_[0]->_AUTOLEXpeek('assertion__S_526bogus',$retree) }
sub assertion__S_526bogus {
my $self = shift;
local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;
my %args = @_;
local $sym = $args{sym} // 'bogus';


my $C = $self;
my $S = $C->{'_pos'};
$C->{'sym'} = $sym;

$self->_MATCHIFYr($S, "assertion__S_526bogus", 
$C->panic("Unrecognized regex assertion")
);
}

##     token sign
##          token sign { '+' | '-' | <?> }

sub sign__PEEK { $_[0]->_AUTOLEXpeek('sign',$retree) }
sub sign {
my $self = shift;
local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;


my $C = $self;
my $S = $C->{'_pos'};

$self->_MATCHIFYr($S, "sign", 
do {
my @result = eval {
my $trystate;
my ($tag, $try);
my @try;
my $relex;

my $fate;
if ($fate = $C->{'_fate'} and $fate->[1] eq 'sign_00') {
$C->deb("Fate passed to sign_00: ", ::fatestr($fate)) if $::DEBUG & DEBUG::fates;
($C->{'_fate'}, $tag, $try) = @$fate;
@try = ($try);
}

my @gather = ();
for (;;) {
if (not @try) {
$relex //= $C->cursor_fate('STD::Regex', 'sign_00', $retree);
@try = $relex->($C, $trystate);
}
last unless @try;
$try = shift(@try) // next;

if (ref $try eq 'ARRAY') {
($C->{'_fate'}, $tag, $try) = @$try;	# next candidate fate
}

$C->deb("sign_00 trying $tag $try") if $::DEBUG & DEBUG::try_processing;
push @gather, ((
sub { my $C=shift;
$C->_EXACT('+')
},
sub { my $C=shift;
$C->_EXACT('-')
},
sub { my $C=shift;
$C->before( sub { my $C=shift;
$C
})
},
)[$try])->($C);
last if @gather;
}
@gather;
};
if (@result) {
@result;
}
elsif ($@) {
my ($first) = $@ =~ /(^.*)/;
$self->deb("CAUGHT $first") if $::DEBUG & DEBUG::trace_call;
die $@ if $@ !~ /^ABORTBRANCH/;
();
}
else {
();
}
}

);
}
##     token cclass_elem
##          token cclass_elem {
##              :dba('character class element')
##              <sign>
##              <.normspace>?
##              [
##              | <name>
##              | <before '['> <quibble($¢.cursor_fresh( %*LANG<Q> ).tweak(:q))> # XXX parse as q[] for now
##              ]
##              <.normspace>?
##          }

sub cclass_elem__PEEK { $_[0]->_AUTOLEXpeek('cclass_elem',$retree) }
sub cclass_elem {
my $self = shift;
local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;


my $C = $self;
my $S = $C->{'_pos'};

$self->_MATCHIFYr($S, "cclass_elem", 
do {
if (my ($C) = ($C->_SUBSUMEr(['sign'], sub {
my $C = shift;
$C->sign
}))) {
do {
if (my ($C) = ($C->_OPTr(sub { my $C=shift;
$C->normspace
}))) {
do {
if (my ($C) = ($C->_BRACKETr( sub { my $C=shift;
do {
my @result = eval {
my $trystate;
my ($tag, $try);
my @try;
my $relex;

my $fate;
if ($fate = $C->{'_fate'} and $fate->[1] eq 'cclass_elem_01') {
$C->deb("Fate passed to cclass_elem_01: ", ::fatestr($fate)) if $::DEBUG & DEBUG::fates;
($C->{'_fate'}, $tag, $try) = @$fate;
@try = ($try);
}

my @gather = ();
for (;;) {
if (not @try) {
$relex //= $C->cursor_fate('STD::Regex', 'cclass_elem_01', $retree);
@try = $relex->($C, $trystate);
}
last unless @try;
$try = shift(@try) // next;

if (ref $try eq 'ARRAY') {
($C->{'_fate'}, $tag, $try) = @$try;	# next candidate fate
}

$C->deb("cclass_elem_01 trying $tag $try") if $::DEBUG & DEBUG::try_processing;
push @gather, ((
sub { my $C=shift;
$C->_SUBSUMEr(['name'], sub {
my $C = shift;
$C->name
})
},
sub { my $C=shift;
do {
if (my ($C) = ($C->_SUBSUMEr(['before'], sub {
my $C = shift;
$C->before(sub { my $C=shift;
$C->_EXACT('[')
})
}))) {
$C->_SUBSUMEr(['quibble'], sub {
my $C = shift;
$C->quibble($C->cursor_fresh( $::LANG{'Q'} )->tweak('q' => 1))
});
}
else {
();
}
}
},
)[$try])->($C);
last if @gather;
}
@gather;
};
if (@result) {
@result;
}
elsif ($@) {
my ($first) = $@ =~ /(^.*)/;
$self->deb("CAUGHT $first") if $::DEBUG & DEBUG::trace_call;
die $@ if $@ !~ /^ABORTBRANCH/;
();
}
else {
();
}
}

}))) {
$C->_OPTr(sub { my $C=shift;
$C->normspace
});
}
else {
();
}
};
}
else {
();
}
};
}
else {
();
}
}
);
}

##     token mod_arg
##          token mod_arg { :dba('modifier argument') '(' ~ ')' <semilist> }

sub mod_arg__PEEK { $_[0]->_AUTOLEXpeek('mod_arg',$retree) }
sub mod_arg {
my $self = shift;
local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;


my $C = $self;
my $S = $C->{'_pos'};

$self->_MATCHIFY($S, "mod_arg", 
Cursor::lazymap(sub { my $C=$_[0];
Cursor::lazymap(sub { my $C=$_[0];
Cursor::lazymap(sub { my $C=$_[0];
$C->_BRACKET( sub { my $C=shift;
do { my @gather;
eval { push @gather, $C->_EXACT(')')} // do {die $@ if $@ and $@ !~ /ABORT/;1} 
or
eval { push @gather, $C->FAILGOAL(')' , 'modifier argument')} or do { die $@ if $@ };
@gather;
}
})
}, $C->_SUBSUME(['semilist'], sub {
my $C = shift;
$C->semilist
}))
}, $C->_COMMITBRANCH(local $::GOAL = ')' ))
}, $C->_EXACT('('))
);
}

##     token mod_internal__S_527Colonmy (:$sym is context<rw> = <:my>)
##          token mod_internal:sym<:my>    { ':' <?before ['my'|'state'|'our'|'constant'] \s > [:lang($¢.cursor_fresh(%*LANG<MAIN>)) <statement> <eat_terminator> ] }

sub mod_internal__S_527Colonmy__PEEK { $_[0]->_AUTOLEXpeek('mod_internal__S_527Colonmy',$retree) }
sub mod_internal__S_527Colonmy {
my $self = shift;
local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;
my %args = @_;
local $sym = $args{sym} // q(:my);


my $C = $self;
my $S = $C->{'_pos'};
$C->{'sym'} = $sym;

$self->_MATCHIFYr($S, "mod_internal__S_527Colonmy", 
do {
if (my ($C) = ($C->_EXACT(':'))) {
do {
if (my ($C) = ($C->before(sub { my $C=shift;
do {
if (my ($C) = ($C->_BRACKETr( sub { my $C=shift;
do {
my @result = eval {
my $trystate;
my ($tag, $try);
my @try;
my $relex;

my $fate;
if ($fate = $C->{'_fate'} and $fate->[1] eq 'mod_internal__S_527Colonmy_02') {
$C->deb("Fate passed to mod_internal__S_527Colonmy_02: ", ::fatestr($fate)) if $::DEBUG & DEBUG::fates;
($C->{'_fate'}, $tag, $try) = @$fate;
@try = ($try);
}

my @gather = ();
for (;;) {
if (not @try) {
$relex //= $C->cursor_fate('STD::Regex', 'mod_internal__S_527Colonmy_02', $retree);
@try = $relex->($C, $trystate);
}
last unless @try;
$try = shift(@try) // next;

if (ref $try eq 'ARRAY') {
($C->{'_fate'}, $tag, $try) = @$try;	# next candidate fate
}

$C->deb("mod_internal__S_527Colonmy_02 trying $tag $try") if $::DEBUG & DEBUG::try_processing;
push @gather, ((
sub { my $C=shift;
$C->_EXACT('my')
},
sub { my $C=shift;
$C->_EXACT('state')
},
sub { my $C=shift;
$C->_EXACT('our')
},
sub { my $C=shift;
$C->_EXACT('constant')
},
)[$try])->($C);
last if @gather;
}
@gather;
};
if (@result) {
@result;
}
elsif ($@) {
my ($first) = $@ =~ /(^.*)/;
$self->deb("CAUGHT $first") if $::DEBUG & DEBUG::trace_call;
die $@ if $@ !~ /^ABORTBRANCH/;
();
}
else {
();
}
}

}))) {
$C->_PATTERN(qr/\G\s/);
}
else {
();
}
}
}))) {
$C->_BRACKETr( sub { my $C=shift;
my $newlang = ($C->cursor_fresh($::LANG{'MAIN'}));  $C = $C->cursor_fresh($newlang); ;do {
if (my ($C) = ($C->_SUBSUMEr(['statement'], sub {
my $C = shift;
$C->statement
}))) {
$C->_SUBSUMEr(['eat_terminator'], sub {
my $C = shift;
$C->eat_terminator
});
}
else {
();
}
}
});
}
else {
();
}
};
}
else {
();
}
}
);
}
##     token mod_internal__S_528Colontemp (:$sym is context<rw> = <:temp>)
##          token mod_internal:sym<:temp>    { ':' <?before ['temp'|'let'] \s > [:lang($¢.cursor_fresh(%*LANG<MAIN>)) <statement> <eat_terminator> ] }

sub mod_internal__S_528Colontemp__PEEK { $_[0]->_AUTOLEXpeek('mod_internal__S_528Colontemp',$retree) }
sub mod_internal__S_528Colontemp {
my $self = shift;
local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;
my %args = @_;
local $sym = $args{sym} // q(:temp);


my $C = $self;
my $S = $C->{'_pos'};
$C->{'sym'} = $sym;

$self->_MATCHIFYr($S, "mod_internal__S_528Colontemp", 
do {
if (my ($C) = ($C->_EXACT(':'))) {
do {
if (my ($C) = ($C->before(sub { my $C=shift;
do {
if (my ($C) = ($C->_BRACKETr( sub { my $C=shift;
do {
my @result = eval {
my $trystate;
my ($tag, $try);
my @try;
my $relex;

my $fate;
if ($fate = $C->{'_fate'} and $fate->[1] eq 'mod_internal__S_528Colontemp_02') {
$C->deb("Fate passed to mod_internal__S_528Colontemp_02: ", ::fatestr($fate)) if $::DEBUG & DEBUG::fates;
($C->{'_fate'}, $tag, $try) = @$fate;
@try = ($try);
}

my @gather = ();
for (;;) {
if (not @try) {
$relex //= $C->cursor_fate('STD::Regex', 'mod_internal__S_528Colontemp_02', $retree);
@try = $relex->($C, $trystate);
}
last unless @try;
$try = shift(@try) // next;

if (ref $try eq 'ARRAY') {
($C->{'_fate'}, $tag, $try) = @$try;	# next candidate fate
}

$C->deb("mod_internal__S_528Colontemp_02 trying $tag $try") if $::DEBUG & DEBUG::try_processing;
push @gather, ((
sub { my $C=shift;
$C->_EXACT('temp')
},
sub { my $C=shift;
$C->_EXACT('let')
},
)[$try])->($C);
last if @gather;
}
@gather;
};
if (@result) {
@result;
}
elsif ($@) {
my ($first) = $@ =~ /(^.*)/;
$self->deb("CAUGHT $first") if $::DEBUG & DEBUG::trace_call;
die $@ if $@ !~ /^ABORTBRANCH/;
();
}
else {
();
}
}

}))) {
$C->_PATTERN(qr/\G\s/);
}
else {
();
}
}
}))) {
$C->_BRACKETr( sub { my $C=shift;
my $newlang = ($C->cursor_fresh($::LANG{'MAIN'}));  $C = $C->cursor_fresh($newlang); ;do {
if (my ($C) = ($C->_SUBSUMEr(['statement'], sub {
my $C = shift;
$C->statement
}))) {
$C->_SUBSUMEr(['eat_terminator'], sub {
my $C = shift;
$C->eat_terminator
});
}
else {
();
}
}
});
}
else {
();
}
};
}
else {
();
}
}
);
}

# XXX needs some generalization

##     token mod_internal__S_529Coloni (:$sym is context<rw> = <:i>)
##          token mod_internal:sym<:i>    { $<sym>=[':i'|':ignorecase'] » { $*ignorecase = 1 } }

sub mod_internal__S_529Coloni__PEEK { $_[0]->_AUTOLEXpeek('mod_internal__S_529Coloni',$retree) }
sub mod_internal__S_529Coloni {
my $self = shift;
local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;
my %args = @_;
local $sym = $args{sym} // q(:i);


my $C = $self;
my $S = $C->{'_pos'};
$C->{'sym'} = $sym;

$self->_MATCHIFYr($S, "mod_internal__S_529Coloni", 
do {
if (my ($C) = (    $C->_SUBSUMEr(['sym'], sub {
my $C = shift;
$C->_BRACKETr( sub { my $C=shift;
do {
my @result = eval {
my $trystate;
my ($tag, $try);
my @try;
my $relex;

my $fate;
if ($fate = $C->{'_fate'} and $fate->[1] eq 'mod_internal__S_529Coloni_01') {
$C->deb("Fate passed to mod_internal__S_529Coloni_01: ", ::fatestr($fate)) if $::DEBUG & DEBUG::fates;
($C->{'_fate'}, $tag, $try) = @$fate;
@try = ($try);
}

my @gather = ();
for (;;) {
if (not @try) {
$relex //= $C->cursor_fate('STD::Regex', 'mod_internal__S_529Coloni_01', $retree);
@try = $relex->($C, $trystate);
}
last unless @try;
$try = shift(@try) // next;

if (ref $try eq 'ARRAY') {
($C->{'_fate'}, $tag, $try) = @$try;	# next candidate fate
}

$C->deb("mod_internal__S_529Coloni_01 trying $tag $try") if $::DEBUG & DEBUG::try_processing;
push @gather, ((
sub { my $C=shift;
$C->_EXACT(':i')
},
sub { my $C=shift;
$C->_EXACT(':ignorecase')
},
)[$try])->($C);
last if @gather;
}
@gather;
};
if (@result) {
@result;
}
elsif ($@) {
my ($first) = $@ =~ /(^.*)/;
$self->deb("CAUGHT $first") if $::DEBUG & DEBUG::trace_call;
die $@ if $@ !~ /^ABORTBRANCH/;
();
}
else {
();
}
}

})
}))) {
do {
if (my ($C) = ($C->_PATTERN(qr/\G\b/))) {
scalar(do {
$::ignorecase = 1 
}, $C);
}
else {
();
}
};
}
else {
();
}
}
);
}
##     token mod_internal__S_530ColonBangi (:$sym is context<rw> = <:!i>)
##          token mod_internal:sym<:!i>   { $<sym>=[':!i'|':!ignorecase'] » { $*ignorecase = 0 } }

sub mod_internal__S_530ColonBangi__PEEK { $_[0]->_AUTOLEXpeek('mod_internal__S_530ColonBangi',$retree) }
sub mod_internal__S_530ColonBangi {
my $self = shift;
local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;
my %args = @_;
local $sym = $args{sym} // q(:!i);


my $C = $self;
my $S = $C->{'_pos'};
$C->{'sym'} = $sym;

$self->_MATCHIFYr($S, "mod_internal__S_530ColonBangi", 
do {
if (my ($C) = (    $C->_SUBSUMEr(['sym'], sub {
my $C = shift;
$C->_BRACKETr( sub { my $C=shift;
do {
my @result = eval {
my $trystate;
my ($tag, $try);
my @try;
my $relex;

my $fate;
if ($fate = $C->{'_fate'} and $fate->[1] eq 'mod_internal__S_530ColonBangi_01') {
$C->deb("Fate passed to mod_internal__S_530ColonBangi_01: ", ::fatestr($fate)) if $::DEBUG & DEBUG::fates;
($C->{'_fate'}, $tag, $try) = @$fate;
@try = ($try);
}

my @gather = ();
for (;;) {
if (not @try) {
$relex //= $C->cursor_fate('STD::Regex', 'mod_internal__S_530ColonBangi_01', $retree);
@try = $relex->($C, $trystate);
}
last unless @try;
$try = shift(@try) // next;

if (ref $try eq 'ARRAY') {
($C->{'_fate'}, $tag, $try) = @$try;	# next candidate fate
}

$C->deb("mod_internal__S_530ColonBangi_01 trying $tag $try") if $::DEBUG & DEBUG::try_processing;
push @gather, ((
sub { my $C=shift;
$C->_EXACT(':!i')
},
sub { my $C=shift;
$C->_EXACT(':!ignorecase')
},
)[$try])->($C);
last if @gather;
}
@gather;
};
if (@result) {
@result;
}
elsif ($@) {
my ($first) = $@ =~ /(^.*)/;
$self->deb("CAUGHT $first") if $::DEBUG & DEBUG::trace_call;
die $@ if $@ !~ /^ABORTBRANCH/;
();
}
else {
();
}
}

})
}))) {
do {
if (my ($C) = ($C->_PATTERN(qr/\G\b/))) {
scalar(do {
$::ignorecase = 0 
}, $C);
}
else {
();
}
};
}
else {
();
}
}
);
}
##     token mod_internal__S_531ColoniParen_Thesis (:$sym is context<rw> = <:i( )>)
##          token mod_internal:sym<:i( )> { $<sym>=[':i'|':ignorecase'] <mod_arg> { $*ignorecase = eval $<mod_arg>.Str } }

sub mod_internal__S_531ColoniParen_Thesis__PEEK { $_[0]->_AUTOLEXpeek('mod_internal__S_531ColoniParen_Thesis',$retree) }
sub mod_internal__S_531ColoniParen_Thesis {
my $self = shift;
local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;
my %args = @_;
local $sym = $args{sym} // [qw[:i( )]];


my $C = $self;
my $S = $C->{'_pos'};
$C->{'sym'} = $sym;

$self->_MATCHIFYr($S, "mod_internal__S_531ColoniParen_Thesis", 
do {
if (my ($C) = (    $C->_SUBSUMEr(['sym'], sub {
my $C = shift;
$C->_BRACKETr( sub { my $C=shift;
do {
my @result = eval {
my $trystate;
my ($tag, $try);
my @try;
my $relex;

my $fate;
if ($fate = $C->{'_fate'} and $fate->[1] eq 'mod_internal__S_531ColoniParen_Thesis_01') {
$C->deb("Fate passed to mod_internal__S_531ColoniParen_Thesis_01: ", ::fatestr($fate)) if $::DEBUG & DEBUG::fates;
($C->{'_fate'}, $tag, $try) = @$fate;
@try = ($try);
}

my @gather = ();
for (;;) {
if (not @try) {
$relex //= $C->cursor_fate('STD::Regex', 'mod_internal__S_531ColoniParen_Thesis_01', $retree);
@try = $relex->($C, $trystate);
}
last unless @try;
$try = shift(@try) // next;

if (ref $try eq 'ARRAY') {
($C->{'_fate'}, $tag, $try) = @$try;	# next candidate fate
}

$C->deb("mod_internal__S_531ColoniParen_Thesis_01 trying $tag $try") if $::DEBUG & DEBUG::try_processing;
push @gather, ((
sub { my $C=shift;
$C->_EXACT(':i')
},
sub { my $C=shift;
$C->_EXACT(':ignorecase')
},
)[$try])->($C);
last if @gather;
}
@gather;
};
if (@result) {
@result;
}
elsif ($@) {
my ($first) = $@ =~ /(^.*)/;
$self->deb("CAUGHT $first") if $::DEBUG & DEBUG::trace_call;
die $@ if $@ !~ /^ABORTBRANCH/;
();
}
else {
();
}
}

})
}))) {
do {
if (my ($C) = ($C->_SUBSUMEr(['mod_arg'], sub {
my $C = shift;
$C->mod_arg
}))) {
scalar(do {
my $M = $C;  $::ignorecase = eval $M->{'mod_arg'}->Str ;
}, $C);
}
else {
();
}
};
}
else {
();
}
}
);
}
##     token mod_internal__S_532Colon0i (:$sym is context<rw> = <:0i>)
##          token mod_internal:sym<:0i>   { ':' (\d+) ['i'|'ignorecase'] { $*ignorecase = $0 } }

sub mod_internal__S_532Colon0i__PEEK { $_[0]->_AUTOLEXpeek('mod_internal__S_532Colon0i',$retree) }
sub mod_internal__S_532Colon0i {
my $self = shift;
local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;
my %args = @_;
local $sym = $args{sym} // q(:0i);


my $C = $self;
my $S = $C->{'_pos'};
$C->{'sym'} = $sym;

$self->_MATCHIFYr($S, "mod_internal__S_532Colon0i", 
do {
if (my ($C) = ($C->_EXACT(':'))) {
do {
if (my ($C) = (    $C->_SUBSUMEr(['0'], sub {
my $C = shift;
do { $C->_PAREN( sub { my $C=shift;
$C->_PATTERN(qr/\G((?:\d)++)/)
})}
}))) {
do {
if (my ($C) = ($C->_BRACKETr( sub { my $C=shift;
do {
my @result = eval {
my $trystate;
my ($tag, $try);
my @try;
my $relex;

my $fate;
if ($fate = $C->{'_fate'} and $fate->[1] eq 'mod_internal__S_532Colon0i_02') {
$C->deb("Fate passed to mod_internal__S_532Colon0i_02: ", ::fatestr($fate)) if $::DEBUG & DEBUG::fates;
($C->{'_fate'}, $tag, $try) = @$fate;
@try = ($try);
}

my @gather = ();
for (;;) {
if (not @try) {
$relex //= $C->cursor_fate('STD::Regex', 'mod_internal__S_532Colon0i_02', $retree);
@try = $relex->($C, $trystate);
}
last unless @try;
$try = shift(@try) // next;

if (ref $try eq 'ARRAY') {
($C->{'_fate'}, $tag, $try) = @$try;	# next candidate fate
}

$C->deb("mod_internal__S_532Colon0i_02 trying $tag $try") if $::DEBUG & DEBUG::try_processing;
push @gather, ((
sub { my $C=shift;
$C->_EXACT('i')
},
sub { my $C=shift;
$C->_EXACT('ignorecase')
},
)[$try])->($C);
last if @gather;
}
@gather;
};
if (@result) {
@result;
}
elsif ($@) {
my ($first) = $@ =~ /(^.*)/;
$self->deb("CAUGHT $first") if $::DEBUG & DEBUG::trace_call;
die $@ if $@ !~ /^ABORTBRANCH/;
();
}
else {
();
}
}

}))) {
scalar(do {
$::ignorecase = $C->{'0'} 
}, $C);
}
else {
();
}
};
}
else {
();
}
};
}
else {
();
}
}
);
}

##     token mod_internal__S_533Colona (:$sym is context<rw> = <:a>)
##          token mod_internal:sym<:a>    { $<sym>=[':a'|':ignoreaccent'] » { $*ignoreaccent = 1 } }

sub mod_internal__S_533Colona__PEEK { $_[0]->_AUTOLEXpeek('mod_internal__S_533Colona',$retree) }
sub mod_internal__S_533Colona {
my $self = shift;
local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;
my %args = @_;
local $sym = $args{sym} // q(:a);


my $C = $self;
my $S = $C->{'_pos'};
$C->{'sym'} = $sym;

$self->_MATCHIFYr($S, "mod_internal__S_533Colona", 
do {
if (my ($C) = (    $C->_SUBSUMEr(['sym'], sub {
my $C = shift;
$C->_BRACKETr( sub { my $C=shift;
do {
my @result = eval {
my $trystate;
my ($tag, $try);
my @try;
my $relex;

my $fate;
if ($fate = $C->{'_fate'} and $fate->[1] eq 'mod_internal__S_533Colona_01') {
$C->deb("Fate passed to mod_internal__S_533Colona_01: ", ::fatestr($fate)) if $::DEBUG & DEBUG::fates;
($C->{'_fate'}, $tag, $try) = @$fate;
@try = ($try);
}

my @gather = ();
for (;;) {
if (not @try) {
$relex //= $C->cursor_fate('STD::Regex', 'mod_internal__S_533Colona_01', $retree);
@try = $relex->($C, $trystate);
}
last unless @try;
$try = shift(@try) // next;

if (ref $try eq 'ARRAY') {
($C->{'_fate'}, $tag, $try) = @$try;	# next candidate fate
}

$C->deb("mod_internal__S_533Colona_01 trying $tag $try") if $::DEBUG & DEBUG::try_processing;
push @gather, ((
sub { my $C=shift;
$C->_EXACT(':a')
},
sub { my $C=shift;
$C->_EXACT(':ignoreaccent')
},
)[$try])->($C);
last if @gather;
}
@gather;
};
if (@result) {
@result;
}
elsif ($@) {
my ($first) = $@ =~ /(^.*)/;
$self->deb("CAUGHT $first") if $::DEBUG & DEBUG::trace_call;
die $@ if $@ !~ /^ABORTBRANCH/;
();
}
else {
();
}
}

})
}))) {
do {
if (my ($C) = ($C->_PATTERN(qr/\G\b/))) {
scalar(do {
$::ignoreaccent = 1 
}, $C);
}
else {
();
}
};
}
else {
();
}
}
);
}
##     token mod_internal__S_534ColonBanga (:$sym is context<rw> = <:!a>)
##          token mod_internal:sym<:!a>   { $<sym>=[':!a'|':!ignoreaccent'] » { $*ignoreaccent = 0 } }

sub mod_internal__S_534ColonBanga__PEEK { $_[0]->_AUTOLEXpeek('mod_internal__S_534ColonBanga',$retree) }
sub mod_internal__S_534ColonBanga {
my $self = shift;
local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;
my %args = @_;
local $sym = $args{sym} // q(:!a);


my $C = $self;
my $S = $C->{'_pos'};
$C->{'sym'} = $sym;

$self->_MATCHIFYr($S, "mod_internal__S_534ColonBanga", 
do {
if (my ($C) = (    $C->_SUBSUMEr(['sym'], sub {
my $C = shift;
$C->_BRACKETr( sub { my $C=shift;
do {
my @result = eval {
my $trystate;
my ($tag, $try);
my @try;
my $relex;

my $fate;
if ($fate = $C->{'_fate'} and $fate->[1] eq 'mod_internal__S_534ColonBanga_01') {
$C->deb("Fate passed to mod_internal__S_534ColonBanga_01: ", ::fatestr($fate)) if $::DEBUG & DEBUG::fates;
($C->{'_fate'}, $tag, $try) = @$fate;
@try = ($try);
}

my @gather = ();
for (;;) {
if (not @try) {
$relex //= $C->cursor_fate('STD::Regex', 'mod_internal__S_534ColonBanga_01', $retree);
@try = $relex->($C, $trystate);
}
last unless @try;
$try = shift(@try) // next;

if (ref $try eq 'ARRAY') {
($C->{'_fate'}, $tag, $try) = @$try;	# next candidate fate
}

$C->deb("mod_internal__S_534ColonBanga_01 trying $tag $try") if $::DEBUG & DEBUG::try_processing;
push @gather, ((
sub { my $C=shift;
$C->_EXACT(':!a')
},
sub { my $C=shift;
$C->_EXACT(':!ignoreaccent')
},
)[$try])->($C);
last if @gather;
}
@gather;
};
if (@result) {
@result;
}
elsif ($@) {
my ($first) = $@ =~ /(^.*)/;
$self->deb("CAUGHT $first") if $::DEBUG & DEBUG::trace_call;
die $@ if $@ !~ /^ABORTBRANCH/;
();
}
else {
();
}
}

})
}))) {
do {
if (my ($C) = ($C->_PATTERN(qr/\G\b/))) {
scalar(do {
$::ignoreaccent = 0 
}, $C);
}
else {
();
}
};
}
else {
();
}
}
);
}
##     token mod_internal__S_535ColonaParen_Thesis (:$sym is context<rw> = <:a( )>)
##          token mod_internal:sym<:a( )> { $<sym>=[':a'|':ignoreaccent'] <mod_arg> { $*ignoreaccent = eval $<mod_arg>.Str } }

sub mod_internal__S_535ColonaParen_Thesis__PEEK { $_[0]->_AUTOLEXpeek('mod_internal__S_535ColonaParen_Thesis',$retree) }
sub mod_internal__S_535ColonaParen_Thesis {
my $self = shift;
local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;
my %args = @_;
local $sym = $args{sym} // [qw[:a( )]];


my $C = $self;
my $S = $C->{'_pos'};
$C->{'sym'} = $sym;

$self->_MATCHIFYr($S, "mod_internal__S_535ColonaParen_Thesis", 
do {
if (my ($C) = (    $C->_SUBSUMEr(['sym'], sub {
my $C = shift;
$C->_BRACKETr( sub { my $C=shift;
do {
my @result = eval {
my $trystate;
my ($tag, $try);
my @try;
my $relex;

my $fate;
if ($fate = $C->{'_fate'} and $fate->[1] eq 'mod_internal__S_535ColonaParen_Thesis_01') {
$C->deb("Fate passed to mod_internal__S_535ColonaParen_Thesis_01: ", ::fatestr($fate)) if $::DEBUG & DEBUG::fates;
($C->{'_fate'}, $tag, $try) = @$fate;
@try = ($try);
}

my @gather = ();
for (;;) {
if (not @try) {
$relex //= $C->cursor_fate('STD::Regex', 'mod_internal__S_535ColonaParen_Thesis_01', $retree);
@try = $relex->($C, $trystate);
}
last unless @try;
$try = shift(@try) // next;

if (ref $try eq 'ARRAY') {
($C->{'_fate'}, $tag, $try) = @$try;	# next candidate fate
}

$C->deb("mod_internal__S_535ColonaParen_Thesis_01 trying $tag $try") if $::DEBUG & DEBUG::try_processing;
push @gather, ((
sub { my $C=shift;
$C->_EXACT(':a')
},
sub { my $C=shift;
$C->_EXACT(':ignoreaccent')
},
)[$try])->($C);
last if @gather;
}
@gather;
};
if (@result) {
@result;
}
elsif ($@) {
my ($first) = $@ =~ /(^.*)/;
$self->deb("CAUGHT $first") if $::DEBUG & DEBUG::trace_call;
die $@ if $@ !~ /^ABORTBRANCH/;
();
}
else {
();
}
}

})
}))) {
do {
if (my ($C) = ($C->_SUBSUMEr(['mod_arg'], sub {
my $C = shift;
$C->mod_arg
}))) {
scalar(do {
my $M = $C;  $::ignoreaccent = eval $M->{'mod_arg'}->Str ;
}, $C);
}
else {
();
}
};
}
else {
();
}
}
);
}
##     token mod_internal__S_536Colon0a (:$sym is context<rw> = <:0a>)
##          token mod_internal:sym<:0a>   { ':' (\d+) ['a'|'ignoreaccent'] { $*ignoreaccent = $0 } }

sub mod_internal__S_536Colon0a__PEEK { $_[0]->_AUTOLEXpeek('mod_internal__S_536Colon0a',$retree) }
sub mod_internal__S_536Colon0a {
my $self = shift;
local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;
my %args = @_;
local $sym = $args{sym} // q(:0a);


my $C = $self;
my $S = $C->{'_pos'};
$C->{'sym'} = $sym;

$self->_MATCHIFYr($S, "mod_internal__S_536Colon0a", 
do {
if (my ($C) = ($C->_EXACT(':'))) {
do {
if (my ($C) = (    $C->_SUBSUMEr(['0'], sub {
my $C = shift;
do { $C->_PAREN( sub { my $C=shift;
$C->_PATTERN(qr/\G((?:\d)++)/)
})}
}))) {
do {
if (my ($C) = ($C->_BRACKETr( sub { my $C=shift;
do {
my @result = eval {
my $trystate;
my ($tag, $try);
my @try;
my $relex;

my $fate;
if ($fate = $C->{'_fate'} and $fate->[1] eq 'mod_internal__S_536Colon0a_02') {
$C->deb("Fate passed to mod_internal__S_536Colon0a_02: ", ::fatestr($fate)) if $::DEBUG & DEBUG::fates;
($C->{'_fate'}, $tag, $try) = @$fate;
@try = ($try);
}

my @gather = ();
for (;;) {
if (not @try) {
$relex //= $C->cursor_fate('STD::Regex', 'mod_internal__S_536Colon0a_02', $retree);
@try = $relex->($C, $trystate);
}
last unless @try;
$try = shift(@try) // next;

if (ref $try eq 'ARRAY') {
($C->{'_fate'}, $tag, $try) = @$try;	# next candidate fate
}

$C->deb("mod_internal__S_536Colon0a_02 trying $tag $try") if $::DEBUG & DEBUG::try_processing;
push @gather, ((
sub { my $C=shift;
$C->_EXACT('a')
},
sub { my $C=shift;
$C->_EXACT('ignoreaccent')
},
)[$try])->($C);
last if @gather;
}
@gather;
};
if (@result) {
@result;
}
elsif ($@) {
my ($first) = $@ =~ /(^.*)/;
$self->deb("CAUGHT $first") if $::DEBUG & DEBUG::trace_call;
die $@ if $@ !~ /^ABORTBRANCH/;
();
}
else {
();
}
}

}))) {
scalar(do {
$::ignoreaccent = $C->{'0'} 
}, $C);
}
else {
();
}
};
}
else {
();
}
};
}
else {
();
}
}
);
}

##     token mod_internal__S_537Colons (:$sym is context<rw> = <:s>)
##          token mod_internal:sym<:s>    { ':s' 'igspace'? » { $*sigspace = 1 } }

sub mod_internal__S_537Colons__PEEK { $_[0]->_AUTOLEXpeek('mod_internal__S_537Colons',$retree) }
sub mod_internal__S_537Colons {
my $self = shift;
local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;
my %args = @_;
local $sym = $args{sym} // q(:s);


my $C = $self;
my $S = $C->{'_pos'};
$C->{'sym'} = $sym;

$self->_MATCHIFYr($S, "mod_internal__S_537Colons", 
do {
if (my ($C) = ($C->_EXACT(':s'))) {
do {
if (my ($C) = ($C->_OPTr(sub { my $C=shift;
$C->_EXACT('igspace')
}))) {
do {
if (my ($C) = ($C->_PATTERN(qr/\G\b/))) {
scalar(do {
$::sigspace = 1 
}, $C);
}
else {
();
}
};
}
else {
();
}
};
}
else {
();
}
}
);
}
##     token mod_internal__S_538ColonBangs (:$sym is context<rw> = <:!s>)
##          token mod_internal:sym<:!s>   { ':!s' 'igspace'? » { $*sigspace = 0 } }

sub mod_internal__S_538ColonBangs__PEEK { $_[0]->_AUTOLEXpeek('mod_internal__S_538ColonBangs',$retree) }
sub mod_internal__S_538ColonBangs {
my $self = shift;
local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;
my %args = @_;
local $sym = $args{sym} // q(:!s);


my $C = $self;
my $S = $C->{'_pos'};
$C->{'sym'} = $sym;

$self->_MATCHIFYr($S, "mod_internal__S_538ColonBangs", 
do {
if (my ($C) = ($C->_EXACT(':!s'))) {
do {
if (my ($C) = ($C->_OPTr(sub { my $C=shift;
$C->_EXACT('igspace')
}))) {
do {
if (my ($C) = ($C->_PATTERN(qr/\G\b/))) {
scalar(do {
$::sigspace = 0 
}, $C);
}
else {
();
}
};
}
else {
();
}
};
}
else {
();
}
}
);
}
##     token mod_internal__S_539ColonsParen_Thesis (:$sym is context<rw> = <:s( )>)
##          token mod_internal:sym<:s( )> { ':s' 'igspace'? <mod_arg> { $*sigspace = eval $<mod_arg>.Str } }

sub mod_internal__S_539ColonsParen_Thesis__PEEK { $_[0]->_AUTOLEXpeek('mod_internal__S_539ColonsParen_Thesis',$retree) }
sub mod_internal__S_539ColonsParen_Thesis {
my $self = shift;
local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;
my %args = @_;
local $sym = $args{sym} // [qw[:s( )]];


my $C = $self;
my $S = $C->{'_pos'};
$C->{'sym'} = $sym;

$self->_MATCHIFYr($S, "mod_internal__S_539ColonsParen_Thesis", 
do {
if (my ($C) = ($C->_EXACT(':s'))) {
do {
if (my ($C) = ($C->_OPTr(sub { my $C=shift;
$C->_EXACT('igspace')
}))) {
do {
if (my ($C) = ($C->_SUBSUMEr(['mod_arg'], sub {
my $C = shift;
$C->mod_arg
}))) {
scalar(do {
my $M = $C;  $::sigspace = eval $M->{'mod_arg'}->Str ;
}, $C);
}
else {
();
}
};
}
else {
();
}
};
}
else {
();
}
}
);
}
##     token mod_internal__S_540Colon0s (:$sym is context<rw> = <:0s>)
##          token mod_internal:sym<:0s>   { ':' (\d+) 's' 'igspace'? » { $*sigspace = $0 } }

sub mod_internal__S_540Colon0s__PEEK { $_[0]->_AUTOLEXpeek('mod_internal__S_540Colon0s',$retree) }
sub mod_internal__S_540Colon0s {
my $self = shift;
local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;
my %args = @_;
local $sym = $args{sym} // q(:0s);


my $C = $self;
my $S = $C->{'_pos'};
$C->{'sym'} = $sym;

$self->_MATCHIFYr($S, "mod_internal__S_540Colon0s", 
do {
if (my ($C) = ($C->_EXACT(':'))) {
do {
if (my ($C) = (    $C->_SUBSUMEr(['0'], sub {
my $C = shift;
do { $C->_PAREN( sub { my $C=shift;
$C->_PATTERN(qr/\G((?:\d)++)/)
})}
}))) {
do {
if (my ($C) = ($C->_EXACT('s'))) {
do {
if (my ($C) = ($C->_OPTr(sub { my $C=shift;
$C->_EXACT('igspace')
}))) {
do {
if (my ($C) = ($C->_PATTERN(qr/\G\b/))) {
scalar(do {
$::sigspace = $C->{'0'} 
}, $C);
}
else {
();
}
};
}
else {
();
}
};
}
else {
();
}
};
}
else {
();
}
};
}
else {
();
}
}
);
}

##     token mod_internal__S_541Colonr (:$sym is context<rw> = <:r>)
##          token mod_internal:sym<:r>    { ':r' 'atchet'? » { $*ratchet = 1 } }

sub mod_internal__S_541Colonr__PEEK { $_[0]->_AUTOLEXpeek('mod_internal__S_541Colonr',$retree) }
sub mod_internal__S_541Colonr {
my $self = shift;
local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;
my %args = @_;
local $sym = $args{sym} // q(:r);


my $C = $self;
my $S = $C->{'_pos'};
$C->{'sym'} = $sym;

$self->_MATCHIFYr($S, "mod_internal__S_541Colonr", 
do {
if (my ($C) = ($C->_EXACT(':r'))) {
do {
if (my ($C) = ($C->_OPTr(sub { my $C=shift;
$C->_EXACT('atchet')
}))) {
do {
if (my ($C) = ($C->_PATTERN(qr/\G\b/))) {
scalar(do {
$::ratchet = 1 
}, $C);
}
else {
();
}
};
}
else {
();
}
};
}
else {
();
}
}
);
}
##     token mod_internal__S_542ColonBangr (:$sym is context<rw> = <:!r>)
##          token mod_internal:sym<:!r>   { ':!r' 'atchet'? » { $*ratchet = 0 } }

sub mod_internal__S_542ColonBangr__PEEK { $_[0]->_AUTOLEXpeek('mod_internal__S_542ColonBangr',$retree) }
sub mod_internal__S_542ColonBangr {
my $self = shift;
local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;
my %args = @_;
local $sym = $args{sym} // q(:!r);


my $C = $self;
my $S = $C->{'_pos'};
$C->{'sym'} = $sym;

$self->_MATCHIFYr($S, "mod_internal__S_542ColonBangr", 
do {
if (my ($C) = ($C->_EXACT(':!r'))) {
do {
if (my ($C) = ($C->_OPTr(sub { my $C=shift;
$C->_EXACT('atchet')
}))) {
do {
if (my ($C) = ($C->_PATTERN(qr/\G\b/))) {
scalar(do {
$::ratchet = 0 
}, $C);
}
else {
();
}
};
}
else {
();
}
};
}
else {
();
}
}
);
}
##     token mod_internal__S_543ColonrParen_Thesis (:$sym is context<rw> = <:r( )>)
##          token mod_internal:sym<:r( )> { ':r' 'atchet'? » <mod_arg> { $*ratchet = eval $<mod_arg>.Str } }

sub mod_internal__S_543ColonrParen_Thesis__PEEK { $_[0]->_AUTOLEXpeek('mod_internal__S_543ColonrParen_Thesis',$retree) }
sub mod_internal__S_543ColonrParen_Thesis {
my $self = shift;
local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;
my %args = @_;
local $sym = $args{sym} // [qw[:r( )]];


my $C = $self;
my $S = $C->{'_pos'};
$C->{'sym'} = $sym;

$self->_MATCHIFYr($S, "mod_internal__S_543ColonrParen_Thesis", 
do {
if (my ($C) = ($C->_EXACT(':r'))) {
do {
if (my ($C) = ($C->_OPTr(sub { my $C=shift;
$C->_EXACT('atchet')
}))) {
do {
if (my ($C) = ($C->_PATTERN(qr/\G\b/))) {
do {
if (my ($C) = ($C->_SUBSUMEr(['mod_arg'], sub {
my $C = shift;
$C->mod_arg
}))) {
scalar(do {
my $M = $C;  $::ratchet = eval $M->{'mod_arg'}->Str ;
}, $C);
}
else {
();
}
};
}
else {
();
}
};
}
else {
();
}
};
}
else {
();
}
}
);
}
##     token mod_internal__S_544Colon0r (:$sym is context<rw> = <:0r>)
##          token mod_internal:sym<:0r>   { ':' (\d+) 'r' 'atchet'? » { $*ratchet = $0 } }

sub mod_internal__S_544Colon0r__PEEK { $_[0]->_AUTOLEXpeek('mod_internal__S_544Colon0r',$retree) }
sub mod_internal__S_544Colon0r {
my $self = shift;
local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;
my %args = @_;
local $sym = $args{sym} // q(:0r);


my $C = $self;
my $S = $C->{'_pos'};
$C->{'sym'} = $sym;

$self->_MATCHIFYr($S, "mod_internal__S_544Colon0r", 
do {
if (my ($C) = ($C->_EXACT(':'))) {
do {
if (my ($C) = (    $C->_SUBSUMEr(['0'], sub {
my $C = shift;
do { $C->_PAREN( sub { my $C=shift;
$C->_PATTERN(qr/\G((?:\d)++)/)
})}
}))) {
do {
if (my ($C) = ($C->_EXACT('r'))) {
do {
if (my ($C) = ($C->_OPTr(sub { my $C=shift;
$C->_EXACT('atchet')
}))) {
do {
if (my ($C) = ($C->_PATTERN(qr/\G\b/))) {
scalar(do {
$::ratchet = $C->{'0'} 
}, $C);
}
else {
();
}
};
}
else {
();
}
};
}
else {
();
}
};
}
else {
();
}
};
}
else {
();
}
}
);
}

##     token mod_internal__S_545ColonPerl5 (:$sym is context<rw> = <:Perl5>)
##          token mod_internal:sym<:Perl5>    { [':Perl5' | ':P5'] [ :lang( $¢.cursor_fresh( %*LANG<P5Regex> ).unbalanced($*GOAL) ) <nibbler> ] }

sub mod_internal__S_545ColonPerl5__PEEK { $_[0]->_AUTOLEXpeek('mod_internal__S_545ColonPerl5',$retree) }
sub mod_internal__S_545ColonPerl5 {
my $self = shift;
local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;
my %args = @_;
local $sym = $args{sym} // q(:Perl5);


my $C = $self;
my $S = $C->{'_pos'};
$C->{'sym'} = $sym;

$self->_MATCHIFYr($S, "mod_internal__S_545ColonPerl5", 
do {
if (my ($C) = ($C->_BRACKETr( sub { my $C=shift;
do {
my @result = eval {
my $trystate;
my ($tag, $try);
my @try;
my $relex;

my $fate;
if ($fate = $C->{'_fate'} and $fate->[1] eq 'mod_internal__S_545ColonPerl5_01') {
$C->deb("Fate passed to mod_internal__S_545ColonPerl5_01: ", ::fatestr($fate)) if $::DEBUG & DEBUG::fates;
($C->{'_fate'}, $tag, $try) = @$fate;
@try = ($try);
}

my @gather = ();
for (;;) {
if (not @try) {
$relex //= $C->cursor_fate('STD::Regex', 'mod_internal__S_545ColonPerl5_01', $retree);
@try = $relex->($C, $trystate);
}
last unless @try;
$try = shift(@try) // next;

if (ref $try eq 'ARRAY') {
($C->{'_fate'}, $tag, $try) = @$try;	# next candidate fate
}

$C->deb("mod_internal__S_545ColonPerl5_01 trying $tag $try") if $::DEBUG & DEBUG::try_processing;
push @gather, ((
sub { my $C=shift;
$C->_EXACT(':Perl5')
},
sub { my $C=shift;
$C->_EXACT(':P5')
},
)[$try])->($C);
last if @gather;
}
@gather;
};
if (@result) {
@result;
}
elsif ($@) {
my ($first) = $@ =~ /(^.*)/;
$self->deb("CAUGHT $first") if $::DEBUG & DEBUG::trace_call;
die $@ if $@ !~ /^ABORTBRANCH/;
();
}
else {
();
}
}

}))) {
$C->_BRACKETr( sub { my $C=shift;
my $newlang = ( $C->cursor_fresh( $::LANG{'P5Regex'} )->unbalanced($::GOAL) );  $C = $C->cursor_fresh($newlang); ;$C->_SUBSUMEr(['nibbler'], sub {
my $C = shift;
$C->nibbler
})
});
}
else {
();
}
}
);
}

##     token mod_internal__S_546adv (:$sym is context<rw> = 'adv')
##          token mod_internal:adv {
##              <?before ':' <.identifier> > [ :lang($¢.cursor_fresh(%*LANG<MAIN>)) <quotepair> ] { $/<sym> := «: $<quotepair><key>» }
##          }

sub mod_internal__S_546adv__PEEK { $_[0]->_AUTOLEXpeek('mod_internal__S_546adv',$retree) }
sub mod_internal__S_546adv {
my $self = shift;
local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;
my %args = @_;
local $sym = $args{sym} // 'adv';


my $C = $self;
my $S = $C->{'_pos'};
$C->{'sym'} = $sym;

$self->_MATCHIFYr($S, "mod_internal__S_546adv", 
do {
if (my ($C) = ($C->before(sub { my $C=shift;
do {
if (my ($C) = ($C->_EXACT(':'))) {
$C->identifier;
}
else {
();
}
}
}))) {
do {
if (my ($C) = ($C->_BRACKETr( sub { my $C=shift;
my $newlang = ($C->cursor_fresh($::LANG{'MAIN'}));  $C = $C->cursor_fresh($newlang); ;$C->_SUBSUMEr(['quotepair'], sub {
my $C = shift;
$C->quotepair
})
}))) {
scalar(do {
my $M = $C;  $M->{'sym'} =[':','$<quotepair><key>'] ;
}, $C);
}
else {
();
}
};
}
else {
();
}
}
);
}

##     token mod_internal__S_547oops (:$sym is context<rw> = 'oops')
##          token mod_internal:oops { ':'\w+ <.panic: "Unrecognized regex modifier"> }

sub mod_internal__S_547oops__PEEK { $_[0]->_AUTOLEXpeek('mod_internal__S_547oops',$retree) }
sub mod_internal__S_547oops {
my $self = shift;
local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;
my %args = @_;
local $sym = $args{sym} // 'oops';


my $C = $self;
my $S = $C->{'_pos'};
$C->{'sym'} = $sym;

$self->_MATCHIFYr($S, "mod_internal__S_547oops", 
do {
if (my ($C) = ($C->_EXACT(':'))) {
do {
if (my ($C) = ($C->_PATTERN(qr/\G((?:\w)++)/))) {
$C->panic("Unrecognized regex modifier");
}
else {
();
}
};
}
else {
();
}
}
);
}

##     token quantifier__S_548Star (:$sym is context<rw> = <*>)
##          token quantifier:sym<*>  { <sym> <quantmod> }

sub quantifier__S_548Star__PEEK { $_[0]->_AUTOLEXpeek('quantifier__S_548Star',$retree) }
sub quantifier__S_548Star {
my $self = shift;
local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;
my %args = @_;
local $sym = $args{sym} // q(*);


my $C = $self;
my $S = $C->{'_pos'};
$C->{'sym'} = $sym;

$self->_MATCHIFYr($S, "quantifier__S_548Star", 
do {
if (my ($C) = ($C->_PATTERN(qr/\G\*/))) {
$C->_SUBSUMEr(['quantmod'], sub {
my $C = shift;
$C->quantmod
});
}
else {
();
}
}
);
}
##     token quantifier__S_549Plus (:$sym is context<rw> = <+>)
##          token quantifier:sym<+>  { <sym> <quantmod> }

sub quantifier__S_549Plus__PEEK { $_[0]->_AUTOLEXpeek('quantifier__S_549Plus',$retree) }
sub quantifier__S_549Plus {
my $self = shift;
local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;
my %args = @_;
local $sym = $args{sym} // q(+);


my $C = $self;
my $S = $C->{'_pos'};
$C->{'sym'} = $sym;

$self->_MATCHIFYr($S, "quantifier__S_549Plus", 
do {
if (my ($C) = ($C->_PATTERN(qr/\G\+/))) {
$C->_SUBSUMEr(['quantmod'], sub {
my $C = shift;
$C->quantmod
});
}
else {
();
}
}
);
}
##     token quantifier__S_550Question (:$sym is context<rw> = <?>)
##          token quantifier:sym<?>  { <sym> <quantmod> }

sub quantifier__S_550Question__PEEK { $_[0]->_AUTOLEXpeek('quantifier__S_550Question',$retree) }
sub quantifier__S_550Question {
my $self = shift;
local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;
my %args = @_;
local $sym = $args{sym} // q(?);


my $C = $self;
my $S = $C->{'_pos'};
$C->{'sym'} = $sym;

$self->_MATCHIFYr($S, "quantifier__S_550Question", 
do {
if (my ($C) = ($C->_PATTERN(qr/\G\?/))) {
$C->_SUBSUMEr(['quantmod'], sub {
my $C = shift;
$C->quantmod
});
}
else {
();
}
}
);
}
##     token quantifier__S_551StarStar (:$sym is context<rw> = <**>)
##          token quantifier:sym<**> { <sym> :: <normspace>? <quantmod> <normspace>?
##              [
##              | \d+ [ '..' [ \d+ | '*' ] ]?
##              | <codeblock>
##              | <quantified_atom>
##              ]
##          }

sub quantifier__S_551StarStar__PEEK { $_[0]->_AUTOLEXpeek('quantifier__S_551StarStar',$retree) }
sub quantifier__S_551StarStar {
my $self = shift;
local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;
my %args = @_;
local $sym = $args{sym} // q(**);


my $C = $self;
my $S = $C->{'_pos'};
$C->{'normspace'} = [];
$C->{'sym'} = $sym;

$self->_MATCHIFY($S, "quantifier__S_551StarStar", 
Cursor::lazymap(sub { my $C=$_[0];
Cursor::lazymap(sub { my $C=$_[0];
Cursor::lazymap(sub { my $C=$_[0];
Cursor::lazymap(sub { my $C=$_[0];
Cursor::lazymap(sub { my $C=$_[0];
$C->_BRACKET( sub { my $C=shift;
do {
my @result = eval {
my $trystate;
my ($tag, $try);
my @try;
my $relex;

my $fate;
if ($fate = $C->{'_fate'} and $fate->[1] eq 'quantifier__S_551StarStar_01') {
$C->deb("Fate passed to quantifier__S_551StarStar_01: ", ::fatestr($fate)) if $::DEBUG & DEBUG::fates;
($C->{'_fate'}, $tag, $try) = @$fate;
@try = ($try);
}

my @gather = ();
for (;;) {
if (not @try) {
$relex //= $C->cursor_fate('STD::Regex', 'quantifier__S_551StarStar_01', $retree);
@try = $relex->($C, $trystate);
}
last unless @try;
$try = shift(@try) // next;

if (ref $try eq 'ARRAY') {
($C->{'_fate'}, $tag, $try) = @$try;	# next candidate fate
}

$C->deb("quantifier__S_551StarStar_01 trying $tag $try") if $::DEBUG & DEBUG::try_processing;
push @gather, ((
sub { my $C=shift;
Cursor::lazymap(sub { my $C=$_[0];
$C->_OPTr(sub { my $C=shift;
$C->_BRACKET( sub { my $C=shift;
Cursor::lazymap(sub { my $C=$_[0];
$C->_BRACKET( sub { my $C=shift;
do {
my @result = eval {
my $trystate;
my ($tag, $try);
my @try;
my $relex;

my $fate;
if ($fate = $C->{'_fate'} and $fate->[1] eq 'quantifier__S_551StarStar_03') {
$C->deb("Fate passed to quantifier__S_551StarStar_03: ", ::fatestr($fate)) if $::DEBUG & DEBUG::fates;
($C->{'_fate'}, $tag, $try) = @$fate;
@try = ($try);
}

my @gather = ();
for (;;) {
if (not @try) {
$relex //= $C->cursor_fate('STD::Regex', 'quantifier__S_551StarStar_03', $retree);
@try = $relex->($C, $trystate);
}
last unless @try;
$try = shift(@try) // next;

if (ref $try eq 'ARRAY') {
($C->{'_fate'}, $tag, $try) = @$try;	# next candidate fate
}

$C->deb("quantifier__S_551StarStar_03 trying $tag $try") if $::DEBUG & DEBUG::try_processing;
push @gather, ((
sub { my $C=shift;
$C->_PATTERN(qr/\G((?:\d)++)/)
},
sub { my $C=shift;
$C->_EXACT('*')
},
)[$try])->($C);
last if @gather;
}
@gather;
};
if (@result) {
@result;
}
elsif ($@) {
my ($first) = $@ =~ /(^.*)/;
$self->deb("CAUGHT $first") if $::DEBUG & DEBUG::trace_call;
die $@ if $@ !~ /^ABORTBRANCH/;
();
}
else {
();
}
}

})
}, $C->_EXACT('..'))
})
})
}, $C->_PATTERN(qr/\G((?:\d)++)/))
},
sub { my $C=shift;
$C->_SUBSUME(['codeblock'], sub {
my $C = shift;
$C->codeblock
})
},
sub { my $C=shift;
$C->_SUBSUME(['quantified_atom'], sub {
my $C = shift;
$C->quantified_atom
})
},
)[$try])->($C);
last if @gather;
}
@gather;
};
if (@result) {
@result;
}
elsif ($@) {
my ($first) = $@ =~ /(^.*)/;
$self->deb("CAUGHT $first") if $::DEBUG & DEBUG::trace_call;
die $@ if $@ !~ /^ABORTBRANCH/;
();
}
else {
();
}
}

})
}, $C->_OPTr(sub { my $C=shift;
$C->_SUBSUME(['normspace'], sub {
my $C = shift;
$C->normspace
})
}))
}, $C->_SUBSUME(['quantmod'], sub {
my $C = shift;
$C->quantmod
}))
}, $C->_OPTr(sub { my $C=shift;
$C->_SUBSUME(['normspace'], sub {
my $C = shift;
$C->normspace
})
}))
}, $C->_COMMITBRANCH())
}, $C->_PATTERN(qr/\G\*\*/))
);
}

##     token quantifier__S_552TildeTilde (:$sym is context<rw> = <~~>)
##          token quantifier:sym<~~> {
##              [
##              | '!' <sym>
##              | <sym>
##              ]
##              <normspace> <quantified_atom> }

sub quantifier__S_552TildeTilde__PEEK { $_[0]->_AUTOLEXpeek('quantifier__S_552TildeTilde',$retree) }
sub quantifier__S_552TildeTilde {
my $self = shift;
local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;
my %args = @_;
local $sym = $args{sym} // q(~~);


my $C = $self;
my $S = $C->{'_pos'};
$C->{'sym'} = $sym;

$self->_MATCHIFYr($S, "quantifier__S_552TildeTilde", 
do {
if (my ($C) = ($C->_BRACKETr( sub { my $C=shift;
do {
my @result = eval {
my $trystate;
my ($tag, $try);
my @try;
my $relex;

my $fate;
if ($fate = $C->{'_fate'} and $fate->[1] eq 'quantifier__S_552TildeTilde_01') {
$C->deb("Fate passed to quantifier__S_552TildeTilde_01: ", ::fatestr($fate)) if $::DEBUG & DEBUG::fates;
($C->{'_fate'}, $tag, $try) = @$fate;
@try = ($try);
}

my @gather = ();
for (;;) {
if (not @try) {
$relex //= $C->cursor_fate('STD::Regex', 'quantifier__S_552TildeTilde_01', $retree);
@try = $relex->($C, $trystate);
}
last unless @try;
$try = shift(@try) // next;

if (ref $try eq 'ARRAY') {
($C->{'_fate'}, $tag, $try) = @$try;	# next candidate fate
}

$C->deb("quantifier__S_552TildeTilde_01 trying $tag $try") if $::DEBUG & DEBUG::try_processing;
push @gather, ((
sub { my $C=shift;
do {
if (my ($C) = ($C->_EXACT('!'))) {
$C->_PATTERN(qr/\G\~\~/);
}
else {
();
}
}
},
sub { my $C=shift;
$C->_PATTERN(qr/\G\~\~/)
},
)[$try])->($C);
last if @gather;
}
@gather;
};
if (@result) {
@result;
}
elsif ($@) {
my ($first) = $@ =~ /(^.*)/;
$self->deb("CAUGHT $first") if $::DEBUG & DEBUG::trace_call;
die $@ if $@ !~ /^ABORTBRANCH/;
();
}
else {
();
}
}

}))) {
do {
if (my ($C) = ($C->_SUBSUMEr(['normspace'], sub {
my $C = shift;
$C->normspace
}))) {
$C->_SUBSUMEr(['quantified_atom'], sub {
my $C = shift;
$C->quantified_atom
});
}
else {
();
}
};
}
else {
();
}
}
);
}

##     token quantmod
##          token quantmod { ':'? [ '?' | '!' | '+' ]? }

sub quantmod__PEEK { $_[0]->_AUTOLEXpeek('quantmod',$retree) }
sub quantmod {
my $self = shift;
local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;


my $C = $self;
my $S = $C->{'_pos'};

$self->_MATCHIFYr($S, "quantmod", 
do {
if (my ($C) = ($C->_OPTr(sub { my $C=shift;
$C->_EXACT(':')
}))) {
$C->_OPTr(sub { my $C=shift;
$C->_BRACKETr( sub { my $C=shift;
do {
my @result = eval {
my $trystate;
my ($tag, $try);
my @try;
my $relex;

my $fate;
if ($fate = $C->{'_fate'} and $fate->[1] eq 'quantmod_01') {
$C->deb("Fate passed to quantmod_01: ", ::fatestr($fate)) if $::DEBUG & DEBUG::fates;
($C->{'_fate'}, $tag, $try) = @$fate;
@try = ($try);
}

my @gather = ();
for (;;) {
if (not @try) {
$relex //= $C->cursor_fate('STD::Regex', 'quantmod_01', $retree);
@try = $relex->($C, $trystate);
}
last unless @try;
$try = shift(@try) // next;

if (ref $try eq 'ARRAY') {
($C->{'_fate'}, $tag, $try) = @$try;	# next candidate fate
}

$C->deb("quantmod_01 trying $tag $try") if $::DEBUG & DEBUG::try_processing;
push @gather, ((
sub { my $C=shift;
$C->_EXACT('?')
},
sub { my $C=shift;
$C->_EXACT('!')
},
sub { my $C=shift;
$C->_EXACT('+')
},
)[$try])->($C);
last if @gather;
}
@gather;
};
if (@result) {
@result;
}
elsif ($@) {
my ($first) = $@ =~ /(^.*)/;
$self->deb("CAUGHT $first") if $::DEBUG & DEBUG::trace_call;
die $@ if $@ !~ /^ABORTBRANCH/;
();
}
else {
();
}
}

})
});
}
else {
();
}
}
);
}

BEGIN {
$retree = YAML::Syck::Load(<<'RETREE_END');
--- 
assertion__S_510DotDotDot: !!perl/hash:RE 
  decl: []

  kind: token
  min: 12345
  pkg: ~
  re: !!perl/hash:RE_method 
    a: 0
    dba: assertion__S_510DotDotDot
    i: 0
    min: 12345
    name: sym
    r: 1
    rest: ''
    s: 0
    sym: ...
assertion__S_511QuestionQuestionQuestion: !!perl/hash:RE 
  decl: []

  kind: token
  min: 12345
  pkg: ~
  re: !!perl/hash:RE_method 
    a: 0
    dba: assertion__S_511QuestionQuestionQuestion
    i: 0
    min: 12345
    name: sym
    r: 1
    rest: ''
    s: 0
    sym: ???
assertion__S_512BangBangBang: !!perl/hash:RE 
  decl: []

  kind: token
  min: 12345
  pkg: ~
  re: !!perl/hash:RE_method 
    a: 0
    dba: assertion__S_512BangBangBang
    i: 0
    min: 12345
    name: sym
    r: 1
    rest: ''
    s: 0
    sym: "!!!"
assertion__S_513Question: !!perl/hash:RE 
  decl: []

  kind: token
  min: 12345
  pkg: ~
  re: !!perl/hash:RE_sequence 
    a: 0
    dba: assertion__S_513Question
    i: 0
    min: 12345
    r: 1
    s: 0
    zyg: 
      - !!perl/hash:RE_method 
        a: 0
        dba: assertion__S_513Question
        i: 0
        min: 12345
        name: sym
        r: 1
        rest: ''
        s: 0
        sym: "?"
      - !!perl/hash:RE_bracket 
        decl: []

        min: 0
        re: &18 !!perl/hash:RE_any 
          a: 0
          altname: assertion__S_513Question_01
          dba: assertion__S_513Question
          i: 0
          min: 0
          name: assertion__S_513Question_01
          r: 1
          s: 0
          zyg: 
            - !!perl/hash:RE_assertion 
              alt: assertion__S_513Question_01 0
              assert: "?"
              min: 0
              re: !!perl/hash:RE_method_re 
                a: 0
                dba: assertion__S_513Question
                i: 0
                min: 0
                name: before
                nobind: 1
                r: 1
                re: !!perl/hash:RE 
                  decl: []

                  min: 1
                  re: !!perl/hash:RE_string 
                    a: 0
                    dba: assertion__S_513Question
                    i: 0
                    min: 1
                    r: 1
                    s: 0
                    text: ">"
                s: 0
            - !!perl/hash:RE_method 
              a: 0
              alt: assertion__S_513Question_01 1
              dba: assertion__S_513Question
              i: 0
              min: 12345
              name: assertion
              r: 1
              rest: ''
              s: 0
assertion__S_513Question_01: *18
assertion__S_514Bang: !!perl/hash:RE 
  decl: []

  kind: token
  min: 12345
  pkg: ~
  re: !!perl/hash:RE_sequence 
    a: 0
    dba: assertion__S_514Bang
    i: 0
    min: 12345
    r: 1
    s: 0
    zyg: 
      - !!perl/hash:RE_method 
        a: 0
        dba: assertion__S_514Bang
        i: 0
        min: 12345
        name: sym
        r: 1
        rest: ''
        s: 0
        sym: "!"
      - !!perl/hash:RE_bracket 
        decl: []

        min: 0
        re: &9 !!perl/hash:RE_any 
          a: 0
          altname: assertion__S_514Bang_01
          dba: assertion__S_514Bang
          i: 0
          min: 0
          name: assertion__S_514Bang_01
          r: 1
          s: 0
          zyg: 
            - !!perl/hash:RE_assertion 
              alt: assertion__S_514Bang_01 0
              assert: "?"
              min: 0
              re: !!perl/hash:RE_method_re 
                a: 0
                dba: assertion__S_514Bang
                i: 0
                min: 0
                name: before
                nobind: 1
                r: 1
                re: !!perl/hash:RE 
                  decl: []

                  min: 1
                  re: !!perl/hash:RE_string 
                    a: 0
                    dba: assertion__S_514Bang
                    i: 0
                    min: 1
                    r: 1
                    s: 0
                    text: ">"
                s: 0
            - !!perl/hash:RE_method 
              a: 0
              alt: assertion__S_514Bang_01 1
              dba: assertion__S_514Bang
              i: 0
              min: 12345
              name: assertion
              r: 1
              rest: ''
              s: 0
assertion__S_514Bang_01: *9
assertion__S_515Star: !!perl/hash:RE 
  decl: []

  kind: token
  min: 12345
  pkg: ~
  re: !!perl/hash:RE_sequence 
    a: 0
    dba: assertion__S_515Star
    i: 0
    min: 12345
    r: 1
    s: 0
    zyg: 
      - !!perl/hash:RE_method 
        a: 0
        dba: assertion__S_515Star
        i: 0
        min: 12345
        name: sym
        r: 1
        rest: ''
        s: 0
        sym: "*"
      - !!perl/hash:RE_bracket 
        decl: []

        min: 0
        re: &31 !!perl/hash:RE_any 
          a: 0
          altname: assertion__S_515Star_01
          dba: assertion__S_515Star
          i: 0
          min: 0
          name: assertion__S_515Star_01
          r: 1
          s: 0
          zyg: 
            - !!perl/hash:RE_assertion 
              alt: assertion__S_515Star_01 0
              assert: "?"
              min: 0
              re: !!perl/hash:RE_method_re 
                a: 0
                dba: assertion__S_515Star
                i: 0
                min: 0
                name: before
                nobind: 1
                r: 1
                re: !!perl/hash:RE 
                  decl: []

                  min: 1
                  re: !!perl/hash:RE_string 
                    a: 0
                    dba: assertion__S_515Star
                    i: 0
                    min: 1
                    r: 1
                    s: 0
                    text: ">"
                s: 0
            - !!perl/hash:RE_sequence 
              a: 0
              alt: assertion__S_515Star_01 1
              dba: assertion__S_515Star
              i: 0
              min: 24690
              r: 1
              s: 0
              zyg: 
                - !!perl/hash:RE_method 
                  a: 0
                  dba: assertion__S_515Star
                  i: 0
                  min: 12345
                  name: ws
                  nobind: 1
                  r: 1
                  rest: ''
                  s: 0
                - !!perl/hash:RE_method 
                  a: 0
                  dba: assertion__S_515Star
                  i: 0
                  min: 12345
                  name: nibbler
                  r: 1
                  rest: ''
                  s: 0
assertion__S_515Star_01: *31
assertion__S_516Cur_Ly: !!perl/hash:RE 
  decl: []

  kind: token
  min: 12345
  pkg: ~
  re: !!perl/hash:RE_method 
    a: 0
    dba: assertion__S_516Cur_Ly
    i: 0
    min: 12345
    name: codeblock
    r: 1
    rest: ''
    s: 0
assertion__S_517variable: !!perl/hash:RE 
  decl: []

  kind: token
  min: 0
  pkg: ~
  re: !!perl/hash:RE_sequence 
    a: 0
    dba: assertion__S_517variable
    i: 0
    min: 0
    r: 1
    s: 0
    zyg: 
      - !!perl/hash:RE_assertion 
        assert: "?"
        min: 0
        re: !!perl/hash:RE_method_re 
          a: 0
          dba: assertion__S_517variable
          i: 0
          min: 0
          name: before
          nobind: 1
          r: 1
          re: !!perl/hash:RE 
            decl: []

            min: 12345
            re: !!perl/hash:RE_method 
              a: 0
              dba: assertion__S_517variable
              i: 0
              min: 12345
              name: sigil
              r: 1
              rest: ''
              s: 0
          s: 0
      - !!perl/hash:RE_bracket 
        decl: []

        min: 0
        re: !!perl/hash:RE_sequence 
          a: 0
          dba: assertion__S_517variable
          i: 0
          lang: ($C->cursor_fresh($::LANG{'MAIN'})->unbalanced('>'))
          min: 0
          r: 1
          s: 0
          zyg: 
            - !!perl/hash:RE_decl 
              a: 0
              dba: assertion__S_517variable
              i: 0
              lang: ($C->cursor_fresh($::LANG{'MAIN'})->unbalanced('>'))
              max: 0
              min: 0
              noquant: 1
              r: 1
              s: 0
              text: "my $newlang = ($C->cursor_fresh($::LANG{'MAIN'})->unbalanced('>'));  $C = $C->cursor_fresh($newlang); "
            - !!perl/hash:RE_bindnamed 
              a: 0
              atom: !!perl/hash:RE_method 
                min: 0
                name: EXPR
                nobind: 1
                rest: (item %LOOSEST)
              dba: assertion__S_517variable
              i: 0
              lang: ($C->cursor_fresh($::LANG{'MAIN'})->unbalanced('>'))
              min: 0
              r: 1
              s: 0
              var: variable
assertion__S_518method: !!perl/hash:RE 
  decl: []

  kind: token
  min: 12346
  pkg: ~
  re: !!perl/hash:RE_sequence 
    a: 0
    dba: assertion__S_518method
    i: 0
    min: 12346
    r: 1
    s: 0
    zyg: 
      - !!perl/hash:RE_string 
        a: 0
        dba: assertion__S_518method
        i: 0
        min: 1
        r: 1
        s: 0
        text: .
      - !!perl/hash:RE_bracket 
        decl: []

        min: 12345
        re: &22 !!perl/hash:RE_any 
          a: 0
          altname: assertion__S_518method_01
          dba: assertion__S_518method
          i: 0
          min: 12345
          name: assertion__S_518method_01
          r: 1
          s: 0
          zyg: 
            - !!perl/hash:RE_sequence 
              a: 0
              alt: assertion__S_518method_01 0
              dba: assertion__S_518method
              i: 0
              min: 12345
              r: 1
              s: 0
              zyg: 
                - !!perl/hash:RE_assertion 
                  assert: "?"
                  min: 0
                  re: !!perl/hash:RE_method_re 
                    a: 0
                    dba: assertion__S_518method
                    i: 0
                    min: 0
                    name: before
                    nobind: 1
                    r: 1
                    re: !!perl/hash:RE 
                      decl: []

                      min: 12345
                      re: !!perl/hash:RE_method 
                        a: 0
                        dba: assertion__S_518method
                        i: 0
                        min: 12345
                        name: alpha
                        r: 1
                        rest: ''
                        s: 0
                    s: 0
                - !!perl/hash:RE_method 
                  a: 0
                  dba: assertion__S_518method
                  i: 0
                  min: 12345
                  name: assertion
                  r: 1
                  rest: ''
                  s: 0
            - !!perl/hash:RE_bracket 
              alt: assertion__S_518method_01 1
              decl: []

              min: 12345
              re: !!perl/hash:RE_sequence 
                a: 0
                dba: assertion__S_518method
                i: 0
                lang: ($C->cursor_fresh($::LANG{'MAIN'})->unbalanced('>'))
                min: 12345
                r: 1
                s: 0
                zyg: 
                  - !!perl/hash:RE_decl 
                    a: 0
                    dba: assertion__S_518method
                    i: 0
                    lang: ($C->cursor_fresh($::LANG{'MAIN'})->unbalanced('>'))
                    max: 0
                    min: 0
                    noquant: 1
                    r: 1
                    s: 0
                    text: "my $newlang = ($C->cursor_fresh($::LANG{'MAIN'})->unbalanced('>'));  $C = $C->cursor_fresh($newlang); "
                  - !!perl/hash:RE_method 
                    a: 0
                    dba: assertion__S_518method
                    i: 0
                    lang: ($C->cursor_fresh($::LANG{'MAIN'})->unbalanced('>'))
                    min: 12345
                    name: dottyop
                    r: 1
                    rest: ''
                    s: 0
assertion__S_518method_01: *22
assertion__S_519name: !!perl/hash:RE 
  decl: []

  kind: token
  min: 12345
  pkg: ~
  re: !!perl/hash:RE_sequence 
    a: 0
    dba: assertion__S_519name
    i: 0
    min: 12345
    r: 1
    s: 0
    zyg: 
      - !!perl/hash:RE_bracket 
        decl: []

        min: 12345
        re: !!perl/hash:RE_sequence 
          a: 0
          dba: assertion__S_519name
          i: 0
          lang: ($C->cursor_fresh($::LANG{'MAIN'})->unbalanced('>'))
          min: 12345
          r: 1
          s: 0
          zyg: 
            - !!perl/hash:RE_decl 
              a: 0
              dba: assertion__S_519name
              i: 0
              lang: ($C->cursor_fresh($::LANG{'MAIN'})->unbalanced('>'))
              max: 0
              min: 0
              noquant: 1
              r: 1
              s: 0
              text: "my $newlang = ($C->cursor_fresh($::LANG{'MAIN'})->unbalanced('>'));  $C = $C->cursor_fresh($newlang); "
            - !!perl/hash:RE_method 
              a: 0
              dba: assertion__S_519name
              i: 0
              lang: ($C->cursor_fresh($::LANG{'MAIN'})->unbalanced('>'))
              min: 12345
              name: longname
              r: 1
              rest: ''
              s: 0
      - !!perl/hash:RE_quantified_atom 
        atom: !!perl/hash:RE_bracket 
          decl: []

          min: 0
          re: &3 !!perl/hash:RE_any 
            a: 0
            altname: assertion__S_519name_02
            dba: assertion__S_519name
            i: 0
            min: 0
            name: assertion__S_519name_02
            r: 1
            s: 0
            zyg: 
              - !!perl/hash:RE_assertion 
                alt: assertion__S_519name_02 0
                assert: "?"
                min: 0
                re: !!perl/hash:RE_method_re 
                  a: 0
                  dba: assertion__S_519name
                  i: 0
                  min: 0
                  name: before
                  nobind: 1
                  r: 1
                  re: !!perl/hash:RE 
                    decl: []

                    min: 1
                    re: !!perl/hash:RE_string 
                      a: 0
                      dba: assertion__S_519name
                      i: 0
                      min: 1
                      r: 1
                      s: 0
                      text: ">"
                  s: 0
              - !!perl/hash:RE_sequence 
                a: 0
                alt: assertion__S_519name_02 1
                dba: assertion__S_519name
                i: 0
                min: 24690
                r: 1
                s: 0
                zyg: 
                  - !!perl/hash:RE_method 
                    a: 0
                    dba: assertion__S_519name
                    i: 0
                    min: 12345
                    name: ws
                    nobind: 1
                    r: 1
                    rest: ''
                    s: 0
                  - !!perl/hash:RE_method 
                    a: 0
                    dba: assertion__S_519name
                    i: 0
                    min: 12345
                    name: nibbler
                    r: 1
                    rest: ''
                    s: 0
              - !!perl/hash:RE_sequence 
                a: 0
                alt: assertion__S_519name_02 2
                dba: assertion__S_519name
                i: 0
                min: 12346
                r: 1
                s: 0
                zyg: 
                  - !!perl/hash:RE_string 
                    a: 0
                    dba: assertion__S_519name
                    i: 0
                    min: 1
                    r: 1
                    s: 0
                    text: =
                  - !!perl/hash:RE_method 
                    a: 0
                    dba: assertion__S_519name
                    i: 0
                    min: 12345
                    name: assertion
                    r: 1
                    rest: ''
                    s: 0
              - !!perl/hash:RE_sequence 
                a: 0
                alt: assertion__S_519name_02 3
                dba: assertion__S_519name
                i: 0
                min: 24691
                r: 1
                s: 0
                zyg: 
                  - !!perl/hash:RE_string 
                    a: 0
                    dba: assertion__S_519name
                    i: 0
                    min: 1
                    r: 1
                    s: 0
                    text: ":"
                  - !!perl/hash:RE_method 
                    a: 0
                    dba: assertion__S_519name
                    i: 0
                    min: 12345
                    name: ws
                    nobind: 1
                    r: 1
                    rest: ''
                    s: 0
                  - !!perl/hash:RE_bracket 
                    decl: []

                    min: 12345
                    re: !!perl/hash:RE_sequence 
                      a: 0
                      dba: assertion__S_519name
                      i: 0
                      lang: ($C->cursor_fresh($::LANG{'MAIN'})->unbalanced('>'))
                      min: 12345
                      r: 1
                      s: 0
                      zyg: 
                        - !!perl/hash:RE_decl 
                          a: 0
                          dba: assertion__S_519name
                          i: 0
                          lang: ($C->cursor_fresh($::LANG{'MAIN'})->unbalanced('>'))
                          max: 0
                          min: 0
                          noquant: 1
                          r: 1
                          s: 0
                          text: "my $newlang = ($C->cursor_fresh($::LANG{'MAIN'})->unbalanced('>'));  $C = $C->cursor_fresh($newlang); "
                        - !!perl/hash:RE_method 
                          a: 0
                          dba: assertion__S_519name
                          i: 0
                          lang: ($C->cursor_fresh($::LANG{'MAIN'})->unbalanced('>'))
                          min: 12345
                          name: arglist
                          r: 1
                          rest: ''
                          s: 0
              - !!perl/hash:RE_sequence 
                a: 0
                alt: assertion__S_519name_02 4
                dba: assertion__S_519name
                i: 0
                min: 12346
                r: 1
                s: 0
                zyg: 
                  - !!perl/hash:RE_string 
                    a: 0
                    dba: assertion__S_519name
                    i: 0
                    min: 1
                    r: 1
                    s: 0
                    text: (
                  - !!perl/hash:RE_block 
                    a: 0
                    context: void
                    dba: assertion__S_519name
                    i: 0
                    min: 0
                    r: 1
                    s: 0
                    text: ''
                  - !!perl/hash:RE_bracket 
                    decl: []

                    min: 12345
                    re: !!perl/hash:RE_sequence 
                      a: 0
                      dba: assertion__S_519name
                      i: 0
                      lang: ($C->cursor_fresh($::LANG{'MAIN'}))
                      min: 12345
                      r: 1
                      s: 0
                      zyg: 
                        - !!perl/hash:RE_decl 
                          a: 0
                          dba: assertion__S_519name
                          i: 0
                          lang: ($C->cursor_fresh($::LANG{'MAIN'}))
                          max: 0
                          min: 0
                          noquant: 1
                          r: 1
                          s: 0
                          text: "my $newlang = ($C->cursor_fresh($::LANG{'MAIN'}));  $C = $C->cursor_fresh($newlang); "
                        - !!perl/hash:RE_method 
                          a: 0
                          dba: assertion__S_519name
                          i: 0
                          lang: ($C->cursor_fresh($::LANG{'MAIN'}))
                          min: 12345
                          name: arglist
                          r: 1
                          rest: ''
                          s: 0
                  - !!perl/hash:RE_bracket 
                    decl: []

                    min: 0
                    re: !!perl/hash:RE_first 
                      a: 0
                      dba: assertion__S_519name
                      i: 0
                      min: 0
                      r: 1
                      s: 0
                      zyg: 
                        - !!perl/hash:RE_string 
                          a: 0
                          dba: assertion__S_519name
                          i: 0
                          min: 1
                          r: 1
                          s: 0
                          text: )
                        - !!perl/hash:RE_method 
                          min: 0
                          name: panic
                          nobind: 1
                          rest: ("Assertion call missing right parenthesis")
        min: 0
        quant: 
          - "?"
          - ":"
          - ''
          - 0
assertion__S_519name_02: *3
assertion__S_520Bra: !!perl/hash:RE 
  decl: []

  kind: token
  min: 12345
  pkg: ~
  re: !!perl/hash:RE_sequence 
    a: 0
    dba: assertion__S_520Bra
    i: 0
    min: 12345
    r: 1
    s: 0
    zyg: 
      - !!perl/hash:RE_assertion 
        assert: "?"
        min: 0
        re: !!perl/hash:RE_method_re 
          a: 0
          dba: assertion__S_520Bra
          i: 0
          min: 0
          name: before
          nobind: 1
          r: 1
          re: !!perl/hash:RE 
            decl: []

            min: 1
            re: !!perl/hash:RE_string 
              a: 0
              dba: assertion__S_520Bra
              i: 0
              min: 1
              r: 1
              s: 0
              text: "["
          s: 0
      - !!perl/hash:RE_quantified_atom 
        atom: !!perl/hash:RE_method 
          a: 0
          dba: assertion__S_520Bra
          i: 0
          min: 12345
          name: cclass_elem
          r: 1
          rest: ''
          s: 0
        min: 12345
        quant: 
          - +
          - ":"
          - ''
          - 1
assertion__S_521Plus: !!perl/hash:RE 
  decl: []

  kind: token
  min: 12345
  pkg: ~
  re: !!perl/hash:RE_sequence 
    a: 0
    dba: assertion__S_521Plus
    i: 0
    min: 12345
    r: 1
    s: 0
    zyg: 
      - !!perl/hash:RE_assertion 
        assert: "?"
        min: 0
        re: !!perl/hash:RE_method_re 
          a: 0
          dba: assertion__S_521Plus
          i: 0
          min: 0
          name: before
          nobind: 1
          r: 1
          re: !!perl/hash:RE 
            decl: []

            min: 1
            re: !!perl/hash:RE_string 
              a: 0
              dba: assertion__S_521Plus
              i: 0
              min: 1
              r: 1
              s: 0
              text: +
          s: 0
      - !!perl/hash:RE_quantified_atom 
        atom: !!perl/hash:RE_method 
          a: 0
          dba: assertion__S_521Plus
          i: 0
          min: 12345
          name: cclass_elem
          r: 1
          rest: ''
          s: 0
        min: 12345
        quant: 
          - +
          - ":"
          - ''
          - 1
assertion__S_522Minus: !!perl/hash:RE 
  decl: []

  kind: token
  min: 12345
  pkg: ~
  re: !!perl/hash:RE_sequence 
    a: 0
    dba: assertion__S_522Minus
    i: 0
    min: 12345
    r: 1
    s: 0
    zyg: 
      - !!perl/hash:RE_assertion 
        assert: "?"
        min: 0
        re: !!perl/hash:RE_method_re 
          a: 0
          dba: assertion__S_522Minus
          i: 0
          min: 0
          name: before
          nobind: 1
          r: 1
          re: !!perl/hash:RE 
            decl: []

            min: 1
            re: !!perl/hash:RE_string 
              a: 0
              dba: assertion__S_522Minus
              i: 0
              min: 1
              r: 1
              s: 0
              text: "-"
          s: 0
      - !!perl/hash:RE_quantified_atom 
        atom: !!perl/hash:RE_method 
          a: 0
          dba: assertion__S_522Minus
          i: 0
          min: 12345
          name: cclass_elem
          r: 1
          rest: ''
          s: 0
        min: 12345
        quant: 
          - +
          - ":"
          - ''
          - 1
assertion__S_523Dot: !!perl/hash:RE 
  decl: []

  kind: token
  min: 12345
  pkg: ~
  re: !!perl/hash:RE_method 
    a: 0
    dba: assertion__S_523Dot
    i: 0
    min: 12345
    name: sym
    r: 1
    rest: ''
    s: 0
    sym: .
assertion__S_524Comma: !!perl/hash:RE 
  decl: []

  kind: token
  min: 12345
  pkg: ~
  re: !!perl/hash:RE_method 
    a: 0
    dba: assertion__S_524Comma
    i: 0
    min: 12345
    name: sym
    r: 1
    rest: ''
    s: 0
    sym: ","
assertion__S_525TildeTilde: !!perl/hash:RE 
  decl: []

  kind: token
  min: 12345
  pkg: ~
  re: !!perl/hash:RE_sequence 
    a: 0
    dba: assertion__S_525TildeTilde
    i: 0
    min: 12345
    r: 1
    s: 0
    zyg: 
      - !!perl/hash:RE_method 
        a: 0
        dba: assertion__S_525TildeTilde
        i: 0
        min: 12345
        name: sym
        r: 1
        rest: ''
        s: 0
        sym: ~~
      - !!perl/hash:RE_bracket 
        decl: []

        min: 0
        re: &11 !!perl/hash:RE_any 
          a: 0
          altname: assertion__S_525TildeTilde_01
          dba: assertion__S_525TildeTilde
          i: 0
          min: 0
          name: assertion__S_525TildeTilde_01
          r: 1
          s: 0
          zyg: 
            - !!perl/hash:RE_assertion 
              alt: assertion__S_525TildeTilde_01 0
              assert: "?"
              min: 0
              re: !!perl/hash:RE_method_re 
                a: 0
                dba: assertion__S_525TildeTilde
                i: 0
                min: 0
                name: before
                nobind: 1
                r: 1
                re: !!perl/hash:RE 
                  decl: []

                  min: 1
                  re: !!perl/hash:RE_string 
                    a: 0
                    dba: assertion__S_525TildeTilde
                    i: 0
                    min: 1
                    r: 1
                    s: 0
                    text: ">"
                s: 0
            - !!perl/hash:RE_quantified_atom 
              alt: assertion__S_525TildeTilde_01 1
              atom: !!perl/hash:RE_meta 
                a: 0
                dba: assertion__S_525TildeTilde
                i: 0
                min: 1
                r: 1
                s: 0
                text: \d
              min: 1
              quant: 
                - +
                - ":"
                - ''
                - 1
            - !!perl/hash:RE_method 
              a: 0
              alt: assertion__S_525TildeTilde_01 2
              dba: assertion__S_525TildeTilde
              i: 0
              min: 12345
              name: desigilname
              r: 1
              rest: ''
              s: 0
assertion__S_525TildeTilde_01: *11
assertion__S_526bogus: !!perl/hash:RE 
  decl: []

  kind: token
  min: 0
  pkg: ~
  re: !!perl/hash:RE_method 
    min: 0
    name: panic
    nobind: 1
    rest: ("Unrecognized regex assertion")
atom: !!perl/hash:RE 
  decl: []

  kind: token
  min: 1
  pkg: ~
  re: !!perl/hash:RE_bracket 
    decl: []

    min: 1
    re: &20 !!perl/hash:RE_any 
      a: 0
      altname: atom_01
      dba: regex atom
      i: 0
      min: 1
      name: atom_01
      r: 1
      s: 0
      zyg: 
        - !!perl/hash:RE_meta 
          a: 0
          alt: atom_01 0
          dba: regex atom
          i: 0
          min: 1
          r: 1
          s: 0
          text: \w
        - !!perl/hash:RE_sequence 
          a: 0
          alt: atom_01 1
          dba: regex atom
          i: 0
          min: 12345
          r: 1
          s: 0
          zyg: 
            - !!perl/hash:RE_method 
              a: 0
              dba: regex atom
              i: 0
              min: 12345
              name: metachar
              r: 1
              rest: ''
              s: 0
            - !!perl/hash:RE_meta 
              a: 0
              dba: regex atom
              i: 0
              min: 0
              r: 1
              s: 0
              text: "::"
atom_01: *20
backslash__S_487unspace: !!perl/hash:RE 
  decl: []

  kind: token
  min: 12345
  pkg: ~
  re: !!perl/hash:RE_sequence 
    a: 0
    dba: backslash__S_487unspace
    i: 0
    min: 12345
    r: 1
    s: 0
    zyg: 
      - !!perl/hash:RE_assertion 
        assert: "?"
        min: 0
        re: !!perl/hash:RE_method_re 
          a: 0
          dba: backslash__S_487unspace
          i: 0
          min: 0
          name: before
          nobind: 1
          r: 1
          re: !!perl/hash:RE 
            decl: []

            min: 1
            re: !!perl/hash:RE_meta 
              a: 0
              dba: backslash__S_487unspace
              i: 0
              min: 1
              r: 1
              s: 0
              text: \s
          s: 0
      - !!perl/hash:RE_method 
        a: 0
        dba: backslash__S_487unspace
        i: 0
        min: 12345
        name: SUPER::ws
        nobind: 1
        r: 1
        rest: ''
        s: 0
backslash__S_4880: !!perl/hash:RE 
  decl: []

  kind: token
  min: 1
  pkg: ~
  re: !!perl/hash:RE_sequence 
    a: 0
    dba: backslash__S_4880
    i: 0
    min: 1
    r: 1
    s: 0
    zyg: 
      - !!perl/hash:RE_string 
        a: 0
        dba: backslash__S_4880
        i: 0
        min: 1
        r: 1
        s: 0
        text: 0
      - !!perl/hash:RE_assertion 
        assert: "!"
        min: 0
        re: !!perl/hash:RE_method_re 
          a: 0
          dba: backslash__S_4880
          i: 0
          min: 0
          name: before
          nobind: 1
          r: 1
          re: !!perl/hash:RE 
            decl: []

            min: 1
            re: !!perl/hash:RE_cclass 
              a: 0
              dba: backslash__S_4880
              i: 0
              min: 1
              r: 1
              s: 0
              text: "[0..7]"
          s: 0
backslash__S_489A: !!perl/hash:RE 
  decl: []

  kind: token
  min: 12345
  pkg: ~
  re: !!perl/hash:RE_sequence 
    a: 0
    dba: backslash__S_489A
    i: 0
    min: 12345
    r: 1
    s: 0
    zyg: 
      - !!perl/hash:RE_method 
        a: 0
        dba: backslash__S_489A
        i: 0
        min: 12345
        name: sym
        r: 1
        rest: ''
        s: 0
        sym: A
      - !!perl/hash:RE_method 
        min: 0
        name: obs
        nobind: 1
        rest: ('\\A as beginning-of-string matcher', '^')
backslash__S_490a: !!perl/hash:RE 
  decl: []

  kind: token
  min: 12345
  pkg: ~
  re: !!perl/hash:RE_sequence 
    a: 0
    dba: backslash__S_490a
    i: 0
    min: 12345
    r: 1
    s: 0
    zyg: 
      - !!perl/hash:RE_method 
        a: 0
        dba: backslash__S_490a
        i: 0
        min: 12345
        name: sym
        r: 1
        rest: ''
        s: 0
        sym: a
      - !!perl/hash:RE_method 
        min: 0
        name: panic
        nobind: 1
        rest: ("\\a is allowed only in strings, not regexes")
backslash__S_491b: !!perl/hash:RE 
  decl: []

  kind: token
  min: 12345
  pkg: ~
  re: !!perl/hash:RE_method 
    a: 0
    dba: backslash__S_491b
    i: 1
    min: 12345
    name: sym
    r: 1
    rest: ''
    s: 0
    sym: b
backslash__S_492c: !!perl/hash:RE 
  decl: []

  kind: token
  min: 24690
  pkg: ~
  re: !!perl/hash:RE_sequence 
    a: 0
    dba: backslash__S_492c
    i: 1
    min: 24690
    r: 1
    s: 0
    zyg: 
      - !!perl/hash:RE_method 
        a: 0
        dba: backslash__S_492c
        i: 1
        min: 12345
        name: sym
        r: 1
        rest: ''
        s: 0
        sym: c
      - !!perl/hash:RE_method 
        a: 0
        dba: backslash__S_492c
        i: 1
        min: 12345
        name: charspec
        r: 1
        rest: ''
        s: 0
backslash__S_493d: !!perl/hash:RE 
  decl: []

  kind: token
  min: 12345
  pkg: ~
  re: !!perl/hash:RE_method 
    a: 0
    dba: backslash__S_493d
    i: 1
    min: 12345
    name: sym
    r: 1
    rest: ''
    s: 0
    sym: d
backslash__S_494e: !!perl/hash:RE 
  decl: []

  kind: token
  min: 12345
  pkg: ~
  re: !!perl/hash:RE_method 
    a: 0
    dba: backslash__S_494e
    i: 1
    min: 12345
    name: sym
    r: 1
    rest: ''
    s: 0
    sym: e
backslash__S_495f: !!perl/hash:RE 
  decl: []

  kind: token
  min: 12345
  pkg: ~
  re: !!perl/hash:RE_method 
    a: 0
    dba: backslash__S_495f
    i: 1
    min: 12345
    name: sym
    r: 1
    rest: ''
    s: 0
    sym: f
backslash__S_496h: !!perl/hash:RE 
  decl: []

  kind: token
  min: 12345
  pkg: ~
  re: !!perl/hash:RE_method 
    a: 0
    dba: backslash__S_496h
    i: 1
    min: 12345
    name: sym
    r: 1
    rest: ''
    s: 0
    sym: h
backslash__S_497n: !!perl/hash:RE 
  decl: []

  kind: token
  min: 12345
  pkg: ~
  re: !!perl/hash:RE_method 
    a: 0
    dba: backslash__S_497n
    i: 1
    min: 12345
    name: sym
    r: 1
    rest: ''
    s: 0
    sym: 'n'
backslash__S_498o: !!perl/hash:RE 
  decl: []

  kind: token
  min: 24690
  pkg: ~
  re: !!perl/hash:RE_sequence 
    a: 0
    dba: octal character
    i: 1
    min: 24690
    r: 1
    s: 0
    zyg: 
      - !!perl/hash:RE_method 
        a: 0
        dba: octal character
        i: 1
        min: 12345
        name: sym
        r: 1
        rest: ''
        s: 0
        sym: o
      - !!perl/hash:RE_bracket 
        decl: []

        min: 12345
        re: &2 !!perl/hash:RE_any 
          a: 0
          altname: backslash__S_498o_01
          dba: octal character
          i: 1
          min: 12345
          name: backslash__S_498o_01
          r: 1
          s: 0
          zyg: 
            - !!perl/hash:RE_method 
              a: 0
              alt: backslash__S_498o_01 0
              dba: octal character
              i: 1
              min: 12345
              name: octint
              r: 1
              rest: ''
              s: 0
            - !!perl/hash:RE_sequence 
              a: 0
              alt: backslash__S_498o_01 1
              dba: octal character
              i: 1
              min: 12347
              r: 1
              s: 0
              zyg: 
                - !!perl/hash:RE_string 
                  a: 0
                  dba: octal character
                  i: 1
                  min: 1
                  r: 1
                  s: 0
                  text: "["
                - !!perl/hash:RE_meta 
                  a: 0
                  dba: octal character
                  extra: "local $::GOAL = ']' "
                  i: 1
                  min: 0
                  r: 1
                  s: 0
                  text: "::"
                - !!perl/hash:RE_method 
                  a: 0
                  dba: octal character
                  i: 1
                  min: 12345
                  name: octints
                  r: 1
                  rest: ''
                  s: 0
                - !!perl/hash:RE_bracket 
                  decl: []

                  min: 1
                  re: !!perl/hash:RE_first 
                    a: 0
                    dba: octal character
                    i: 1
                    min: 1
                    r: 1
                    s: 0
                    zyg: 
                      - !!perl/hash:RE_string 
                        a: 0
                        dba: octal character
                        i: 1
                        min: 1
                        r: 1
                        s: 0
                        text: "]"
                      - !!perl/hash:RE_method 
                        min: 0
                        name: FAILGOAL
                        nobind: 1
                        rest: (']' , 'octal character')
backslash__S_498o_01: *2
backslash__S_499Q: !!perl/hash:RE 
  decl: []

  kind: token
  min: 12345
  pkg: ~
  re: !!perl/hash:RE_sequence 
    a: 0
    dba: backslash__S_499Q
    i: 0
    min: 12345
    r: 1
    s: 0
    zyg: 
      - !!perl/hash:RE_method 
        a: 0
        dba: backslash__S_499Q
        i: 0
        min: 12345
        name: sym
        r: 1
        rest: ''
        s: 0
        sym: Q
      - !!perl/hash:RE_method 
        min: 0
        name: obs
        nobind: 1
        rest: ('\\Q as quotemeta', 'quotes or literal variable match')
backslash__S_500r: !!perl/hash:RE 
  decl: []

  kind: token
  min: 12345
  pkg: ~
  re: !!perl/hash:RE_method 
    a: 0
    dba: backslash__S_500r
    i: 1
    min: 12345
    name: sym
    r: 1
    rest: ''
    s: 0
    sym: r
backslash__S_501s: !!perl/hash:RE 
  decl: []

  kind: token
  min: 12345
  pkg: ~
  re: !!perl/hash:RE_method 
    a: 0
    dba: backslash__S_501s
    i: 1
    min: 12345
    name: sym
    r: 1
    rest: ''
    s: 0
    sym: s
backslash__S_502t: !!perl/hash:RE 
  decl: []

  kind: token
  min: 12345
  pkg: ~
  re: !!perl/hash:RE_method 
    a: 0
    dba: backslash__S_502t
    i: 1
    min: 12345
    name: sym
    r: 1
    rest: ''
    s: 0
    sym: t
backslash__S_503v: !!perl/hash:RE 
  decl: []

  kind: token
  min: 12345
  pkg: ~
  re: !!perl/hash:RE_method 
    a: 0
    dba: backslash__S_503v
    i: 1
    min: 12345
    name: sym
    r: 1
    rest: ''
    s: 0
    sym: v
backslash__S_504w: !!perl/hash:RE 
  decl: []

  kind: token
  min: 12345
  pkg: ~
  re: !!perl/hash:RE_method 
    a: 0
    dba: backslash__S_504w
    i: 1
    min: 12345
    name: sym
    r: 1
    rest: ''
    s: 0
    sym: w
backslash__S_505x: !!perl/hash:RE 
  decl: []

  kind: token
  min: 24690
  pkg: ~
  re: !!perl/hash:RE_sequence 
    a: 0
    dba: hex character
    i: 1
    min: 24690
    r: 1
    s: 0
    zyg: 
      - !!perl/hash:RE_method 
        a: 0
        dba: hex character
        i: 1
        min: 12345
        name: sym
        r: 1
        rest: ''
        s: 0
        sym: x
      - !!perl/hash:RE_bracket 
        decl: []

        min: 12345
        re: &21 !!perl/hash:RE_any 
          a: 0
          altname: backslash__S_505x_01
          dba: hex character
          i: 1
          min: 12345
          name: backslash__S_505x_01
          r: 1
          s: 0
          zyg: 
            - !!perl/hash:RE_method 
              a: 0
              alt: backslash__S_505x_01 0
              dba: hex character
              i: 1
              min: 12345
              name: hexint
              r: 1
              rest: ''
              s: 0
            - !!perl/hash:RE_sequence 
              a: 0
              alt: backslash__S_505x_01 1
              dba: hex character
              i: 1
              min: 12347
              r: 1
              s: 0
              zyg: 
                - !!perl/hash:RE_string 
                  a: 0
                  dba: hex character
                  i: 1
                  min: 1
                  r: 1
                  s: 0
                  text: "["
                - !!perl/hash:RE_meta 
                  a: 0
                  dba: hex character
                  extra: "local $::GOAL = ']' "
                  i: 1
                  min: 0
                  r: 1
                  s: 0
                  text: "::"
                - !!perl/hash:RE_method 
                  a: 0
                  dba: hex character
                  i: 1
                  min: 12345
                  name: hexints
                  r: 1
                  rest: ''
                  s: 0
                - !!perl/hash:RE_bracket 
                  decl: []

                  min: 1
                  re: !!perl/hash:RE_first 
                    a: 0
                    dba: hex character
                    i: 1
                    min: 1
                    r: 1
                    s: 0
                    zyg: 
                      - !!perl/hash:RE_string 
                        a: 0
                        dba: hex character
                        i: 1
                        min: 1
                        r: 1
                        s: 0
                        text: "]"
                      - !!perl/hash:RE_method 
                        min: 0
                        name: FAILGOAL
                        nobind: 1
                        rest: (']' , 'hex character')
backslash__S_505x_01: *21
backslash__S_506z: !!perl/hash:RE 
  decl: []

  kind: token
  min: 12345
  pkg: ~
  re: !!perl/hash:RE_sequence 
    a: 0
    dba: backslash__S_506z
    i: 0
    min: 12345
    r: 1
    s: 0
    zyg: 
      - !!perl/hash:RE_method 
        a: 0
        dba: backslash__S_506z
        i: 0
        min: 12345
        name: sym
        r: 1
        rest: ''
        s: 0
        sym: z
      - !!perl/hash:RE_method 
        min: 0
        name: obs
        nobind: 1
        rest: ('\\z as end-of-string matcher', '$')
backslash__S_507Z: !!perl/hash:RE 
  decl: []

  kind: token
  min: 12345
  pkg: ~
  re: !!perl/hash:RE_sequence 
    a: 0
    dba: backslash__S_507Z
    i: 0
    min: 12345
    r: 1
    s: 0
    zyg: 
      - !!perl/hash:RE_method 
        a: 0
        dba: backslash__S_507Z
        i: 0
        min: 12345
        name: sym
        r: 1
        rest: ''
        s: 0
        sym: Z
      - !!perl/hash:RE_method 
        min: 0
        name: obs
        nobind: 1
        rest: ('\\Z as end-of-string matcher', '\\n?$')
backslash__S_508misc: !!perl/hash:RE 
  decl: []

  kind: token
  min: 1
  pkg: ~
  re: !!perl/hash:RE_bindnamed 
    a: 0
    atom: !!perl/hash:RE_paren 
      decl: []

      min: 1
      nobind: 1
      re: !!perl/hash:RE_meta 
        a: 0
        dba: backslash__S_508misc
        i: 0
        min: 1
        r: 1
        s: 0
        text: \W
    dba: backslash__S_508misc
    i: 0
    min: 1
    r: 1
    s: 0
    var: litchar
backslash__S_509oops: !!perl/hash:RE 
  decl: []

  kind: token
  min: 0
  pkg: ~
  re: !!perl/hash:RE_method 
    min: 0
    name: panic
    nobind: 1
    rest: ("Unrecognized regex backslash sequence")
category__S_442metachar: !!perl/hash:RE 
  decl: []

  kind: token
  min: 12345
  pkg: ~
  re: !!perl/hash:RE_method 
    a: 0
    dba: category__S_442metachar
    i: 0
    min: 12345
    name: sym
    r: 1
    rest: ''
    s: 0
    sym: metachar
category__S_443backslash: !!perl/hash:RE 
  decl: []

  kind: token
  min: 12345
  pkg: ~
  re: !!perl/hash:RE_method 
    a: 0
    dba: category__S_443backslash
    i: 0
    min: 12345
    name: sym
    r: 1
    rest: ''
    s: 0
    sym: backslash
category__S_444assertion: !!perl/hash:RE 
  decl: []

  kind: token
  min: 12345
  pkg: ~
  re: !!perl/hash:RE_method 
    a: 0
    dba: category__S_444assertion
    i: 0
    min: 12345
    name: sym
    r: 1
    rest: ''
    s: 0
    sym: assertion
category__S_445quantifier: !!perl/hash:RE 
  decl: []

  kind: token
  min: 12345
  pkg: ~
  re: !!perl/hash:RE_method 
    a: 0
    dba: category__S_445quantifier
    i: 0
    min: 12345
    name: sym
    r: 1
    rest: ''
    s: 0
    sym: quantifier
category__S_446mod_internal: !!perl/hash:RE 
  decl: []

  kind: token
  min: 12345
  pkg: ~
  re: !!perl/hash:RE_method 
    a: 0
    dba: category__S_446mod_internal
    i: 0
    min: 12345
    name: sym
    r: 1
    rest: ''
    s: 0
    sym: mod_internal
cclass_elem: !!perl/hash:RE 
  decl: []

  kind: token
  min: 12345
  pkg: ~
  re: !!perl/hash:RE_sequence 
    a: 0
    dba: character class element
    i: 0
    min: 12345
    r: 1
    s: 0
    zyg: 
      - !!perl/hash:RE_method 
        a: 0
        dba: character class element
        i: 0
        min: 12345
        name: sign
        r: 1
        rest: ''
        s: 0
      - !!perl/hash:RE_quantified_atom 
        atom: !!perl/hash:RE_method 
          a: 0
          dba: character class element
          i: 0
          min: 12345
          name: normspace
          nobind: 1
          r: 1
          rest: ''
          s: 0
        min: 0
        quant: 
          - "?"
          - ":"
          - ''
          - 0
      - !!perl/hash:RE_bracket 
        decl: []

        min: 0
        re: &25 !!perl/hash:RE_any 
          a: 0
          altname: cclass_elem_01
          dba: character class element
          i: 0
          min: 0
          name: cclass_elem_01
          r: 1
          s: 0
          zyg: 
            - !!perl/hash:RE_method 
              a: 0
              alt: cclass_elem_01 0
              dba: character class element
              i: 0
              min: 12345
              name: name
              r: 1
              rest: ''
              s: 0
            - !!perl/hash:RE_sequence 
              a: 0
              alt: cclass_elem_01 1
              dba: character class element
              i: 0
              min: 0
              r: 1
              s: 0
              zyg: 
                - !!perl/hash:RE_method_re 
                  a: 0
                  dba: character class element
                  i: 0
                  min: 0
                  name: before
                  r: 1
                  re: !!perl/hash:RE 
                    decl: []

                    min: 1
                    re: !!perl/hash:RE_string 
                      a: 0
                      dba: character class element
                      i: 0
                      min: 1
                      r: 1
                      s: 0
                      text: "["
                  s: 0
                - !!perl/hash:RE_method 
                  min: 0
                  name: quibble
                  rest: ($¢.cursor_fresh( %*LANG<Q> ).tweak(:q))
      - !!perl/hash:RE_quantified_atom 
        atom: !!perl/hash:RE_method 
          a: 0
          dba: character class element
          i: 0
          min: 12345
          name: normspace
          nobind: 1
          r: 1
          rest: ''
          s: 0
        min: 0
        quant: 
          - "?"
          - ":"
          - ''
          - 0
cclass_elem_01: *25
codeblock: !!perl/hash:RE 
  decl: 
    - !!perl/hash:RE_decl 
      a: 0
      dba: codeblock
      i: 0
      max: 0
      min: 0
      r: 1
      s: 0
      text: my $GOAL is context = '}'
  kind: token
  min: 12346
  pkg: ~
  re: !!perl/hash:RE_sequence 
    a: 0
    dba: codeblock
    i: 0
    min: 12346
    r: 1
    s: 0
    zyg: 
      - !!perl/hash:RE_string 
        a: 0
        dba: codeblock
        i: 0
        min: 1
        r: 1
        s: 0
        text: "{"
      - !!perl/hash:RE_meta 
        a: 0
        dba: codeblock
        i: 0
        min: 0
        r: 1
        s: 0
        text: "::"
      - !!perl/hash:RE_bracket 
        decl: []

        min: 12345
        re: !!perl/hash:RE_sequence 
          a: 0
          dba: codeblock
          i: 0
          lang: ($C->cursor_fresh($::LANG{'MAIN'}))
          min: 12345
          r: 1
          s: 0
          zyg: 
            - !!perl/hash:RE_decl 
              a: 0
              dba: codeblock
              i: 0
              lang: ($C->cursor_fresh($::LANG{'MAIN'}))
              max: 0
              min: 0
              noquant: 1
              r: 1
              s: 0
              text: "my $newlang = ($C->cursor_fresh($::LANG{'MAIN'}));  $C = $C->cursor_fresh($newlang); "
            - !!perl/hash:RE_method 
              a: 0
              dba: codeblock
              i: 0
              lang: ($C->cursor_fresh($::LANG{'MAIN'}))
              min: 12345
              name: statementlist
              r: 1
              rest: ''
              s: 0
      - !!perl/hash:RE_bracket 
        decl: []

        min: 0
        re: !!perl/hash:RE_first 
          a: 0
          dba: codeblock
          i: 0
          min: 0
          r: 1
          s: 0
          zyg: 
            - !!perl/hash:RE_string 
              a: 0
              dba: codeblock
              i: 0
              min: 1
              r: 1
              s: 0
              text: "}"
            - !!perl/hash:RE_method 
              min: 0
              name: panic
              nobind: 1
              rest: ("Unable to parse statement list; couldn't find right brace")
infixish: !!perl/hash:RE 
  decl: []

  kind: token
  min: 12345
  pkg: ~
  re: !!perl/hash:RE_sequence 
    a: 0
    dba: infixish
    i: 0
    min: 12345
    r: 1
    s: 0
    zyg: 
      - !!perl/hash:RE_assertion 
        assert: "!"
        min: 0
        re: !!perl/hash:RE_method 
          a: 0
          dba: infixish
          i: 0
          min: 12345
          name: infixstopper
          nobind: 1
          r: 1
          rest: ''
          s: 0
      - !!perl/hash:RE_assertion 
        assert: "!"
        min: 0
        re: !!perl/hash:RE_method 
          a: 0
          dba: infixish
          i: 0
          min: 12345
          name: stdstopper
          nobind: 1
          r: 1
          rest: ''
          s: 0
      - !!perl/hash:RE_method 
        a: 0
        dba: infixish
        i: 0
        min: 12345
        name: regex_infix
        r: 1
        rest: ''
        s: 0
      - !!perl/hash:RE_block 
        a: 0
        context: void
        dba: infixish
        i: 0
        min: 0
        r: 1
        s: 0
        text: "\n            $<O> = $<regex_infix><O>;\n            $<sym> = $<regex_infix><sym>;\n        "
metachar__S_452Gt: !!perl/hash:RE 
  decl: []

  kind: token
  min: 12346
  pkg: ~
  re: !!perl/hash:RE_sequence 
    a: 0
    dba: metachar__S_452Gt
    i: 0
    min: 12346
    r: 1
    s: 0
    zyg: 
      - !!perl/hash:RE_string 
        a: 0
        dba: metachar__S_452Gt
        i: 0
        min: 1
        r: 1
        s: 0
        text: ">"
      - !!perl/hash:RE_meta 
        a: 0
        dba: metachar__S_452Gt
        i: 0
        min: 0
        r: 1
        s: 0
        text: "::"
      - !!perl/hash:RE_method 
        a: 0
        dba: metachar__S_452Gt
        i: 0
        min: 12345
        name: fail
        r: 1
        rest: ''
        s: 0
metachar__S_453AmpAmp: !!perl/hash:RE 
  decl: []

  kind: token
  min: 12347
  pkg: ~
  re: !!perl/hash:RE_sequence 
    a: 0
    dba: metachar__S_453AmpAmp
    i: 0
    min: 12347
    r: 1
    s: 0
    zyg: 
      - !!perl/hash:RE_string 
        a: 0
        dba: metachar__S_453AmpAmp
        i: 0
        min: 2
        r: 1
        s: 0
        text: "&&"
      - !!perl/hash:RE_meta 
        a: 0
        dba: metachar__S_453AmpAmp
        i: 0
        min: 0
        r: 1
        s: 0
        text: "::"
      - !!perl/hash:RE_method 
        a: 0
        dba: metachar__S_453AmpAmp
        i: 0
        min: 12345
        name: fail
        r: 1
        rest: ''
        s: 0
metachar__S_454Amp: !!perl/hash:RE 
  decl: []

  kind: token
  min: 12346
  pkg: ~
  re: !!perl/hash:RE_sequence 
    a: 0
    dba: metachar__S_454Amp
    i: 0
    min: 12346
    r: 1
    s: 0
    zyg: 
      - !!perl/hash:RE_string 
        a: 0
        dba: metachar__S_454Amp
        i: 0
        min: 1
        r: 1
        s: 0
        text: "&"
      - !!perl/hash:RE_meta 
        a: 0
        dba: metachar__S_454Amp
        i: 0
        min: 0
        r: 1
        s: 0
        text: "::"
      - !!perl/hash:RE_method 
        a: 0
        dba: metachar__S_454Amp
        i: 0
        min: 12345
        name: fail
        r: 1
        rest: ''
        s: 0
metachar__S_455VertVert: !!perl/hash:RE 
  decl: []

  kind: token
  min: 12347
  pkg: ~
  re: !!perl/hash:RE_sequence 
    a: 0
    dba: metachar__S_455VertVert
    i: 0
    min: 12347
    r: 1
    s: 0
    zyg: 
      - !!perl/hash:RE_string 
        a: 0
        dba: metachar__S_455VertVert
        i: 0
        min: 2
        r: 1
        s: 0
        text: "||"
      - !!perl/hash:RE_meta 
        a: 0
        dba: metachar__S_455VertVert
        i: 0
        min: 0
        r: 1
        s: 0
        text: "::"
      - !!perl/hash:RE_method 
        a: 0
        dba: metachar__S_455VertVert
        i: 0
        min: 12345
        name: fail
        r: 1
        rest: ''
        s: 0
metachar__S_456Vert: !!perl/hash:RE 
  decl: []

  kind: token
  min: 12346
  pkg: ~
  re: !!perl/hash:RE_sequence 
    a: 0
    dba: metachar__S_456Vert
    i: 0
    min: 12346
    r: 1
    s: 0
    zyg: 
      - !!perl/hash:RE_string 
        a: 0
        dba: metachar__S_456Vert
        i: 0
        min: 1
        r: 1
        s: 0
        text: "|"
      - !!perl/hash:RE_meta 
        a: 0
        dba: metachar__S_456Vert
        i: 0
        min: 0
        r: 1
        s: 0
        text: "::"
      - !!perl/hash:RE_method 
        a: 0
        dba: metachar__S_456Vert
        i: 0
        min: 12345
        name: fail
        r: 1
        rest: ''
        s: 0
metachar__S_457Ket: !!perl/hash:RE 
  decl: []

  kind: token
  min: 12346
  pkg: ~
  re: !!perl/hash:RE_sequence 
    a: 0
    dba: metachar__S_457Ket
    i: 0
    min: 12346
    r: 1
    s: 0
    zyg: 
      - !!perl/hash:RE_string 
        a: 0
        dba: metachar__S_457Ket
        i: 0
        min: 1
        r: 1
        s: 0
        text: "]"
      - !!perl/hash:RE_meta 
        a: 0
        dba: metachar__S_457Ket
        i: 0
        min: 0
        r: 1
        s: 0
        text: "::"
      - !!perl/hash:RE_method 
        a: 0
        dba: metachar__S_457Ket
        i: 0
        min: 12345
        name: fail
        r: 1
        rest: ''
        s: 0
metachar__S_458Thesis: !!perl/hash:RE 
  decl: []

  kind: token
  min: 12346
  pkg: ~
  re: !!perl/hash:RE_sequence 
    a: 0
    dba: metachar__S_458Thesis
    i: 0
    min: 12346
    r: 1
    s: 0
    zyg: 
      - !!perl/hash:RE_string 
        a: 0
        dba: metachar__S_458Thesis
        i: 0
        min: 1
        r: 1
        s: 0
        text: )
      - !!perl/hash:RE_meta 
        a: 0
        dba: metachar__S_458Thesis
        i: 0
        min: 0
        r: 1
        s: 0
        text: "::"
      - !!perl/hash:RE_method 
        a: 0
        dba: metachar__S_458Thesis
        i: 0
        min: 12345
        name: fail
        r: 1
        rest: ''
        s: 0
metachar__S_459Semi: !!perl/hash:RE 
  decl: []

  kind: token
  min: 1
  pkg: ~
  re: !!perl/hash:RE_sequence 
    a: 0
    dba: metachar__S_459Semi
    i: 0
    min: 1
    r: 1
    s: 0
    zyg: 
      - !!perl/hash:RE_string 
        a: 0
        dba: metachar__S_459Semi
        i: 0
        min: 1
        r: 1
        s: 0
        text: ;
      - !!perl/hash:RE_block 
        a: 0
        context: void
        dba: metachar__S_459Semi
        i: 0
        min: 0
        r: 1
        s: 0
        text: ''
      - !!perl/hash:RE_bracket 
        decl: []

        min: 0
        re: !!perl/hash:RE_first 
          a: 0
          dba: metachar__S_459Semi
          i: 0
          min: 0
          r: 1
          s: 0
          zyg: 
            - !!perl/hash:RE_sequence 
              a: 0
              dba: metachar__S_459Semi
              i: 0
              min: 0
              r: 1
              s: 0
              zyg: 
                - !!perl/hash:RE_assertion 
                  assert: "?"
                  min: 0
                  re: !!perl/hash:RE_method_re 
                    a: 0
                    dba: metachar__S_459Semi
                    i: 0
                    min: 0
                    name: before
                    nobind: 1
                    r: 1
                    re: !!perl/hash:RE 
                      decl: []

                      min: 12345
                      re: !!perl/hash:RE_sequence 
                        a: 0
                        dba: metachar__S_459Semi
                        i: 0
                        min: 12345
                        r: 1
                        s: 0
                        zyg: 
                          - !!perl/hash:RE_quantified_atom 
                            atom: !!perl/hash:RE_meta 
                              a: 0
                              dba: metachar__S_459Semi
                              i: 0
                              min: 1
                              r: 1
                              s: 0
                              text: \N
                            min: 0
                            quant: 
                              - "*"
                              - "?"
                              - ''
                              - 0
                          - !!perl/hash:RE_method 
                            a: 0
                            dba: metachar__S_459Semi
                            i: 0
                            min: 12345
                            name: stopper
                            r: 1
                            rest: ''
                            s: 0
                    s: 0
                - !!perl/hash:RE_method 
                  min: 0
                  name: panic
                  nobind: 1
                  rest: ("Semicolon must be quoted")
            - !!perl/hash:RE_sequence 
              a: 0
              dba: metachar__S_459Semi
              i: 0
              min: 0
              r: 1
              s: 0
              zyg: 
                - !!perl/hash:RE_assertion 
                  assert: "?"
                  min: 0
                  re: !!perl/hash:RE_method_re 
                    a: 0
                    dba: metachar__S_459Semi
                    i: 0
                    min: 0
                    name: before
                    nobind: 1
                    r: 1
                    re: !!perl/hash:RE 
                      decl: []

                      min: 1
                      re: !!perl/hash:RE_meta 
                        a: 0
                        dba: metachar__S_459Semi
                        i: 0
                        min: 1
                        r: 1
                        s: 0
                        text: .
                    s: 0
                - !!perl/hash:RE_method 
                  min: 0
                  name: panic
                  nobind: 1
                  rest: ("Regex missing terminator (or semicolon must be quoted?)")
            - !!perl/hash:RE_method 
              min: 0
              name: panic
              nobind: 1
              rest: ("Regex missing terminator")
metachar__S_460quant: !!perl/hash:RE 
  decl: []

  kind: token
  min: 12345
  pkg: ~
  re: !!perl/hash:RE_sequence 
    a: 0
    dba: metachar__S_460quant
    i: 0
    min: 12345
    r: 1
    s: 0
    zyg: 
      - !!perl/hash:RE_method 
        a: 0
        dba: metachar__S_460quant
        i: 0
        min: 12345
        name: quantifier
        r: 1
        rest: ''
        s: 0
      - !!perl/hash:RE_method 
        min: 0
        name: panic
        nobind: 1
        rest: ("quantifier quantifies nothing")
metachar__S_461sigwhite: !!perl/hash:RE 
  decl: []

  kind: token
  min: 12345
  pkg: ~
  re: !!perl/hash:RE_method 
    a: 0
    dba: metachar__S_461sigwhite
    i: 0
    min: 12345
    name: normspace
    r: 1
    rest: ''
    s: 0
metachar__S_462unsp: !!perl/hash:RE 
  decl: []

  kind: token
  min: 12345
  pkg: ~
  re: !!perl/hash:RE_method 
    a: 0
    dba: metachar__S_462unsp
    i: 0
    min: 12345
    name: unsp
    r: 1
    rest: ''
    s: 0
metachar__S_463Cur_Ly: !!perl/hash:RE 
  decl: []

  kind: token
  min: 12345
  pkg: ~
  re: !!perl/hash:RE_sequence 
    a: 0
    dba: metachar__S_463Cur_Ly
    i: 0
    min: 12345
    r: 1
    s: 0
    zyg: 
      - !!perl/hash:RE_assertion 
        assert: "?"
        min: 0
        re: !!perl/hash:RE_method_re 
          a: 0
          dba: metachar__S_463Cur_Ly
          i: 0
          min: 0
          name: before
          nobind: 1
          r: 1
          re: !!perl/hash:RE 
            decl: []

            min: 1
            re: !!perl/hash:RE_string 
              a: 0
              dba: metachar__S_463Cur_Ly
              i: 0
              min: 1
              r: 1
              s: 0
              text: "{"
          s: 0
      - !!perl/hash:RE_method 
        a: 0
        dba: metachar__S_463Cur_Ly
        i: 0
        min: 12345
        name: codeblock
        r: 1
        rest: ''
        s: 0
      - !!perl/hash:RE_block 
        a: 0
        context: void
        dba: metachar__S_463Cur_Ly
        i: 0
        min: 0
        r: 1
        s: 0
        text: " $/<sym> := <{ }> "
metachar__S_464mod: !!perl/hash:RE 
  decl: []

  kind: token
  min: 12345
  pkg: ~
  re: !!perl/hash:RE_sequence 
    a: 0
    dba: metachar__S_464mod
    i: 0
    min: 12345
    r: 1
    s: 0
    zyg: 
      - !!perl/hash:RE_method 
        a: 0
        dba: metachar__S_464mod
        i: 0
        min: 12345
        name: mod_internal
        r: 1
        rest: ''
        s: 0
      - !!perl/hash:RE_block 
        a: 0
        context: void
        dba: metachar__S_464mod
        i: 0
        min: 0
        r: 1
        s: 0
        text: " $/<sym> := $<mod_internal><sym> "
metachar__S_465Colon: !!perl/hash:RE 
  decl: []

  kind: token
  min: 12345
  pkg: ~
  re: !!perl/hash:RE_method 
    a: 0
    dba: metachar__S_465Colon
    i: 0
    min: 12345
    name: sym
    r: 1
    rest: ''
    s: 0
    sym: ":"
metachar__S_466ColonColon: !!perl/hash:RE 
  decl: []

  kind: token
  min: 12345
  pkg: ~
  re: !!perl/hash:RE_method 
    a: 0
    dba: metachar__S_466ColonColon
    i: 0
    min: 12345
    name: sym
    r: 1
    rest: ''
    s: 0
    sym: "::"
metachar__S_467ColonColonColon: !!perl/hash:RE 
  decl: []

  kind: token
  min: 12345
  pkg: ~
  re: !!perl/hash:RE_method 
    a: 0
    dba: metachar__S_467ColonColonColon
    i: 0
    min: 12345
    name: sym
    r: 1
    rest: ''
    s: 0
    sym: ":::"
metachar__S_468Bra_Ket: !!perl/hash:RE 
  decl: []

  kind: token
  min: 12346
  pkg: ~
  re: !!perl/hash:RE_sequence 
    a: 0
    dba: metachar__S_468Bra_Ket
    i: 0
    min: 12346
    r: 1
    s: 0
    zyg: 
      - !!perl/hash:RE_string 
        a: 0
        dba: metachar__S_468Bra_Ket
        i: 0
        min: 1
        r: 1
        s: 0
        text: "["
      - !!perl/hash:RE_block 
        a: 0
        context: void
        dba: metachar__S_468Bra_Ket
        i: 0
        min: 0
        r: 1
        s: 0
        text: ''
      - !!perl/hash:RE_bracket 
        decl: []

        min: 12345
        re: !!perl/hash:RE_sequence 
          a: 0
          dba: metachar__S_468Bra_Ket
          i: 0
          lang: ($self->unbalanced(']'))
          min: 12345
          r: 1
          s: 0
          zyg: 
            - !!perl/hash:RE_decl 
              a: 0
              dba: metachar__S_468Bra_Ket
              i: 0
              lang: ($self->unbalanced(']'))
              max: 0
              min: 0
              noquant: 1
              r: 1
              s: 0
              text: "my $newlang = ($self->unbalanced(']'));  $C = $C->cursor_fresh($newlang); "
            - !!perl/hash:RE_method 
              a: 0
              dba: metachar__S_468Bra_Ket
              i: 0
              lang: ($self->unbalanced(']'))
              min: 12345
              name: nibbler
              r: 1
              rest: ''
              s: 0
      - !!perl/hash:RE_bracket 
        decl: []

        min: 0
        re: !!perl/hash:RE_first 
          a: 0
          dba: metachar__S_468Bra_Ket
          i: 0
          min: 0
          r: 1
          s: 0
          zyg: 
            - !!perl/hash:RE_string 
              a: 0
              dba: metachar__S_468Bra_Ket
              i: 0
              min: 1
              r: 1
              s: 0
              text: "]"
            - !!perl/hash:RE_method 
              min: 0
              name: panic
              nobind: 1
              rest: ("Unable to parse regex; couldn't find right bracket")
      - !!perl/hash:RE_block 
        a: 0
        context: void
        dba: metachar__S_468Bra_Ket
        i: 0
        min: 0
        r: 1
        s: 0
        text: " $/<sym> := <[ ]> "
metachar__S_469Paren_Thesis: !!perl/hash:RE 
  decl: []

  kind: token
  min: 12346
  pkg: ~
  re: !!perl/hash:RE_sequence 
    a: 0
    dba: metachar__S_469Paren_Thesis
    i: 0
    min: 12346
    r: 1
    s: 0
    zyg: 
      - !!perl/hash:RE_string 
        a: 0
        dba: metachar__S_469Paren_Thesis
        i: 0
        min: 1
        r: 1
        s: 0
        text: (
      - !!perl/hash:RE_block 
        a: 0
        context: void
        dba: metachar__S_469Paren_Thesis
        i: 0
        min: 0
        r: 1
        s: 0
        text: ''
      - !!perl/hash:RE_bracket 
        decl: []

        min: 12345
        re: !!perl/hash:RE_sequence 
          a: 0
          dba: metachar__S_469Paren_Thesis
          i: 0
          lang: ($self->unbalanced(')'))
          min: 12345
          r: 1
          s: 0
          zyg: 
            - !!perl/hash:RE_decl 
              a: 0
              dba: metachar__S_469Paren_Thesis
              i: 0
              lang: ($self->unbalanced(')'))
              max: 0
              min: 0
              noquant: 1
              r: 1
              s: 0
              text: "my $newlang = ($self->unbalanced(')'));  $C = $C->cursor_fresh($newlang); "
            - !!perl/hash:RE_method 
              a: 0
              dba: metachar__S_469Paren_Thesis
              i: 0
              lang: ($self->unbalanced(')'))
              min: 12345
              name: nibbler
              r: 1
              rest: ''
              s: 0
      - !!perl/hash:RE_bracket 
        decl: []

        min: 0
        re: !!perl/hash:RE_first 
          a: 0
          dba: metachar__S_469Paren_Thesis
          i: 0
          min: 0
          r: 1
          s: 0
          zyg: 
            - !!perl/hash:RE_string 
              a: 0
              dba: metachar__S_469Paren_Thesis
              i: 0
              min: 1
              r: 1
              s: 0
              text: )
            - !!perl/hash:RE_method 
              min: 0
              name: panic
              nobind: 1
              rest: ("Unable to parse regex; couldn't find right parenthesis")
      - !!perl/hash:RE_block 
        a: 0
        context: void
        dba: metachar__S_469Paren_Thesis
        i: 0
        min: 0
        r: 1
        s: 0
        text: " $/<sym> := <( )> "
metachar__S_470LtParen: !!perl/hash:RE 
  decl: []

  kind: token
  min: 2
  pkg: ~
  re: !!perl/hash:RE_string 
    a: 0
    dba: metachar__S_470LtParen
    i: 0
    min: 2
    r: 1
    s: 0
    text: <(
metachar__S_471ThesisGt: !!perl/hash:RE 
  decl: []

  kind: token
  min: 2
  pkg: ~
  re: !!perl/hash:RE_string 
    a: 0
    dba: metachar__S_471ThesisGt
    i: 0
    min: 2
    r: 1
    s: 0
    text: )>
metachar__S_472LtLt: !!perl/hash:RE 
  decl: []

  kind: token
  min: 2
  pkg: ~
  re: !!perl/hash:RE_string 
    a: 0
    dba: metachar__S_472LtLt
    i: 0
    min: 2
    r: 1
    s: 0
    text: <<
metachar__S_473GtGt: !!perl/hash:RE 
  decl: []

  kind: token
  min: 2
  pkg: ~
  re: !!perl/hash:RE_string 
    a: 0
    dba: metachar__S_473GtGt
    i: 0
    min: 2
    r: 1
    s: 0
    text: ">>"
metachar__S_474Fre: !!perl/hash:RE 
  decl: []

  kind: token
  min: 1
  pkg: ~
  re: !!perl/hash:RE_string 
    a: 0
    dba: metachar__S_474Fre
    i: 0
    min: 1
    r: 1
    s: 0
    text: «
metachar__S_475Nch: !!perl/hash:RE 
  decl: []

  kind: token
  min: 1
  pkg: ~
  re: !!perl/hash:RE_string 
    a: 0
    dba: metachar__S_475Nch
    i: 0
    min: 1
    r: 1
    s: 0
    text: »
metachar__S_476qw: !!perl/hash:RE 
  decl: []

  kind: token
  min: 12345
  pkg: ~
  re: !!perl/hash:RE_sequence 
    a: 0
    dba: metachar__S_476qw
    i: 0
    min: 12345
    r: 1
    s: 0
    zyg: 
      - !!perl/hash:RE_assertion 
        assert: "?"
        min: 0
        re: !!perl/hash:RE_method_re 
          a: 0
          dba: metachar__S_476qw
          i: 0
          min: 0
          name: before
          nobind: 1
          r: 1
          re: !!perl/hash:RE 
            decl: []

            min: 2
            re: !!perl/hash:RE_sequence 
              a: 0
              dba: metachar__S_476qw
              i: 0
              min: 2
              r: 1
              s: 0
              zyg: 
                - !!perl/hash:RE_string 
                  a: 0
                  dba: metachar__S_476qw
                  i: 0
                  min: 1
                  r: 1
                  s: 0
                  text: <
                - !!perl/hash:RE_meta 
                  a: 0
                  dba: metachar__S_476qw
                  i: 0
                  min: 1
                  r: 1
                  s: 0
                  text: \s
          s: 0
      - !!perl/hash:RE_method 
        a: 0
        dba: metachar__S_476qw
        i: 0
        min: 12345
        name: circumfix
        r: 1
        rest: ''
        s: 0
metachar__S_477Lt_Gt: !!perl/hash:RE 
  decl: []

  kind: token
  min: 12346
  pkg: ~
  re: !!perl/hash:RE_sequence 
    a: 0
    dba: metachar__S_477Lt_Gt
    i: 0
    min: 12346
    r: 1
    s: 0
    zyg: 
      - !!perl/hash:RE_string 
        a: 0
        dba: metachar__S_477Lt_Gt
        i: 0
        min: 1
        r: 1
        s: 0
        text: <
      - !!perl/hash:RE_quantified_atom 
        atom: !!perl/hash:RE_method 
          a: 0
          dba: metachar__S_477Lt_Gt
          i: 0
          min: 12345
          name: unsp
          r: 1
          rest: ''
          s: 0
        min: 0
        quant: 
          - "?"
          - ":"
          - ''
          - 0
      - !!perl/hash:RE_block 
        a: 0
        context: void
        dba: metachar__S_477Lt_Gt
        i: 0
        min: 0
        r: 1
        s: 0
        text: ''
      - !!perl/hash:RE_method 
        a: 0
        dba: metachar__S_477Lt_Gt
        i: 0
        min: 12345
        name: assertion
        r: 1
        rest: ''
        s: 0
      - !!perl/hash:RE_bracket 
        decl: []

        min: 0
        re: !!perl/hash:RE_first 
          a: 0
          dba: metachar__S_477Lt_Gt
          i: 0
          min: 0
          r: 1
          s: 0
          zyg: 
            - !!perl/hash:RE_string 
              a: 0
              dba: metachar__S_477Lt_Gt
              i: 0
              min: 1
              r: 1
              s: 0
              text: ">"
            - !!perl/hash:RE_method 
              min: 0
              name: panic
              nobind: 1
              rest: ("regex assertion not terminated by angle bracket")
metachar__S_478Back: !!perl/hash:RE 
  decl: []

  kind: token
  min: 24690
  pkg: ~
  re: !!perl/hash:RE_sequence 
    a: 0
    dba: metachar__S_478Back
    i: 0
    min: 24690
    r: 1
    s: 0
    zyg: 
      - !!perl/hash:RE_method 
        a: 0
        dba: metachar__S_478Back
        i: 0
        min: 12345
        name: sym
        r: 1
        rest: ''
        s: 0
        sym: \
      - !!perl/hash:RE_method 
        a: 0
        dba: metachar__S_478Back
        i: 0
        min: 12345
        name: backslash
        r: 1
        rest: ''
        s: 0
metachar__S_479Dot: !!perl/hash:RE 
  decl: []

  kind: token
  min: 12345
  pkg: ~
  re: !!perl/hash:RE_method 
    a: 0
    dba: metachar__S_479Dot
    i: 0
    min: 12345
    name: sym
    r: 1
    rest: ''
    s: 0
    sym: .
metachar__S_480CaretCaret: !!perl/hash:RE 
  decl: []

  kind: token
  min: 12345
  pkg: ~
  re: !!perl/hash:RE_method 
    a: 0
    dba: metachar__S_480CaretCaret
    i: 0
    min: 12345
    name: sym
    r: 1
    rest: ''
    s: 0
    sym: "^^"
metachar__S_481Caret: !!perl/hash:RE 
  decl: []

  kind: token
  min: 12345
  pkg: ~
  re: !!perl/hash:RE_method 
    a: 0
    dba: metachar__S_481Caret
    i: 0
    min: 12345
    name: sym
    r: 1
    rest: ''
    s: 0
    sym: "^"
metachar__S_482DollarDollar: !!perl/hash:RE 
  decl: []

  kind: token
  min: 12345
  pkg: ~
  re: !!perl/hash:RE_sequence 
    a: 0
    dba: metachar__S_482DollarDollar
    i: 0
    min: 12345
    r: 1
    s: 0
    zyg: 
      - !!perl/hash:RE_method 
        a: 0
        dba: metachar__S_482DollarDollar
        i: 0
        min: 12345
        name: sym
        r: 1
        rest: ''
        s: 0
        sym: $$
      - !!perl/hash:RE_quantified_atom 
        atom: !!perl/hash:RE_bracket 
          decl: []

          min: 1
          re: !!perl/hash:RE_sequence 
            a: 0
            dba: metachar__S_482DollarDollar
            i: 0
            min: 1
            r: 1
            s: 0
            zyg: 
              - !!perl/hash:RE_bindpos 
                atom: !!perl/hash:RE_paren 
                  decl: []

                  min: 1
                  re: !!perl/hash:RE_quantified_atom 
                    atom: !!perl/hash:RE_meta 
                      a: 0
                      dba: metachar__S_482DollarDollar
                      i: 0
                      min: 1
                      r: 1
                      s: 0
                      text: \w
                    min: 1
                    quant: 
                      - +
                      - ":"
                      - ''
                      - 1
                min: 1
                var: 0
              - !!perl/hash:RE_method 
                min: 0
                name: obs
                nobind: 1
                rest: ("\$\$" ~ $0.Str ~ " to deref var inside a regex", "\$(\$" ~ $0.Str ~ ")")
        min: 0
        quant: 
          - "?"
          - ":"
          - ''
          - 0
metachar__S_483Dollar: !!perl/hash:RE 
  decl: []

  kind: token
  min: 1
  pkg: ~
  re: !!perl/hash:RE_sequence 
    a: 0
    dba: metachar__S_483Dollar
    i: 0
    min: 1
    r: 1
    s: 0
    zyg: 
      - !!perl/hash:RE_string 
        a: 0
        dba: metachar__S_483Dollar
        i: 0
        min: 1
        r: 1
        s: 0
        text: $
      - !!perl/hash:RE_assertion 
        assert: "?"
        min: 0
        re: !!perl/hash:RE_method_re 
          a: 0
          dba: metachar__S_483Dollar
          i: 0
          min: 0
          name: before
          nobind: 1
          r: 1
          re: !!perl/hash:RE 
            decl: []

            min: 0
            re: &5 !!perl/hash:RE_any 
              a: 0
              altname: metachar__S_483Dollar_01
              dba: metachar__S_483Dollar
              i: 0
              min: 0
              name: metachar__S_483Dollar_01
              r: 1
              s: 0
              zyg: 
                - !!perl/hash:RE_meta 
                  a: 0
                  alt: metachar__S_483Dollar_01 0
                  dba: metachar__S_483Dollar
                  i: 0
                  min: 1
                  r: 1
                  s: 0
                  text: \s
                - !!perl/hash:RE_string 
                  a: 0
                  alt: metachar__S_483Dollar_01 1
                  dba: metachar__S_483Dollar
                  i: 0
                  min: 1
                  r: 1
                  s: 0
                  text: "|"
                - !!perl/hash:RE_string 
                  a: 0
                  alt: metachar__S_483Dollar_01 2
                  dba: metachar__S_483Dollar
                  i: 0
                  min: 1
                  r: 1
                  s: 0
                  text: "&"
                - !!perl/hash:RE_string 
                  a: 0
                  alt: metachar__S_483Dollar_01 3
                  dba: metachar__S_483Dollar
                  i: 0
                  min: 1
                  r: 1
                  s: 0
                  text: )
                - !!perl/hash:RE_string 
                  a: 0
                  alt: metachar__S_483Dollar_01 4
                  dba: metachar__S_483Dollar
                  i: 0
                  min: 1
                  r: 1
                  s: 0
                  text: "]"
                - !!perl/hash:RE_string 
                  a: 0
                  alt: metachar__S_483Dollar_01 5
                  dba: metachar__S_483Dollar
                  i: 0
                  min: 1
                  r: 1
                  s: 0
                  text: ">"
                - !!perl/hash:RE_meta 
                  a: 0
                  alt: metachar__S_483Dollar_01 6
                  dba: metachar__S_483Dollar
                  i: 0
                  min: 0
                  r: 1
                  s: 0
                  text: $
                - !!perl/hash:RE_method 
                  a: 0
                  alt: metachar__S_483Dollar_01 7
                  dba: metachar__S_483Dollar
                  i: 0
                  min: 12345
                  name: stopper
                  nobind: 1
                  r: 1
                  rest: ''
                  s: 0
          s: 0
metachar__S_483Dollar_01: *5
metachar__S_484Single_Single: !!perl/hash:RE 
  decl: []

  kind: token
  min: 12345
  pkg: ~
  re: !!perl/hash:RE_sequence 
    a: 0
    dba: metachar__S_484Single_Single
    i: 0
    min: 12345
    r: 1
    s: 0
    zyg: 
      - !!perl/hash:RE_assertion 
        assert: "?"
        min: 0
        re: !!perl/hash:RE_method_re 
          a: 0
          dba: metachar__S_484Single_Single
          i: 0
          min: 0
          name: before
          nobind: 1
          r: 1
          re: !!perl/hash:RE 
            decl: []

            min: 1
            re: !!perl/hash:RE_double 
              a: 0
              dba: metachar__S_484Single_Single
              i: 0
              min: 1
              r: 1
              s: 0
              text: "'"
          s: 0
      - !!perl/hash:RE_bracket 
        decl: []

        min: 12345
        re: !!perl/hash:RE_sequence 
          a: 0
          dba: metachar__S_484Single_Single
          i: 0
          lang: ($C->cursor_fresh($::LANG{'MAIN'}))
          min: 12345
          r: 1
          s: 0
          zyg: 
            - !!perl/hash:RE_decl 
              a: 0
              dba: metachar__S_484Single_Single
              i: 0
              lang: ($C->cursor_fresh($::LANG{'MAIN'}))
              max: 0
              min: 0
              noquant: 1
              r: 1
              s: 0
              text: "my $newlang = ($C->cursor_fresh($::LANG{'MAIN'}));  $C = $C->cursor_fresh($newlang); "
            - !!perl/hash:RE_method 
              a: 0
              dba: metachar__S_484Single_Single
              i: 0
              lang: ($C->cursor_fresh($::LANG{'MAIN'}))
              min: 12345
              name: quote
              r: 1
              rest: ''
              s: 0
metachar__S_485Double_Double: !!perl/hash:RE 
  decl: []

  kind: token
  min: 12345
  pkg: ~
  re: !!perl/hash:RE_sequence 
    a: 0
    dba: metachar__S_485Double_Double
    i: 0
    min: 12345
    r: 1
    s: 0
    zyg: 
      - !!perl/hash:RE_assertion 
        assert: "?"
        min: 0
        re: !!perl/hash:RE_method_re 
          a: 0
          dba: metachar__S_485Double_Double
          i: 0
          min: 0
          name: before
          nobind: 1
          r: 1
          re: !!perl/hash:RE 
            decl: []

            min: 1
            re: !!perl/hash:RE_string 
              a: 0
              dba: metachar__S_485Double_Double
              i: 0
              min: 1
              r: 1
              s: 0
              text: "\""
          s: 0
      - !!perl/hash:RE_bracket 
        decl: []

        min: 12345
        re: !!perl/hash:RE_sequence 
          a: 0
          dba: metachar__S_485Double_Double
          i: 0
          lang: ($C->cursor_fresh($::LANG{'MAIN'}))
          min: 12345
          r: 1
          s: 0
          zyg: 
            - !!perl/hash:RE_decl 
              a: 0
              dba: metachar__S_485Double_Double
              i: 0
              lang: ($C->cursor_fresh($::LANG{'MAIN'}))
              max: 0
              min: 0
              noquant: 1
              r: 1
              s: 0
              text: "my $newlang = ($C->cursor_fresh($::LANG{'MAIN'}));  $C = $C->cursor_fresh($newlang); "
            - !!perl/hash:RE_method 
              a: 0
              dba: metachar__S_485Double_Double
              i: 0
              lang: ($C->cursor_fresh($::LANG{'MAIN'}))
              min: 12345
              name: quote
              r: 1
              rest: ''
              s: 0
metachar__S_486var: !!perl/hash:RE 
  decl: []

  kind: token
  min: 24690
  pkg: ~
  re: !!perl/hash:RE_sequence 
    a: 0
    dba: metachar__S_486var
    i: 0
    min: 24690
    r: 1
    s: 0
    zyg: 
      - !!perl/hash:RE_assertion 
        assert: "!"
        min: 0
        re: !!perl/hash:RE_method_re 
          a: 0
          dba: metachar__S_486var
          i: 0
          min: 0
          name: before
          nobind: 1
          r: 1
          re: !!perl/hash:RE 
            decl: []

            min: 2
            re: !!perl/hash:RE_string 
              a: 0
              dba: metachar__S_486var
              i: 0
              min: 2
              r: 1
              s: 0
              text: $$
          s: 0
      - !!perl/hash:RE_assertion 
        assert: "?"
        min: 0
        re: !!perl/hash:RE_method_re 
          a: 0
          dba: metachar__S_486var
          i: 0
          min: 0
          name: before
          nobind: 1
          r: 1
          re: !!perl/hash:RE 
            decl: []

            min: 12345
            re: !!perl/hash:RE_method 
              a: 0
              dba: metachar__S_486var
              i: 0
              min: 12345
              name: sigil
              r: 1
              rest: ''
              s: 0
          s: 0
      - !!perl/hash:RE_bracket 
        decl: []

        min: 24690
        re: !!perl/hash:RE_sequence 
          a: 0
          dba: metachar__S_486var
          i: 0
          lang: ($C->cursor_fresh($::LANG{'MAIN'}))
          min: 24690
          r: 1
          s: 0
          zyg: 
            - !!perl/hash:RE_decl 
              a: 0
              dba: metachar__S_486var
              i: 0
              lang: ($C->cursor_fresh($::LANG{'MAIN'}))
              max: 0
              min: 0
              noquant: 1
              r: 1
              s: 0
              text: "my $newlang = ($C->cursor_fresh($::LANG{'MAIN'}));  $C = $C->cursor_fresh($newlang); "
            - !!perl/hash:RE_method 
              a: 0
              dba: metachar__S_486var
              i: 0
              lang: ($C->cursor_fresh($::LANG{'MAIN'}))
              min: 12345
              name: variable
              r: 1
              rest: ''
              s: 0
            - !!perl/hash:RE_method 
              a: 0
              dba: metachar__S_486var
              i: 0
              lang: ($C->cursor_fresh($::LANG{'MAIN'}))
              min: 12345
              name: ws
              nobind: 1
              r: 1
              rest: ''
              s: 0
            - !!perl/hash:RE_method 
              min: 0
              name: check_variable
              nobind: 1
              rest: ($<variable>)
      - !!perl/hash:RE_bindnamed 
        a: 0
        atom: !!perl/hash:RE_quantified_atom 
          atom: !!perl/hash:RE_paren 
            decl: []

            min: 37036
            re: !!perl/hash:RE_sequence 
              a: 0
              dba: metachar__S_486var
              i: 0
              min: 37036
              r: 1
              s: 0
              zyg: 
                - !!perl/hash:RE_method 
                  a: 0
                  dba: metachar__S_486var
                  i: 0
                  min: 12345
                  name: ws
                  nobind: 1
                  r: 1
                  rest: ''
                  s: 0
                - !!perl/hash:RE_string 
                  a: 0
                  dba: metachar__S_486var
                  i: 0
                  min: 1
                  r: 1
                  s: 0
                  text: =
                - !!perl/hash:RE_method 
                  a: 0
                  dba: metachar__S_486var
                  i: 0
                  min: 12345
                  name: ws
                  nobind: 1
                  r: 1
                  rest: ''
                  s: 0
                - !!perl/hash:RE_method 
                  a: 0
                  dba: metachar__S_486var
                  i: 0
                  min: 12345
                  name: quantified_atom
                  r: 1
                  rest: ''
                  s: 0
          min: 0
          nobind: 1
          quant: 
            - "?"
            - ":"
            - ''
            - 0
        dba: metachar__S_486var
        i: 0
        min: 0
        r: 1
        s: 0
        var: binding
      - !!perl/hash:RE_block 
        a: 0
        context: void
        dba: metachar__S_486var
        i: 0
        min: 0
        r: 1
        s: 0
        text: " $<sym> = $<variable>.Str; "
mod_arg: !!perl/hash:RE 
  decl: []

  kind: token
  min: 12347
  pkg: ~
  re: !!perl/hash:RE_sequence 
    a: 0
    dba: modifier argument
    i: 0
    min: 12347
    r: 1
    s: 0
    zyg: 
      - !!perl/hash:RE_string 
        a: 0
        dba: modifier argument
        i: 0
        min: 1
        r: 1
        s: 0
        text: (
      - !!perl/hash:RE_meta 
        a: 0
        dba: modifier argument
        extra: "local $::GOAL = ')' "
        i: 0
        min: 0
        r: 1
        s: 0
        text: "::"
      - !!perl/hash:RE_method 
        a: 0
        dba: modifier argument
        i: 0
        min: 12345
        name: semilist
        r: 1
        rest: ''
        s: 0
      - !!perl/hash:RE_bracket 
        decl: []

        min: 1
        re: !!perl/hash:RE_first 
          a: 0
          dba: modifier argument
          i: 0
          min: 1
          r: 1
          s: 0
          zyg: 
            - !!perl/hash:RE_string 
              a: 0
              dba: modifier argument
              i: 0
              min: 1
              r: 1
              s: 0
              text: )
            - !!perl/hash:RE_method 
              min: 0
              name: FAILGOAL
              nobind: 1
              rest: (')' , 'modifier argument')
mod_internal__S_527Colonmy: !!perl/hash:RE 
  decl: []

  kind: token
  min: 24691
  pkg: ~
  re: !!perl/hash:RE_sequence 
    a: 0
    dba: mod_internal__S_527Colonmy
    i: 0
    min: 24691
    r: 1
    s: 0
    zyg: 
      - !!perl/hash:RE_string 
        a: 0
        dba: mod_internal__S_527Colonmy
        i: 0
        min: 1
        r: 1
        s: 0
        text: ":"
      - !!perl/hash:RE_assertion 
        assert: "?"
        min: 0
        re: !!perl/hash:RE_method_re 
          a: 0
          dba: mod_internal__S_527Colonmy
          i: 0
          min: 0
          name: before
          nobind: 1
          r: 1
          re: !!perl/hash:RE 
            decl: []

            min: 3
            re: !!perl/hash:RE_sequence 
              a: 0
              dba: mod_internal__S_527Colonmy
              i: 0
              min: 3
              r: 1
              s: 0
              zyg: 
                - !!perl/hash:RE_bracket 
                  decl: []

                  min: 2
                  re: &17 !!perl/hash:RE_any 
                    a: 0
                    altname: mod_internal__S_527Colonmy_02
                    dba: mod_internal__S_527Colonmy
                    i: 0
                    min: 2
                    name: mod_internal__S_527Colonmy_02
                    r: 1
                    s: 0
                    zyg: 
                      - !!perl/hash:RE_string 
                        a: 0
                        alt: mod_internal__S_527Colonmy_02 0
                        dba: mod_internal__S_527Colonmy
                        i: 0
                        min: 2
                        r: 1
                        s: 0
                        text: my
                      - !!perl/hash:RE_string 
                        a: 0
                        alt: mod_internal__S_527Colonmy_02 1
                        dba: mod_internal__S_527Colonmy
                        i: 0
                        min: 5
                        r: 1
                        s: 0
                        text: state
                      - !!perl/hash:RE_string 
                        a: 0
                        alt: mod_internal__S_527Colonmy_02 2
                        dba: mod_internal__S_527Colonmy
                        i: 0
                        min: 3
                        r: 1
                        s: 0
                        text: our
                      - !!perl/hash:RE_string 
                        a: 0
                        alt: mod_internal__S_527Colonmy_02 3
                        dba: mod_internal__S_527Colonmy
                        i: 0
                        min: 8
                        r: 1
                        s: 0
                        text: constant
                - !!perl/hash:RE_meta 
                  a: 0
                  dba: mod_internal__S_527Colonmy
                  i: 0
                  min: 1
                  r: 1
                  s: 0
                  text: \s
          s: 0
      - !!perl/hash:RE_bracket 
        decl: []

        min: 24690
        re: !!perl/hash:RE_sequence 
          a: 0
          dba: mod_internal__S_527Colonmy
          i: 0
          lang: ($C->cursor_fresh($::LANG{'MAIN'}))
          min: 24690
          r: 1
          s: 0
          zyg: 
            - !!perl/hash:RE_decl 
              a: 0
              dba: mod_internal__S_527Colonmy
              i: 0
              lang: ($C->cursor_fresh($::LANG{'MAIN'}))
              max: 0
              min: 0
              noquant: 1
              r: 1
              s: 0
              text: "my $newlang = ($C->cursor_fresh($::LANG{'MAIN'}));  $C = $C->cursor_fresh($newlang); "
            - !!perl/hash:RE_method 
              a: 0
              dba: mod_internal__S_527Colonmy
              i: 0
              lang: ($C->cursor_fresh($::LANG{'MAIN'}))
              min: 12345
              name: statement
              r: 1
              rest: ''
              s: 0
            - !!perl/hash:RE_method 
              a: 0
              dba: mod_internal__S_527Colonmy
              i: 0
              lang: ($C->cursor_fresh($::LANG{'MAIN'}))
              min: 12345
              name: eat_terminator
              r: 1
              rest: ''
              s: 0
mod_internal__S_527Colonmy_02: *17
mod_internal__S_528Colontemp: !!perl/hash:RE 
  decl: []

  kind: token
  min: 24691
  pkg: ~
  re: !!perl/hash:RE_sequence 
    a: 0
    dba: mod_internal__S_528Colontemp
    i: 0
    min: 24691
    r: 1
    s: 0
    zyg: 
      - !!perl/hash:RE_string 
        a: 0
        dba: mod_internal__S_528Colontemp
        i: 0
        min: 1
        r: 1
        s: 0
        text: ":"
      - !!perl/hash:RE_assertion 
        assert: "?"
        min: 0
        re: !!perl/hash:RE_method_re 
          a: 0
          dba: mod_internal__S_528Colontemp
          i: 0
          min: 0
          name: before
          nobind: 1
          r: 1
          re: !!perl/hash:RE 
            decl: []

            min: 4
            re: !!perl/hash:RE_sequence 
              a: 0
              dba: mod_internal__S_528Colontemp
              i: 0
              min: 4
              r: 1
              s: 0
              zyg: 
                - !!perl/hash:RE_bracket 
                  decl: []

                  min: 3
                  re: &27 !!perl/hash:RE_any 
                    a: 0
                    altname: mod_internal__S_528Colontemp_02
                    dba: mod_internal__S_528Colontemp
                    i: 0
                    min: 3
                    name: mod_internal__S_528Colontemp_02
                    r: 1
                    s: 0
                    zyg: 
                      - !!perl/hash:RE_string 
                        a: 0
                        alt: mod_internal__S_528Colontemp_02 0
                        dba: mod_internal__S_528Colontemp
                        i: 0
                        min: 4
                        r: 1
                        s: 0
                        text: temp
                      - !!perl/hash:RE_string 
                        a: 0
                        alt: mod_internal__S_528Colontemp_02 1
                        dba: mod_internal__S_528Colontemp
                        i: 0
                        min: 3
                        r: 1
                        s: 0
                        text: let
                - !!perl/hash:RE_meta 
                  a: 0
                  dba: mod_internal__S_528Colontemp
                  i: 0
                  min: 1
                  r: 1
                  s: 0
                  text: \s
          s: 0
      - !!perl/hash:RE_bracket 
        decl: []

        min: 24690
        re: !!perl/hash:RE_sequence 
          a: 0
          dba: mod_internal__S_528Colontemp
          i: 0
          lang: ($C->cursor_fresh($::LANG{'MAIN'}))
          min: 24690
          r: 1
          s: 0
          zyg: 
            - !!perl/hash:RE_decl 
              a: 0
              dba: mod_internal__S_528Colontemp
              i: 0
              lang: ($C->cursor_fresh($::LANG{'MAIN'}))
              max: 0
              min: 0
              noquant: 1
              r: 1
              s: 0
              text: "my $newlang = ($C->cursor_fresh($::LANG{'MAIN'}));  $C = $C->cursor_fresh($newlang); "
            - !!perl/hash:RE_method 
              a: 0
              dba: mod_internal__S_528Colontemp
              i: 0
              lang: ($C->cursor_fresh($::LANG{'MAIN'}))
              min: 12345
              name: statement
              r: 1
              rest: ''
              s: 0
            - !!perl/hash:RE_method 
              a: 0
              dba: mod_internal__S_528Colontemp
              i: 0
              lang: ($C->cursor_fresh($::LANG{'MAIN'}))
              min: 12345
              name: eat_terminator
              r: 1
              rest: ''
              s: 0
mod_internal__S_528Colontemp_02: *27
mod_internal__S_529Coloni: !!perl/hash:RE 
  decl: []

  kind: token
  min: 2
  pkg: ~
  re: !!perl/hash:RE_sequence 
    a: 0
    dba: mod_internal__S_529Coloni
    i: 0
    min: 2
    r: 1
    s: 0
    zyg: 
      - !!perl/hash:RE_bindnamed 
        a: 0
        atom: !!perl/hash:RE_bracket 
          decl: []

          min: 2
          nobind: 1
          re: &26 !!perl/hash:RE_any 
            a: 0
            altname: mod_internal__S_529Coloni_01
            dba: mod_internal__S_529Coloni
            i: 0
            min: 2
            name: mod_internal__S_529Coloni_01
            r: 1
            s: 0
            zyg: 
              - !!perl/hash:RE_string 
                a: 0
                alt: mod_internal__S_529Coloni_01 0
                dba: mod_internal__S_529Coloni
                i: 0
                min: 2
                r: 1
                s: 0
                text: :i
              - !!perl/hash:RE_string 
                a: 0
                alt: mod_internal__S_529Coloni_01 1
                dba: mod_internal__S_529Coloni
                i: 0
                min: 11
                r: 1
                s: 0
                text: :ignorecase
        dba: mod_internal__S_529Coloni
        i: 0
        min: 2
        r: 1
        s: 0
        var: sym
      - !!perl/hash:RE_meta 
        a: 0
        dba: mod_internal__S_529Coloni
        i: 0
        min: 0
        r: 1
        s: 0
        text: »
      - !!perl/hash:RE_block 
        a: 0
        context: void
        dba: mod_internal__S_529Coloni
        i: 0
        min: 0
        r: 1
        s: 0
        text: " $*ignorecase = 1 "
mod_internal__S_529Coloni_01: *26
mod_internal__S_530ColonBangi: !!perl/hash:RE 
  decl: []

  kind: token
  min: 3
  pkg: ~
  re: !!perl/hash:RE_sequence 
    a: 0
    dba: mod_internal__S_530ColonBangi
    i: 0
    min: 3
    r: 1
    s: 0
    zyg: 
      - !!perl/hash:RE_bindnamed 
        a: 0
        atom: !!perl/hash:RE_bracket 
          decl: []

          min: 3
          nobind: 1
          re: &1 !!perl/hash:RE_any 
            a: 0
            altname: mod_internal__S_530ColonBangi_01
            dba: mod_internal__S_530ColonBangi
            i: 0
            min: 3
            name: mod_internal__S_530ColonBangi_01
            r: 1
            s: 0
            zyg: 
              - !!perl/hash:RE_string 
                a: 0
                alt: mod_internal__S_530ColonBangi_01 0
                dba: mod_internal__S_530ColonBangi
                i: 0
                min: 3
                r: 1
                s: 0
                text: :!i
              - !!perl/hash:RE_string 
                a: 0
                alt: mod_internal__S_530ColonBangi_01 1
                dba: mod_internal__S_530ColonBangi
                i: 0
                min: 12
                r: 1
                s: 0
                text: :!ignorecase
        dba: mod_internal__S_530ColonBangi
        i: 0
        min: 3
        r: 1
        s: 0
        var: sym
      - !!perl/hash:RE_meta 
        a: 0
        dba: mod_internal__S_530ColonBangi
        i: 0
        min: 0
        r: 1
        s: 0
        text: »
      - !!perl/hash:RE_block 
        a: 0
        context: void
        dba: mod_internal__S_530ColonBangi
        i: 0
        min: 0
        r: 1
        s: 0
        text: " $*ignorecase = 0 "
mod_internal__S_530ColonBangi_01: *1
mod_internal__S_531ColoniParen_Thesis: !!perl/hash:RE 
  decl: []

  kind: token
  min: 12347
  pkg: ~
  re: !!perl/hash:RE_sequence 
    a: 0
    dba: mod_internal__S_531ColoniParen_Thesis
    i: 0
    min: 12347
    r: 1
    s: 0
    zyg: 
      - !!perl/hash:RE_bindnamed 
        a: 0
        atom: !!perl/hash:RE_bracket 
          decl: []

          min: 2
          nobind: 1
          re: &7 !!perl/hash:RE_any 
            a: 0
            altname: mod_internal__S_531ColoniParen_Thesis_01
            dba: mod_internal__S_531ColoniParen_Thesis
            i: 0
            min: 2
            name: mod_internal__S_531ColoniParen_Thesis_01
            r: 1
            s: 0
            zyg: 
              - !!perl/hash:RE_string 
                a: 0
                alt: mod_internal__S_531ColoniParen_Thesis_01 0
                dba: mod_internal__S_531ColoniParen_Thesis
                i: 0
                min: 2
                r: 1
                s: 0
                text: :i
              - !!perl/hash:RE_string 
                a: 0
                alt: mod_internal__S_531ColoniParen_Thesis_01 1
                dba: mod_internal__S_531ColoniParen_Thesis
                i: 0
                min: 11
                r: 1
                s: 0
                text: :ignorecase
        dba: mod_internal__S_531ColoniParen_Thesis
        i: 0
        min: 2
        r: 1
        s: 0
        var: sym
      - !!perl/hash:RE_method 
        a: 0
        dba: mod_internal__S_531ColoniParen_Thesis
        i: 0
        min: 12345
        name: mod_arg
        r: 1
        rest: ''
        s: 0
      - !!perl/hash:RE_block 
        a: 0
        context: void
        dba: mod_internal__S_531ColoniParen_Thesis
        i: 0
        min: 0
        r: 1
        s: 0
        text: " $*ignorecase = eval $<mod_arg>.Str "
mod_internal__S_531ColoniParen_Thesis_01: *7
mod_internal__S_532Colon0i: !!perl/hash:RE 
  decl: []

  kind: token
  min: 3
  pkg: ~
  re: !!perl/hash:RE_sequence 
    a: 0
    dba: mod_internal__S_532Colon0i
    i: 0
    min: 3
    r: 1
    s: 0
    zyg: 
      - !!perl/hash:RE_string 
        a: 0
        dba: mod_internal__S_532Colon0i
        i: 0
        min: 1
        r: 1
        s: 0
        text: ":"
      - !!perl/hash:RE_bindpos 
        atom: !!perl/hash:RE_paren 
          decl: []

          min: 1
          re: !!perl/hash:RE_quantified_atom 
            atom: !!perl/hash:RE_meta 
              a: 0
              dba: mod_internal__S_532Colon0i
              i: 0
              min: 1
              r: 1
              s: 0
              text: \d
            min: 1
            quant: 
              - +
              - ":"
              - ''
              - 1
        min: 1
        var: 0
      - !!perl/hash:RE_bracket 
        decl: []

        min: 1
        re: &28 !!perl/hash:RE_any 
          a: 0
          altname: mod_internal__S_532Colon0i_02
          dba: mod_internal__S_532Colon0i
          i: 0
          min: 1
          name: mod_internal__S_532Colon0i_02
          r: 1
          s: 0
          zyg: 
            - !!perl/hash:RE_string 
              a: 0
              alt: mod_internal__S_532Colon0i_02 0
              dba: mod_internal__S_532Colon0i
              i: 0
              min: 1
              r: 1
              s: 0
              text: i
            - !!perl/hash:RE_string 
              a: 0
              alt: mod_internal__S_532Colon0i_02 1
              dba: mod_internal__S_532Colon0i
              i: 0
              min: 10
              r: 1
              s: 0
              text: ignorecase
      - !!perl/hash:RE_block 
        a: 0
        context: void
        dba: mod_internal__S_532Colon0i
        i: 0
        min: 0
        r: 1
        s: 0
        text: " $*ignorecase = $0 "
mod_internal__S_532Colon0i_02: *28
mod_internal__S_533Colona: !!perl/hash:RE 
  decl: []

  kind: token
  min: 2
  pkg: ~
  re: !!perl/hash:RE_sequence 
    a: 0
    dba: mod_internal__S_533Colona
    i: 0
    min: 2
    r: 1
    s: 0
    zyg: 
      - !!perl/hash:RE_bindnamed 
        a: 0
        atom: !!perl/hash:RE_bracket 
          decl: []

          min: 2
          nobind: 1
          re: &29 !!perl/hash:RE_any 
            a: 0
            altname: mod_internal__S_533Colona_01
            dba: mod_internal__S_533Colona
            i: 0
            min: 2
            name: mod_internal__S_533Colona_01
            r: 1
            s: 0
            zyg: 
              - !!perl/hash:RE_string 
                a: 0
                alt: mod_internal__S_533Colona_01 0
                dba: mod_internal__S_533Colona
                i: 0
                min: 2
                r: 1
                s: 0
                text: :a
              - !!perl/hash:RE_string 
                a: 0
                alt: mod_internal__S_533Colona_01 1
                dba: mod_internal__S_533Colona
                i: 0
                min: 13
                r: 1
                s: 0
                text: :ignoreaccent
        dba: mod_internal__S_533Colona
        i: 0
        min: 2
        r: 1
        s: 0
        var: sym
      - !!perl/hash:RE_meta 
        a: 0
        dba: mod_internal__S_533Colona
        i: 0
        min: 0
        r: 1
        s: 0
        text: »
      - !!perl/hash:RE_block 
        a: 0
        context: void
        dba: mod_internal__S_533Colona
        i: 0
        min: 0
        r: 1
        s: 0
        text: " $*ignoreaccent = 1 "
mod_internal__S_533Colona_01: *29
mod_internal__S_534ColonBanga: !!perl/hash:RE 
  decl: []

  kind: token
  min: 3
  pkg: ~
  re: !!perl/hash:RE_sequence 
    a: 0
    dba: mod_internal__S_534ColonBanga
    i: 0
    min: 3
    r: 1
    s: 0
    zyg: 
      - !!perl/hash:RE_bindnamed 
        a: 0
        atom: !!perl/hash:RE_bracket 
          decl: []

          min: 3
          nobind: 1
          re: &15 !!perl/hash:RE_any 
            a: 0
            altname: mod_internal__S_534ColonBanga_01
            dba: mod_internal__S_534ColonBanga
            i: 0
            min: 3
            name: mod_internal__S_534ColonBanga_01
            r: 1
            s: 0
            zyg: 
              - !!perl/hash:RE_string 
                a: 0
                alt: mod_internal__S_534ColonBanga_01 0
                dba: mod_internal__S_534ColonBanga
                i: 0
                min: 3
                r: 1
                s: 0
                text: :!a
              - !!perl/hash:RE_string 
                a: 0
                alt: mod_internal__S_534ColonBanga_01 1
                dba: mod_internal__S_534ColonBanga
                i: 0
                min: 14
                r: 1
                s: 0
                text: :!ignoreaccent
        dba: mod_internal__S_534ColonBanga
        i: 0
        min: 3
        r: 1
        s: 0
        var: sym
      - !!perl/hash:RE_meta 
        a: 0
        dba: mod_internal__S_534ColonBanga
        i: 0
        min: 0
        r: 1
        s: 0
        text: »
      - !!perl/hash:RE_block 
        a: 0
        context: void
        dba: mod_internal__S_534ColonBanga
        i: 0
        min: 0
        r: 1
        s: 0
        text: " $*ignoreaccent = 0 "
mod_internal__S_534ColonBanga_01: *15
mod_internal__S_535ColonaParen_Thesis: !!perl/hash:RE 
  decl: []

  kind: token
  min: 12347
  pkg: ~
  re: !!perl/hash:RE_sequence 
    a: 0
    dba: mod_internal__S_535ColonaParen_Thesis
    i: 0
    min: 12347
    r: 1
    s: 0
    zyg: 
      - !!perl/hash:RE_bindnamed 
        a: 0
        atom: !!perl/hash:RE_bracket 
          decl: []

          min: 2
          nobind: 1
          re: &13 !!perl/hash:RE_any 
            a: 0
            altname: mod_internal__S_535ColonaParen_Thesis_01
            dba: mod_internal__S_535ColonaParen_Thesis
            i: 0
            min: 2
            name: mod_internal__S_535ColonaParen_Thesis_01
            r: 1
            s: 0
            zyg: 
              - !!perl/hash:RE_string 
                a: 0
                alt: mod_internal__S_535ColonaParen_Thesis_01 0
                dba: mod_internal__S_535ColonaParen_Thesis
                i: 0
                min: 2
                r: 1
                s: 0
                text: :a
              - !!perl/hash:RE_string 
                a: 0
                alt: mod_internal__S_535ColonaParen_Thesis_01 1
                dba: mod_internal__S_535ColonaParen_Thesis
                i: 0
                min: 13
                r: 1
                s: 0
                text: :ignoreaccent
        dba: mod_internal__S_535ColonaParen_Thesis
        i: 0
        min: 2
        r: 1
        s: 0
        var: sym
      - !!perl/hash:RE_method 
        a: 0
        dba: mod_internal__S_535ColonaParen_Thesis
        i: 0
        min: 12345
        name: mod_arg
        r: 1
        rest: ''
        s: 0
      - !!perl/hash:RE_block 
        a: 0
        context: void
        dba: mod_internal__S_535ColonaParen_Thesis
        i: 0
        min: 0
        r: 1
        s: 0
        text: " $*ignoreaccent = eval $<mod_arg>.Str "
mod_internal__S_535ColonaParen_Thesis_01: *13
mod_internal__S_536Colon0a: !!perl/hash:RE 
  decl: []

  kind: token
  min: 3
  pkg: ~
  re: !!perl/hash:RE_sequence 
    a: 0
    dba: mod_internal__S_536Colon0a
    i: 0
    min: 3
    r: 1
    s: 0
    zyg: 
      - !!perl/hash:RE_string 
        a: 0
        dba: mod_internal__S_536Colon0a
        i: 0
        min: 1
        r: 1
        s: 0
        text: ":"
      - !!perl/hash:RE_bindpos 
        atom: !!perl/hash:RE_paren 
          decl: []

          min: 1
          re: !!perl/hash:RE_quantified_atom 
            atom: !!perl/hash:RE_meta 
              a: 0
              dba: mod_internal__S_536Colon0a
              i: 0
              min: 1
              r: 1
              s: 0
              text: \d
            min: 1
            quant: 
              - +
              - ":"
              - ''
              - 1
        min: 1
        var: 0
      - !!perl/hash:RE_bracket 
        decl: []

        min: 1
        re: &6 !!perl/hash:RE_any 
          a: 0
          altname: mod_internal__S_536Colon0a_02
          dba: mod_internal__S_536Colon0a
          i: 0
          min: 1
          name: mod_internal__S_536Colon0a_02
          r: 1
          s: 0
          zyg: 
            - !!perl/hash:RE_string 
              a: 0
              alt: mod_internal__S_536Colon0a_02 0
              dba: mod_internal__S_536Colon0a
              i: 0
              min: 1
              r: 1
              s: 0
              text: a
            - !!perl/hash:RE_string 
              a: 0
              alt: mod_internal__S_536Colon0a_02 1
              dba: mod_internal__S_536Colon0a
              i: 0
              min: 12
              r: 1
              s: 0
              text: ignoreaccent
      - !!perl/hash:RE_block 
        a: 0
        context: void
        dba: mod_internal__S_536Colon0a
        i: 0
        min: 0
        r: 1
        s: 0
        text: " $*ignoreaccent = $0 "
mod_internal__S_536Colon0a_02: *6
mod_internal__S_537Colons: !!perl/hash:RE 
  decl: []

  kind: token
  min: 2
  pkg: ~
  re: !!perl/hash:RE_sequence 
    a: 0
    dba: mod_internal__S_537Colons
    i: 0
    min: 2
    r: 1
    s: 0
    zyg: 
      - !!perl/hash:RE_string 
        a: 0
        dba: mod_internal__S_537Colons
        i: 0
        min: 2
        r: 1
        s: 0
        text: :s
      - !!perl/hash:RE_quantified_atom 
        atom: !!perl/hash:RE_string 
          a: 0
          dba: mod_internal__S_537Colons
          i: 0
          min: 7
          r: 1
          s: 0
          text: igspace
        min: 0
        quant: 
          - "?"
          - ":"
          - ''
          - 0
      - !!perl/hash:RE_meta 
        a: 0
        dba: mod_internal__S_537Colons
        i: 0
        min: 0
        r: 1
        s: 0
        text: »
      - !!perl/hash:RE_block 
        a: 0
        context: void
        dba: mod_internal__S_537Colons
        i: 0
        min: 0
        r: 1
        s: 0
        text: " $*sigspace = 1 "
mod_internal__S_538ColonBangs: !!perl/hash:RE 
  decl: []

  kind: token
  min: 3
  pkg: ~
  re: !!perl/hash:RE_sequence 
    a: 0
    dba: mod_internal__S_538ColonBangs
    i: 0
    min: 3
    r: 1
    s: 0
    zyg: 
      - !!perl/hash:RE_string 
        a: 0
        dba: mod_internal__S_538ColonBangs
        i: 0
        min: 3
        r: 1
        s: 0
        text: :!s
      - !!perl/hash:RE_quantified_atom 
        atom: !!perl/hash:RE_string 
          a: 0
          dba: mod_internal__S_538ColonBangs
          i: 0
          min: 7
          r: 1
          s: 0
          text: igspace
        min: 0
        quant: 
          - "?"
          - ":"
          - ''
          - 0
      - !!perl/hash:RE_meta 
        a: 0
        dba: mod_internal__S_538ColonBangs
        i: 0
        min: 0
        r: 1
        s: 0
        text: »
      - !!perl/hash:RE_block 
        a: 0
        context: void
        dba: mod_internal__S_538ColonBangs
        i: 0
        min: 0
        r: 1
        s: 0
        text: " $*sigspace = 0 "
mod_internal__S_539ColonsParen_Thesis: !!perl/hash:RE 
  decl: []

  kind: token
  min: 12347
  pkg: ~
  re: !!perl/hash:RE_sequence 
    a: 0
    dba: mod_internal__S_539ColonsParen_Thesis
    i: 0
    min: 12347
    r: 1
    s: 0
    zyg: 
      - !!perl/hash:RE_string 
        a: 0
        dba: mod_internal__S_539ColonsParen_Thesis
        i: 0
        min: 2
        r: 1
        s: 0
        text: :s
      - !!perl/hash:RE_quantified_atom 
        atom: !!perl/hash:RE_string 
          a: 0
          dba: mod_internal__S_539ColonsParen_Thesis
          i: 0
          min: 7
          r: 1
          s: 0
          text: igspace
        min: 0
        quant: 
          - "?"
          - ":"
          - ''
          - 0
      - !!perl/hash:RE_method 
        a: 0
        dba: mod_internal__S_539ColonsParen_Thesis
        i: 0
        min: 12345
        name: mod_arg
        r: 1
        rest: ''
        s: 0
      - !!perl/hash:RE_block 
        a: 0
        context: void
        dba: mod_internal__S_539ColonsParen_Thesis
        i: 0
        min: 0
        r: 1
        s: 0
        text: " $*sigspace = eval $<mod_arg>.Str "
mod_internal__S_540Colon0s: !!perl/hash:RE 
  decl: []

  kind: token
  min: 3
  pkg: ~
  re: !!perl/hash:RE_sequence 
    a: 0
    dba: mod_internal__S_540Colon0s
    i: 0
    min: 3
    r: 1
    s: 0
    zyg: 
      - !!perl/hash:RE_string 
        a: 0
        dba: mod_internal__S_540Colon0s
        i: 0
        min: 1
        r: 1
        s: 0
        text: ":"
      - !!perl/hash:RE_bindpos 
        atom: !!perl/hash:RE_paren 
          decl: []

          min: 1
          re: !!perl/hash:RE_quantified_atom 
            atom: !!perl/hash:RE_meta 
              a: 0
              dba: mod_internal__S_540Colon0s
              i: 0
              min: 1
              r: 1
              s: 0
              text: \d
            min: 1
            quant: 
              - +
              - ":"
              - ''
              - 1
        min: 1
        var: 0
      - !!perl/hash:RE_string 
        a: 0
        dba: mod_internal__S_540Colon0s
        i: 0
        min: 1
        r: 1
        s: 0
        text: s
      - !!perl/hash:RE_quantified_atom 
        atom: !!perl/hash:RE_string 
          a: 0
          dba: mod_internal__S_540Colon0s
          i: 0
          min: 7
          r: 1
          s: 0
          text: igspace
        min: 0
        quant: 
          - "?"
          - ":"
          - ''
          - 0
      - !!perl/hash:RE_meta 
        a: 0
        dba: mod_internal__S_540Colon0s
        i: 0
        min: 0
        r: 1
        s: 0
        text: »
      - !!perl/hash:RE_block 
        a: 0
        context: void
        dba: mod_internal__S_540Colon0s
        i: 0
        min: 0
        r: 1
        s: 0
        text: " $*sigspace = $0 "
mod_internal__S_541Colonr: !!perl/hash:RE 
  decl: []

  kind: token
  min: 2
  pkg: ~
  re: !!perl/hash:RE_sequence 
    a: 0
    dba: mod_internal__S_541Colonr
    i: 0
    min: 2
    r: 1
    s: 0
    zyg: 
      - !!perl/hash:RE_string 
        a: 0
        dba: mod_internal__S_541Colonr
        i: 0
        min: 2
        r: 1
        s: 0
        text: :r
      - !!perl/hash:RE_quantified_atom 
        atom: !!perl/hash:RE_string 
          a: 0
          dba: mod_internal__S_541Colonr
          i: 0
          min: 6
          r: 1
          s: 0
          text: atchet
        min: 0
        quant: 
          - "?"
          - ":"
          - ''
          - 0
      - !!perl/hash:RE_meta 
        a: 0
        dba: mod_internal__S_541Colonr
        i: 0
        min: 0
        r: 1
        s: 0
        text: »
      - !!perl/hash:RE_block 
        a: 0
        context: void
        dba: mod_internal__S_541Colonr
        i: 0
        min: 0
        r: 1
        s: 0
        text: " $*ratchet = 1 "
mod_internal__S_542ColonBangr: !!perl/hash:RE 
  decl: []

  kind: token
  min: 3
  pkg: ~
  re: !!perl/hash:RE_sequence 
    a: 0
    dba: mod_internal__S_542ColonBangr
    i: 0
    min: 3
    r: 1
    s: 0
    zyg: 
      - !!perl/hash:RE_string 
        a: 0
        dba: mod_internal__S_542ColonBangr
        i: 0
        min: 3
        r: 1
        s: 0
        text: :!r
      - !!perl/hash:RE_quantified_atom 
        atom: !!perl/hash:RE_string 
          a: 0
          dba: mod_internal__S_542ColonBangr
          i: 0
          min: 6
          r: 1
          s: 0
          text: atchet
        min: 0
        quant: 
          - "?"
          - ":"
          - ''
          - 0
      - !!perl/hash:RE_meta 
        a: 0
        dba: mod_internal__S_542ColonBangr
        i: 0
        min: 0
        r: 1
        s: 0
        text: »
      - !!perl/hash:RE_block 
        a: 0
        context: void
        dba: mod_internal__S_542ColonBangr
        i: 0
        min: 0
        r: 1
        s: 0
        text: " $*ratchet = 0 "
mod_internal__S_543ColonrParen_Thesis: !!perl/hash:RE 
  decl: []

  kind: token
  min: 12347
  pkg: ~
  re: !!perl/hash:RE_sequence 
    a: 0
    dba: mod_internal__S_543ColonrParen_Thesis
    i: 0
    min: 12347
    r: 1
    s: 0
    zyg: 
      - !!perl/hash:RE_string 
        a: 0
        dba: mod_internal__S_543ColonrParen_Thesis
        i: 0
        min: 2
        r: 1
        s: 0
        text: :r
      - !!perl/hash:RE_quantified_atom 
        atom: !!perl/hash:RE_string 
          a: 0
          dba: mod_internal__S_543ColonrParen_Thesis
          i: 0
          min: 6
          r: 1
          s: 0
          text: atchet
        min: 0
        quant: 
          - "?"
          - ":"
          - ''
          - 0
      - !!perl/hash:RE_meta 
        a: 0
        dba: mod_internal__S_543ColonrParen_Thesis
        i: 0
        min: 0
        r: 1
        s: 0
        text: »
      - !!perl/hash:RE_method 
        a: 0
        dba: mod_internal__S_543ColonrParen_Thesis
        i: 0
        min: 12345
        name: mod_arg
        r: 1
        rest: ''
        s: 0
      - !!perl/hash:RE_block 
        a: 0
        context: void
        dba: mod_internal__S_543ColonrParen_Thesis
        i: 0
        min: 0
        r: 1
        s: 0
        text: " $*ratchet = eval $<mod_arg>.Str "
mod_internal__S_544Colon0r: !!perl/hash:RE 
  decl: []

  kind: token
  min: 3
  pkg: ~
  re: !!perl/hash:RE_sequence 
    a: 0
    dba: mod_internal__S_544Colon0r
    i: 0
    min: 3
    r: 1
    s: 0
    zyg: 
      - !!perl/hash:RE_string 
        a: 0
        dba: mod_internal__S_544Colon0r
        i: 0
        min: 1
        r: 1
        s: 0
        text: ":"
      - !!perl/hash:RE_bindpos 
        atom: !!perl/hash:RE_paren 
          decl: []

          min: 1
          re: !!perl/hash:RE_quantified_atom 
            atom: !!perl/hash:RE_meta 
              a: 0
              dba: mod_internal__S_544Colon0r
              i: 0
              min: 1
              r: 1
              s: 0
              text: \d
            min: 1
            quant: 
              - +
              - ":"
              - ''
              - 1
        min: 1
        var: 0
      - !!perl/hash:RE_string 
        a: 0
        dba: mod_internal__S_544Colon0r
        i: 0
        min: 1
        r: 1
        s: 0
        text: r
      - !!perl/hash:RE_quantified_atom 
        atom: !!perl/hash:RE_string 
          a: 0
          dba: mod_internal__S_544Colon0r
          i: 0
          min: 6
          r: 1
          s: 0
          text: atchet
        min: 0
        quant: 
          - "?"
          - ":"
          - ''
          - 0
      - !!perl/hash:RE_meta 
        a: 0
        dba: mod_internal__S_544Colon0r
        i: 0
        min: 0
        r: 1
        s: 0
        text: »
      - !!perl/hash:RE_block 
        a: 0
        context: void
        dba: mod_internal__S_544Colon0r
        i: 0
        min: 0
        r: 1
        s: 0
        text: " $*ratchet = $0 "
mod_internal__S_545ColonPerl5: !!perl/hash:RE 
  decl: []

  kind: token
  min: 12348
  pkg: ~
  re: !!perl/hash:RE_sequence 
    a: 0
    dba: mod_internal__S_545ColonPerl5
    i: 0
    min: 12348
    r: 1
    s: 0
    zyg: 
      - !!perl/hash:RE_bracket 
        decl: []

        min: 3
        re: &8 !!perl/hash:RE_any 
          a: 0
          altname: mod_internal__S_545ColonPerl5_01
          dba: mod_internal__S_545ColonPerl5
          i: 0
          min: 3
          name: mod_internal__S_545ColonPerl5_01
          r: 1
          s: 0
          zyg: 
            - !!perl/hash:RE_string 
              a: 0
              alt: mod_internal__S_545ColonPerl5_01 0
              dba: mod_internal__S_545ColonPerl5
              i: 0
              min: 6
              r: 1
              s: 0
              text: :Perl5
            - !!perl/hash:RE_string 
              a: 0
              alt: mod_internal__S_545ColonPerl5_01 1
              dba: mod_internal__S_545ColonPerl5
              i: 0
              min: 3
              r: 1
              s: 0
              text: :P5
      - !!perl/hash:RE_bracket 
        decl: []

        min: 12345
        re: !!perl/hash:RE_sequence 
          a: 0
          dba: mod_internal__S_545ColonPerl5
          i: 0
          lang: ( $C->cursor_fresh( $::LANG{'P5Regex'} )->unbalanced($::GOAL) )
          min: 12345
          r: 1
          s: 0
          zyg: 
            - !!perl/hash:RE_decl 
              a: 0
              dba: mod_internal__S_545ColonPerl5
              i: 0
              lang: ( $C->cursor_fresh( $::LANG{'P5Regex'} )->unbalanced($::GOAL) )
              max: 0
              min: 0
              noquant: 1
              r: 1
              s: 0
              text: "my $newlang = ( $C->cursor_fresh( $::LANG{'P5Regex'} )->unbalanced($::GOAL) );  $C = $C->cursor_fresh($newlang); "
            - !!perl/hash:RE_method 
              a: 0
              dba: mod_internal__S_545ColonPerl5
              i: 0
              lang: ( $C->cursor_fresh( $::LANG{'P5Regex'} )->unbalanced($::GOAL) )
              min: 12345
              name: nibbler
              r: 1
              rest: ''
              s: 0
mod_internal__S_545ColonPerl5_01: *8
mod_internal__S_546adv: !!perl/hash:RE 
  decl: []

  kind: token
  min: 12345
  pkg: ~
  re: !!perl/hash:RE_sequence 
    a: 0
    dba: mod_internal__S_546adv
    i: 0
    min: 12345
    r: 1
    s: 0
    zyg: 
      - !!perl/hash:RE_assertion 
        assert: "?"
        min: 0
        re: !!perl/hash:RE_method_re 
          a: 0
          dba: mod_internal__S_546adv
          i: 0
          min: 0
          name: before
          nobind: 1
          r: 1
          re: !!perl/hash:RE 
            decl: []

            min: 12346
            re: !!perl/hash:RE_sequence 
              a: 0
              dba: mod_internal__S_546adv
              i: 0
              min: 12346
              r: 1
              s: 0
              zyg: 
                - !!perl/hash:RE_string 
                  a: 0
                  dba: mod_internal__S_546adv
                  i: 0
                  min: 1
                  r: 1
                  s: 0
                  text: ":"
                - !!perl/hash:RE_method 
                  a: 0
                  dba: mod_internal__S_546adv
                  i: 0
                  min: 12345
                  name: identifier
                  nobind: 1
                  r: 1
                  rest: ''
                  s: 0
          s: 0
      - !!perl/hash:RE_bracket 
        decl: []

        min: 12345
        re: !!perl/hash:RE_sequence 
          a: 0
          dba: mod_internal__S_546adv
          i: 0
          lang: ($C->cursor_fresh($::LANG{'MAIN'}))
          min: 12345
          r: 1
          s: 0
          zyg: 
            - !!perl/hash:RE_decl 
              a: 0
              dba: mod_internal__S_546adv
              i: 0
              lang: ($C->cursor_fresh($::LANG{'MAIN'}))
              max: 0
              min: 0
              noquant: 1
              r: 1
              s: 0
              text: "my $newlang = ($C->cursor_fresh($::LANG{'MAIN'}));  $C = $C->cursor_fresh($newlang); "
            - !!perl/hash:RE_method 
              a: 0
              dba: mod_internal__S_546adv
              i: 0
              lang: ($C->cursor_fresh($::LANG{'MAIN'}))
              min: 12345
              name: quotepair
              r: 1
              rest: ''
              s: 0
      - !!perl/hash:RE_block 
        a: 0
        context: void
        dba: mod_internal__S_546adv
        i: 0
        min: 0
        r: 1
        s: 0
        text: " $/<sym> := «: $<quotepair><key>» "
mod_internal__S_547oops: !!perl/hash:RE 
  decl: []

  kind: token
  min: 2
  pkg: ~
  re: !!perl/hash:RE_sequence 
    a: 0
    dba: mod_internal__S_547oops
    i: 0
    min: 2
    r: 1
    s: 0
    zyg: 
      - !!perl/hash:RE_string 
        a: 0
        dba: mod_internal__S_547oops
        i: 0
        min: 1
        r: 1
        s: 0
        text: ":"
      - !!perl/hash:RE_quantified_atom 
        atom: !!perl/hash:RE_meta 
          a: 0
          dba: mod_internal__S_547oops
          i: 0
          min: 1
          r: 1
          s: 0
          text: \w
        min: 1
        quant: 
          - +
          - ":"
          - ''
          - 1
      - !!perl/hash:RE_method 
        min: 0
        name: panic
        nobind: 1
        rest: ("Unrecognized regex modifier")
nibbler: !!perl/hash:RE 
  decl: 
    - !!perl/hash:RE_decl 
      a: 0
      dba: nibbler
      i: 0
      max: 0
      min: 0
      r: 1
      s: 1
      text: my $sigspace    is context<rw> = $*sigspace    // 0
    - !!perl/hash:RE_decl 
      a: 0
      dba: nibbler
      i: 0
      max: 0
      min: 0
      r: 1
      s: 1
      text: my $ratchet     is context<rw> = $*ratchet     // 0
    - !!perl/hash:RE_decl 
      a: 0
      dba: nibbler
      i: 0
      max: 0
      min: 0
      r: 1
      s: 1
      text: my $ignorecase is context<rw> = $*ignorecase // 0
    - !!perl/hash:RE_decl 
      a: 0
      dba: nibbler
      i: 0
      max: 0
      min: 0
      r: 1
      s: 1
      text: my $ignoreaccent    is context<rw> = $*ignoreaccent    // 0
  kind: rule
  min: 12345
  pkg: ~
  re: !!perl/hash:RE_sequence 
    a: 0
    dba: nibbler
    i: 0
    min: 12345
    r: 1
    s: 1
    zyg: 
      - !!perl/hash:RE_method 
        min: 0
        name: ws
        nobind: 1
        noquant: 1
        rest: ''
      - !!perl/hash:RE_quantified_atom 
        atom: !!perl/hash:RE_bracket 
          decl: []

          min: 1
          re: !!perl/hash:RE_sequence 
            a: 0
            dba: nibbler
            i: 0
            min: 1
            r: 1
            s: 1
            zyg: 
              - !!perl/hash:RE_method 
                min: 0
                name: ws
                nobind: 1
                noquant: 1
                rest: ''
              - !!perl/hash:RE_quantified_atom 
                atom: !!perl/hash:RE_meta 
                  a: 0
                  dba: nibbler
                  i: 0
                  min: 1
                  r: 1
                  s: 1
                  text: \s
                min: 0
                quant: 
                  - "*"
                  - ":"
                  - ''
                  - 0
              - !!perl/hash:RE_method 
                min: 0
                name: ws
                nobind: 1
                noquant: 1
                rest: ''
              - !!perl/hash:RE_qw 
                a: 0
                dba: nibbler
                i: 0
                min: 1
                r: 1
                s: 1
                text: < || | && & >
              - !!perl/hash:RE_method 
                min: 0
                name: ws
                nobind: 1
                noquant: 1
                rest: ''
        min: 0
        quant: 
          - "?"
          - ":"
          - ''
          - 0
      - !!perl/hash:RE_method 
        min: 0
        name: ws
        nobind: 1
        noquant: 1
        rest: ''
      - !!perl/hash:RE_method 
        a: 0
        dba: nibbler
        i: 0
        min: 12345
        name: EXPR
        r: 1
        rest: ''
        s: 1
      - !!perl/hash:RE_method 
        min: 0
        name: ws
        nobind: 1
        noquant: 1
        rest: ''
normspace: !!perl/hash:RE 
  decl: []

  kind: token
  min: 12345
  pkg: ~
  re: !!perl/hash:RE_sequence 
    a: 0
    dba: normspace
    i: 0
    min: 12345
    r: 1
    s: 0
    zyg: 
      - !!perl/hash:RE_assertion 
        assert: "?"
        min: 0
        re: !!perl/hash:RE_method_re 
          a: 0
          dba: normspace
          i: 0
          min: 0
          name: before
          nobind: 1
          r: 1
          re: !!perl/hash:RE 
            decl: []

            min: 1
            re: &24 !!perl/hash:RE_any 
              a: 0
              altname: normspace_01
              dba: normspace
              i: 0
              min: 1
              name: normspace_01
              r: 1
              s: 0
              zyg: 
                - !!perl/hash:RE_meta 
                  a: 0
                  alt: normspace_01 0
                  dba: normspace
                  i: 0
                  min: 1
                  r: 1
                  s: 0
                  text: \s
                - !!perl/hash:RE_string 
                  a: 0
                  alt: normspace_01 1
                  dba: normspace
                  i: 0
                  min: 1
                  r: 1
                  s: 0
                  text: "#"
          s: 0
      - !!perl/hash:RE_bracket 
        decl: []

        min: 12345
        re: !!perl/hash:RE_sequence 
          a: 0
          dba: normspace
          i: 0
          lang: ($C->cursor_fresh($::LANG{'MAIN'}))
          min: 12345
          r: 1
          s: 0
          zyg: 
            - !!perl/hash:RE_decl 
              a: 0
              dba: normspace
              i: 0
              lang: ($C->cursor_fresh($::LANG{'MAIN'}))
              max: 0
              min: 0
              noquant: 1
              r: 1
              s: 0
              text: "my $newlang = ($C->cursor_fresh($::LANG{'MAIN'}));  $C = $C->cursor_fresh($newlang); "
            - !!perl/hash:RE_method 
              a: 0
              dba: normspace
              i: 0
              lang: ($C->cursor_fresh($::LANG{'MAIN'}))
              min: 12345
              name: ws
              nobind: 1
              r: 1
              rest: ''
              s: 0
normspace_01: *24
quantified_atom: !!perl/hash:RE 
  decl: []

  kind: token
  min: 24690
  pkg: ~
  re: !!perl/hash:RE_sequence 
    a: 0
    dba: quantified_atom
    i: 0
    min: 24690
    r: 1
    s: 0
    zyg: 
      - !!perl/hash:RE_assertion 
        assert: "!"
        min: 0
        re: !!perl/hash:RE_method 
          a: 0
          dba: quantified_atom
          i: 0
          min: 12345
          name: stopper
          nobind: 1
          r: 1
          rest: ''
          s: 0
      - !!perl/hash:RE_assertion 
        assert: "!"
        min: 0
        re: !!perl/hash:RE_method 
          a: 0
          dba: quantified_atom
          i: 0
          min: 12345
          name: regex_infix
          nobind: 1
          r: 1
          rest: ''
          s: 0
      - !!perl/hash:RE_method 
        a: 0
        dba: quantified_atom
        i: 0
        min: 12345
        name: atom
        r: 1
        rest: ''
        s: 0
      - !!perl/hash:RE_method 
        a: 0
        dba: quantified_atom
        i: 0
        min: 12345
        name: ws
        nobind: 1
        r: 1
        rest: ''
        s: 0
      - !!perl/hash:RE_quantified_atom 
        atom: !!perl/hash:RE_bracket 
          decl: []

          min: 24690
          re: !!perl/hash:RE_sequence 
            a: 0
            dba: quantified_atom
            i: 0
            min: 24690
            r: 1
            s: 0
            zyg: 
              - !!perl/hash:RE_method 
                a: 0
                dba: quantified_atom
                i: 0
                min: 12345
                name: quantifier
                r: 1
                rest: ''
                s: 0
              - !!perl/hash:RE_method 
                a: 0
                dba: quantified_atom
                i: 0
                min: 12345
                name: ws
                nobind: 1
                r: 1
                rest: ''
                s: 0
        min: 0
        quant: 
          - "?"
          - ":"
          - ''
          - 0
quantifier__S_548Star: !!perl/hash:RE 
  decl: []

  kind: token
  min: 24690
  pkg: ~
  re: !!perl/hash:RE_sequence 
    a: 0
    dba: quantifier__S_548Star
    i: 0
    min: 24690
    r: 1
    s: 0
    zyg: 
      - !!perl/hash:RE_method 
        a: 0
        dba: quantifier__S_548Star
        i: 0
        min: 12345
        name: sym
        r: 1
        rest: ''
        s: 0
        sym: "*"
      - !!perl/hash:RE_method 
        a: 0
        dba: quantifier__S_548Star
        i: 0
        min: 12345
        name: quantmod
        r: 1
        rest: ''
        s: 0
quantifier__S_549Plus: !!perl/hash:RE 
  decl: []

  kind: token
  min: 24690
  pkg: ~
  re: !!perl/hash:RE_sequence 
    a: 0
    dba: quantifier__S_549Plus
    i: 0
    min: 24690
    r: 1
    s: 0
    zyg: 
      - !!perl/hash:RE_method 
        a: 0
        dba: quantifier__S_549Plus
        i: 0
        min: 12345
        name: sym
        r: 1
        rest: ''
        s: 0
        sym: +
      - !!perl/hash:RE_method 
        a: 0
        dba: quantifier__S_549Plus
        i: 0
        min: 12345
        name: quantmod
        r: 1
        rest: ''
        s: 0
quantifier__S_550Question: !!perl/hash:RE 
  decl: []

  kind: token
  min: 24690
  pkg: ~
  re: !!perl/hash:RE_sequence 
    a: 0
    dba: quantifier__S_550Question
    i: 0
    min: 24690
    r: 1
    s: 0
    zyg: 
      - !!perl/hash:RE_method 
        a: 0
        dba: quantifier__S_550Question
        i: 0
        min: 12345
        name: sym
        r: 1
        rest: ''
        s: 0
        sym: "?"
      - !!perl/hash:RE_method 
        a: 0
        dba: quantifier__S_550Question
        i: 0
        min: 12345
        name: quantmod
        r: 1
        rest: ''
        s: 0
quantifier__S_551StarStar: !!perl/hash:RE 
  decl: []

  kind: token
  min: 24691
  pkg: ~
  re: !!perl/hash:RE_sequence 
    a: 0
    dba: quantifier__S_551StarStar
    i: 0
    min: 24691
    r: 1
    s: 0
    zyg: 
      - !!perl/hash:RE_method 
        a: 0
        dba: quantifier__S_551StarStar
        i: 0
        min: 12345
        name: sym
        r: 1
        rest: ''
        s: 0
        sym: "**"
      - !!perl/hash:RE_meta 
        a: 0
        dba: quantifier__S_551StarStar
        i: 0
        min: 0
        r: 1
        s: 0
        text: "::"
      - !!perl/hash:RE_quantified_atom 
        atom: !!perl/hash:RE_method 
          a: 0
          dba: quantifier__S_551StarStar
          i: 0
          min: 12345
          name: normspace
          r: 1
          rest: ''
          s: 0
        min: 0
        quant: 
          - "?"
          - ":"
          - ''
          - 0
      - !!perl/hash:RE_method 
        a: 0
        dba: quantifier__S_551StarStar
        i: 0
        min: 12345
        name: quantmod
        r: 1
        rest: ''
        s: 0
      - !!perl/hash:RE_quantified_atom 
        atom: !!perl/hash:RE_method 
          a: 0
          dba: quantifier__S_551StarStar
          i: 0
          min: 12345
          name: normspace
          r: 1
          rest: ''
          s: 0
        min: 0
        quant: 
          - "?"
          - ":"
          - ''
          - 0
      - !!perl/hash:RE_bracket 
        decl: []

        min: 1
        re: &14 !!perl/hash:RE_any 
          a: 0
          altname: quantifier__S_551StarStar_01
          dba: quantifier__S_551StarStar
          i: 0
          min: 1
          name: quantifier__S_551StarStar_01
          r: 1
          s: 0
          zyg: 
            - !!perl/hash:RE_sequence 
              a: 0
              alt: quantifier__S_551StarStar_01 0
              dba: quantifier__S_551StarStar
              i: 0
              min: 1
              r: 1
              s: 0
              zyg: 
                - !!perl/hash:RE_quantified_atom 
                  atom: !!perl/hash:RE_meta 
                    a: 0
                    dba: quantifier__S_551StarStar
                    i: 0
                    min: 1
                    r: 1
                    s: 0
                    text: \d
                  min: 1
                  quant: 
                    - +
                    - ":"
                    - ''
                    - 1
                - !!perl/hash:RE_quantified_atom 
                  atom: !!perl/hash:RE_bracket 
                    decl: []

                    min: 3
                    re: !!perl/hash:RE_sequence 
                      a: 0
                      dba: quantifier__S_551StarStar
                      i: 0
                      min: 3
                      r: 1
                      s: 0
                      zyg: 
                        - !!perl/hash:RE_string 
                          a: 0
                          dba: quantifier__S_551StarStar
                          i: 0
                          min: 2
                          r: 1
                          s: 0
                          text: ..
                        - !!perl/hash:RE_bracket 
                          decl: []

                          min: 1
                          re: &16 !!perl/hash:RE_any 
                            a: 0
                            altname: quantifier__S_551StarStar_03
                            dba: quantifier__S_551StarStar
                            i: 0
                            min: 1
                            name: quantifier__S_551StarStar_03
                            r: 1
                            s: 0
                            zyg: 
                              - !!perl/hash:RE_quantified_atom 
                                alt: quantifier__S_551StarStar_03 0
                                atom: !!perl/hash:RE_meta 
                                  a: 0
                                  dba: quantifier__S_551StarStar
                                  i: 0
                                  min: 1
                                  r: 1
                                  s: 0
                                  text: \d
                                min: 1
                                quant: 
                                  - +
                                  - ":"
                                  - ''
                                  - 1
                              - !!perl/hash:RE_string 
                                a: 0
                                alt: quantifier__S_551StarStar_03 1
                                dba: quantifier__S_551StarStar
                                i: 0
                                min: 1
                                r: 1
                                s: 0
                                text: "*"
                  min: 0
                  quant: 
                    - "?"
                    - ":"
                    - ''
                    - 0
            - !!perl/hash:RE_method 
              a: 0
              alt: quantifier__S_551StarStar_01 1
              dba: quantifier__S_551StarStar
              i: 0
              min: 12345
              name: codeblock
              r: 1
              rest: ''
              s: 0
            - !!perl/hash:RE_method 
              a: 0
              alt: quantifier__S_551StarStar_01 2
              dba: quantifier__S_551StarStar
              i: 0
              min: 12345
              name: quantified_atom
              r: 1
              rest: ''
              s: 0
quantifier__S_551StarStar_01: *14
quantifier__S_551StarStar_03: *16
quantifier__S_552TildeTilde: !!perl/hash:RE 
  decl: []

  kind: token
  min: 37035
  pkg: ~
  re: !!perl/hash:RE_sequence 
    a: 0
    dba: quantifier__S_552TildeTilde
    i: 0
    min: 37035
    r: 1
    s: 0
    zyg: 
      - !!perl/hash:RE_bracket 
        decl: []

        min: 12345
        re: &4 !!perl/hash:RE_any 
          a: 0
          altname: quantifier__S_552TildeTilde_01
          dba: quantifier__S_552TildeTilde
          i: 0
          min: 12345
          name: quantifier__S_552TildeTilde_01
          r: 1
          s: 0
          zyg: 
            - !!perl/hash:RE_sequence 
              a: 0
              alt: quantifier__S_552TildeTilde_01 0
              dba: quantifier__S_552TildeTilde
              i: 0
              min: 12346
              r: 1
              s: 0
              zyg: 
                - !!perl/hash:RE_string 
                  a: 0
                  dba: quantifier__S_552TildeTilde
                  i: 0
                  min: 1
                  r: 1
                  s: 0
                  text: "!"
                - !!perl/hash:RE_method 
                  a: 0
                  dba: quantifier__S_552TildeTilde
                  i: 0
                  min: 12345
                  name: sym
                  r: 1
                  rest: ''
                  s: 0
                  sym: ~~
            - !!perl/hash:RE_method 
              a: 0
              alt: quantifier__S_552TildeTilde_01 1
              dba: quantifier__S_552TildeTilde
              i: 0
              min: 12345
              name: sym
              r: 1
              rest: ''
              s: 0
              sym: ~~
      - !!perl/hash:RE_method 
        a: 0
        dba: quantifier__S_552TildeTilde
        i: 0
        min: 12345
        name: normspace
        r: 1
        rest: ''
        s: 0
      - !!perl/hash:RE_method 
        a: 0
        dba: quantifier__S_552TildeTilde
        i: 0
        min: 12345
        name: quantified_atom
        r: 1
        rest: ''
        s: 0
quantifier__S_552TildeTilde_01: *4
quantmod: !!perl/hash:RE 
  decl: []

  kind: token
  min: 0
  pkg: ~
  re: !!perl/hash:RE_sequence 
    a: 0
    dba: quantmod
    i: 0
    min: 0
    r: 1
    s: 0
    zyg: 
      - !!perl/hash:RE_quantified_atom 
        atom: !!perl/hash:RE_string 
          a: 0
          dba: quantmod
          i: 0
          min: 1
          r: 1
          s: 0
          text: ":"
        min: 0
        quant: 
          - "?"
          - ":"
          - ''
          - 0
      - !!perl/hash:RE_quantified_atom 
        atom: !!perl/hash:RE_bracket 
          decl: []

          min: 1
          re: &12 !!perl/hash:RE_any 
            a: 0
            altname: quantmod_01
            dba: quantmod
            i: 0
            min: 1
            name: quantmod_01
            r: 1
            s: 0
            zyg: 
              - !!perl/hash:RE_string 
                a: 0
                alt: quantmod_01 0
                dba: quantmod
                i: 0
                min: 1
                r: 1
                s: 0
                text: "?"
              - !!perl/hash:RE_string 
                a: 0
                alt: quantmod_01 1
                dba: quantmod
                i: 0
                min: 1
                r: 1
                s: 0
                text: "!"
              - !!perl/hash:RE_string 
                a: 0
                alt: quantmod_01 2
                dba: quantmod
                i: 0
                min: 1
                r: 1
                s: 0
                text: +
        min: 0
        quant: 
          - "?"
          - ":"
          - ''
          - 0
quantmod_01: *12
regex_infix__S_447VertVert: !!perl/hash:RE 
  decl: []

  kind: token
  min: 12345
  pkg: STD::Tight_or
  re: !!perl/hash:RE_method 
    a: 0
    dba: regex_infix__S_447VertVert
    i: 0
    min: 12345
    name: sym
    r: 1
    rest: ''
    s: 0
    sym: "||"
regex_infix__S_448AmpAmp: !!perl/hash:RE 
  decl: []

  kind: token
  min: 12345
  pkg: STD::Tight_and
  re: !!perl/hash:RE_method 
    a: 0
    dba: regex_infix__S_448AmpAmp
    i: 0
    min: 12345
    name: sym
    r: 1
    rest: ''
    s: 0
    sym: "&&"
regex_infix__S_449Vert: !!perl/hash:RE 
  decl: []

  kind: token
  min: 12345
  pkg: STD::Junctive_or
  re: !!perl/hash:RE_method 
    a: 0
    dba: regex_infix__S_449Vert
    i: 0
    min: 12345
    name: sym
    r: 1
    rest: ''
    s: 0
    sym: "|"
regex_infix__S_450Amp: !!perl/hash:RE 
  decl: []

  kind: token
  min: 12345
  pkg: STD::Junctive_and
  re: !!perl/hash:RE_method 
    a: 0
    dba: regex_infix__S_450Amp
    i: 0
    min: 12345
    name: sym
    r: 1
    rest: ''
    s: 0
    sym: "&"
regex_infix__S_451Tilde: !!perl/hash:RE 
  decl: []

  kind: token
  min: 12345
  pkg: STD::Additive
  re: !!perl/hash:RE_method 
    a: 0
    dba: regex_infix__S_451Tilde
    i: 0
    min: 12345
    name: sym
    r: 1
    rest: ''
    s: 0
    sym: '~'
sign: !!perl/hash:RE 
  decl: []

  kind: token
  min: 0
  pkg: ~
  re: &10 !!perl/hash:RE_any 
    a: 0
    altname: sign_00
    dba: sign
    i: 0
    min: 0
    name: sign_00
    r: 1
    s: 0
    zyg: 
      - !!perl/hash:RE_string 
        a: 0
        alt: sign_00 0
        dba: sign
        i: 0
        min: 1
        r: 1
        s: 0
        text: +
      - !!perl/hash:RE_string 
        a: 0
        alt: sign_00 1
        dba: sign
        i: 0
        min: 1
        r: 1
        s: 0
        text: "-"
      - !!perl/hash:RE_assertion 
        alt: sign_00 2
        assert: "?"
        min: 0
        re: !!perl/hash:RE_noop 
          a: 0
          dba: sign
          i: 0
          min: 0
          nobind: 1
          r: 1
          s: 0
sign_00: *10
termish: !!perl/hash:RE 
  decl: []

  kind: token
  min: 12345
  pkg: ~
  re: !!perl/hash:RE_sequence 
    a: 0
    dba: termish
    i: 0
    min: 12345
    r: 1
    s: 0
    zyg: 
      - !!perl/hash:RE_method 
        a: 0
        dba: termish
        i: 0
        min: 12345
        name: ws
        nobind: 1
        r: 1
        rest: ''
        s: 0
      - !!perl/hash:RE_bracket 
        decl: []

        min: 0
        re: !!perl/hash:RE_first 
          a: 0
          dba: termish
          i: 0
          min: 0
          r: 1
          s: 0
          zyg: 
            - !!perl/hash:RE_bindnamed 
              a: 0
              atom: !!perl/hash:RE_quantified_atom 
                atom: !!perl/hash:RE_method 
                  a: 0
                  dba: termish
                  i: 0
                  min: 12345
                  name: quantified_atom
                  r: 1
                  rest: ''
                  s: 0
                min: 12345
                nobind: 1
                quant: 
                  - +
                  - ":"
                  - ''
                  - 1
              dba: termish
              i: 0
              min: 12345
              r: 1
              s: 0
              var: noun
            - !!perl/hash:RE_sequence 
              a: 0
              dba: termish
              i: 0
              min: 0
              r: 1
              s: 0
              zyg: 
                - !!perl/hash:RE_assertion 
                  assert: "?"
                  min: 0
                  re: !!perl/hash:RE_method_re 
                    a: 0
                    dba: termish
                    i: 0
                    min: 0
                    name: before
                    nobind: 1
                    r: 1
                    re: !!perl/hash:RE 
                      decl: []

                      min: 1
                      re: &19 !!perl/hash:RE_any 
                        a: 0
                        altname: termish_03
                        dba: termish
                        i: 0
                        min: 1
                        name: termish_03
                        r: 1
                        s: 0
                        zyg: 
                          - !!perl/hash:RE_method 
                            a: 0
                            alt: termish_03 0
                            dba: termish
                            i: 0
                            min: 12345
                            name: stopper
                            r: 1
                            rest: ''
                            s: 0
                          - !!perl/hash:RE_cclass 
                            a: 0
                            alt: termish_03 1
                            dba: termish
                            i: 0
                            min: 1
                            r: 1
                            s: 0
                            text: "[&|~]"
                    s: 0
                - !!perl/hash:RE_method 
                  min: 0
                  name: panic
                  nobind: 1
                  rest: ("Null pattern not allowed")
            - !!perl/hash:RE_sequence 
              a: 0
              dba: termish
              i: 0
              min: 0
              r: 1
              s: 0
              zyg: 
                - !!perl/hash:RE_assertion 
                  assert: "?"
                  min: 0
                  re: !!perl/hash:RE_method_re 
                    a: 0
                    dba: termish
                    i: 0
                    min: 0
                    name: before
                    nobind: 1
                    r: 1
                    re: !!perl/hash:RE 
                      decl: []

                      min: 1
                      re: !!perl/hash:RE_cclass 
                        a: 0
                        dba: termish
                        i: 0
                        min: 1
                        r: 1
                        s: 0
                        text: "[ \\] \\) \\> ]"
                    s: 0
                - !!perl/hash:RE_method 
                  min: 0
                  name: panic
                  nobind: 1
                  rest: ("Unmatched closing bracket")
            - !!perl/hash:RE_method 
              min: 0
              name: panic
              nobind: 1
              rest: ("Unrecognized regex metacharacter (must be quoted to match literally)")
termish_03: *19
unsp: !!perl/hash:RE 
  decl: []

  kind: token
  min: 1
  pkg: ~
  re: !!perl/hash:RE_sequence 
    a: 0
    dba: unsp
    i: 0
    min: 1
    r: 1
    s: 0
    zyg: 
      - !!perl/hash:RE_string 
        a: 0
        dba: unsp
        i: 0
        min: 1
        r: 1
        s: 0
        text: \
      - !!perl/hash:RE_assertion 
        assert: "?"
        min: 0
        re: !!perl/hash:RE_method_re 
          a: 0
          dba: unsp
          i: 0
          min: 0
          name: before
          nobind: 1
          r: 1
          re: !!perl/hash:RE 
            decl: []

            min: 1
            re: &30 !!perl/hash:RE_any 
              a: 0
              altname: unsp_01
              dba: unsp
              i: 0
              min: 1
              name: unsp_01
              r: 1
              s: 0
              zyg: 
                - !!perl/hash:RE_meta 
                  a: 0
                  alt: unsp_01 0
                  dba: unsp
                  i: 0
                  min: 1
                  r: 1
                  s: 0
                  text: \s
                - !!perl/hash:RE_string 
                  a: 0
                  alt: unsp_01 1
                  dba: unsp
                  i: 0
                  min: 1
                  r: 1
                  s: 0
                  text: "#"
          s: 0
      - !!perl/hash:RE_method 
        min: 0
        name: panic
        nobind: 1
        rest: ("No unspace allowed in regex (for literal please quote with single quotes)")
unsp_01: *30
ws: !!perl/hash:RE 
  decl: []

  kind: token
  min: 0
  pkg: ~
  re: !!perl/hash:RE_first 
    a: 0
    dba: ws
    i: 0
    min: 0
    r: 1
    s: 0
    zyg: 
      - !!perl/hash:RE_assertion 
        assert: "?"
        min: 0
        re: !!perl/hash:RE_block 
          a: 0
          context: bool
          dba: ws
          i: 0
          min: 0
          nobind: 1
          r: 1
          s: 0
          text: " $*sigspace "
      - !!perl/hash:RE_quantified_atom 
        atom: !!perl/hash:RE_bracket 
          decl: []

          min: 12345
          re: !!perl/hash:RE_sequence 
            a: 0
            dba: ws
            i: 0
            min: 12345
            r: 1
            s: 0
            zyg: 
              - !!perl/hash:RE_assertion 
                assert: "?"
                min: 0
                re: !!perl/hash:RE_method_re 
                  a: 0
                  dba: ws
                  i: 0
                  min: 0
                  name: before
                  nobind: 1
                  r: 1
                  re: !!perl/hash:RE 
                    decl: []

                    min: 1
                    re: &23 !!perl/hash:RE_any 
                      a: 0
                      altname: ws_03
                      dba: ws
                      i: 0
                      min: 1
                      name: ws_03
                      r: 1
                      s: 0
                      zyg: 
                        - !!perl/hash:RE_meta 
                          a: 0
                          alt: ws_03 0
                          dba: ws
                          i: 0
                          min: 1
                          r: 1
                          s: 0
                          text: \s
                        - !!perl/hash:RE_string 
                          a: 0
                          alt: ws_03 1
                          dba: ws
                          i: 0
                          min: 1
                          r: 1
                          s: 0
                          text: "#"
                  s: 0
              - !!perl/hash:RE_method 
                a: 0
                dba: ws
                i: 0
                min: 12345
                name: nextsame
                nobind: 1
                r: 1
                rest: ''
                s: 0
        min: 0
        quant: 
          - "?"
          - ":"
          - ''
          - 0
ws_03: *23
RETREE_END
}
} ## end grammar

############
# P5 Regex #
############

{ package STD::P5Regex;
use Moose ':all' => { -prefix => "moose_" };
my $retree;
moose_extends(qw(STD));
sub multitweak { # begin tweaks
my $self = shift;
my ($k, $v) = @_;

if (0) {}
elsif ($k eq 'global' or $k eq 'g') {
my $g = $v;  $self }
elsif ($k eq 'ignorecase' or $k eq 'i') {
my $i = $v;  $self }
else { die 'NOMATCH' }
} # end tweaks

##     token category__S_553metachar (:$sym is context<rw> = 'metachar')
##          token category:metachar { <sym> }

sub category__S_553metachar__PEEK { $_[0]->_AUTOLEXpeek('category__S_553metachar',$retree) }
sub category__S_553metachar {
my $self = shift;
local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;
my %args = @_;
local $sym = $args{sym} // 'metachar';


my $C = $self;
my $S = $C->{'_pos'};
$C->{'sym'} = $sym;

$self->_MATCHIFYr($S, "category__S_553metachar", 
$C->_PATTERN(qr/\Gmetachar/)
);
}
#proto token metachar { <...> }
sub metachar__PEEK { $_[0]->_AUTOLEXpeek('metachar:*',$retree); }
sub metachar {
my $self = shift;
my $subs;

local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;

my $C = $self;
my $S = $C->{'_pos'};

my @result = eval {
my $trystate;
my ($tag, $try);
my @try;
my $relex;
if (my $fate = $C->{'_fate'}) {
if ($fate->[1] eq 'metachar') {
$C->deb("Fate passed to metachar: ", ::fatestr($fate)) if $::DEBUG & DEBUG::fates;
($C->{'_fate'}, $tag, $try) = @$fate;
@try = ($try);
}
}

my @gather = ();
for (;;) {
if (not @try) {
$relex //= $C->cursor_fate('STD::P5Regex', 'metachar:*', $retree);
@try = $relex->($C, $trystate);
}
last unless @try;
$try = shift(@try) // next;

if (ref $try eq 'ARRAY') {
($C->{'_fate'}, $tag, $try) = @$try;	# next candidate fate
}

$C->deb("metachar trying $tag $try") if $::DEBUG & DEBUG::try_processing;
push @gather, $C->$try(@_);
last if @gather;
}
$self->_MATCHIFY($S, "metachar", @gather);
};
if ($@) {
return () if $@ =~ /^ABORTRULE/;
die $@;
}
@result;
}


##     token category__S_554backslash (:$sym is context<rw> = 'backslash')
##          token category:backslash { <sym> }

sub category__S_554backslash__PEEK { $_[0]->_AUTOLEXpeek('category__S_554backslash',$retree) }
sub category__S_554backslash {
my $self = shift;
local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;
my %args = @_;
local $sym = $args{sym} // 'backslash';


my $C = $self;
my $S = $C->{'_pos'};
$C->{'sym'} = $sym;

$self->_MATCHIFYr($S, "category__S_554backslash", 
$C->_PATTERN(qr/\Gbackslash/)
);
}
#proto token backslash { <...> }
sub backslash__PEEK { $_[0]->_AUTOLEXpeek('backslash:*',$retree); }
sub backslash {
my $self = shift;
my $subs;

local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;

my $C = $self;
my $S = $C->{'_pos'};

my @result = eval {
my $trystate;
my ($tag, $try);
my @try;
my $relex;
if (my $fate = $C->{'_fate'}) {
if ($fate->[1] eq 'backslash') {
$C->deb("Fate passed to backslash: ", ::fatestr($fate)) if $::DEBUG & DEBUG::fates;
($C->{'_fate'}, $tag, $try) = @$fate;
@try = ($try);
}
}

my @gather = ();
for (;;) {
if (not @try) {
$relex //= $C->cursor_fate('STD::P5Regex', 'backslash:*', $retree);
@try = $relex->($C, $trystate);
}
last unless @try;
$try = shift(@try) // next;

if (ref $try eq 'ARRAY') {
($C->{'_fate'}, $tag, $try) = @$try;	# next candidate fate
}

$C->deb("backslash trying $tag $try") if $::DEBUG & DEBUG::try_processing;
push @gather, $C->$try(@_);
last if @gather;
}
$self->_MATCHIFY($S, "backslash", @gather);
};
if ($@) {
return () if $@ =~ /^ABORTRULE/;
die $@;
}
@result;
}


##     token category__S_555assertion (:$sym is context<rw> = 'assertion')
##          token category:assertion { <sym> }

sub category__S_555assertion__PEEK { $_[0]->_AUTOLEXpeek('category__S_555assertion',$retree) }
sub category__S_555assertion {
my $self = shift;
local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;
my %args = @_;
local $sym = $args{sym} // 'assertion';


my $C = $self;
my $S = $C->{'_pos'};
$C->{'sym'} = $sym;

$self->_MATCHIFYr($S, "category__S_555assertion", 
$C->_PATTERN(qr/\Gassertion/)
);
}
#proto token assertion { <...> }
sub assertion__PEEK { $_[0]->_AUTOLEXpeek('assertion:*',$retree); }
sub assertion {
my $self = shift;
my $subs;

local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;

my $C = $self;
my $S = $C->{'_pos'};

my @result = eval {
my $trystate;
my ($tag, $try);
my @try;
my $relex;
if (my $fate = $C->{'_fate'}) {
if ($fate->[1] eq 'assertion') {
$C->deb("Fate passed to assertion: ", ::fatestr($fate)) if $::DEBUG & DEBUG::fates;
($C->{'_fate'}, $tag, $try) = @$fate;
@try = ($try);
}
}

my @gather = ();
for (;;) {
if (not @try) {
$relex //= $C->cursor_fate('STD::P5Regex', 'assertion:*', $retree);
@try = $relex->($C, $trystate);
}
last unless @try;
$try = shift(@try) // next;

if (ref $try eq 'ARRAY') {
($C->{'_fate'}, $tag, $try) = @$try;	# next candidate fate
}

$C->deb("assertion trying $tag $try") if $::DEBUG & DEBUG::try_processing;
push @gather, $C->$try(@_);
last if @gather;
}
$self->_MATCHIFY($S, "assertion", @gather);
};
if ($@) {
return () if $@ =~ /^ABORTRULE/;
die $@;
}
@result;
}


##     token category__S_556quantifier (:$sym is context<rw> = 'quantifier')
##          token category:quantifier { <sym> }

sub category__S_556quantifier__PEEK { $_[0]->_AUTOLEXpeek('category__S_556quantifier',$retree) }
sub category__S_556quantifier {
my $self = shift;
local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;
my %args = @_;
local $sym = $args{sym} // 'quantifier';


my $C = $self;
my $S = $C->{'_pos'};
$C->{'sym'} = $sym;

$self->_MATCHIFYr($S, "category__S_556quantifier", 
$C->_PATTERN(qr/\Gquantifier/)
);
}
#proto token quantifier { <...> }
sub quantifier__PEEK { $_[0]->_AUTOLEXpeek('quantifier:*',$retree); }
sub quantifier {
my $self = shift;
my $subs;

local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;

my $C = $self;
my $S = $C->{'_pos'};

my @result = eval {
my $trystate;
my ($tag, $try);
my @try;
my $relex;
if (my $fate = $C->{'_fate'}) {
if ($fate->[1] eq 'quantifier') {
$C->deb("Fate passed to quantifier: ", ::fatestr($fate)) if $::DEBUG & DEBUG::fates;
($C->{'_fate'}, $tag, $try) = @$fate;
@try = ($try);
}
}

my @gather = ();
for (;;) {
if (not @try) {
$relex //= $C->cursor_fate('STD::P5Regex', 'quantifier:*', $retree);
@try = $relex->($C, $trystate);
}
last unless @try;
$try = shift(@try) // next;

if (ref $try eq 'ARRAY') {
($C->{'_fate'}, $tag, $try) = @$try;	# next candidate fate
}

$C->deb("quantifier trying $tag $try") if $::DEBUG & DEBUG::try_processing;
push @gather, $C->$try(@_);
last if @gather;
}
$self->_MATCHIFY($S, "quantifier", @gather);
};
if ($@) {
return () if $@ =~ /^ABORTRULE/;
die $@;
}
@result;
}


##     token category__S_557mod_internal (:$sym is context<rw> = 'mod_internal')
##          token category:mod_internal { <sym> }

sub category__S_557mod_internal__PEEK { $_[0]->_AUTOLEXpeek('category__S_557mod_internal',$retree) }
sub category__S_557mod_internal {
my $self = shift;
local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;
my %args = @_;
local $sym = $args{sym} // 'mod_internal';


my $C = $self;
my $S = $C->{'_pos'};
$C->{'sym'} = $sym;

$self->_MATCHIFYr($S, "category__S_557mod_internal", 
$C->_PATTERN(qr/\Gmod_internal/)
);
}
#proto token mod_internal { <...> }
sub mod_internal__PEEK { $_[0]->_AUTOLEXpeek('mod_internal:*',$retree); }
sub mod_internal {
my $self = shift;
my $subs;

local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;

my $C = $self;
my $S = $C->{'_pos'};

my @result = eval {
my $trystate;
my ($tag, $try);
my @try;
my $relex;
if (my $fate = $C->{'_fate'}) {
if ($fate->[1] eq 'mod_internal') {
$C->deb("Fate passed to mod_internal: ", ::fatestr($fate)) if $::DEBUG & DEBUG::fates;
($C->{'_fate'}, $tag, $try) = @$fate;
@try = ($try);
}
}

my @gather = ();
for (;;) {
if (not @try) {
$relex //= $C->cursor_fate('STD::P5Regex', 'mod_internal:*', $retree);
@try = $relex->($C, $trystate);
}
last unless @try;
$try = shift(@try) // next;

if (ref $try eq 'ARRAY') {
($C->{'_fate'}, $tag, $try) = @$try;	# next candidate fate
}

$C->deb("mod_internal trying $tag $try") if $::DEBUG & DEBUG::try_processing;
push @gather, $C->$try(@_);
last if @gather;
}
$self->_MATCHIFY($S, "mod_internal", @gather);
};
if ($@) {
return () if $@ =~ /^ABORTRULE/;
die $@;
}
@result;
}


#proto token regex_infix { <...> }
sub regex_infix__PEEK { $_[0]->_AUTOLEXpeek('regex_infix:*',$retree); }
sub regex_infix {
my $self = shift;
my $subs;

local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;

my $C = $self;
my $S = $C->{'_pos'};

my @result = eval {
my $trystate;
my ($tag, $try);
my @try;
my $relex;
if (my $fate = $C->{'_fate'}) {
if ($fate->[1] eq 'regex_infix') {
$C->deb("Fate passed to regex_infix: ", ::fatestr($fate)) if $::DEBUG & DEBUG::fates;
($C->{'_fate'}, $tag, $try) = @$fate;
@try = ($try);
}
}

my @gather = ();
for (;;) {
if (not @try) {
$relex //= $C->cursor_fate('STD::P5Regex', 'regex_infix:*', $retree);
@try = $relex->($C, $trystate);
}
last unless @try;
$try = shift(@try) // next;

if (ref $try eq 'ARRAY') {
($C->{'_fate'}, $tag, $try) = @$try;	# next candidate fate
}

$C->deb("regex_infix trying $tag $try") if $::DEBUG & DEBUG::try_processing;
push @gather, $C->$try(@_);
last if @gather;
}
$self->_MATCHIFY($S, "regex_infix", @gather);
};
if ($@) {
return () if $@ =~ /^ABORTRULE/;
die $@;
}
@result;
}


# suppress fancy end-of-line checking
##     token codeblock
##          token codeblock {
##              :my $GOAL is context = '}';
##              '{' :: [ :lang($¢.cursor_fresh(%*LANG<MAIN>)) <statementlist> ]
##              [ '}' || <.panic: "Unable to parse statement list; couldn't find right brace"> ]
##          }

sub codeblock__PEEK { $_[0]->_AUTOLEXpeek('codeblock',$retree) }
sub codeblock {
my $self = shift;
local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;
local $::GOAL = '}';


my $C = $self;
my $S = $C->{'_pos'};

$self->_MATCHIFY($S, "codeblock", 
Cursor::lazymap(sub { my $C=$_[0];
Cursor::lazymap(sub { my $C=$_[0];
Cursor::lazymap(sub { my $C=$_[0];
$C->_BRACKET( sub { my $C=shift;
do { my @gather;
eval { push @gather, $C->_EXACT('}')} // do {die $@ if $@ and $@ !~ /ABORT/;1} 
or
eval { push @gather, $C->panic("Unable to parse statement list; couldn't find right brace")} or do { die $@ if $@ };
@gather;
}
})
}, $C->_BRACKET( sub { my $C=shift;
my $newlang = ($C->cursor_fresh($::LANG{'MAIN'}));  $C = $C->cursor_fresh($newlang); ;$C->_SUBSUME(['statementlist'], sub {
my $C = shift;
$C->statementlist
})
}))
}, $C->_COMMITBRANCH())
}, $C->_EXACT('{'))
);
}

##     token ws
##          token ws {
##              <?{ $*sigspace }>
##              || [ <?before \s | '#'> <.nextsame> ]?   # still get all the pod goodness, hopefully
##          }

sub ws__PEEK { '' }
sub ws {
my $self = shift;
my @origargs = @_;
local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;


my $C = $self;
my $S = $C->{'_pos'};

$self->_MATCHIFYr($S, "ws", 
do { my @gather;
eval { push @gather, $C->before( sub { my $C=shift;
(($C) x !!do {
$::sigspace 
})
})} // do {die $@ if $@ and $@ !~ /ABORT/;1} 
or
eval { push @gather, $C->_OPTr(sub { my $C=shift;
$C->_BRACKETr( sub { my $C=shift;
do {
if (my ($C) = ($C->before(sub { my $C=shift;
do {
my @result = eval {
my $trystate;
my ($tag, $try);
my @try;
my $relex;

my $fate;
if ($fate = $C->{'_fate'} and $fate->[1] eq 'ws_03') {
$C->deb("Fate passed to ws_03: ", ::fatestr($fate)) if $::DEBUG & DEBUG::fates;
($C->{'_fate'}, $tag, $try) = @$fate;
@try = ($try);
}

my @gather = ();
for (;;) {
if (not @try) {
$relex //= $C->cursor_fate('STD::P5Regex', 'ws_03', $retree);
@try = $relex->($C, $trystate);
}
last unless @try;
$try = shift(@try) // next;

if (ref $try eq 'ARRAY') {
($C->{'_fate'}, $tag, $try) = @$try;	# next candidate fate
}

$C->deb("ws_03 trying $tag $try") if $::DEBUG & DEBUG::try_processing;
push @gather, ((
sub { my $C=shift;
$C->_PATTERN(qr/\G\s/)
},
sub { my $C=shift;
$C->_EXACT('#')
},
)[$try])->($C);
last if @gather;
}
@gather;
};
if (@result) {
@result;
}
elsif ($@) {
my ($first) = $@ =~ /(^.*)/;
$self->deb("CAUGHT $first") if $::DEBUG & DEBUG::trace_call;
die $@ if $@ !~ /^ABORTBRANCH/;
();
}
else {
();
}
}

}))) {
$self->SUPER::ws(@origargs);
}
else {
();
}
}
})
})} or do { die $@ if $@ };
@gather;
}
);
}

##     rule nibbler
##          rule nibbler {
##              :my $ignorecase is context<rw> = $*ignorecase // 0;
##              <EXPR>
##          }

sub nibbler__PEEK { $_[0]->_AUTOLEXpeek('nibbler',$retree) }
sub nibbler {
my $self = shift;
local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;
local $::ignorecase = $::ignorecase // 0;


my $C = $self;
my $S = $C->{'_pos'};

$self->_MATCHIFYr($S, "nibbler", 
do {
if (my ($C) = ($C->ws)) {
do {
if (my ($C) = ($C->_SUBSUMEr(['EXPR'], sub {
my $C = shift;
$C->EXPR
}))) {
$C->ws;
}
else {
();
}
};
}
else {
();
}
}
);
}

##     token termish
##          token termish {
##              <.ws>  # XXX assuming old /x here?
##              <noun=quantified_atom>+
##          }

sub termish__PEEK { $_[0]->_AUTOLEXpeek('termish',$retree) }
sub termish {
my $self = shift;
local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;


my $C = $self;
my $S = $C->{'_pos'};
$C->{'quantified_atom'} = [];

$self->_MATCHIFYr($S, "termish", 
do {
if (my ($C) = ($C->ws)) {
$C->_PLUSr(sub { my $C=shift;
$C->_SUBSUMEr(['noun','quantified_atom'], sub {
my $C = shift;
$C->quantified_atom
})
});
}
else {
();
}
}
);
}
##     token infixish
##          token infixish {
##              <!infixstopper>
##              <!stdstopper>
##              <regex_infix>
##              {
##                  $<O> = $<regex_infix><O>;
##                  $<sym> = $<regex_infix><sym>;
##              }
##          }

sub infixish__PEEK { $_[0]->_AUTOLEXpeek('infixish',$retree) }
sub infixish {
my $self = shift;
local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;


my $C = $self;
my $S = $C->{'_pos'};

$self->_MATCHIFYr($S, "infixish", 
do {
if (my ($C) = ($C->_NOTBEFORE( sub { my $C=shift;
$C->infixstopper
}))) {
do {
if (my ($C) = ($C->_NOTBEFORE( sub { my $C=shift;
$C->stdstopper
}))) {
do {
if (my ($C) = ($C->_SUBSUMEr(['regex_infix'], sub {
my $C = shift;
$C->regex_infix
}))) {
scalar(do {
my $M = $C; 
$M->{'O'} = $M->{'regex_infix'}{'O'};
$M->{'sym'} = $M->{'regex_infix'}{'sym'};
;
}, $C);
}
else {
();
}
};
}
else {
();
}
};
}
else {
();
}
}
);
}

##     token regex_infix__S_558Vert (  :$sym is context<rw> = <|> --> Junctive_or )
##          token regex_infix:sym<|> ( --> Junctive_or ) { <sym> }

sub regex_infix__S_558Vert__PEEK { $_[0]->_AUTOLEXpeek('regex_infix__S_558Vert',$retree) }
sub regex_infix__S_558Vert {
my $self = shift;
local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;
my %args = @_;
local $sym = $args{sym} // q(|);


my $C = $self;
my $S = $C->{'_pos'};
$C->{'sym'} = $sym;

$self->_MATCHIFYr($S, "regex_infix__S_558Vert",  map { STD::Junctive_or->coerce($_) } 
$C->_PATTERN(qr/\G\|/)
);
}

##     token quantified_atom
##          token quantified_atom {
##              <!stopper>
##              <!regex_infix>
##              <atom>
##              [ <.ws> <quantifier>
##      #            <?{ $<atom>.max_width }>
##      #                || <.panic: "Can't quantify zero-width atom">
##              ]?
##              <.ws>
##          }

sub quantified_atom__PEEK { $_[0]->_AUTOLEXpeek('quantified_atom',$retree) }
sub quantified_atom {
my $self = shift;
local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;


my $C = $self;
my $S = $C->{'_pos'};
$C->{'quantifier'} = [];

$self->_MATCHIFYr($S, "quantified_atom", 
do {
if (my ($C) = ($C->_NOTBEFORE( sub { my $C=shift;
$C->stopper
}))) {
do {
if (my ($C) = ($C->_NOTBEFORE( sub { my $C=shift;
$C->regex_infix
}))) {
do {
if (my ($C) = ($C->_SUBSUMEr(['atom'], sub {
my $C = shift;
$C->atom
}))) {
do {
if (my ($C) = ($C->_OPTr(sub { my $C=shift;
$C->_BRACKETr( sub { my $C=shift;
do {
if (my ($C) = ($C->ws)) {
$C->_SUBSUMEr(['quantifier'], sub {
my $C = shift;
$C->quantifier
});
}
else {
();
}
}
})
}))) {
$C->ws;
}
else {
();
}
};
}
else {
();
}
};
}
else {
();
}
};
}
else {
();
}
}
);
}

##     token atom
##          token atom {
##              [
##              | \w
##              | <metachar>
##              | '\\' :: .
##              ]
##          }

sub atom__PEEK { $_[0]->_AUTOLEXpeek('atom',$retree) }
sub atom {
my $self = shift;
local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;


my $C = $self;
my $S = $C->{'_pos'};

$self->_MATCHIFY($S, "atom", 
$C->_BRACKET( sub { my $C=shift;
do {
my @result = eval {
my $trystate;
my ($tag, $try);
my @try;
my $relex;

my $fate;
if ($fate = $C->{'_fate'} and $fate->[1] eq 'atom_01') {
$C->deb("Fate passed to atom_01: ", ::fatestr($fate)) if $::DEBUG & DEBUG::fates;
($C->{'_fate'}, $tag, $try) = @$fate;
@try = ($try);
}

my @gather = ();
for (;;) {
if (not @try) {
$relex //= $C->cursor_fate('STD::P5Regex', 'atom_01', $retree);
@try = $relex->($C, $trystate);
}
last unless @try;
$try = shift(@try) // next;

if (ref $try eq 'ARRAY') {
($C->{'_fate'}, $tag, $try) = @$try;	# next candidate fate
}

$C->deb("atom_01 trying $tag $try") if $::DEBUG & DEBUG::try_processing;
push @gather, ((
sub { my $C=shift;
$C->_PATTERN(qr/\G\w/)
},
sub { my $C=shift;
$C->_SUBSUMEr(['metachar'], sub {
my $C = shift;
$C->metachar
})
},
sub { my $C=shift;
Cursor::lazymap(sub { my $C=$_[0];
Cursor::lazymap(sub { my $C=$_[0];
$C->_PATTERN(qr/\G(?s:.)/)
}, $C->_COMMITBRANCH())
}, $C->_EXACT('\\'))
},
)[$try])->($C);
last if @gather;
}
@gather;
};
if (@result) {
@result;
}
elsif ($@) {
my ($first) = $@ =~ /(^.*)/;
$self->deb("CAUGHT $first") if $::DEBUG & DEBUG::trace_call;
die $@ if $@ !~ /^ABORTBRANCH/;
();
}
else {
();
}
}

})
);
}

# sequence stoppers
##     token metachar__S_559Vert (:$sym is context<rw> = <|>)
##          token metachar:sym<|>   { '|'  :: <fail> }

sub metachar__S_559Vert__PEEK { $_[0]->_AUTOLEXpeek('metachar__S_559Vert',$retree) }
sub metachar__S_559Vert {
my $self = shift;
local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;
my %args = @_;
local $sym = $args{sym} // q(|);


my $C = $self;
my $S = $C->{'_pos'};
$C->{'sym'} = $sym;

$self->_MATCHIFY($S, "metachar__S_559Vert", 
Cursor::lazymap(sub { my $C=$_[0];
Cursor::lazymap(sub { my $C=$_[0];
$C->_SUBSUME(['fail'], sub {
my $C = shift;
$C->fail
})
}, $C->_COMMITBRANCH())
}, $C->_EXACT('|'))
);
}
##     token metachar__S_560Thesis (:$sym is context<rw> = <)>)
##          token metachar:sym<)>   { ')'  :: <fail> }

sub metachar__S_560Thesis__PEEK { $_[0]->_AUTOLEXpeek('metachar__S_560Thesis',$retree) }
sub metachar__S_560Thesis {
my $self = shift;
local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;
my %args = @_;
local $sym = $args{sym} // q[)];


my $C = $self;
my $S = $C->{'_pos'};
$C->{'sym'} = $sym;

$self->_MATCHIFY($S, "metachar__S_560Thesis", 
Cursor::lazymap(sub { my $C=$_[0];
Cursor::lazymap(sub { my $C=$_[0];
$C->_SUBSUME(['fail'], sub {
my $C = shift;
$C->fail
})
}, $C->_COMMITBRANCH())
}, $C->_EXACT(')'))
);
}

##     token metachar__S_561quant (:$sym is context<rw> = 'quant')
##          token metachar:quant { <quantifier> <.panic: "quantifier quantifies nothing"> }

sub metachar__S_561quant__PEEK { $_[0]->_AUTOLEXpeek('metachar__S_561quant',$retree) }
sub metachar__S_561quant {
my $self = shift;
local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;
my %args = @_;
local $sym = $args{sym} // 'quant';


my $C = $self;
my $S = $C->{'_pos'};
$C->{'sym'} = $sym;

$self->_MATCHIFYr($S, "metachar__S_561quant", 
do {
if (my ($C) = ($C->_SUBSUMEr(['quantifier'], sub {
my $C = shift;
$C->quantifier
}))) {
$C->panic("quantifier quantifies nothing");
}
else {
();
}
}
);
}

# "normal" metachars

##     token metachar__S_562Bra_Ket (:$sym is context<rw> = <[ ]>)
##          token metachar:sym<[ ]> {
##              <before '['> <quibble($¢.cursor_fresh( %*LANG<Q> ).tweak(:q))> # XXX parse as q[] for now
##          }

sub metachar__S_562Bra_Ket__PEEK { $_[0]->_AUTOLEXpeek('metachar__S_562Bra_Ket',$retree) }
sub metachar__S_562Bra_Ket {
my $self = shift;
local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;
my %args = @_;
local $sym = $args{sym} // [qw([ ])];


my $C = $self;
my $S = $C->{'_pos'};
$C->{'sym'} = $sym;

$self->_MATCHIFYr($S, "metachar__S_562Bra_Ket", 
do {
if (my ($C) = ($C->_SUBSUMEr(['before'], sub {
my $C = shift;
$C->before(sub { my $C=shift;
$C->_EXACT('[')
})
}))) {
$C->_SUBSUMEr(['quibble'], sub {
my $C = shift;
$C->quibble($C->cursor_fresh( $::LANG{'Q'} )->tweak('q' => 1))
});
}
else {
();
}
}
);
}

##     token metachar__S_563ParenQuestion_Thesis (:$sym is context<rw> = «(? )»)
##          token metachar:sym«(? )» {
##              '(?' {} <assertion>
##              [ ')' || <.panic: "Perl 5 regex assertion not terminated by parenthesis"> ]
##          }

sub metachar__S_563ParenQuestion_Thesis__PEEK { $_[0]->_AUTOLEXpeek('metachar__S_563ParenQuestion_Thesis',$retree) }
sub metachar__S_563ParenQuestion_Thesis {
my $self = shift;
local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;
my %args = @_;
local $sym = $args{sym} //['(?',')'];


my $C = $self;
my $S = $C->{'_pos'};
$C->{'sym'} = $sym;

$self->_MATCHIFYr($S, "metachar__S_563ParenQuestion_Thesis", 
do {
if (my ($C) = ($C->_EXACT('(?'))) {
do {
if (my ($C) = (scalar(do {

}, $C))) {
do {
if (my ($C) = ($C->_SUBSUMEr(['assertion'], sub {
my $C = shift;
$C->assertion
}))) {
$C->_BRACKETr( sub { my $C=shift;
do { my @gather;
eval { push @gather, $C->_EXACT(')')} // do {die $@ if $@ and $@ !~ /ABORT/;1} 
or
eval { push @gather, $C->panic("Perl 5 regex assertion not terminated by parenthesis")} or do { die $@ if $@ };
@gather;
}
});
}
else {
();
}
};
}
else {
();
}
};
}
else {
();
}
}
);
}

##     token metachar__S_564Paren_Thesis (:$sym is context<rw> = <( )>)
##          token metachar:sym<( )> {
##              '(' {} [:lang(self.unbalanced(')')) <nibbler>]?
##              [ ')' || <.panic: "Unable to parse Perl 5 regex; couldn't find right parenthesis"> ]
##              { $/<sym> := <( )> }
##          }

sub metachar__S_564Paren_Thesis__PEEK { $_[0]->_AUTOLEXpeek('metachar__S_564Paren_Thesis',$retree) }
sub metachar__S_564Paren_Thesis {
my $self = shift;
local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;
my %args = @_;
local $sym = $args{sym} // [qw[( )]];


my $C = $self;
my $S = $C->{'_pos'};
$C->{'nibbler'} = [];
$C->{'sym'} = $sym;

$self->_MATCHIFYr($S, "metachar__S_564Paren_Thesis", 
do {
if (my ($C) = ($C->_EXACT('('))) {
do {
if (my ($C) = (scalar(do {

}, $C))) {
do {
if (my ($C) = ($C->_OPTr(sub { my $C=shift;
$C->_BRACKETr( sub { my $C=shift;
my $newlang = ($self->unbalanced(')'));  $C = $C->cursor_fresh($newlang); ;$C->_SUBSUMEr(['nibbler'], sub {
my $C = shift;
$C->nibbler
})
})
}))) {
do {
if (my ($C) = ($C->_BRACKETr( sub { my $C=shift;
do { my @gather;
eval { push @gather, $C->_EXACT(')')} // do {die $@ if $@ and $@ !~ /ABORT/;1} 
or
eval { push @gather, $C->panic("Unable to parse Perl 5 regex; couldn't find right parenthesis")} or do { die $@ if $@ };
@gather;
}
}))) {
scalar(do {
my $M = $C;  $M->{'sym'} = [qw[( )]] ;
}, $C);
}
else {
();
}
};
}
else {
();
}
};
}
else {
();
}
};
}
else {
();
}
}
);
}

##     token metachar__S_565Back (:$sym is context<rw> = <\\>)
##          token metachar:sym<\\> { <sym> <backslash> }

sub metachar__S_565Back__PEEK { $_[0]->_AUTOLEXpeek('metachar__S_565Back',$retree) }
sub metachar__S_565Back {
my $self = shift;
local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;
my %args = @_;
local $sym = $args{sym} // q(\\);


my $C = $self;
my $S = $C->{'_pos'};
$C->{'sym'} = $sym;

$self->_MATCHIFYr($S, "metachar__S_565Back", 
do {
if (my ($C) = ($C->_PATTERN(qr/\G\\/))) {
$C->_SUBSUMEr(['backslash'], sub {
my $C = shift;
$C->backslash
});
}
else {
();
}
}
);
}
##     token metachar__S_566Dot (:$sym is context<rw> = <.>)
##          token metachar:sym<.>  { <sym> }

sub metachar__S_566Dot__PEEK { $_[0]->_AUTOLEXpeek('metachar__S_566Dot',$retree) }
sub metachar__S_566Dot {
my $self = shift;
local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;
my %args = @_;
local $sym = $args{sym} // q(.);


my $C = $self;
my $S = $C->{'_pos'};
$C->{'sym'} = $sym;

$self->_MATCHIFYr($S, "metachar__S_566Dot", 
$C->_PATTERN(qr/\G\./)
);
}
##     token metachar__S_567Caret (:$sym is context<rw> = <^>)
##          token metachar:sym<^>  { <sym> }

sub metachar__S_567Caret__PEEK { $_[0]->_AUTOLEXpeek('metachar__S_567Caret',$retree) }
sub metachar__S_567Caret {
my $self = shift;
local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;
my %args = @_;
local $sym = $args{sym} // q(^);


my $C = $self;
my $S = $C->{'_pos'};
$C->{'sym'} = $sym;

$self->_MATCHIFYr($S, "metachar__S_567Caret", 
$C->_PATTERN(qr/\G\^/)
);
}
##     token metachar__S_568Dollar (:$sym is context<rw> = <$>)
##          token metachar:sym<$>  {
##              '$' <?before \W | $>
##          }

sub metachar__S_568Dollar__PEEK { $_[0]->_AUTOLEXpeek('metachar__S_568Dollar',$retree) }
sub metachar__S_568Dollar {
my $self = shift;
local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;
my %args = @_;
local $sym = $args{sym} // q($);


my $C = $self;
my $S = $C->{'_pos'};
$C->{'sym'} = $sym;

$self->_MATCHIFYr($S, "metachar__S_568Dollar", 
do {
if (my ($C) = ($C->_EXACT('$'))) {
$C->before(sub { my $C=shift;
do {
my @result = eval {
my $trystate;
my ($tag, $try);
my @try;
my $relex;

my $fate;
if ($fate = $C->{'_fate'} and $fate->[1] eq 'metachar__S_568Dollar_01') {
$C->deb("Fate passed to metachar__S_568Dollar_01: ", ::fatestr($fate)) if $::DEBUG & DEBUG::fates;
($C->{'_fate'}, $tag, $try) = @$fate;
@try = ($try);
}

my @gather = ();
for (;;) {
if (not @try) {
$relex //= $C->cursor_fate('STD::P5Regex', 'metachar__S_568Dollar_01', $retree);
@try = $relex->($C, $trystate);
}
last unless @try;
$try = shift(@try) // next;

if (ref $try eq 'ARRAY') {
($C->{'_fate'}, $tag, $try) = @$try;	# next candidate fate
}

$C->deb("metachar__S_568Dollar_01 trying $tag $try") if $::DEBUG & DEBUG::try_processing;
push @gather, ((
sub { my $C=shift;
$C->_NOTCHAR( sub { my $C=shift;
$C->_PATTERN(qr/\G\w/)
})
},
sub { my $C=shift;
$C->_PATTERN(qr/\G\z/)
},
)[$try])->($C);
last if @gather;
}
@gather;
};
if (@result) {
@result;
}
elsif ($@) {
my ($first) = $@ =~ /(^.*)/;
$self->deb("CAUGHT $first") if $::DEBUG & DEBUG::trace_call;
die $@ if $@ !~ /^ABORTBRANCH/;
();
}
else {
();
}
}

});
}
else {
();
}
}
);
}

##     token metachar__S_569var (:$sym is context<rw> = 'var')
##          token metachar:var {
##              <?before <sigil>\w>
##              <.panic: "Can't interpolate variable in Perl 5 regex">
##          }

sub metachar__S_569var__PEEK { $_[0]->_AUTOLEXpeek('metachar__S_569var',$retree) }
sub metachar__S_569var {
my $self = shift;
local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;
my %args = @_;
local $sym = $args{sym} // 'var';


my $C = $self;
my $S = $C->{'_pos'};
$C->{'sym'} = $sym;

$self->_MATCHIFYr($S, "metachar__S_569var", 
do {
if (my ($C) = ($C->before(sub { my $C=shift;
do {
if (my ($C) = ($C->_SUBSUMEr(['sigil'], sub {
my $C = shift;
$C->sigil
}))) {
$C->_PATTERN(qr/\G\w/);
}
else {
();
}
}
}))) {
$C->panic("Can't interpolate variable in Perl 5 regex");
}
else {
();
}
}
);
}

##     token backslash__S_570A (:$sym is context<rw> = 'A')
##          token backslash:A { <sym> }

sub backslash__S_570A__PEEK { $_[0]->_AUTOLEXpeek('backslash__S_570A',$retree) }
sub backslash__S_570A {
my $self = shift;
local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;
my %args = @_;
local $sym = $args{sym} // 'A';


my $C = $self;
my $S = $C->{'_pos'};
$C->{'sym'} = $sym;

$self->_MATCHIFYr($S, "backslash__S_570A", 
$C->_PATTERN(qr/\GA/)
);
}
##     token backslash__S_571a (:$sym is context<rw> = 'a')
##          token backslash:a { <sym> }

sub backslash__S_571a__PEEK { $_[0]->_AUTOLEXpeek('backslash__S_571a',$retree) }
sub backslash__S_571a {
my $self = shift;
local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;
my %args = @_;
local $sym = $args{sym} // 'a';


my $C = $self;
my $S = $C->{'_pos'};
$C->{'sym'} = $sym;

$self->_MATCHIFYr($S, "backslash__S_571a", 
$C->_PATTERN(qr/\Ga/)
);
}
##     token backslash__S_572b (:$sym is context<rw> = 'b')
##          token backslash:b { :i <sym> }

sub backslash__S_572b__PEEK { $_[0]->_AUTOLEXpeek('backslash__S_572b',$retree) }
sub backslash__S_572b {
my $self = shift;
local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;
my %args = @_;
local $sym = $args{sym} // 'b';


my $C = $self;
my $S = $C->{'_pos'};
$C->{'sym'} = $sym;

$self->_MATCHIFYr($S, "backslash__S_572b", 
$C->_PATTERN(qr/\G(?i:b)/)
);
}
##     token backslash__S_573c (:$sym is context<rw> = 'c')
##          token backslash:c { :i <sym>
##              <[ ?.._ ]> || <.panic: "Unrecognized \\c character">
##          }

sub backslash__S_573c__PEEK { $_[0]->_AUTOLEXpeek('backslash__S_573c',$retree) }
sub backslash__S_573c {
my $self = shift;
local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;
my %args = @_;
local $sym = $args{sym} // 'c';


my $C = $self;
my $S = $C->{'_pos'};
$C->{'sym'} = $sym;

$self->_MATCHIFYr($S, "backslash__S_573c", 
do { my @gather;
eval { push @gather, $C->_PATTERN(qr/\G(?i:c)(?i:[?-_])/)} // do {die $@ if $@ and $@ !~ /ABORT/;1} 
or
eval { push @gather, $C->panic("Unrecognized \\c character")} or do { die $@ if $@ };
@gather;
}
);
}
##     token backslash__S_574d (:$sym is context<rw> = 'd')
##          token backslash:d { :i <sym> }

sub backslash__S_574d__PEEK { $_[0]->_AUTOLEXpeek('backslash__S_574d',$retree) }
sub backslash__S_574d {
my $self = shift;
local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;
my %args = @_;
local $sym = $args{sym} // 'd';


my $C = $self;
my $S = $C->{'_pos'};
$C->{'sym'} = $sym;

$self->_MATCHIFYr($S, "backslash__S_574d", 
$C->_PATTERN(qr/\G(?i:d)/)
);
}
##     token backslash__S_575e (:$sym is context<rw> = 'e')
##          token backslash:e { :i <sym> }

sub backslash__S_575e__PEEK { $_[0]->_AUTOLEXpeek('backslash__S_575e',$retree) }
sub backslash__S_575e {
my $self = shift;
local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;
my %args = @_;
local $sym = $args{sym} // 'e';


my $C = $self;
my $S = $C->{'_pos'};
$C->{'sym'} = $sym;

$self->_MATCHIFYr($S, "backslash__S_575e", 
$C->_PATTERN(qr/\G(?i:e)/)
);
}
##     token backslash__S_576f (:$sym is context<rw> = 'f')
##          token backslash:f { :i <sym> }

sub backslash__S_576f__PEEK { $_[0]->_AUTOLEXpeek('backslash__S_576f',$retree) }
sub backslash__S_576f {
my $self = shift;
local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;
my %args = @_;
local $sym = $args{sym} // 'f';


my $C = $self;
my $S = $C->{'_pos'};
$C->{'sym'} = $sym;

$self->_MATCHIFYr($S, "backslash__S_576f", 
$C->_PATTERN(qr/\G(?i:f)/)
);
}
##     token backslash__S_577h (:$sym is context<rw> = 'h')
##          token backslash:h { :i <sym> }

sub backslash__S_577h__PEEK { $_[0]->_AUTOLEXpeek('backslash__S_577h',$retree) }
sub backslash__S_577h {
my $self = shift;
local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;
my %args = @_;
local $sym = $args{sym} // 'h';


my $C = $self;
my $S = $C->{'_pos'};
$C->{'sym'} = $sym;

$self->_MATCHIFYr($S, "backslash__S_577h", 
$C->_PATTERN(qr/\G(?i:h)/)
);
}
##     token backslash__S_578l (:$sym is context<rw> = 'l')
##          token backslash:l { :i <sym> }

sub backslash__S_578l__PEEK { $_[0]->_AUTOLEXpeek('backslash__S_578l',$retree) }
sub backslash__S_578l {
my $self = shift;
local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;
my %args = @_;
local $sym = $args{sym} // 'l';


my $C = $self;
my $S = $C->{'_pos'};
$C->{'sym'} = $sym;

$self->_MATCHIFYr($S, "backslash__S_578l", 
$C->_PATTERN(qr/\G(?i:l)/)
);
}
##     token backslash__S_579n (:$sym is context<rw> = 'n')
##          token backslash:n { :i <sym> }

sub backslash__S_579n__PEEK { $_[0]->_AUTOLEXpeek('backslash__S_579n',$retree) }
sub backslash__S_579n {
my $self = shift;
local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;
my %args = @_;
local $sym = $args{sym} // 'n';


my $C = $self;
my $S = $C->{'_pos'};
$C->{'sym'} = $sym;

$self->_MATCHIFYr($S, "backslash__S_579n", 
$C->_PATTERN(qr/\G(?i:n)/)
);
}
##     token backslash__S_580o (:$sym is context<rw> = 'o')
##          token backslash:o { :dba('octal character') '0' [ <octint> | '{' ~ '}' <octints> ] }

sub backslash__S_580o__PEEK { $_[0]->_AUTOLEXpeek('backslash__S_580o',$retree) }
sub backslash__S_580o {
my $self = shift;
local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;
my %args = @_;
local $sym = $args{sym} // 'o';


my $C = $self;
my $S = $C->{'_pos'};
$C->{'sym'} = $sym;

$self->_MATCHIFY($S, "backslash__S_580o", 
Cursor::lazymap(sub { my $C=$_[0];
$C->_BRACKET( sub { my $C=shift;
do {
my @result = eval {
my $trystate;
my ($tag, $try);
my @try;
my $relex;

my $fate;
if ($fate = $C->{'_fate'} and $fate->[1] eq 'backslash__S_580o_01') {
$C->deb("Fate passed to backslash__S_580o_01: ", ::fatestr($fate)) if $::DEBUG & DEBUG::fates;
($C->{'_fate'}, $tag, $try) = @$fate;
@try = ($try);
}

my @gather = ();
for (;;) {
if (not @try) {
$relex //= $C->cursor_fate('STD::P5Regex', 'backslash__S_580o_01', $retree);
@try = $relex->($C, $trystate);
}
last unless @try;
$try = shift(@try) // next;

if (ref $try eq 'ARRAY') {
($C->{'_fate'}, $tag, $try) = @$try;	# next candidate fate
}

$C->deb("backslash__S_580o_01 trying $tag $try") if $::DEBUG & DEBUG::try_processing;
push @gather, ((
sub { my $C=shift;
$C->_SUBSUMEr(['octint'], sub {
my $C = shift;
$C->octint
})
},
sub { my $C=shift;
Cursor::lazymap(sub { my $C=$_[0];
Cursor::lazymap(sub { my $C=$_[0];
Cursor::lazymap(sub { my $C=$_[0];
$C->_BRACKET( sub { my $C=shift;
do { my @gather;
eval { push @gather, $C->_EXACT('}')} // do {die $@ if $@ and $@ !~ /ABORT/;1} 
or
eval { push @gather, $C->FAILGOAL('}' , 'octal character')} or do { die $@ if $@ };
@gather;
}
})
}, $C->_SUBSUME(['octints'], sub {
my $C = shift;
$C->octints
}))
}, $C->_COMMITBRANCH(local $::GOAL = '}' ))
}, $C->_EXACT('{'))
},
)[$try])->($C);
last if @gather;
}
@gather;
};
if (@result) {
@result;
}
elsif ($@) {
my ($first) = $@ =~ /(^.*)/;
$self->deb("CAUGHT $first") if $::DEBUG & DEBUG::trace_call;
die $@ if $@ !~ /^ABORTBRANCH/;
();
}
else {
();
}
}

})
}, $C->_EXACT('0'))
);
}
##     token backslash__S_581p (:$sym is context<rw> = 'p')
##          token backslash:p { :i <sym> '{' <[\w:]>+ '}' }

sub backslash__S_581p__PEEK { $_[0]->_AUTOLEXpeek('backslash__S_581p',$retree) }
sub backslash__S_581p {
my $self = shift;
local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;
my %args = @_;
local $sym = $args{sym} // 'p';


my $C = $self;
my $S = $C->{'_pos'};
$C->{'sym'} = $sym;

$self->_MATCHIFYr($S, "backslash__S_581p", 
$C->_PATTERN(qr/\G(?i:p)(?i:\{)((?:(?i:[\w:]))++)(?i:\})/)
);
}
##     token backslash__S_582Q (:$sym is context<rw> = 'Q')
##          token backslash:Q { <sym> }

sub backslash__S_582Q__PEEK { $_[0]->_AUTOLEXpeek('backslash__S_582Q',$retree) }
sub backslash__S_582Q {
my $self = shift;
local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;
my %args = @_;
local $sym = $args{sym} // 'Q';


my $C = $self;
my $S = $C->{'_pos'};
$C->{'sym'} = $sym;

$self->_MATCHIFYr($S, "backslash__S_582Q", 
$C->_PATTERN(qr/\GQ/)
);
}
##     token backslash__S_583r (:$sym is context<rw> = 'r')
##          token backslash:r { :i <sym> }

sub backslash__S_583r__PEEK { $_[0]->_AUTOLEXpeek('backslash__S_583r',$retree) }
sub backslash__S_583r {
my $self = shift;
local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;
my %args = @_;
local $sym = $args{sym} // 'r';


my $C = $self;
my $S = $C->{'_pos'};
$C->{'sym'} = $sym;

$self->_MATCHIFYr($S, "backslash__S_583r", 
$C->_PATTERN(qr/\G(?i:r)/)
);
}
##     token backslash__S_584s (:$sym is context<rw> = 's')
##          token backslash:s { :i <sym> }

sub backslash__S_584s__PEEK { $_[0]->_AUTOLEXpeek('backslash__S_584s',$retree) }
sub backslash__S_584s {
my $self = shift;
local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;
my %args = @_;
local $sym = $args{sym} // 's';


my $C = $self;
my $S = $C->{'_pos'};
$C->{'sym'} = $sym;

$self->_MATCHIFYr($S, "backslash__S_584s", 
$C->_PATTERN(qr/\G(?i:s)/)
);
}
##     token backslash__S_585t (:$sym is context<rw> = 't')
##          token backslash:t { :i <sym> }

sub backslash__S_585t__PEEK { $_[0]->_AUTOLEXpeek('backslash__S_585t',$retree) }
sub backslash__S_585t {
my $self = shift;
local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;
my %args = @_;
local $sym = $args{sym} // 't';


my $C = $self;
my $S = $C->{'_pos'};
$C->{'sym'} = $sym;

$self->_MATCHIFYr($S, "backslash__S_585t", 
$C->_PATTERN(qr/\G(?i:t)/)
);
}
##     token backslash__S_586u (:$sym is context<rw> = 'u')
##          token backslash:u { :i <sym> }

sub backslash__S_586u__PEEK { $_[0]->_AUTOLEXpeek('backslash__S_586u',$retree) }
sub backslash__S_586u {
my $self = shift;
local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;
my %args = @_;
local $sym = $args{sym} // 'u';


my $C = $self;
my $S = $C->{'_pos'};
$C->{'sym'} = $sym;

$self->_MATCHIFYr($S, "backslash__S_586u", 
$C->_PATTERN(qr/\G(?i:u)/)
);
}
##     token backslash__S_587v (:$sym is context<rw> = 'v')
##          token backslash:v { :i <sym> }

sub backslash__S_587v__PEEK { $_[0]->_AUTOLEXpeek('backslash__S_587v',$retree) }
sub backslash__S_587v {
my $self = shift;
local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;
my %args = @_;
local $sym = $args{sym} // 'v';


my $C = $self;
my $S = $C->{'_pos'};
$C->{'sym'} = $sym;

$self->_MATCHIFYr($S, "backslash__S_587v", 
$C->_PATTERN(qr/\G(?i:v)/)
);
}
##     token backslash__S_588w (:$sym is context<rw> = 'w')
##          token backslash:w { :i <sym> }

sub backslash__S_588w__PEEK { $_[0]->_AUTOLEXpeek('backslash__S_588w',$retree) }
sub backslash__S_588w {
my $self = shift;
local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;
my %args = @_;
local $sym = $args{sym} // 'w';


my $C = $self;
my $S = $C->{'_pos'};
$C->{'sym'} = $sym;

$self->_MATCHIFYr($S, "backslash__S_588w", 
$C->_PATTERN(qr/\G(?i:w)/)
);
}
##     token backslash__S_589x (:$sym is context<rw> = 'x')
##          token backslash:x { :i :dba('hex character') <sym> [ <hexint> | '{' ~ '}' <hexints> ] }

sub backslash__S_589x__PEEK { $_[0]->_AUTOLEXpeek('backslash__S_589x',$retree) }
sub backslash__S_589x {
my $self = shift;
local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;
my %args = @_;
local $sym = $args{sym} // 'x';


my $C = $self;
my $S = $C->{'_pos'};
$C->{'sym'} = $sym;

$self->_MATCHIFY($S, "backslash__S_589x", 
Cursor::lazymap(sub { my $C=$_[0];
$C->_BRACKET( sub { my $C=shift;
do {
my @result = eval {
my $trystate;
my ($tag, $try);
my @try;
my $relex;

my $fate;
if ($fate = $C->{'_fate'} and $fate->[1] eq 'backslash__S_589x_01') {
$C->deb("Fate passed to backslash__S_589x_01: ", ::fatestr($fate)) if $::DEBUG & DEBUG::fates;
($C->{'_fate'}, $tag, $try) = @$fate;
@try = ($try);
}

my @gather = ();
for (;;) {
if (not @try) {
$relex //= $C->cursor_fate('STD::P5Regex', 'backslash__S_589x_01', $retree);
@try = $relex->($C, $trystate);
}
last unless @try;
$try = shift(@try) // next;

if (ref $try eq 'ARRAY') {
($C->{'_fate'}, $tag, $try) = @$try;	# next candidate fate
}

$C->deb("backslash__S_589x_01 trying $tag $try") if $::DEBUG & DEBUG::try_processing;
push @gather, ((
sub { my $C=shift;
$C->_SUBSUMEr(['hexint'], sub {
my $C = shift;
$C->hexint
})
},
sub { my $C=shift;
Cursor::lazymap(sub { my $C=$_[0];
Cursor::lazymap(sub { my $C=$_[0];
Cursor::lazymap(sub { my $C=$_[0];
$C->_BRACKET( sub { my $C=shift;
do { my @gather;
eval { push @gather, $C->_PATTERN(qr/\G(?i:\})/)} // do {die $@ if $@ and $@ !~ /ABORT/;1} 
or
eval { push @gather, $C->FAILGOAL('}' , 'hex character')} or do { die $@ if $@ };
@gather;
}
})
}, $C->_SUBSUME(['hexints'], sub {
my $C = shift;
$C->hexints
}))
}, $C->_COMMITBRANCH(local $::GOAL = '}' ))
}, $C->_PATTERN(qr/\G(?i:\{)/))
},
)[$try])->($C);
last if @gather;
}
@gather;
};
if (@result) {
@result;
}
elsif ($@) {
my ($first) = $@ =~ /(^.*)/;
$self->deb("CAUGHT $first") if $::DEBUG & DEBUG::trace_call;
die $@ if $@ !~ /^ABORTBRANCH/;
();
}
else {
();
}
}

})
}, $C->_PATTERN(qr/\G(?i:x)/))
);
}
##     token backslash__S_590z (:$sym is context<rw> = 'z')
##          token backslash:z { :i <sym> }

sub backslash__S_590z__PEEK { $_[0]->_AUTOLEXpeek('backslash__S_590z',$retree) }
sub backslash__S_590z {
my $self = shift;
local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;
my %args = @_;
local $sym = $args{sym} // 'z';


my $C = $self;
my $S = $C->{'_pos'};
$C->{'sym'} = $sym;

$self->_MATCHIFYr($S, "backslash__S_590z", 
$C->_PATTERN(qr/\G(?i:z)/)
);
}
##     token backslash__S_591misc (:$sym is context<rw> = 'misc')
##          token backslash:misc { $<litchar>=(\W) | $<number>=(\d+) }

sub backslash__S_591misc__PEEK { $_[0]->_AUTOLEXpeek('backslash__S_591misc',$retree) }
sub backslash__S_591misc {
my $self = shift;
local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;
my %args = @_;
local $sym = $args{sym} // 'misc';


my $C = $self;
my $S = $C->{'_pos'};
$C->{'sym'} = $sym;

$self->_MATCHIFYr($S, "backslash__S_591misc", 
do {
my @result = eval {
my $trystate;
my ($tag, $try);
my @try;
my $relex;

my $fate;
if ($fate = $C->{'_fate'} and $fate->[1] eq 'backslash__S_591misc_00') {
$C->deb("Fate passed to backslash__S_591misc_00: ", ::fatestr($fate)) if $::DEBUG & DEBUG::fates;
($C->{'_fate'}, $tag, $try) = @$fate;
@try = ($try);
}

my @gather = ();
for (;;) {
if (not @try) {
$relex //= $C->cursor_fate('STD::P5Regex', 'backslash__S_591misc_00', $retree);
@try = $relex->($C, $trystate);
}
last unless @try;
$try = shift(@try) // next;

if (ref $try eq 'ARRAY') {
($C->{'_fate'}, $tag, $try) = @$try;	# next candidate fate
}

$C->deb("backslash__S_591misc_00 trying $tag $try") if $::DEBUG & DEBUG::try_processing;
push @gather, ((
sub { my $C=shift;
$C->_SUBSUMEr(['litchar'], sub {
my $C = shift;
do { $C->_PAREN( sub { my $C=shift;
$C->_NOTCHAR( sub { my $C=shift;
$C->_PATTERN(qr/\G\w/)
})
})}
})
},
sub { my $C=shift;
$C->_SUBSUMEr(['number'], sub {
my $C = shift;
do { $C->_PAREN( sub { my $C=shift;
$C->_PATTERN(qr/\G((?:\d)++)/)
})}
})
},
)[$try])->($C);
last if @gather;
}
@gather;
};
if (@result) {
@result;
}
elsif ($@) {
my ($first) = $@ =~ /(^.*)/;
$self->deb("CAUGHT $first") if $::DEBUG & DEBUG::trace_call;
die $@ if $@ !~ /^ABORTBRANCH/;
();
}
else {
();
}
}

);
}
##     token backslash__S_592oops (:$sym is context<rw> = 'oops')
##          token backslash:oops { <.panic: "Unrecognized Perl 5 regex backslash sequence"> }

sub backslash__S_592oops__PEEK { $_[0]->_AUTOLEXpeek('backslash__S_592oops',$retree) }
sub backslash__S_592oops {
my $self = shift;
local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;
my %args = @_;
local $sym = $args{sym} // 'oops';


my $C = $self;
my $S = $C->{'_pos'};
$C->{'sym'} = $sym;

$self->_MATCHIFYr($S, "backslash__S_592oops", 
$C->panic("Unrecognized Perl 5 regex backslash sequence")
);
}

##     token assertion__S_593Question (:$sym is context<rw> = <?>)
##          token assertion:sym<?> { <sym> <codeblock> }

sub assertion__S_593Question__PEEK { $_[0]->_AUTOLEXpeek('assertion__S_593Question',$retree) }
sub assertion__S_593Question {
my $self = shift;
local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;
my %args = @_;
local $sym = $args{sym} // q(?);


my $C = $self;
my $S = $C->{'_pos'};
$C->{'sym'} = $sym;

$self->_MATCHIFYr($S, "assertion__S_593Question", 
do {
if (my ($C) = ($C->_PATTERN(qr/\G\?/))) {
$C->_SUBSUMEr(['codeblock'], sub {
my $C = shift;
$C->codeblock
});
}
else {
();
}
}
);
}
##     token assertion__S_594Cur_Ly (:$sym is context<rw> = <{ }>)
##          token assertion:sym<{ }> { <codeblock> }

sub assertion__S_594Cur_Ly__PEEK { $_[0]->_AUTOLEXpeek('assertion__S_594Cur_Ly',$retree) }
sub assertion__S_594Cur_Ly {
my $self = shift;
local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;
my %args = @_;
local $sym = $args{sym} // [qw({ })];


my $C = $self;
my $S = $C->{'_pos'};
$C->{'sym'} = $sym;

$self->_MATCHIFYr($S, "assertion__S_594Cur_Ly", 
$C->_SUBSUMEr(['codeblock'], sub {
my $C = shift;
$C->codeblock
})
);
}

##     token assertion__S_595Lt (:$sym is context<rw> = «<»)
##          token assertion:sym«<» { <sym> <?before '=' | '!'> <assertion> }

sub assertion__S_595Lt__PEEK { $_[0]->_AUTOLEXpeek('assertion__S_595Lt',$retree) }
sub assertion__S_595Lt {
my $self = shift;
local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;
my %args = @_;
local $sym = $args{sym} //['<'];


my $C = $self;
my $S = $C->{'_pos'};
$C->{'sym'} = $sym;

$self->_MATCHIFYr($S, "assertion__S_595Lt", 
do {
if (my ($C) = ($C->_PATTERN(qr/\G\</))) {
do {
if (my ($C) = ($C->before(sub { my $C=shift;
do {
my @result = eval {
my $trystate;
my ($tag, $try);
my @try;
my $relex;

my $fate;
if ($fate = $C->{'_fate'} and $fate->[1] eq 'assertion__S_595Lt_01') {
$C->deb("Fate passed to assertion__S_595Lt_01: ", ::fatestr($fate)) if $::DEBUG & DEBUG::fates;
($C->{'_fate'}, $tag, $try) = @$fate;
@try = ($try);
}

my @gather = ();
for (;;) {
if (not @try) {
$relex //= $C->cursor_fate('STD::P5Regex', 'assertion__S_595Lt_01', $retree);
@try = $relex->($C, $trystate);
}
last unless @try;
$try = shift(@try) // next;

if (ref $try eq 'ARRAY') {
($C->{'_fate'}, $tag, $try) = @$try;	# next candidate fate
}

$C->deb("assertion__S_595Lt_01 trying $tag $try") if $::DEBUG & DEBUG::try_processing;
push @gather, ((
sub { my $C=shift;
$C->_EXACT('=')
},
sub { my $C=shift;
$C->_EXACT('!')
},
)[$try])->($C);
last if @gather;
}
@gather;
};
if (@result) {
@result;
}
elsif ($@) {
my ($first) = $@ =~ /(^.*)/;
$self->deb("CAUGHT $first") if $::DEBUG & DEBUG::trace_call;
die $@ if $@ !~ /^ABORTBRANCH/;
();
}
else {
();
}
}

}))) {
$C->_SUBSUMEr(['assertion'], sub {
my $C = shift;
$C->assertion
});
}
else {
();
}
};
}
else {
();
}
}
);
}
##     token assertion__S_596Equal (:$sym is context<rw> = <=>)
##          token assertion:sym<=> { <sym> [ <?before ')'> | <rx> ] }

sub assertion__S_596Equal__PEEK { $_[0]->_AUTOLEXpeek('assertion__S_596Equal',$retree) }
sub assertion__S_596Equal {
my $self = shift;
local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;
my %args = @_;
local $sym = $args{sym} // q(=);


my $C = $self;
my $S = $C->{'_pos'};
$C->{'sym'} = $sym;

$self->_MATCHIFYr($S, "assertion__S_596Equal", 
do {
if (my ($C) = ($C->_PATTERN(qr/\G\=/))) {
$C->_BRACKETr( sub { my $C=shift;
do {
my @result = eval {
my $trystate;
my ($tag, $try);
my @try;
my $relex;

my $fate;
if ($fate = $C->{'_fate'} and $fate->[1] eq 'assertion__S_596Equal_01') {
$C->deb("Fate passed to assertion__S_596Equal_01: ", ::fatestr($fate)) if $::DEBUG & DEBUG::fates;
($C->{'_fate'}, $tag, $try) = @$fate;
@try = ($try);
}

my @gather = ();
for (;;) {
if (not @try) {
$relex //= $C->cursor_fate('STD::P5Regex', 'assertion__S_596Equal_01', $retree);
@try = $relex->($C, $trystate);
}
last unless @try;
$try = shift(@try) // next;

if (ref $try eq 'ARRAY') {
($C->{'_fate'}, $tag, $try) = @$try;	# next candidate fate
}

$C->deb("assertion__S_596Equal_01 trying $tag $try") if $::DEBUG & DEBUG::try_processing;
push @gather, ((
sub { my $C=shift;
$C->before(sub { my $C=shift;
$C->_EXACT(')')
})
},
sub { my $C=shift;
$C->_SUBSUMEr(['rx'], sub {
my $C = shift;
$C->rx
})
},
)[$try])->($C);
last if @gather;
}
@gather;
};
if (@result) {
@result;
}
elsif ($@) {
my ($first) = $@ =~ /(^.*)/;
$self->deb("CAUGHT $first") if $::DEBUG & DEBUG::trace_call;
die $@ if $@ !~ /^ABORTBRANCH/;
();
}
else {
();
}
}

});
}
else {
();
}
}
);
}
##     token assertion__S_597Bang (:$sym is context<rw> = <!>)
##          token assertion:sym<!> { <sym> [ <?before ')'> | <rx> ] }

sub assertion__S_597Bang__PEEK { $_[0]->_AUTOLEXpeek('assertion__S_597Bang',$retree) }
sub assertion__S_597Bang {
my $self = shift;
local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;
my %args = @_;
local $sym = $args{sym} // q(!);


my $C = $self;
my $S = $C->{'_pos'};
$C->{'sym'} = $sym;

$self->_MATCHIFYr($S, "assertion__S_597Bang", 
do {
if (my ($C) = ($C->_PATTERN(qr/\G\!/))) {
$C->_BRACKETr( sub { my $C=shift;
do {
my @result = eval {
my $trystate;
my ($tag, $try);
my @try;
my $relex;

my $fate;
if ($fate = $C->{'_fate'} and $fate->[1] eq 'assertion__S_597Bang_01') {
$C->deb("Fate passed to assertion__S_597Bang_01: ", ::fatestr($fate)) if $::DEBUG & DEBUG::fates;
($C->{'_fate'}, $tag, $try) = @$fate;
@try = ($try);
}

my @gather = ();
for (;;) {
if (not @try) {
$relex //= $C->cursor_fate('STD::P5Regex', 'assertion__S_597Bang_01', $retree);
@try = $relex->($C, $trystate);
}
last unless @try;
$try = shift(@try) // next;

if (ref $try eq 'ARRAY') {
($C->{'_fate'}, $tag, $try) = @$try;	# next candidate fate
}

$C->deb("assertion__S_597Bang_01 trying $tag $try") if $::DEBUG & DEBUG::try_processing;
push @gather, ((
sub { my $C=shift;
$C->before(sub { my $C=shift;
$C->_EXACT(')')
})
},
sub { my $C=shift;
$C->_SUBSUMEr(['rx'], sub {
my $C = shift;
$C->rx
})
},
)[$try])->($C);
last if @gather;
}
@gather;
};
if (@result) {
@result;
}
elsif ($@) {
my ($first) = $@ =~ /(^.*)/;
$self->deb("CAUGHT $first") if $::DEBUG & DEBUG::trace_call;
die $@ if $@ !~ /^ABORTBRANCH/;
();
}
else {
();
}
}

});
}
else {
();
}
}
);
}
##     token assertion__S_598Gt (:$sym is context<rw> = «>»)
##          token assertion:sym«>» { <sym> <rx> }

sub assertion__S_598Gt__PEEK { $_[0]->_AUTOLEXpeek('assertion__S_598Gt',$retree) }
sub assertion__S_598Gt {
my $self = shift;
local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;
my %args = @_;
local $sym = $args{sym} //['>'];


my $C = $self;
my $S = $C->{'_pos'};
$C->{'sym'} = $sym;

$self->_MATCHIFYr($S, "assertion__S_598Gt", 
do {
if (my ($C) = ($C->_PATTERN(qr/\G\>/))) {
$C->_SUBSUMEr(['rx'], sub {
my $C = shift;
$C->rx
});
}
else {
();
}
}
);
}

##     token rx
##          token rx {
##              #[:lang(self.unbalanced(')')) <nibbler>]
##              <nibbler>
##              [ <?before ')'> || <.panic: "Unable to parse Perl 5 regex; couldn't find right parenthesis"> ]
##          }

sub rx__PEEK { $_[0]->_AUTOLEXpeek('rx',$retree) }
sub rx {
my $self = shift;
local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;


my $C = $self;
my $S = $C->{'_pos'};

$self->_MATCHIFYr($S, "rx", 
do {
if (my ($C) = ($C->_SUBSUMEr(['nibbler'], sub {
my $C = shift;
$C->nibbler
}))) {
$C->_BRACKETr( sub { my $C=shift;
do { my @gather;
eval { push @gather, $C->before(sub { my $C=shift;
$C->_EXACT(')')
})} // do {die $@ if $@ and $@ !~ /ABORT/;1} 
or
eval { push @gather, $C->panic("Unable to parse Perl 5 regex; couldn't find right parenthesis")} or do { die $@ if $@ };
@gather;
}
});
}
else {
();
}
}
);
}

#token assertion:identifier { <longname> [               # is qq right here?
#                                | <?before ')' >
#                                | <.ws> <nibbler>
#                               ]
#                               [ ':' <rx> ]?
#}
##     token p5mod
##          token p5mod { <[imox]>* }

sub p5mod__PEEK { $_[0]->_AUTOLEXpeek('p5mod',$retree) }
sub p5mod {
my $self = shift;
local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;


my $C = $self;
my $S = $C->{'_pos'};

$self->_MATCHIFYr($S, "p5mod", 
$C->_PATTERN(qr/\G((?:[imox])*+)/)
);
}
##     token p5mods
##          token p5mods { <on=p5mod> [ '-' <off=p5mod> ]? }

sub p5mods__PEEK { $_[0]->_AUTOLEXpeek('p5mods',$retree) }
sub p5mods {
my $self = shift;
local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;


my $C = $self;
my $S = $C->{'_pos'};
$C->{'off'} = [];

$self->_MATCHIFYr($S, "p5mods", 
do {
if (my ($C) = (    $C->_SUBSUMEr(['on'], sub {
my $C = shift;
$C->p5mod
}))) {
$C->_OPTr(sub { my $C=shift;
$C->_BRACKETr( sub { my $C=shift;
do {
if (my ($C) = ($C->_EXACT('-'))) {
$C->_SUBSUMEr(['off'], sub {
my $C = shift;
$C->p5mod
});
}
else {
();
}
}
})
});
}
else {
();
}
}
);
}
##     token assertion__S_599mod (:$sym is context<rw> = 'mod')
##          token assertion:mod { <p5mods> [               # is qq right here?
##                                         | ':' <rx>?
##                                         | <?before ')' >
##                                         ]
##          }

sub assertion__S_599mod__PEEK { $_[0]->_AUTOLEXpeek('assertion__S_599mod',$retree) }
sub assertion__S_599mod {
my $self = shift;
local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;
my %args = @_;
local $sym = $args{sym} // 'mod';


my $C = $self;
my $S = $C->{'_pos'};
$C->{'rx'} = [];
$C->{'sym'} = $sym;

$self->_MATCHIFYr($S, "assertion__S_599mod", 
do {
if (my ($C) = ($C->_SUBSUMEr(['p5mods'], sub {
my $C = shift;
$C->p5mods
}))) {
$C->_BRACKETr( sub { my $C=shift;
do {
my @result = eval {
my $trystate;
my ($tag, $try);
my @try;
my $relex;

my $fate;
if ($fate = $C->{'_fate'} and $fate->[1] eq 'assertion__S_599mod_01') {
$C->deb("Fate passed to assertion__S_599mod_01: ", ::fatestr($fate)) if $::DEBUG & DEBUG::fates;
($C->{'_fate'}, $tag, $try) = @$fate;
@try = ($try);
}

my @gather = ();
for (;;) {
if (not @try) {
$relex //= $C->cursor_fate('STD::P5Regex', 'assertion__S_599mod_01', $retree);
@try = $relex->($C, $trystate);
}
last unless @try;
$try = shift(@try) // next;

if (ref $try eq 'ARRAY') {
($C->{'_fate'}, $tag, $try) = @$try;	# next candidate fate
}

$C->deb("assertion__S_599mod_01 trying $tag $try") if $::DEBUG & DEBUG::try_processing;
push @gather, ((
sub { my $C=shift;
do {
if (my ($C) = ($C->_EXACT(':'))) {
$C->_OPTr(sub { my $C=shift;
$C->_SUBSUMEr(['rx'], sub {
my $C = shift;
$C->rx
})
});
}
else {
();
}
}
},
sub { my $C=shift;
$C->before(sub { my $C=shift;
$C->_EXACT(')')
})
},
)[$try])->($C);
last if @gather;
}
@gather;
};
if (@result) {
@result;
}
elsif ($@) {
my ($first) = $@ =~ /(^.*)/;
$self->deb("CAUGHT $first") if $::DEBUG & DEBUG::trace_call;
die $@ if $@ !~ /^ABORTBRANCH/;
();
}
else {
();
}
}

});
}
else {
();
}
}
);
}

##     token assertion__S_600bogus (:$sym is context<rw> = 'bogus')
##          token assertion:bogus { <.panic: "Unrecognized Perl 5 regex assertion"> }

sub assertion__S_600bogus__PEEK { $_[0]->_AUTOLEXpeek('assertion__S_600bogus',$retree) }
sub assertion__S_600bogus {
my $self = shift;
local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;
my %args = @_;
local $sym = $args{sym} // 'bogus';


my $C = $self;
my $S = $C->{'_pos'};
$C->{'sym'} = $sym;

$self->_MATCHIFYr($S, "assertion__S_600bogus", 
$C->panic("Unrecognized Perl 5 regex assertion")
);
}

##     token quantifier__S_601Star (:$sym is context<rw> = <*>)
##          token quantifier:sym<*>  { <sym> <quantmod> }

sub quantifier__S_601Star__PEEK { $_[0]->_AUTOLEXpeek('quantifier__S_601Star',$retree) }
sub quantifier__S_601Star {
my $self = shift;
local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;
my %args = @_;
local $sym = $args{sym} // q(*);


my $C = $self;
my $S = $C->{'_pos'};
$C->{'sym'} = $sym;

$self->_MATCHIFYr($S, "quantifier__S_601Star", 
do {
if (my ($C) = ($C->_PATTERN(qr/\G\*/))) {
$C->_SUBSUMEr(['quantmod'], sub {
my $C = shift;
$C->quantmod
});
}
else {
();
}
}
);
}
##     token quantifier__S_602Plus (:$sym is context<rw> = <+>)
##          token quantifier:sym<+>  { <sym> <quantmod> }

sub quantifier__S_602Plus__PEEK { $_[0]->_AUTOLEXpeek('quantifier__S_602Plus',$retree) }
sub quantifier__S_602Plus {
my $self = shift;
local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;
my %args = @_;
local $sym = $args{sym} // q(+);


my $C = $self;
my $S = $C->{'_pos'};
$C->{'sym'} = $sym;

$self->_MATCHIFYr($S, "quantifier__S_602Plus", 
do {
if (my ($C) = ($C->_PATTERN(qr/\G\+/))) {
$C->_SUBSUMEr(['quantmod'], sub {
my $C = shift;
$C->quantmod
});
}
else {
();
}
}
);
}
##     token quantifier__S_603Question (:$sym is context<rw> = <?>)
##          token quantifier:sym<?>  { <sym> <quantmod> }

sub quantifier__S_603Question__PEEK { $_[0]->_AUTOLEXpeek('quantifier__S_603Question',$retree) }
sub quantifier__S_603Question {
my $self = shift;
local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;
my %args = @_;
local $sym = $args{sym} // q(?);


my $C = $self;
my $S = $C->{'_pos'};
$C->{'sym'} = $sym;

$self->_MATCHIFYr($S, "quantifier__S_603Question", 
do {
if (my ($C) = ($C->_PATTERN(qr/\G\?/))) {
$C->_SUBSUMEr(['quantmod'], sub {
my $C = shift;
$C->quantmod
});
}
else {
();
}
}
);
}
##     token quantifier__S_604Cur_Ly (:$sym is context<rw> = <{ }>)
##          token quantifier:sym<{ }> { '{' \d+ [','\d*]? '}' <quantmod> }

sub quantifier__S_604Cur_Ly__PEEK { $_[0]->_AUTOLEXpeek('quantifier__S_604Cur_Ly',$retree) }
sub quantifier__S_604Cur_Ly {
my $self = shift;
local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;
my %args = @_;
local $sym = $args{sym} // [qw({ })];


my $C = $self;
my $S = $C->{'_pos'};
$C->{'sym'} = $sym;

$self->_MATCHIFYr($S, "quantifier__S_604Cur_Ly", 
do {
if (my ($C) = ($C->_EXACT('{'))) {
do {
if (my ($C) = ($C->_PATTERN(qr/\G((?:\d)++)/))) {
do {
if (my ($C) = ($C->_OPTr(sub { my $C=shift;
$C->_BRACKETr( sub { my $C=shift;
do {
if (my ($C) = ($C->_EXACT(','))) {
$C->_PATTERN(qr/\G((?:\d)*+)/);
}
else {
();
}
}
})
}))) {
do {
if (my ($C) = ($C->_EXACT('}'))) {
$C->_SUBSUMEr(['quantmod'], sub {
my $C = shift;
$C->quantmod
});
}
else {
();
}
};
}
else {
();
}
};
}
else {
();
}
};
}
else {
();
}
}
);
}

##     token quantmod
##          token quantmod { [ '?' | '+' ]? }

sub quantmod__PEEK { $_[0]->_AUTOLEXpeek('quantmod',$retree) }
sub quantmod {
my $self = shift;
local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;


my $C = $self;
my $S = $C->{'_pos'};

$self->_MATCHIFYr($S, "quantmod", 
$C->_OPTr(sub { my $C=shift;
$C->_BRACKETr( sub { my $C=shift;
do {
my @result = eval {
my $trystate;
my ($tag, $try);
my @try;
my $relex;

my $fate;
if ($fate = $C->{'_fate'} and $fate->[1] eq 'quantmod_01') {
$C->deb("Fate passed to quantmod_01: ", ::fatestr($fate)) if $::DEBUG & DEBUG::fates;
($C->{'_fate'}, $tag, $try) = @$fate;
@try = ($try);
}

my @gather = ();
for (;;) {
if (not @try) {
$relex //= $C->cursor_fate('STD::P5Regex', 'quantmod_01', $retree);
@try = $relex->($C, $trystate);
}
last unless @try;
$try = shift(@try) // next;

if (ref $try eq 'ARRAY') {
($C->{'_fate'}, $tag, $try) = @$try;	# next candidate fate
}

$C->deb("quantmod_01 trying $tag $try") if $::DEBUG & DEBUG::try_processing;
push @gather, ((
sub { my $C=shift;
$C->_EXACT('?')
},
sub { my $C=shift;
$C->_EXACT('+')
},
)[$try])->($C);
last if @gather;
}
@gather;
};
if (@result) {
@result;
}
elsif ($@) {
my ($first) = $@ =~ /(^.*)/;
$self->deb("CAUGHT $first") if $::DEBUG & DEBUG::trace_call;
die $@ if $@ !~ /^ABORTBRANCH/;
();
}
else {
();
}
}

})
})
);
}

BEGIN {
$retree = YAML::Syck::Load(<<'RETREE_END');
--- 
assertion__S_593Question: !!perl/hash:RE 
  decl: []

  kind: token
  min: 24690
  pkg: ~
  re: !!perl/hash:RE_sequence 
    a: 0
    dba: assertion__S_593Question
    i: 0
    min: 24690
    r: 1
    s: 0
    zyg: 
      - !!perl/hash:RE_method 
        a: 0
        dba: assertion__S_593Question
        i: 0
        min: 12345
        name: sym
        r: 1
        rest: ''
        s: 0
        sym: "?"
      - !!perl/hash:RE_method 
        a: 0
        dba: assertion__S_593Question
        i: 0
        min: 12345
        name: codeblock
        r: 1
        rest: ''
        s: 0
assertion__S_594Cur_Ly: !!perl/hash:RE 
  decl: []

  kind: token
  min: 12345
  pkg: ~
  re: !!perl/hash:RE_method 
    a: 0
    dba: assertion__S_594Cur_Ly
    i: 0
    min: 12345
    name: codeblock
    r: 1
    rest: ''
    s: 0
assertion__S_595Lt: !!perl/hash:RE 
  decl: []

  kind: token
  min: 24690
  pkg: ~
  re: !!perl/hash:RE_sequence 
    a: 0
    dba: assertion__S_595Lt
    i: 0
    min: 24690
    r: 1
    s: 0
    zyg: 
      - !!perl/hash:RE_method 
        a: 0
        dba: assertion__S_595Lt
        i: 0
        min: 12345
        name: sym
        r: 1
        rest: ''
        s: 0
        sym: <
      - !!perl/hash:RE_assertion 
        assert: "?"
        min: 0
        re: !!perl/hash:RE_method_re 
          a: 0
          dba: assertion__S_595Lt
          i: 0
          min: 0
          name: before
          nobind: 1
          r: 1
          re: !!perl/hash:RE 
            decl: []

            min: 1
            re: &11 !!perl/hash:RE_any 
              a: 0
              altname: assertion__S_595Lt_01
              dba: assertion__S_595Lt
              i: 0
              min: 1
              name: assertion__S_595Lt_01
              r: 1
              s: 0
              zyg: 
                - !!perl/hash:RE_string 
                  a: 0
                  alt: assertion__S_595Lt_01 0
                  dba: assertion__S_595Lt
                  i: 0
                  min: 1
                  r: 1
                  s: 0
                  text: =
                - !!perl/hash:RE_string 
                  a: 0
                  alt: assertion__S_595Lt_01 1
                  dba: assertion__S_595Lt
                  i: 0
                  min: 1
                  r: 1
                  s: 0
                  text: "!"
          s: 0
      - !!perl/hash:RE_method 
        a: 0
        dba: assertion__S_595Lt
        i: 0
        min: 12345
        name: assertion
        r: 1
        rest: ''
        s: 0
assertion__S_595Lt_01: *11
assertion__S_596Equal: !!perl/hash:RE 
  decl: []

  kind: token
  min: 12345
  pkg: ~
  re: !!perl/hash:RE_sequence 
    a: 0
    dba: assertion__S_596Equal
    i: 0
    min: 12345
    r: 1
    s: 0
    zyg: 
      - !!perl/hash:RE_method 
        a: 0
        dba: assertion__S_596Equal
        i: 0
        min: 12345
        name: sym
        r: 1
        rest: ''
        s: 0
        sym: =
      - !!perl/hash:RE_bracket 
        decl: []

        min: 0
        re: &4 !!perl/hash:RE_any 
          a: 0
          altname: assertion__S_596Equal_01
          dba: assertion__S_596Equal
          i: 0
          min: 0
          name: assertion__S_596Equal_01
          r: 1
          s: 0
          zyg: 
            - !!perl/hash:RE_assertion 
              alt: assertion__S_596Equal_01 0
              assert: "?"
              min: 0
              re: !!perl/hash:RE_method_re 
                a: 0
                dba: assertion__S_596Equal
                i: 0
                min: 0
                name: before
                nobind: 1
                r: 1
                re: !!perl/hash:RE 
                  decl: []

                  min: 1
                  re: !!perl/hash:RE_string 
                    a: 0
                    dba: assertion__S_596Equal
                    i: 0
                    min: 1
                    r: 1
                    s: 0
                    text: )
                s: 0
            - !!perl/hash:RE_method 
              a: 0
              alt: assertion__S_596Equal_01 1
              dba: assertion__S_596Equal
              i: 0
              min: 12345
              name: rx
              r: 1
              rest: ''
              s: 0
assertion__S_596Equal_01: *4
assertion__S_597Bang: !!perl/hash:RE 
  decl: []

  kind: token
  min: 12345
  pkg: ~
  re: !!perl/hash:RE_sequence 
    a: 0
    dba: assertion__S_597Bang
    i: 0
    min: 12345
    r: 1
    s: 0
    zyg: 
      - !!perl/hash:RE_method 
        a: 0
        dba: assertion__S_597Bang
        i: 0
        min: 12345
        name: sym
        r: 1
        rest: ''
        s: 0
        sym: "!"
      - !!perl/hash:RE_bracket 
        decl: []

        min: 0
        re: &9 !!perl/hash:RE_any 
          a: 0
          altname: assertion__S_597Bang_01
          dba: assertion__S_597Bang
          i: 0
          min: 0
          name: assertion__S_597Bang_01
          r: 1
          s: 0
          zyg: 
            - !!perl/hash:RE_assertion 
              alt: assertion__S_597Bang_01 0
              assert: "?"
              min: 0
              re: !!perl/hash:RE_method_re 
                a: 0
                dba: assertion__S_597Bang
                i: 0
                min: 0
                name: before
                nobind: 1
                r: 1
                re: !!perl/hash:RE 
                  decl: []

                  min: 1
                  re: !!perl/hash:RE_string 
                    a: 0
                    dba: assertion__S_597Bang
                    i: 0
                    min: 1
                    r: 1
                    s: 0
                    text: )
                s: 0
            - !!perl/hash:RE_method 
              a: 0
              alt: assertion__S_597Bang_01 1
              dba: assertion__S_597Bang
              i: 0
              min: 12345
              name: rx
              r: 1
              rest: ''
              s: 0
assertion__S_597Bang_01: *9
assertion__S_598Gt: !!perl/hash:RE 
  decl: []

  kind: token
  min: 24690
  pkg: ~
  re: !!perl/hash:RE_sequence 
    a: 0
    dba: assertion__S_598Gt
    i: 0
    min: 24690
    r: 1
    s: 0
    zyg: 
      - !!perl/hash:RE_method 
        a: 0
        dba: assertion__S_598Gt
        i: 0
        min: 12345
        name: sym
        r: 1
        rest: ''
        s: 0
        sym: ">"
      - !!perl/hash:RE_method 
        a: 0
        dba: assertion__S_598Gt
        i: 0
        min: 12345
        name: rx
        r: 1
        rest: ''
        s: 0
assertion__S_599mod: !!perl/hash:RE 
  decl: []

  kind: token
  min: 12345
  pkg: ~
  re: !!perl/hash:RE_sequence 
    a: 0
    dba: assertion__S_599mod
    i: 0
    min: 12345
    r: 1
    s: 0
    zyg: 
      - !!perl/hash:RE_method 
        a: 0
        dba: assertion__S_599mod
        i: 0
        min: 12345
        name: p5mods
        r: 1
        rest: ''
        s: 0
      - !!perl/hash:RE_bracket 
        decl: []

        min: 0
        re: &8 !!perl/hash:RE_any 
          a: 0
          altname: assertion__S_599mod_01
          dba: assertion__S_599mod
          i: 0
          min: 0
          name: assertion__S_599mod_01
          r: 1
          s: 0
          zyg: 
            - !!perl/hash:RE_sequence 
              a: 0
              alt: assertion__S_599mod_01 0
              dba: assertion__S_599mod
              i: 0
              min: 1
              r: 1
              s: 0
              zyg: 
                - !!perl/hash:RE_string 
                  a: 0
                  dba: assertion__S_599mod
                  i: 0
                  min: 1
                  r: 1
                  s: 0
                  text: ":"
                - !!perl/hash:RE_quantified_atom 
                  atom: !!perl/hash:RE_method 
                    a: 0
                    dba: assertion__S_599mod
                    i: 0
                    min: 12345
                    name: rx
                    r: 1
                    rest: ''
                    s: 0
                  min: 0
                  quant: 
                    - "?"
                    - ":"
                    - ''
                    - 0
            - !!perl/hash:RE_assertion 
              alt: assertion__S_599mod_01 1
              assert: "?"
              min: 0
              re: !!perl/hash:RE_method_re 
                a: 0
                dba: assertion__S_599mod
                i: 0
                min: 0
                name: before
                nobind: 1
                r: 1
                re: !!perl/hash:RE 
                  decl: []

                  min: 1
                  re: !!perl/hash:RE_string 
                    a: 0
                    dba: assertion__S_599mod
                    i: 0
                    min: 1
                    r: 1
                    s: 0
                    text: )
                s: 0
assertion__S_599mod_01: *8
assertion__S_600bogus: !!perl/hash:RE 
  decl: []

  kind: token
  min: 0
  pkg: ~
  re: !!perl/hash:RE_method 
    min: 0
    name: panic
    nobind: 1
    rest: ("Unrecognized Perl 5 regex assertion")
atom: !!perl/hash:RE 
  decl: []

  kind: token
  min: 1
  pkg: ~
  re: !!perl/hash:RE_bracket 
    decl: []

    min: 1
    re: &6 !!perl/hash:RE_any 
      a: 0
      altname: atom_01
      dba: atom
      i: 0
      min: 1
      name: atom_01
      r: 1
      s: 0
      zyg: 
        - !!perl/hash:RE_meta 
          a: 0
          alt: atom_01 0
          dba: atom
          i: 0
          min: 1
          r: 1
          s: 0
          text: \w
        - !!perl/hash:RE_method 
          a: 0
          alt: atom_01 1
          dba: atom
          i: 0
          min: 12345
          name: metachar
          r: 1
          rest: ''
          s: 0
        - !!perl/hash:RE_sequence 
          a: 0
          alt: atom_01 2
          dba: atom
          i: 0
          min: 2
          r: 1
          s: 0
          zyg: 
            - !!perl/hash:RE_string 
              a: 0
              dba: atom
              i: 0
              min: 1
              r: 1
              s: 0
              text: \
            - !!perl/hash:RE_meta 
              a: 0
              dba: atom
              i: 0
              min: 0
              r: 1
              s: 0
              text: "::"
            - !!perl/hash:RE_meta 
              a: 0
              dba: atom
              i: 0
              min: 1
              r: 1
              s: 0
              text: .
atom_01: *6
backslash__S_570A: !!perl/hash:RE 
  decl: []

  kind: token
  min: 12345
  pkg: ~
  re: !!perl/hash:RE_method 
    a: 0
    dba: backslash__S_570A
    i: 0
    min: 12345
    name: sym
    r: 1
    rest: ''
    s: 0
    sym: A
backslash__S_571a: !!perl/hash:RE 
  decl: []

  kind: token
  min: 12345
  pkg: ~
  re: !!perl/hash:RE_method 
    a: 0
    dba: backslash__S_571a
    i: 0
    min: 12345
    name: sym
    r: 1
    rest: ''
    s: 0
    sym: a
backslash__S_572b: !!perl/hash:RE 
  decl: []

  kind: token
  min: 12345
  pkg: ~
  re: !!perl/hash:RE_method 
    a: 0
    dba: backslash__S_572b
    i: 1
    min: 12345
    name: sym
    r: 1
    rest: ''
    s: 0
    sym: b
backslash__S_573c: !!perl/hash:RE 
  decl: []

  kind: token
  min: 0
  pkg: ~
  re: !!perl/hash:RE_first 
    a: 0
    dba: backslash__S_573c
    i: 1
    min: 0
    r: 1
    s: 0
    zyg: 
      - !!perl/hash:RE_sequence 
        a: 0
        dba: backslash__S_573c
        i: 1
        min: 12346
        r: 1
        s: 0
        zyg: 
          - !!perl/hash:RE_method 
            a: 0
            dba: backslash__S_573c
            i: 1
            min: 12345
            name: sym
            r: 1
            rest: ''
            s: 0
            sym: c
          - !!perl/hash:RE_cclass 
            a: 0
            dba: backslash__S_573c
            i: 1
            min: 1
            r: 1
            s: 0
            text: "[ ?.._ ]"
      - !!perl/hash:RE_method 
        min: 0
        name: panic
        nobind: 1
        rest: ("Unrecognized \\c character")
backslash__S_574d: !!perl/hash:RE 
  decl: []

  kind: token
  min: 12345
  pkg: ~
  re: !!perl/hash:RE_method 
    a: 0
    dba: backslash__S_574d
    i: 1
    min: 12345
    name: sym
    r: 1
    rest: ''
    s: 0
    sym: d
backslash__S_575e: !!perl/hash:RE 
  decl: []

  kind: token
  min: 12345
  pkg: ~
  re: !!perl/hash:RE_method 
    a: 0
    dba: backslash__S_575e
    i: 1
    min: 12345
    name: sym
    r: 1
    rest: ''
    s: 0
    sym: e
backslash__S_576f: !!perl/hash:RE 
  decl: []

  kind: token
  min: 12345
  pkg: ~
  re: !!perl/hash:RE_method 
    a: 0
    dba: backslash__S_576f
    i: 1
    min: 12345
    name: sym
    r: 1
    rest: ''
    s: 0
    sym: f
backslash__S_577h: !!perl/hash:RE 
  decl: []

  kind: token
  min: 12345
  pkg: ~
  re: !!perl/hash:RE_method 
    a: 0
    dba: backslash__S_577h
    i: 1
    min: 12345
    name: sym
    r: 1
    rest: ''
    s: 0
    sym: h
backslash__S_578l: !!perl/hash:RE 
  decl: []

  kind: token
  min: 12345
  pkg: ~
  re: !!perl/hash:RE_method 
    a: 0
    dba: backslash__S_578l
    i: 1
    min: 12345
    name: sym
    r: 1
    rest: ''
    s: 0
    sym: l
backslash__S_579n: !!perl/hash:RE 
  decl: []

  kind: token
  min: 12345
  pkg: ~
  re: !!perl/hash:RE_method 
    a: 0
    dba: backslash__S_579n
    i: 1
    min: 12345
    name: sym
    r: 1
    rest: ''
    s: 0
    sym: 'n'
backslash__S_580o: !!perl/hash:RE 
  decl: []

  kind: token
  min: 12346
  pkg: ~
  re: !!perl/hash:RE_sequence 
    a: 0
    dba: octal character
    i: 0
    min: 12346
    r: 1
    s: 0
    zyg: 
      - !!perl/hash:RE_string 
        a: 0
        dba: octal character
        i: 0
        min: 1
        r: 1
        s: 0
        text: 0
      - !!perl/hash:RE_bracket 
        decl: []

        min: 12345
        re: &7 !!perl/hash:RE_any 
          a: 0
          altname: backslash__S_580o_01
          dba: octal character
          i: 0
          min: 12345
          name: backslash__S_580o_01
          r: 1
          s: 0
          zyg: 
            - !!perl/hash:RE_method 
              a: 0
              alt: backslash__S_580o_01 0
              dba: octal character
              i: 0
              min: 12345
              name: octint
              r: 1
              rest: ''
              s: 0
            - !!perl/hash:RE_sequence 
              a: 0
              alt: backslash__S_580o_01 1
              dba: octal character
              i: 0
              min: 12347
              r: 1
              s: 0
              zyg: 
                - !!perl/hash:RE_string 
                  a: 0
                  dba: octal character
                  i: 0
                  min: 1
                  r: 1
                  s: 0
                  text: "{"
                - !!perl/hash:RE_meta 
                  a: 0
                  dba: octal character
                  extra: "local $::GOAL = '}' "
                  i: 0
                  min: 0
                  r: 1
                  s: 0
                  text: "::"
                - !!perl/hash:RE_method 
                  a: 0
                  dba: octal character
                  i: 0
                  min: 12345
                  name: octints
                  r: 1
                  rest: ''
                  s: 0
                - !!perl/hash:RE_bracket 
                  decl: []

                  min: 1
                  re: !!perl/hash:RE_first 
                    a: 0
                    dba: octal character
                    i: 0
                    min: 1
                    r: 1
                    s: 0
                    zyg: 
                      - !!perl/hash:RE_string 
                        a: 0
                        dba: octal character
                        i: 0
                        min: 1
                        r: 1
                        s: 0
                        text: "}"
                      - !!perl/hash:RE_method 
                        min: 0
                        name: FAILGOAL
                        nobind: 1
                        rest: ('}' , 'octal character')
backslash__S_580o_01: *7
backslash__S_581p: !!perl/hash:RE 
  decl: []

  kind: token
  min: 12348
  pkg: ~
  re: !!perl/hash:RE_sequence 
    a: 0
    dba: backslash__S_581p
    i: 1
    min: 12348
    r: 1
    s: 0
    zyg: 
      - !!perl/hash:RE_method 
        a: 0
        dba: backslash__S_581p
        i: 1
        min: 12345
        name: sym
        r: 1
        rest: ''
        s: 0
        sym: p
      - !!perl/hash:RE_string 
        a: 0
        dba: backslash__S_581p
        i: 1
        min: 1
        r: 1
        s: 0
        text: "{"
      - !!perl/hash:RE_quantified_atom 
        atom: !!perl/hash:RE_cclass 
          a: 0
          dba: backslash__S_581p
          i: 1
          min: 1
          r: 1
          s: 0
          text: "[\\w:]"
        min: 1
        quant: 
          - +
          - ":"
          - ''
          - 1
      - !!perl/hash:RE_string 
        a: 0
        dba: backslash__S_581p
        i: 1
        min: 1
        r: 1
        s: 0
        text: "}"
backslash__S_582Q: !!perl/hash:RE 
  decl: []

  kind: token
  min: 12345
  pkg: ~
  re: !!perl/hash:RE_method 
    a: 0
    dba: backslash__S_582Q
    i: 0
    min: 12345
    name: sym
    r: 1
    rest: ''
    s: 0
    sym: Q
backslash__S_583r: !!perl/hash:RE 
  decl: []

  kind: token
  min: 12345
  pkg: ~
  re: !!perl/hash:RE_method 
    a: 0
    dba: backslash__S_583r
    i: 1
    min: 12345
    name: sym
    r: 1
    rest: ''
    s: 0
    sym: r
backslash__S_584s: !!perl/hash:RE 
  decl: []

  kind: token
  min: 12345
  pkg: ~
  re: !!perl/hash:RE_method 
    a: 0
    dba: backslash__S_584s
    i: 1
    min: 12345
    name: sym
    r: 1
    rest: ''
    s: 0
    sym: s
backslash__S_585t: !!perl/hash:RE 
  decl: []

  kind: token
  min: 12345
  pkg: ~
  re: !!perl/hash:RE_method 
    a: 0
    dba: backslash__S_585t
    i: 1
    min: 12345
    name: sym
    r: 1
    rest: ''
    s: 0
    sym: t
backslash__S_586u: !!perl/hash:RE 
  decl: []

  kind: token
  min: 12345
  pkg: ~
  re: !!perl/hash:RE_method 
    a: 0
    dba: backslash__S_586u
    i: 1
    min: 12345
    name: sym
    r: 1
    rest: ''
    s: 0
    sym: u
backslash__S_587v: !!perl/hash:RE 
  decl: []

  kind: token
  min: 12345
  pkg: ~
  re: !!perl/hash:RE_method 
    a: 0
    dba: backslash__S_587v
    i: 1
    min: 12345
    name: sym
    r: 1
    rest: ''
    s: 0
    sym: v
backslash__S_588w: !!perl/hash:RE 
  decl: []

  kind: token
  min: 12345
  pkg: ~
  re: !!perl/hash:RE_method 
    a: 0
    dba: backslash__S_588w
    i: 1
    min: 12345
    name: sym
    r: 1
    rest: ''
    s: 0
    sym: w
backslash__S_589x: !!perl/hash:RE 
  decl: []

  kind: token
  min: 24690
  pkg: ~
  re: !!perl/hash:RE_sequence 
    a: 0
    dba: hex character
    i: 1
    min: 24690
    r: 1
    s: 0
    zyg: 
      - !!perl/hash:RE_method 
        a: 0
        dba: hex character
        i: 1
        min: 12345
        name: sym
        r: 1
        rest: ''
        s: 0
        sym: x
      - !!perl/hash:RE_bracket 
        decl: []

        min: 12345
        re: &2 !!perl/hash:RE_any 
          a: 0
          altname: backslash__S_589x_01
          dba: hex character
          i: 1
          min: 12345
          name: backslash__S_589x_01
          r: 1
          s: 0
          zyg: 
            - !!perl/hash:RE_method 
              a: 0
              alt: backslash__S_589x_01 0
              dba: hex character
              i: 1
              min: 12345
              name: hexint
              r: 1
              rest: ''
              s: 0
            - !!perl/hash:RE_sequence 
              a: 0
              alt: backslash__S_589x_01 1
              dba: hex character
              i: 1
              min: 12347
              r: 1
              s: 0
              zyg: 
                - !!perl/hash:RE_string 
                  a: 0
                  dba: hex character
                  i: 1
                  min: 1
                  r: 1
                  s: 0
                  text: "{"
                - !!perl/hash:RE_meta 
                  a: 0
                  dba: hex character
                  extra: "local $::GOAL = '}' "
                  i: 1
                  min: 0
                  r: 1
                  s: 0
                  text: "::"
                - !!perl/hash:RE_method 
                  a: 0
                  dba: hex character
                  i: 1
                  min: 12345
                  name: hexints
                  r: 1
                  rest: ''
                  s: 0
                - !!perl/hash:RE_bracket 
                  decl: []

                  min: 1
                  re: !!perl/hash:RE_first 
                    a: 0
                    dba: hex character
                    i: 1
                    min: 1
                    r: 1
                    s: 0
                    zyg: 
                      - !!perl/hash:RE_string 
                        a: 0
                        dba: hex character
                        i: 1
                        min: 1
                        r: 1
                        s: 0
                        text: "}"
                      - !!perl/hash:RE_method 
                        min: 0
                        name: FAILGOAL
                        nobind: 1
                        rest: ('}' , 'hex character')
backslash__S_589x_01: *2
backslash__S_590z: !!perl/hash:RE 
  decl: []

  kind: token
  min: 12345
  pkg: ~
  re: !!perl/hash:RE_method 
    a: 0
    dba: backslash__S_590z
    i: 1
    min: 12345
    name: sym
    r: 1
    rest: ''
    s: 0
    sym: z
backslash__S_591misc: !!perl/hash:RE 
  decl: []

  kind: token
  min: 1
  pkg: ~
  re: &3 !!perl/hash:RE_any 
    a: 0
    altname: backslash__S_591misc_00
    dba: backslash__S_591misc
    i: 0
    min: 1
    name: backslash__S_591misc_00
    r: 1
    s: 0
    zyg: 
      - !!perl/hash:RE_bindnamed 
        a: 0
        alt: backslash__S_591misc_00 0
        atom: !!perl/hash:RE_paren 
          decl: []

          min: 1
          nobind: 1
          re: !!perl/hash:RE_meta 
            a: 0
            dba: backslash__S_591misc
            i: 0
            min: 1
            r: 1
            s: 0
            text: \W
        dba: backslash__S_591misc
        i: 0
        min: 1
        r: 1
        s: 0
        var: litchar
      - !!perl/hash:RE_bindnamed 
        a: 0
        alt: backslash__S_591misc_00 1
        atom: !!perl/hash:RE_paren 
          decl: []

          min: 1
          nobind: 1
          re: !!perl/hash:RE_quantified_atom 
            atom: !!perl/hash:RE_meta 
              a: 0
              dba: backslash__S_591misc
              i: 0
              min: 1
              r: 1
              s: 0
              text: \d
            min: 1
            quant: 
              - +
              - ":"
              - ''
              - 1
        dba: backslash__S_591misc
        i: 0
        min: 1
        r: 1
        s: 0
        var: number
backslash__S_591misc_00: *3
backslash__S_592oops: !!perl/hash:RE 
  decl: []

  kind: token
  min: 0
  pkg: ~
  re: !!perl/hash:RE_method 
    min: 0
    name: panic
    nobind: 1
    rest: ("Unrecognized Perl 5 regex backslash sequence")
category__S_553metachar: !!perl/hash:RE 
  decl: []

  kind: token
  min: 12345
  pkg: ~
  re: !!perl/hash:RE_method 
    a: 0
    dba: category__S_553metachar
    i: 0
    min: 12345
    name: sym
    r: 1
    rest: ''
    s: 0
    sym: metachar
category__S_554backslash: !!perl/hash:RE 
  decl: []

  kind: token
  min: 12345
  pkg: ~
  re: !!perl/hash:RE_method 
    a: 0
    dba: category__S_554backslash
    i: 0
    min: 12345
    name: sym
    r: 1
    rest: ''
    s: 0
    sym: backslash
category__S_555assertion: !!perl/hash:RE 
  decl: []

  kind: token
  min: 12345
  pkg: ~
  re: !!perl/hash:RE_method 
    a: 0
    dba: category__S_555assertion
    i: 0
    min: 12345
    name: sym
    r: 1
    rest: ''
    s: 0
    sym: assertion
category__S_556quantifier: !!perl/hash:RE 
  decl: []

  kind: token
  min: 12345
  pkg: ~
  re: !!perl/hash:RE_method 
    a: 0
    dba: category__S_556quantifier
    i: 0
    min: 12345
    name: sym
    r: 1
    rest: ''
    s: 0
    sym: quantifier
category__S_557mod_internal: !!perl/hash:RE 
  decl: []

  kind: token
  min: 12345
  pkg: ~
  re: !!perl/hash:RE_method 
    a: 0
    dba: category__S_557mod_internal
    i: 0
    min: 12345
    name: sym
    r: 1
    rest: ''
    s: 0
    sym: mod_internal
codeblock: !!perl/hash:RE 
  decl: 
    - !!perl/hash:RE_decl 
      a: 0
      dba: codeblock
      i: 0
      max: 0
      min: 0
      r: 1
      s: 0
      text: my $GOAL is context = '}'
  kind: token
  min: 12346
  pkg: ~
  re: !!perl/hash:RE_sequence 
    a: 0
    dba: codeblock
    i: 0
    min: 12346
    r: 1
    s: 0
    zyg: 
      - !!perl/hash:RE_string 
        a: 0
        dba: codeblock
        i: 0
        min: 1
        r: 1
        s: 0
        text: "{"
      - !!perl/hash:RE_meta 
        a: 0
        dba: codeblock
        i: 0
        min: 0
        r: 1
        s: 0
        text: "::"
      - !!perl/hash:RE_bracket 
        decl: []

        min: 12345
        re: !!perl/hash:RE_sequence 
          a: 0
          dba: codeblock
          i: 0
          lang: ($C->cursor_fresh($::LANG{'MAIN'}))
          min: 12345
          r: 1
          s: 0
          zyg: 
            - !!perl/hash:RE_decl 
              a: 0
              dba: codeblock
              i: 0
              lang: ($C->cursor_fresh($::LANG{'MAIN'}))
              max: 0
              min: 0
              noquant: 1
              r: 1
              s: 0
              text: "my $newlang = ($C->cursor_fresh($::LANG{'MAIN'}));  $C = $C->cursor_fresh($newlang); "
            - !!perl/hash:RE_method 
              a: 0
              dba: codeblock
              i: 0
              lang: ($C->cursor_fresh($::LANG{'MAIN'}))
              min: 12345
              name: statementlist
              r: 1
              rest: ''
              s: 0
      - !!perl/hash:RE_bracket 
        decl: []

        min: 0
        re: !!perl/hash:RE_first 
          a: 0
          dba: codeblock
          i: 0
          min: 0
          r: 1
          s: 0
          zyg: 
            - !!perl/hash:RE_string 
              a: 0
              dba: codeblock
              i: 0
              min: 1
              r: 1
              s: 0
              text: "}"
            - !!perl/hash:RE_method 
              min: 0
              name: panic
              nobind: 1
              rest: ("Unable to parse statement list; couldn't find right brace")
infixish: !!perl/hash:RE 
  decl: []

  kind: token
  min: 12345
  pkg: ~
  re: !!perl/hash:RE_sequence 
    a: 0
    dba: infixish
    i: 0
    min: 12345
    r: 1
    s: 0
    zyg: 
      - !!perl/hash:RE_assertion 
        assert: "!"
        min: 0
        re: !!perl/hash:RE_method 
          a: 0
          dba: infixish
          i: 0
          min: 12345
          name: infixstopper
          nobind: 1
          r: 1
          rest: ''
          s: 0
      - !!perl/hash:RE_assertion 
        assert: "!"
        min: 0
        re: !!perl/hash:RE_method 
          a: 0
          dba: infixish
          i: 0
          min: 12345
          name: stdstopper
          nobind: 1
          r: 1
          rest: ''
          s: 0
      - !!perl/hash:RE_method 
        a: 0
        dba: infixish
        i: 0
        min: 12345
        name: regex_infix
        r: 1
        rest: ''
        s: 0
      - !!perl/hash:RE_block 
        a: 0
        context: void
        dba: infixish
        i: 0
        min: 0
        r: 1
        s: 0
        text: "\n            $<O> = $<regex_infix><O>;\n            $<sym> = $<regex_infix><sym>;\n        "
metachar__S_559Vert: !!perl/hash:RE 
  decl: []

  kind: token
  min: 12346
  pkg: ~
  re: !!perl/hash:RE_sequence 
    a: 0
    dba: metachar__S_559Vert
    i: 0
    min: 12346
    r: 1
    s: 0
    zyg: 
      - !!perl/hash:RE_string 
        a: 0
        dba: metachar__S_559Vert
        i: 0
        min: 1
        r: 1
        s: 0
        text: "|"
      - !!perl/hash:RE_meta 
        a: 0
        dba: metachar__S_559Vert
        i: 0
        min: 0
        r: 1
        s: 0
        text: "::"
      - !!perl/hash:RE_method 
        a: 0
        dba: metachar__S_559Vert
        i: 0
        min: 12345
        name: fail
        r: 1
        rest: ''
        s: 0
metachar__S_560Thesis: !!perl/hash:RE 
  decl: []

  kind: token
  min: 12346
  pkg: ~
  re: !!perl/hash:RE_sequence 
    a: 0
    dba: metachar__S_560Thesis
    i: 0
    min: 12346
    r: 1
    s: 0
    zyg: 
      - !!perl/hash:RE_string 
        a: 0
        dba: metachar__S_560Thesis
        i: 0
        min: 1
        r: 1
        s: 0
        text: )
      - !!perl/hash:RE_meta 
        a: 0
        dba: metachar__S_560Thesis
        i: 0
        min: 0
        r: 1
        s: 0
        text: "::"
      - !!perl/hash:RE_method 
        a: 0
        dba: metachar__S_560Thesis
        i: 0
        min: 12345
        name: fail
        r: 1
        rest: ''
        s: 0
metachar__S_561quant: !!perl/hash:RE 
  decl: []

  kind: token
  min: 12345
  pkg: ~
  re: !!perl/hash:RE_sequence 
    a: 0
    dba: metachar__S_561quant
    i: 0
    min: 12345
    r: 1
    s: 0
    zyg: 
      - !!perl/hash:RE_method 
        a: 0
        dba: metachar__S_561quant
        i: 0
        min: 12345
        name: quantifier
        r: 1
        rest: ''
        s: 0
      - !!perl/hash:RE_method 
        min: 0
        name: panic
        nobind: 1
        rest: ("quantifier quantifies nothing")
metachar__S_562Bra_Ket: !!perl/hash:RE 
  decl: []

  kind: token
  min: 0
  pkg: ~
  re: !!perl/hash:RE_sequence 
    a: 0
    dba: metachar__S_562Bra_Ket
    i: 0
    min: 0
    r: 1
    s: 0
    zyg: 
      - !!perl/hash:RE_method_re 
        a: 0
        dba: metachar__S_562Bra_Ket
        i: 0
        min: 0
        name: before
        r: 1
        re: !!perl/hash:RE 
          decl: []

          min: 1
          re: !!perl/hash:RE_string 
            a: 0
            dba: metachar__S_562Bra_Ket
            i: 0
            min: 1
            r: 1
            s: 0
            text: "["
        s: 0
      - !!perl/hash:RE_method 
        min: 0
        name: quibble
        rest: ($¢.cursor_fresh( %*LANG<Q> ).tweak(:q))
metachar__S_563ParenQuestion_Thesis: !!perl/hash:RE 
  decl: []

  kind: token
  min: 12347
  pkg: ~
  re: !!perl/hash:RE_sequence 
    a: 0
    dba: metachar__S_563ParenQuestion_Thesis
    i: 0
    min: 12347
    r: 1
    s: 0
    zyg: 
      - !!perl/hash:RE_string 
        a: 0
        dba: metachar__S_563ParenQuestion_Thesis
        i: 0
        min: 2
        r: 1
        s: 0
        text: (?
      - !!perl/hash:RE_block 
        a: 0
        context: void
        dba: metachar__S_563ParenQuestion_Thesis
        i: 0
        min: 0
        r: 1
        s: 0
        text: ''
      - !!perl/hash:RE_method 
        a: 0
        dba: metachar__S_563ParenQuestion_Thesis
        i: 0
        min: 12345
        name: assertion
        r: 1
        rest: ''
        s: 0
      - !!perl/hash:RE_bracket 
        decl: []

        min: 0
        re: !!perl/hash:RE_first 
          a: 0
          dba: metachar__S_563ParenQuestion_Thesis
          i: 0
          min: 0
          r: 1
          s: 0
          zyg: 
            - !!perl/hash:RE_string 
              a: 0
              dba: metachar__S_563ParenQuestion_Thesis
              i: 0
              min: 1
              r: 1
              s: 0
              text: )
            - !!perl/hash:RE_method 
              min: 0
              name: panic
              nobind: 1
              rest: ("Perl 5 regex assertion not terminated by parenthesis")
metachar__S_564Paren_Thesis: !!perl/hash:RE 
  decl: []

  kind: token
  min: 1
  pkg: ~
  re: !!perl/hash:RE_sequence 
    a: 0
    dba: metachar__S_564Paren_Thesis
    i: 0
    min: 1
    r: 1
    s: 0
    zyg: 
      - !!perl/hash:RE_string 
        a: 0
        dba: metachar__S_564Paren_Thesis
        i: 0
        min: 1
        r: 1
        s: 0
        text: (
      - !!perl/hash:RE_block 
        a: 0
        context: void
        dba: metachar__S_564Paren_Thesis
        i: 0
        min: 0
        r: 1
        s: 0
        text: ''
      - !!perl/hash:RE_quantified_atom 
        atom: !!perl/hash:RE_bracket 
          decl: []

          min: 12345
          re: !!perl/hash:RE_sequence 
            a: 0
            dba: metachar__S_564Paren_Thesis
            i: 0
            lang: ($self->unbalanced(')'))
            min: 12345
            r: 1
            s: 0
            zyg: 
              - !!perl/hash:RE_decl 
                a: 0
                dba: metachar__S_564Paren_Thesis
                i: 0
                lang: ($self->unbalanced(')'))
                max: 0
                min: 0
                noquant: 1
                r: 1
                s: 0
                text: "my $newlang = ($self->unbalanced(')'));  $C = $C->cursor_fresh($newlang); "
              - !!perl/hash:RE_method 
                a: 0
                dba: metachar__S_564Paren_Thesis
                i: 0
                lang: ($self->unbalanced(')'))
                min: 12345
                name: nibbler
                r: 1
                rest: ''
                s: 0
        min: 0
        quant: 
          - "?"
          - ":"
          - ''
          - 0
      - !!perl/hash:RE_bracket 
        decl: []

        min: 0
        re: !!perl/hash:RE_first 
          a: 0
          dba: metachar__S_564Paren_Thesis
          i: 0
          min: 0
          r: 1
          s: 0
          zyg: 
            - !!perl/hash:RE_string 
              a: 0
              dba: metachar__S_564Paren_Thesis
              i: 0
              min: 1
              r: 1
              s: 0
              text: )
            - !!perl/hash:RE_method 
              min: 0
              name: panic
              nobind: 1
              rest: ("Unable to parse Perl 5 regex; couldn't find right parenthesis")
      - !!perl/hash:RE_block 
        a: 0
        context: void
        dba: metachar__S_564Paren_Thesis
        i: 0
        min: 0
        r: 1
        s: 0
        text: " $/<sym> := <( )> "
metachar__S_565Back: !!perl/hash:RE 
  decl: []

  kind: token
  min: 24690
  pkg: ~
  re: !!perl/hash:RE_sequence 
    a: 0
    dba: metachar__S_565Back
    i: 0
    min: 24690
    r: 1
    s: 0
    zyg: 
      - !!perl/hash:RE_method 
        a: 0
        dba: metachar__S_565Back
        i: 0
        min: 12345
        name: sym
        r: 1
        rest: ''
        s: 0
        sym: \
      - !!perl/hash:RE_method 
        a: 0
        dba: metachar__S_565Back
        i: 0
        min: 12345
        name: backslash
        r: 1
        rest: ''
        s: 0
metachar__S_566Dot: !!perl/hash:RE 
  decl: []

  kind: token
  min: 12345
  pkg: ~
  re: !!perl/hash:RE_method 
    a: 0
    dba: metachar__S_566Dot
    i: 0
    min: 12345
    name: sym
    r: 1
    rest: ''
    s: 0
    sym: .
metachar__S_567Caret: !!perl/hash:RE 
  decl: []

  kind: token
  min: 12345
  pkg: ~
  re: !!perl/hash:RE_method 
    a: 0
    dba: metachar__S_567Caret
    i: 0
    min: 12345
    name: sym
    r: 1
    rest: ''
    s: 0
    sym: "^"
metachar__S_568Dollar: !!perl/hash:RE 
  decl: []

  kind: token
  min: 1
  pkg: ~
  re: !!perl/hash:RE_sequence 
    a: 0
    dba: metachar__S_568Dollar
    i: 0
    min: 1
    r: 1
    s: 0
    zyg: 
      - !!perl/hash:RE_string 
        a: 0
        dba: metachar__S_568Dollar
        i: 0
        min: 1
        r: 1
        s: 0
        text: $
      - !!perl/hash:RE_assertion 
        assert: "?"
        min: 0
        re: !!perl/hash:RE_method_re 
          a: 0
          dba: metachar__S_568Dollar
          i: 0
          min: 0
          name: before
          nobind: 1
          r: 1
          re: !!perl/hash:RE 
            decl: []

            min: 0
            re: &5 !!perl/hash:RE_any 
              a: 0
              altname: metachar__S_568Dollar_01
              dba: metachar__S_568Dollar
              i: 0
              min: 0
              name: metachar__S_568Dollar_01
              r: 1
              s: 0
              zyg: 
                - !!perl/hash:RE_meta 
                  a: 0
                  alt: metachar__S_568Dollar_01 0
                  dba: metachar__S_568Dollar
                  i: 0
                  min: 1
                  r: 1
                  s: 0
                  text: \W
                - !!perl/hash:RE_meta 
                  a: 0
                  alt: metachar__S_568Dollar_01 1
                  dba: metachar__S_568Dollar
                  i: 0
                  min: 0
                  r: 1
                  s: 0
                  text: $
          s: 0
metachar__S_568Dollar_01: *5
metachar__S_569var: !!perl/hash:RE 
  decl: []

  kind: token
  min: 0
  pkg: ~
  re: !!perl/hash:RE_sequence 
    a: 0
    dba: metachar__S_569var
    i: 0
    min: 0
    r: 1
    s: 0
    zyg: 
      - !!perl/hash:RE_assertion 
        assert: "?"
        min: 0
        re: !!perl/hash:RE_method_re 
          a: 0
          dba: metachar__S_569var
          i: 0
          min: 0
          name: before
          nobind: 1
          r: 1
          re: !!perl/hash:RE 
            decl: []

            min: 12346
            re: !!perl/hash:RE_sequence 
              a: 0
              dba: metachar__S_569var
              i: 0
              min: 12346
              r: 1
              s: 0
              zyg: 
                - !!perl/hash:RE_method 
                  a: 0
                  dba: metachar__S_569var
                  i: 0
                  min: 12345
                  name: sigil
                  r: 1
                  rest: ''
                  s: 0
                - !!perl/hash:RE_meta 
                  a: 0
                  dba: metachar__S_569var
                  i: 0
                  min: 1
                  r: 1
                  s: 0
                  text: \w
          s: 0
      - !!perl/hash:RE_method 
        min: 0
        name: panic
        nobind: 1
        rest: ("Can't interpolate variable in Perl 5 regex")
nibbler: !!perl/hash:RE 
  decl: 
    - !!perl/hash:RE_decl 
      a: 0
      dba: nibbler
      i: 0
      max: 0
      min: 0
      r: 1
      s: 1
      text: my $ignorecase is context<rw> = $*ignorecase // 0
  kind: rule
  min: 12345
  pkg: ~
  re: !!perl/hash:RE_sequence 
    a: 0
    dba: nibbler
    i: 0
    min: 12345
    r: 1
    s: 1
    zyg: 
      - !!perl/hash:RE_method 
        min: 0
        name: ws
        nobind: 1
        noquant: 1
        rest: ''
      - !!perl/hash:RE_method 
        a: 0
        dba: nibbler
        i: 0
        min: 12345
        name: EXPR
        r: 1
        rest: ''
        s: 1
      - !!perl/hash:RE_method 
        min: 0
        name: ws
        nobind: 1
        noquant: 1
        rest: ''
p5mod: !!perl/hash:RE 
  decl: []

  kind: token
  min: 0
  pkg: ~
  re: !!perl/hash:RE_quantified_atom 
    atom: !!perl/hash:RE_cclass 
      a: 0
      dba: p5mod
      i: 0
      min: 1
      r: 1
      s: 0
      text: "[imox]"
    min: 0
    quant: 
      - "*"
      - ":"
      - ''
      - 0
p5mods: !!perl/hash:RE 
  decl: []

  kind: token
  min: 12345
  pkg: ~
  re: !!perl/hash:RE_sequence 
    a: 0
    dba: p5mods
    i: 0
    min: 12345
    r: 1
    s: 0
    zyg: 
      - !!perl/hash:RE_bindnamed 
        a: 0
        atom: !!perl/hash:RE_method 
          a: 0
          dba: p5mods
          i: 0
          min: 12345
          name: p5mod
          nobind: 1
          r: 1
          rest: ''
          s: 0
        dba: p5mods
        i: 0
        min: 12345
        r: 1
        s: 0
        var: 'on'
      - !!perl/hash:RE_quantified_atom 
        atom: !!perl/hash:RE_bracket 
          decl: []

          min: 12346
          re: !!perl/hash:RE_sequence 
            a: 0
            dba: p5mods
            i: 0
            min: 12346
            r: 1
            s: 0
            zyg: 
              - !!perl/hash:RE_string 
                a: 0
                dba: p5mods
                i: 0
                min: 1
                r: 1
                s: 0
                text: "-"
              - !!perl/hash:RE_bindnamed 
                a: 0
                atom: !!perl/hash:RE_method 
                  a: 0
                  dba: p5mods
                  i: 0
                  min: 12345
                  name: p5mod
                  nobind: 1
                  r: 1
                  rest: ''
                  s: 0
                dba: p5mods
                i: 0
                min: 12345
                r: 1
                s: 0
                var: 'off'
        min: 0
        quant: 
          - "?"
          - ":"
          - ''
          - 0
quantified_atom: !!perl/hash:RE 
  decl: []

  kind: token
  min: 24690
  pkg: ~
  re: !!perl/hash:RE_sequence 
    a: 0
    dba: quantified_atom
    i: 0
    min: 24690
    r: 1
    s: 0
    zyg: 
      - !!perl/hash:RE_assertion 
        assert: "!"
        min: 0
        re: !!perl/hash:RE_method 
          a: 0
          dba: quantified_atom
          i: 0
          min: 12345
          name: stopper
          nobind: 1
          r: 1
          rest: ''
          s: 0
      - !!perl/hash:RE_assertion 
        assert: "!"
        min: 0
        re: !!perl/hash:RE_method 
          a: 0
          dba: quantified_atom
          i: 0
          min: 12345
          name: regex_infix
          nobind: 1
          r: 1
          rest: ''
          s: 0
      - !!perl/hash:RE_method 
        a: 0
        dba: quantified_atom
        i: 0
        min: 12345
        name: atom
        r: 1
        rest: ''
        s: 0
      - !!perl/hash:RE_quantified_atom 
        atom: !!perl/hash:RE_bracket 
          decl: []

          min: 24690
          re: !!perl/hash:RE_sequence 
            a: 0
            dba: quantified_atom
            i: 0
            min: 24690
            r: 1
            s: 0
            zyg: 
              - !!perl/hash:RE_method 
                a: 0
                dba: quantified_atom
                i: 0
                min: 12345
                name: ws
                nobind: 1
                r: 1
                rest: ''
                s: 0
              - !!perl/hash:RE_method 
                a: 0
                dba: quantified_atom
                i: 0
                min: 12345
                name: quantifier
                r: 1
                rest: ''
                s: 0
        min: 0
        quant: 
          - "?"
          - ":"
          - ''
          - 0
      - !!perl/hash:RE_method 
        a: 0
        dba: quantified_atom
        i: 0
        min: 12345
        name: ws
        nobind: 1
        r: 1
        rest: ''
        s: 0
quantifier__S_601Star: !!perl/hash:RE 
  decl: []

  kind: token
  min: 24690
  pkg: ~
  re: !!perl/hash:RE_sequence 
    a: 0
    dba: quantifier__S_601Star
    i: 0
    min: 24690
    r: 1
    s: 0
    zyg: 
      - !!perl/hash:RE_method 
        a: 0
        dba: quantifier__S_601Star
        i: 0
        min: 12345
        name: sym
        r: 1
        rest: ''
        s: 0
        sym: "*"
      - !!perl/hash:RE_method 
        a: 0
        dba: quantifier__S_601Star
        i: 0
        min: 12345
        name: quantmod
        r: 1
        rest: ''
        s: 0
quantifier__S_602Plus: !!perl/hash:RE 
  decl: []

  kind: token
  min: 24690
  pkg: ~
  re: !!perl/hash:RE_sequence 
    a: 0
    dba: quantifier__S_602Plus
    i: 0
    min: 24690
    r: 1
    s: 0
    zyg: 
      - !!perl/hash:RE_method 
        a: 0
        dba: quantifier__S_602Plus
        i: 0
        min: 12345
        name: sym
        r: 1
        rest: ''
        s: 0
        sym: +
      - !!perl/hash:RE_method 
        a: 0
        dba: quantifier__S_602Plus
        i: 0
        min: 12345
        name: quantmod
        r: 1
        rest: ''
        s: 0
quantifier__S_603Question: !!perl/hash:RE 
  decl: []

  kind: token
  min: 24690
  pkg: ~
  re: !!perl/hash:RE_sequence 
    a: 0
    dba: quantifier__S_603Question
    i: 0
    min: 24690
    r: 1
    s: 0
    zyg: 
      - !!perl/hash:RE_method 
        a: 0
        dba: quantifier__S_603Question
        i: 0
        min: 12345
        name: sym
        r: 1
        rest: ''
        s: 0
        sym: "?"
      - !!perl/hash:RE_method 
        a: 0
        dba: quantifier__S_603Question
        i: 0
        min: 12345
        name: quantmod
        r: 1
        rest: ''
        s: 0
quantifier__S_604Cur_Ly: !!perl/hash:RE 
  decl: []

  kind: token
  min: 12348
  pkg: ~
  re: !!perl/hash:RE_sequence 
    a: 0
    dba: quantifier__S_604Cur_Ly
    i: 0
    min: 12348
    r: 1
    s: 0
    zyg: 
      - !!perl/hash:RE_string 
        a: 0
        dba: quantifier__S_604Cur_Ly
        i: 0
        min: 1
        r: 1
        s: 0
        text: "{"
      - !!perl/hash:RE_quantified_atom 
        atom: !!perl/hash:RE_meta 
          a: 0
          dba: quantifier__S_604Cur_Ly
          i: 0
          min: 1
          r: 1
          s: 0
          text: \d
        min: 1
        quant: 
          - +
          - ":"
          - ''
          - 1
      - !!perl/hash:RE_quantified_atom 
        atom: !!perl/hash:RE_bracket 
          decl: []

          min: 1
          re: !!perl/hash:RE_sequence 
            a: 0
            dba: quantifier__S_604Cur_Ly
            i: 0
            min: 1
            r: 1
            s: 0
            zyg: 
              - !!perl/hash:RE_string 
                a: 0
                dba: quantifier__S_604Cur_Ly
                i: 0
                min: 1
                r: 1
                s: 0
                text: ","
              - !!perl/hash:RE_quantified_atom 
                atom: !!perl/hash:RE_meta 
                  a: 0
                  dba: quantifier__S_604Cur_Ly
                  i: 0
                  min: 1
                  r: 1
                  s: 0
                  text: \d
                min: 0
                quant: 
                  - "*"
                  - ":"
                  - ''
                  - 0
        min: 0
        quant: 
          - "?"
          - ":"
          - ''
          - 0
      - !!perl/hash:RE_string 
        a: 0
        dba: quantifier__S_604Cur_Ly
        i: 0
        min: 1
        r: 1
        s: 0
        text: "}"
      - !!perl/hash:RE_method 
        a: 0
        dba: quantifier__S_604Cur_Ly
        i: 0
        min: 12345
        name: quantmod
        r: 1
        rest: ''
        s: 0
quantmod: !!perl/hash:RE 
  decl: []

  kind: token
  min: 0
  pkg: ~
  re: !!perl/hash:RE_quantified_atom 
    atom: !!perl/hash:RE_bracket 
      decl: []

      min: 1
      re: &1 !!perl/hash:RE_any 
        a: 0
        altname: quantmod_01
        dba: quantmod
        i: 0
        min: 1
        name: quantmod_01
        r: 1
        s: 0
        zyg: 
          - !!perl/hash:RE_string 
            a: 0
            alt: quantmod_01 0
            dba: quantmod
            i: 0
            min: 1
            r: 1
            s: 0
            text: "?"
          - !!perl/hash:RE_string 
            a: 0
            alt: quantmod_01 1
            dba: quantmod
            i: 0
            min: 1
            r: 1
            s: 0
            text: +
    min: 0
    quant: 
      - "?"
      - ":"
      - ''
      - 0
quantmod_01: *1
regex_infix__S_558Vert: !!perl/hash:RE 
  decl: []

  kind: token
  min: 12345
  pkg: STD::Junctive_or
  re: !!perl/hash:RE_method 
    a: 0
    dba: regex_infix__S_558Vert
    i: 0
    min: 12345
    name: sym
    r: 1
    rest: ''
    s: 0
    sym: "|"
rx: !!perl/hash:RE 
  decl: []

  kind: token
  min: 12345
  pkg: ~
  re: !!perl/hash:RE_sequence 
    a: 0
    dba: rx
    i: 0
    min: 12345
    r: 1
    s: 0
    zyg: 
      - !!perl/hash:RE_method 
        a: 0
        dba: rx
        i: 0
        min: 12345
        name: nibbler
        r: 1
        rest: ''
        s: 0
      - !!perl/hash:RE_bracket 
        decl: []

        min: 0
        re: !!perl/hash:RE_first 
          a: 0
          dba: rx
          i: 0
          min: 0
          r: 1
          s: 0
          zyg: 
            - !!perl/hash:RE_assertion 
              assert: "?"
              min: 0
              re: !!perl/hash:RE_method_re 
                a: 0
                dba: rx
                i: 0
                min: 0
                name: before
                nobind: 1
                r: 1
                re: !!perl/hash:RE 
                  decl: []

                  min: 1
                  re: !!perl/hash:RE_string 
                    a: 0
                    dba: rx
                    i: 0
                    min: 1
                    r: 1
                    s: 0
                    text: )
                s: 0
            - !!perl/hash:RE_method 
              min: 0
              name: panic
              nobind: 1
              rest: ("Unable to parse Perl 5 regex; couldn't find right parenthesis")
termish: !!perl/hash:RE 
  decl: []

  kind: token
  min: 24690
  pkg: ~
  re: !!perl/hash:RE_sequence 
    a: 0
    dba: termish
    i: 0
    min: 24690
    r: 1
    s: 0
    zyg: 
      - !!perl/hash:RE_method 
        a: 0
        dba: termish
        i: 0
        min: 12345
        name: ws
        nobind: 1
        r: 1
        rest: ''
        s: 0
      - !!perl/hash:RE_bindnamed 
        a: 0
        atom: !!perl/hash:RE_quantified_atom 
          atom: !!perl/hash:RE_method 
            a: 0
            dba: termish
            i: 0
            min: 12345
            name: quantified_atom
            r: 1
            rest: ''
            s: 0
          min: 12345
          nobind: 1
          quant: 
            - +
            - ":"
            - ''
            - 1
        dba: termish
        i: 0
        min: 12345
        r: 1
        s: 0
        var: noun
ws: !!perl/hash:RE 
  decl: []

  kind: token
  min: 0
  pkg: ~
  re: !!perl/hash:RE_first 
    a: 0
    dba: ws
    i: 0
    min: 0
    r: 1
    s: 0
    zyg: 
      - !!perl/hash:RE_assertion 
        assert: "?"
        min: 0
        re: !!perl/hash:RE_block 
          a: 0
          context: bool
          dba: ws
          i: 0
          min: 0
          nobind: 1
          r: 1
          s: 0
          text: " $*sigspace "
      - !!perl/hash:RE_quantified_atom 
        atom: !!perl/hash:RE_bracket 
          decl: []

          min: 12345
          re: !!perl/hash:RE_sequence 
            a: 0
            dba: ws
            i: 0
            min: 12345
            r: 1
            s: 0
            zyg: 
              - !!perl/hash:RE_assertion 
                assert: "?"
                min: 0
                re: !!perl/hash:RE_method_re 
                  a: 0
                  dba: ws
                  i: 0
                  min: 0
                  name: before
                  nobind: 1
                  r: 1
                  re: !!perl/hash:RE 
                    decl: []

                    min: 1
                    re: &10 !!perl/hash:RE_any 
                      a: 0
                      altname: ws_03
                      dba: ws
                      i: 0
                      min: 1
                      name: ws_03
                      r: 1
                      s: 0
                      zyg: 
                        - !!perl/hash:RE_meta 
                          a: 0
                          alt: ws_03 0
                          dba: ws
                          i: 0
                          min: 1
                          r: 1
                          s: 0
                          text: \s
                        - !!perl/hash:RE_string 
                          a: 0
                          alt: ws_03 1
                          dba: ws
                          i: 0
                          min: 1
                          r: 1
                          s: 0
                          text: "#"
                  s: 0
              - !!perl/hash:RE_method 
                a: 0
                dba: ws
                i: 0
                min: 12345
                name: nextsame
                nobind: 1
                r: 1
                rest: ''
                s: 0
        min: 0
        quant: 
          - "?"
          - ":"
          - ''
          - 0
ws_03: *10
RETREE_END
}
} ## end grammar

#################
# Symbol tables #
#################

use NAME;
use STASH;

## method newpad
sub newpad {
my $self = shift;


my $outer = $::CURPAD;
my $line = $self->lineof($self->{'_pos'});
$::CURPAD = STASH->new(
_file => $::FILE, _line => $line,
_cf => $::FILE->{'name'} . ':' . $line,
);
$::CURPAD->{'OUTER::'} = $outer if $outer;
$self;
}

## method finishpad($siggy = $*CURPAD.{'$?GOTSIG'}//0)
sub finishpad {
my $self = shift;
my $siggy = shift() // $::CURPAD->{'$?GOTSIG'}//0;


my $line = $self->lineof($self->{'_pos'});
$::CURPAD->{'$_'} //= NAME->new( name => '$_', file => $::FILE, line => $line );
$::CURPAD->{'$/'} //= NAME->new( name => '$/', file => $::FILE, line => $line );
$::CURPAD->{'$!'} //= NAME->new( name => '$!', file => $::FILE, line => $line );
if (not $siggy) {
$::CURPAD->{'@_'} = NAME->new( name => '@_', file => $::FILE, line => $line );
$::CURPAD->{'%_'} = NAME->new( name => '%_', file => $::FILE, line => $line );
$::CURPAD->{'$?GOTSIG'} = '';
}
$self;
}

## method is_name ($n, $curpad = $*CURPAD)
sub is_name {
my $self = shift;
my $n = shift;
my $curpad = shift() // $::CURPAD;


my $name = $n;
say "is_name $name" if $::DEBUG & DEBUG::symtab;

my $curpkg = $::CURPKG;
return 1 if $name =~ qr/\:\:\(/;
my @components = $self->canonicalize_name($name);
if (@components > 1) {
return 1 if $components[0] eq 'COMPILING::';
return 1 if $components[0] eq 'CALLER::';
return 1 if $components[0] eq 'CONTEXT::';
if ($curpkg = $self->find_top_pkg($components[0])) {
say "Found lexical package ", $components[0] if $::DEBUG & DEBUG::symtab;
shift @components;
}
else {
say "Looking for GLOBAL::<$name>" if $::DEBUG & DEBUG::symtab;
$curpkg = $::GLOBAL;
}
while (@components > 1) {
my $pkg = shift @components;
$curpkg = $curpkg->{$pkg};
return 0 unless $curpkg;
say "Found $pkg okay" if $::DEBUG & DEBUG::symtab;
}
}
$name = shift(@components)//'';
say "Looking for $name" if $::DEBUG & DEBUG::symtab;
return 1 if $name eq '';
my $pad = $curpad;
while ($pad) {
say "Looking in ", $pad->cf if $::DEBUG & DEBUG::symtab;
if ($pad->{$name}) {
say "Found $name in ", $pad->cf if $::DEBUG & DEBUG::symtab;
return 1;
}
$pad = $pad->{'OUTER::'};
}
return 1 if $curpkg->{$name};
return 1 if $::GLOBAL->{$name};
say "$name not found" if $::DEBUG & DEBUG::symtab;
return 0;
}

## method find_stash ($n, $curpad = $*CURPAD)
sub find_stash {
my $self = shift;
my $n = shift;
my $curpad = shift() // $::CURPAD;


my $name = $n;
say "find_stash $name" if $::DEBUG & DEBUG::symtab;

my $curpkg = $::CURPKG;
return () if $name =~ qr/\:\:\(/;
my @components = $self->canonicalize_name($name);
if (@components > 1) {
return () if $components[0] eq 'COMPILING::';
return () if $components[0] eq 'CALLER::';
return () if $components[0] eq 'CONTEXT::';
if ($curpkg = $self->find_top_pkg($components[0])) {
say "Found lexical package ", $components[0] if $::DEBUG & DEBUG::symtab;
shift @components;
}
else {
say "Looking for GLOBAL::<$name>" if $::DEBUG & DEBUG::symtab;
$curpkg = $::GLOBAL;
}
while (@components > 1) {
my $pkg = shift @components;
$curpkg = $curpkg->{$pkg};
return () unless $curpkg;
say "Found $pkg okay" if $::DEBUG & DEBUG::symtab;
}
}
$name = shift(@components)//'';
return () if $name eq '';

my $pad = $curpad;
while ($pad) {
return $_ if $_ = $pad->{$name};
$pad = $pad->{'OUTER::'};
}
return $_ if $_ = $curpkg->{$name};
return $_ if $_ = $::GLOBAL->{$name};
return ();
}

## method find_top_pkg ($name)
sub find_top_pkg {
my $self = shift;
my $name = shift;


say "find_top_pkg $name" if $::DEBUG & DEBUG::symtab;
if ($name eq 'OUR::') {
return $::CURPKG;
}
elsif ($name eq 'MY::') {
return $::CURPAD;
}
elsif ($name eq 'CORE::') {
return $::CORE;
}
elsif ($name eq 'SETTING::') {
return $::SETTING;
}
elsif ($name eq 'UNIT::') {
return $::UNIT;
}
# everything is somewhere in lexical scope (we hope)
my $pad = $::CURPAD;
while ($pad) {
return $pad->{$name} if $pad->{$name};
$pad = $pad->{'OUTER::'};
}
return 0;
}

## method add_name ($name)
sub add_name {
my $self = shift;
my $name = shift;


my $scope = $::SCOPE // 'our';
say "Adding $::SCOPE $name in $::PKGNAME" if $::DEBUG & DEBUG::symtab;
if ($scope eq 'augment' or $scope eq 'supersede') {
$self->is_name($name) or $self->worry("Can't $scope something that doesn't exist");
}
else {
if ($scope eq 'our' or $scope eq 'constant') {
$self->add_our_name($name);
}
else {
$self->add_my_name($name);
}
}
$self;
}

## method add_my_name ($n, $d, $p)
sub add_my_name {
my $self = shift;
my $n = shift;
my $d = shift;
my $p = shift;


my $name = $n;
say "add_my_name $name" if $::DEBUG & DEBUG::symtab;
return $self if $name =~ qr/\:\:\(/;
my $curstash = $::CURPAD;
my @components = $self->canonicalize_name($name);
while (@components > 1) {
my $pkg = shift @components;
my $newstash = $curstash->{$pkg} //= STASH->new( 'PARENT::' => $curstash );
say "Adding new package $pkg in ", $curstash->cf if $::DEBUG & DEBUG::symtab;
$curstash = $newstash;
}
$name = shift @components;
return $self unless defined $name and $name ne '';
return $self if $name eq '$' or $name eq '@' or $name eq '%';

# This may just be a lexical alias to "our" and such,
# so reuse $::DECLARAND pointer if it's there.
my $declaring = $d // NAME->new(
xpad => $::CURPAD,
name => $name,
file => $::FILE, line => $self->line,
mult => ($::MULTINESS||'only'),
);
if (exists $curstash->{$name} and $curstash->{$name}{'line'}) {
say "$name exists, curstash = ", $curstash->cf if $::DEBUG & DEBUG::symtab;
my $omult = $curstash->{$name}{'mult'} // '';
if ($declaring == $curstash->{$name}) {}  # already did this, probably enum
elsif ($::SCOPE eq 'use') {}
elsif ($::MULTINESS eq 'multi' and $omult ne 'only') {}
elsif ($omult eq 'proto') {}
elsif ($::PKGDECL eq 'role') {}
else {
my $old = $curstash->{$name};
my $ofile = $old->file // 0;
my $oline = $old->line // '???';
my $loc = '';
if ($ofile) {
if ($ofile != $::FILE) {
my $oname = $ofile->{'name'};
$loc = " (from $oname line $oline)";
}
else {
$loc = " (from line $oline)";
}
}
if ($name =~ qr/^\w/) {
$self->panic("Illegal redeclaration of lexical symbol $name$loc");
}
elsif ($name =~ s/^\&//) {
$self->panic("Illegal redeclaration of lexical routine $name$loc");
}
else {  # XXX eventually check for conformant arrays here
$self->worry("Useless redeclaration of lexical variable $name$loc");
}
}
}
else {
$::DECLARAND = $curstash->{$name} = $declaring;
if ($name =~ qr/^\w+$/ and $::SCOPE ne 'constant') {
$curstash->{"&$name"} //= $curstash->{$name};
$curstash->{$name . '::'} //= ($p // STASH->new( 'PARENT::' => $curstash, _file => $::FILE, _line => $self->line ));
}
}
$self;
}

## method add_our_name ($n)
sub add_our_name {
my $self = shift;
my $n = shift;


my $name = $n;
say "add_our_name $name " . $::PKGNAME if $::DEBUG & DEBUG::symtab;
return $self if $name =~ qr/\:\:\(/;
my $curstash = $::CURPKG;
say "curstash $curstash global $GLOBAL ", join ' ', %$::GLOBAL if $::DEBUG & DEBUG::symtab;
$name =~ s/\:ver\<.*?\>//;
$name =~ s/\:auth\<.*?\>//;
my @components = $self->canonicalize_name($name);
if (@components > 1) {
my $c = $self->find_top_pkg($components[0]);
if ($c) {
shift @components;
$curstash = $c;
}
}
while (@components > 1) {
my $pkg = shift @components;
my $newstash = $curstash->{$pkg} //= STASH->new('PARENT::' => $curstash );
$curstash = $newstash;
say "Adding new package $pkg in $curstash " if $::DEBUG & DEBUG::symtab;
}
$name = shift @components;
return $self unless defined $name and $name ne '';

my $declaring = $::DECLARAND // NAME->new(
xpad => $::CURPAD,
name => $name,
file => $::FILE, line => $self->line,
mult => ($::MULTINESS||'only'),
);
if (exists $curstash->{$name} and $curstash->{$name}{'line'}) {
my $omult = $curstash->{$name}{'mult'} // '';
if ($declaring == $curstash->{$name}) {} # already did it somehow
elsif ($::SCOPE eq 'use') {}
elsif ($::MULTINESS eq 'multi' and $omult ne 'only') {}
elsif ($omult eq 'proto') {}
elsif ($::PKGDECL eq 'role') {}
else {
my $old = $curstash->{$name};
my $ofile = $old->file // 0;
my $oline = $old->line // '???';
my $loc = '';
if ($ofile) {
if ($ofile != $::FILE) {
my $oname = $ofile->{'name'};
$loc = " (from $oname line $oline)";
}
else {
$loc = " (from line $oline)";
}
}
if ($name =~ qr/^\w/) {
$self->panic("Illegal redeclaration of package symbol $name$loc");
}
elsif ($name =~ s/^\&//) {
$self->panic("Illegal redeclaration of package routine $name$loc");
}
else {  # XXX eventually check for conformant arrays here
# (redeclaration of identical package vars is not useless)
}
}
}
else {
$::DECLARAND = $curstash->{$name} = $declaring;
if ($name =~ qr/^\w+$/) {
$curstash->{"&$name"} //= $declaring;
$curstash->{$name . '::'} //= STASH->new( 'PARENT::' => $curstash, _file => $::FILE, _line => $self->line );
}
}
$self->add_my_name($n, $declaring, $curstash->{$name . '::'}) if $curstash == $::CURPKG;   # the lexical alias
$self;
}

## method add_mystery ($name,$pos)
sub add_mystery {
my $self = shift;
my $name = shift;
my $pos = shift;


if (not $self->is_known($name)) {
say "add_mystery $name $::CURPAD" if $::DEBUG & DEBUG::symtab;
$::MYSTERY{$name}->{'pad'} = $::CURPAD;
$::MYSTERY{$name}->{'line'} .= $self->lineof($pos) . ' ';
}
else {
say "$name is known" if $::DEBUG & DEBUG::symtab;
}
$self;
}

## method load_setting ($setting)
sub load_setting {
my $self = shift;
my $setting = shift;


@PKGS = ();

$::SETTING = $self->load_pad($setting);
$::CURPAD = $::SETTING;
$::CORE = $::SETTING;
for (1..100) {
my $outerer = $::CORE->{'OUTER::'};
last unless $outerer;
$::CORE = $outerer;
}
if ($::CORE->{'OUTER::'}) {
warn "Internal error: infinite setting loop";
delete $::CORE->{'OUTER::'};
}
$::GLOBAL = $::CORE->{'GLOBAL::'} = STASH->new(
_file => $::FILE, _line => 1,
_cf => 'GLOBAL',
);
$::CURPKG = $::GLOBAL;
}

## method is_known ($n, $curpad = $*CURPAD)
sub is_known {
my $self = shift;
my $n = shift;
my $curpad = shift() // $::CURPAD;


my $name = $n;
say "is_known $name" if $::DEBUG & DEBUG::symtab;
return 1 if $::QUASIMODO;
return 1 if $::CURPKG->{$name};
my $curpkg = $::CURPKG;
my @components = $self->canonicalize_name($name);
if (@components > 1) {
return 1 if $components[0] eq 'COMPILING::';
return 1 if $components[0] eq 'CALLER::';
return 1 if $components[0] eq 'CONTEXT::';
if ($curpkg = $self->find_top_pkg($components[0])) {
say "Found lexical package ", $components[0] if $::DEBUG & DEBUG::symtab;
shift @components;
}
else {
say "Looking for GLOBAL::<$name>" if $::DEBUG & DEBUG::symtab;
$curpkg = $::GLOBAL;
}
while (@components > 1) {
my $pkg = shift @components;
say "Looking for $pkg in $curpkg ", join ' ', keys(%$curpkg) if $::DEBUG & DEBUG::symtab;
$curpkg = $curpkg->{$pkg};
return 0 unless $curpkg;
say "Found $pkg okay, now in $curpkg " if $::DEBUG & DEBUG::symtab;
}
}

$name = shift(@components)//'';
say "Final component is $name" if $::DEBUG & DEBUG::symtab;
return 1 if $name eq '';
if ($curpkg->{$name}) {
say "Found" if $::DEBUG & DEBUG::symtab;
return 1;
}

my $pad = $curpad;
while ($pad) {
say "Looking in ", $pad->cf if $::DEBUG & DEBUG::symtab;
if ($pad->{$name}) {
say "Found $name in ", $pad->cf if $::DEBUG & DEBUG::symtab;
return 1;
}
say $pad->{'OUTER::'} // "No OUTER" if $::DEBUG & DEBUG::symtab;
$pad = $pad->{'OUTER::'};
}
say "Not Found" if $::DEBUG & DEBUG::symtab;

return 0;
}


## method add_routine ($name)
sub add_routine {
my $self = shift;
my $name = shift;


my $vname = '&' . $name;
$self->add_name($vname);
$self;
}

## method add_variable ($name)
sub add_variable {
my $self = shift;
my $name = shift;


if (($::SCOPE//'') eq 'our') {
$self->add_our_variable($name);
}
else {
$self->add_my_variable($name);
}
$self;
}

## method add_my_variable ($n)
sub add_my_variable {
my $self = shift;
my $n = shift;


my $name = $n;
say "add_my_variable $name" if $::DEBUG & DEBUG::symtab;
if (substr($name, 0, 1) eq '&') {
$self->add_my_name($name);
if ($name =~ s/\:\(.*//) {
$self->add_my_name($name);
}
return $self;
}
$self->add_my_name($name);
$self;
}

## method add_our_variable ($name)
sub add_our_variable {
my $self = shift;
my $name = shift;


$self->add_our_name($name);
$self;
}

## method check_variable ($variable)
sub check_variable {
my $self = shift;
my $variable = shift;


my $name = $variable->Str;
say "check_variable $name" if $::DEBUG & DEBUG::symtab;
my ($sigil, $twigil, $first) = $name =~ qr/(\W)(\W?)(.?)/;
given ($twigil) {
when ('') {
my $ok = 0;
$ok = 1 if $name =~ qr/::/;
$ok ||= $::IN_DECL;
$ok ||= $sigil eq '&';
$ok ||= $first lt 'A';
$ok ||= $self->is_known($name);
if (not $ok) {
$variable->worry("Variable $name is not predeclared");
}
}
when ('^') {
local $::MULTINESS = 'multi';
my $siggy = $::CURPAD->{'$?GOTSIG'}//'';
if ($siggy) { $variable->panic("Placeholder variable $name cannot override existing signature $siggy"); }
$self->add_my_variable($name);
}
when (':') {
local $::MULTINESS = 'multi';
$self->add_my_variable($name);
}
when ('~') {
return $::LANG{substr($name,2)};
}
when ('?') {
if ($name =~ qr/\:\:/) {
my ($first) = $self->canonicalize_name($name);
$variable->worry("Unrecognized variable: $name") unless $first =~ qr/^(CALLER|CONTEXT|OUTER|MY|SETTING|CORE)$/;
}
else {
# search upward through languages to STD
my $v = $variable->lookup_compiler_var($name);
$variable->{'value'} = $v if $v;
}
}
}
$self;
}

## method lookup_compiler_var($name)
sub lookup_compiler_var {
my $self = shift;
my $name = shift;



# see if they did "constant $?FOO = something" earlier
my $lex = $::CURPAD->{$name};
if (defined $lex) {
if (exists $lex->{'thunk'}) {
return $lex->{'thunk'}->();
}
else {
return $lex->{'value'};
}
}

given ($name) {
when ('$?FILE')     { return $::FILE->{'name'}; }
when ('$?LINE')     { return $self->lineof($self->{'_pos'}); }
when ('$?POSITION') { return $self->{'_pos'}; }

when ('$?LANG')    { return \%::LANG; }

when ('$?STASH')    { return $::CURPAD; }

when ('$?PACKAGE')  { return $::CURPKG; }
when ('$?MODULE')   { return $::CURPKG; } #  XXX should scan
when ('$?CLASS')    { return $::CURPKG; } #  XXX should scan
when ('$?ROLE')     { return $::CURPKG; } #  XXX should scan
when ('$?GRAMMAR')  { return $::CURPKG; } #  XXX should scan

when ('$?PACKAGENAME') { return $::PKGNAME; }

when ('$?OS')       { return 'unimpl'; }
when ('$?DISTRO')   { return 'unimpl'; }
when ('$?VM')       { return 'unimpl'; }
when ('$?XVM')      { return 'unimpl'; }
when ('$?PERL')     { return 'unimpl'; }

when ('$?USAGE')    { return 'unimpl'; }

when ('&?ROUTINE')  { return 'unimpl'; }
when ('&?BLOCK')    { return 'unimpl'; }

when ('%?CONFIG')    { return 'unimpl'; }
when ('%?DEEPMAGIC') { return 'unimpl'; }

# (derived grammars should default to nextsame, terminating here)
default { $self->worry("Unrecognized variable: $name"); return 0; }
}
}

####################
# Service Routines #
####################

# token panic (Str $s) { <commit> <fail($s)> }

## method panic (Str $s)
sub panic {
my $self = shift;
my $s = shift;


my $m;
my $here = $self;

# Have we backed off recently?
my $highvalid = $self->{'_pos'} <= $::HIGHWATER;

$here = $self->cursor($::HIGHWATER) if $highvalid;

my $first = $here->lineof($::LAST_NIBBLE->{'_from'});
my $last = $here->lineof($::LAST_NIBBLE->{'_pos'});
if ($first != $last) {
if ($here->lineof($here->{'_pos'}) == $last) {
$m .= "\n(Possible runaway string from line $first)";
}
else {
$first = $here->lineof($::LAST_NIBBLE_MULTILINE->{'_from'});
$last = $here->lineof($::LAST_NIBBLE_MULTILINE->{'_pos'});
# the bigger the string (in lines), the further back we suspect it
if ($here->lineof($here->{'_pos'}) - $last < $last - $first)  {
$m .= "\n(Possible runaway string from line $first to line $last)";
}
}
}

$m .= "\n" . $s;

if ($highvalid) {
$m .= $::HIGHMESS if $::HIGHMESS;
$::HIGHMESS = $m;
}
else {
# not in backoff, so at "bleeding edge", as it were... therefore probably
# the exception will be caught and re-panicked later, so remember message
$::HIGHMESS .= "\n" . $s;
}

$m .= $here->locmess;

if ($highvalid and %$::HIGHEXPECT) {
my @keys = sort keys %$::HIGHEXPECT;
if (@keys > 1) {
$m .= "\n    expecting any of:\n\t" . join("\n\t", sort keys %$::HIGHEXPECT);
}
else {
$m .= "\n    expecting @keys" unless $keys[0] eq 'whitespace';
}
}
$m =~ s|Confused|Confused (two terms in a row?)| if $m =~ qr/infix|nofun/;

if (@::WORRIES) {
$m .= "\nOther potential difficulties:\n  " . join( "\n  ", @::WORRIES);
}
$m .= "\n";
$m .= $self->explain_mystery();

die $Cursor::RED . '===' . $Cursor::CLEAR . 'SORRY!' . $Cursor::RED . '===' . $Cursor::CLEAR . $m;
}

## method worry (Str $s)
sub worry {
my $self = shift;
my $s = shift;


push @::WORRIES, $s . $self->locmess;
$self;
}

## method locmess ()
sub locmess {
my $self = shift;


my $pos = $self->{'_pos'};
my $line = $self->lineof($pos);
if ($pos >= @::MEMOS - 2) {
$pos = @::MEMOS - 3;
$line = ($line - 1) . " (EOF)";
}
my $pre = substr($::ORIG, 0, $pos);
$pre = substr($pre, -40, 40);
1 while $pre =~ s!.*\n!!;
$pre = '<BOL>' if $pre eq '';
my $post = substr($::ORIG, $pos, 40);
1 while $post =~ s!(\n.*)!!;
$post = '<EOL>' if $post eq '';
" at " . $::FILE->{'name'} . " line $line:\n------> " . $Cursor::GREEN . $pre . $Cursor::YELLOW . $::PERL6HERE . $Cursor::RED . 
"$post$Cursor::CLEAR";
}

## method line
sub line {
my $self = shift;


$self->lineof($self->{'_pos'});
}

## method lineof ($p)
sub lineof {
my $self = shift;
my $p = shift;


return 1 unless defined $p;
my $line = $::MEMOS[$p]{'L'};
return $line if $line;
$line = 0;
my $pos = 0;
my @text = split(qr/^/,$::ORIG);   # XXX p5ism, should be ^^
for (@text) {
$line++;
$::MEMOS[$pos++]{'L'} = $line
for 1 .. length($_);
}
$::MEMOS[$pos++]{'L'} = $line;
return $::MEMOS[$p]{'L'} // 0;
}

## method SETGOAL
sub SETGOAL {
my $self = shift;

}
## method FAILGOAL (Str $stop, Str $name)
sub FAILGOAL {
my $self = shift;
my $stop = shift;
my $name = shift;


$self->panic("Unable to parse $name; couldn't find final '$stop'");
}

# "when" arg assumes more things will become obsolete after Perl 6 comes out...
## method obs (Str $old, Str $new, Str $when = ' in Perl 6')
sub obs {
my $self = shift;
my $old = shift;
my $new = shift;
my $when = shift() // ' in Perl 6';


%$::HIGHEXPECT = ();
$self->panic("Obsolete use of $old;$when please use $new instead");
}

## method worryobs (Str $old, Str $new, Str $when = ' in Perl 6')
sub worryobs {
my $self = shift;
my $old = shift;
my $new = shift;
my $when = shift() // ' in Perl 6';


$self->worry("Possible obsolete use of $old;$when please use $new instead");
$self;
}

# Since most keys are valid prefix operators or terms, this rule is difficult
# to reach ('say »+«' works), but it's okay as a last-ditch default anyway.
## token term__S_605miscbad (:$sym is context<rw> = <miscbad>)
##      token term:sym<miscbad> {
##          {} <!{ $*QSIGIL }> <infixish> <.badinfix($<infixish>.Str)>
##      }

sub term__S_605miscbad__PEEK { $_[0]->_AUTOLEXpeek('term__S_605miscbad',$retree) }
sub term__S_605miscbad {
my $self = shift;
local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;
my %args = @_;
local $sym = $args{sym} // q(miscbad);


my $C = $self;
my $S = $C->{'_pos'};
$C->{'sym'} = $sym;

$self->_MATCHIFYr($S, "term__S_605miscbad", 
do {
if (my ($C) = (scalar(do {

}, $C))) {
do {
if (my ($C) = ($C->_NOTBEFORE( sub { my $C=shift;
(($C) x !!do {
$::QSIGIL 
})
}))) {
do {
if (my ($C) = ($C->_SUBSUMEr(['infixish'], sub {
my $C = shift;
$C->infixish
}))) {
do { my $M = $C;
$C->badinfix($M->{'infixish'}->Str)
; };
}
else {
();
}
};
}
else {
();
}
};
}
else {
();
}
}
);
}

## method badinfix (Str $bad = $*sym)
sub badinfix {
my $self = shift;
my $bad = shift() // $::sym;


$self->panic("Preceding operator expects term, but found infix $bad instead");
}

## vim: expandtab sw=4 ft=perl6
BEGIN {
$retree = YAML::Syck::Load(<<'RETREE_END');
--- 
POST: !!perl/hash:RE 
  decl: []

  kind: token
  min: 12345
  pkg: ~
  re: !!perl/hash:RE_sequence 
    a: 0
    dba: postfix
    i: 0
    min: 12345
    r: 1
    s: 0
    zyg: 
      - !!perl/hash:RE_assertion 
        assert: "!"
        min: 0
        re: !!perl/hash:RE_method 
          a: 0
          dba: POST
          i: 0
          min: 12345
          name: stdstopper
          nobind: 1
          r: 1
          rest: ''
          s: 0
      - !!perl/hash:RE_assertion 
        assert: "!"
        min: 0
        re: !!perl/hash:RE_block 
          a: 0
          context: bool
          dba: POST
          i: 0
          min: 0
          nobind: 1
          r: 1
          s: 0
          text: " @*MEMOS[$¢.pos]<ws> "
      - !!perl/hash:RE_quantified_atom 
        atom: !!perl/hash:RE_bracket 
          decl: []

          min: 1
          re: &19 !!perl/hash:RE_any 
            a: 0
            altname: POST_01
            dba: POST
            i: 0
            min: 1
            name: POST_01
            r: 1
            s: 0
            zyg: 
              - !!perl/hash:RE_method 
                a: 0
                alt: POST_01 0
                dba: POST
                i: 0
                min: 12345
                name: unsp
                nobind: 1
                r: 1
                rest: ''
                s: 0
              - !!perl/hash:RE_string 
                a: 0
                alt: POST_01 1
                dba: POST
                i: 0
                min: 1
                r: 1
                s: 0
                text: \
        min: 0
        quant: 
          - "?"
          - ":"
          - ''
          - 0
      - !!perl/hash:RE_quantified_atom 
        atom: !!perl/hash:RE_bracket 
          decl: []

          min: 12345
          re: !!perl/hash:RE_sequence 
            a: 0
            dba: POST
            i: 0
            min: 12345
            r: 1
            s: 0
            zyg: 
              - !!perl/hash:RE_quantified_atom 
                atom: !!perl/hash:RE_bracket 
                  decl: []

                  min: 1
                  re: !!perl/hash:RE_sequence 
                    a: 0
                    dba: POST
                    i: 0
                    min: 1
                    r: 1
                    s: 0
                    zyg: 
                      - !!perl/hash:RE_string 
                        a: 0
                        dba: POST
                        i: 0
                        min: 1
                        r: 1
                        s: 0
                        text: .
                      - !!perl/hash:RE_quantified_atom 
                        atom: !!perl/hash:RE_method 
                          a: 0
                          dba: POST
                          i: 0
                          min: 12345
                          name: unsp
                          nobind: 1
                          r: 1
                          rest: ''
                          s: 0
                        min: 0
                        quant: 
                          - "?"
                          - ":"
                          - ''
                          - 0
                min: 0
                quant: 
                  - "?"
                  - ":"
                  - ''
                  - 0
              - !!perl/hash:RE_method 
                a: 0
                dba: POST
                i: 0
                min: 12345
                name: postfix_prefix_meta_operator
                r: 1
                rest: ''
                s: 0
              - !!perl/hash:RE_quantified_atom 
                atom: !!perl/hash:RE_method 
                  a: 0
                  dba: POST
                  i: 0
                  min: 12345
                  name: unsp
                  nobind: 1
                  r: 1
                  rest: ''
                  s: 0
                min: 0
                quant: 
                  - "?"
                  - ":"
                  - ''
                  - 0
        min: 0
        quant: 
          - "*"
          - ":"
          - ''
          - 0
      - !!perl/hash:RE_bracket 
        decl: []

        min: 12345
        re: &47 !!perl/hash:RE_any 
          a: 0
          altname: POST_04
          dba: postfix
          i: 0
          min: 12345
          name: POST_04
          r: 1
          s: 0
          zyg: 
            - !!perl/hash:RE_sequence 
              a: 0
              alt: POST_04 0
              dba: postfix
              i: 0
              min: 12345
              r: 1
              s: 0
              zyg: 
                - !!perl/hash:RE_method 
                  a: 0
                  dba: postfix
                  i: 0
                  min: 12345
                  name: dotty
                  r: 1
                  rest: ''
                  s: 0
                - !!perl/hash:RE_block 
                  a: 0
                  context: void
                  dba: postfix
                  i: 0
                  min: 0
                  r: 1
                  s: 0
                  text: " $<O> = $<dotty><O>;  $<sym> = $<dotty><sym>;  $<~CAPS> = $<dotty><~CAPS>; "
            - !!perl/hash:RE_sequence 
              a: 0
              alt: POST_04 1
              dba: postfix
              i: 0
              min: 12345
              r: 1
              s: 0
              zyg: 
                - !!perl/hash:RE_method 
                  a: 0
                  dba: postfix
                  i: 0
                  min: 12345
                  name: privop
                  r: 1
                  rest: ''
                  s: 0
                - !!perl/hash:RE_block 
                  a: 0
                  context: void
                  dba: postfix
                  i: 0
                  min: 0
                  r: 1
                  s: 0
                  text: " $<O> = $<privop><O>; $<sym> = $<privop><sym>; $<~CAPS> = $<privop><~CAPS>; "
            - !!perl/hash:RE_sequence 
              a: 0
              alt: POST_04 2
              dba: postfix
              i: 0
              min: 12345
              r: 1
              s: 0
              zyg: 
                - !!perl/hash:RE_method 
                  a: 0
                  dba: postfix
                  i: 0
                  min: 12345
                  name: postop
                  r: 1
                  rest: ''
                  s: 0
                - !!perl/hash:RE_block 
                  a: 0
                  context: void
                  dba: postfix
                  i: 0
                  min: 0
                  r: 1
                  s: 0
                  text: " $<O> = $<postop><O>; $<sym> = $<postop><sym>; $<~CAPS> = $<postop><~CAPS>; "
      - !!perl/hash:RE_block 
        a: 0
        context: void
        dba: postfix
        i: 0
        min: 0
        r: 1
        s: 0
        text: " $*LEFTSIGIL = '@'; "
POST_01: *19
POST_04: *47
PRE: !!perl/hash:RE 
  decl: []

  kind: token
  min: 24690
  pkg: ~
  re: !!perl/hash:RE_sequence 
    a: 0
    dba: prefix or meta-prefix
    i: 0
    min: 24690
    r: 1
    s: 0
    zyg: 
      - !!perl/hash:RE_bracket 
        decl: []

        min: 12345
        re: &66 !!perl/hash:RE_any 
          a: 0
          altname: PRE_01
          dba: prefix or meta-prefix
          i: 0
          min: 12345
          name: PRE_01
          r: 1
          s: 0
          zyg: 
            - !!perl/hash:RE_sequence 
              a: 0
              alt: PRE_01 0
              dba: prefix or meta-prefix
              i: 0
              min: 12345
              r: 1
              s: 0
              zyg: 
                - !!perl/hash:RE_method 
                  a: 0
                  dba: prefix or meta-prefix
                  i: 0
                  min: 12345
                  name: prefix
                  r: 1
                  rest: ''
                  s: 0
                - !!perl/hash:RE_block 
                  a: 0
                  context: void
                  dba: prefix or meta-prefix
                  i: 0
                  min: 0
                  r: 1
                  s: 0
                  text: " $<O> = $<prefix><O>; $<sym> = $<prefix><sym> "
                - !!perl/hash:RE_method_internal 
                  args: $S, 'PRE', 'prefix'
                  max: 0
                  min: 0
                  name: _REDUCE
            - !!perl/hash:RE_sequence 
              a: 0
              alt: PRE_01 1
              dba: prefix or meta-prefix
              i: 0
              min: 12345
              r: 1
              s: 0
              zyg: 
                - !!perl/hash:RE_method 
                  a: 0
                  dba: prefix or meta-prefix
                  i: 0
                  min: 12345
                  name: prefix_circumfix_meta_operator
                  r: 1
                  rest: ''
                  s: 0
                - !!perl/hash:RE_block 
                  a: 0
                  context: void
                  dba: prefix or meta-prefix
                  i: 0
                  min: 0
                  r: 1
                  s: 0
                  text: " $<O> = $<prefix_circumfix_meta_operator><O>; $<sym> = $<prefix_circumfix_meta_operator>.Str "
                - !!perl/hash:RE_method_internal 
                  args: $S, 'PRE', 'precircum'
                  max: 0
                  min: 0
                  name: _REDUCE
      - !!perl/hash:RE_quantified_atom 
        atom: !!perl/hash:RE_method 
          a: 0
          dba: prefix or meta-prefix
          i: 0
          min: 12345
          name: prefix_postfix_meta_operator
          r: 1
          rest: ''
          s: 0
        min: 0
        quant: 
          - "*"
          - ":"
          - ''
          - 0
      - !!perl/hash:RE_method_internal 
        args: $S, 'PRE', 'prepost'
        max: 0
        min: 0
        name: _REDUCE
      - !!perl/hash:RE_method 
        a: 0
        dba: prefix or meta-prefix
        i: 0
        min: 12345
        name: ws
        nobind: 1
        r: 1
        rest: ''
        s: 0
PRE_01: *66
apostrophe: !!perl/hash:RE 
  decl: []

  kind: token
  min: 1
  pkg: ~
  re: !!perl/hash:RE_cclass 
    a: 0
    dba: apostrophe
    i: 0
    min: 1
    r: 1
    s: 0
    text: "[ ' \\- ]"
arglist: !!perl/hash:RE 
  decl: 
    - !!perl/hash:RE_decl 
      a: 0
      dba: arglist
      i: 0
      max: 0
      min: 0
      r: 1
      s: 0
      text: my $inv_ok = $*INVOCANT_OK
    - !!perl/hash:RE_decl 
      a: 0
      dba: arglist
      i: 0
      max: 0
      min: 0
      r: 1
      s: 0
      text: my StrPos $endargs is context<rw> = 0
    - !!perl/hash:RE_decl 
      a: 0
      dba: arglist
      i: 0
      max: 0
      min: 0
      r: 1
      s: 0
      text: my $GOAL is context = 'endargs'
    - !!perl/hash:RE_decl 
      a: 0
      dba: arglist
      i: 0
      max: 0
      min: 0
      r: 1
      s: 0
      text: my $QSIGIL is context<rw> = ''
  kind: token
  min: 12345
  pkg: ~
  re: !!perl/hash:RE_sequence 
    a: 0
    dba: argument list
    i: 0
    min: 12345
    r: 1
    s: 0
    zyg: 
      - !!perl/hash:RE_method 
        a: 0
        dba: arglist
        i: 0
        min: 12345
        name: ws
        nobind: 1
        r: 1
        rest: ''
        s: 0
      - !!perl/hash:RE_bracket 
        decl: []

        min: 0
        re: &27 !!perl/hash:RE_any 
          a: 0
          altname: arglist_01
          dba: argument list
          i: 0
          min: 0
          name: arglist_01
          r: 1
          s: 0
          zyg: 
            - !!perl/hash:RE_assertion 
              alt: arglist_01 0
              assert: "?"
              min: 0
              re: !!perl/hash:RE_method 
                a: 0
                dba: argument list
                i: 0
                min: 12345
                name: stdstopper
                nobind: 1
                r: 1
                rest: ''
                s: 0
            - !!perl/hash:RE_sequence 
              a: 0
              alt: arglist_01 1
              dba: argument list
              i: 0
              min: 0
              r: 1
              s: 0
              zyg: 
                - !!perl/hash:RE_method 
                  min: 0
                  name: EXPR
                  rest: (item %list_infix)
                - !!perl/hash:RE_block 
                  a: 0
                  context: void
                  dba: argument list
                  i: 0
                  min: 0
                  r: 1
                  s: 0
                  text: "\n            my $delims = $<EXPR><delims>;\n            for @$delims {\n                if ($_.<sym> // '') eq ':' {\n                    if $inv_ok {\n                        $*INVOCANT_IS = $<EXPR><list>[0];\n                    }\n                }\n            }\n        "
arglist_01: *27
args: !!perl/hash:RE 
  decl: 
    - !!perl/hash:RE_decl 
      a: 0
      dba: args
      i: 0
      max: 0
      min: 0
      r: 1
      s: 0
      text: my $listopish = 0
    - !!perl/hash:RE_decl 
      a: 0
      dba: args
      i: 0
      max: 0
      min: 0
      r: 1
      s: 0
      text: my $GOAL is context = ''
    - !!perl/hash:RE_decl 
      a: 0
      dba: args
      i: 0
      max: 0
      min: 0
      r: 1
      s: 0
      text: my $INVOCANT_OK is context<rw> = 1
    - !!perl/hash:RE_decl 
      a: 0
      dba: args
      i: 0
      max: 0
      min: 0
      r: 1
      s: 0
      text: my $INVOCANT_IS is context<rw>
  kind: token
  min: 0
  pkg: ~
  re: !!perl/hash:RE_sequence 
    a: 0
    dba: "extra arglist after (...):"
    i: 0
    min: 0
    r: 1
    s: 0
    zyg: 
      - !!perl/hash:RE_bracket 
        decl: []

        min: 0
        re: &111 !!perl/hash:RE_any 
          a: 0
          altname: args_01
          dba: argument list
          i: 0
          min: 0
          name: args_01
          r: 1
          s: 0
          zyg: 
            - !!perl/hash:RE_sequence 
              a: 0
              alt: args_01 0
              dba: argument list
              i: 0
              min: 12347
              r: 1
              s: 0
              zyg: 
                - !!perl/hash:RE_string 
                  a: 0
                  dba: argument list
                  i: 0
                  min: 1
                  r: 1
                  s: 0
                  text: (
                - !!perl/hash:RE_meta 
                  a: 0
                  dba: argument list
                  extra: "local $::GOAL = ')' "
                  i: 0
                  min: 0
                  r: 1
                  s: 0
                  text: "::"
                - !!perl/hash:RE_method 
                  a: 0
                  dba: argument list
                  i: 0
                  min: 12345
                  name: semiarglist
                  r: 1
                  rest: ''
                  s: 0
                - !!perl/hash:RE_bracket 
                  decl: []

                  min: 1
                  re: !!perl/hash:RE_first 
                    a: 0
                    dba: argument list
                    i: 0
                    min: 1
                    r: 1
                    s: 0
                    zyg: 
                      - !!perl/hash:RE_string 
                        a: 0
                        dba: argument list
                        i: 0
                        min: 1
                        r: 1
                        s: 0
                        text: )
                      - !!perl/hash:RE_method 
                        min: 0
                        name: FAILGOAL
                        nobind: 1
                        rest: (')' , 'argument list')
                - !!perl/hash:RE_method_internal 
                  args: $S, 'args', 'func args'
                  max: 0
                  min: 0
                  name: _REDUCE
            - !!perl/hash:RE_sequence 
              a: 0
              alt: args_01 1
              dba: argument list
              i: 0
              min: 24692
              r: 1
              s: 0
              zyg: 
                - !!perl/hash:RE_method 
                  a: 0
                  dba: argument list
                  i: 0
                  min: 12345
                  name: unsp
                  nobind: 1
                  r: 1
                  rest: ''
                  s: 0
                - !!perl/hash:RE_string 
                  a: 0
                  dba: argument list
                  i: 0
                  min: 1
                  r: 1
                  s: 0
                  text: (
                - !!perl/hash:RE_meta 
                  a: 0
                  dba: argument list
                  extra: "local $::GOAL = ')' "
                  i: 0
                  min: 0
                  r: 1
                  s: 0
                  text: "::"
                - !!perl/hash:RE_method 
                  a: 0
                  dba: argument list
                  i: 0
                  min: 12345
                  name: semiarglist
                  r: 1
                  rest: ''
                  s: 0
                - !!perl/hash:RE_bracket 
                  decl: []

                  min: 1
                  re: !!perl/hash:RE_first 
                    a: 0
                    dba: argument list
                    i: 0
                    min: 1
                    r: 1
                    s: 0
                    zyg: 
                      - !!perl/hash:RE_string 
                        a: 0
                        dba: argument list
                        i: 0
                        min: 1
                        r: 1
                        s: 0
                        text: )
                      - !!perl/hash:RE_method 
                        min: 0
                        name: FAILGOAL
                        nobind: 1
                        rest: (')' , 'argument list')
                - !!perl/hash:RE_method_internal 
                  args: $S, 'args', 'func args'
                  max: 0
                  min: 0
                  name: _REDUCE
            - !!perl/hash:RE_sequence 
              a: 0
              alt: args_01 2
              dba: argument list
              i: 0
              min: 0
              r: 1
              s: 0
              zyg: 
                - !!perl/hash:RE_block 
                  a: 0
                  context: void
                  dba: argument list
                  i: 0
                  min: 0
                  r: 1
                  s: 0
                  text: " $listopish = 1 "
                - !!perl/hash:RE_quantified_atom 
                  atom: !!perl/hash:RE_bracket 
                    decl: []

                    min: 24690
                    re: !!perl/hash:RE_sequence 
                      a: 0
                      dba: argument list
                      i: 0
                      min: 24690
                      r: 1
                      s: 0
                      zyg: 
                        - !!perl/hash:RE_assertion 
                          assert: "?"
                          min: 0
                          re: !!perl/hash:RE_method_re 
                            a: 0
                            dba: argument list
                            i: 0
                            min: 0
                            name: before
                            nobind: 1
                            r: 1
                            re: !!perl/hash:RE 
                              decl: []

                              min: 1
                              re: !!perl/hash:RE_meta 
                                a: 0
                                dba: argument list
                                i: 0
                                min: 1
                                r: 1
                                s: 0
                                text: \s
                            s: 0
                        - !!perl/hash:RE_assertion 
                          assert: "!"
                          min: 0
                          re: !!perl/hash:RE_block 
                            a: 0
                            context: bool
                            dba: argument list
                            i: 0
                            min: 0
                            nobind: 1
                            r: 1
                            s: 0
                            text: " $istype "
                        - !!perl/hash:RE_method 
                          a: 0
                          dba: argument list
                          i: 0
                          min: 12345
                          name: ws
                          nobind: 1
                          r: 1
                          rest: ''
                          s: 0
                        - !!perl/hash:RE_assertion 
                          assert: "!"
                          min: 0
                          re: !!perl/hash:RE_method 
                            a: 0
                            dba: argument list
                            i: 0
                            min: 12345
                            name: infixstopper
                            nobind: 1
                            r: 1
                            rest: ''
                            s: 0
                        - !!perl/hash:RE_method 
                          a: 0
                          dba: argument list
                          i: 0
                          min: 12345
                          name: arglist
                          r: 1
                          rest: ''
                          s: 0
                  min: 0
                  quant: 
                    - "?"
                    - ":"
                    - ''
                    - 0
      - !!perl/hash:RE_block 
        a: 0
        context: void
        dba: args
        i: 0
        min: 0
        r: 1
        s: 0
        text: " $<invocant> = $*INVOCANT_IS; "
      - !!perl/hash:RE_bracket 
        decl: []

        min: 0
        re: !!perl/hash:RE_first 
          a: 0
          dba: "extra arglist after (...):"
          i: 0
          min: 0
          r: 1
          s: 0
          zyg: 
            - !!perl/hash:RE_assertion 
              assert: "?"
              min: 0
              re: !!perl/hash:RE_block 
                a: 0
                context: bool
                dba: "extra arglist after (...):"
                i: 0
                min: 0
                nobind: 1
                r: 1
                s: 0
                text: " $listopish "
            - !!perl/hash:RE_sequence 
              a: 0
              dba: "extra arglist after (...):"
              i: 0
              min: 12346
              r: 1
              s: 0
              zyg: 
                - !!perl/hash:RE_string 
                  a: 0
                  dba: "extra arglist after (...):"
                  i: 0
                  min: 1
                  r: 1
                  s: 0
                  text: ":"
                - !!perl/hash:RE_assertion 
                  assert: "?"
                  min: 0
                  re: !!perl/hash:RE_method_re 
                    a: 0
                    dba: "extra arglist after (...):"
                    i: 0
                    min: 0
                    name: before
                    nobind: 1
                    r: 1
                    re: !!perl/hash:RE 
                      decl: []

                      min: 1
                      re: !!perl/hash:RE_meta 
                        a: 0
                        dba: "extra arglist after (...):"
                        i: 0
                        min: 1
                        r: 1
                        s: 0
                        text: \s
                    s: 0
                - !!perl/hash:RE_bindnamed 
                  a: 0
                  atom: !!perl/hash:RE_method 
                    a: 0
                    dba: "extra arglist after (...):"
                    i: 0
                    min: 12345
                    name: arglist
                    nobind: 1
                    r: 1
                    rest: ''
                    s: 0
                  dba: "extra arglist after (...):"
                  i: 0
                  min: 12345
                  r: 1
                  s: 0
                  var: moreargs
            - !!perl/hash:RE_block 
              a: 0
              context: void
              dba: "extra arglist after (...):"
              i: 0
              min: 0
              r: 1
              s: 0
              text: " $<O> = {}; "
args_01: *111
babble: !!perl/hash:RE 
  decl: 
    - !!perl/hash:RE_decl 
      a: 0
      dba: babble
      i: 0
      max: 0
      min: 0
      r: 1
      s: 0
      text: my $lang = $l
    - !!perl/hash:RE_decl 
      a: 0
      dba: babble
      i: 0
      max: 0
      min: 0
      r: 1
      s: 0
      text: my $start
    - !!perl/hash:RE_decl 
      a: 0
      dba: babble
      i: 0
      max: 0
      min: 0
      r: 1
      s: 0
      text: my $stop
  kind: token
  min: 12345
  pkg: ~
  re: !!perl/hash:RE_sequence 
    a: 0
    dba: babble
    i: 0
    min: 12345
    r: 1
    s: 0
    zyg: 
      - !!perl/hash:RE_method 
        a: 0
        dba: babble
        i: 0
        min: 12345
        name: ws
        nobind: 1
        r: 1
        rest: ''
        s: 0
      - !!perl/hash:RE_quantified_atom 
        atom: !!perl/hash:RE_bracket 
          decl: []

          min: 24690
          re: !!perl/hash:RE_sequence 
            a: 0
            dba: babble
            i: 0
            min: 24690
            r: 1
            s: 0
            zyg: 
              - !!perl/hash:RE_method 
                a: 0
                dba: babble
                i: 0
                min: 12345
                name: quotepair
                r: 1
                rest: ''
                s: 0
              - !!perl/hash:RE_method 
                a: 0
                dba: babble
                i: 0
                min: 12345
                name: ws
                nobind: 1
                r: 1
                rest: ''
                s: 0
              - !!perl/hash:RE_block 
                a: 0
                context: void
                dba: babble
                i: 0
                min: 0
                r: 1
                s: 0
                text: "\n            my $kv = $<quotepair>[*-1];\n            $lang = $lang.tweak($kv.<k>, $kv.<v>)\n                or self.panic(\"Unrecognized adverb :\" ~ $kv.<k> ~ '(' ~ $kv.<v> ~ ')');\n        "
        min: 0
        quant: 
          - "*"
          - ":"
          - ''
          - 0
      - !!perl/hash:RE_block 
        a: 0
        context: void
        dba: babble
        i: 0
        min: 0
        r: 1
        s: 0
        text: "\n        ($start,$stop) = $¢.peek_delimiters();\n        $lang = $start ne $stop ?? $lang.balanced($start,$stop)\n                                !! $lang.unbalanced($stop);\n        $<B> = [$lang,$start,$stop];\n    "
block: !!perl/hash:RE 
  decl: []

  kind: token
  min: 24690
  pkg: ~
  re: !!perl/hash:RE_sequence 
    a: 0
    dba: scoped block
    i: 0
    min: 24690
    r: 1
    s: 0
    zyg: 
      - !!perl/hash:RE_bracket 
        decl: []

        min: 0
        re: !!perl/hash:RE_first 
          a: 0
          dba: scoped block
          i: 0
          min: 0
          r: 1
          s: 0
          zyg: 
            - !!perl/hash:RE_assertion 
              assert: "?"
              min: 0
              re: !!perl/hash:RE_method_re 
                a: 0
                dba: scoped block
                i: 0
                min: 0
                name: before
                nobind: 1
                r: 1
                re: !!perl/hash:RE 
                  decl: []

                  min: 1
                  re: !!perl/hash:RE_string 
                    a: 0
                    dba: scoped block
                    i: 0
                    min: 1
                    r: 1
                    s: 0
                    text: "{"
                s: 0
            - !!perl/hash:RE_method 
              min: 0
              name: panic
              nobind: 1
              rest: ("Missing block")
      - !!perl/hash:RE_method 
        a: 0
        dba: scoped block
        i: 0
        min: 12345
        name: newpad
        nobind: 1
        r: 1
        rest: ''
        s: 0
      - !!perl/hash:RE_method 
        a: 0
        dba: scoped block
        i: 0
        min: 12345
        name: blockoid
        r: 1
        rest: ''
        s: 0
blockoid: !!perl/hash:RE 
  decl: 
    - !!perl/hash:RE_decl 
      a: 0
      dba: blockoid
      i: 0
      max: 0
      min: 0
      r: 1
      s: 0
      text: temp %*LANG
  kind: token
  min: 12345
  pkg: ~
  re: !!perl/hash:RE_sequence 
    a: 0
    dba: blockoid
    i: 0
    min: 12345
    r: 1
    s: 0
    zyg: 
      - !!perl/hash:RE_method 
        a: 0
        dba: blockoid
        i: 0
        min: 12345
        name: finishpad
        nobind: 1
        r: 1
        rest: ''
        s: 0
      - !!perl/hash:RE_bracket 
        decl: []

        min: 0
        re: &135 !!perl/hash:RE_any 
          a: 0
          altname: blockoid_01
          dba: block
          i: 0
          min: 0
          name: blockoid_01
          r: 1
          s: 0
          zyg: 
            - !!perl/hash:RE_sequence 
              a: 0
              alt: blockoid_01 0
              dba: block
              i: 0
              min: 12347
              r: 1
              s: 0
              zyg: 
                - !!perl/hash:RE_string 
                  a: 0
                  dba: block
                  i: 0
                  min: 1
                  r: 1
                  s: 0
                  text: "{"
                - !!perl/hash:RE_meta 
                  a: 0
                  dba: block
                  extra: "local $::GOAL = '}' "
                  i: 0
                  min: 0
                  r: 1
                  s: 0
                  text: "::"
                - !!perl/hash:RE_method 
                  a: 0
                  dba: block
                  i: 0
                  min: 12345
                  name: statementlist
                  r: 1
                  rest: ''
                  s: 0
                - !!perl/hash:RE_bracket 
                  decl: []

                  min: 1
                  re: !!perl/hash:RE_first 
                    a: 0
                    dba: block
                    i: 0
                    min: 1
                    r: 1
                    s: 0
                    zyg: 
                      - !!perl/hash:RE_string 
                        a: 0
                        dba: block
                        i: 0
                        min: 1
                        r: 1
                        s: 0
                        text: "}"
                      - !!perl/hash:RE_method 
                        min: 0
                        name: FAILGOAL
                        nobind: 1
                        rest: ('}' , 'block')
            - !!perl/hash:RE_sequence 
              a: 0
              alt: blockoid_01 1
              dba: block
              i: 0
              min: 0
              r: 1
              s: 0
              zyg: 
                - !!perl/hash:RE_assertion 
                  assert: "?"
                  min: 0
                  re: !!perl/hash:RE_method 
                    a: 0
                    dba: block
                    i: 0
                    min: 12345
                    name: terminator
                    nobind: 1
                    r: 1
                    rest: ''
                    s: 0
                - !!perl/hash:RE_method 
                  min: 0
                  name: panic
                  nobind: 1
                  rest: ('Missing block')
            - !!perl/hash:RE_sequence 
              a: 0
              alt: blockoid_01 2
              dba: block
              i: 0
              min: 0
              r: 1
              s: 0
              zyg: 
                - !!perl/hash:RE_assertion 
                  assert: "?"
                  min: 0
                  re: !!perl/hash:RE_noop 
                    a: 0
                    dba: block
                    i: 0
                    min: 0
                    nobind: 1
                    r: 1
                    s: 0
                - !!perl/hash:RE_method 
                  min: 0
                  name: panic
                  nobind: 1
                  rest: ("Malformed block")
      - !!perl/hash:RE_bracket 
        decl: []

        min: 0
        re: &60 !!perl/hash:RE_any 
          a: 0
          altname: blockoid_02
          dba: blockoid
          i: 0
          min: 0
          name: blockoid_02
          r: 1
          s: 0
          zyg: 
            - !!perl/hash:RE_sequence 
              a: 0
              alt: blockoid_02 0
              dba: blockoid
              i: 0
              min: 0
              r: 1
              s: 0
              zyg: 
                - !!perl/hash:RE_assertion 
                  assert: "?"
                  min: 0
                  re: !!perl/hash:RE_method_re 
                    a: 0
                    dba: blockoid
                    i: 0
                    min: 0
                    name: before
                    nobind: 1
                    r: 1
                    re: !!perl/hash:RE 
                      decl: []

                      min: 0
                      re: !!perl/hash:RE_sequence 
                        a: 0
                        dba: blockoid
                        i: 0
                        min: 0
                        r: 1
                        s: 0
                        zyg: 
                          - !!perl/hash:RE_quantified_atom 
                            atom: !!perl/hash:RE_meta 
                              a: 0
                              dba: blockoid
                              i: 0
                              min: 1
                              r: 1
                              s: 0
                              text: \h
                            min: 0
                            quant: 
                              - "*"
                              - ":"
                              - ''
                              - 0
                          - !!perl/hash:RE_meta 
                            a: 0
                            dba: blockoid
                            i: 0
                            min: 0
                            r: 1
                            s: 0
                            text: $$
                    s: 0
                - !!perl/hash:RE_block 
                  a: 0
                  context: void
                  dba: blockoid
                  i: 0
                  min: 0
                  r: 1
                  s: 0
                  text: " @*MEMOS[$¢.pos]<endstmt> = 2; "
                - !!perl/hash:RE_method_internal 
                  args: $S, 'blockoid', 'endstmt simple '
                  max: 0
                  min: 0
                  name: _REDUCE
            - !!perl/hash:RE_sequence 
              a: 0
              alt: blockoid_02 1
              dba: blockoid
              i: 0
              min: 0
              r: 1
              s: 0
              zyg: 
                - !!perl/hash:RE_quantified_atom 
                  atom: !!perl/hash:RE_meta 
                    a: 0
                    dba: blockoid
                    i: 0
                    min: 1
                    r: 1
                    s: 0
                    text: \h
                  min: 0
                  quant: 
                    - "*"
                    - ":"
                    - ''
                    - 0
                - !!perl/hash:RE_assertion 
                  assert: "?"
                  min: 0
                  re: !!perl/hash:RE_method_re 
                    a: 0
                    dba: blockoid
                    i: 0
                    min: 0
                    name: before
                    nobind: 1
                    r: 1
                    re: !!perl/hash:RE 
                      decl: []

                      min: 1
                      re: !!perl/hash:RE_cclass 
                        a: 0
                        dba: blockoid
                        i: 0
                        min: 1
                        r: 1
                        s: 0
                        text: "[\\\\,:]"
                    s: 0
                - !!perl/hash:RE_method_internal 
                  args: $S, 'blockoid', 'normal '
                  max: 0
                  min: 0
                  name: _REDUCE
            - !!perl/hash:RE_sequence 
              a: 0
              alt: blockoid_02 2
              dba: blockoid
              i: 0
              min: 0
              r: 1
              s: 0
              zyg: 
                - !!perl/hash:RE_quantified_atom 
                  atom: !!perl/hash:RE_method 
                    a: 0
                    dba: blockoid
                    i: 0
                    min: 12345
                    name: unv
                    nobind: 1
                    r: 1
                    rest: ''
                    s: 0
                  min: 0
                  quant: 
                    - "?"
                    - ":"
                    - ''
                    - 0
                - !!perl/hash:RE_meta 
                  a: 0
                  dba: blockoid
                  i: 0
                  min: 0
                  r: 1
                  s: 0
                  text: $$
                - !!perl/hash:RE_block 
                  a: 0
                  context: void
                  dba: blockoid
                  i: 0
                  min: 0
                  r: 1
                  s: 0
                  text: " @*MEMOS[$¢.pos]<endstmt> = 2; "
                - !!perl/hash:RE_method_internal 
                  args: $S, 'blockoid', 'endstmt complex'
                  max: 0
                  min: 0
                  name: _REDUCE
            - !!perl/hash:RE_sequence 
              a: 0
              alt: blockoid_02 3
              dba: blockoid
              i: 0
              min: 0
              r: 1
              s: 0
              zyg: 
                - !!perl/hash:RE_block 
                  a: 0
                  context: void
                  dba: blockoid
                  i: 0
                  min: 0
                  r: 1
                  s: 0
                  text: ''
                - !!perl/hash:RE_quantified_atom 
                  atom: !!perl/hash:RE_method 
                    a: 0
                    dba: blockoid
                    i: 0
                    min: 12345
                    name: unsp
                    nobind: 1
                    r: 1
                    rest: ''
                    s: 0
                  min: 0
                  quant: 
                    - "?"
                    - ":"
                    - ''
                    - 0
                - !!perl/hash:RE_block 
                  a: 0
                  context: void
                  dba: blockoid
                  i: 0
                  min: 0
                  r: 1
                  s: 0
                  text: " @*MEMOS[$¢.pos]<endargs> = 1; "
                - !!perl/hash:RE_method_internal 
                  args: $S, 'blockoid', 'endargs'
                  max: 0
                  min: 0
                  name: _REDUCE
blockoid_01: *135
blockoid_02: *60
blorst: !!perl/hash:RE 
  decl: []

  kind: token
  min: 24690
  pkg: ~
  re: !!perl/hash:RE_sequence 
    a: 0
    dba: blorst
    i: 0
    min: 24690
    r: 1
    s: 0
    zyg: 
      - !!perl/hash:RE_assertion 
        assert: "?"
        min: 0
        re: !!perl/hash:RE_method_re 
          a: 0
          dba: blorst
          i: 0
          min: 0
          name: before
          nobind: 1
          r: 1
          re: !!perl/hash:RE 
            decl: []

            min: 1
            re: !!perl/hash:RE_meta 
              a: 0
              dba: blorst
              i: 0
              min: 1
              r: 1
              s: 0
              text: \s
          s: 0
      - !!perl/hash:RE_method 
        a: 0
        dba: blorst
        i: 0
        min: 12345
        name: ws
        nobind: 1
        r: 1
        rest: ''
        s: 0
      - !!perl/hash:RE_bracket 
        decl: []

        min: 12345
        re: &28 !!perl/hash:RE_any 
          a: 0
          altname: blorst_02
          dba: blorst
          i: 0
          min: 12345
          name: blorst_02
          r: 1
          s: 0
          zyg: 
            - !!perl/hash:RE_method 
              a: 0
              alt: blorst_02 0
              dba: blorst
              i: 0
              min: 12345
              name: block
              r: 1
              rest: ''
              s: 0
            - !!perl/hash:RE_method 
              a: 0
              alt: blorst_02 1
              dba: blorst
              i: 0
              min: 12345
              name: statement
              r: 1
              rest: ''
              s: 0
blorst_02: *28
capterm: !!perl/hash:RE 
  decl: []

  kind: token
  min: 3
  pkg: ~
  re: !!perl/hash:RE_sequence 
    a: 0
    dba: capterm
    i: 0
    min: 3
    r: 1
    s: 0
    zyg: 
      - !!perl/hash:RE_string 
        a: 0
        dba: capterm
        i: 0
        min: 1
        r: 1
        s: 0
        text: \
      - !!perl/hash:RE_bracket 
        decl: []

        min: 2
        re: &127 !!perl/hash:RE_any 
          a: 0
          altname: capterm_01
          dba: capterm
          i: 0
          min: 2
          name: capterm_01
          r: 1
          s: 0
          zyg: 
            - !!perl/hash:RE_sequence 
              a: 0
              alt: capterm_01 0
              dba: capterm
              i: 0
              min: 2
              r: 1
              s: 0
              zyg: 
                - !!perl/hash:RE_string 
                  a: 0
                  dba: capterm
                  i: 0
                  min: 1
                  r: 1
                  s: 0
                  text: (
                - !!perl/hash:RE_quantified_atom 
                  atom: !!perl/hash:RE_method 
                    a: 0
                    dba: capterm
                    i: 0
                    min: 12345
                    name: capture
                    r: 1
                    rest: ''
                    s: 0
                  min: 0
                  quant: 
                    - "?"
                    - ":"
                    - ''
                    - 0
                - !!perl/hash:RE_string 
                  a: 0
                  dba: capterm
                  i: 0
                  min: 1
                  r: 1
                  s: 0
                  text: )
            - !!perl/hash:RE_sequence 
              a: 0
              alt: capterm_01 1
              dba: capterm
              i: 0
              min: 12345
              r: 1
              s: 0
              zyg: 
                - !!perl/hash:RE_assertion 
                  assert: "?"
                  min: 0
                  re: !!perl/hash:RE_method_re 
                    a: 0
                    dba: capterm
                    i: 0
                    min: 0
                    name: before
                    nobind: 1
                    r: 1
                    re: !!perl/hash:RE 
                      decl: []

                      min: 1
                      re: !!perl/hash:RE_meta 
                        a: 0
                        dba: capterm
                        i: 0
                        min: 1
                        r: 1
                        s: 0
                        text: \S
                    s: 0
                - !!perl/hash:RE_method 
                  a: 0
                  dba: capterm
                  i: 0
                  min: 12345
                  name: termish
                  r: 1
                  rest: ''
                  s: 0
capterm_01: *127
capture: !!perl/hash:RE 
  decl: 
    - !!perl/hash:RE_decl 
      a: 0
      dba: capture
      i: 0
      max: 0
      min: 0
      r: 1
      s: 1
      text: my $INVOCANT_OK is context<rw> = 1
  kind: rule
  min: 12345
  pkg: ~
  re: !!perl/hash:RE_sequence 
    a: 0
    dba: capture
    i: 0
    min: 12345
    r: 1
    s: 1
    zyg: 
      - !!perl/hash:RE_method 
        min: 0
        name: ws
        nobind: 1
        noquant: 1
        rest: ''
      - !!perl/hash:RE_method 
        a: 0
        dba: capture
        i: 0
        min: 12345
        name: EXPR
        r: 1
        rest: ''
        s: 1
      - !!perl/hash:RE_method 
        min: 0
        name: ws
        nobind: 1
        noquant: 1
        rest: ''
category__S_000category: !!perl/hash:RE 
  decl: []

  kind: token
  min: 12345
  pkg: ~
  re: !!perl/hash:RE_method 
    a: 0
    dba: category__S_000category
    i: 0
    min: 12345
    name: sym
    r: 1
    rest: ''
    s: 0
    sym: category
category__S_001sigil: !!perl/hash:RE 
  decl: []

  kind: token
  min: 12345
  pkg: ~
  re: !!perl/hash:RE_method 
    a: 0
    dba: category__S_001sigil
    i: 0
    min: 12345
    name: sym
    r: 1
    rest: ''
    s: 0
    sym: sigil
category__S_002twigil: !!perl/hash:RE 
  decl: []

  kind: token
  min: 12345
  pkg: ~
  re: !!perl/hash:RE_method 
    a: 0
    dba: category__S_002twigil
    i: 0
    min: 12345
    name: sym
    r: 1
    rest: ''
    s: 0
    sym: twigil
category__S_003special_variable: !!perl/hash:RE 
  decl: []

  kind: token
  min: 12345
  pkg: ~
  re: !!perl/hash:RE_method 
    a: 0
    dba: category__S_003special_variable
    i: 0
    min: 12345
    name: sym
    r: 1
    rest: ''
    s: 0
    sym: special_variable
category__S_004version: !!perl/hash:RE 
  decl: []

  kind: token
  min: 12345
  pkg: ~
  re: !!perl/hash:RE_method 
    a: 0
    dba: category__S_004version
    i: 0
    min: 12345
    name: sym
    r: 1
    rest: ''
    s: 0
    sym: version
category__S_005module_name: !!perl/hash:RE 
  decl: []

  kind: token
  min: 12345
  pkg: ~
  re: !!perl/hash:RE_method 
    a: 0
    dba: category__S_005module_name
    i: 0
    min: 12345
    name: sym
    r: 1
    rest: ''
    s: 0
    sym: module_name
category__S_006noun: !!perl/hash:RE 
  decl: []

  kind: token
  min: 12345
  pkg: ~
  re: !!perl/hash:RE_method 
    a: 0
    dba: category__S_006noun
    i: 0
    min: 12345
    name: sym
    r: 1
    rest: ''
    s: 0
    sym: noun
category__S_007value: !!perl/hash:RE 
  decl: []

  kind: token
  min: 12345
  pkg: ~
  re: !!perl/hash:RE_method 
    a: 0
    dba: category__S_007value
    i: 0
    min: 12345
    name: sym
    r: 1
    rest: ''
    s: 0
    sym: value
category__S_008term: !!perl/hash:RE 
  decl: []

  kind: token
  min: 12345
  pkg: ~
  re: !!perl/hash:RE_method 
    a: 0
    dba: category__S_008term
    i: 0
    min: 12345
    name: sym
    r: 1
    rest: ''
    s: 0
    sym: term
category__S_009number: !!perl/hash:RE 
  decl: []

  kind: token
  min: 12345
  pkg: ~
  re: !!perl/hash:RE_method 
    a: 0
    dba: category__S_009number
    i: 0
    min: 12345
    name: sym
    r: 1
    rest: ''
    s: 0
    sym: number
category__S_010quote: !!perl/hash:RE 
  decl: []

  kind: token
  min: 12345
  pkg: ~
  re: !!perl/hash:RE_method 
    a: 0
    dba: category__S_010quote
    i: 0
    min: 12345
    name: sym
    r: 1
    rest: ''
    s: 0
    sym: quote
category__S_011prefix: !!perl/hash:RE 
  decl: []

  kind: token
  min: 12345
  pkg: ~
  re: !!perl/hash:RE_method 
    a: 0
    dba: category__S_011prefix
    i: 0
    min: 12345
    name: sym
    r: 1
    rest: ''
    s: 0
    sym: prefix
category__S_012infix: !!perl/hash:RE 
  decl: []

  kind: token
  min: 12345
  pkg: ~
  re: !!perl/hash:RE_method 
    a: 0
    dba: category__S_012infix
    i: 0
    min: 12345
    name: sym
    r: 1
    rest: ''
    s: 0
    sym: infix
category__S_013postfix: !!perl/hash:RE 
  decl: []

  kind: token
  min: 12345
  pkg: ~
  re: !!perl/hash:RE_method 
    a: 0
    dba: category__S_013postfix
    i: 0
    min: 12345
    name: sym
    r: 1
    rest: ''
    s: 0
    sym: postfix
category__S_014dotty: !!perl/hash:RE 
  decl: []

  kind: token
  min: 12345
  pkg: ~
  re: !!perl/hash:RE_method 
    a: 0
    dba: category__S_014dotty
    i: 0
    min: 12345
    name: sym
    r: 1
    rest: ''
    s: 0
    sym: dotty
category__S_015circumfix: !!perl/hash:RE 
  decl: []

  kind: token
  min: 12345
  pkg: ~
  re: !!perl/hash:RE_method 
    a: 0
    dba: category__S_015circumfix
    i: 0
    min: 12345
    name: sym
    r: 1
    rest: ''
    s: 0
    sym: circumfix
category__S_016postcircumfix: !!perl/hash:RE 
  decl: []

  kind: token
  min: 12345
  pkg: ~
  re: !!perl/hash:RE_method 
    a: 0
    dba: category__S_016postcircumfix
    i: 0
    min: 12345
    name: sym
    r: 1
    rest: ''
    s: 0
    sym: postcircumfix
category__S_017quote_mod: !!perl/hash:RE 
  decl: []

  kind: token
  min: 12345
  pkg: ~
  re: !!perl/hash:RE_method 
    a: 0
    dba: category__S_017quote_mod
    i: 0
    min: 12345
    name: sym
    r: 1
    rest: ''
    s: 0
    sym: quote_mod
category__S_018trait_mod: !!perl/hash:RE 
  decl: []

  kind: token
  min: 12345
  pkg: ~
  re: !!perl/hash:RE_method 
    a: 0
    dba: category__S_018trait_mod
    i: 0
    min: 12345
    name: sym
    r: 1
    rest: ''
    s: 0
    sym: trait_mod
category__S_019type_declarator: !!perl/hash:RE 
  decl: []

  kind: token
  min: 12345
  pkg: ~
  re: !!perl/hash:RE_method 
    a: 0
    dba: category__S_019type_declarator
    i: 0
    min: 12345
    name: sym
    r: 1
    rest: ''
    s: 0
    sym: type_declarator
category__S_020scope_declarator: !!perl/hash:RE 
  decl: []

  kind: token
  min: 12345
  pkg: ~
  re: !!perl/hash:RE_method 
    a: 0
    dba: category__S_020scope_declarator
    i: 0
    min: 12345
    name: sym
    r: 1
    rest: ''
    s: 0
    sym: scope_declarator
category__S_021package_declarator: !!perl/hash:RE 
  decl: []

  kind: token
  min: 12345
  pkg: ~
  re: !!perl/hash:RE_method 
    a: 0
    dba: category__S_021package_declarator
    i: 0
    min: 12345
    name: sym
    r: 1
    rest: ''
    s: 0
    sym: package_declarator
category__S_022multi_declarator: !!perl/hash:RE 
  decl: []

  kind: token
  min: 12345
  pkg: ~
  re: !!perl/hash:RE_method 
    a: 0
    dba: category__S_022multi_declarator
    i: 0
    min: 12345
    name: sym
    r: 1
    rest: ''
    s: 0
    sym: multi_declarator
category__S_023routine_declarator: !!perl/hash:RE 
  decl: []

  kind: token
  min: 12345
  pkg: ~
  re: !!perl/hash:RE_method 
    a: 0
    dba: category__S_023routine_declarator
    i: 0
    min: 12345
    name: sym
    r: 1
    rest: ''
    s: 0
    sym: routine_declarator
category__S_024regex_declarator: !!perl/hash:RE 
  decl: []

  kind: token
  min: 12345
  pkg: ~
  re: !!perl/hash:RE_method 
    a: 0
    dba: category__S_024regex_declarator
    i: 0
    min: 12345
    name: sym
    r: 1
    rest: ''
    s: 0
    sym: regex_declarator
category__S_025statement_prefix: !!perl/hash:RE 
  decl: []

  kind: token
  min: 12345
  pkg: ~
  re: !!perl/hash:RE_method 
    a: 0
    dba: category__S_025statement_prefix
    i: 0
    min: 12345
    name: sym
    r: 1
    rest: ''
    s: 0
    sym: statement_prefix
category__S_026statement_control: !!perl/hash:RE 
  decl: []

  kind: token
  min: 12345
  pkg: ~
  re: !!perl/hash:RE_method 
    a: 0
    dba: category__S_026statement_control
    i: 0
    min: 12345
    name: sym
    r: 1
    rest: ''
    s: 0
    sym: statement_control
category__S_027statement_mod_cond: !!perl/hash:RE 
  decl: []

  kind: token
  min: 12345
  pkg: ~
  re: !!perl/hash:RE_method 
    a: 0
    dba: category__S_027statement_mod_cond
    i: 0
    min: 12345
    name: sym
    r: 1
    rest: ''
    s: 0
    sym: statement_mod_cond
category__S_028statement_mod_loop: !!perl/hash:RE 
  decl: []

  kind: token
  min: 12345
  pkg: ~
  re: !!perl/hash:RE_method 
    a: 0
    dba: category__S_028statement_mod_loop
    i: 0
    min: 12345
    name: sym
    r: 1
    rest: ''
    s: 0
    sym: statement_mod_loop
category__S_029infix_prefix_meta_operator: !!perl/hash:RE 
  decl: []

  kind: token
  min: 12345
  pkg: ~
  re: !!perl/hash:RE_method 
    a: 0
    dba: category__S_029infix_prefix_meta_operator
    i: 0
    min: 12345
    name: sym
    r: 1
    rest: ''
    s: 0
    sym: infix_prefix_meta_operator
category__S_030infix_postfix_meta_operator: !!perl/hash:RE 
  decl: []

  kind: token
  min: 12345
  pkg: ~
  re: !!perl/hash:RE_method 
    a: 0
    dba: category__S_030infix_postfix_meta_operator
    i: 0
    min: 12345
    name: sym
    r: 1
    rest: ''
    s: 0
    sym: infix_postfix_meta_operator
category__S_031infix_circumfix_meta_operator: !!perl/hash:RE 
  decl: []

  kind: token
  min: 12345
  pkg: ~
  re: !!perl/hash:RE_method 
    a: 0
    dba: category__S_031infix_circumfix_meta_operator
    i: 0
    min: 12345
    name: sym
    r: 1
    rest: ''
    s: 0
    sym: infix_circumfix_meta_operator
category__S_032postfix_prefix_meta_operator: !!perl/hash:RE 
  decl: []

  kind: token
  min: 12345
  pkg: ~
  re: !!perl/hash:RE_method 
    a: 0
    dba: category__S_032postfix_prefix_meta_operator
    i: 0
    min: 12345
    name: sym
    r: 1
    rest: ''
    s: 0
    sym: postfix_prefix_meta_operator
category__S_033prefix_postfix_meta_operator: !!perl/hash:RE 
  decl: []

  kind: token
  min: 12345
  pkg: ~
  re: !!perl/hash:RE_method 
    a: 0
    dba: category__S_033prefix_postfix_meta_operator
    i: 0
    min: 12345
    name: sym
    r: 1
    rest: ''
    s: 0
    sym: prefix_postfix_meta_operator
category__S_034prefix_circumfix_meta_operator: !!perl/hash:RE 
  decl: []

  kind: token
  min: 12345
  pkg: ~
  re: !!perl/hash:RE_method 
    a: 0
    dba: category__S_034prefix_circumfix_meta_operator
    i: 0
    min: 12345
    name: sym
    r: 1
    rest: ''
    s: 0
    sym: prefix_circumfix_meta_operator
category__S_035terminator: !!perl/hash:RE 
  decl: []

  kind: token
  min: 12345
  pkg: ~
  re: !!perl/hash:RE_method 
    a: 0
    dba: category__S_035terminator
    i: 0
    min: 12345
    name: sym
    r: 1
    rest: ''
    s: 0
    sym: terminator
charname: !!perl/hash:RE 
  decl: []

  kind: token
  min: 0
  pkg: ~
  re: !!perl/hash:RE_first 
    a: 0
    dba: charname
    i: 0
    min: 0
    r: 1
    s: 0
    zyg: 
      - !!perl/hash:RE_bracket 
        decl: []

        min: 2
        re: &36 !!perl/hash:RE_any 
          a: 0
          altname: charname_01
          dba: charname
          i: 0
          min: 2
          name: charname_01
          r: 1
          s: 0
          zyg: 
            - !!perl/hash:RE_method 
              a: 0
              alt: charname_01 0
              dba: charname
              i: 0
              min: 12345
              name: radint
              r: 1
              rest: ''
              s: 0
            - !!perl/hash:RE_sequence 
              a: 0
              alt: charname_01 1
              dba: charname
              i: 0
              min: 2
              r: 1
              s: 0
              zyg: 
                - !!perl/hash:RE_cclass 
                  a: 0
                  dba: charname
                  i: 0
                  min: 1
                  r: 1
                  s: 0
                  text: "[a..z A..Z]"
                - !!perl/hash:RE_quantified_atom 
                  atom: !!perl/hash:RE_cclass 
                    a: 0
                    dba: charname
                    i: 0
                    min: 1
                    r: 1
                    s: 0
                    text: "-[ \\] , # ]"
                  min: 0
                  quant: 
                    - "*"
                    - "?"
                    - ''
                    - 0
                - !!perl/hash:RE_cclass 
                  a: 0
                  dba: charname
                  i: 0
                  min: 1
                  r: 1
                  s: 0
                  text: "[a..z A..Z ) ]"
                - !!perl/hash:RE_assertion 
                  assert: "?"
                  min: 0
                  re: !!perl/hash:RE_method_re 
                    a: 0
                    dba: charname
                    i: 0
                    min: 0
                    name: before
                    nobind: 1
                    r: 1
                    re: !!perl/hash:RE 
                      decl: []

                      min: 1
                      re: !!perl/hash:RE_sequence 
                        a: 0
                        dba: charname
                        i: 0
                        min: 1
                        r: 1
                        s: 0
                        zyg: 
                          - !!perl/hash:RE_quantified_atom 
                            atom: !!perl/hash:RE_meta 
                              a: 0
                              dba: charname
                              i: 0
                              min: 1
                              r: 1
                              s: 0
                              text: \s
                            min: 0
                            quant: 
                              - "*"
                              - ":"
                              - ''
                              - 0
                          - !!perl/hash:RE_cclass 
                            a: 0
                            dba: charname
                            i: 0
                            min: 1
                            r: 1
                            s: 0
                            text: "[ \\] , # ]"
                    s: 0
      - !!perl/hash:RE_method 
        min: 0
        name: panic
        nobind: 1
        rest: ("Unrecognized character name")
charname_01: *36
charnames: !!perl/hash:RE 
  decl: []

  kind: token
  min: 37035
  pkg: ~
  re: !!perl/hash:RE_quantified_atom 
    atom: !!perl/hash:RE_bracket 
      decl: []

      min: 37035
      re: !!perl/hash:RE_sequence 
        a: 0
        dba: charnames
        i: 0
        min: 37035
        r: 1
        s: 0
        zyg: 
          - !!perl/hash:RE_method 
            a: 0
            dba: charnames
            i: 0
            min: 12345
            name: ws
            nobind: 1
            r: 1
            rest: ''
            s: 0
          - !!perl/hash:RE_method 
            a: 0
            dba: charnames
            i: 0
            min: 12345
            name: charname
            r: 1
            rest: ''
            s: 0
          - !!perl/hash:RE_method 
            a: 0
            dba: charnames
            i: 0
            min: 12345
            name: ws
            nobind: 1
            r: 1
            rest: ''
            s: 0
    min: 37035
    quant: 
      - "**"
      - ":"
      - !!perl/hash:RE_string 
        a: 0
        dba: charnames
        i: 0
        min: 1
        r: 1
        s: 0
        text: ","
      - 1
charspec: !!perl/hash:RE 
  decl: []

  kind: token
  min: 0
  pkg: ~
  re: !!perl/hash:RE_bracket 
    decl: []

    min: 0
    re: &138 !!perl/hash:RE_any 
      a: 0
      altname: charspec_01
      dba: character name
      i: 0
      min: 0
      name: charspec_01
      r: 1
      s: 0
      zyg: 
        - !!perl/hash:RE_sequence 
          a: 0
          alt: charspec_01 0
          dba: character name
          i: 0
          min: 12347
          r: 1
          s: 0
          zyg: 
            - !!perl/hash:RE_string 
              a: 0
              dba: character name
              i: 0
              min: 1
              r: 1
              s: 0
              text: "["
            - !!perl/hash:RE_meta 
              a: 0
              dba: character name
              extra: "local $::GOAL = ']' "
              i: 0
              min: 0
              r: 1
              s: 0
              text: "::"
            - !!perl/hash:RE_method 
              a: 0
              dba: character name
              i: 0
              min: 12345
              name: charnames
              r: 1
              rest: ''
              s: 0
            - !!perl/hash:RE_bracket 
              decl: []

              min: 1
              re: !!perl/hash:RE_first 
                a: 0
                dba: character name
                i: 0
                min: 1
                r: 1
                s: 0
                zyg: 
                  - !!perl/hash:RE_string 
                    a: 0
                    dba: character name
                    i: 0
                    min: 1
                    r: 1
                    s: 0
                    text: "]"
                  - !!perl/hash:RE_method 
                    min: 0
                    name: FAILGOAL
                    nobind: 1
                    rest: (']' , 'character name')
        - !!perl/hash:RE_quantified_atom 
          alt: charspec_01 1
          atom: !!perl/hash:RE_meta 
            a: 0
            dba: character name
            i: 0
            min: 1
            r: 1
            s: 0
            text: \d
          min: 1
          quant: 
            - +
            - ":"
            - ''
            - 1
        - !!perl/hash:RE_cclass 
          a: 0
          alt: charspec_01 2
          dba: character name
          i: 0
          min: 1
          r: 1
          s: 0
          text: "[ ?..Z \\\\.._ ]"
        - !!perl/hash:RE_sequence 
          a: 0
          alt: charspec_01 3
          dba: character name
          i: 0
          min: 0
          r: 1
          s: 0
          zyg: 
            - !!perl/hash:RE_assertion 
              assert: "?"
              min: 0
              re: !!perl/hash:RE_noop 
                a: 0
                dba: character name
                i: 0
                min: 0
                nobind: 1
                r: 1
                s: 0
            - !!perl/hash:RE_method 
              min: 0
              name: panic
              nobind: 1
              rest: ("Unrecognized \\c character")
charspec_01: *138
circumfix__S_195Fre_Nch: !!perl/hash:RE 
  decl: []

  kind: token
  min: 2
  pkg: ~
  re: !!perl/hash:RE_sequence 
    a: 0
    dba: circumfix__S_195Fre_Nch
    i: 0
    min: 2
    r: 1
    s: 0
    zyg: 
      - !!perl/hash:RE_string 
        a: 0
        dba: circumfix__S_195Fre_Nch
        i: 0
        min: 1
        r: 1
        s: 0
        text: «
      - !!perl/hash:RE_method 
        min: 0
        name: nibble
        rest: ($¢.cursor_fresh( %*LANG<Q> ).tweak(:qq).tweak(:ww).balanced('«','»'))
      - !!perl/hash:RE_string 
        a: 0
        dba: circumfix__S_195Fre_Nch
        i: 0
        min: 1
        r: 1
        s: 0
        text: »
circumfix__S_196LtLt_GtGt: !!perl/hash:RE 
  decl: []

  kind: token
  min: 4
  pkg: ~
  re: !!perl/hash:RE_sequence 
    a: 0
    dba: circumfix__S_196LtLt_GtGt
    i: 0
    min: 4
    r: 1
    s: 0
    zyg: 
      - !!perl/hash:RE_string 
        a: 0
        dba: circumfix__S_196LtLt_GtGt
        i: 0
        min: 2
        r: 1
        s: 0
        text: <<
      - !!perl/hash:RE_method 
        min: 0
        name: nibble
        rest: ($¢.cursor_fresh( %*LANG<Q> ).tweak(:qq).tweak(:ww).balanced('<<','>>'))
      - !!perl/hash:RE_string 
        a: 0
        dba: circumfix__S_196LtLt_GtGt
        i: 0
        min: 2
        r: 1
        s: 0
        text: ">>"
circumfix__S_197Lt_Gt: !!perl/hash:RE 
  decl: []

  kind: token
  min: 2
  pkg: ~
  re: !!perl/hash:RE_sequence 
    a: 0
    dba: circumfix__S_197Lt_Gt
    i: 0
    min: 2
    r: 1
    s: 0
    zyg: 
      - !!perl/hash:RE_string 
        a: 0
        dba: circumfix__S_197Lt_Gt
        i: 0
        min: 1
        r: 1
        s: 0
        text: <
      - !!perl/hash:RE_quantified_atom 
        atom: !!perl/hash:RE_bracket 
          decl: []

          min: 0
          re: !!perl/hash:RE_sequence 
            a: 0
            dba: circumfix__S_197Lt_Gt
            i: 0
            min: 0
            r: 1
            s: 0
            zyg: 
              - !!perl/hash:RE_assertion 
                assert: "?"
                min: 0
                re: !!perl/hash:RE_method_re 
                  a: 0
                  dba: circumfix__S_197Lt_Gt
                  i: 0
                  min: 0
                  name: before
                  nobind: 1
                  r: 1
                  re: !!perl/hash:RE 
                    decl: []

                    min: 6
                    re: !!perl/hash:RE_string 
                      a: 0
                      dba: circumfix__S_197Lt_Gt
                      i: 0
                      min: 6
                      r: 1
                      s: 0
                      text: STDIN>
                  s: 0
              - !!perl/hash:RE_method 
                min: 0
                name: obs
                nobind: 1
                rest: ('<STDIN>', '$' ~ '*IN.lines')
        min: 0
        quant: 
          - "?"
          - ":"
          - ''
          - 0
      - !!perl/hash:RE_quantified_atom 
        atom: !!perl/hash:RE_bracket 
          decl: []

          min: 0
          re: !!perl/hash:RE_sequence 
            a: 0
            dba: circumfix__S_197Lt_Gt
            i: 0
            min: 0
            r: 1
            s: 0
            zyg: 
              - !!perl/hash:RE_assertion 
                assert: "?"
                min: 0
                re: !!perl/hash:RE_method_re 
                  a: 0
                  dba: circumfix__S_197Lt_Gt
                  i: 0
                  min: 0
                  name: before
                  nobind: 1
                  r: 1
                  re: !!perl/hash:RE 
                    decl: []

                    min: 1
                    re: !!perl/hash:RE_string 
                      a: 0
                      dba: circumfix__S_197Lt_Gt
                      i: 0
                      min: 1
                      r: 1
                      s: 0
                      text: ">"
                  s: 0
              - !!perl/hash:RE_method 
                min: 0
                name: obs
                nobind: 1
                rest: ('<>', 'lines() or ()')
        min: 0
        quant: 
          - "?"
          - ":"
          - ''
          - 0
      - !!perl/hash:RE_method 
        min: 0
        name: nibble
        rest: ($¢.cursor_fresh( %*LANG<Q> ).tweak(:q).tweak(:w).balanced('<','>'))
      - !!perl/hash:RE_string 
        a: 0
        dba: circumfix__S_197Lt_Gt
        i: 0
        min: 1
        r: 1
        s: 0
        text: ">"
circumfix__S_279sigil: !!perl/hash:RE 
  decl: []

  kind: token
  min: 24692
  pkg: STD::Term
  re: !!perl/hash:RE_sequence 
    a: 0
    dba: contextualizer
    i: 0
    min: 24692
    r: 1
    s: 0
    zyg: 
      - !!perl/hash:RE_method 
        a: 0
        dba: contextualizer
        i: 0
        min: 12345
        name: sigil
        r: 1
        rest: ''
        s: 0
      - !!perl/hash:RE_string 
        a: 0
        dba: contextualizer
        i: 0
        min: 1
        r: 1
        s: 0
        text: (
      - !!perl/hash:RE_meta 
        a: 0
        dba: contextualizer
        extra: "local $::GOAL = ')' "
        i: 0
        min: 0
        r: 1
        s: 0
        text: "::"
      - !!perl/hash:RE_method 
        a: 0
        dba: contextualizer
        i: 0
        min: 12345
        name: semilist
        r: 1
        rest: ''
        s: 0
      - !!perl/hash:RE_bracket 
        decl: []

        min: 1
        re: !!perl/hash:RE_first 
          a: 0
          dba: contextualizer
          i: 0
          min: 1
          r: 1
          s: 0
          zyg: 
            - !!perl/hash:RE_string 
              a: 0
              dba: contextualizer
              i: 0
              min: 1
              r: 1
              s: 0
              text: )
            - !!perl/hash:RE_method 
              min: 0
              name: FAILGOAL
              nobind: 1
              rest: (')' , 'contextualizer')
      - !!perl/hash:RE_block 
        a: 0
        context: void
        dba: contextualizer
        i: 0
        min: 0
        r: 1
        s: 0
        text: " $*LEFTSIGIL ||= $<sigil>.Str "
circumfix__S_280Paren_Thesis: !!perl/hash:RE 
  decl: []

  kind: token
  min: 12347
  pkg: STD::Term
  re: !!perl/hash:RE_sequence 
    a: 0
    dba: parenthesized expression
    i: 0
    min: 12347
    r: 1
    s: 0
    zyg: 
      - !!perl/hash:RE_string 
        a: 0
        dba: parenthesized expression
        i: 0
        min: 1
        r: 1
        s: 0
        text: (
      - !!perl/hash:RE_meta 
        a: 0
        dba: parenthesized expression
        extra: "local $::GOAL = ')' "
        i: 0
        min: 0
        r: 1
        s: 0
        text: "::"
      - !!perl/hash:RE_method 
        a: 0
        dba: parenthesized expression
        i: 0
        min: 12345
        name: semilist
        r: 1
        rest: ''
        s: 0
      - !!perl/hash:RE_bracket 
        decl: []

        min: 1
        re: !!perl/hash:RE_first 
          a: 0
          dba: parenthesized expression
          i: 0
          min: 1
          r: 1
          s: 0
          zyg: 
            - !!perl/hash:RE_string 
              a: 0
              dba: parenthesized expression
              i: 0
              min: 1
              r: 1
              s: 0
              text: )
            - !!perl/hash:RE_method 
              min: 0
              name: FAILGOAL
              nobind: 1
              rest: (')' , 'parenthesized expression')
circumfix__S_281Bra_Ket: !!perl/hash:RE 
  decl: []

  kind: token
  min: 12347
  pkg: STD::Term
  re: !!perl/hash:RE_sequence 
    a: 0
    dba: array composer
    i: 0
    min: 12347
    r: 1
    s: 0
    zyg: 
      - !!perl/hash:RE_string 
        a: 0
        dba: array composer
        i: 0
        min: 1
        r: 1
        s: 0
        text: "["
      - !!perl/hash:RE_meta 
        a: 0
        dba: array composer
        extra: "local $::GOAL = ']' "
        i: 0
        min: 0
        r: 1
        s: 0
        text: "::"
      - !!perl/hash:RE_method 
        a: 0
        dba: array composer
        i: 0
        min: 12345
        name: semilist
        r: 1
        rest: ''
        s: 0
      - !!perl/hash:RE_bracket 
        decl: []

        min: 1
        re: !!perl/hash:RE_first 
          a: 0
          dba: array composer
          i: 0
          min: 1
          r: 1
          s: 0
          zyg: 
            - !!perl/hash:RE_string 
              a: 0
              dba: array composer
              i: 0
              min: 1
              r: 1
              s: 0
              text: "]"
            - !!perl/hash:RE_method 
              min: 0
              name: FAILGOAL
              nobind: 1
              rest: (']' , 'array composer')
circumfix__S_300Cur_Ly: !!perl/hash:RE 
  decl: []

  kind: token
  min: 12345
  pkg: STD::Term
  re: !!perl/hash:RE_sequence 
    a: 0
    dba: circumfix__S_300Cur_Ly
    i: 0
    min: 12345
    r: 1
    s: 0
    zyg: 
      - !!perl/hash:RE_assertion 
        assert: "?"
        min: 0
        re: !!perl/hash:RE_method_re 
          a: 0
          dba: circumfix__S_300Cur_Ly
          i: 0
          min: 0
          name: before
          nobind: 1
          r: 1
          re: !!perl/hash:RE 
            decl: []

            min: 1
            re: !!perl/hash:RE_string 
              a: 0
              dba: circumfix__S_300Cur_Ly
              i: 0
              min: 1
              r: 1
              s: 0
              text: "{"
          s: 0
      - !!perl/hash:RE_method 
        a: 0
        dba: circumfix__S_300Cur_Ly
        i: 0
        min: 12345
        name: pblock
        r: 1
        rest: ''
        s: 0
      - !!perl/hash:RE_block 
        a: 0
        context: void
        dba: circumfix__S_300Cur_Ly
        i: 0
        min: 0
        r: 1
        s: 0
        text: "\n        if $*BORG {\n            $*BORG.<block> = $<pblock>;\n        }\n    "
colonpair: !!perl/hash:RE 
  decl: 
    - !!perl/hash:RE_decl 
      a: 0
      dba: colonpair
      i: 0
      max: 0
      min: 0
      r: 1
      s: 0
      text: my $key
    - !!perl/hash:RE_decl 
      a: 0
      dba: colonpair
      i: 0
      max: 0
      min: 0
      r: 1
      s: 0
      text: my $value
  kind: token
  min: 12346
  pkg: ~
  re: !!perl/hash:RE_sequence 
    a: 0
    dba: colon pair
    i: 0
    min: 12346
    r: 1
    s: 0
    zyg: 
      - !!perl/hash:RE_string 
        a: 0
        dba: colonpair
        i: 0
        min: 1
        r: 1
        s: 0
        text: ":"
      - !!perl/hash:RE_bracket 
        decl: []

        min: 12345
        re: &30 !!perl/hash:RE_any 
          a: 0
          altname: colonpair_01
          dba: signature
          i: 0
          min: 12345
          name: colonpair_01
          r: 1
          s: 0
          zyg: 
            - !!perl/hash:RE_sequence 
              a: 0
              alt: colonpair_01 0
              dba: colon pair
              i: 0
              min: 12346
              r: 1
              s: 0
              zyg: 
                - !!perl/hash:RE_string 
                  a: 0
                  dba: colon pair
                  i: 0
                  min: 1
                  r: 1
                  s: 0
                  text: "!"
                - !!perl/hash:RE_method 
                  a: 0
                  dba: colon pair
                  i: 0
                  min: 12345
                  name: identifier
                  r: 1
                  rest: ''
                  s: 0
                - !!perl/hash:RE_block 
                  a: 0
                  context: void
                  dba: colon pair
                  i: 0
                  min: 0
                  r: 1
                  s: 0
                  text: " $key = $<identifier>.Str; $value = 0; "
                - !!perl/hash:RE_method_internal 
                  args: $S, 'colonpair', 'false'
                  max: 0
                  min: 0
                  name: _REDUCE
            - !!perl/hash:RE_sequence 
              a: 0
              alt: colonpair_01 1
              dba: colon pair
              i: 0
              min: 12346
              r: 1
              s: 0
              zyg: 
                - !!perl/hash:RE_bindnamed 
                  a: 0
                  atom: !!perl/hash:RE_bracket 
                    decl: []

                    min: 1
                    nobind: 1
                    re: !!perl/hash:RE_quantified_atom 
                      atom: !!perl/hash:RE_meta 
                        a: 0
                        dba: colon pair
                        i: 0
                        min: 1
                        r: 1
                        s: 0
                        text: \d
                      min: 1
                      quant: 
                        - +
                        - ":"
                        - ''
                        - 1
                  dba: colon pair
                  i: 0
                  min: 1
                  r: 1
                  s: 0
                  var: num
                - !!perl/hash:RE_method 
                  a: 0
                  dba: colon pair
                  i: 0
                  min: 12345
                  name: identifier
                  r: 1
                  rest: ''
                  s: 0
            - !!perl/hash:RE_sequence 
              a: 0
              alt: colonpair_01 2
              dba: colon pair
              i: 0
              min: 12345
              r: 1
              s: 0
              zyg: 
                - !!perl/hash:RE_method 
                  a: 0
                  dba: colon pair
                  i: 0
                  min: 12345
                  name: identifier
                  r: 1
                  rest: ''
                  s: 0
                - !!perl/hash:RE_block 
                  a: 0
                  context: void
                  dba: colon pair
                  i: 0
                  min: 0
                  r: 1
                  s: 0
                  text: " $key = $<identifier>.Str; "
                - !!perl/hash:RE_bracket 
                  decl: []

                  min: 0
                  re: !!perl/hash:RE_first 
                    a: 0
                    dba: colon pair
                    i: 0
                    min: 0
                    r: 1
                    s: 0
                    zyg: 
                      - !!perl/hash:RE_sequence 
                        a: 0
                        dba: colon pair
                        i: 0
                        min: 12345
                        r: 1
                        s: 0
                        zyg: 
                          - !!perl/hash:RE_quantified_atom 
                            atom: !!perl/hash:RE_method 
                              a: 0
                              dba: colon pair
                              i: 0
                              min: 12345
                              name: unsp
                              nobind: 1
                              r: 1
                              rest: ''
                              s: 0
                            min: 0
                            quant: 
                              - "?"
                              - ":"
                              - ''
                              - 0
                          - !!perl/hash:RE_method 
                            a: 0
                            dba: colon pair
                            i: 0
                            min: 12345
                            name: circumfix
                            r: 1
                            rest: ''
                            s: 0
                          - !!perl/hash:RE_block 
                            a: 0
                            context: void
                            dba: colon pair
                            i: 0
                            min: 0
                            r: 1
                            s: 0
                            text: " $value = $<circumfix>; "
                      - !!perl/hash:RE_block 
                        a: 0
                        context: void
                        dba: colon pair
                        i: 0
                        min: 0
                        r: 1
                        s: 0
                        text: " $value = 1; "
                - !!perl/hash:RE_method_internal 
                  args: $S, 'colonpair', 'value'
                  max: 0
                  min: 0
                  name: _REDUCE
            - !!perl/hash:RE_sequence 
              a: 0
              alt: colonpair_01 3
              dba: signature
              i: 0
              min: 12347
              r: 1
              s: 0
              zyg: 
                - !!perl/hash:RE_string 
                  a: 0
                  dba: signature
                  i: 0
                  min: 1
                  r: 1
                  s: 0
                  text: (
                - !!perl/hash:RE_meta 
                  a: 0
                  dba: signature
                  extra: "local $::GOAL = ')' "
                  i: 0
                  min: 0
                  r: 1
                  s: 0
                  text: "::"
                - !!perl/hash:RE_method 
                  a: 0
                  dba: signature
                  i: 0
                  min: 12345
                  name: fakesignature
                  r: 1
                  rest: ''
                  s: 0
                - !!perl/hash:RE_bracket 
                  decl: []

                  min: 1
                  re: !!perl/hash:RE_first 
                    a: 0
                    dba: signature
                    i: 0
                    min: 1
                    r: 1
                    s: 0
                    zyg: 
                      - !!perl/hash:RE_string 
                        a: 0
                        dba: signature
                        i: 0
                        min: 1
                        r: 1
                        s: 0
                        text: )
                      - !!perl/hash:RE_method 
                        min: 0
                        name: FAILGOAL
                        nobind: 1
                        rest: (')' , 'signature')
            - !!perl/hash:RE_sequence 
              a: 0
              alt: colonpair_01 4
              dba: signature
              i: 0
              min: 12345
              r: 1
              s: 0
              zyg: 
                - !!perl/hash:RE_method 
                  a: 0
                  dba: signature
                  i: 0
                  min: 12345
                  name: circumfix
                  r: 1
                  rest: ''
                  s: 0
                - !!perl/hash:RE_block 
                  a: 0
                  context: void
                  dba: signature
                  i: 0
                  min: 0
                  r: 1
                  s: 0
                  text: " $key = \"\"; $value = $<circumfix>; "
                - !!perl/hash:RE_method_internal 
                  args: $S, 'colonpair', 'structural'
                  max: 0
                  min: 0
                  name: _REDUCE
            - !!perl/hash:RE_sequence 
              a: 0
              alt: colonpair_01 5
              dba: signature
              i: 0
              min: 24690
              r: 1
              s: 0
              zyg: 
                - !!perl/hash:RE_bindnamed 
                  a: 0
                  atom: !!perl/hash:RE_paren 
                    decl: []

                    min: 24690
                    nobind: 1
                    re: !!perl/hash:RE_sequence 
                      a: 0
                      dba: signature
                      i: 0
                      min: 24690
                      r: 1
                      s: 0
                      zyg: 
                        - !!perl/hash:RE_method 
                          a: 0
                          dba: signature
                          i: 0
                          min: 12345
                          name: sigil
                          r: 1
                          rest: ''
                          s: 0
                        - !!perl/hash:RE_block 
                          a: 0
                          context: void
                          dba: signature
                          i: 0
                          min: 0
                          r: 1
                          s: 0
                          text: ''
                        - !!perl/hash:RE_quantified_atom 
                          atom: !!perl/hash:RE_method 
                            a: 0
                            dba: signature
                            i: 0
                            min: 12345
                            name: twigil
                            r: 1
                            rest: ''
                            s: 0
                          min: 0
                          quant: 
                            - "?"
                            - ":"
                            - ''
                            - 0
                        - !!perl/hash:RE_method 
                          a: 0
                          dba: signature
                          i: 0
                          min: 12345
                          name: desigilname
                          r: 1
                          rest: ''
                          s: 0
                  dba: signature
                  i: 0
                  min: 24690
                  r: 1
                  s: 0
                  var: var
                - !!perl/hash:RE_block 
                  a: 0
                  context: void
                  dba: signature
                  i: 0
                  min: 0
                  r: 1
                  s: 0
                  text: " $key = $<var><desigilname>.Str; $value = $<var>; "
                - !!perl/hash:RE_method_internal 
                  args: $S, 'colonpair', 'varname'
                  max: 0
                  min: 0
                  name: _REDUCE
      - !!perl/hash:RE_block 
        a: 0
        context: void
        dba: colon pair
        i: 0
        min: 0
        r: 1
        s: 0
        text: " $<k> = $key; $<v> = $value; "
colonpair_01: *30
comp_unit: !!perl/hash:RE 
  decl: 
    - !!perl/hash:RE_decl 
      a: 0
      dba: comp_unit
      i: 0
      max: 0
      min: 0
      r: 1
      s: 1
      text: my $begin_compunit is context = 1
    - !!perl/hash:RE_decl 
      a: 0
      dba: comp_unit
      i: 0
      max: 0
      min: 0
      r: 1
      s: 1
      text: my $endargs        is context<rw> = -1
    - !!perl/hash:RE_decl 
      a: 0
      dba: comp_unit
      i: 0
      max: 0
      min: 0
      r: 1
      s: 1
      text: my %LANG is context
    - !!perl/hash:RE_decl 
      a: 0
      dba: comp_unit
      i: 0
      max: 0
      min: 0
      r: 1
      s: 1
      text: my $PKGDECL is context = ""
    - !!perl/hash:RE_decl 
      a: 0
      dba: comp_unit
      i: 0
      max: 0
      min: 0
      r: 1
      s: 1
      text: my $PKGNAME is context = "GLOBAL"
    - !!perl/hash:RE_decl 
      a: 0
      dba: comp_unit
      i: 0
      max: 0
      min: 0
      r: 1
      s: 1
      text: my @PKGS is context<rw> = ()
    - !!perl/hash:RE_decl 
      a: 0
      dba: comp_unit
      i: 0
      max: 0
      min: 0
      r: 1
      s: 1
      text: my $IN_DECL is context<rw>
    - !!perl/hash:RE_decl 
      a: 0
      dba: comp_unit
      i: 0
      max: 0
      min: 0
      r: 1
      s: 1
      text: my $DECLARAND is context<rw>
    - !!perl/hash:RE_decl 
      a: 0
      dba: comp_unit
      i: 0
      max: 0
      min: 0
      r: 1
      s: 1
      text: my $QSIGIL is context<rw> = ''
    - !!perl/hash:RE_decl 
      a: 0
      dba: comp_unit
      i: 0
      max: 0
      min: 0
      r: 1
      s: 1
      text: my $IN_META is context<rw> = 0
    - !!perl/hash:RE_decl 
      a: 0
      dba: comp_unit
      i: 0
      max: 0
      min: 0
      r: 1
      s: 1
      text: my $QUASIMODO is context<rw>
    - !!perl/hash:RE_decl 
      a: 0
      dba: comp_unit
      i: 0
      max: 0
      min: 0
      r: 1
      s: 1
      text: my $SCOPE is context = ""
    - !!perl/hash:RE_decl 
      a: 0
      dba: comp_unit
      i: 0
      max: 0
      min: 0
      r: 1
      s: 1
      text: my $LEFTSIGIL is context<rw>
    - !!perl/hash:RE_decl 
      a: 0
      dba: comp_unit
      i: 0
      max: 0
      min: 0
      r: 1
      s: 1
      text: my %MYSTERY is context<rw> = ()
    - !!perl/hash:RE_decl 
      a: 0
      dba: comp_unit
      i: 0
      max: 0
      min: 0
      r: 1
      s: 1
      text: my $INVOCANT_OK is context<rw>
    - !!perl/hash:RE_decl 
      a: 0
      dba: comp_unit
      i: 0
      max: 0
      min: 0
      r: 1
      s: 1
      text: my $INVOCANT_IS is context<rw>
    - !!perl/hash:RE_decl 
      a: 0
      dba: comp_unit
      i: 0
      max: 0
      min: 0
      r: 1
      s: 1
      text: my $CURPAD is context<rw>
    - !!perl/hash:RE_decl 
      a: 0
      dba: comp_unit
      i: 0
      max: 0
      min: 0
      r: 1
      s: 1
      text: my $MULTINESS is context = ''
    - !!perl/hash:RE_decl 
      a: 0
      dba: comp_unit
      i: 0
      max: 0
      min: 0
      r: 1
      s: 1
      text: my $CURPKG is context
  kind: rule
  min: 12345
  pkg: ~
  re: !!perl/hash:RE_sequence 
    a: 0
    dba: comp_unit
    i: 0
    min: 12345
    r: 1
    s: 1
    zyg: 
      - !!perl/hash:RE_method 
        min: 0
        name: ws
        nobind: 1
        noquant: 1
        rest: ''
      - !!perl/hash:RE_block 
        a: 0
        context: void
        dba: comp_unit
        i: 0
        min: 0
        r: 1
        s: 1
        text: "\n\n        %*LANG<MAIN>    = ::STD ;\n        %*LANG<Q>       = ::STD::Q ;\n        %*LANG<Quasi>   = ::STD::Quasi ;\n        %*LANG<Regex>   = ::STD::Regex ;\n        %*LANG<Trans>   = ::STD::Trans ;\n        %*LANG<P5Regex> = ::STD::P5Regex ;\n\n        @*WORRIES = ();\n        self.load_setting($*SETTINGNAME);\n        self.newpad;\n        $*UNIT = $*CURPAD;\n        self.finishpad(1);\n    "
      - !!perl/hash:RE_method 
        min: 0
        name: ws
        nobind: 1
        noquant: 1
        rest: ''
      - !!perl/hash:RE_method 
        a: 0
        dba: comp_unit
        i: 0
        min: 12345
        name: statementlist
        r: 1
        rest: ''
        s: 1
      - !!perl/hash:RE_method 
        min: 0
        name: ws
        nobind: 1
        noquant: 1
        rest: ''
      - !!perl/hash:RE_bracket 
        decl: []

        min: 0
        re: !!perl/hash:RE_first 
          a: 0
          dba: comp_unit
          i: 0
          min: 0
          r: 1
          s: 1
          zyg: 
            - !!perl/hash:RE_sequence 
              a: 0
              dba: comp_unit
              i: 0
              min: 0
              r: 1
              s: 1
              zyg: 
                - !!perl/hash:RE_assertion 
                  assert: "?"
                  min: 0
                  re: !!perl/hash:RE_method 
                    a: 0
                    dba: comp_unit
                    i: 0
                    min: 12345
                    name: unitstopper
                    nobind: 1
                    r: 1
                    rest: ''
                    s: 1
                - !!perl/hash:RE_method 
                  min: 0
                  name: ws
                  nobind: 1
                  noquant: 1
                  rest: ''
            - !!perl/hash:RE_sequence 
              a: 0
              dba: comp_unit
              i: 0
              min: 0
              r: 1
              s: 1
              zyg: 
                - !!perl/hash:RE_method 
                  min: 0
                  name: panic
                  nobind: 1
                  rest: ("Confused")
                - !!perl/hash:RE_method 
                  min: 0
                  name: ws
                  nobind: 1
                  noquant: 1
                  rest: ''
      - !!perl/hash:RE_method 
        min: 0
        name: ws
        nobind: 1
        noquant: 1
        rest: ''
      - !!perl/hash:RE_block 
        a: 0
        context: void
        dba: comp_unit
        i: 0
        min: 0
        r: 1
        s: 1
        text: "\n        if @*WORRIES {\n            warn \"Potential difficulties:\\n  \" ~ join( \"\\n  \", @*WORRIES) ~ \"\\n\";\n        }\n        my $m = $¢.explain_mystery();\n        warn $m if $m;\n    "
      - !!perl/hash:RE_method 
        min: 0
        name: ws
        nobind: 1
        noquant: 1
        rest: ''
constant_declarator: !!perl/hash:RE 
  decl: 
    - !!perl/hash:RE_decl 
      a: 0
      dba: constant_declarator
      i: 0
      max: 0
      min: 0
      r: 1
      s: 0
      text: my $IN_DECL is context<rw> = 1
    - !!perl/hash:RE_decl 
      a: 0
      dba: constant_declarator
      i: 0
      max: 0
      min: 0
      r: 1
      s: 0
      text: my $DECLARAND is context<rw>
  kind: token
  min: 24690
  pkg: ~
  re: !!perl/hash:RE_sequence 
    a: 0
    dba: constant_declarator
    i: 0
    min: 24690
    r: 1
    s: 0
    zyg: 
      - !!perl/hash:RE_assertion 
        assert: "?"
        min: 0
        re: !!perl/hash:RE_block 
          a: 0
          context: bool
          dba: constant_declarator
          i: 0
          min: 0
          nobind: 1
          r: 1
          s: 0
          text: " $*SCOPE eq 'constant' "
      - !!perl/hash:RE_method 
        a: 0
        dba: constant_declarator
        i: 0
        min: 12345
        name: identifier
        r: 1
        rest: ''
        s: 0
      - !!perl/hash:RE_method 
        a: 0
        dba: constant_declarator
        i: 0
        min: 12345
        name: ws
        nobind: 1
        r: 1
        rest: ''
        s: 0
      - !!perl/hash:RE_assertion 
        assert: "?"
        min: 0
        re: !!perl/hash:RE_method_re 
          a: 0
          dba: constant_declarator
          i: 0
          min: 0
          name: before
          nobind: 1
          r: 1
          re: !!perl/hash:RE 
            decl: []

            min: 1
            re: &46 !!perl/hash:RE_any 
              a: 0
              altname: constant_declarator_01
              dba: constant_declarator
              i: 0
              min: 1
              name: constant_declarator_01
              r: 1
              s: 0
              zyg: 
                - !!perl/hash:RE_string 
                  a: 0
                  alt: constant_declarator_01 0
                  dba: constant_declarator
                  i: 0
                  min: 1
                  r: 1
                  s: 0
                  text: =
                - !!perl/hash:RE_sequence 
                  a: 0
                  alt: constant_declarator_01 1
                  dba: constant_declarator
                  i: 0
                  min: 3
                  r: 1
                  s: 0
                  zyg: 
                    - !!perl/hash:RE_string 
                      a: 0
                      dba: constant_declarator
                      i: 0
                      min: 2
                      r: 1
                      s: 0
                      text: is
                    - !!perl/hash:RE_meta 
                      a: 0
                      dba: constant_declarator
                      i: 0
                      min: 1
                      r: 1
                      s: 0
                      text: \s
          s: 0
      - !!perl/hash:RE_block 
        a: 0
        context: void
        dba: constant_declarator
        i: 0
        min: 0
        r: 1
        s: 0
        text: " $*IN_DECL = 0; self.add_name($<identifier>.Str) "
      - !!perl/hash:RE_quantified_atom 
        atom: !!perl/hash:RE_method 
          a: 0
          dba: constant_declarator
          i: 0
          min: 12345
          name: trait
          r: 1
          rest: ''
          s: 0
        min: 0
        quant: 
          - "*"
          - ":"
          - ''
          - 0
constant_declarator_01: *46
dec_number: !!perl/hash:RE 
  decl: []

  kind: token
  min: 2
  pkg: ~
  re: !!perl/hash:RE_sequence 
    a: 0
    dba: decimal number
    i: 0
    min: 2
    r: 1
    s: 0
    zyg: 
      - !!perl/hash:RE_bracket 
        decl: []

        min: 2
        re: &118 !!perl/hash:RE_any 
          a: 0
          altname: dec_number_01
          dba: decimal number
          i: 0
          min: 2
          name: dec_number_01
          r: 1
          s: 0
          zyg: 
            - !!perl/hash:RE_sequence 
              a: 0
              alt: dec_number_01 0
              dba: decimal number
              i: 0
              min: 2
              r: 1
              s: 0
              zyg: 
                - !!perl/hash:RE_bindnamed 
                  a: 0
                  atom: !!perl/hash:RE_bracket 
                    decl: []

                    min: 2
                    nobind: 1
                    re: !!perl/hash:RE_sequence 
                      a: 0
                      dba: decimal number
                      i: 0
                      min: 2
                      r: 1
                      s: 0
                      zyg: 
                        - !!perl/hash:RE_string 
                          a: 0
                          dba: decimal number
                          i: 0
                          min: 1
                          r: 1
                          s: 0
                          text: .
                        - !!perl/hash:RE_quantified_atom 
                          atom: !!perl/hash:RE_meta 
                            a: 0
                            dba: decimal number
                            i: 0
                            min: 1
                            r: 1
                            s: 0
                            text: \d
                          min: 1
                          quant: 
                            - +
                            - ":"
                            - ''
                            - 1
                        - !!perl/hash:RE_quantified_atom 
                          atom: !!perl/hash:RE_bracket 
                            decl: []

                            min: 2
                            re: !!perl/hash:RE_sequence 
                              a: 0
                              dba: decimal number
                              i: 0
                              min: 2
                              r: 1
                              s: 0
                              zyg: 
                                - !!perl/hash:RE_string 
                                  a: 0
                                  dba: decimal number
                                  i: 0
                                  min: 1
                                  r: 1
                                  s: 0
                                  text: _
                                - !!perl/hash:RE_quantified_atom 
                                  atom: !!perl/hash:RE_meta 
                                    a: 0
                                    dba: decimal number
                                    i: 0
                                    min: 1
                                    r: 1
                                    s: 0
                                    text: \d
                                  min: 1
                                  quant: 
                                    - +
                                    - ":"
                                    - ''
                                    - 1
                          min: 0
                          quant: 
                            - "*"
                            - ":"
                            - ''
                            - 0
                  dba: decimal number
                  i: 0
                  min: 2
                  r: 1
                  s: 0
                  var: coeff
                - !!perl/hash:RE_quantified_atom 
                  atom: !!perl/hash:RE_method 
                    a: 0
                    dba: decimal number
                    i: 0
                    min: 12345
                    name: escale
                    r: 1
                    rest: ''
                    s: 0
                  min: 0
                  quant: 
                    - "?"
                    - ":"
                    - ''
                    - 0
            - !!perl/hash:RE_sequence 
              a: 0
              alt: dec_number_01 1
              dba: decimal number
              i: 0
              min: 3
              r: 1
              s: 0
              zyg: 
                - !!perl/hash:RE_bindnamed 
                  a: 0
                  atom: !!perl/hash:RE_bracket 
                    decl: []

                    min: 3
                    nobind: 1
                    re: !!perl/hash:RE_sequence 
                      a: 0
                      dba: decimal number
                      i: 0
                      min: 3
                      r: 1
                      s: 0
                      zyg: 
                        - !!perl/hash:RE_quantified_atom 
                          atom: !!perl/hash:RE_meta 
                            a: 0
                            dba: decimal number
                            i: 0
                            min: 1
                            r: 1
                            s: 0
                            text: \d
                          min: 1
                          quant: 
                            - +
                            - ":"
                            - ''
                            - 1
                        - !!perl/hash:RE_quantified_atom 
                          atom: !!perl/hash:RE_bracket 
                            decl: []

                            min: 2
                            re: !!perl/hash:RE_sequence 
                              a: 0
                              dba: decimal number
                              i: 0
                              min: 2
                              r: 1
                              s: 0
                              zyg: 
                                - !!perl/hash:RE_string 
                                  a: 0
                                  dba: decimal number
                                  i: 0
                                  min: 1
                                  r: 1
                                  s: 0
                                  text: _
                                - !!perl/hash:RE_quantified_atom 
                                  atom: !!perl/hash:RE_meta 
                                    a: 0
                                    dba: decimal number
                                    i: 0
                                    min: 1
                                    r: 1
                                    s: 0
                                    text: \d
                                  min: 1
                                  quant: 
                                    - +
                                    - ":"
                                    - ''
                                    - 1
                          min: 0
                          quant: 
                            - "*"
                            - ":"
                            - ''
                            - 0
                        - !!perl/hash:RE_string 
                          a: 0
                          dba: decimal number
                          i: 0
                          min: 1
                          r: 1
                          s: 0
                          text: .
                        - !!perl/hash:RE_quantified_atom 
                          atom: !!perl/hash:RE_meta 
                            a: 0
                            dba: decimal number
                            i: 0
                            min: 1
                            r: 1
                            s: 0
                            text: \d
                          min: 1
                          quant: 
                            - +
                            - ":"
                            - ''
                            - 1
                        - !!perl/hash:RE_quantified_atom 
                          atom: !!perl/hash:RE_bracket 
                            decl: []

                            min: 2
                            re: !!perl/hash:RE_sequence 
                              a: 0
                              dba: decimal number
                              i: 0
                              min: 2
                              r: 1
                              s: 0
                              zyg: 
                                - !!perl/hash:RE_string 
                                  a: 0
                                  dba: decimal number
                                  i: 0
                                  min: 1
                                  r: 1
                                  s: 0
                                  text: _
                                - !!perl/hash:RE_quantified_atom 
                                  atom: !!perl/hash:RE_meta 
                                    a: 0
                                    dba: decimal number
                                    i: 0
                                    min: 1
                                    r: 1
                                    s: 0
                                    text: \d
                                  min: 1
                                  quant: 
                                    - +
                                    - ":"
                                    - ''
                                    - 1
                          min: 0
                          quant: 
                            - "*"
                            - ":"
                            - ''
                            - 0
                  dba: decimal number
                  i: 0
                  min: 3
                  r: 1
                  s: 0
                  var: coeff
                - !!perl/hash:RE_quantified_atom 
                  atom: !!perl/hash:RE_method 
                    a: 0
                    dba: decimal number
                    i: 0
                    min: 12345
                    name: escale
                    r: 1
                    rest: ''
                    s: 0
                  min: 0
                  quant: 
                    - "?"
                    - ":"
                    - ''
                    - 0
            - !!perl/hash:RE_sequence 
              a: 0
              alt: dec_number_01 2
              dba: decimal number
              i: 0
              min: 12346
              r: 1
              s: 0
              zyg: 
                - !!perl/hash:RE_bindnamed 
                  a: 0
                  atom: !!perl/hash:RE_bracket 
                    decl: []

                    min: 1
                    nobind: 1
                    re: !!perl/hash:RE_sequence 
                      a: 0
                      dba: decimal number
                      i: 0
                      min: 1
                      r: 1
                      s: 0
                      zyg: 
                        - !!perl/hash:RE_quantified_atom 
                          atom: !!perl/hash:RE_meta 
                            a: 0
                            dba: decimal number
                            i: 0
                            min: 1
                            r: 1
                            s: 0
                            text: \d
                          min: 1
                          quant: 
                            - +
                            - ":"
                            - ''
                            - 1
                        - !!perl/hash:RE_quantified_atom 
                          atom: !!perl/hash:RE_bracket 
                            decl: []

                            min: 2
                            re: !!perl/hash:RE_sequence 
                              a: 0
                              dba: decimal number
                              i: 0
                              min: 2
                              r: 1
                              s: 0
                              zyg: 
                                - !!perl/hash:RE_string 
                                  a: 0
                                  dba: decimal number
                                  i: 0
                                  min: 1
                                  r: 1
                                  s: 0
                                  text: _
                                - !!perl/hash:RE_quantified_atom 
                                  atom: !!perl/hash:RE_meta 
                                    a: 0
                                    dba: decimal number
                                    i: 0
                                    min: 1
                                    r: 1
                                    s: 0
                                    text: \d
                                  min: 1
                                  quant: 
                                    - +
                                    - ":"
                                    - ''
                                    - 1
                          min: 0
                          quant: 
                            - "*"
                            - ":"
                            - ''
                            - 0
                  dba: decimal number
                  i: 0
                  min: 1
                  r: 1
                  s: 0
                  var: coeff
                - !!perl/hash:RE_method 
                  a: 0
                  dba: decimal number
                  i: 0
                  min: 12345
                  name: escale
                  r: 1
                  rest: ''
                  s: 0
      - !!perl/hash:RE_assertion 
        assert: "!"
        min: 0
        re: !!perl/hash:RE_assertion 
          assert: "!"
          min: 0
          nobind: 1
          re: !!perl/hash:RE_method_re 
            a: 0
            dba: decimal number
            i: 0
            min: 0
            name: before
            nobind: 1
            r: 1
            re: !!perl/hash:RE 
              decl: []

              min: 0
              re: !!perl/hash:RE_quantified_atom 
                atom: !!perl/hash:RE_bracket 
                  decl: []

                  min: 1
                  re: !!perl/hash:RE_sequence 
                    a: 0
                    dba: decimal number
                    i: 0
                    min: 1
                    r: 1
                    s: 0
                    zyg: 
                      - !!perl/hash:RE_string 
                        a: 0
                        dba: decimal number
                        i: 0
                        min: 1
                        r: 1
                        s: 0
                        text: .
                      - !!perl/hash:RE_assertion 
                        assert: "?"
                        min: 0
                        re: !!perl/hash:RE_method_re 
                          a: 0
                          dba: decimal number
                          i: 0
                          min: 0
                          name: before
                          nobind: 1
                          r: 1
                          re: !!perl/hash:RE 
                            decl: []

                            min: 1
                            re: !!perl/hash:RE_meta 
                              a: 0
                              dba: decimal number
                              i: 0
                              min: 1
                              r: 1
                              s: 0
                              text: \d
                          s: 0
                      - !!perl/hash:RE_method 
                        min: 0
                        name: panic
                        nobind: 1
                        rest: ("Number contains two decimal points (missing 'v' for version number?)")
                min: 0
                quant: 
                  - "?"
                  - ":"
                  - ''
                  - 0
            s: 0
dec_number_01: *118
declarator: !!perl/hash:RE 
  decl: []

  kind: token
  min: 12345
  pkg: ~
  re: !!perl/hash:RE_bracket 
    decl: []

    min: 12345
    re: &17 !!perl/hash:RE_any 
      a: 0
      altname: declarator_01
      dba: declarator
      i: 0
      min: 12345
      name: declarator_01
      r: 1
      s: 0
      zyg: 
        - !!perl/hash:RE_method 
          a: 0
          alt: declarator_01 0
          dba: declarator
          i: 0
          min: 12345
          name: constant_declarator
          r: 1
          rest: ''
          s: 0
        - !!perl/hash:RE_method 
          a: 0
          alt: declarator_01 1
          dba: declarator
          i: 0
          min: 12345
          name: variable_declarator
          r: 1
          rest: ''
          s: 0
        - !!perl/hash:RE_sequence 
          a: 0
          alt: declarator_01 2
          dba: declarator
          i: 0
          min: 12347
          r: 1
          s: 0
          zyg: 
            - !!perl/hash:RE_string 
              a: 0
              dba: declarator
              i: 0
              min: 1
              r: 1
              s: 0
              text: (
            - !!perl/hash:RE_meta 
              a: 0
              dba: declarator
              extra: "local $::GOAL = ')' "
              i: 0
              min: 0
              r: 1
              s: 0
              text: "::"
            - !!perl/hash:RE_method 
              a: 0
              dba: declarator
              i: 0
              min: 12345
              name: signature
              r: 1
              rest: ''
              s: 0
            - !!perl/hash:RE_bracket 
              decl: []

              min: 1
              re: !!perl/hash:RE_first 
                a: 0
                dba: declarator
                i: 0
                min: 1
                r: 1
                s: 0
                zyg: 
                  - !!perl/hash:RE_string 
                    a: 0
                    dba: declarator
                    i: 0
                    min: 1
                    r: 1
                    s: 0
                    text: )
                  - !!perl/hash:RE_method 
                    min: 0
                    name: FAILGOAL
                    nobind: 1
                    rest: (')' , 'declarator')
            - !!perl/hash:RE_quantified_atom 
              atom: !!perl/hash:RE_method 
                a: 0
                dba: declarator
                i: 0
                min: 12345
                name: trait
                r: 1
                rest: ''
                s: 0
              min: 0
              quant: 
                - "*"
                - ":"
                - ''
                - 0
        - !!perl/hash:RE_method 
          a: 0
          alt: declarator_01 3
          dba: declarator
          i: 0
          min: 12345
          name: routine_declarator
          r: 1
          rest: ''
          s: 0
        - !!perl/hash:RE_method 
          a: 0
          alt: declarator_01 4
          dba: declarator
          i: 0
          min: 12345
          name: regex_declarator
          r: 1
          rest: ''
          s: 0
        - !!perl/hash:RE_method 
          a: 0
          alt: declarator_01 5
          dba: declarator
          i: 0
          min: 12345
          name: type_declarator
          r: 1
          rest: ''
          s: 0
declarator_01: *17
def_module_name: !!perl/hash:RE 
  decl: []

  kind: token
  min: 12345
  pkg: ~
  re: !!perl/hash:RE_sequence 
    a: 0
    dba: def_module_name
    i: 0
    min: 12345
    r: 1
    s: 0
    zyg: 
      - !!perl/hash:RE_method 
        a: 0
        dba: def_module_name
        i: 0
        min: 12345
        name: longname
        r: 1
        rest: ''
        s: 0
      - !!perl/hash:RE_quantified_atom 
        atom: !!perl/hash:RE_bracket 
          decl: []

          min: 37037
          re: !!perl/hash:RE_sequence 
            a: 0
            dba: generic role
            i: 0
            min: 37037
            r: 1
            s: 0
            zyg: 
              - !!perl/hash:RE_assertion 
                assert: "?"
                min: 0
                re: !!perl/hash:RE_method_re 
                  a: 0
                  dba: generic role
                  i: 0
                  min: 0
                  name: before
                  nobind: 1
                  r: 1
                  re: !!perl/hash:RE 
                    decl: []

                    min: 1
                    re: !!perl/hash:RE_string 
                      a: 0
                      dba: generic role
                      i: 0
                      min: 1
                      r: 1
                      s: 0
                      text: "["
                  s: 0
              - !!perl/hash:RE_assertion 
                assert: "?"
                min: 0
                re: !!perl/hash:RE_block 
                  a: 0
                  context: bool
                  dba: generic role
                  i: 0
                  min: 0
                  nobind: 1
                  r: 1
                  s: 0
                  text: " ($*PKGDECL//'') eq 'role' "
              - !!perl/hash:RE_method 
                a: 0
                dba: generic role
                i: 0
                min: 12345
                name: newpad
                nobind: 1
                r: 1
                rest: ''
                s: 0
              - !!perl/hash:RE_string 
                a: 0
                dba: generic role
                i: 0
                min: 1
                r: 1
                s: 0
                text: "["
              - !!perl/hash:RE_meta 
                a: 0
                dba: generic role
                extra: "local $::GOAL = ']' "
                i: 0
                min: 0
                r: 1
                s: 0
                text: "::"
              - !!perl/hash:RE_method 
                a: 0
                dba: generic role
                i: 0
                min: 12345
                name: signature
                r: 1
                rest: ''
                s: 0
              - !!perl/hash:RE_bracket 
                decl: []

                min: 1
                re: !!perl/hash:RE_first 
                  a: 0
                  dba: generic role
                  i: 0
                  min: 1
                  r: 1
                  s: 0
                  zyg: 
                    - !!perl/hash:RE_string 
                      a: 0
                      dba: generic role
                      i: 0
                      min: 1
                      r: 1
                      s: 0
                      text: "]"
                    - !!perl/hash:RE_method 
                      min: 0
                      name: FAILGOAL
                      nobind: 1
                      rest: (']' , 'generic role')
              - !!perl/hash:RE_block 
                a: 0
                context: void
                dba: generic role
                i: 0
                min: 0
                r: 1
                s: 0
                text: " $*IN_DECL = 0; "
              - !!perl/hash:RE_method 
                a: 0
                dba: generic role
                i: 0
                min: 12345
                name: finishpad
                nobind: 1
                r: 1
                rest: ''
                s: 0
        min: 0
        quant: 
          - "?"
          - ":"
          - ''
          - 0
default_value: !!perl/hash:RE 
  decl: []

  kind: rule
  min: 1
  pkg: ~
  re: !!perl/hash:RE_sequence 
    a: 0
    dba: default_value
    i: 0
    min: 1
    r: 1
    s: 1
    zyg: 
      - !!perl/hash:RE_method 
        min: 0
        name: ws
        nobind: 1
        noquant: 1
        rest: ''
      - !!perl/hash:RE_string 
        a: 0
        dba: default_value
        i: 0
        min: 1
        r: 1
        s: 1
        text: =
      - !!perl/hash:RE_method 
        min: 0
        name: ws
        nobind: 1
        noquant: 1
        rest: ''
      - !!perl/hash:RE_method 
        min: 0
        name: EXPR
        rest: (item %item_assignment)
      - !!perl/hash:RE_method 
        min: 0
        name: ws
        nobind: 1
        noquant: 1
        rest: ''
deflongname: !!perl/hash:RE 
  decl: []

  kind: token
  min: 12345
  pkg: ~
  re: !!perl/hash:RE_sequence 
    a: 0
    dba: new name to be defined
    i: 0
    min: 12345
    r: 1
    s: 0
    zyg: 
      - !!perl/hash:RE_method 
        a: 0
        dba: new name to be defined
        i: 0
        min: 12345
        name: name
        r: 1
        rest: ''
        s: 0
      - !!perl/hash:RE_bracket 
        decl: []

        min: 0
        re: &12 !!perl/hash:RE_any 
          a: 0
          altname: deflongname_01
          dba: new name to be defined
          i: 0
          min: 0
          name: deflongname_01
          r: 1
          s: 0
          zyg: 
            - !!perl/hash:RE_sequence 
              a: 0
              alt: deflongname_01 0
              dba: new name to be defined
              i: 0
              min: 12345
              r: 1
              s: 0
              zyg: 
                - !!perl/hash:RE_quantified_atom 
                  atom: !!perl/hash:RE_method 
                    a: 0
                    dba: new name to be defined
                    i: 0
                    min: 12345
                    name: colonpair
                    r: 1
                    rest: ''
                    s: 0
                  min: 12345
                  quant: 
                    - +
                    - ":"
                    - ''
                    - 1
                - !!perl/hash:RE_block 
                  a: 0
                  context: void
                  dba: new name to be defined
                  i: 0
                  min: 0
                  r: 1
                  s: 0
                  text: " $¢.add_macro($<name>) if $*IN_DECL; "
            - !!perl/hash:RE_block 
              a: 0
              alt: deflongname_01 1
              context: void
              dba: new name to be defined
              i: 0
              min: 0
              r: 1
              s: 0
              text: " $¢.add_routine($<name>.Str) if $*IN_DECL; "
deflongname_01: *12
desigilname: !!perl/hash:RE 
  decl: []

  kind: token
  min: 12345
  pkg: ~
  re: !!perl/hash:RE_bracket 
    decl: []

    min: 12345
    re: &98 !!perl/hash:RE_any 
      a: 0
      altname: desigilname_01
      dba: desigilname
      i: 0
      min: 12345
      name: desigilname_01
      r: 1
      s: 0
      zyg: 
        - !!perl/hash:RE_sequence 
          a: 0
          alt: desigilname_01 0
          dba: desigilname
          i: 0
          min: 12345
          r: 1
          s: 0
          zyg: 
            - !!perl/hash:RE_assertion 
              assert: "?"
              min: 0
              re: !!perl/hash:RE_method_re 
                a: 0
                dba: desigilname
                i: 0
                min: 0
                name: before
                nobind: 1
                r: 1
                re: !!perl/hash:RE 
                  decl: []

                  min: 1
                  re: !!perl/hash:RE_string 
                    a: 0
                    dba: desigilname
                    i: 0
                    min: 1
                    r: 1
                    s: 0
                    text: $
                s: 0
            - !!perl/hash:RE_method 
              a: 0
              dba: desigilname
              i: 0
              min: 12345
              name: variable
              r: 1
              rest: ''
              s: 0
            - !!perl/hash:RE_block 
              a: 0
              context: void
              dba: desigilname
              i: 0
              min: 0
              r: 1
              s: 0
              text: " $*VAR = $<variable> "
        - !!perl/hash:RE_method 
          a: 0
          alt: desigilname_01 1
          dba: desigilname
          i: 0
          min: 12345
          name: longname
          r: 1
          rest: ''
          s: 0
desigilname_01: *98
dotty__S_282DotStar: !!perl/hash:RE 
  decl: []

  kind: token
  min: 24692
  pkg: STD::Methodcall
  re: !!perl/hash:RE_sequence 
    a: 0
    dba: dotty__S_282DotStar
    i: 0
    min: 24692
    r: 1
    s: 0
    zyg: 
      - !!perl/hash:RE_bindpos 
        atom: !!perl/hash:RE_paren 
          decl: []

          min: 2
          re: !!perl/hash:RE_sequence 
            a: 0
            dba: dotty__S_282DotStar
            i: 0
            min: 2
            r: 1
            s: 0
            zyg: 
              - !!perl/hash:RE_string 
                a: 0
                dba: dotty__S_282DotStar
                i: 0
                min: 1
                r: 1
                s: 0
                text: .
              - !!perl/hash:RE_bracket 
                decl: []

                min: 1
                re: &16 !!perl/hash:RE_any 
                  a: 0
                  altname: dotty__S_282DotStar_02
                  dba: dotty__S_282DotStar
                  i: 0
                  min: 1
                  name: dotty__S_282DotStar_02
                  r: 1
                  s: 0
                  zyg: 
                    - !!perl/hash:RE_cclass 
                      a: 0
                      alt: dotty__S_282DotStar_02 0
                      dba: dotty__S_282DotStar
                      i: 0
                      min: 1
                      r: 1
                      s: 0
                      text: "[+*?=]"
                    - !!perl/hash:RE_sequence 
                      a: 0
                      alt: dotty__S_282DotStar_02 1
                      dba: dotty__S_282DotStar
                      i: 0
                      min: 1
                      r: 1
                      s: 0
                      zyg: 
                        - !!perl/hash:RE_string 
                          a: 0
                          dba: dotty__S_282DotStar
                          i: 0
                          min: 1
                          r: 1
                          s: 0
                          text: "^"
                        - !!perl/hash:RE_quantified_atom 
                          atom: !!perl/hash:RE_string 
                            a: 0
                            dba: dotty__S_282DotStar
                            i: 0
                            min: 1
                            r: 1
                            s: 0
                            text: "!"
                          min: 0
                          quant: 
                            - "?"
                            - ":"
                            - ''
                            - 0
        min: 2
        var: 0
      - !!perl/hash:RE_meta 
        a: 0
        dba: dotty__S_282DotStar
        i: 0
        min: 0
        r: 1
        s: 0
        text: "::"
      - !!perl/hash:RE_method 
        a: 0
        dba: dotty__S_282DotStar
        i: 0
        min: 12345
        name: unspacey
        nobind: 1
        r: 1
        rest: ''
        s: 0
      - !!perl/hash:RE_method 
        a: 0
        dba: dotty__S_282DotStar
        i: 0
        min: 12345
        name: dottyop
        r: 1
        rest: ''
        s: 0
      - !!perl/hash:RE_block 
        a: 0
        context: void
        dba: dotty__S_282DotStar
        i: 0
        min: 0
        r: 1
        s: 0
        text: " $<sym> = $0.Str; "
dotty__S_282DotStar_02: *16
dotty__S_283Dot: !!perl/hash:RE 
  decl: []

  kind: token
  min: 37035
  pkg: STD::Methodcall
  re: !!perl/hash:RE_sequence 
    a: 0
    dba: dotty__S_283Dot
    i: 0
    min: 37035
    r: 1
    s: 0
    zyg: 
      - !!perl/hash:RE_method 
        a: 0
        dba: dotty__S_283Dot
        endsym: unspacey
        i: 0
        min: 12345
        name: sym
        r: 1
        rest: ''
        s: 0
        sym: .
      - !!perl/hash:RE_method 
        a: 0
        dba: dotty__S_283Dot
        i: 0
        min: 12345
        name: unspacey
        nobind: 1
        r: 1
        rest: ''
        s: 0
      - !!perl/hash:RE_method 
        a: 0
        dba: dotty__S_283Dot
        i: 0
        min: 12345
        name: dottyop
        r: 1
        rest: ''
        s: 0
dottyop: !!perl/hash:RE 
  decl: []

  kind: token
  min: 12345
  pkg: ~
  re: !!perl/hash:RE_bracket 
    decl: []

    min: 12345
    re: &104 !!perl/hash:RE_any 
      a: 0
      altname: dottyop_01
      dba: dotty method or postfix
      i: 0
      min: 12345
      name: dottyop_01
      r: 1
      s: 0
      zyg: 
        - !!perl/hash:RE_method 
          a: 0
          alt: dottyop_01 0
          dba: dotty method or postfix
          i: 0
          min: 12345
          name: methodop
          r: 1
          rest: ''
          s: 0
        - !!perl/hash:RE_method 
          a: 0
          alt: dottyop_01 1
          dba: dotty method or postfix
          i: 0
          min: 12345
          name: colonpair
          r: 1
          rest: ''
          s: 0
        - !!perl/hash:RE_sequence 
          a: 0
          alt: dottyop_01 2
          dba: dotty method or postfix
          i: 0
          min: 12345
          r: 1
          s: 0
          zyg: 
            - !!perl/hash:RE_assertion 
              assert: "!"
              min: 0
              re: !!perl/hash:RE_method 
                a: 0
                dba: dotty method or postfix
                i: 0
                min: 12345
                name: alpha
                nobind: 1
                r: 1
                rest: ''
                s: 0
            - !!perl/hash:RE_method 
              a: 0
              dba: dotty method or postfix
              i: 0
              min: 12345
              name: postop
              r: 1
              rest: ''
              s: 0
            - !!perl/hash:RE_block 
              a: 0
              context: void
              dba: dotty method or postfix
              i: 0
              min: 0
              r: 1
              s: 0
              text: " $<O> = $<postop><O>; $<sym> = $<postop><sym>; "
dottyop_01: *104
dottyopish: !!perl/hash:RE 
  decl: []

  kind: token
  min: 12345
  pkg: ~
  re: !!perl/hash:RE_bindnamed 
    a: 0
    atom: !!perl/hash:RE_method 
      a: 0
      dba: dottyopish
      i: 0
      min: 12345
      name: dottyop
      nobind: 1
      r: 1
      rest: ''
      s: 0
    dba: dottyopish
    i: 0
    min: 12345
    r: 1
    s: 0
    var: noun
eat_terminator: !!perl/hash:RE 
  decl: []

  kind: token
  min: 0
  pkg: ~
  re: !!perl/hash:RE_bracket 
    decl: []

    min: 0
    re: !!perl/hash:RE_first 
      a: 0
      dba: eat_terminator
      i: 0
      min: 0
      r: 1
      s: 0
      zyg: 
        - !!perl/hash:RE_string 
          a: 0
          dba: eat_terminator
          i: 0
          min: 1
          r: 1
          s: 0
          text: ;
        - !!perl/hash:RE_sequence 
          a: 0
          dba: eat_terminator
          i: 0
          min: 12345
          r: 1
          s: 0
          zyg: 
            - !!perl/hash:RE_assertion 
              assert: "?"
              min: 0
              re: !!perl/hash:RE_block 
                a: 0
                context: bool
                dba: eat_terminator
                i: 0
                min: 0
                nobind: 1
                r: 1
                s: 0
                text: " @*MEMOS[$¢.pos]<endstmt> "
            - !!perl/hash:RE_method 
              a: 0
              dba: eat_terminator
              i: 0
              min: 12345
              name: ws
              nobind: 1
              r: 1
              rest: ''
              s: 0
        - !!perl/hash:RE_assertion 
          assert: "?"
          min: 0
          re: !!perl/hash:RE_method 
            a: 0
            dba: eat_terminator
            i: 0
            min: 12345
            name: terminator
            nobind: 1
            r: 1
            rest: ''
            s: 0
        - !!perl/hash:RE_meta 
          a: 0
          dba: eat_terminator
          i: 0
          min: 0
          r: 1
          s: 0
          text: $
        - !!perl/hash:RE_sequence 
          a: 0
          dba: eat_terminator
          i: 0
          min: 0
          r: 1
          s: 0
          zyg: 
            - !!perl/hash:RE_block 
              a: 0
              context: void
              dba: eat_terminator
              i: 0
              min: 0
              r: 1
              s: 0
              text: " if @*MEMOS[$¢.pos]<ws> { $¢.pos = @*MEMOS[$¢.pos]<ws>; } "
            - !!perl/hash:RE_method 
              min: 0
              name: panic
              nobind: 1
              rest: ("Confused")
endid: !!perl/hash:RE 
  decl: []

  kind: token
  min: 0
  pkg: ~
  re: !!perl/hash:RE_assertion 
    assert: "?"
    min: 0
    re: !!perl/hash:RE_method_re 
      a: 0
      dba: endid
      i: 0
      min: 0
      name: before
      nobind: 1
      r: 1
      re: !!perl/hash:RE 
        decl: []

        min: 1
        re: !!perl/hash:RE_cclass 
          a: 0
          dba: endid
          i: 0
          min: 1
          r: 1
          s: 0
          text: -[ \- \' \w ]
      s: 0
escale: !!perl/hash:RE 
  decl: []

  kind: token
  min: 2
  pkg: ~
  re: !!perl/hash:RE_sequence 
    a: 0
    dba: escale
    i: 0
    min: 2
    r: 1
    s: 0
    zyg: 
      - !!perl/hash:RE_cclass 
        a: 0
        dba: escale
        i: 0
        min: 1
        r: 1
        s: 0
        text: "[Ee]"
      - !!perl/hash:RE_quantified_atom 
        atom: !!perl/hash:RE_cclass 
          a: 0
          dba: escale
          i: 0
          min: 1
          r: 1
          s: 0
          text: "[+\\-]"
        min: 0
        quant: 
          - "?"
          - ":"
          - ''
          - 0
      - !!perl/hash:RE_quantified_atom 
        atom: !!perl/hash:RE_meta 
          a: 0
          dba: escale
          i: 0
          min: 1
          r: 1
          s: 0
          text: \d
        min: 1
        quant: 
          - +
          - ":"
          - ''
          - 1
      - !!perl/hash:RE_quantified_atom 
        atom: !!perl/hash:RE_bracket 
          decl: []

          min: 2
          re: !!perl/hash:RE_sequence 
            a: 0
            dba: escale
            i: 0
            min: 2
            r: 1
            s: 0
            zyg: 
              - !!perl/hash:RE_string 
                a: 0
                dba: escale
                i: 0
                min: 1
                r: 1
                s: 0
                text: _
              - !!perl/hash:RE_quantified_atom 
                atom: !!perl/hash:RE_meta 
                  a: 0
                  dba: escale
                  i: 0
                  min: 1
                  r: 1
                  s: 0
                  text: \d
                min: 1
                quant: 
                  - +
                  - ":"
                  - ''
                  - 1
        min: 0
        quant: 
          - "*"
          - ":"
          - ''
          - 0
escape__S_192none: !!perl/hash:RE 
  decl: []

  kind: token
  min: 0
  pkg: ~
  re: !!perl/hash:RE_assertion 
    assert: "!"
    min: 0
    re: !!perl/hash:RE_noop 
      a: 0
      dba: escape__S_192none
      i: 0
      min: 0
      nobind: 1
      r: 1
      s: 0
fakesignature: !!perl/hash:RE 
  decl: []

  kind: token
  min: 24690
  pkg: ~
  re: !!perl/hash:RE_sequence 
    a: 0
    dba: fakesignature
    i: 0
    min: 24690
    r: 1
    s: 0
    zyg: 
      - !!perl/hash:RE_method 
        a: 0
        dba: fakesignature
        i: 0
        min: 12345
        name: newpad
        nobind: 1
        r: 1
        rest: ''
        s: 0
      - !!perl/hash:RE_method 
        a: 0
        dba: fakesignature
        i: 0
        min: 12345
        name: signature
        r: 1
        rest: ''
        s: 0
fatarrow: !!perl/hash:RE 
  decl: []

  kind: token
  min: 24692
  pkg: ~
  re: !!perl/hash:RE_sequence 
    a: 0
    dba: fatarrow
    i: 0
    min: 24692
    r: 1
    s: 0
    zyg: 
      - !!perl/hash:RE_bindnamed 
        a: 0
        atom: !!perl/hash:RE_method 
          a: 0
          dba: fatarrow
          i: 0
          min: 12345
          name: identifier
          nobind: 1
          r: 1
          rest: ''
          s: 0
        dba: fatarrow
        i: 0
        min: 12345
        r: 1
        s: 0
        var: key
      - !!perl/hash:RE_quantified_atom 
        atom: !!perl/hash:RE_meta 
          a: 0
          dba: fatarrow
          i: 0
          min: 1
          r: 1
          s: 0
          text: \h
        min: 0
        quant: 
          - "*"
          - ":"
          - ''
          - 0
      - !!perl/hash:RE_string 
        a: 0
        dba: fatarrow
        i: 0
        min: 2
        r: 1
        s: 0
        text: =>
      - !!perl/hash:RE_method 
        a: 0
        dba: fatarrow
        i: 0
        min: 12345
        name: ws
        nobind: 1
        r: 1
        rest: ''
        s: 0
      - !!perl/hash:RE_bindnamed 
        a: 0
        atom: !!perl/hash:RE_method 
          min: 0
          name: EXPR
          nobind: 1
          rest: (item %item_assignment)
        dba: fatarrow
        i: 0
        min: 0
        r: 1
        s: 0
        var: val
hexint: !!perl/hash:RE 
  decl: []

  kind: token
  min: 1
  pkg: ~
  re: !!perl/hash:RE_sequence 
    a: 0
    dba: hexint
    i: 0
    min: 1
    r: 1
    s: 0
    zyg: 
      - !!perl/hash:RE_quantified_atom 
        atom: !!perl/hash:RE_cclass 
          a: 0
          dba: hexint
          i: 0
          min: 1
          r: 1
          s: 0
          text: "[ 0..9 a..f A..F ]"
        min: 1
        quant: 
          - +
          - ":"
          - ''
          - 1
      - !!perl/hash:RE_quantified_atom 
        atom: !!perl/hash:RE_bracket 
          decl: []

          min: 2
          re: !!perl/hash:RE_sequence 
            a: 0
            dba: hexint
            i: 0
            min: 2
            r: 1
            s: 0
            zyg: 
              - !!perl/hash:RE_string 
                a: 0
                dba: hexint
                i: 0
                min: 1
                r: 1
                s: 0
                text: _
              - !!perl/hash:RE_quantified_atom 
                atom: !!perl/hash:RE_cclass 
                  a: 0
                  dba: hexint
                  i: 0
                  min: 1
                  r: 1
                  s: 0
                  text: "[ 0..9 a..f A..F ]"
                min: 1
                quant: 
                  - +
                  - ":"
                  - ''
                  - 1
        min: 0
        quant: 
          - "*"
          - ":"
          - ''
          - 0
hexints: !!perl/hash:RE 
  decl: []

  kind: token
  min: 37035
  pkg: ~
  re: !!perl/hash:RE_quantified_atom 
    atom: !!perl/hash:RE_bracket 
      decl: []

      min: 37035
      re: !!perl/hash:RE_sequence 
        a: 0
        dba: hexints
        i: 0
        min: 37035
        r: 1
        s: 0
        zyg: 
          - !!perl/hash:RE_method 
            a: 0
            dba: hexints
            i: 0
            min: 12345
            name: ws
            nobind: 1
            r: 1
            rest: ''
            s: 0
          - !!perl/hash:RE_method 
            a: 0
            dba: hexints
            i: 0
            min: 12345
            name: hexint
            r: 1
            rest: ''
            s: 0
          - !!perl/hash:RE_method 
            a: 0
            dba: hexints
            i: 0
            min: 12345
            name: ws
            nobind: 1
            r: 1
            rest: ''
            s: 0
    min: 37035
    quant: 
      - "**"
      - ":"
      - !!perl/hash:RE_string 
        a: 0
        dba: hexints
        i: 0
        min: 1
        r: 1
        s: 0
        text: ","
      - 1
ident: !!perl/hash:RE 
  decl: []

  kind: token
  min: 12345
  pkg: ~
  re: !!perl/hash:RE_sequence 
    a: 0
    dba: ident
    i: 0
    min: 12345
    r: 1
    s: 0
    zyg: 
      - !!perl/hash:RE_method 
        a: 0
        dba: ident
        i: 0
        min: 12345
        name: alpha
        nobind: 1
        r: 1
        rest: ''
        s: 0
      - !!perl/hash:RE_quantified_atom 
        atom: !!perl/hash:RE_meta 
          a: 0
          dba: ident
          i: 0
          min: 1
          r: 1
          s: 0
          text: \w
        min: 0
        quant: 
          - "*"
          - ":"
          - ''
          - 0
identifier: !!perl/hash:RE 
  decl: []

  kind: token
  min: 12345
  pkg: ~
  re: !!perl/hash:RE_sequence 
    a: 0
    dba: identifier
    i: 0
    min: 12345
    r: 1
    s: 0
    zyg: 
      - !!perl/hash:RE_method 
        a: 0
        dba: identifier
        i: 0
        min: 12345
        name: ident
        nobind: 1
        r: 1
        rest: ''
        s: 0
      - !!perl/hash:RE_quantified_atom 
        atom: !!perl/hash:RE_bracket 
          decl: []

          min: 24690
          re: !!perl/hash:RE_sequence 
            a: 0
            dba: identifier
            i: 0
            min: 24690
            r: 1
            s: 0
            zyg: 
              - !!perl/hash:RE_method 
                a: 0
                dba: identifier
                i: 0
                min: 12345
                name: apostrophe
                nobind: 1
                r: 1
                rest: ''
                s: 0
              - !!perl/hash:RE_method 
                a: 0
                dba: identifier
                i: 0
                min: 12345
                name: ident
                nobind: 1
                r: 1
                rest: ''
                s: 0
        min: 0
        quant: 
          - "*"
          - ":"
          - ''
          - 0
infix__S_278lambda: !!perl/hash:RE 
  decl: []

  kind: token
  min: 0
  pkg: STD::Term
  re: !!perl/hash:RE_sequence 
    a: 0
    dba: infix__S_278lambda
    i: 0
    min: 0
    r: 1
    s: 0
    zyg: 
      - !!perl/hash:RE_assertion 
        assert: "?"
        min: 0
        re: !!perl/hash:RE_method_re 
          a: 0
          dba: infix__S_278lambda
          i: 0
          min: 0
          name: before
          nobind: 1
          r: 1
          re: !!perl/hash:RE 
            decl: []

            min: 1
            re: &107 !!perl/hash:RE_any 
              a: 0
              altname: infix__S_278lambda_01
              dba: infix__S_278lambda
              i: 0
              min: 1
              name: infix__S_278lambda_01
              r: 1
              s: 0
              zyg: 
                - !!perl/hash:RE_string 
                  a: 0
                  alt: infix__S_278lambda_01 0
                  dba: infix__S_278lambda
                  i: 0
                  min: 1
                  r: 1
                  s: 0
                  text: "{"
                - !!perl/hash:RE_string 
                  a: 0
                  alt: infix__S_278lambda_01 1
                  dba: infix__S_278lambda
                  i: 0
                  min: 2
                  r: 1
                  s: 0
                  text: ->
          s: 0
      - !!perl/hash:RE_block 
        a: 0
        context: void
        dba: infix__S_278lambda
        i: 0
        min: 0
        r: 1
        s: 0
        text: "\n        my $line = $¢.lineof($¢.pos);\n        for 'if', 'unless', 'while', 'until', 'for', 'loop', 'given', 'when' {\n            my $m = %*MYSTERY{$_};\n            next unless $m;\n            if $line - ($m.<line>//-123) < 5 {\n                $¢.panic(\"$_() interpreted as function call at line \" ~ $m.<line> ~\n                \"; please use whitespace instead of parens\\nUnexpected block in infix position (two terms in a row)\");\n            }\n        }\n        return () if $*IN_REDUCE;\n        $¢.panic(\"Unexpected block in infix position (two terms in a row, or previous statement missing semicolon?)\");\n    "
infix__S_278lambda_01: *107
infix__S_302Dot: !!perl/hash:RE 
  decl: []

  kind: token
  min: 2
  pkg: ~
  re: !!perl/hash:RE_sequence 
    a: 0
    dba: infix__S_302Dot
    i: 0
    min: 2
    r: 1
    s: 0
    zyg: 
      - !!perl/hash:RE_string 
        a: 0
        dba: infix__S_302Dot
        i: 0
        min: 1
        r: 1
        s: 0
        text: .
      - !!perl/hash:RE_cclass 
        a: 0
        dba: infix__S_302Dot
        i: 0
        min: 1
        r: 1
        s: 0
        text: "[\\]\\)\\},:\\s\\$\"']"
      - !!perl/hash:RE_method 
        min: 0
        name: obs
        nobind: 1
        rest: ('. to concatenate strings', '~')
infix__S_308StarStar: !!perl/hash:RE 
  decl: []

  kind: token
  min: 12345
  pkg: STD::Exponentiation
  re: !!perl/hash:RE_method 
    a: 0
    dba: infix__S_308StarStar
    i: 0
    min: 12345
    name: sym
    r: 1
    rest: ''
    s: 0
    sym: "**"
infix__S_323Star: !!perl/hash:RE 
  decl: []

  kind: token
  min: 12345
  pkg: STD::Multiplicative
  re: !!perl/hash:RE_method 
    a: 0
    dba: infix__S_323Star
    i: 0
    min: 12345
    name: sym
    r: 1
    rest: ''
    s: 0
    sym: "*"
infix__S_324Slash: !!perl/hash:RE 
  decl: []

  kind: token
  min: 12345
  pkg: STD::Multiplicative
  re: !!perl/hash:RE_method 
    a: 0
    dba: infix__S_324Slash
    i: 0
    min: 12345
    name: sym
    r: 1
    rest: ''
    s: 0
    sym: /
infix__S_325div: !!perl/hash:RE 
  decl: []

  kind: token
  min: 12345
  pkg: STD::Multiplicative
  re: !!perl/hash:RE_method 
    a: 0
    dba: infix__S_325div
    i: 0
    min: 12345
    name: sym
    r: 1
    rest: ''
    s: 0
    sym: div
infix__S_326Percent: !!perl/hash:RE 
  decl: []

  kind: token
  min: 12345
  pkg: STD::Multiplicative
  re: !!perl/hash:RE_sequence 
    a: 0
    dba: infix__S_326Percent
    i: 0
    min: 12345
    r: 1
    s: 0
    zyg: 
      - !!perl/hash:RE_method 
        a: 0
        dba: infix__S_326Percent
        i: 0
        min: 12345
        name: sym
        r: 1
        rest: ''
        s: 0
        sym: "%"
      - !!perl/hash:RE_assertion 
        assert: "?"
        min: 0
        re: !!perl/hash:RE_block 
          a: 0
          context: bool
          dba: infix__S_326Percent
          i: 0
          min: 0
          nobind: 1
          r: 1
          s: 0
          text: " $<O><iffy> = 1; "
infix__S_327mod: !!perl/hash:RE 
  decl: []

  kind: token
  min: 12345
  pkg: STD::Multiplicative
  re: !!perl/hash:RE_method 
    a: 0
    dba: infix__S_327mod
    i: 0
    min: 12345
    name: sym
    r: 1
    rest: ''
    s: 0
    sym: mod
infix__S_328PlusAmp: !!perl/hash:RE 
  decl: []

  kind: token
  min: 12345
  pkg: STD::Multiplicative
  re: !!perl/hash:RE_method 
    a: 0
    dba: infix__S_328PlusAmp
    i: 0
    min: 12345
    name: sym
    r: 1
    rest: ''
    s: 0
    sym: +&
infix__S_329PlusLt: !!perl/hash:RE 
  decl: []

  kind: token
  min: 12345
  pkg: STD::Multiplicative
  re: !!perl/hash:RE_sequence 
    a: 0
    dba: infix__S_329PlusLt
    i: 0
    min: 12345
    r: 1
    s: 0
    zyg: 
      - !!perl/hash:RE_method 
        a: 0
        dba: infix__S_329PlusLt
        i: 0
        min: 12345
        name: sym
        r: 1
        rest: ''
        s: 0
        sym: +<
      - !!perl/hash:RE_assertion 
        assert: "!"
        min: 0
        re: !!perl/hash:RE_method_re 
          a: 0
          dba: infix__S_329PlusLt
          i: 0
          min: 0
          name: before
          nobind: 1
          r: 1
          re: !!perl/hash:RE 
            decl: []

            min: 1
            re: !!perl/hash:RE_string 
              a: 0
              dba: infix__S_329PlusLt
              i: 0
              min: 1
              r: 1
              s: 0
              text: <
          s: 0
infix__S_330LtLt: !!perl/hash:RE 
  decl: []

  kind: token
  min: 12346
  pkg: STD::Multiplicative
  re: !!perl/hash:RE_sequence 
    a: 0
    dba: infix__S_330LtLt
    i: 0
    min: 12346
    r: 1
    s: 0
    zyg: 
      - !!perl/hash:RE_method 
        a: 0
        dba: infix__S_330LtLt
        i: 0
        min: 12345
        name: sym
        r: 1
        rest: ''
        s: 0
        sym: <<
      - !!perl/hash:RE_meta 
        a: 0
        dba: infix__S_330LtLt
        i: 0
        min: 1
        r: 1
        s: 0
        text: \s
      - !!perl/hash:RE_method 
        min: 0
        name: obs
        nobind: 1
        rest: ('<< to do left shift', '+< or ~<')
infix__S_331GtGt: !!perl/hash:RE 
  decl: []

  kind: token
  min: 12346
  pkg: STD::Multiplicative
  re: !!perl/hash:RE_sequence 
    a: 0
    dba: infix__S_331GtGt
    i: 0
    min: 12346
    r: 1
    s: 0
    zyg: 
      - !!perl/hash:RE_method 
        a: 0
        dba: infix__S_331GtGt
        i: 0
        min: 12345
        name: sym
        r: 1
        rest: ''
        s: 0
        sym: ">>"
      - !!perl/hash:RE_meta 
        a: 0
        dba: infix__S_331GtGt
        i: 0
        min: 1
        r: 1
        s: 0
        text: \s
      - !!perl/hash:RE_method 
        min: 0
        name: obs
        nobind: 1
        rest: ('>> to do right shift', '+> or ~>')
infix__S_332PlusGt: !!perl/hash:RE 
  decl: []

  kind: token
  min: 12345
  pkg: STD::Multiplicative
  re: !!perl/hash:RE_sequence 
    a: 0
    dba: infix__S_332PlusGt
    i: 0
    min: 12345
    r: 1
    s: 0
    zyg: 
      - !!perl/hash:RE_method 
        a: 0
        dba: infix__S_332PlusGt
        i: 0
        min: 12345
        name: sym
        r: 1
        rest: ''
        s: 0
        sym: +>
      - !!perl/hash:RE_assertion 
        assert: "!"
        min: 0
        re: !!perl/hash:RE_method_re 
          a: 0
          dba: infix__S_332PlusGt
          i: 0
          min: 0
          name: before
          nobind: 1
          r: 1
          re: !!perl/hash:RE 
            decl: []

            min: 1
            re: !!perl/hash:RE_string 
              a: 0
              dba: infix__S_332PlusGt
              i: 0
              min: 1
              r: 1
              s: 0
              text: ">"
          s: 0
infix__S_333TildeAmp: !!perl/hash:RE 
  decl: []

  kind: token
  min: 12345
  pkg: STD::Multiplicative
  re: !!perl/hash:RE_method 
    a: 0
    dba: infix__S_333TildeAmp
    i: 0
    min: 12345
    name: sym
    r: 1
    rest: ''
    s: 0
    sym: ~&
infix__S_334QuestionAmp: !!perl/hash:RE 
  decl: []

  kind: token
  min: 12345
  pkg: STD::Multiplicative
  re: !!perl/hash:RE_method 
    a: 0
    dba: infix__S_334QuestionAmp
    i: 0
    min: 12345
    name: sym
    r: 1
    rest: ''
    s: 0
    sym: ?&
infix__S_335TildeLt: !!perl/hash:RE 
  decl: []

  kind: token
  min: 12345
  pkg: STD::Multiplicative
  re: !!perl/hash:RE_sequence 
    a: 0
    dba: infix__S_335TildeLt
    i: 0
    min: 12345
    r: 1
    s: 0
    zyg: 
      - !!perl/hash:RE_method 
        a: 0
        dba: infix__S_335TildeLt
        i: 0
        min: 12345
        name: sym
        r: 1
        rest: ''
        s: 0
        sym: ~<
      - !!perl/hash:RE_assertion 
        assert: "!"
        min: 0
        re: !!perl/hash:RE_method_re 
          a: 0
          dba: infix__S_335TildeLt
          i: 0
          min: 0
          name: before
          nobind: 1
          r: 1
          re: !!perl/hash:RE 
            decl: []

            min: 1
            re: !!perl/hash:RE_string 
              a: 0
              dba: infix__S_335TildeLt
              i: 0
              min: 1
              r: 1
              s: 0
              text: <
          s: 0
infix__S_336TildeGt: !!perl/hash:RE 
  decl: []

  kind: token
  min: 12345
  pkg: STD::Multiplicative
  re: !!perl/hash:RE_sequence 
    a: 0
    dba: infix__S_336TildeGt
    i: 0
    min: 12345
    r: 1
    s: 0
    zyg: 
      - !!perl/hash:RE_method 
        a: 0
        dba: infix__S_336TildeGt
        i: 0
        min: 12345
        name: sym
        r: 1
        rest: ''
        s: 0
        sym: ~>
      - !!perl/hash:RE_assertion 
        assert: "!"
        min: 0
        re: !!perl/hash:RE_method_re 
          a: 0
          dba: infix__S_336TildeGt
          i: 0
          min: 0
          name: before
          nobind: 1
          r: 1
          re: !!perl/hash:RE 
            decl: []

            min: 1
            re: !!perl/hash:RE_string 
              a: 0
              dba: infix__S_336TildeGt
              i: 0
              min: 1
              r: 1
              s: 0
              text: ">"
          s: 0
infix__S_337Plus: !!perl/hash:RE 
  decl: []

  kind: token
  min: 12345
  pkg: STD::Additive
  re: !!perl/hash:RE_method 
    a: 0
    dba: infix__S_337Plus
    i: 0
    min: 12345
    name: sym
    r: 1
    rest: ''
    s: 0
    sym: +
infix__S_338Minus: !!perl/hash:RE 
  decl: []

  kind: token
  min: 12345
  pkg: STD::Additive
  re: !!perl/hash:RE_method 
    a: 0
    dba: infix__S_338Minus
    i: 0
    min: 12345
    name: sym
    r: 1
    rest: ''
    s: 0
    sym: "-"
infix__S_339PlusVert: !!perl/hash:RE 
  decl: []

  kind: token
  min: 12345
  pkg: STD::Additive
  re: !!perl/hash:RE_method 
    a: 0
    dba: infix__S_339PlusVert
    i: 0
    min: 12345
    name: sym
    r: 1
    rest: ''
    s: 0
    sym: +|
infix__S_340PlusCaret: !!perl/hash:RE 
  decl: []

  kind: token
  min: 12345
  pkg: STD::Additive
  re: !!perl/hash:RE_method 
    a: 0
    dba: infix__S_340PlusCaret
    i: 0
    min: 12345
    name: sym
    r: 1
    rest: ''
    s: 0
    sym: +^
infix__S_341TildeVert: !!perl/hash:RE 
  decl: []

  kind: token
  min: 12345
  pkg: STD::Additive
  re: !!perl/hash:RE_method 
    a: 0
    dba: infix__S_341TildeVert
    i: 0
    min: 12345
    name: sym
    r: 1
    rest: ''
    s: 0
    sym: ~|
infix__S_342TildeCaret: !!perl/hash:RE 
  decl: []

  kind: token
  min: 12345
  pkg: STD::Additive
  re: !!perl/hash:RE_method 
    a: 0
    dba: infix__S_342TildeCaret
    i: 0
    min: 12345
    name: sym
    r: 1
    rest: ''
    s: 0
    sym: ~^
infix__S_343QuestionVert: !!perl/hash:RE 
  decl: []

  kind: token
  min: 12345
  pkg: STD::Additive
  re: !!perl/hash:RE_method 
    a: 0
    dba: infix__S_343QuestionVert
    i: 0
    min: 12345
    name: sym
    r: 1
    rest: ''
    s: 0
    sym: ?|
infix__S_344QuestionCaret: !!perl/hash:RE 
  decl: []

  kind: token
  min: 12345
  pkg: STD::Additive
  re: !!perl/hash:RE_method 
    a: 0
    dba: infix__S_344QuestionCaret
    i: 0
    min: 12345
    name: sym
    r: 1
    rest: ''
    s: 0
    sym: ?^
infix__S_345x: !!perl/hash:RE 
  decl: []

  kind: token
  min: 12345
  pkg: STD::Replication
  re: !!perl/hash:RE_method 
    a: 0
    dba: infix__S_345x
    i: 0
    min: 12345
    name: sym
    r: 1
    rest: ''
    s: 0
    sym: x
infix__S_346xx: !!perl/hash:RE 
  decl: []

  kind: token
  min: 12345
  pkg: STD::Replication
  re: !!perl/hash:RE_method 
    a: 0
    dba: infix__S_346xx
    i: 0
    min: 12345
    name: sym
    r: 1
    rest: ''
    s: 0
    sym: xx
infix__S_347Tilde: !!perl/hash:RE 
  decl: []

  kind: token
  min: 12345
  pkg: STD::Concatenation
  re: !!perl/hash:RE_method 
    a: 0
    dba: infix__S_347Tilde
    i: 0
    min: 12345
    name: sym
    r: 1
    rest: ''
    s: 0
    sym: '~'
infix__S_348Amp: !!perl/hash:RE 
  decl: []

  kind: token
  min: 12345
  pkg: STD::Junctive_and
  re: !!perl/hash:RE_method 
    a: 0
    dba: infix__S_348Amp
    i: 0
    min: 12345
    name: sym
    r: 1
    rest: ''
    s: 0
    sym: "&"
infix__S_349also: !!perl/hash:RE 
  decl: []

  kind: token
  min: 12345
  pkg: STD::Junctive_and
  re: !!perl/hash:RE_method 
    a: 0
    dba: infix__S_349also
    i: 0
    min: 12345
    name: sym
    r: 1
    rest: ''
    s: 0
    sym: also
infix__S_350Vert: !!perl/hash:RE 
  decl: []

  kind: token
  min: 12345
  pkg: STD::Junctive_or
  re: !!perl/hash:RE_method 
    a: 0
    dba: infix__S_350Vert
    i: 0
    min: 12345
    name: sym
    r: 1
    rest: ''
    s: 0
    sym: "|"
infix__S_351Caret: !!perl/hash:RE 
  decl: []

  kind: token
  min: 12345
  pkg: STD::Junctive_or
  re: !!perl/hash:RE_method 
    a: 0
    dba: infix__S_351Caret
    i: 0
    min: 12345
    name: sym
    r: 1
    rest: ''
    s: 0
    sym: "^"
infix__S_356LtEqualGt: !!perl/hash:RE 
  decl: []

  kind: token
  min: 12345
  pkg: STD::Structural
  re: !!perl/hash:RE_sequence 
    a: 0
    dba: infix__S_356LtEqualGt
    i: 0
    min: 12345
    r: 1
    s: 0
    zyg: 
      - !!perl/hash:RE_method 
        a: 0
        dba: infix__S_356LtEqualGt
        i: 0
        min: 12345
        name: sym
        r: 1
        rest: ''
        s: 0
        sym: <=>
      - !!perl/hash:RE_assertion 
        assert: "?"
        min: 0
        re: !!perl/hash:RE_block 
          a: 0
          context: bool
          dba: infix__S_356LtEqualGt
          i: 0
          min: 0
          nobind: 1
          r: 1
          s: 0
          text: " $<O><returns> = \"Order\"; "
infix__S_357cmp: !!perl/hash:RE 
  decl: []

  kind: token
  min: 12345
  pkg: STD::Structural
  re: !!perl/hash:RE_sequence 
    a: 0
    dba: infix__S_357cmp
    i: 0
    min: 12345
    r: 1
    s: 0
    zyg: 
      - !!perl/hash:RE_method 
        a: 0
        dba: infix__S_357cmp
        i: 0
        min: 12345
        name: sym
        r: 1
        rest: ''
        s: 0
        sym: cmp
      - !!perl/hash:RE_assertion 
        assert: "?"
        min: 0
        re: !!perl/hash:RE_block 
          a: 0
          context: bool
          dba: infix__S_357cmp
          i: 0
          min: 0
          nobind: 1
          r: 1
          s: 0
          text: " $<O><returns> = \"Order\"; "
infix__S_358leg: !!perl/hash:RE 
  decl: []

  kind: token
  min: 12345
  pkg: STD::Structural
  re: !!perl/hash:RE_sequence 
    a: 0
    dba: infix__S_358leg
    i: 0
    min: 12345
    r: 1
    s: 0
    zyg: 
      - !!perl/hash:RE_method 
        a: 0
        dba: infix__S_358leg
        i: 0
        min: 12345
        name: sym
        r: 1
        rest: ''
        s: 0
        sym: leg
      - !!perl/hash:RE_assertion 
        assert: "?"
        min: 0
        re: !!perl/hash:RE_block 
          a: 0
          context: bool
          dba: infix__S_358leg
          i: 0
          min: 0
          nobind: 1
          r: 1
          s: 0
          text: " $<O><returns> = \"Order\"; "
infix__S_359but: !!perl/hash:RE 
  decl: []

  kind: token
  min: 12345
  pkg: STD::Structural
  re: !!perl/hash:RE_method 
    a: 0
    dba: infix__S_359but
    i: 0
    min: 12345
    name: sym
    r: 1
    rest: ''
    s: 0
    sym: but
infix__S_360does: !!perl/hash:RE 
  decl: []

  kind: token
  min: 12345
  pkg: STD::Structural
  re: !!perl/hash:RE_method 
    a: 0
    dba: infix__S_360does
    i: 0
    min: 12345
    name: sym
    r: 1
    rest: ''
    s: 0
    sym: does
infix__S_361DotDot: !!perl/hash:RE 
  decl: []

  kind: token
  min: 12345
  pkg: STD::Structural
  re: !!perl/hash:RE_sequence 
    a: 0
    dba: infix__S_361DotDot
    i: 0
    min: 12345
    r: 1
    s: 0
    zyg: 
      - !!perl/hash:RE_method 
        a: 0
        dba: infix__S_361DotDot
        i: 0
        min: 12345
        name: sym
        r: 1
        rest: ''
        s: 0
        sym: ..
      - !!perl/hash:RE_quantified_atom 
        atom: !!perl/hash:RE_bracket 
          decl: []

          min: 0
          re: !!perl/hash:RE_sequence 
            a: 0
            dba: infix__S_361DotDot
            i: 0
            min: 0
            r: 1
            s: 0
            zyg: 
              - !!perl/hash:RE_assertion 
                assert: "!"
                min: 0
                re: !!perl/hash:RE_block 
                  a: 0
                  context: bool
                  dba: infix__S_361DotDot
                  i: 0
                  min: 0
                  nobind: 1
                  r: 1
                  s: 0
                  text: " $*IN_META "
              - !!perl/hash:RE_assertion 
                assert: "?"
                min: 0
                re: !!perl/hash:RE_method_re 
                  a: 0
                  dba: infix__S_361DotDot
                  i: 0
                  min: 0
                  name: before
                  nobind: 1
                  r: 1
                  re: !!perl/hash:RE 
                    decl: []

                    min: 1
                    re: &44 !!perl/hash:RE_any 
                      a: 0
                      altname: infix__S_361DotDot_02
                      dba: infix__S_361DotDot
                      i: 0
                      min: 1
                      name: infix__S_361DotDot_02
                      r: 1
                      s: 0
                      zyg: 
                        - !!perl/hash:RE_string 
                          a: 0
                          alt: infix__S_361DotDot_02 0
                          dba: infix__S_361DotDot
                          i: 0
                          min: 1
                          r: 1
                          s: 0
                          text: )
                        - !!perl/hash:RE_string 
                          a: 0
                          alt: infix__S_361DotDot_02 1
                          dba: infix__S_361DotDot
                          i: 0
                          min: 1
                          r: 1
                          s: 0
                          text: "]"
                  s: 0
              - !!perl/hash:RE_method 
                min: 0
                name: panic
                nobind: 1
                rest: ("Please use ..* for indefinite range")
        min: 0
        quant: 
          - "?"
          - ":"
          - ''
          - 0
infix__S_361DotDot_02: *44
infix__S_362CaretDotDot: !!perl/hash:RE 
  decl: []

  kind: token
  min: 12345
  pkg: STD::Structural
  re: !!perl/hash:RE_method 
    a: 0
    dba: infix__S_362CaretDotDot
    i: 0
    min: 12345
    name: sym
    r: 1
    rest: ''
    s: 0
    sym: "^.."
infix__S_363DotDotCaret: !!perl/hash:RE 
  decl: []

  kind: token
  min: 12345
  pkg: STD::Structural
  re: !!perl/hash:RE_method 
    a: 0
    dba: infix__S_363DotDotCaret
    i: 0
    min: 12345
    name: sym
    r: 1
    rest: ''
    s: 0
    sym: ..^
infix__S_364CaretDotDotCaret: !!perl/hash:RE 
  decl: []

  kind: token
  min: 12345
  pkg: STD::Structural
  re: !!perl/hash:RE_method 
    a: 0
    dba: infix__S_364CaretDotDotCaret
    i: 0
    min: 12345
    name: sym
    r: 1
    rest: ''
    s: 0
    sym: "^..^"
infix__S_365EqualEqual: !!perl/hash:RE 
  decl: []

  kind: token
  min: 12345
  pkg: STD::Chaining
  re: !!perl/hash:RE_sequence 
    a: 0
    dba: infix__S_365EqualEqual
    i: 0
    min: 12345
    r: 1
    s: 0
    zyg: 
      - !!perl/hash:RE_method 
        a: 0
        dba: infix__S_365EqualEqual
        i: 0
        min: 12345
        name: sym
        r: 1
        rest: ''
        s: 0
        sym: ==
      - !!perl/hash:RE_assertion 
        assert: "!"
        min: 0
        re: !!perl/hash:RE_method_re 
          a: 0
          dba: infix__S_365EqualEqual
          i: 0
          min: 0
          name: before
          nobind: 1
          r: 1
          re: !!perl/hash:RE 
            decl: []

            min: 1
            re: !!perl/hash:RE_string 
              a: 0
              dba: infix__S_365EqualEqual
              i: 0
              min: 1
              r: 1
              s: 0
              text: =
          s: 0
infix__S_366BangEqual: !!perl/hash:RE 
  decl: []

  kind: token
  min: 12345
  pkg: STD::Chaining
  re: !!perl/hash:RE_sequence 
    a: 0
    dba: infix__S_366BangEqual
    i: 0
    min: 12345
    r: 1
    s: 0
    zyg: 
      - !!perl/hash:RE_method 
        a: 0
        dba: infix__S_366BangEqual
        i: 0
        min: 12345
        name: sym
        r: 1
        rest: ''
        s: 0
        sym: "!="
      - !!perl/hash:RE_assertion 
        assert: "?"
        min: 0
        re: !!perl/hash:RE_method_re 
          a: 0
          dba: infix__S_366BangEqual
          i: 0
          min: 0
          name: before
          nobind: 1
          r: 1
          re: !!perl/hash:RE 
            decl: []

            min: 1
            re: !!perl/hash:RE_meta 
              a: 0
              dba: infix__S_366BangEqual
              i: 0
              min: 1
              r: 1
              s: 0
              text: \s
          s: 0
infix__S_367Lt: !!perl/hash:RE 
  decl: []

  kind: token
  min: 12345
  pkg: STD::Chaining
  re: !!perl/hash:RE_method 
    a: 0
    dba: infix__S_367Lt
    i: 0
    min: 12345
    name: sym
    r: 1
    rest: ''
    s: 0
    sym: <
infix__S_368LtEqual: !!perl/hash:RE 
  decl: []

  kind: token
  min: 12345
  pkg: STD::Chaining
  re: !!perl/hash:RE_method 
    a: 0
    dba: infix__S_368LtEqual
    i: 0
    min: 12345
    name: sym
    r: 1
    rest: ''
    s: 0
    sym: <=
infix__S_369Gt: !!perl/hash:RE 
  decl: []

  kind: token
  min: 12345
  pkg: STD::Chaining
  re: !!perl/hash:RE_method 
    a: 0
    dba: infix__S_369Gt
    i: 0
    min: 12345
    name: sym
    r: 1
    rest: ''
    s: 0
    sym: ">"
infix__S_370GtEqual: !!perl/hash:RE 
  decl: []

  kind: token
  min: 12345
  pkg: STD::Chaining
  re: !!perl/hash:RE_method 
    a: 0
    dba: infix__S_370GtEqual
    i: 0
    min: 12345
    name: sym
    r: 1
    rest: ''
    s: 0
    sym: ">="
infix__S_371TildeTilde: !!perl/hash:RE 
  decl: []

  kind: token
  min: 12345
  pkg: STD::Chaining
  re: !!perl/hash:RE_method 
    a: 0
    dba: infix__S_371TildeTilde
    i: 0
    min: 12345
    name: sym
    r: 1
    rest: ''
    s: 0
    sym: ~~
infix__S_372BangTilde: !!perl/hash:RE 
  decl: []

  kind: token
  min: 12346
  pkg: STD::Chaining
  re: !!perl/hash:RE_sequence 
    a: 0
    dba: infix__S_372BangTilde
    i: 0
    min: 12346
    r: 1
    s: 0
    zyg: 
      - !!perl/hash:RE_method 
        a: 0
        dba: infix__S_372BangTilde
        i: 0
        min: 12345
        name: sym
        r: 1
        rest: ''
        s: 0
        sym: "!~"
      - !!perl/hash:RE_meta 
        a: 0
        dba: infix__S_372BangTilde
        i: 0
        min: 1
        r: 1
        s: 0
        text: \s
      - !!perl/hash:RE_method 
        min: 0
        name: obs
        nobind: 1
        rest: ('!~ to do negated pattern matching', '!~~')
infix__S_373EqualTilde: !!perl/hash:RE 
  decl: []

  kind: token
  min: 12345
  pkg: STD::Chaining
  re: !!perl/hash:RE_sequence 
    a: 0
    dba: infix__S_373EqualTilde
    i: 0
    min: 12345
    r: 1
    s: 0
    zyg: 
      - !!perl/hash:RE_method 
        a: 0
        dba: infix__S_373EqualTilde
        i: 0
        min: 12345
        name: sym
        r: 1
        rest: ''
        s: 0
        sym: =~
      - !!perl/hash:RE_method 
        min: 0
        name: obs
        nobind: 1
        rest: ('=~ to do pattern matching', '~~')
infix__S_374eq: !!perl/hash:RE 
  decl: []

  kind: token
  min: 12345
  pkg: STD::Chaining
  re: !!perl/hash:RE_method 
    a: 0
    dba: infix__S_374eq
    i: 0
    min: 12345
    name: sym
    r: 1
    rest: ''
    s: 0
    sym: eq
infix__S_375ne: !!perl/hash:RE 
  decl: []

  kind: token
  min: 12345
  pkg: STD::Chaining
  re: !!perl/hash:RE_method 
    a: 0
    dba: infix__S_375ne
    i: 0
    min: 12345
    name: sym
    r: 1
    rest: ''
    s: 0
    sym: ne
infix__S_376lt: !!perl/hash:RE 
  decl: []

  kind: token
  min: 12345
  pkg: STD::Chaining
  re: !!perl/hash:RE_method 
    a: 0
    dba: infix__S_376lt
    i: 0
    min: 12345
    name: sym
    r: 1
    rest: ''
    s: 0
    sym: lt
infix__S_377le: !!perl/hash:RE 
  decl: []

  kind: token
  min: 12345
  pkg: STD::Chaining
  re: !!perl/hash:RE_method 
    a: 0
    dba: infix__S_377le
    i: 0
    min: 12345
    name: sym
    r: 1
    rest: ''
    s: 0
    sym: le
infix__S_378gt: !!perl/hash:RE 
  decl: []

  kind: token
  min: 12345
  pkg: STD::Chaining
  re: !!perl/hash:RE_method 
    a: 0
    dba: infix__S_378gt
    i: 0
    min: 12345
    name: sym
    r: 1
    rest: ''
    s: 0
    sym: gt
infix__S_379ge: !!perl/hash:RE 
  decl: []

  kind: token
  min: 12345
  pkg: STD::Chaining
  re: !!perl/hash:RE_method 
    a: 0
    dba: infix__S_379ge
    i: 0
    min: 12345
    name: sym
    r: 1
    rest: ''
    s: 0
    sym: ge
infix__S_380EqualColonEqual: !!perl/hash:RE 
  decl: []

  kind: token
  min: 12345
  pkg: STD::Chaining
  re: !!perl/hash:RE_method 
    a: 0
    dba: infix__S_380EqualColonEqual
    i: 0
    min: 12345
    name: sym
    r: 1
    rest: ''
    s: 0
    sym: =:=
infix__S_381EqualEqualEqual: !!perl/hash:RE 
  decl: []

  kind: token
  min: 12345
  pkg: STD::Chaining
  re: !!perl/hash:RE_method 
    a: 0
    dba: infix__S_381EqualEqualEqual
    i: 0
    min: 12345
    name: sym
    r: 1
    rest: ''
    s: 0
    sym: ===
infix__S_382eqv: !!perl/hash:RE 
  decl: []

  kind: token
  min: 12345
  pkg: STD::Chaining
  re: !!perl/hash:RE_method 
    a: 0
    dba: infix__S_382eqv
    i: 0
    min: 12345
    name: sym
    r: 1
    rest: ''
    s: 0
    sym: eqv
infix__S_383before: !!perl/hash:RE 
  decl: []

  kind: token
  min: 12345
  pkg: STD::Chaining
  re: !!perl/hash:RE_method 
    a: 0
    dba: infix__S_383before
    i: 0
    min: 12345
    name: sym
    r: 1
    rest: ''
    s: 0
    sym: before
infix__S_384after: !!perl/hash:RE 
  decl: []

  kind: token
  min: 12345
  pkg: STD::Chaining
  re: !!perl/hash:RE_method 
    a: 0
    dba: infix__S_384after
    i: 0
    min: 12345
    name: sym
    r: 1
    rest: ''
    s: 0
    sym: after
infix__S_385AmpAmp: !!perl/hash:RE 
  decl: []

  kind: token
  min: 12345
  pkg: STD::Tight_and
  re: !!perl/hash:RE_method 
    a: 0
    dba: infix__S_385AmpAmp
    i: 0
    min: 12345
    name: sym
    r: 1
    rest: ''
    s: 0
    sym: "&&"
infix__S_386VertVert: !!perl/hash:RE 
  decl: []

  kind: token
  min: 12345
  pkg: STD::Tight_or
  re: !!perl/hash:RE_method 
    a: 0
    dba: infix__S_386VertVert
    i: 0
    min: 12345
    name: sym
    r: 1
    rest: ''
    s: 0
    sym: "||"
infix__S_387CaretCaret: !!perl/hash:RE 
  decl: []

  kind: token
  min: 12345
  pkg: STD::Tight_or
  re: !!perl/hash:RE_method 
    a: 0
    dba: infix__S_387CaretCaret
    i: 0
    min: 12345
    name: sym
    r: 1
    rest: ''
    s: 0
    sym: "^^"
infix__S_388SlashSlash: !!perl/hash:RE 
  decl: []

  kind: token
  min: 12345
  pkg: STD::Tight_or
  re: !!perl/hash:RE_method 
    a: 0
    dba: infix__S_388SlashSlash
    i: 0
    min: 12345
    name: sym
    r: 1
    rest: ''
    s: 0
    sym: //
infix__S_389min: !!perl/hash:RE 
  decl: []

  kind: token
  min: 12345
  pkg: STD::Tight_or
  re: !!perl/hash:RE_method 
    a: 0
    dba: infix__S_389min
    i: 0
    min: 12345
    name: sym
    r: 1
    rest: ''
    s: 0
    sym: min
infix__S_390max: !!perl/hash:RE 
  decl: []

  kind: token
  min: 12345
  pkg: STD::Tight_or
  re: !!perl/hash:RE_method 
    a: 0
    dba: infix__S_390max
    i: 0
    min: 12345
    name: sym
    r: 1
    rest: ''
    s: 0
    sym: max
infix__S_391QuestionQuestion_BangBang: !!perl/hash:RE 
  decl: 
    - !!perl/hash:RE_decl 
      a: 0
      dba: infix__S_391QuestionQuestion_BangBang
      i: 0
      max: 0
      min: 0
      r: 1
      s: 0
      text: my $GOAL is context = '!!'
  kind: token
  min: 12347
  pkg: STD::Conditional
  re: !!perl/hash:RE_sequence 
    a: 0
    dba: infix__S_391QuestionQuestion_BangBang
    i: 0
    min: 12347
    r: 1
    s: 0
    zyg: 
      - !!perl/hash:RE_string 
        a: 0
        dba: infix__S_391QuestionQuestion_BangBang
        i: 0
        min: 2
        r: 1
        s: 0
        text: ??
      - !!perl/hash:RE_method 
        a: 0
        dba: infix__S_391QuestionQuestion_BangBang
        i: 0
        min: 12345
        name: ws
        nobind: 1
        r: 1
        rest: ''
        s: 0
      - !!perl/hash:RE_method 
        min: 0
        name: EXPR
        rest: (item %item_assignment)
      - !!perl/hash:RE_bracket 
        decl: []

        min: 0
        re: !!perl/hash:RE_first 
          a: 0
          dba: infix__S_391QuestionQuestion_BangBang
          i: 0
          min: 0
          r: 1
          s: 0
          zyg: 
            - !!perl/hash:RE_string 
              a: 0
              dba: infix__S_391QuestionQuestion_BangBang
              i: 0
              min: 2
              r: 1
              s: 0
              text: "!!"
            - !!perl/hash:RE_bracket 
              decl: []

              min: 0
              re: !!perl/hash:RE_first 
                a: 0
                dba: infix__S_391QuestionQuestion_BangBang
                i: 0
                min: 0
                r: 1
                s: 0
                zyg: 
                  - !!perl/hash:RE_sequence 
                    a: 0
                    dba: infix__S_391QuestionQuestion_BangBang
                    i: 0
                    min: 0
                    r: 1
                    s: 0
                    zyg: 
                      - !!perl/hash:RE_assertion 
                        assert: "?"
                        min: 0
                        re: !!perl/hash:RE_method_re 
                          a: 0
                          dba: infix__S_391QuestionQuestion_BangBang
                          i: 0
                          min: 0
                          name: before
                          nobind: 1
                          r: 1
                          re: !!perl/hash:RE 
                            decl: []

                            min: 1
                            re: !!perl/hash:RE_string 
                              a: 0
                              dba: infix__S_391QuestionQuestion_BangBang
                              i: 0
                              min: 1
                              r: 1
                              s: 0
                              text: =
                          s: 0
                      - !!perl/hash:RE_method 
                        min: 0
                        name: panic
                        nobind: 1
                        rest: ("Assignment not allowed within ??!!")
                  - !!perl/hash:RE_sequence 
                    a: 0
                    dba: infix__S_391QuestionQuestion_BangBang
                    i: 0
                    min: 0
                    r: 1
                    s: 0
                    zyg: 
                      - !!perl/hash:RE_assertion 
                        assert: "?"
                        min: 0
                        re: !!perl/hash:RE_method_re 
                          a: 0
                          dba: infix__S_391QuestionQuestion_BangBang
                          i: 0
                          min: 0
                          name: before
                          nobind: 1
                          r: 1
                          re: !!perl/hash:RE 
                            decl: []

                            min: 2
                            re: !!perl/hash:RE_string 
                              a: 0
                              dba: infix__S_391QuestionQuestion_BangBang
                              i: 0
                              min: 2
                              r: 1
                              s: 0
                              text: "::"
                          s: 0
                      - !!perl/hash:RE_method 
                        min: 0
                        name: panic
                        nobind: 1
                        rest: ("Please use !! rather than ::")
                  - !!perl/hash:RE_sequence 
                    a: 0
                    dba: infix__S_391QuestionQuestion_BangBang
                    i: 0
                    min: 0
                    r: 1
                    s: 0
                    zyg: 
                      - !!perl/hash:RE_assertion 
                        assert: "?"
                        min: 0
                        re: !!perl/hash:RE_method_re 
                          a: 0
                          dba: infix__S_391QuestionQuestion_BangBang
                          i: 0
                          min: 0
                          name: before
                          nobind: 1
                          r: 1
                          re: !!perl/hash:RE 
                            decl: []

                            min: 12345
                            re: !!perl/hash:RE_method 
                              a: 0
                              dba: infix__S_391QuestionQuestion_BangBang
                              i: 0
                              min: 12345
                              name: infixish
                              r: 1
                              rest: ''
                              s: 0
                          s: 0
                      - !!perl/hash:RE_method 
                        min: 0
                        name: panic
                        nobind: 1
                        rest: ("Precedence too loose within ??!!; use ??()!! instead ")
                  - !!perl/hash:RE_method 
                    min: 0
                    name: panic
                    nobind: 1
                    rest: ("Found ?? but no !!; possible precedence problem")
infix__S_392Question: !!perl/hash:RE 
  decl: []

  kind: token
  min: 12345
  pkg: STD::Conditional
  re: !!perl/hash:RE_sequence 
    a: 0
    dba: infix__S_392Question
    i: 0
    min: 12345
    r: 1
    s: 0
    zyg: 
      - !!perl/hash:RE_method 
        a: 0
        dba: infix__S_392Question
        i: 0
        min: 12345
        name: sym
        r: 1
        rest: ''
        s: 0
        sym: "?"
      - !!perl/hash:RE_method 
        min: 0
        name: obs
        nobind: 1
        rest: "('?: for the conditional operator', '??!!')"
infix__S_393ff: !!perl/hash:RE 
  decl: []

  kind: token
  min: 12345
  pkg: STD::Conditional
  re: !!perl/hash:RE_method 
    a: 0
    dba: infix__S_393ff
    i: 0
    min: 12345
    name: sym
    r: 1
    rest: ''
    s: 0
    sym: ff
infix__S_394Caretff: !!perl/hash:RE 
  decl: []

  kind: token
  min: 12345
  pkg: STD::Conditional
  re: !!perl/hash:RE_method 
    a: 0
    dba: infix__S_394Caretff
    i: 0
    min: 12345
    name: sym
    r: 1
    rest: ''
    s: 0
    sym: "^ff"
infix__S_395ffCaret: !!perl/hash:RE 
  decl: []

  kind: token
  min: 12345
  pkg: STD::Conditional
  re: !!perl/hash:RE_method 
    a: 0
    dba: infix__S_395ffCaret
    i: 0
    min: 12345
    name: sym
    r: 1
    rest: ''
    s: 0
    sym: ff^
infix__S_396CaretffCaret: !!perl/hash:RE 
  decl: []

  kind: token
  min: 12345
  pkg: STD::Conditional
  re: !!perl/hash:RE_method 
    a: 0
    dba: infix__S_396CaretffCaret
    i: 0
    min: 12345
    name: sym
    r: 1
    rest: ''
    s: 0
    sym: "^ff^"
infix__S_397fff: !!perl/hash:RE 
  decl: []

  kind: token
  min: 12345
  pkg: STD::Conditional
  re: !!perl/hash:RE_method 
    a: 0
    dba: infix__S_397fff
    i: 0
    min: 12345
    name: sym
    r: 1
    rest: ''
    s: 0
    sym: fff
infix__S_398Caretfff: !!perl/hash:RE 
  decl: []

  kind: token
  min: 12345
  pkg: STD::Conditional
  re: !!perl/hash:RE_method 
    a: 0
    dba: infix__S_398Caretfff
    i: 0
    min: 12345
    name: sym
    r: 1
    rest: ''
    s: 0
    sym: "^fff"
infix__S_399fffCaret: !!perl/hash:RE 
  decl: []

  kind: token
  min: 12345
  pkg: STD::Conditional
  re: !!perl/hash:RE_method 
    a: 0
    dba: infix__S_399fffCaret
    i: 0
    min: 12345
    name: sym
    r: 1
    rest: ''
    s: 0
    sym: fff^
infix__S_400CaretfffCaret: !!perl/hash:RE 
  decl: []

  kind: token
  min: 12345
  pkg: STD::Conditional
  re: !!perl/hash:RE_method 
    a: 0
    dba: infix__S_400CaretfffCaret
    i: 0
    min: 12345
    name: sym
    r: 1
    rest: ''
    s: 0
    sym: "^fff^"
infix__S_401Equal: !!perl/hash:RE 
  decl: []

  kind: token
  min: 12345
  pkg: ~
  re: !!perl/hash:RE_sequence 
    a: 0
    dba: infix__S_401Equal
    i: 0
    min: 12345
    r: 1
    s: 0
    zyg: 
      - !!perl/hash:RE_method 
        a: 0
        dba: infix__S_401Equal
        i: 0
        min: 12345
        name: sym
        r: 1
        rest: ''
        s: 0
        sym: =
      - !!perl/hash:RE_block 
        a: 0
        context: void
        dba: infix__S_401Equal
        i: 0
        min: 0
        r: 1
        s: 0
        text: " $¢ = $*LEFTSIGIL eq '$' \n        ?? ::Item_assignment.coerce($¢)\n        !! ::List_assignment.coerce($¢);\n    "
infix__S_402ColonEqual: !!perl/hash:RE 
  decl: []

  kind: token
  min: 12345
  pkg: STD::Item_assignment
  re: !!perl/hash:RE_method 
    a: 0
    dba: infix__S_402ColonEqual
    i: 0
    min: 12345
    name: sym
    r: 1
    rest: ''
    s: 0
    sym: :=
infix__S_403ColonColonEqual: !!perl/hash:RE 
  decl: []

  kind: token
  min: 12345
  pkg: STD::Item_assignment
  re: !!perl/hash:RE_method 
    a: 0
    dba: infix__S_403ColonColonEqual
    i: 0
    min: 12345
    name: sym
    r: 1
    rest: ''
    s: 0
    sym: ::=
infix__S_404DotEqual: !!perl/hash:RE 
  decl: []

  kind: token
  min: 24690
  pkg: STD::Item_assignment
  re: !!perl/hash:RE_sequence 
    a: 0
    dba: infix__S_404DotEqual
    i: 0
    min: 24690
    r: 1
    s: 0
    zyg: 
      - !!perl/hash:RE_method 
        a: 0
        dba: infix__S_404DotEqual
        i: 0
        min: 12345
        name: sym
        r: 1
        rest: ''
        s: 0
        sym: .=
      - !!perl/hash:RE_method 
        a: 0
        dba: infix__S_404DotEqual
        i: 0
        min: 12345
        name: ws
        nobind: 1
        r: 1
        rest: ''
        s: 0
      - !!perl/hash:RE_bracket 
        decl: []

        min: 0
        re: !!perl/hash:RE_first 
          a: 0
          dba: infix__S_404DotEqual
          i: 0
          min: 0
          r: 1
          s: 0
          zyg: 
            - !!perl/hash:RE_assertion 
              assert: "?"
              min: 0
              re: !!perl/hash:RE_method_re 
                a: 0
                dba: infix__S_404DotEqual
                i: 0
                min: 0
                name: before
                nobind: 1
                r: 1
                re: !!perl/hash:RE 
                  decl: []

                  min: 2
                  re: &54 !!perl/hash:RE_any 
                    a: 0
                    altname: infix__S_404DotEqual_02
                    dba: infix__S_404DotEqual
                    i: 0
                    min: 2
                    name: infix__S_404DotEqual_02
                    r: 1
                    s: 0
                    zyg: 
                      - !!perl/hash:RE_sequence 
                        a: 0
                        alt: infix__S_404DotEqual_02 0
                        dba: infix__S_404DotEqual
                        i: 0
                        min: 2
                        r: 1
                        s: 0
                        zyg: 
                          - !!perl/hash:RE_quantified_atom 
                            atom: !!perl/hash:RE_meta 
                              a: 0
                              dba: infix__S_404DotEqual
                              i: 0
                              min: 1
                              r: 1
                              s: 0
                              text: \w
                            min: 1
                            quant: 
                              - +
                              - ":"
                              - ''
                              - 1
                          - !!perl/hash:RE_string 
                            a: 0
                            dba: infix__S_404DotEqual
                            i: 0
                            min: 1
                            r: 1
                            s: 0
                            text: ;
                      - !!perl/hash:RE_string 
                        a: 0
                        alt: infix__S_404DotEqual_02 1
                        dba: infix__S_404DotEqual
                        i: 0
                        min: 3
                        r: 1
                        s: 0
                        text: new
                      - !!perl/hash:RE_string 
                        a: 0
                        alt: infix__S_404DotEqual_02 2
                        dba: infix__S_404DotEqual
                        i: 0
                        min: 4
                        r: 1
                        s: 0
                        text: sort
                      - !!perl/hash:RE_string 
                        a: 0
                        alt: infix__S_404DotEqual_02 3
                        dba: infix__S_404DotEqual
                        i: 0
                        min: 5
                        r: 1
                        s: 0
                        text: subst
                      - !!perl/hash:RE_string 
                        a: 0
                        alt: infix__S_404DotEqual_02 4
                        dba: infix__S_404DotEqual
                        i: 0
                        min: 5
                        r: 1
                        s: 0
                        text: trans
                      - !!perl/hash:RE_string 
                        a: 0
                        alt: infix__S_404DotEqual_02 5
                        dba: infix__S_404DotEqual
                        i: 0
                        min: 7
                        r: 1
                        s: 0
                        text: reverse
                      - !!perl/hash:RE_string 
                        a: 0
                        alt: infix__S_404DotEqual_02 6
                        dba: infix__S_404DotEqual
                        i: 0
                        min: 4
                        r: 1
                        s: 0
                        text: uniq
                      - !!perl/hash:RE_string 
                        a: 0
                        alt: infix__S_404DotEqual_02 7
                        dba: infix__S_404DotEqual
                        i: 0
                        min: 3
                        r: 1
                        s: 0
                        text: map
                      - !!perl/hash:RE_string 
                        a: 0
                        alt: infix__S_404DotEqual_02 8
                        dba: infix__S_404DotEqual
                        i: 0
                        min: 8
                        r: 1
                        s: 0
                        text: samecase
                      - !!perl/hash:RE_string 
                        a: 0
                        alt: infix__S_404DotEqual_02 9
                        dba: infix__S_404DotEqual
                        i: 0
                        min: 6
                        r: 1
                        s: 0
                        text: substr
                      - !!perl/hash:RE_string 
                        a: 0
                        alt: infix__S_404DotEqual_02 10
                        dba: infix__S_404DotEqual
                        i: 0
                        min: 4
                        r: 1
                        s: 0
                        text: flip
                      - !!perl/hash:RE_string 
                        a: 0
                        alt: infix__S_404DotEqual_02 11
                        dba: infix__S_404DotEqual
                        i: 0
                        min: 3
                        r: 1
                        s: 0
                        text: fmt
                s: 0
            - !!perl/hash:RE_method 
              min: 0
              name: worryobs
              rest: ('.= as append operator', '~=')
      - !!perl/hash:RE_block 
        a: 0
        context: void
        dba: infix__S_404DotEqual
        i: 0
        min: 0
        r: 1
        s: 0
        text: " $<O><nextterm> = 'dottyopish' "
infix__S_404DotEqual_02: *54
infix__S_405EqualGt: !!perl/hash:RE 
  decl: []

  kind: token
  min: 12345
  pkg: STD::Item_assignment
  re: !!perl/hash:RE_sequence 
    a: 0
    dba: infix__S_405EqualGt
    i: 0
    min: 12345
    r: 1
    s: 0
    zyg: 
      - !!perl/hash:RE_method 
        a: 0
        dba: infix__S_405EqualGt
        i: 0
        min: 12345
        name: sym
        r: 1
        rest: ''
        s: 0
        sym: =>
      - !!perl/hash:RE_block 
        a: 0
        context: void
        dba: infix__S_405EqualGt
        i: 0
        min: 0
        r: 1
        s: 0
        text: " $<O><fiddly> = 0; "
infix__S_408Comma: !!perl/hash:RE 
  decl: []

  kind: token
  min: 12345
  pkg: STD::Comma
  re: !!perl/hash:RE_sequence 
    a: 0
    dba: infix__S_408Comma
    i: 0
    min: 12345
    r: 1
    s: 0
    zyg: 
      - !!perl/hash:RE_method 
        a: 0
        dba: infix__S_408Comma
        i: 0
        min: 12345
        name: sym
        r: 1
        rest: ''
        s: 0
        sym: ","
      - !!perl/hash:RE_block 
        a: 0
        context: void
        dba: infix__S_408Comma
        i: 0
        min: 0
        r: 1
        s: 0
        text: " $<O><fiddly> = 0; "
infix__S_409Colon: !!perl/hash:RE 
  decl: []

  kind: token
  min: 12345
  pkg: STD::Comma
  re: !!perl/hash:RE_sequence 
    a: 0
    dba: infix__S_409Colon
    i: 0
    min: 12345
    r: 1
    s: 0
    zyg: 
      - !!perl/hash:RE_method 
        a: 0
        dba: infix__S_409Colon
        i: 0
        min: 12345
        name: sym
        r: 1
        rest: ''
        s: 0
        sym: ":"
      - !!perl/hash:RE_assertion 
        assert: "?"
        min: 0
        re: !!perl/hash:RE_method_re 
          a: 0
          dba: infix__S_409Colon
          i: 0
          min: 0
          name: before
          nobind: 1
          r: 1
          re: !!perl/hash:RE 
            decl: []

            min: 1
            re: &39 !!perl/hash:RE_any 
              a: 0
              altname: infix__S_409Colon_01
              dba: infix__S_409Colon
              i: 0
              min: 1
              name: infix__S_409Colon_01
              r: 1
              s: 0
              zyg: 
                - !!perl/hash:RE_meta 
                  a: 0
                  alt: infix__S_409Colon_01 0
                  dba: infix__S_409Colon
                  i: 0
                  min: 1
                  r: 1
                  s: 0
                  text: \s
                - !!perl/hash:RE_method 
                  a: 0
                  alt: infix__S_409Colon_01 1
                  dba: infix__S_409Colon
                  i: 0
                  min: 12345
                  name: terminator
                  r: 1
                  rest: ''
                  s: 0
          s: 0
      - !!perl/hash:RE_block 
        a: 0
        context: void
        dba: infix__S_409Colon
        i: 0
        min: 0
        r: 1
        s: 0
        text: " $¢.panic(\"Illegal use of colon as invocant marker\") unless $*INVOCANT_OK--; "
infix__S_409Colon_01: *39
infix__S_410p5EqualGt: !!perl/hash:RE 
  decl: []

  kind: token
  min: 12345
  pkg: STD::Comma
  re: !!perl/hash:RE_method 
    a: 0
    dba: infix__S_410p5EqualGt
    i: 0
    min: 12345
    name: sym
    r: 1
    rest: ''
    s: 0
    sym: p5=>
infix__S_411Z: !!perl/hash:RE 
  decl: []

  kind: token
  min: 12345
  pkg: STD::List_infix
  re: !!perl/hash:RE_method 
    a: 0
    dba: infix__S_411Z
    i: 0
    min: 12345
    name: sym
    r: 1
    rest: ''
    s: 0
    sym: Z
infix__S_412minmax: !!perl/hash:RE 
  decl: []

  kind: token
  min: 12345
  pkg: STD::List_infix
  re: !!perl/hash:RE_method 
    a: 0
    dba: infix__S_412minmax
    i: 0
    min: 12345
    name: sym
    r: 1
    rest: ''
    s: 0
    sym: minmax
infix__S_413DotDotDot: !!perl/hash:RE 
  decl: []

  kind: token
  min: 12345
  pkg: STD::List_infix
  re: !!perl/hash:RE_method 
    a: 0
    dba: infix__S_413DotDotDot
    i: 0
    min: 12345
    name: sym
    r: 1
    rest: ''
    s: 0
    sym: ...
infix__S_420and: !!perl/hash:RE 
  decl: []

  kind: token
  min: 12345
  pkg: STD::Loose_and
  re: !!perl/hash:RE_method 
    a: 0
    dba: infix__S_420and
    i: 0
    min: 12345
    name: sym
    r: 1
    rest: ''
    s: 0
    sym: and
infix__S_421andthen: !!perl/hash:RE 
  decl: []

  kind: token
  min: 12345
  pkg: STD::Loose_and
  re: !!perl/hash:RE_method 
    a: 0
    dba: infix__S_421andthen
    i: 0
    min: 12345
    name: sym
    r: 1
    rest: ''
    s: 0
    sym: andthen
infix__S_422or: !!perl/hash:RE 
  decl: []

  kind: token
  min: 12345
  pkg: STD::Loose_or
  re: !!perl/hash:RE_method 
    a: 0
    dba: infix__S_422or
    i: 0
    min: 12345
    name: sym
    r: 1
    rest: ''
    s: 0
    sym: or
infix__S_423orelse: !!perl/hash:RE 
  decl: []

  kind: token
  min: 12345
  pkg: STD::Loose_or
  re: !!perl/hash:RE_method 
    a: 0
    dba: infix__S_423orelse
    i: 0
    min: 12345
    name: sym
    r: 1
    rest: ''
    s: 0
    sym: orelse
infix__S_424xor: !!perl/hash:RE 
  decl: []

  kind: token
  min: 12345
  pkg: STD::Loose_or
  re: !!perl/hash:RE_method 
    a: 0
    dba: infix__S_424xor
    i: 0
    min: 12345
    name: sym
    r: 1
    rest: ''
    s: 0
    sym: xor
infix__S_425LtEqualEqual: !!perl/hash:RE 
  decl: []

  kind: token
  min: 12345
  pkg: STD::Sequencer
  re: !!perl/hash:RE_method 
    a: 0
    dba: infix__S_425LtEqualEqual
    i: 0
    min: 12345
    name: sym
    r: 1
    rest: ''
    s: 0
    sym: <==
infix__S_426EqualEqualGt: !!perl/hash:RE 
  decl: []

  kind: token
  min: 12345
  pkg: STD::Sequencer
  re: !!perl/hash:RE_sequence 
    a: 0
    dba: infix__S_426EqualEqualGt
    i: 0
    min: 12345
    r: 1
    s: 0
    zyg: 
      - !!perl/hash:RE_method 
        a: 0
        dba: infix__S_426EqualEqualGt
        i: 0
        min: 12345
        name: sym
        r: 1
        rest: ''
        s: 0
        sym: ==>
      - !!perl/hash:RE_method_internal 
        args: $S, 'infix__S_426EqualEqualGt'
        max: 0
        min: 0
        name: _REDUCE
infix__S_427LtLtEqualEqual: !!perl/hash:RE 
  decl: []

  kind: token
  min: 12345
  pkg: STD::Sequencer
  re: !!perl/hash:RE_method 
    a: 0
    dba: infix__S_427LtLtEqualEqual
    i: 0
    min: 12345
    name: sym
    r: 1
    rest: ''
    s: 0
    sym: <<==
infix__S_428EqualEqualGtGt: !!perl/hash:RE 
  decl: []

  kind: token
  min: 12345
  pkg: STD::Sequencer
  re: !!perl/hash:RE_sequence 
    a: 0
    dba: infix__S_428EqualEqualGtGt
    i: 0
    min: 12345
    r: 1
    s: 0
    zyg: 
      - !!perl/hash:RE_method 
        a: 0
        dba: infix__S_428EqualEqualGtGt
        i: 0
        min: 12345
        name: sym
        r: 1
        rest: ''
        s: 0
        sym: ==>>
      - !!perl/hash:RE_method_internal 
        args: $S, 'infix__S_428EqualEqualGtGt'
        max: 0
        min: 0
        name: _REDUCE
infix_circumfix_meta_operator__S_290Fre_Nch: !!perl/hash:RE 
  decl: []

  kind: token
  min: 1
  pkg: STD::Transparent
  re: !!perl/hash:RE_sequence 
    a: 0
    dba: infix_circumfix_meta_operator__S_290Fre_Nch
    i: 0
    min: 1
    r: 1
    s: 0
    zyg: 
      - !!perl/hash:RE_bracket 
        decl: []

        min: 1
        re: &77 !!perl/hash:RE_any 
          a: 0
          altname: infix_circumfix_meta_operator__S_290Fre_Nch_01
          dba: infix_circumfix_meta_operator__S_290Fre_Nch
          i: 0
          min: 1
          name: infix_circumfix_meta_operator__S_290Fre_Nch_01
          r: 1
          s: 0
          zyg: 
            - !!perl/hash:RE_string 
              a: 0
              alt: infix_circumfix_meta_operator__S_290Fre_Nch_01 0
              dba: infix_circumfix_meta_operator__S_290Fre_Nch
              i: 0
              min: 1
              r: 1
              s: 0
              text: «
            - !!perl/hash:RE_string 
              a: 0
              alt: infix_circumfix_meta_operator__S_290Fre_Nch_01 1
              dba: infix_circumfix_meta_operator__S_290Fre_Nch
              i: 0
              min: 1
              r: 1
              s: 0
              text: »
      - !!perl/hash:RE_block 
        a: 0
        context: void
        dba: infix_circumfix_meta_operator__S_290Fre_Nch
        i: 0
        min: 0
        r: 1
        s: 0
        text: ''
      - !!perl/hash:RE_method 
        min: 0
        name: infixish
        rest: (1)
      - !!perl/hash:RE_bracket 
        decl: []

        min: 0
        re: !!perl/hash:RE_first 
          a: 0
          dba: infix_circumfix_meta_operator__S_290Fre_Nch
          i: 0
          min: 0
          r: 1
          s: 0
          zyg: 
            - &7 !!perl/hash:RE_any 
              a: 0
              altname: infix_circumfix_meta_operator__S_290Fre_Nch_02
              dba: infix_circumfix_meta_operator__S_290Fre_Nch
              i: 0
              min: 1
              name: infix_circumfix_meta_operator__S_290Fre_Nch_02
              r: 1
              s: 0
              zyg: 
                - !!perl/hash:RE_string 
                  a: 0
                  alt: infix_circumfix_meta_operator__S_290Fre_Nch_02 0
                  dba: infix_circumfix_meta_operator__S_290Fre_Nch
                  i: 0
                  min: 1
                  r: 1
                  s: 0
                  text: «
                - !!perl/hash:RE_string 
                  a: 0
                  alt: infix_circumfix_meta_operator__S_290Fre_Nch_02 1
                  dba: infix_circumfix_meta_operator__S_290Fre_Nch
                  i: 0
                  min: 1
                  r: 1
                  s: 0
                  text: »
            - !!perl/hash:RE_method 
              min: 0
              name: panic
              nobind: 1
              rest: ("Missing « or »")
      - !!perl/hash:RE_method 
        min: 0
        name: can_meta
        nobind: 1
        rest: ($<infixish>, "hyper")
      - !!perl/hash:RE_assertion 
        assert: "?"
        min: 0
        re: !!perl/hash:RE_block 
          a: 0
          context: bool
          dba: infix_circumfix_meta_operator__S_290Fre_Nch
          i: 0
          min: 0
          nobind: 1
          r: 1
          s: 0
          text: " $<O> := $<infixish><O>; "
infix_circumfix_meta_operator__S_290Fre_Nch_01: *77
infix_circumfix_meta_operator__S_290Fre_Nch_02: *7
infix_circumfix_meta_operator__S_291LtLt_GtGt: !!perl/hash:RE 
  decl: []

  kind: token
  min: 2
  pkg: STD::Transparent
  re: !!perl/hash:RE_sequence 
    a: 0
    dba: infix_circumfix_meta_operator__S_291LtLt_GtGt
    i: 0
    min: 2
    r: 1
    s: 0
    zyg: 
      - !!perl/hash:RE_bracket 
        decl: []

        min: 2
        re: &55 !!perl/hash:RE_any 
          a: 0
          altname: infix_circumfix_meta_operator__S_291LtLt_GtGt_01
          dba: infix_circumfix_meta_operator__S_291LtLt_GtGt
          i: 0
          min: 2
          name: infix_circumfix_meta_operator__S_291LtLt_GtGt_01
          r: 1
          s: 0
          zyg: 
            - !!perl/hash:RE_string 
              a: 0
              alt: infix_circumfix_meta_operator__S_291LtLt_GtGt_01 0
              dba: infix_circumfix_meta_operator__S_291LtLt_GtGt
              i: 0
              min: 2
              r: 1
              s: 0
              text: <<
            - !!perl/hash:RE_string 
              a: 0
              alt: infix_circumfix_meta_operator__S_291LtLt_GtGt_01 1
              dba: infix_circumfix_meta_operator__S_291LtLt_GtGt
              i: 0
              min: 2
              r: 1
              s: 0
              text: ">>"
      - !!perl/hash:RE_block 
        a: 0
        context: void
        dba: infix_circumfix_meta_operator__S_291LtLt_GtGt
        i: 0
        min: 0
        r: 1
        s: 0
        text: ''
      - !!perl/hash:RE_method 
        min: 0
        name: infixish
        rest: (1)
      - !!perl/hash:RE_bracket 
        decl: []

        min: 0
        re: !!perl/hash:RE_first 
          a: 0
          dba: infix_circumfix_meta_operator__S_291LtLt_GtGt
          i: 0
          min: 0
          r: 1
          s: 0
          zyg: 
            - &71 !!perl/hash:RE_any 
              a: 0
              altname: infix_circumfix_meta_operator__S_291LtLt_GtGt_02
              dba: infix_circumfix_meta_operator__S_291LtLt_GtGt
              i: 0
              min: 2
              name: infix_circumfix_meta_operator__S_291LtLt_GtGt_02
              r: 1
              s: 0
              zyg: 
                - !!perl/hash:RE_string 
                  a: 0
                  alt: infix_circumfix_meta_operator__S_291LtLt_GtGt_02 0
                  dba: infix_circumfix_meta_operator__S_291LtLt_GtGt
                  i: 0
                  min: 2
                  r: 1
                  s: 0
                  text: <<
                - !!perl/hash:RE_string 
                  a: 0
                  alt: infix_circumfix_meta_operator__S_291LtLt_GtGt_02 1
                  dba: infix_circumfix_meta_operator__S_291LtLt_GtGt
                  i: 0
                  min: 2
                  r: 1
                  s: 0
                  text: ">>"
            - !!perl/hash:RE_method 
              min: 0
              name: panic
              nobind: 1
              rest: ("Missing << or >>")
      - !!perl/hash:RE_method 
        min: 0
        name: can_meta
        nobind: 1
        rest: ($<infixish>, "hyper")
      - !!perl/hash:RE_assertion 
        assert: "?"
        min: 0
        re: !!perl/hash:RE_block 
          a: 0
          context: bool
          dba: infix_circumfix_meta_operator__S_291LtLt_GtGt
          i: 0
          min: 0
          nobind: 1
          r: 1
          s: 0
          text: " $<O> := $<infixish><O>; "
infix_circumfix_meta_operator__S_291LtLt_GtGt_01: *55
infix_circumfix_meta_operator__S_291LtLt_GtGt_02: *71
infix_postfix_meta_operator__S_292Equal: !!perl/hash:RE 
  decl: []

  kind: token
  min: 1
  pkg: STD::Item_assignment
  re: !!perl/hash:RE_sequence 
    a: 0
    dba: infix_postfix_meta_operator__S_292Equal
    i: 0
    min: 1
    r: 1
    s: 0
    zyg: 
      - !!perl/hash:RE_string 
        a: 0
        dba: infix_postfix_meta_operator__S_292Equal
        i: 0
        min: 1
        r: 1
        s: 0
        text: =
      - !!perl/hash:RE_method 
        min: 0
        name: can_meta
        nobind: 1
        rest: ($op, "make assignment out of")
      - !!perl/hash:RE_bracket 
        decl: []

        min: 0
        re: !!perl/hash:RE_first 
          a: 0
          dba: infix_postfix_meta_operator__S_292Equal
          i: 0
          min: 0
          r: 1
          s: 0
          zyg: 
            - !!perl/hash:RE_assertion 
              assert: "!"
              min: 0
              re: !!perl/hash:RE_block 
                a: 0
                context: bool
                dba: infix_postfix_meta_operator__S_292Equal
                i: 0
                min: 0
                nobind: 1
                r: 1
                s: 0
                text: " $op<O><diffy> "
            - !!perl/hash:RE_method 
              min: 0
              name: panic
              nobind: 1
              rest: ("Can't make assignment out of " ~ $op<sym> ~ " because " ~ $op<O><dba> ~ " operators are diffy")
      - !!perl/hash:RE_block 
        a: 0
        context: void
        dba: infix_postfix_meta_operator__S_292Equal
        i: 0
        min: 0
        r: 1
        s: 0
        text: " $<O> = $op<O>; $<sym> = $op<sym> ~ '='; $<O><dba> = \"assignment\"; $<O><prec>:delete; $<O><iffy> = 0; "
infix_prefix_meta_operator__S_287Bang: !!perl/hash:RE 
  decl: []

  kind: token
  min: 12345
  pkg: STD::Transparent
  re: !!perl/hash:RE_sequence 
    a: 0
    dba: infix_prefix_meta_operator__S_287Bang
    i: 0
    min: 12345
    r: 1
    s: 0
    zyg: 
      - !!perl/hash:RE_method 
        a: 0
        dba: infix_prefix_meta_operator__S_287Bang
        i: 0
        min: 12345
        name: sym
        r: 1
        rest: ''
        s: 0
        sym: "!"
      - !!perl/hash:RE_assertion 
        assert: "!"
        min: 0
        re: !!perl/hash:RE_method_re 
          a: 0
          dba: infix_prefix_meta_operator__S_287Bang
          i: 0
          min: 0
          name: before
          nobind: 1
          r: 1
          re: !!perl/hash:RE 
            decl: []

            min: 1
            re: !!perl/hash:RE_string 
              a: 0
              dba: infix_prefix_meta_operator__S_287Bang
              i: 0
              min: 1
              r: 1
              s: 0
              text: "!"
          s: 0
      - !!perl/hash:RE_block 
        a: 0
        context: void
        dba: infix_prefix_meta_operator__S_287Bang
        i: 0
        min: 0
        r: 1
        s: 0
        text: ''
      - !!perl/hash:RE_method 
        min: 0
        name: infixish
        rest: (1)
      - !!perl/hash:RE_bracket 
        decl: []

        min: 0
        re: !!perl/hash:RE_first 
          a: 0
          dba: infix_prefix_meta_operator__S_287Bang
          i: 0
          min: 0
          r: 1
          s: 0
          zyg: 
            - !!perl/hash:RE_sequence 
              a: 0
              dba: infix_prefix_meta_operator__S_287Bang
              i: 0
              min: 0
              r: 1
              s: 0
              zyg: 
                - !!perl/hash:RE_assertion 
                  assert: "?"
                  min: 0
                  re: !!perl/hash:RE_block 
                    a: 0
                    context: bool
                    dba: infix_prefix_meta_operator__S_287Bang
                    i: 0
                    min: 0
                    nobind: 1
                    r: 1
                    s: 0
                    text: " $<infixish>.Str eq '=' "
                - !!perl/hash:RE_block 
                  a: 0
                  context: void
                  dba: infix_prefix_meta_operator__S_287Bang
                  i: 0
                  min: 0
                  r: 1
                  s: 0
                  text: " $¢ = ::Chaining.coerce($¢); "
            - !!perl/hash:RE_sequence 
              a: 0
              dba: infix_prefix_meta_operator__S_287Bang
              i: 0
              min: 0
              r: 1
              s: 0
              zyg: 
                - !!perl/hash:RE_method 
                  min: 0
                  name: can_meta
                  nobind: 1
                  rest: ($<infixish>, "negate")
                - !!perl/hash:RE_assertion 
                  assert: "?"
                  min: 0
                  re: !!perl/hash:RE_block 
                    a: 0
                    context: bool
                    dba: infix_prefix_meta_operator__S_287Bang
                    i: 0
                    min: 0
                    nobind: 1
                    r: 1
                    s: 0
                    text: " $<infixish><O><iffy> "
                - !!perl/hash:RE_assertion 
                  assert: "?"
                  min: 0
                  re: !!perl/hash:RE_block 
                    a: 0
                    context: bool
                    dba: infix_prefix_meta_operator__S_287Bang
                    i: 0
                    min: 0
                    nobind: 1
                    r: 1
                    s: 0
                    text: " $<O> = $<infixish><O>; "
            - !!perl/hash:RE_method 
              min: 0
              name: panic
              nobind: 1
              rest: ("Can't negate " ~ $<infixish>.Str ~ " because " ~ $<infixish><O><dba> ~ " operators are not iffy enough")
infix_prefix_meta_operator__S_288R: !!perl/hash:RE 
  decl: []

  kind: token
  min: 12345
  pkg: STD::Transparent
  re: !!perl/hash:RE_sequence 
    a: 0
    dba: infix_prefix_meta_operator__S_288R
    i: 0
    min: 12345
    r: 1
    s: 0
    zyg: 
      - !!perl/hash:RE_method 
        a: 0
        dba: infix_prefix_meta_operator__S_288R
        i: 0
        min: 12345
        name: sym
        r: 1
        rest: ''
        s: 0
        sym: R
      - !!perl/hash:RE_block 
        a: 0
        context: void
        dba: infix_prefix_meta_operator__S_288R
        i: 0
        min: 0
        r: 1
        s: 0
        text: ''
      - !!perl/hash:RE_method 
        min: 0
        name: infixish
        rest: (1)
      - !!perl/hash:RE_method 
        min: 0
        name: can_meta
        nobind: 1
        rest: ($<infixish>, "reverse")
      - !!perl/hash:RE_assertion 
        assert: "?"
        min: 0
        re: !!perl/hash:RE_block 
          a: 0
          context: bool
          dba: infix_prefix_meta_operator__S_288R
          i: 0
          min: 0
          nobind: 1
          r: 1
          s: 0
          text: " $<O> = $<infixish><O>; "
infix_prefix_meta_operator__S_289X: !!perl/hash:RE 
  decl: []

  kind: token
  min: 12345
  pkg: STD::List_infix
  re: !!perl/hash:RE_sequence 
    a: 0
    dba: infix_prefix_meta_operator__S_289X
    i: 0
    min: 12345
    r: 1
    s: 0
    zyg: 
      - !!perl/hash:RE_method 
        a: 0
        dba: infix_prefix_meta_operator__S_289X
        i: 0
        min: 12345
        name: sym
        r: 1
        rest: ''
        s: 0
        sym: X
      - !!perl/hash:RE_block 
        a: 0
        context: void
        dba: infix_prefix_meta_operator__S_289X
        i: 0
        min: 0
        r: 1
        s: 0
        text: ''
      - !!perl/hash:RE_quantified_atom 
        atom: !!perl/hash:RE_bracket 
          decl: []

          min: 0
          re: !!perl/hash:RE_sequence 
            a: 0
            dba: infix_prefix_meta_operator__S_289X
            i: 0
            min: 0
            r: 1
            s: 0
            zyg: 
              - !!perl/hash:RE_method 
                min: 0
                name: infixish
                rest: (1)
              - !!perl/hash:RE_quantified_atom 
                atom: !!perl/hash:RE_bracket 
                  decl: []

                  min: 1
                  re: !!perl/hash:RE_sequence 
                    a: 0
                    dba: infix_prefix_meta_operator__S_289X
                    i: 0
                    min: 1
                    r: 1
                    s: 0
                    zyg: 
                      - !!perl/hash:RE_string 
                        a: 0
                        dba: infix_prefix_meta_operator__S_289X
                        i: 0
                        min: 1
                        r: 1
                        s: 0
                        text: X
                      - !!perl/hash:RE_method 
                        min: 0
                        name: panic
                        nobind: 1
                        rest: ("Old form of XopX found")
                min: 0
                quant: 
                  - "?"
                  - ":"
                  - ''
                  - 0
              - !!perl/hash:RE_method 
                min: 0
                name: can_meta
                nobind: 1
                rest: ($<infixish>[0], "cross")
              - !!perl/hash:RE_assertion 
                assert: "?"
                min: 0
                re: !!perl/hash:RE_block 
                  a: 0
                  context: bool
                  dba: infix_prefix_meta_operator__S_289X
                  i: 0
                  min: 0
                  nobind: 1
                  r: 1
                  s: 0
                  text: " $<O> = $<infixish>[0]<O>; $<O><prec>:delete; $<sym> ~= $<infixish>[0].Str "
        min: 0
        quant: 
          - "?"
          - ":"
          - ''
          - 0
infixish: !!perl/hash:RE 
  decl: 
    - !!perl/hash:RE_decl 
      a: 0
      dba: infixish
      i: 0
      max: 0
      min: 0
      r: 1
      s: 0
      text: my $infix
    - !!perl/hash:RE_decl 
      a: 0
      dba: infixish
      i: 0
      max: 0
      min: 0
      r: 1
      s: 0
      text: my $IN_META is context<rw> = $in_meta
  kind: token
  min: 2
  pkg: ~
  re: !!perl/hash:RE_sequence 
    a: 0
    dba: infix or meta-infix
    i: 0
    min: 2
    r: 1
    s: 0
    zyg: 
      - !!perl/hash:RE_assertion 
        assert: "!"
        min: 0
        re: !!perl/hash:RE_method 
          a: 0
          dba: infixish
          i: 0
          min: 12345
          name: stdstopper
          nobind: 1
          r: 1
          rest: ''
          s: 0
      - !!perl/hash:RE_assertion 
        assert: "!"
        min: 0
        re: !!perl/hash:RE_method 
          a: 0
          dba: infixish
          i: 0
          min: 12345
          name: infixstopper
          nobind: 1
          r: 1
          rest: ''
          s: 0
      - !!perl/hash:RE_bracket 
        decl: []

        min: 2
        re: &124 !!perl/hash:RE_any 
          a: 0
          altname: infixish_01
          dba: bracketed infix
          i: 0
          min: 2
          name: infixish_01
          r: 1
          s: 0
          zyg: 
            - !!perl/hash:RE_sequence 
              a: 0
              alt: infixish_01 0
              dba: infix or meta-infix
              i: 0
              min: 12345
              r: 1
              s: 0
              zyg: 
                - !!perl/hash:RE_method 
                  a: 0
                  dba: infix or meta-infix
                  i: 0
                  min: 12345
                  name: colonpair
                  r: 1
                  rest: ''
                  s: 0
                - !!perl/hash:RE_block 
                  a: 0
                  context: void
                  dba: infix or meta-infix
                  i: 0
                  min: 0
                  r: 1
                  s: 0
                  text: "\n            $<fake> = 1;\n            $<sym> = ':';\n            %<O><prec> = %item_assignment<prec>;  # actual test is non-inclusive!\n            %<O><assoc> = 'unary';\n            %<O><kind> = 'ADVERB';\n        "
            - !!perl/hash:RE_sequence 
              a: 0
              alt: infixish_01 1
              dba: bracketed infix
              i: 0
              min: 2
              r: 1
              s: 0
              zyg: 
                - !!perl/hash:RE_string 
                  a: 0
                  dba: bracketed infix
                  i: 0
                  min: 1
                  r: 1
                  s: 0
                  text: "["
                - !!perl/hash:RE_meta 
                  a: 0
                  dba: bracketed infix
                  extra: "local $::GOAL = ']' "
                  i: 0
                  min: 0
                  r: 1
                  s: 0
                  text: "::"
                - !!perl/hash:RE_method 
                  min: 0
                  name: infixish
                  rest: (1)
                - !!perl/hash:RE_bracket 
                  decl: []

                  min: 1
                  re: !!perl/hash:RE_first 
                    a: 0
                    dba: bracketed infix
                    i: 0
                    min: 1
                    r: 1
                    s: 0
                    zyg: 
                      - !!perl/hash:RE_string 
                        a: 0
                        dba: bracketed infix
                        i: 0
                        min: 1
                        r: 1
                        s: 0
                        text: "]"
                      - !!perl/hash:RE_method 
                        min: 0
                        name: FAILGOAL
                        nobind: 1
                        rest: (']' , 'bracketed infix')
                - !!perl/hash:RE_block 
                  a: 0
                  context: void
                  dba: bracketed infix
                  i: 0
                  min: 0
                  r: 1
                  s: 0
                  text: " $<O> = $<infixish><O>; $<sym> = $<infixish><sym>; "
            - !!perl/hash:RE_sequence 
              a: 0
              alt: infixish_01 2
              dba: bracketed infix
              i: 0
              min: 12345
              r: 1
              s: 0
              zyg: 
                - !!perl/hash:RE_method 
                  a: 0
                  dba: bracketed infix
                  i: 0
                  min: 12345
                  name: infix_circumfix_meta_operator
                  r: 1
                  rest: ''
                  s: 0
                - !!perl/hash:RE_block 
                  a: 0
                  context: void
                  dba: bracketed infix
                  i: 0
                  min: 0
                  r: 1
                  s: 0
                  text: " $<O> = $<infix_circumfix_meta_operator><O>;\n          $<sym> = $<infix_circumfix_meta_operator><sym>; "
            - !!perl/hash:RE_sequence 
              a: 0
              alt: infixish_01 3
              dba: bracketed infix
              i: 0
              min: 12345
              r: 1
              s: 0
              zyg: 
                - !!perl/hash:RE_method 
                  a: 0
                  dba: bracketed infix
                  i: 0
                  min: 12345
                  name: infix_prefix_meta_operator
                  r: 1
                  rest: ''
                  s: 0
                - !!perl/hash:RE_block 
                  a: 0
                  context: void
                  dba: bracketed infix
                  i: 0
                  min: 0
                  r: 1
                  s: 0
                  text: " $<O> = $<infix_prefix_meta_operator><O>;\n          $<sym> = $<infix_prefix_meta_operator><sym>; "
            - !!perl/hash:RE_sequence 
              a: 0
              alt: infixish_01 4
              dba: bracketed infix
              i: 0
              min: 12345
              r: 1
              s: 0
              zyg: 
                - !!perl/hash:RE_method 
                  a: 0
                  dba: bracketed infix
                  i: 0
                  min: 12345
                  name: infix
                  r: 1
                  rest: ''
                  s: 0
                - !!perl/hash:RE_assertion 
                  assert: "!"
                  min: 0
                  re: !!perl/hash:RE_method_re 
                    a: 0
                    dba: bracketed infix
                    i: 0
                    min: 0
                    name: before
                    nobind: 1
                    r: 1
                    re: !!perl/hash:RE 
                      decl: []

                      min: 1
                      re: !!perl/hash:RE_string 
                        a: 0
                        dba: bracketed infix
                        i: 0
                        min: 1
                        r: 1
                        s: 0
                        text: =
                    s: 0
                - !!perl/hash:RE_block 
                  a: 0
                  context: void
                  dba: bracketed infix
                  i: 0
                  min: 0
                  r: 1
                  s: 0
                  text: " $<O> = $<infix>.<O>; $<sym> = $<infix>.<sym>; "
            - !!perl/hash:RE_sequence 
              a: 0
              alt: infixish_01 5
              dba: bracketed infix
              i: 0
              min: 12345
              r: 1
              s: 0
              zyg: 
                - !!perl/hash:RE_method 
                  a: 0
                  dba: bracketed infix
                  i: 0
                  min: 12345
                  name: infix
                  r: 1
                  rest: ''
                  s: 0
                - !!perl/hash:RE_assertion 
                  assert: "?"
                  min: 0
                  re: !!perl/hash:RE_method_re 
                    a: 0
                    dba: bracketed infix
                    i: 0
                    min: 0
                    name: before
                    nobind: 1
                    r: 1
                    re: !!perl/hash:RE 
                      decl: []

                      min: 1
                      re: !!perl/hash:RE_string 
                        a: 0
                        dba: bracketed infix
                        i: 0
                        min: 1
                        r: 1
                        s: 0
                        text: =
                    s: 0
                - !!perl/hash:RE_assertion 
                  assert: "?"
                  min: 0
                  re: !!perl/hash:RE_block 
                    a: 0
                    context: bool
                    dba: bracketed infix
                    i: 0
                    min: 0
                    nobind: 1
                    r: 1
                    s: 0
                    text: " $infix = $<infix>; "
                - !!perl/hash:RE_method 
                  min: 0
                  name: infix_postfix_meta_operator
                  rest: ($infix)
                - !!perl/hash:RE_block 
                  a: 0
                  context: void
                  dba: bracketed infix
                  i: 0
                  min: 0
                  r: 1
                  s: 0
                  text: " $<O> = $<infix_postfix_meta_operator>.<O>; $<sym> = $<infix_postfix_meta_operator>.<sym>; "
infixish_01: *124
infixstopper: !!perl/hash:RE 
  decl: []

  kind: regex
  min: 0
  pkg: ~
  re: !!perl/hash:RE_bracket 
    decl: []

    min: 0
    re: &59 !!perl/hash:RE_any 
      a: 0
      altname: infixstopper_01
      dba: infix stopper
      i: 0
      min: 0
      name: infixstopper_01
      r: 0
      s: 0
      zyg: 
        - !!perl/hash:RE_assertion 
          alt: infixstopper_01 0
          assert: "?"
          min: 0
          re: !!perl/hash:RE_method_re 
            a: 0
            dba: infix stopper
            i: 0
            min: 0
            name: before
            nobind: 1
            r: 0
            re: !!perl/hash:RE 
              decl: []

              min: 12345
              re: !!perl/hash:RE_method 
                a: 0
                dba: infix stopper
                i: 0
                min: 12345
                name: stopper
                r: 0
                rest: ''
                s: 0
            s: 0
        - !!perl/hash:RE_sequence 
          a: 0
          alt: infixstopper_01 1
          dba: infix stopper
          i: 0
          min: 0
          r: 0
          s: 0
          zyg: 
            - !!perl/hash:RE_assertion 
              assert: "?"
              min: 0
              re: !!perl/hash:RE_method_re 
                a: 0
                dba: infix stopper
                i: 0
                min: 0
                name: before
                nobind: 1
                r: 0
                re: !!perl/hash:RE 
                  decl: []

                  min: 2
                  re: !!perl/hash:RE_string 
                    a: 0
                    dba: infix stopper
                    i: 0
                    min: 2
                    r: 0
                    s: 0
                    text: "!!"
                s: 0
            - !!perl/hash:RE_assertion 
              assert: "?"
              min: 0
              re: !!perl/hash:RE_block 
                a: 0
                context: bool
                dba: infix stopper
                i: 0
                min: 0
                nobind: 1
                r: 0
                s: 0
                text: " $*GOAL eq '!!' "
        - !!perl/hash:RE_sequence 
          a: 0
          alt: infixstopper_01 2
          dba: infix stopper
          i: 0
          min: 0
          r: 0
          s: 0
          zyg: 
            - !!perl/hash:RE_assertion 
              assert: "?"
              min: 0
              re: !!perl/hash:RE_method_re 
                a: 0
                dba: infix stopper
                i: 0
                min: 0
                name: before
                nobind: 1
                r: 0
                re: !!perl/hash:RE 
                  decl: []

                  min: 1
                  re: &89 !!perl/hash:RE_any 
                    a: 0
                    altname: infixstopper_04
                    dba: infix stopper
                    i: 0
                    min: 1
                    name: infixstopper_04
                    r: 0
                    s: 0
                    zyg: 
                      - !!perl/hash:RE_string 
                        a: 0
                        alt: infixstopper_04 0
                        dba: infix stopper
                        i: 0
                        min: 1
                        r: 0
                        s: 0
                        text: "{"
                      - !!perl/hash:RE_method 
                        a: 0
                        alt: infixstopper_04 1
                        dba: infix stopper
                        i: 0
                        min: 12345
                        name: lambda
                        r: 0
                        rest: ''
                        s: 0
                s: 0
            - !!perl/hash:RE_assertion 
              assert: "?"
              min: 0
              re: !!perl/hash:RE_block 
                a: 0
                context: bool
                dba: infix stopper
                i: 0
                min: 0
                nobind: 1
                r: 0
                s: 0
                text: " ($*GOAL eq '{' or $*GOAL eq 'endargs') and @*MEMOS[$¢.pos]<ws> "
        - !!perl/hash:RE_assertion 
          alt: infixstopper_01 3
          assert: "?"
          min: 0
          re: !!perl/hash:RE_block 
            a: 0
            context: bool
            dba: infix stopper
            i: 0
            min: 0
            nobind: 1
            r: 0
            s: 0
            text: " $*GOAL eq 'endargs' and @*MEMOS[$¢.pos]<endargs> "
infixstopper_01: *59
infixstopper_04: *89
integer: !!perl/hash:RE 
  decl: []

  kind: token
  min: 1
  pkg: ~
  re: !!perl/hash:RE_sequence 
    a: 0
    dba: integer
    i: 0
    min: 1
    r: 1
    s: 0
    zyg: 
      - !!perl/hash:RE_bracket 
        decl: []

        min: 1
        re: &120 !!perl/hash:RE_any 
          a: 0
          altname: integer_01
          dba: integer
          i: 0
          min: 1
          name: integer_01
          r: 1
          s: 0
          zyg: 
            - !!perl/hash:RE_sequence 
              a: 0
              alt: integer_01 0
              dba: integer
              i: 0
              min: 2
              r: 1
              s: 0
              zyg: 
                - !!perl/hash:RE_string 
                  a: 0
                  dba: integer
                  i: 0
                  min: 1
                  r: 1
                  s: 0
                  text: 0
                - !!perl/hash:RE_bracket 
                  decl: []

                  min: 1
                  re: &38 !!perl/hash:RE_any 
                    a: 0
                    altname: integer_02
                    dba: integer
                    i: 0
                    min: 1
                    name: integer_02
                    r: 1
                    s: 0
                    zyg: 
                      - !!perl/hash:RE_sequence 
                        a: 0
                        alt: integer_02 0
                        dba: integer
                        i: 0
                        min: 2
                        r: 1
                        s: 0
                        zyg: 
                          - !!perl/hash:RE_string 
                            a: 0
                            dba: integer
                            i: 0
                            min: 1
                            r: 1
                            s: 0
                            text: b
                          - !!perl/hash:RE_quantified_atom 
                            atom: !!perl/hash:RE_cclass 
                              a: 0
                              dba: integer
                              i: 0
                              min: 1
                              r: 1
                              s: 0
                              text: "[01]"
                            min: 1
                            quant: 
                              - +
                              - ":"
                              - ''
                              - 1
                          - !!perl/hash:RE_quantified_atom 
                            atom: !!perl/hash:RE_bracket 
                              decl: []

                              min: 2
                              re: !!perl/hash:RE_sequence 
                                a: 0
                                dba: integer
                                i: 0
                                min: 2
                                r: 1
                                s: 0
                                zyg: 
                                  - !!perl/hash:RE_string 
                                    a: 0
                                    dba: integer
                                    i: 0
                                    min: 1
                                    r: 1
                                    s: 0
                                    text: _
                                  - !!perl/hash:RE_quantified_atom 
                                    atom: !!perl/hash:RE_cclass 
                                      a: 0
                                      dba: integer
                                      i: 0
                                      min: 1
                                      r: 1
                                      s: 0
                                      text: "[01]"
                                    min: 1
                                    quant: 
                                      - +
                                      - ":"
                                      - ''
                                      - 1
                            min: 0
                            quant: 
                              - "*"
                              - ":"
                              - ''
                              - 0
                      - !!perl/hash:RE_sequence 
                        a: 0
                        alt: integer_02 1
                        dba: integer
                        i: 0
                        min: 2
                        r: 1
                        s: 0
                        zyg: 
                          - !!perl/hash:RE_string 
                            a: 0
                            dba: integer
                            i: 0
                            min: 1
                            r: 1
                            s: 0
                            text: o
                          - !!perl/hash:RE_quantified_atom 
                            atom: !!perl/hash:RE_cclass 
                              a: 0
                              dba: integer
                              i: 0
                              min: 1
                              r: 1
                              s: 0
                              text: "[0..7]"
                            min: 1
                            quant: 
                              - +
                              - ":"
                              - ''
                              - 1
                          - !!perl/hash:RE_quantified_atom 
                            atom: !!perl/hash:RE_bracket 
                              decl: []

                              min: 2
                              re: !!perl/hash:RE_sequence 
                                a: 0
                                dba: integer
                                i: 0
                                min: 2
                                r: 1
                                s: 0
                                zyg: 
                                  - !!perl/hash:RE_string 
                                    a: 0
                                    dba: integer
                                    i: 0
                                    min: 1
                                    r: 1
                                    s: 0
                                    text: _
                                  - !!perl/hash:RE_quantified_atom 
                                    atom: !!perl/hash:RE_cclass 
                                      a: 0
                                      dba: integer
                                      i: 0
                                      min: 1
                                      r: 1
                                      s: 0
                                      text: "[0..7]"
                                    min: 1
                                    quant: 
                                      - +
                                      - ":"
                                      - ''
                                      - 1
                            min: 0
                            quant: 
                              - "*"
                              - ":"
                              - ''
                              - 0
                      - !!perl/hash:RE_sequence 
                        a: 0
                        alt: integer_02 2
                        dba: integer
                        i: 0
                        min: 2
                        r: 1
                        s: 0
                        zyg: 
                          - !!perl/hash:RE_string 
                            a: 0
                            dba: integer
                            i: 0
                            min: 1
                            r: 1
                            s: 0
                            text: x
                          - !!perl/hash:RE_quantified_atom 
                            atom: !!perl/hash:RE_cclass 
                              a: 0
                              dba: integer
                              i: 0
                              min: 1
                              r: 1
                              s: 0
                              text: "[0..9a..fA..F]"
                            min: 1
                            quant: 
                              - +
                              - ":"
                              - ''
                              - 1
                          - !!perl/hash:RE_quantified_atom 
                            atom: !!perl/hash:RE_bracket 
                              decl: []

                              min: 2
                              re: !!perl/hash:RE_sequence 
                                a: 0
                                dba: integer
                                i: 0
                                min: 2
                                r: 1
                                s: 0
                                zyg: 
                                  - !!perl/hash:RE_string 
                                    a: 0
                                    dba: integer
                                    i: 0
                                    min: 1
                                    r: 1
                                    s: 0
                                    text: _
                                  - !!perl/hash:RE_quantified_atom 
                                    atom: !!perl/hash:RE_cclass 
                                      a: 0
                                      dba: integer
                                      i: 0
                                      min: 1
                                      r: 1
                                      s: 0
                                      text: "[0..9a..fA..F]"
                                    min: 1
                                    quant: 
                                      - +
                                      - ":"
                                      - ''
                                      - 1
                            min: 0
                            quant: 
                              - "*"
                              - ":"
                              - ''
                              - 0
                      - !!perl/hash:RE_sequence 
                        a: 0
                        alt: integer_02 3
                        dba: integer
                        i: 0
                        min: 2
                        r: 1
                        s: 0
                        zyg: 
                          - !!perl/hash:RE_string 
                            a: 0
                            dba: integer
                            i: 0
                            min: 1
                            r: 1
                            s: 0
                            text: d
                          - !!perl/hash:RE_quantified_atom 
                            atom: !!perl/hash:RE_meta 
                              a: 0
                              dba: integer
                              i: 0
                              min: 1
                              r: 1
                              s: 0
                              text: \d
                            min: 1
                            quant: 
                              - +
                              - ":"
                              - ''
                              - 1
                          - !!perl/hash:RE_quantified_atom 
                            atom: !!perl/hash:RE_bracket 
                              decl: []

                              min: 2
                              re: !!perl/hash:RE_sequence 
                                a: 0
                                dba: integer
                                i: 0
                                min: 2
                                r: 1
                                s: 0
                                zyg: 
                                  - !!perl/hash:RE_string 
                                    a: 0
                                    dba: integer
                                    i: 0
                                    min: 1
                                    r: 1
                                    s: 0
                                    text: _
                                  - !!perl/hash:RE_quantified_atom 
                                    atom: !!perl/hash:RE_meta 
                                      a: 0
                                      dba: integer
                                      i: 0
                                      min: 1
                                      r: 1
                                      s: 0
                                      text: \d
                                    min: 1
                                    quant: 
                                      - +
                                      - ":"
                                      - ''
                                      - 1
                            min: 0
                            quant: 
                              - "*"
                              - ":"
                              - ''
                              - 0
                      - !!perl/hash:RE_sequence 
                        a: 0
                        alt: integer_02 4
                        dba: integer
                        i: 0
                        min: 1
                        r: 1
                        s: 0
                        zyg: 
                          - !!perl/hash:RE_quantified_atom 
                            atom: !!perl/hash:RE_meta 
                              a: 0
                              dba: integer
                              i: 0
                              min: 1
                              r: 1
                              s: 0
                              text: \d
                            min: 1
                            quant: 
                              - +
                              - ":"
                              - ''
                              - 1
                          - !!perl/hash:RE_quantified_atom 
                            atom: !!perl/hash:RE_bracket 
                              decl: []

                              min: 2
                              re: !!perl/hash:RE_sequence 
                                a: 0
                                dba: integer
                                i: 0
                                min: 2
                                r: 1
                                s: 0
                                zyg: 
                                  - !!perl/hash:RE_string 
                                    a: 0
                                    dba: integer
                                    i: 0
                                    min: 1
                                    r: 1
                                    s: 0
                                    text: _
                                  - !!perl/hash:RE_quantified_atom 
                                    atom: !!perl/hash:RE_meta 
                                      a: 0
                                      dba: integer
                                      i: 0
                                      min: 1
                                      r: 1
                                      s: 0
                                      text: \d
                                    min: 1
                                    quant: 
                                      - +
                                      - ":"
                                      - ''
                                      - 1
                            min: 0
                            quant: 
                              - "*"
                              - ":"
                              - ''
                              - 0
                          - !!perl/hash:RE_assertion 
                            assert: "!"
                            min: 0
                            re: !!perl/hash:RE_assertion 
                              assert: "!"
                              min: 0
                              nobind: 1
                              re: !!perl/hash:RE_block 
                                a: 0
                                context: bool
                                dba: integer
                                i: 0
                                min: 0
                                nobind: 1
                                r: 1
                                s: 0
                                text: " $¢.worry(\"Leading 0 does not indicate octal in Perl 6\") "
            - !!perl/hash:RE_sequence 
              a: 0
              alt: integer_01 1
              dba: integer
              i: 0
              min: 1
              r: 1
              s: 0
              zyg: 
                - !!perl/hash:RE_quantified_atom 
                  atom: !!perl/hash:RE_meta 
                    a: 0
                    dba: integer
                    i: 0
                    min: 1
                    r: 1
                    s: 0
                    text: \d
                  min: 1
                  quant: 
                    - +
                    - ":"
                    - ''
                    - 1
                - !!perl/hash:RE_quantified_atom 
                  atom: !!perl/hash:RE_bracket 
                    decl: []

                    min: 2
                    re: !!perl/hash:RE_sequence 
                      a: 0
                      dba: integer
                      i: 0
                      min: 2
                      r: 1
                      s: 0
                      zyg: 
                        - !!perl/hash:RE_string 
                          a: 0
                          dba: integer
                          i: 0
                          min: 1
                          r: 1
                          s: 0
                          text: _
                        - !!perl/hash:RE_quantified_atom 
                          atom: !!perl/hash:RE_meta 
                            a: 0
                            dba: integer
                            i: 0
                            min: 1
                            r: 1
                            s: 0
                            text: \d
                          min: 1
                          quant: 
                            - +
                            - ":"
                            - ''
                            - 1
                  min: 0
                  quant: 
                    - "*"
                    - ":"
                    - ''
                    - 0
      - !!perl/hash:RE_assertion 
        assert: "!"
        min: 0
        re: !!perl/hash:RE_assertion 
          assert: "!"
          min: 0
          nobind: 1
          re: !!perl/hash:RE_method_re 
            a: 0
            dba: integer
            i: 0
            min: 0
            name: before
            nobind: 1
            r: 1
            re: !!perl/hash:RE 
              decl: []

              min: 0
              re: !!perl/hash:RE_quantified_atom 
                atom: !!perl/hash:RE_bracket 
                  decl: []

                  min: 1
                  re: !!perl/hash:RE_sequence 
                    a: 0
                    dba: integer
                    i: 0
                    min: 1
                    r: 1
                    s: 0
                    zyg: 
                      - !!perl/hash:RE_string 
                        a: 0
                        dba: integer
                        i: 0
                        min: 1
                        r: 1
                        s: 0
                        text: .
                      - !!perl/hash:RE_assertion 
                        assert: "?"
                        min: 0
                        re: !!perl/hash:RE_method_re 
                          a: 0
                          dba: integer
                          i: 0
                          min: 0
                          name: before
                          nobind: 1
                          r: 1
                          re: !!perl/hash:RE 
                            decl: []

                            min: 1
                            re: &121 !!perl/hash:RE_any 
                              a: 0
                              altname: integer_11
                              dba: integer
                              i: 0
                              min: 1
                              name: integer_11
                              r: 1
                              s: 0
                              zyg: 
                                - !!perl/hash:RE_meta 
                                  a: 0
                                  alt: integer_11 0
                                  dba: integer
                                  i: 0
                                  min: 1
                                  r: 1
                                  s: 0
                                  text: \s
                                - !!perl/hash:RE_string 
                                  a: 0
                                  alt: integer_11 1
                                  dba: integer
                                  i: 0
                                  min: 1
                                  r: 1
                                  s: 0
                                  text: ","
                                - !!perl/hash:RE_string 
                                  a: 0
                                  alt: integer_11 2
                                  dba: integer
                                  i: 0
                                  min: 1
                                  r: 1
                                  s: 0
                                  text: =
                                - !!perl/hash:RE_method 
                                  a: 0
                                  alt: integer_11 3
                                  dba: integer
                                  i: 0
                                  min: 12345
                                  name: terminator
                                  r: 1
                                  rest: ''
                                  s: 0
                          s: 0
                      - !!perl/hash:RE_method 
                        min: 0
                        name: panic
                        nobind: 1
                        rest: ("Decimal point must be followed by digit")
                min: 0
                quant: 
                  - "?"
                  - ":"
                  - ''
                  - 0
            s: 0
integer_01: *120
integer_02: *38
integer_11: *121
label: !!perl/hash:RE 
  decl: 
    - !!perl/hash:RE_decl 
      a: 0
      dba: label
      i: 0
      max: 0
      min: 0
      r: 1
      s: 0
      text: my $label
  kind: token
  min: 24691
  pkg: ~
  re: !!perl/hash:RE_sequence 
    a: 0
    dba: label
    i: 0
    min: 24691
    r: 1
    s: 0
    zyg: 
      - !!perl/hash:RE_method 
        a: 0
        dba: label
        i: 0
        min: 12345
        name: identifier
        r: 1
        rest: ''
        s: 0
      - !!perl/hash:RE_string 
        a: 0
        dba: label
        i: 0
        min: 1
        r: 1
        s: 0
        text: ":"
      - !!perl/hash:RE_assertion 
        assert: "?"
        min: 0
        re: !!perl/hash:RE_method_re 
          a: 0
          dba: label
          i: 0
          min: 0
          name: before
          nobind: 1
          r: 1
          re: !!perl/hash:RE 
            decl: []

            min: 1
            re: !!perl/hash:RE_meta 
              a: 0
              dba: label
              i: 0
              min: 1
              r: 1
              s: 0
              text: \s
          s: 0
      - !!perl/hash:RE_method 
        a: 0
        dba: label
        i: 0
        min: 12345
        name: ws
        nobind: 1
        r: 1
        rest: ''
        s: 0
      - !!perl/hash:RE_quantified_atom 
        atom: !!perl/hash:RE_bracket 
          decl: []

          min: 0
          re: !!perl/hash:RE_sequence 
            a: 0
            dba: label
            i: 0
            min: 0
            r: 1
            s: 0
            zyg: 
              - !!perl/hash:RE_assertion 
                assert: "?"
                min: 0
                re: !!perl/hash:RE_block 
                  a: 0
                  context: bool
                  dba: label
                  i: 0
                  min: 0
                  nobind: 1
                  r: 1
                  s: 0
                  text: " $¢.is_name($label = $<identifier>.Str) "
              - !!perl/hash:RE_method 
                min: 0
                name: panic
                nobind: 1
                rest: ("Illegal redeclaration of '$label'")
        min: 0
        quant: 
          - "?"
          - ":"
          - ''
          - 0
      - !!perl/hash:RE_block 
        a: 0
        context: void
        dba: label
        i: 0
        min: 0
        r: 1
        s: 0
        text: " $¢.add_my_name($label); "
lambda: !!perl/hash:RE 
  decl: []

  kind: token
  min: 2
  pkg: ~
  re: &106 !!perl/hash:RE_any 
    a: 0
    altname: lambda_00
    dba: lambda
    i: 0
    min: 2
    name: lambda_00
    r: 1
    s: 0
    zyg: 
      - !!perl/hash:RE_string 
        a: 0
        alt: lambda_00 0
        dba: lambda
        i: 0
        min: 2
        r: 1
        s: 0
        text: ->
      - !!perl/hash:RE_string 
        a: 0
        alt: lambda_00 1
        dba: lambda
        i: 0
        min: 3
        r: 1
        s: 0
        text: <->
lambda_00: *106
longname: !!perl/hash:RE 
  decl: []

  kind: token
  min: 12345
  pkg: ~
  re: !!perl/hash:RE_sequence 
    a: 0
    dba: longname
    i: 0
    min: 12345
    r: 1
    s: 0
    zyg: 
      - !!perl/hash:RE_method 
        a: 0
        dba: longname
        i: 0
        min: 12345
        name: name
        r: 1
        rest: ''
        s: 0
      - !!perl/hash:RE_quantified_atom 
        atom: !!perl/hash:RE_method 
          a: 0
          dba: longname
          i: 0
          min: 12345
          name: colonpair
          r: 1
          rest: ''
          s: 0
        min: 0
        quant: 
          - "*"
          - ":"
          - ''
          - 0
macro_def: !!perl/hash:RE 
  decl: 
    - !!perl/hash:RE_decl 
      a: 0
      dba: macro_def
      i: 0
      max: 0
      min: 0
      r: 1
      s: 1
      text: my $IN_DECL is context<rw> = 1
    - !!perl/hash:RE_decl 
      a: 0
      dba: macro_def
      i: 0
      max: 0
      min: 0
      r: 1
      s: 1
      text: my $DECLARAND is context<rw>
  kind: rule
  min: 0
  pkg: ~
  re: !!perl/hash:RE_first 
    a: 0
    dba: macro_def
    i: 0
    min: 0
    r: 1
    s: 1
    zyg: 
      - !!perl/hash:RE_sequence 
        a: 0
        dba: macro_def
        i: 0
        min: 24690
        r: 1
        s: 1
        zyg: 
          - !!perl/hash:RE_method 
            min: 0
            name: ws
            nobind: 1
            noquant: 1
            rest: ''
          - !!perl/hash:RE_bracket 
            decl: []

            min: 24690
            re: !!perl/hash:RE_sequence 
              a: 0
              dba: macro_def
              i: 0
              min: 24690
              r: 1
              s: 0
              zyg: 
                - !!perl/hash:RE_quantified_atom 
                  atom: !!perl/hash:RE_bracket 
                    decl: []

                    min: 1
                    re: &113 !!perl/hash:RE_any 
                      a: 0
                      altname: macro_def_02
                      dba: macro_def
                      i: 0
                      min: 1
                      name: macro_def_02
                      r: 1
                      s: 1
                      zyg: 
                        - !!perl/hash:RE_sequence 
                          a: 0
                          alt: macro_def_02 0
                          dba: macro_def
                          i: 0
                          min: 1
                          r: 1
                          s: 1
                          zyg: 
                            - !!perl/hash:RE_method 
                              min: 0
                              name: ws
                              nobind: 1
                              noquant: 1
                              rest: ''
                            - !!perl/hash:RE_string 
                              a: 0
                              dba: macro_def
                              i: 0
                              min: 1
                              r: 1
                              s: 1
                              text: "&"
                            - !!perl/hash:RE_quantified_atom 
                              atom: !!perl/hash:RE_method 
                                a: 0
                                dba: macro_def
                                i: 0
                                min: 12345
                                name: deflongname
                                r: 1
                                rest: ''
                                s: 1
                              min: 0
                              quant: 
                                - "?"
                                - ":"
                                - ''
                                - 0
                            - !!perl/hash:RE_method 
                              min: 0
                              name: ws
                              nobind: 1
                              noquant: 1
                              rest: ''
                        - !!perl/hash:RE_sequence 
                          a: 0
                          alt: macro_def_02 1
                          dba: macro_def
                          i: 0
                          min: 12345
                          r: 1
                          s: 1
                          zyg: 
                            - !!perl/hash:RE_method 
                              min: 0
                              name: ws
                              nobind: 1
                              noquant: 1
                              rest: ''
                            - !!perl/hash:RE_method 
                              a: 0
                              dba: macro_def
                              i: 0
                              min: 12345
                              name: deflongname
                              r: 1
                              rest: ''
                              s: 1
                            - !!perl/hash:RE_method 
                              min: 0
                              name: ws
                              nobind: 1
                              noquant: 1
                              rest: ''
                  min: 0
                  quant: 
                    - "?"
                    - ":"
                    - ''
                    - 0
                - !!perl/hash:RE_method 
                  min: 0
                  name: ws
                  nobind: 1
                  noquant: 1
                  rest: ''
                - !!perl/hash:RE_method 
                  a: 0
                  dba: macro_def
                  i: 0
                  min: 12345
                  name: newpad
                  nobind: 1
                  r: 1
                  rest: ''
                  s: 1
                - !!perl/hash:RE_method 
                  min: 0
                  name: ws
                  nobind: 1
                  noquant: 1
                  rest: ''
                - !!perl/hash:RE_quantified_atom 
                  atom: !!perl/hash:RE_bracket 
                    decl: []

                    min: 12345
                    re: &14 !!perl/hash:RE_any 
                      a: 0
                      altname: macro_def_03
                      dba: macro_def
                      i: 0
                      min: 12345
                      name: macro_def_03
                      r: 1
                      s: 1
                      zyg: 
                        - !!perl/hash:RE_sequence 
                          a: 0
                          alt: macro_def_03 0
                          dba: macro_def
                          i: 0
                          min: 12345
                          r: 1
                          s: 1
                          zyg: 
                            - !!perl/hash:RE_method 
                              min: 0
                              name: ws
                              nobind: 1
                              noquant: 1
                              rest: ''
                            - !!perl/hash:RE_method 
                              a: 0
                              dba: macro_def
                              i: 0
                              min: 12345
                              name: multisig
                              r: 1
                              rest: ''
                              s: 1
                            - !!perl/hash:RE_method 
                              min: 0
                              name: ws
                              nobind: 1
                              noquant: 1
                              rest: ''
                        - !!perl/hash:RE_sequence 
                          a: 0
                          alt: macro_def_03 1
                          dba: macro_def
                          i: 0
                          min: 12345
                          r: 1
                          s: 1
                          zyg: 
                            - !!perl/hash:RE_method 
                              min: 0
                              name: ws
                              nobind: 1
                              noquant: 1
                              rest: ''
                            - !!perl/hash:RE_method 
                              a: 0
                              dba: macro_def
                              i: 0
                              min: 12345
                              name: trait
                              r: 1
                              rest: ''
                              s: 1
                            - !!perl/hash:RE_method 
                              min: 0
                              name: ws
                              nobind: 1
                              noquant: 1
                              rest: ''
                  min: 0
                  quant: 
                    - "*"
                    - ":"
                    - ''
                    - 0
                - !!perl/hash:RE_method 
                  min: 0
                  name: ws
                  nobind: 1
                  noquant: 1
                  rest: ''
                - !!perl/hash:RE_assertion 
                  assert: "!"
                  min: 0
                  re: !!perl/hash:RE_block 
                    a: 0
                    context: bool
                    dba: macro_def
                    i: 0
                    min: 0
                    nobind: 1
                    r: 1
                    s: 1
                    text: "\n            $*IN_DECL = 0;\n        "
                - !!perl/hash:RE_method 
                  min: 0
                  name: ws
                  nobind: 1
                  noquant: 1
                  rest: ''
                - !!perl/hash:RE_method 
                  a: 0
                  dba: macro_def
                  i: 0
                  min: 12345
                  name: blockoid
                  r: 1
                  rest: ''
                  s: 1
          - !!perl/hash:RE_method 
            min: 0
            name: ws
            nobind: 1
            noquant: 1
            rest: ''
      - !!perl/hash:RE_sequence 
        a: 0
        dba: macro_def
        i: 0
        min: 0
        r: 1
        s: 1
        zyg: 
          - !!perl/hash:RE_method 
            min: 0
            name: ws
            nobind: 1
            noquant: 1
            rest: ''
          - !!perl/hash:RE_method 
            min: 0
            name: panic
            nobind: 1
            rest: ("Malformed macro")
          - !!perl/hash:RE_method 
            min: 0
            name: ws
            nobind: 1
            noquant: 1
            rest: ''
macro_def_02: *113
macro_def_03: *14
method_def: !!perl/hash:RE 
  decl: 
    - !!perl/hash:RE_decl 
      a: 0
      dba: method_def
      i: 0
      max: 0
      min: 0
      r: 1
      s: 1
      text: my $IN_DECL is context<rw> = 1
    - !!perl/hash:RE_decl 
      a: 0
      dba: method_def
      i: 0
      max: 0
      min: 0
      r: 1
      s: 1
      text: my $DECLARAND is context<rw>
  kind: rule
  min: 0
  pkg: ~
  re: !!perl/hash:RE_first 
    a: 0
    dba: method_def
    i: 0
    min: 0
    r: 1
    s: 1
    zyg: 
      - !!perl/hash:RE_sequence 
        a: 0
        dba: method_def
        i: 0
        min: 24690
        r: 1
        s: 1
        zyg: 
          - !!perl/hash:RE_method 
            min: 0
            name: ws
            nobind: 1
            noquant: 1
            rest: ''
          - !!perl/hash:RE_method 
            a: 0
            dba: method_def
            i: 0
            min: 12345
            name: newpad
            nobind: 1
            r: 1
            rest: ''
            s: 1
          - !!perl/hash:RE_method 
            min: 0
            name: ws
            nobind: 1
            noquant: 1
            rest: ''
          - !!perl/hash:RE_bracket 
            decl: []

            min: 12345
            re: !!perl/hash:RE_sequence 
              a: 0
              dba: method_def
              i: 0
              min: 12345
              r: 1
              s: 0
              zyg: 
                - !!perl/hash:RE_bracket 
                  decl: []

                  min: 0
                  re: &63 !!perl/hash:RE_any 
                    a: 0
                    altname: method_def_02
                    dba: subscript signature
                    i: 0
                    min: 0
                    name: method_def_02
                    r: 1
                    s: 1
                    zyg: 
                      - !!perl/hash:RE_sequence 
                        a: 0
                        alt: method_def_02 0
                        dba: method_def
                        i: 0
                        min: 12345
                        r: 1
                        s: 1
                        zyg: 
                          - !!perl/hash:RE_quantified_atom 
                            atom: !!perl/hash:RE_cclass 
                              a: 0
                              dba: method_def
                              i: 0
                              min: 1
                              r: 1
                              s: 1
                              text: "[ ! ^ ]"
                            min: 0
                            quant: 
                              - "?"
                              - ":"
                              - ''
                              - 0
                          - !!perl/hash:RE_method 
                            a: 0
                            dba: method_def
                            i: 0
                            min: 12345
                            name: longname
                            r: 1
                            rest: ''
                            s: 1
                          - !!perl/hash:RE_method 
                            min: 0
                            name: ws
                            nobind: 1
                            noquant: 1
                            rest: ''
                          - !!perl/hash:RE_quantified_atom 
                            atom: !!perl/hash:RE_bracket 
                              decl: []

                              min: 12345
                              re: &2 !!perl/hash:RE_any 
                                a: 0
                                altname: method_def_03
                                dba: method_def
                                i: 0
                                min: 12345
                                name: method_def_03
                                r: 1
                                s: 1
                                zyg: 
                                  - !!perl/hash:RE_sequence 
                                    a: 0
                                    alt: method_def_03 0
                                    dba: method_def
                                    i: 0
                                    min: 12345
                                    r: 1
                                    s: 1
                                    zyg: 
                                      - !!perl/hash:RE_method 
                                        min: 0
                                        name: ws
                                        nobind: 1
                                        noquant: 1
                                        rest: ''
                                      - !!perl/hash:RE_method 
                                        a: 0
                                        dba: method_def
                                        i: 0
                                        min: 12345
                                        name: multisig
                                        r: 1
                                        rest: ''
                                        s: 1
                                      - !!perl/hash:RE_method 
                                        min: 0
                                        name: ws
                                        nobind: 1
                                        noquant: 1
                                        rest: ''
                                  - !!perl/hash:RE_sequence 
                                    a: 0
                                    alt: method_def_03 1
                                    dba: method_def
                                    i: 0
                                    min: 12345
                                    r: 1
                                    s: 1
                                    zyg: 
                                      - !!perl/hash:RE_method 
                                        min: 0
                                        name: ws
                                        nobind: 1
                                        noquant: 1
                                        rest: ''
                                      - !!perl/hash:RE_method 
                                        a: 0
                                        dba: method_def
                                        i: 0
                                        min: 12345
                                        name: trait
                                        r: 1
                                        rest: ''
                                        s: 1
                                      - !!perl/hash:RE_method 
                                        min: 0
                                        name: ws
                                        nobind: 1
                                        noquant: 1
                                        rest: ''
                            min: 0
                            quant: 
                              - "*"
                              - ":"
                              - ''
                              - 0
                          - !!perl/hash:RE_method 
                            min: 0
                            name: ws
                            nobind: 1
                            noquant: 1
                            rest: ''
                      - !!perl/hash:RE_sequence 
                        a: 0
                        alt: method_def_02 1
                        dba: method_def
                        i: 0
                        min: 12345
                        r: 1
                        s: 1
                        zyg: 
                          - !!perl/hash:RE_method 
                            a: 0
                            dba: method_def
                            i: 0
                            min: 12345
                            name: multisig
                            r: 1
                            rest: ''
                            s: 1
                          - !!perl/hash:RE_method 
                            min: 0
                            name: ws
                            nobind: 1
                            noquant: 1
                            rest: ''
                          - !!perl/hash:RE_quantified_atom 
                            atom: !!perl/hash:RE_method 
                              a: 0
                              dba: method_def
                              i: 0
                              min: 12345
                              name: trait
                              r: 1
                              rest: ''
                              s: 1
                            min: 0
                            quant: 
                              - "*"
                              - ":"
                              - ''
                              - 0
                          - !!perl/hash:RE_method 
                            min: 0
                            name: ws
                            nobind: 1
                            noquant: 1
                            rest: ''
                      - !!perl/hash:RE_sequence 
                        a: 0
                        alt: method_def_02 2
                        dba: subscript signature
                        i: 0
                        min: 24691
                        r: 1
                        s: 1
                        zyg: 
                          - !!perl/hash:RE_method 
                            a: 0
                            dba: method_def
                            i: 0
                            min: 12345
                            name: sigil
                            r: 1
                            rest: ''
                            s: 1
                          - !!perl/hash:RE_method 
                            min: 0
                            name: ws
                            nobind: 1
                            noquant: 1
                            rest: ''
                          - !!perl/hash:RE_string 
                            a: 0
                            dba: method_def
                            i: 0
                            min: 1
                            r: 1
                            s: 1
                            text: .
                          - !!perl/hash:RE_method 
                            min: 0
                            name: ws
                            nobind: 1
                            noquant: 1
                            rest: ''
                          - !!perl/hash:RE_method 
                            min: 0
                            name: ws
                            nobind: 1
                            noquant: 1
                            rest: ''
                          - !!perl/hash:RE_bracket 
                            decl: []

                            min: 12345
                            re: &105 !!perl/hash:RE_any 
                              a: 0
                              altname: method_def_04
                              dba: subscript signature
                              i: 0
                              min: 12345
                              name: method_def_04
                              r: 1
                              s: 1
                              zyg: 
                                - !!perl/hash:RE_sequence 
                                  a: 0
                                  alt: method_def_04 0
                                  dba: subscript signature
                                  i: 0
                                  min: 12347
                                  r: 1
                                  s: 1
                                  zyg: 
                                    - !!perl/hash:RE_string 
                                      a: 0
                                      dba: subscript signature
                                      i: 0
                                      min: 1
                                      r: 1
                                      s: 1
                                      text: (
                                    - !!perl/hash:RE_method 
                                      min: 0
                                      name: ws
                                      nobind: 1
                                      noquant: 1
                                      rest: ''
                                    - !!perl/hash:RE_meta 
                                      a: 0
                                      dba: subscript signature
                                      extra: local $::GOAL = ')'
                                      i: 0
                                      min: 0
                                      r: 1
                                      s: 1
                                      text: "::"
                                    - !!perl/hash:RE_method 
                                      a: 0
                                      dba: subscript signature
                                      i: 0
                                      min: 12345
                                      name: signature
                                      r: 1
                                      rest: ''
                                      s: 1
                                    - !!perl/hash:RE_bracket 
                                      decl: []

                                      min: 1
                                      re: !!perl/hash:RE_first 
                                        a: 0
                                        dba: subscript signature
                                        i: 0
                                        min: 1
                                        r: 1
                                        s: 1
                                        zyg: 
                                          - !!perl/hash:RE_string 
                                            a: 0
                                            dba: subscript signature
                                            i: 0
                                            min: 1
                                            r: 1
                                            s: 1
                                            text: )
                                          - !!perl/hash:RE_method 
                                            min: 0
                                            name: FAILGOAL
                                            nobind: 1
                                            rest: (')', 'subscript signature')
                                    - !!perl/hash:RE_method 
                                      min: 0
                                      name: ws
                                      nobind: 1
                                      noquant: 1
                                      rest: ''
                                - !!perl/hash:RE_sequence 
                                  a: 0
                                  alt: method_def_04 1
                                  dba: subscript signature
                                  i: 0
                                  min: 12347
                                  r: 1
                                  s: 1
                                  zyg: 
                                    - !!perl/hash:RE_string 
                                      a: 0
                                      dba: subscript signature
                                      i: 0
                                      min: 1
                                      r: 1
                                      s: 1
                                      text: "["
                                    - !!perl/hash:RE_method 
                                      min: 0
                                      name: ws
                                      nobind: 1
                                      noquant: 1
                                      rest: ''
                                    - !!perl/hash:RE_meta 
                                      a: 0
                                      dba: subscript signature
                                      extra: local $::GOAL = ']'
                                      i: 0
                                      min: 0
                                      r: 1
                                      s: 1
                                      text: "::"
                                    - !!perl/hash:RE_method 
                                      a: 0
                                      dba: subscript signature
                                      i: 0
                                      min: 12345
                                      name: signature
                                      r: 1
                                      rest: ''
                                      s: 1
                                    - !!perl/hash:RE_bracket 
                                      decl: []

                                      min: 1
                                      re: !!perl/hash:RE_first 
                                        a: 0
                                        dba: subscript signature
                                        i: 0
                                        min: 1
                                        r: 1
                                        s: 1
                                        zyg: 
                                          - !!perl/hash:RE_string 
                                            a: 0
                                            dba: subscript signature
                                            i: 0
                                            min: 1
                                            r: 1
                                            s: 1
                                            text: "]"
                                          - !!perl/hash:RE_method 
                                            min: 0
                                            name: FAILGOAL
                                            nobind: 1
                                            rest: (']', 'subscript signature')
                                    - !!perl/hash:RE_method 
                                      min: 0
                                      name: ws
                                      nobind: 1
                                      noquant: 1
                                      rest: ''
                                - !!perl/hash:RE_sequence 
                                  a: 0
                                  alt: method_def_04 2
                                  dba: subscript signature
                                  i: 0
                                  min: 12347
                                  r: 1
                                  s: 1
                                  zyg: 
                                    - !!perl/hash:RE_string 
                                      a: 0
                                      dba: subscript signature
                                      i: 0
                                      min: 1
                                      r: 1
                                      s: 1
                                      text: "{"
                                    - !!perl/hash:RE_method 
                                      min: 0
                                      name: ws
                                      nobind: 1
                                      noquant: 1
                                      rest: ''
                                    - !!perl/hash:RE_meta 
                                      a: 0
                                      dba: subscript signature
                                      extra: local $::GOAL = '}'
                                      i: 0
                                      min: 0
                                      r: 1
                                      s: 1
                                      text: "::"
                                    - !!perl/hash:RE_method 
                                      a: 0
                                      dba: subscript signature
                                      i: 0
                                      min: 12345
                                      name: signature
                                      r: 1
                                      rest: ''
                                      s: 1
                                    - !!perl/hash:RE_bracket 
                                      decl: []

                                      min: 1
                                      re: !!perl/hash:RE_first 
                                        a: 0
                                        dba: subscript signature
                                        i: 0
                                        min: 1
                                        r: 1
                                        s: 1
                                        zyg: 
                                          - !!perl/hash:RE_string 
                                            a: 0
                                            dba: subscript signature
                                            i: 0
                                            min: 1
                                            r: 1
                                            s: 1
                                            text: "}"
                                          - !!perl/hash:RE_method 
                                            min: 0
                                            name: FAILGOAL
                                            nobind: 1
                                            rest: ('}', 'subscript signature')
                                    - !!perl/hash:RE_method 
                                      min: 0
                                      name: ws
                                      nobind: 1
                                      noquant: 1
                                      rest: ''
                                - !!perl/hash:RE_sequence 
                                  a: 0
                                  alt: method_def_04 3
                                  dba: subscript signature
                                  i: 0
                                  min: 12345
                                  r: 1
                                  s: 1
                                  zyg: 
                                    - !!perl/hash:RE_assertion 
                                      assert: "?"
                                      min: 0
                                      re: !!perl/hash:RE_method_re 
                                        a: 0
                                        dba: subscript signature
                                        i: 0
                                        min: 0
                                        name: before
                                        nobind: 1
                                        r: 1
                                        re: !!perl/hash:RE 
                                          decl: []

                                          min: 1
                                          re: !!perl/hash:RE_string 
                                            a: 0
                                            dba: subscript signature
                                            i: 0
                                            min: 1
                                            r: 1
                                            s: 1
                                            text: <
                                        s: 1
                                    - !!perl/hash:RE_method 
                                      min: 0
                                      name: ws
                                      nobind: 1
                                      noquant: 1
                                      rest: ''
                                    - !!perl/hash:RE_method 
                                      a: 0
                                      dba: subscript signature
                                      i: 0
                                      min: 12345
                                      name: postcircumfix
                                      r: 1
                                      rest: ''
                                      s: 1
                                    - !!perl/hash:RE_method 
                                      min: 0
                                      name: ws
                                      nobind: 1
                                      noquant: 1
                                      rest: ''
                          - !!perl/hash:RE_method 
                            min: 0
                            name: ws
                            nobind: 1
                            noquant: 1
                            rest: ''
                          - !!perl/hash:RE_quantified_atom 
                            atom: !!perl/hash:RE_method 
                              a: 0
                              dba: subscript signature
                              i: 0
                              min: 12345
                              name: trait
                              r: 1
                              rest: ''
                              s: 1
                            min: 0
                            quant: 
                              - "*"
                              - ":"
                              - ''
                              - 0
                          - !!perl/hash:RE_method 
                            min: 0
                            name: ws
                            nobind: 1
                            noquant: 1
                            rest: ''
                      - !!perl/hash:RE_sequence 
                        a: 0
                        alt: method_def_02 3
                        dba: subscript signature
                        i: 0
                        min: 0
                        r: 1
                        s: 1
                        zyg: 
                          - !!perl/hash:RE_assertion 
                            assert: "?"
                            min: 0
                            re: !!perl/hash:RE_noop 
                              a: 0
                              dba: subscript signature
                              i: 0
                              min: 0
                              nobind: 1
                              r: 1
                              s: 1
                          - !!perl/hash:RE_method 
                            min: 0
                            name: ws
                            nobind: 1
                            noquant: 1
                            rest: ''
                - !!perl/hash:RE_method 
                  min: 0
                  name: ws
                  nobind: 1
                  noquant: 1
                  rest: ''
                - !!perl/hash:RE_method 
                  a: 0
                  dba: method_def
                  i: 0
                  min: 12345
                  name: blockoid
                  r: 1
                  rest: ''
                  s: 1
          - !!perl/hash:RE_method 
            min: 0
            name: ws
            nobind: 1
            noquant: 1
            rest: ''
      - !!perl/hash:RE_sequence 
        a: 0
        dba: method_def
        i: 0
        min: 0
        r: 1
        s: 1
        zyg: 
          - !!perl/hash:RE_method 
            min: 0
            name: ws
            nobind: 1
            noquant: 1
            rest: ''
          - !!perl/hash:RE_method 
            min: 0
            name: panic
            nobind: 1
            rest: ("Malformed method")
          - !!perl/hash:RE_method 
            min: 0
            name: ws
            nobind: 1
            noquant: 1
            rest: ''
method_def_02: *63
method_def_03: *2
method_def_04: *105
methodop: !!perl/hash:RE 
  decl: []

  kind: token
  min: 12345
  pkg: ~
  re: !!perl/hash:RE_sequence 
    a: 0
    dba: method arguments
    i: 0
    min: 12345
    r: 1
    s: 0
    zyg: 
      - !!perl/hash:RE_bracket 
        decl: []

        min: 12345
        re: &74 !!perl/hash:RE_any 
          a: 0
          altname: methodop_01
          dba: methodop
          i: 0
          min: 12345
          name: methodop_01
          r: 1
          s: 0
          zyg: 
            - !!perl/hash:RE_method 
              a: 0
              alt: methodop_01 0
              dba: methodop
              i: 0
              min: 12345
              name: longname
              r: 1
              rest: ''
              s: 0
            - !!perl/hash:RE_sequence 
              a: 0
              alt: methodop_01 1
              dba: methodop
              i: 0
              min: 12345
              r: 1
              s: 0
              zyg: 
                - !!perl/hash:RE_assertion 
                  assert: "?"
                  min: 0
                  re: !!perl/hash:RE_method_re 
                    a: 0
                    dba: methodop
                    i: 0
                    min: 0
                    name: before
                    nobind: 1
                    r: 1
                    re: !!perl/hash:RE 
                      decl: []

                      min: 1
                      re: &116 !!perl/hash:RE_any 
                        a: 0
                        altname: methodop_02
                        dba: methodop
                        i: 0
                        min: 1
                        name: methodop_02
                        r: 1
                        s: 0
                        zyg: 
                          - !!perl/hash:RE_string 
                            a: 0
                            alt: methodop_02 0
                            dba: methodop
                            i: 0
                            min: 1
                            r: 1
                            s: 0
                            text: $
                          - !!perl/hash:RE_string 
                            a: 0
                            alt: methodop_02 1
                            dba: methodop
                            i: 0
                            min: 1
                            r: 1
                            s: 0
                            text: "@"
                          - !!perl/hash:RE_string 
                            a: 0
                            alt: methodop_02 2
                            dba: methodop
                            i: 0
                            min: 1
                            r: 1
                            s: 0
                            text: "&"
                    s: 0
                - !!perl/hash:RE_method 
                  a: 0
                  dba: methodop
                  i: 0
                  min: 12345
                  name: variable
                  r: 1
                  rest: ''
                  s: 0
                - !!perl/hash:RE_block 
                  a: 0
                  context: void
                  dba: methodop
                  i: 0
                  min: 0
                  r: 1
                  s: 0
                  text: " $*VAR = $<variable> "
            - !!perl/hash:RE_sequence 
              a: 0
              alt: methodop_01 2
              dba: methodop
              i: 0
              min: 12345
              r: 1
              s: 0
              zyg: 
                - !!perl/hash:RE_assertion 
                  assert: "?"
                  min: 0
                  re: !!perl/hash:RE_method_re 
                    a: 0
                    dba: methodop
                    i: 0
                    min: 0
                    name: before
                    nobind: 1
                    r: 1
                    re: !!perl/hash:RE 
                      decl: []

                      min: 1
                      re: !!perl/hash:RE_cclass 
                        a: 0
                        dba: methodop
                        i: 0
                        min: 1
                        r: 1
                        s: 0
                        text: "[ ' \" ]"
                    s: 0
                - !!perl/hash:RE_bracket 
                  decl: []

                  min: 0
                  re: !!perl/hash:RE_first 
                    a: 0
                    dba: methodop
                    i: 0
                    min: 0
                    r: 1
                    s: 0
                    zyg: 
                      - !!perl/hash:RE_assertion 
                        assert: "!"
                        min: 0
                        re: !!perl/hash:RE_block 
                          a: 0
                          context: bool
                          dba: methodop
                          i: 0
                          min: 0
                          nobind: 1
                          r: 1
                          s: 0
                          text: $*QSIGIL
                      - !!perl/hash:RE_assertion 
                        assert: "!"
                        min: 0
                        re: !!perl/hash:RE_method_re 
                          a: 0
                          dba: methodop
                          i: 0
                          min: 0
                          name: before
                          nobind: 1
                          r: 1
                          re: !!perl/hash:RE 
                            decl: []

                            min: 2
                            re: !!perl/hash:RE_sequence 
                              a: 0
                              dba: methodop
                              i: 0
                              min: 2
                              r: 1
                              s: 0
                              zyg: 
                                - !!perl/hash:RE_string 
                                  a: 0
                                  dba: methodop
                                  i: 0
                                  min: 1
                                  r: 1
                                  s: 0
                                  text: "\""
                                - !!perl/hash:RE_quantified_atom 
                                  atom: !!perl/hash:RE_cclass 
                                    a: 0
                                    dba: methodop
                                    i: 0
                                    min: 1
                                    r: 1
                                    s: 0
                                    text: -["]
                                  min: 0
                                  quant: 
                                    - "*"
                                    - "?"
                                    - ''
                                    - 0
                                - !!perl/hash:RE_meta 
                                  a: 0
                                  dba: methodop
                                  i: 0
                                  min: 1
                                  r: 1
                                  s: 0
                                  text: \s
                          s: 0
                - !!perl/hash:RE_method 
                  a: 0
                  dba: methodop
                  i: 0
                  min: 12345
                  name: quote
                  r: 1
                  rest: ''
                  s: 0
                - !!perl/hash:RE_block 
                  a: 0
                  context: void
                  dba: methodop
                  i: 0
                  min: 0
                  r: 1
                  s: 0
                  text: " my $t = $<quote><nibble>.Str; $t ~~ /\\W/ or $t ~~ /^(WHO|WHAT|WHERE|WHEN|WHY|HOW)$/ or $¢.worry(\"Useless use of quotes\") "
      - !!perl/hash:RE_quantified_atom 
        atom: !!perl/hash:RE_method 
          a: 0
          dba: methodop
          i: 0
          min: 12345
          name: unsp
          nobind: 1
          r: 1
          rest: ''
          s: 0
        min: 0
        quant: 
          - "?"
          - ":"
          - ''
          - 0
      - !!perl/hash:RE_quantified_atom 
        atom: !!perl/hash:RE_bracket 
          decl: []

          min: 12345
          re: &88 !!perl/hash:RE_any 
            a: 0
            altname: methodop_07
            dba: method arguments
            i: 0
            min: 12345
            name: methodop_07
            r: 1
            s: 0
            zyg: 
              - !!perl/hash:RE_sequence 
                a: 0
                alt: methodop_07 0
                dba: method arguments
                i: 0
                min: 12346
                r: 1
                s: 0
                zyg: 
                  - !!perl/hash:RE_string 
                    a: 0
                    dba: method arguments
                    i: 0
                    min: 1
                    r: 1
                    s: 0
                    text: ":"
                  - !!perl/hash:RE_assertion 
                    assert: "?"
                    min: 0
                    re: !!perl/hash:RE_method_re 
                      a: 0
                      dba: method arguments
                      i: 0
                      min: 0
                      name: before
                      nobind: 1
                      r: 1
                      re: !!perl/hash:RE 
                        decl: []

                        min: 1
                        re: !!perl/hash:RE_meta 
                          a: 0
                          dba: method arguments
                          i: 0
                          min: 1
                          r: 1
                          s: 0
                          text: \s
                      s: 0
                  - !!perl/hash:RE_assertion 
                    assert: "!"
                    min: 0
                    re: !!perl/hash:RE_block 
                      a: 0
                      context: bool
                      dba: method arguments
                      i: 0
                      min: 0
                      nobind: 1
                      r: 1
                      s: 0
                      text: " $*QSIGIL "
                  - !!perl/hash:RE_method 
                    a: 0
                    dba: method arguments
                    i: 0
                    min: 12345
                    name: arglist
                    r: 1
                    rest: ''
                    s: 0
              - !!perl/hash:RE_sequence 
                a: 0
                alt: methodop_07 1
                dba: method arguments
                i: 0
                min: 12345
                r: 1
                s: 0
                zyg: 
                  - !!perl/hash:RE_assertion 
                    assert: "?"
                    min: 0
                    re: !!perl/hash:RE_cclass 
                      a: 0
                      dba: method arguments
                      i: 0
                      min: 1
                      nobind: 1
                      r: 1
                      s: 0
                      text: "[\\\\(]"
                  - !!perl/hash:RE_method 
                    a: 0
                    dba: method arguments
                    i: 0
                    min: 12345
                    name: args
                    r: 1
                    rest: ''
                    s: 0
        min: 0
        quant: 
          - "?"
          - ":"
          - ''
          - 0
methodop_01: *74
methodop_02: *116
methodop_07: *88
modifier_expr: !!perl/hash:RE 
  decl: []

  kind: rule
  min: 12345
  pkg: ~
  re: !!perl/hash:RE_sequence 
    a: 0
    dba: modifier_expr
    i: 0
    min: 12345
    r: 1
    s: 1
    zyg: 
      - !!perl/hash:RE_method 
        min: 0
        name: ws
        nobind: 1
        noquant: 1
        rest: ''
      - !!perl/hash:RE_method 
        a: 0
        dba: modifier_expr
        i: 0
        min: 12345
        name: EXPR
        r: 1
        rest: ''
        s: 1
      - !!perl/hash:RE_method 
        min: 0
        name: ws
        nobind: 1
        noquant: 1
        rest: ''
module_name__S_073normal: !!perl/hash:RE 
  decl: []

  kind: token
  min: 12345
  pkg: ~
  re: !!perl/hash:RE_sequence 
    a: 0
    dba: module_name__S_073normal
    i: 0
    min: 12345
    r: 1
    s: 0
    zyg: 
      - !!perl/hash:RE_method 
        a: 0
        dba: module_name__S_073normal
        i: 0
        min: 12345
        name: longname
        r: 1
        rest: ''
        s: 0
      - !!perl/hash:RE_quantified_atom 
        atom: !!perl/hash:RE_bracket 
          decl: []

          min: 12347
          re: !!perl/hash:RE_sequence 
            a: 0
            dba: generic role
            i: 0
            min: 12347
            r: 1
            s: 0
            zyg: 
              - !!perl/hash:RE_assertion 
                assert: "?"
                min: 0
                re: !!perl/hash:RE_method_re 
                  a: 0
                  dba: module_name__S_073normal
                  i: 0
                  min: 0
                  name: before
                  nobind: 1
                  r: 1
                  re: !!perl/hash:RE 
                    decl: []

                    min: 1
                    re: !!perl/hash:RE_string 
                      a: 0
                      dba: module_name__S_073normal
                      i: 0
                      min: 1
                      r: 1
                      s: 0
                      text: "["
                  s: 0
              - !!perl/hash:RE_string 
                a: 0
                dba: generic role
                i: 0
                min: 1
                r: 1
                s: 0
                text: "["
              - !!perl/hash:RE_meta 
                a: 0
                dba: generic role
                extra: "local $::GOAL = ']' "
                i: 0
                min: 0
                r: 1
                s: 0
                text: "::"
              - !!perl/hash:RE_method 
                a: 0
                dba: generic role
                i: 0
                min: 12345
                name: arglist
                r: 1
                rest: ''
                s: 0
              - !!perl/hash:RE_bracket 
                decl: []

                min: 1
                re: !!perl/hash:RE_first 
                  a: 0
                  dba: generic role
                  i: 0
                  min: 1
                  r: 1
                  s: 0
                  zyg: 
                    - !!perl/hash:RE_string 
                      a: 0
                      dba: generic role
                      i: 0
                      min: 1
                      r: 1
                      s: 0
                      text: "]"
                    - !!perl/hash:RE_method 
                      min: 0
                      name: FAILGOAL
                      nobind: 1
                      rest: (']' , 'generic role')
        min: 0
        quant: 
          - "?"
          - ":"
          - ''
          - 0
module_name__S_074deprecated: !!perl/hash:RE 
  decl: []

  kind: token
  min: 8
  pkg: ~
  re: !!perl/hash:RE_string 
    a: 0
    dba: module_name__S_074deprecated
    i: 0
    min: 8
    r: 1
    s: 0
    text: v6-alpha
morename: !!perl/hash:RE 
  decl: 
    - !!perl/hash:RE_decl 
      a: 0
      dba: morename
      i: 0
      max: 0
      min: 0
      r: 1
      s: 0
      text: my $QSIGIL is context<rw> = ''
  kind: token
  min: 2
  pkg: ~
  re: !!perl/hash:RE_sequence 
    a: 0
    dba: morename
    i: 0
    min: 2
    r: 1
    s: 0
    zyg: 
      - !!perl/hash:RE_string 
        a: 0
        dba: morename
        i: 0
        min: 2
        r: 1
        s: 0
        text: "::"
      - !!perl/hash:RE_quantified_atom 
        atom: !!perl/hash:RE_bracket 
          decl: []

          min: 12345
          re: !!perl/hash:RE_sequence 
            a: 0
            dba: morename
            i: 0
            min: 12345
            r: 1
            s: 0
            zyg: 
              - !!perl/hash:RE_assertion 
                assert: "?"
                min: 0
                re: !!perl/hash:RE_method_re 
                  a: 0
                  dba: morename
                  i: 0
                  min: 0
                  name: before
                  nobind: 1
                  r: 1
                  re: !!perl/hash:RE 
                    decl: []

                    min: 1
                    re: &125 !!perl/hash:RE_any 
                      a: 0
                      altname: morename_02
                      dba: morename
                      i: 0
                      min: 1
                      name: morename_02
                      r: 1
                      s: 0
                      zyg: 
                        - !!perl/hash:RE_string 
                          a: 0
                          alt: morename_02 0
                          dba: morename
                          i: 0
                          min: 1
                          r: 1
                          s: 0
                          text: (
                        - !!perl/hash:RE_method 
                          a: 0
                          alt: morename_02 1
                          dba: morename
                          i: 0
                          min: 12345
                          name: alpha
                          r: 1
                          rest: ''
                          s: 0
                  s: 0
              - !!perl/hash:RE_bracket 
                decl: []

                min: 12345
                re: &126 !!perl/hash:RE_any 
                  a: 0
                  altname: morename_03
                  dba: indirect name
                  i: 0
                  min: 12345
                  name: morename_03
                  r: 1
                  s: 0
                  zyg: 
                    - !!perl/hash:RE_method 
                      a: 0
                      alt: morename_03 0
                      dba: morename
                      i: 0
                      min: 12345
                      name: identifier
                      r: 1
                      rest: ''
                      s: 0
                    - !!perl/hash:RE_sequence 
                      a: 0
                      alt: morename_03 1
                      dba: indirect name
                      i: 0
                      min: 12347
                      r: 1
                      s: 0
                      zyg: 
                        - !!perl/hash:RE_string 
                          a: 0
                          dba: indirect name
                          i: 0
                          min: 1
                          r: 1
                          s: 0
                          text: (
                        - !!perl/hash:RE_meta 
                          a: 0
                          dba: indirect name
                          extra: "local $::GOAL = ')' "
                          i: 0
                          min: 0
                          r: 1
                          s: 0
                          text: "::"
                        - !!perl/hash:RE_method 
                          a: 0
                          dba: indirect name
                          i: 0
                          min: 12345
                          name: EXPR
                          r: 1
                          rest: ''
                          s: 0
                        - !!perl/hash:RE_bracket 
                          decl: []

                          min: 1
                          re: !!perl/hash:RE_first 
                            a: 0
                            dba: indirect name
                            i: 0
                            min: 1
                            r: 1
                            s: 0
                            zyg: 
                              - !!perl/hash:RE_string 
                                a: 0
                                dba: indirect name
                                i: 0
                                min: 1
                                r: 1
                                s: 0
                                text: )
                              - !!perl/hash:RE_method 
                                min: 0
                                name: FAILGOAL
                                nobind: 1
                                rest: (')' , 'indirect name')
        min: 0
        quant: 
          - "?"
          - ":"
          - ''
          - 0
morename_02: *125
morename_03: *126
multi_declarator__S_093multi: !!perl/hash:RE 
  decl: 
    - !!perl/hash:RE_decl 
      a: 0
      dba: multi_declarator__S_093multi
      i: 0
      max: 0
      min: 0
      r: 1
      s: 0
      text: my $MULTINESS is context = 'multi'
  kind: token
  min: 37035
  pkg: ~
  re: !!perl/hash:RE_sequence 
    a: 0
    dba: multi_declarator__S_093multi
    i: 0
    min: 37035
    r: 1
    s: 0
    zyg: 
      - !!perl/hash:RE_method 
        a: 0
        dba: multi_declarator__S_093multi
        endsym: spacey
        i: 0
        min: 12345
        name: sym
        r: 1
        rest: ''
        s: 0
        sym: multi
      - !!perl/hash:RE_method 
        a: 0
        dba: multi_declarator__S_093multi
        i: 0
        min: 12345
        name: spacey
        nobind: 1
        r: 1
        rest: ''
        s: 0
      - !!perl/hash:RE_method 
        a: 0
        dba: multi_declarator__S_093multi
        i: 0
        min: 12345
        name: ws
        nobind: 1
        r: 1
        rest: ''
        s: 0
      - !!perl/hash:RE_bracket 
        decl: []

        min: 0
        re: !!perl/hash:RE_first 
          a: 0
          dba: multi_declarator__S_093multi
          i: 0
          min: 0
          r: 1
          s: 0
          zyg: 
            - !!perl/hash:RE_method 
              a: 0
              dba: multi_declarator__S_093multi
              i: 0
              min: 12345
              name: declarator
              r: 1
              rest: ''
              s: 0
            - !!perl/hash:RE_method 
              a: 0
              dba: multi_declarator__S_093multi
              i: 0
              min: 12345
              name: routine_def
              r: 1
              rest: ''
              s: 0
            - !!perl/hash:RE_method 
              min: 0
              name: panic
              nobind: 1
              rest: ('Malformed multi')
multi_declarator__S_094proto: !!perl/hash:RE 
  decl: 
    - !!perl/hash:RE_decl 
      a: 0
      dba: multi_declarator__S_094proto
      i: 0
      max: 0
      min: 0
      r: 1
      s: 0
      text: my $MULTINESS is context = 'proto'
  kind: token
  min: 37035
  pkg: ~
  re: !!perl/hash:RE_sequence 
    a: 0
    dba: multi_declarator__S_094proto
    i: 0
    min: 37035
    r: 1
    s: 0
    zyg: 
      - !!perl/hash:RE_method 
        a: 0
        dba: multi_declarator__S_094proto
        endsym: spacey
        i: 0
        min: 12345
        name: sym
        r: 1
        rest: ''
        s: 0
        sym: proto
      - !!perl/hash:RE_method 
        a: 0
        dba: multi_declarator__S_094proto
        i: 0
        min: 12345
        name: spacey
        nobind: 1
        r: 1
        rest: ''
        s: 0
      - !!perl/hash:RE_method 
        a: 0
        dba: multi_declarator__S_094proto
        i: 0
        min: 12345
        name: ws
        nobind: 1
        r: 1
        rest: ''
        s: 0
      - !!perl/hash:RE_bracket 
        decl: []

        min: 0
        re: !!perl/hash:RE_first 
          a: 0
          dba: multi_declarator__S_094proto
          i: 0
          min: 0
          r: 1
          s: 0
          zyg: 
            - !!perl/hash:RE_method 
              a: 0
              dba: multi_declarator__S_094proto
              i: 0
              min: 12345
              name: declarator
              r: 1
              rest: ''
              s: 0
            - !!perl/hash:RE_method 
              a: 0
              dba: multi_declarator__S_094proto
              i: 0
              min: 12345
              name: routine_def
              r: 1
              rest: ''
              s: 0
            - !!perl/hash:RE_method 
              min: 0
              name: panic
              nobind: 1
              rest: ('Malformed proto')
multi_declarator__S_095only: !!perl/hash:RE 
  decl: 
    - !!perl/hash:RE_decl 
      a: 0
      dba: multi_declarator__S_095only
      i: 0
      max: 0
      min: 0
      r: 1
      s: 0
      text: my $MULTINESS is context = 'only'
  kind: token
  min: 37035
  pkg: ~
  re: !!perl/hash:RE_sequence 
    a: 0
    dba: multi_declarator__S_095only
    i: 0
    min: 37035
    r: 1
    s: 0
    zyg: 
      - !!perl/hash:RE_method 
        a: 0
        dba: multi_declarator__S_095only
        endsym: spacey
        i: 0
        min: 12345
        name: sym
        r: 1
        rest: ''
        s: 0
        sym: only
      - !!perl/hash:RE_method 
        a: 0
        dba: multi_declarator__S_095only
        i: 0
        min: 12345
        name: spacey
        nobind: 1
        r: 1
        rest: ''
        s: 0
      - !!perl/hash:RE_method 
        a: 0
        dba: multi_declarator__S_095only
        i: 0
        min: 12345
        name: ws
        nobind: 1
        r: 1
        rest: ''
        s: 0
      - !!perl/hash:RE_bracket 
        decl: []

        min: 0
        re: !!perl/hash:RE_first 
          a: 0
          dba: multi_declarator__S_095only
          i: 0
          min: 0
          r: 1
          s: 0
          zyg: 
            - !!perl/hash:RE_method 
              a: 0
              dba: multi_declarator__S_095only
              i: 0
              min: 12345
              name: declarator
              r: 1
              rest: ''
              s: 0
            - !!perl/hash:RE_method 
              a: 0
              dba: multi_declarator__S_095only
              i: 0
              min: 12345
              name: routine_def
              r: 1
              rest: ''
              s: 0
            - !!perl/hash:RE_method 
              min: 0
              name: panic
              nobind: 1
              rest: ('Malformed only')
multi_declarator__S_096null: !!perl/hash:RE 
  decl: 
    - !!perl/hash:RE_decl 
      a: 0
      dba: multi_declarator__S_096null
      i: 0
      max: 0
      min: 0
      r: 1
      s: 0
      text: my $MULTINESS is context = ''
  kind: token
  min: 12345
  pkg: ~
  re: !!perl/hash:RE_method 
    a: 0
    dba: multi_declarator__S_096null
    i: 0
    min: 12345
    name: declarator
    r: 1
    rest: ''
    s: 0
multisig: !!perl/hash:RE 
  decl: []

  kind: rule
  min: 12347
  pkg: ~
  re: !!perl/hash:RE_sequence 
    a: 0
    dba: signature
    i: 0
    min: 12347
    r: 1
    s: 1
    zyg: 
      - !!perl/hash:RE_method 
        min: 0
        name: ws
        nobind: 1
        noquant: 1
        rest: ''
      - !!perl/hash:RE_method 
        min: 0
        name: ws
        nobind: 1
        noquant: 1
        rest: ''
      - !!perl/hash:RE_quantified_atom 
        atom: !!perl/hash:RE_bracket 
          decl: []

          min: 12347
          re: !!perl/hash:RE_sequence 
            a: 0
            dba: signature
            i: 0
            min: 12347
            r: 1
            s: 1
            zyg: 
              - !!perl/hash:RE_method 
                min: 0
                name: ws
                nobind: 1
                noquant: 1
                rest: ''
              - !!perl/hash:RE_quantified_atom 
                atom: !!perl/hash:RE_string 
                  a: 0
                  dba: signature
                  i: 0
                  min: 1
                  r: 1
                  s: 1
                  text: ":"
                min: 0
                quant: 
                  - "?"
                  - ":"
                  - ''
                  - 0
              - !!perl/hash:RE_string 
                a: 0
                dba: signature
                i: 0
                min: 1
                r: 1
                s: 1
                text: (
              - !!perl/hash:RE_method 
                min: 0
                name: ws
                nobind: 1
                noquant: 1
                rest: ''
              - !!perl/hash:RE_meta 
                a: 0
                dba: signature
                extra: local $::GOAL = ')'
                i: 0
                min: 0
                r: 1
                s: 1
                text: "::"
              - !!perl/hash:RE_method 
                a: 0
                dba: signature
                i: 0
                min: 12345
                name: signature
                r: 1
                rest: ''
                s: 1
              - !!perl/hash:RE_bracket 
                decl: []

                min: 1
                re: !!perl/hash:RE_first 
                  a: 0
                  dba: signature
                  i: 0
                  min: 1
                  r: 1
                  s: 1
                  zyg: 
                    - !!perl/hash:RE_string 
                      a: 0
                      dba: signature
                      i: 0
                      min: 1
                      r: 1
                      s: 1
                      text: )
                    - !!perl/hash:RE_method 
                      min: 0
                      name: FAILGOAL
                      nobind: 1
                      rest: (')', 'signature')
              - !!perl/hash:RE_method 
                min: 0
                name: ws
                nobind: 1
                noquant: 1
                rest: ''
        min: 12347
        quant: 
          - "**"
          - ":"
          - !!perl/hash:RE_string 
            a: 0
            dba: signature
            i: 0
            min: 1
            r: 1
            s: 1
            text: "|"
          - 1
      - !!perl/hash:RE_method 
        min: 0
        name: ws
        nobind: 1
        noquant: 1
        rest: ''
name: !!perl/hash:RE 
  decl: []

  kind: token
  min: 12345
  pkg: ~
  re: !!perl/hash:RE_bracket 
    decl: []

    min: 12345
    re: &76 !!perl/hash:RE_any 
      a: 0
      altname: name_01
      dba: name
      i: 0
      min: 12345
      name: name_01
      r: 1
      s: 0
      zyg: 
        - !!perl/hash:RE_sequence 
          a: 0
          alt: name_01 0
          dba: name
          i: 0
          min: 12345
          r: 1
          s: 0
          zyg: 
            - !!perl/hash:RE_method 
              a: 0
              dba: name
              i: 0
              min: 12345
              name: identifier
              r: 1
              rest: ''
              s: 0
            - !!perl/hash:RE_quantified_atom 
              atom: !!perl/hash:RE_method 
                a: 0
                dba: name
                i: 0
                min: 12345
                name: morename
                r: 1
                rest: ''
                s: 0
              min: 0
              quant: 
                - "*"
                - ":"
                - ''
                - 0
        - !!perl/hash:RE_quantified_atom 
          alt: name_01 1
          atom: !!perl/hash:RE_method 
            a: 0
            dba: name
            i: 0
            min: 12345
            name: morename
            r: 1
            rest: ''
            s: 0
          min: 12345
          quant: 
            - +
            - ":"
            - ''
            - 1
name_01: *76
named_param: !!perl/hash:RE 
  decl: 
    - !!perl/hash:RE_decl 
      a: 0
      dba: named_param
      i: 0
      max: 0
      min: 0
      r: 1
      s: 0
      text: my $GOAL is context = ')'
  kind: token
  min: 12346
  pkg: ~
  re: !!perl/hash:RE_sequence 
    a: 0
    dba: named_param
    i: 0
    min: 12346
    r: 1
    s: 0
    zyg: 
      - !!perl/hash:RE_string 
        a: 0
        dba: named_param
        i: 0
        min: 1
        r: 1
        s: 0
        text: ":"
      - !!perl/hash:RE_bracket 
        decl: []

        min: 12345
        re: &26 !!perl/hash:RE_any 
          a: 0
          altname: named_param_01
          dba: named_param
          i: 0
          min: 12345
          name: named_param_01
          r: 1
          s: 0
          zyg: 
            - !!perl/hash:RE_sequence 
              a: 0
              alt: named_param_01 0
              dba: named_param
              i: 0
              min: 37036
              r: 1
              s: 0
              zyg: 
                - !!perl/hash:RE_bindnamed 
                  a: 0
                  atom: !!perl/hash:RE_method 
                    a: 0
                    dba: named_param
                    i: 0
                    min: 12345
                    name: identifier
                    nobind: 1
                    r: 1
                    rest: ''
                    s: 0
                  dba: named_param
                  i: 0
                  min: 12345
                  r: 1
                  s: 0
                  var: name
                - !!perl/hash:RE_string 
                  a: 0
                  dba: named_param
                  i: 0
                  min: 1
                  r: 1
                  s: 0
                  text: (
                - !!perl/hash:RE_method 
                  a: 0
                  dba: named_param
                  i: 0
                  min: 12345
                  name: ws
                  nobind: 1
                  r: 1
                  rest: ''
                  s: 0
                - !!perl/hash:RE_bracket 
                  decl: []

                  min: 12345
                  re: &94 !!perl/hash:RE_any 
                    a: 0
                    altname: named_param_02
                    dba: named_param
                    i: 0
                    min: 12345
                    name: named_param_02
                    r: 1
                    s: 0
                    zyg: 
                      - !!perl/hash:RE_method 
                        a: 0
                        alt: named_param_02 0
                        dba: named_param
                        i: 0
                        min: 12345
                        name: named_param
                        r: 1
                        rest: ''
                        s: 0
                      - !!perl/hash:RE_sequence 
                        a: 0
                        alt: named_param_02 1
                        dba: named_param
                        i: 0
                        min: 24690
                        r: 1
                        s: 0
                        zyg: 
                          - !!perl/hash:RE_method 
                            a: 0
                            dba: named_param
                            i: 0
                            min: 12345
                            name: param_var
                            r: 1
                            rest: ''
                            s: 0
                          - !!perl/hash:RE_method 
                            a: 0
                            dba: named_param
                            i: 0
                            min: 12345
                            name: ws
                            nobind: 1
                            r: 1
                            rest: ''
                            s: 0
                - !!perl/hash:RE_bracket 
                  decl: []

                  min: 0
                  re: !!perl/hash:RE_first 
                    a: 0
                    dba: named_param
                    i: 0
                    min: 0
                    r: 1
                    s: 0
                    zyg: 
                      - !!perl/hash:RE_string 
                        a: 0
                        dba: named_param
                        i: 0
                        min: 1
                        r: 1
                        s: 0
                        text: )
                      - !!perl/hash:RE_method 
                        min: 0
                        name: panic
                        nobind: 1
                        rest: ("Unable to parse named parameter; couldn't find right parenthesis")
            - !!perl/hash:RE_method 
              a: 0
              alt: named_param_01 1
              dba: named_param
              i: 0
              min: 12345
              name: param_var
              r: 1
              rest: ''
              s: 0
named_param_01: *26
named_param_02: *94
nibbler: !!perl/hash:RE 
  decl: 
    - !!perl/hash:RE_decl 
      a: 0
      dba: nibbler
      i: 0
      max: 0
      min: 0
      r: 1
      s: 0
      text: my $text = ''
    - !!perl/hash:RE_decl 
      a: 0
      dba: nibbler
      i: 0
      max: 0
      min: 0
      r: 1
      s: 0
      text: my $from = self.pos
    - !!perl/hash:RE_decl 
      a: 0
      dba: nibbler
      i: 0
      max: 0
      min: 0
      r: 1
      s: 0
      text: my $to = $from
    - !!perl/hash:RE_decl 
      a: 0
      dba: nibbler
      i: 0
      max: 0
      min: 0
      r: 1
      s: 0
      text: my @nibbles = ()
    - !!perl/hash:RE_decl 
      a: 0
      dba: nibbler
      i: 0
      max: 0
      min: 0
      r: 1
      s: 0
      text: my $multiline = 0
    - !!perl/hash:RE_decl 
      a: 0
      dba: nibbler
      i: 0
      max: 0
      min: 0
      r: 1
      s: 0
      text: my $nibble
  kind: token
  min: 0
  pkg: ~
  re: !!perl/hash:RE_sequence 
    a: 0
    dba: nibbler
    i: 0
    min: 0
    r: 1
    s: 0
    zyg: 
      - !!perl/hash:RE_block 
        a: 0
        context: void
        dba: nibbler
        i: 0
        min: 0
        r: 1
        s: 0
        text: " $<_from> = self.pos; "
      - !!perl/hash:RE_quantified_atom 
        atom: !!perl/hash:RE_bracket 
          decl: []

          min: 1
          re: !!perl/hash:RE_sequence 
            a: 0
            dba: nibbler
            i: 0
            min: 1
            r: 1
            s: 0
            zyg: 
              - !!perl/hash:RE_assertion 
                assert: "!"
                min: 0
                re: !!perl/hash:RE_method_re 
                  a: 0
                  dba: nibbler
                  i: 0
                  min: 0
                  name: before
                  nobind: 1
                  r: 1
                  re: !!perl/hash:RE 
                    decl: []

                    min: 12345
                    re: !!perl/hash:RE_method 
                      a: 0
                      dba: nibbler
                      i: 0
                      min: 12345
                      name: stopper
                      r: 1
                      rest: ''
                      s: 0
                  s: 0
              - !!perl/hash:RE_bracket 
                decl: []

                min: 1
                re: !!perl/hash:RE_first 
                  a: 0
                  dba: nibbler
                  i: 0
                  min: 1
                  r: 1
                  s: 0
                  zyg: 
                    - !!perl/hash:RE_sequence 
                      a: 0
                      dba: nibbler
                      i: 0
                      min: 37035
                      r: 1
                      s: 0
                      zyg: 
                        - !!perl/hash:RE_method 
                          a: 0
                          dba: nibbler
                          i: 0
                          min: 12345
                          name: starter
                          r: 1
                          rest: ''
                          s: 0
                        - !!perl/hash:RE_method 
                          a: 0
                          dba: nibbler
                          i: 0
                          min: 12345
                          name: nibbler
                          r: 1
                          rest: ''
                          s: 0
                        - !!perl/hash:RE_method 
                          a: 0
                          dba: nibbler
                          i: 0
                          min: 12345
                          name: stopper
                          r: 1
                          rest: ''
                          s: 0
                        - !!perl/hash:RE_block 
                          a: 0
                          context: void
                          dba: nibbler
                          i: 0
                          min: 0
                          r: 1
                          s: 0
                          text: "\n                            push @nibbles, $¢.cursor_singleton(TEXT => $text, _from => $from, _pos => $to );\n\n                            my $n = $<nibbler>[*-1]<nibbles>;\n                            my @n = @$n;\n\n                            push @nibbles, $<starter>;\n                            push @nibbles, @n;\n                            push @nibbles, $<stopper>;\n\n                            $text = '';\n                            $to = $from = $¢.pos;\n                        "
                    - !!perl/hash:RE_sequence 
                      a: 0
                      dba: nibbler
                      i: 0
                      min: 12345
                      r: 1
                      s: 0
                      zyg: 
                        - !!perl/hash:RE_method 
                          a: 0
                          dba: nibbler
                          i: 0
                          min: 12345
                          name: escape
                          r: 1
                          rest: ''
                          s: 0
                        - !!perl/hash:RE_block 
                          a: 0
                          context: void
                          dba: nibbler
                          i: 0
                          min: 0
                          r: 1
                          s: 0
                          text: "\n                            push @nibbles, $¢.cursor_singleton(TEXT => $text, _from => $from, _pos => $to ), $<escape>[*-1];\n                            $text = '';\n                            $to = $from = $¢.pos;\n                        "
                    - !!perl/hash:RE_sequence 
                      a: 0
                      dba: nibbler
                      i: 0
                      min: 1
                      r: 1
                      s: 0
                      zyg: 
                        - !!perl/hash:RE_meta 
                          a: 0
                          dba: nibbler
                          i: 0
                          min: 1
                          r: 1
                          s: 0
                          text: .
                        - !!perl/hash:RE_block 
                          a: 0
                          context: void
                          dba: nibbler
                          i: 0
                          min: 0
                          r: 1
                          s: 0
                          text: "\n                            my $ch = substr($*ORIG, $¢.pos-1, 1);\n                            $text ~= $ch;\n                            $to = $¢.pos;\n                            if $ch ~~ \"\\n\" {\n                                $multiline++;\n                            }\n                        "
        min: 0
        quant: 
          - "*"
          - ":"
          - ''
          - 0
      - !!perl/hash:RE_block 
        a: 0
        context: void
        dba: nibbler
        i: 0
        min: 0
        r: 1
        s: 0
        text: "\n        push @nibbles, $¢.cursor_singleton(TEXT => $text, _from => $from, _pos => $to );\n        $<nibbles> = \\@nibbles;\n        $<_pos> = $¢.pos;\n        $<nibbler> :delete;\n        $<escape> :delete;\n        $<starter> :delete;\n        $<stopper> :delete;\n        $*LAST_NIBBLE = $¢;\n        $*LAST_NIBBLE_MULTILINE = $¢ if $multiline;\n    "
nofun: !!perl/hash:RE 
  decl: []

  kind: token
  min: 0
  pkg: ~
  re: !!perl/hash:RE_assertion 
    assert: "!"
    min: 0
    re: !!perl/hash:RE_method_re 
      a: 0
      dba: nofun
      i: 0
      min: 0
      name: before
      nobind: 1
      r: 1
      re: !!perl/hash:RE 
        decl: []

        min: 1
        re: &45 !!perl/hash:RE_any 
          a: 0
          altname: nofun_01
          dba: nofun
          i: 0
          min: 1
          name: nofun_01
          r: 1
          s: 0
          zyg: 
            - !!perl/hash:RE_string 
              a: 0
              alt: nofun_01 0
              dba: nofun
              i: 0
              min: 1
              r: 1
              s: 0
              text: (
            - !!perl/hash:RE_string 
              a: 0
              alt: nofun_01 1
              dba: nofun
              i: 0
              min: 2
              r: 1
              s: 0
              text: .(
            - !!perl/hash:RE_string 
              a: 0
              alt: nofun_01 2
              dba: nofun
              i: 0
              min: 1
              r: 1
              s: 0
              text: \
            - !!perl/hash:RE_string 
              a: 0
              alt: nofun_01 3
              dba: nofun
              i: 0
              min: 1
              r: 1
              s: 0
              text: "'"
            - !!perl/hash:RE_string 
              a: 0
              alt: nofun_01 4
              dba: nofun
              i: 0
              min: 1
              r: 1
              s: 0
              text: "-"
      s: 0
nofun_01: *45
noun__S_112fatarrow: !!perl/hash:RE 
  decl: []

  kind: token
  min: 12345
  pkg: ~
  re: !!perl/hash:RE_method 
    a: 0
    dba: noun__S_112fatarrow
    i: 0
    min: 12345
    name: fatarrow
    r: 1
    rest: ''
    s: 0
noun__S_113variable: !!perl/hash:RE 
  decl: []

  kind: token
  min: 12345
  pkg: ~
  re: !!perl/hash:RE_sequence 
    a: 0
    dba: noun__S_113variable
    i: 0
    min: 12345
    r: 1
    s: 0
    zyg: 
      - !!perl/hash:RE_method 
        a: 0
        dba: noun__S_113variable
        i: 0
        min: 12345
        name: variable
        r: 1
        rest: ''
        s: 0
      - !!perl/hash:RE_block 
        a: 0
        context: void
        dba: noun__S_113variable
        i: 0
        min: 0
        r: 1
        s: 0
        text: " $*VAR = $<variable> "
noun__S_114package_declarator: !!perl/hash:RE 
  decl: []

  kind: token
  min: 12345
  pkg: ~
  re: !!perl/hash:RE_method 
    a: 0
    dba: noun__S_114package_declarator
    i: 0
    min: 12345
    name: package_declarator
    r: 1
    rest: ''
    s: 0
noun__S_115scope_declarator: !!perl/hash:RE 
  decl: []

  kind: token
  min: 12345
  pkg: ~
  re: !!perl/hash:RE_method 
    a: 0
    dba: noun__S_115scope_declarator
    i: 0
    min: 12345
    name: scope_declarator
    r: 1
    rest: ''
    s: 0
noun__S_116multi_declarator: !!perl/hash:RE 
  decl: []

  kind: token
  min: 12345
  pkg: ~
  re: !!perl/hash:RE_sequence 
    a: 0
    dba: noun__S_116multi_declarator
    i: 0
    min: 12345
    r: 1
    s: 0
    zyg: 
      - !!perl/hash:RE_assertion 
        assert: "?"
        min: 0
        re: !!perl/hash:RE_method_re 
          a: 0
          dba: noun__S_116multi_declarator
          i: 0
          min: 0
          name: before
          nobind: 1
          r: 1
          re: !!perl/hash:RE 
            decl: []

            min: 4
            re: &23 !!perl/hash:RE_any 
              a: 0
              altname: noun__S_116multi_declarator_01
              dba: noun__S_116multi_declarator
              i: 0
              min: 4
              name: noun__S_116multi_declarator_01
              r: 1
              s: 0
              zyg: 
                - !!perl/hash:RE_string 
                  a: 0
                  alt: noun__S_116multi_declarator_01 0
                  dba: noun__S_116multi_declarator
                  i: 0
                  min: 5
                  r: 1
                  s: 0
                  text: multi
                - !!perl/hash:RE_string 
                  a: 0
                  alt: noun__S_116multi_declarator_01 1
                  dba: noun__S_116multi_declarator
                  i: 0
                  min: 5
                  r: 1
                  s: 0
                  text: proto
                - !!perl/hash:RE_string 
                  a: 0
                  alt: noun__S_116multi_declarator_01 2
                  dba: noun__S_116multi_declarator
                  i: 0
                  min: 4
                  r: 1
                  s: 0
                  text: only
          s: 0
      - !!perl/hash:RE_method 
        a: 0
        dba: noun__S_116multi_declarator
        i: 0
        min: 12345
        name: multi_declarator
        r: 1
        rest: ''
        s: 0
noun__S_116multi_declarator_01: *23
noun__S_117routine_declarator: !!perl/hash:RE 
  decl: []

  kind: token
  min: 12345
  pkg: ~
  re: !!perl/hash:RE_method 
    a: 0
    dba: noun__S_117routine_declarator
    i: 0
    min: 12345
    name: routine_declarator
    r: 1
    rest: ''
    s: 0
noun__S_118regex_declarator: !!perl/hash:RE 
  decl: []

  kind: token
  min: 12345
  pkg: ~
  re: !!perl/hash:RE_method 
    a: 0
    dba: noun__S_118regex_declarator
    i: 0
    min: 12345
    name: regex_declarator
    r: 1
    rest: ''
    s: 0
noun__S_119type_declarator: !!perl/hash:RE 
  decl: []

  kind: token
  min: 12345
  pkg: ~
  re: !!perl/hash:RE_method 
    a: 0
    dba: noun__S_119type_declarator
    i: 0
    min: 12345
    name: type_declarator
    r: 1
    rest: ''
    s: 0
noun__S_120circumfix: !!perl/hash:RE 
  decl: []

  kind: token
  min: 12345
  pkg: ~
  re: !!perl/hash:RE_method 
    a: 0
    dba: noun__S_120circumfix
    i: 0
    min: 12345
    name: circumfix
    r: 1
    rest: ''
    s: 0
noun__S_121dotty: !!perl/hash:RE 
  decl: []

  kind: token
  min: 12345
  pkg: ~
  re: !!perl/hash:RE_method 
    a: 0
    dba: noun__S_121dotty
    i: 0
    min: 12345
    name: dotty
    r: 1
    rest: ''
    s: 0
noun__S_122value: !!perl/hash:RE 
  decl: []

  kind: token
  min: 12345
  pkg: ~
  re: !!perl/hash:RE_method 
    a: 0
    dba: noun__S_122value
    i: 0
    min: 12345
    name: value
    r: 1
    rest: ''
    s: 0
noun__S_123capterm: !!perl/hash:RE 
  decl: []

  kind: token
  min: 12345
  pkg: ~
  re: !!perl/hash:RE_method 
    a: 0
    dba: noun__S_123capterm
    i: 0
    min: 12345
    name: capterm
    r: 1
    rest: ''
    s: 0
noun__S_124sigterm: !!perl/hash:RE 
  decl: []

  kind: token
  min: 12345
  pkg: ~
  re: !!perl/hash:RE_method 
    a: 0
    dba: noun__S_124sigterm
    i: 0
    min: 12345
    name: sigterm
    r: 1
    rest: ''
    s: 0
noun__S_125term: !!perl/hash:RE 
  decl: []

  kind: token
  min: 12345
  pkg: ~
  re: !!perl/hash:RE_method 
    a: 0
    dba: noun__S_125term
    i: 0
    min: 12345
    name: term
    r: 1
    rest: ''
    s: 0
noun__S_126statement_prefix: !!perl/hash:RE 
  decl: []

  kind: token
  min: 12345
  pkg: ~
  re: !!perl/hash:RE_method 
    a: 0
    dba: noun__S_126statement_prefix
    i: 0
    min: 12345
    name: statement_prefix
    r: 1
    rest: ''
    s: 0
noun__S_127colonpair: !!perl/hash:RE 
  decl: []

  kind: token
  min: 24690
  pkg: ~
  re: !!perl/hash:RE_quantified_atom 
    atom: !!perl/hash:RE_bracket 
      decl: []

      min: 24690
      re: !!perl/hash:RE_sequence 
        a: 0
        dba: noun__S_127colonpair
        i: 0
        min: 24690
        r: 1
        s: 0
        zyg: 
          - !!perl/hash:RE_method 
            a: 0
            dba: noun__S_127colonpair
            i: 0
            min: 12345
            name: colonpair
            r: 1
            rest: ''
            s: 0
          - !!perl/hash:RE_method 
            a: 0
            dba: noun__S_127colonpair
            i: 0
            min: 12345
            name: ws
            nobind: 1
            r: 1
            rest: ''
            s: 0
    min: 24690
    quant: 
      - +
      - ":"
      - ''
      - 1
nullterm: !!perl/hash:RE 
  decl: []

  kind: token
  min: 0
  pkg: ~
  re: !!perl/hash:RE_assertion 
    assert: "?"
    min: 0
    re: !!perl/hash:RE_noop 
      a: 0
      dba: nullterm
      i: 0
      min: 0
      nobind: 1
      r: 1
      s: 0
nulltermish: !!perl/hash:RE 
  decl: []

  kind: token
  min: 0
  pkg: ~
  re: !!perl/hash:RE_bracket 
    decl: []

    min: 0
    re: &91 !!perl/hash:RE_any 
      a: 0
      altname: nulltermish_01
      dba: null term
      i: 0
      min: 0
      name: nulltermish_01
      r: 1
      s: 0
      zyg: 
        - !!perl/hash:RE_assertion 
          alt: nulltermish_01 0
          assert: "?"
          min: 0
          re: !!perl/hash:RE_method 
            a: 0
            dba: null term
            i: 0
            min: 12345
            name: stdstopper
            nobind: 1
            r: 1
            rest: ''
            s: 0
        - !!perl/hash:RE_sequence 
          a: 0
          alt: nulltermish_01 1
          dba: null term
          i: 0
          min: 12345
          r: 1
          s: 0
          zyg: 
            - !!perl/hash:RE_bindnamed 
              a: 0
              atom: !!perl/hash:RE_method 
                a: 0
                dba: null term
                i: 0
                min: 12345
                name: termish
                nobind: 1
                r: 1
                rest: ''
                s: 0
              dba: null term
              i: 0
              min: 12345
              r: 1
              s: 0
              var: noun
            - !!perl/hash:RE_block 
              a: 0
              context: void
              dba: null term
              i: 0
              min: 0
              r: 1
              s: 0
              text: "\n            $¢.<PRE>  = $<noun><PRE>:delete;\n            $¢.<POST> = $<noun><POST>:delete;\n            $¢.<~CAPS> = $<noun><~CAPS>;\n        "
        - !!perl/hash:RE_assertion 
          alt: nulltermish_01 2
          assert: "?"
          min: 0
          re: !!perl/hash:RE_noop 
            a: 0
            dba: null term
            i: 0
            min: 0
            nobind: 1
            r: 1
            s: 0
nulltermish_01: *91
number__S_189rational: !!perl/hash:RE 
  decl: []

  kind: token
  min: 24691
  pkg: ~
  re: !!perl/hash:RE_sequence 
    a: 0
    dba: number__S_189rational
    i: 0
    min: 24691
    r: 1
    s: 0
    zyg: 
      - !!perl/hash:RE_bindnamed 
        a: 0
        atom: !!perl/hash:RE_method 
          a: 0
          dba: number__S_189rational
          i: 0
          min: 12345
          name: integer
          nobind: 1
          r: 1
          rest: ''
          s: 0
        dba: number__S_189rational
        i: 0
        min: 12345
        r: 1
        s: 0
        var: nu
      - !!perl/hash:RE_string 
        a: 0
        dba: number__S_189rational
        i: 0
        min: 1
        r: 1
        s: 0
        text: /
      - !!perl/hash:RE_bindnamed 
        a: 0
        atom: !!perl/hash:RE_method 
          a: 0
          dba: number__S_189rational
          i: 0
          min: 12345
          name: integer
          nobind: 1
          r: 1
          rest: ''
          s: 0
        dba: number__S_189rational
        i: 0
        min: 12345
        r: 1
        s: 0
        var: de
number__S_190complex: !!perl/hash:RE 
  decl: []

  kind: token
  min: 12346
  pkg: ~
  re: &5 !!perl/hash:RE_any 
    a: 0
    altname: number__S_190complex_00
    dba: number__S_190complex
    i: 0
    min: 12346
    name: number__S_190complex_00
    r: 1
    s: 0
    zyg: 
      - !!perl/hash:RE_sequence 
        a: 0
        alt: number__S_190complex_00 0
        dba: number__S_190complex
        i: 0
        min: 24692
        r: 1
        s: 0
        zyg: 
          - !!perl/hash:RE_bindnamed 
            a: 0
            atom: !!perl/hash:RE_method 
              a: 0
              dba: number__S_190complex
              i: 0
              min: 12345
              name: numish
              nobind: 1
              r: 1
              rest: ''
              s: 0
            dba: number__S_190complex
            i: 0
            min: 12345
            r: 1
            s: 0
            var: re
          - !!perl/hash:RE_string 
            a: 0
            dba: number__S_190complex
            i: 0
            min: 1
            r: 1
            s: 0
            text: +
          - !!perl/hash:RE_bindnamed 
            a: 0
            atom: !!perl/hash:RE_method 
              a: 0
              dba: number__S_190complex
              i: 0
              min: 12345
              name: numish
              nobind: 1
              r: 1
              rest: ''
              s: 0
            dba: number__S_190complex
            i: 0
            min: 12345
            r: 1
            s: 0
            var: im
          - !!perl/hash:RE_quantified_atom 
            atom: !!perl/hash:RE_string 
              a: 0
              dba: number__S_190complex
              i: 0
              min: 1
              r: 1
              s: 0
              text: \
            min: 0
            quant: 
              - "?"
              - ":"
              - ''
              - 0
          - !!perl/hash:RE_string 
            a: 0
            dba: number__S_190complex
            i: 0
            min: 1
            r: 1
            s: 0
            text: i
      - !!perl/hash:RE_sequence 
        a: 0
        alt: number__S_190complex_00 1
        dba: number__S_190complex
        i: 0
        min: 12346
        r: 1
        s: 0
        zyg: 
          - !!perl/hash:RE_bindnamed 
            a: 0
            atom: !!perl/hash:RE_method 
              a: 0
              dba: number__S_190complex
              i: 0
              min: 12345
              name: numish
              nobind: 1
              r: 1
              rest: ''
              s: 0
            dba: number__S_190complex
            i: 0
            min: 12345
            r: 1
            s: 0
            var: im
          - !!perl/hash:RE_quantified_atom 
            atom: !!perl/hash:RE_string 
              a: 0
              dba: number__S_190complex
              i: 0
              min: 1
              r: 1
              s: 0
              text: \
            min: 0
            quant: 
              - "?"
              - ":"
              - ''
              - 0
          - !!perl/hash:RE_string 
            a: 0
            dba: number__S_190complex
            i: 0
            min: 1
            r: 1
            s: 0
            text: i
number__S_190complex_00: *5
number__S_191numish: !!perl/hash:RE 
  decl: []

  kind: token
  min: 12345
  pkg: ~
  re: !!perl/hash:RE_method 
    a: 0
    dba: number__S_191numish
    i: 0
    min: 12345
    name: numish
    r: 1
    rest: ''
    s: 0
numish: !!perl/hash:RE 
  decl: []

  kind: token
  min: 3
  pkg: ~
  re: !!perl/hash:RE_bracket 
    decl: []

    min: 3
    re: &137 !!perl/hash:RE_any 
      a: 0
      altname: numish_01
      dba: numish
      i: 0
      min: 3
      name: numish_01
      r: 1
      s: 0
      zyg: 
        - !!perl/hash:RE_method 
          a: 0
          alt: numish_01 0
          dba: numish
          i: 0
          min: 12345
          name: integer
          r: 1
          rest: ''
          s: 0
        - !!perl/hash:RE_method 
          a: 0
          alt: numish_01 1
          dba: numish
          i: 0
          min: 12345
          name: dec_number
          r: 1
          rest: ''
          s: 0
        - !!perl/hash:RE_method 
          a: 0
          alt: numish_01 2
          dba: numish
          i: 0
          min: 12345
          name: rad_number
          r: 1
          rest: ''
          s: 0
        - !!perl/hash:RE_sequence 
          a: 0
          alt: numish_01 3
          dba: numish
          i: 0
          min: 3
          r: 1
          s: 0
          zyg: 
            - !!perl/hash:RE_string 
              a: 0
              dba: numish
              i: 0
              min: 3
              r: 1
              s: 0
              text: NaN
            - !!perl/hash:RE_meta 
              a: 0
              dba: numish
              i: 0
              min: 0
              r: 1
              s: 0
              text: »
        - !!perl/hash:RE_sequence 
          a: 0
          alt: numish_01 4
          dba: numish
          i: 0
          min: 3
          r: 1
          s: 0
          zyg: 
            - !!perl/hash:RE_string 
              a: 0
              dba: numish
              i: 0
              min: 3
              r: 1
              s: 0
              text: Inf
            - !!perl/hash:RE_meta 
              a: 0
              dba: numish
              i: 0
              min: 0
              r: 1
              s: 0
              text: »
        - !!perl/hash:RE_sequence 
          a: 0
          alt: numish_01 5
          dba: numish
          i: 0
          min: 4
          r: 1
          s: 0
          zyg: 
            - !!perl/hash:RE_string 
              a: 0
              dba: numish
              i: 0
              min: 4
              r: 1
              s: 0
              text: +Inf
            - !!perl/hash:RE_meta 
              a: 0
              dba: numish
              i: 0
              min: 0
              r: 1
              s: 0
              text: »
        - !!perl/hash:RE_sequence 
          a: 0
          alt: numish_01 6
          dba: numish
          i: 0
          min: 4
          r: 1
          s: 0
          zyg: 
            - !!perl/hash:RE_string 
              a: 0
              dba: numish
              i: 0
              min: 4
              r: 1
              s: 0
              text: -Inf
            - !!perl/hash:RE_meta 
              a: 0
              dba: numish
              i: 0
              min: 0
              r: 1
              s: 0
              text: »
numish_01: *137
octint: !!perl/hash:RE 
  decl: []

  kind: token
  min: 1
  pkg: ~
  re: !!perl/hash:RE_sequence 
    a: 0
    dba: octint
    i: 0
    min: 1
    r: 1
    s: 0
    zyg: 
      - !!perl/hash:RE_quantified_atom 
        atom: !!perl/hash:RE_cclass 
          a: 0
          dba: octint
          i: 0
          min: 1
          r: 1
          s: 0
          text: "[ 0..7 ]"
        min: 1
        quant: 
          - +
          - ":"
          - ''
          - 1
      - !!perl/hash:RE_quantified_atom 
        atom: !!perl/hash:RE_bracket 
          decl: []

          min: 2
          re: !!perl/hash:RE_sequence 
            a: 0
            dba: octint
            i: 0
            min: 2
            r: 1
            s: 0
            zyg: 
              - !!perl/hash:RE_string 
                a: 0
                dba: octint
                i: 0
                min: 1
                r: 1
                s: 0
                text: _
              - !!perl/hash:RE_quantified_atom 
                atom: !!perl/hash:RE_cclass 
                  a: 0
                  dba: octint
                  i: 0
                  min: 1
                  r: 1
                  s: 0
                  text: "[ 0..7 ]"
                min: 1
                quant: 
                  - +
                  - ":"
                  - ''
                  - 1
        min: 0
        quant: 
          - "*"
          - ":"
          - ''
          - 0
octints: !!perl/hash:RE 
  decl: []

  kind: token
  min: 37035
  pkg: ~
  re: !!perl/hash:RE_quantified_atom 
    atom: !!perl/hash:RE_bracket 
      decl: []

      min: 37035
      re: !!perl/hash:RE_sequence 
        a: 0
        dba: octints
        i: 0
        min: 37035
        r: 1
        s: 0
        zyg: 
          - !!perl/hash:RE_method 
            a: 0
            dba: octints
            i: 0
            min: 12345
            name: ws
            nobind: 1
            r: 1
            rest: ''
            s: 0
          - !!perl/hash:RE_method 
            a: 0
            dba: octints
            i: 0
            min: 12345
            name: octint
            r: 1
            rest: ''
            s: 0
          - !!perl/hash:RE_method 
            a: 0
            dba: octints
            i: 0
            min: 12345
            name: ws
            nobind: 1
            r: 1
            rest: ''
            s: 0
    min: 37035
    quant: 
      - "**"
      - ":"
      - !!perl/hash:RE_string 
        a: 0
        dba: octints
        i: 0
        min: 1
        r: 1
        s: 0
        text: ","
      - 1
old_rx_mods: !!perl/hash:RE 
  decl: []

  kind: token
  min: 1
  pkg: ~
  re: !!perl/hash:RE_sequence 
    a: 0
    dba: old_rx_mods
    i: 0
    min: 1
    r: 1
    s: 0
    zyg: 
      - !!perl/hash:RE_assertion 
        assert: "!"
        min: 0
        re: !!perl/hash:RE_method_re 
          a: 0
          dba: old_rx_mods
          i: 0
          min: 0
          name: after
          nobind: 1
          r: 1
          re: !!perl/hash:RE 
            decl: []

            min: 1
            re: !!perl/hash:RE_meta 
              a: 0
              dba: old_rx_mods
              i: 0
              min: 1
              r: 1
              s: 0
              text: \s
          s: 0
      - !!perl/hash:RE_bindpos 
        atom: !!perl/hash:RE_paren 
          decl: []

          min: 1
          re: !!perl/hash:RE_quantified_atom 
            atom: !!perl/hash:RE_qw 
              a: 0
              dba: old_rx_mods
              i: 0
              min: 1
              r: 1
              s: 0
              text: < i g s m x c e >
            min: 1
            quant: 
              - +
              - ":"
              - ''
              - 1
        min: 1
        var: 0
      - !!perl/hash:RE_block 
        a: 0
        context: void
        dba: old_rx_mods
        i: 0
        min: 0
        r: 1
        s: 0
        text: "\n        given $0.Str {\n            $_ ~~ /i/ and $¢.worryobs('/i',':i');\n            $_ ~~ /g/ and $¢.worryobs('/g',':g');\n            $_ ~~ /s/ and $¢.worryobs('/s','^^ and $$ anchors');\n            $_ ~~ /m/ and $¢.worryobs('/m','. or \\N');\n            $_ ~~ /x/ and $¢.worryobs('/x','normal default whitespace');\n            $_ ~~ /c/ and $¢.worryobs('/c',':c or :p');\n            $_ ~~ /e/ and $¢.worryobs('/e','interpolated {...} or s{} = ... form');\n            $¢.obs('suffix regex modifiers','prefix adverbs');\n        }\n    "
old_tr_mods: !!perl/hash:RE 
  decl: []

  kind: token
  min: 1
  pkg: ~
  re: !!perl/hash:RE_sequence 
    a: 0
    dba: old_tr_mods
    i: 0
    min: 1
    r: 1
    s: 0
    zyg: 
      - !!perl/hash:RE_bindpos 
        atom: !!perl/hash:RE_paren 
          decl: []

          min: 1
          re: !!perl/hash:RE_quantified_atom 
            atom: !!perl/hash:RE_qw 
              a: 0
              dba: old_tr_mods
              i: 0
              min: 1
              r: 1
              s: 0
              text: < c d s ] >
            min: 1
            quant: 
              - +
              - ":"
              - ''
              - 1
        min: 1
        var: 0
      - !!perl/hash:RE_block 
        a: 0
        context: void
        dba: old_tr_mods
        i: 0
        min: 0
        r: 1
        s: 0
        text: "\n        given $0.Str {\n            $_ ~~ /c/ and $¢.worryobs('/c',':c');\n            $_ ~~ /d/ and $¢.worryobs('/g',':d');\n            $_ ~~ /s/ and $¢.worryobs('/s',':s');\n            $¢.obs('suffix transliteration modifiers','prefix adverbs');\n        }\n    "
opener: !!perl/hash:RE 
  decl: []

  kind: token
  min: 1
  pkg: ~
  re: !!perl/hash:RE_cclass 
    a: 0
    dba: opener
    i: 0
    min: 1
    r: 1
    s: 0
    text: "[\n\\x{0028}\n\\x{003C}\n\\x{005B}\n\\x{007B}\n\\x{00AB}\n\\x{0F3A}\n\\x{0F3C}\n\\x{169B}\n\\x{2018}\n\\x{201A}\n\\x{201B}\n\\x{201C}\n\\x{201E}\n\\x{201F}\n\\x{2039}\n\\x{2045}\n\\x{207D}\n\\x{208D}\n\\x{2208}\n\\x{2209}\n\\x{220A}\n\\x{2215}\n\\x{223C}\n\\x{2243}\n\\x{2252}\n\\x{2254}\n\\x{2264}\n\\x{2266}\n\\x{2268}\n\\x{226A}\n\\x{226E}\n\\x{2270}\n\\x{2272}\n\\x{2274}\n\\x{2276}\n\\x{2278}\n\\x{227A}\n\\x{227C}\n\\x{227E}\n\\x{2280}\n\\x{2282}\n\\x{2284}\n\\x{2286}\n\\x{2288}\n\\x{228A}\n\\x{228F}\n\\x{2291}\n\\x{2298}\n\\x{22A2}\n\\x{22A6}\n\\x{22A8}\n\\x{22A9}\n\\x{22AB}\n\\x{22B0}\n\\x{22B2}\n\\x{22B4}\n\\x{22B6}\n\\x{22C9}\n\\x{22CB}\n\\x{22D0}\n\\x{22D6}\n\\x{22D8}\n\\x{22DA}\n\\x{22DC}\n\\x{22DE}\n\\x{22E0}\n\\x{22E2}\n\\x{22E4}\n\\x{22E6}\n\\x{22E8}\n\\x{22EA}\n\\x{22EC}\n\\x{22F0}\n\\x{22F2}\n\\x{22F3}\n\\x{22F4}\n\\x{22F6}\n\\x{22F7}\n\\x{2308}\n\\x{230A}\n\\x{2329}\n\\x{23B4}\n\\x{2768}\n\\x{276A}\n\\x{276C}\n\\x{276E}\n\\x{2770}\n\\x{2772}\n\\x{2774}\n\\x{27C3}\n\\x{27C5}\n\\x{27D5}\n\\x{27DD}\n\\x{27E2}\n\\x{27E4}\n\\x{27E6}\n\\x{27E8}\n\\x{27EA}\n\\x{2983}\n\\x{2985}\n\\x{2987}\n\\x{2989}\n\\x{298B}\n\\x{298D}\n\\x{298F}\n\\x{2991}\n\\x{2993}\n\\x{2995}\n\\x{2997}\n\\x{29C0}\n\\x{29C4}\n\\x{29CF}\n\\x{29D1}\n\\x{29D4}\n\\x{29D8}\n\\x{29DA}\n\\x{29F8}\n\\x{29FC}\n\\x{2A2B}\n\\x{2A2D}\n\\x{2A34}\n\\x{2A3C}\n\\x{2A64}\n\\x{2A79}\n\\x{2A7D}\n\\x{2A7F}\n\\x{2A81}\n\\x{2A83}\n\\x{2A8B}\n\\x{2A91}\n\\x{2A93}\n\\x{2A95}\n\\x{2A97}\n\\x{2A99}\n\\x{2A9B}\n\\x{2AA1}\n\\x{2AA6}\n\\x{2AA8}\n\\x{2AAA}\n\\x{2AAC}\n\\x{2AAF}\n\\x{2AB3}\n\\x{2ABB}\n\\x{2ABD}\n\\x{2ABF}\n\\x{2AC1}\n\\x{2AC3}\n\\x{2AC5}\n\\x{2ACD}\n\\x{2ACF}\n\\x{2AD1}\n\\x{2AD3}\n\\x{2AD5}\n\\x{2AEC}\n\\x{2AF7}\n\\x{2AF9}\n\\x{2E02}\n\\x{2E04}\n\\x{2E09}\n\\x{2E0C}\n\\x{2E1C}\n\\x{2E20}\n\\x{3008}\n\\x{300A}\n\\x{300C}\n\\x{300E}\n\\x{3010}\n\\x{3014}\n\\x{3016}\n\\x{3018}\n\\x{301A}\n\\x{301D}\n\\x{FD3E}\n\\x{FE17}\n\\x{FE35}\n\\x{FE37}\n\\x{FE39}\n\\x{FE3B}\n\\x{FE3D}\n\\x{FE3F}\n\\x{FE41}\n\\x{FE43}\n\\x{FE47}\n\\x{FE59}\n\\x{FE5B}\n\\x{FE5D}\n\\x{FF08}\n\\x{FF1C}\n\\x{FF3B}\n\\x{FF5B}\n\\x{FF5F}\n\\x{FF62}\n  ]"
package_declarator__S_083class: !!perl/hash:RE 
  decl: 
    - !!perl/hash:RE_decl 
      a: 0
      dba: package_declarator__S_083class
      i: 0
      max: 0
      min: 0
      r: 1
      s: 0
      text: my $PKGDECL is context = 'class'
  kind: token
  min: 37035
  pkg: ~
  re: !!perl/hash:RE_sequence 
    a: 0
    dba: package_declarator__S_083class
    i: 0
    min: 37035
    r: 1
    s: 0
    zyg: 
      - !!perl/hash:RE_method 
        a: 0
        dba: package_declarator__S_083class
        endsym: spacey
        i: 0
        min: 12345
        name: sym
        r: 1
        rest: ''
        s: 0
        sym: class
      - !!perl/hash:RE_method 
        a: 0
        dba: package_declarator__S_083class
        i: 0
        min: 12345
        name: spacey
        nobind: 1
        r: 1
        rest: ''
        s: 0
      - !!perl/hash:RE_method 
        a: 0
        dba: package_declarator__S_083class
        i: 0
        min: 12345
        name: package_def
        r: 1
        rest: ''
        s: 0
package_declarator__S_084grammar: !!perl/hash:RE 
  decl: 
    - !!perl/hash:RE_decl 
      a: 0
      dba: package_declarator__S_084grammar
      i: 0
      max: 0
      min: 0
      r: 1
      s: 0
      text: my $PKGDECL is context = 'grammar'
  kind: token
  min: 37035
  pkg: ~
  re: !!perl/hash:RE_sequence 
    a: 0
    dba: package_declarator__S_084grammar
    i: 0
    min: 37035
    r: 1
    s: 0
    zyg: 
      - !!perl/hash:RE_method 
        a: 0
        dba: package_declarator__S_084grammar
        endsym: spacey
        i: 0
        min: 12345
        name: sym
        r: 1
        rest: ''
        s: 0
        sym: grammar
      - !!perl/hash:RE_method 
        a: 0
        dba: package_declarator__S_084grammar
        i: 0
        min: 12345
        name: spacey
        nobind: 1
        r: 1
        rest: ''
        s: 0
      - !!perl/hash:RE_method 
        a: 0
        dba: package_declarator__S_084grammar
        i: 0
        min: 12345
        name: package_def
        r: 1
        rest: ''
        s: 0
package_declarator__S_085module: !!perl/hash:RE 
  decl: 
    - !!perl/hash:RE_decl 
      a: 0
      dba: package_declarator__S_085module
      i: 0
      max: 0
      min: 0
      r: 1
      s: 0
      text: my $PKGDECL is context = 'module'
  kind: token
  min: 37035
  pkg: ~
  re: !!perl/hash:RE_sequence 
    a: 0
    dba: package_declarator__S_085module
    i: 0
    min: 37035
    r: 1
    s: 0
    zyg: 
      - !!perl/hash:RE_method 
        a: 0
        dba: package_declarator__S_085module
        endsym: spacey
        i: 0
        min: 12345
        name: sym
        r: 1
        rest: ''
        s: 0
        sym: module
      - !!perl/hash:RE_method 
        a: 0
        dba: package_declarator__S_085module
        i: 0
        min: 12345
        name: spacey
        nobind: 1
        r: 1
        rest: ''
        s: 0
      - !!perl/hash:RE_method 
        a: 0
        dba: package_declarator__S_085module
        i: 0
        min: 12345
        name: package_def
        r: 1
        rest: ''
        s: 0
package_declarator__S_086package: !!perl/hash:RE 
  decl: 
    - !!perl/hash:RE_decl 
      a: 0
      dba: package_declarator__S_086package
      i: 0
      max: 0
      min: 0
      r: 1
      s: 0
      text: my $PKGDECL is context = 'package'
  kind: token
  min: 37035
  pkg: ~
  re: !!perl/hash:RE_sequence 
    a: 0
    dba: package_declarator__S_086package
    i: 0
    min: 37035
    r: 1
    s: 0
    zyg: 
      - !!perl/hash:RE_method 
        a: 0
        dba: package_declarator__S_086package
        endsym: spacey
        i: 0
        min: 12345
        name: sym
        r: 1
        rest: ''
        s: 0
        sym: package
      - !!perl/hash:RE_method 
        a: 0
        dba: package_declarator__S_086package
        i: 0
        min: 12345
        name: spacey
        nobind: 1
        r: 1
        rest: ''
        s: 0
      - !!perl/hash:RE_method 
        a: 0
        dba: package_declarator__S_086package
        i: 0
        min: 12345
        name: package_def
        r: 1
        rest: ''
        s: 0
package_declarator__S_087role: !!perl/hash:RE 
  decl: 
    - !!perl/hash:RE_decl 
      a: 0
      dba: package_declarator__S_087role
      i: 0
      max: 0
      min: 0
      r: 1
      s: 0
      text: my $PKGDECL is context = 'role'
  kind: token
  min: 37035
  pkg: ~
  re: !!perl/hash:RE_sequence 
    a: 0
    dba: package_declarator__S_087role
    i: 0
    min: 37035
    r: 1
    s: 0
    zyg: 
      - !!perl/hash:RE_method 
        a: 0
        dba: package_declarator__S_087role
        endsym: spacey
        i: 0
        min: 12345
        name: sym
        r: 1
        rest: ''
        s: 0
        sym: role
      - !!perl/hash:RE_method 
        a: 0
        dba: package_declarator__S_087role
        i: 0
        min: 12345
        name: spacey
        nobind: 1
        r: 1
        rest: ''
        s: 0
      - !!perl/hash:RE_method 
        a: 0
        dba: package_declarator__S_087role
        i: 0
        min: 12345
        name: package_def
        r: 1
        rest: ''
        s: 0
package_declarator__S_088knowhow: !!perl/hash:RE 
  decl: 
    - !!perl/hash:RE_decl 
      a: 0
      dba: package_declarator__S_088knowhow
      i: 0
      max: 0
      min: 0
      r: 1
      s: 0
      text: my $PKGDECL is context = 'knowhow'
  kind: token
  min: 37035
  pkg: ~
  re: !!perl/hash:RE_sequence 
    a: 0
    dba: package_declarator__S_088knowhow
    i: 0
    min: 37035
    r: 1
    s: 0
    zyg: 
      - !!perl/hash:RE_method 
        a: 0
        dba: package_declarator__S_088knowhow
        endsym: spacey
        i: 0
        min: 12345
        name: sym
        r: 1
        rest: ''
        s: 0
        sym: knowhow
      - !!perl/hash:RE_method 
        a: 0
        dba: package_declarator__S_088knowhow
        i: 0
        min: 12345
        name: spacey
        nobind: 1
        r: 1
        rest: ''
        s: 0
      - !!perl/hash:RE_method 
        a: 0
        dba: package_declarator__S_088knowhow
        i: 0
        min: 12345
        name: package_def
        r: 1
        rest: ''
        s: 0
package_declarator__S_089slang: !!perl/hash:RE 
  decl: 
    - !!perl/hash:RE_decl 
      a: 0
      dba: package_declarator__S_089slang
      i: 0
      max: 0
      min: 0
      r: 1
      s: 0
      text: my $PKGDECL is context = 'slang'
  kind: token
  min: 37035
  pkg: ~
  re: !!perl/hash:RE_sequence 
    a: 0
    dba: package_declarator__S_089slang
    i: 0
    min: 37035
    r: 1
    s: 0
    zyg: 
      - !!perl/hash:RE_method 
        a: 0
        dba: package_declarator__S_089slang
        endsym: spacey
        i: 0
        min: 12345
        name: sym
        r: 1
        rest: ''
        s: 0
        sym: slang
      - !!perl/hash:RE_method 
        a: 0
        dba: package_declarator__S_089slang
        i: 0
        min: 12345
        name: spacey
        nobind: 1
        r: 1
        rest: ''
        s: 0
      - !!perl/hash:RE_method 
        a: 0
        dba: package_declarator__S_089slang
        i: 0
        min: 12345
        name: package_def
        r: 1
        rest: ''
        s: 0
package_declarator__S_090require: !!perl/hash:RE 
  decl: []

  kind: token
  min: 49380
  pkg: ~
  re: !!perl/hash:RE_sequence 
    a: 0
    dba: package_declarator__S_090require
    i: 0
    min: 49380
    r: 1
    s: 0
    zyg: 
      - !!perl/hash:RE_method 
        a: 0
        dba: package_declarator__S_090require
        endsym: spacey
        i: 0
        min: 12345
        name: sym
        r: 1
        rest: ''
        s: 0
        sym: require
      - !!perl/hash:RE_method 
        a: 0
        dba: package_declarator__S_090require
        i: 0
        min: 12345
        name: spacey
        nobind: 1
        r: 1
        rest: ''
        s: 0
      - !!perl/hash:RE_method 
        a: 0
        dba: package_declarator__S_090require
        i: 0
        min: 12345
        name: ws
        nobind: 1
        r: 1
        rest: ''
        s: 0
      - !!perl/hash:RE_bracket 
        decl: []

        min: 12345
        re: !!perl/hash:RE_first 
          a: 0
          dba: package_declarator__S_090require
          i: 0
          min: 12345
          r: 1
          s: 0
          zyg: 
            - !!perl/hash:RE_sequence 
              a: 0
              dba: package_declarator__S_090require
              i: 0
              min: 12345
              r: 1
              s: 0
              zyg: 
                - !!perl/hash:RE_method 
                  a: 0
                  dba: package_declarator__S_090require
                  i: 0
                  min: 12345
                  name: module_name
                  r: 1
                  rest: ''
                  s: 0
                - !!perl/hash:RE_quantified_atom 
                  atom: !!perl/hash:RE_method 
                    a: 0
                    dba: package_declarator__S_090require
                    i: 0
                    min: 12345
                    name: EXPR
                    r: 1
                    rest: ''
                    s: 0
                  min: 0
                  quant: 
                    - "?"
                    - ":"
                    - ''
                    - 0
            - !!perl/hash:RE_method 
              a: 0
              dba: package_declarator__S_090require
              i: 0
              min: 12345
              name: EXPR
              r: 1
              rest: ''
              s: 0
package_declarator__S_091trusts: !!perl/hash:RE 
  decl: []

  kind: token
  min: 49380
  pkg: ~
  re: !!perl/hash:RE_sequence 
    a: 0
    dba: package_declarator__S_091trusts
    i: 0
    min: 49380
    r: 1
    s: 0
    zyg: 
      - !!perl/hash:RE_method 
        a: 0
        dba: package_declarator__S_091trusts
        endsym: spacey
        i: 0
        min: 12345
        name: sym
        r: 1
        rest: ''
        s: 0
        sym: trusts
      - !!perl/hash:RE_method 
        a: 0
        dba: package_declarator__S_091trusts
        i: 0
        min: 12345
        name: spacey
        nobind: 1
        r: 1
        rest: ''
        s: 0
      - !!perl/hash:RE_method 
        a: 0
        dba: package_declarator__S_091trusts
        i: 0
        min: 12345
        name: ws
        nobind: 1
        r: 1
        rest: ''
        s: 0
      - !!perl/hash:RE_method 
        a: 0
        dba: package_declarator__S_091trusts
        i: 0
        min: 12345
        name: module_name
        r: 1
        rest: ''
        s: 0
package_declarator__S_092does: !!perl/hash:RE 
  decl: []

  kind: token
  min: 49380
  pkg: ~
  re: !!perl/hash:RE_sequence 
    a: 0
    dba: package_declarator__S_092does
    i: 0
    min: 49380
    r: 1
    s: 0
    zyg: 
      - !!perl/hash:RE_method 
        a: 0
        dba: package_declarator__S_092does
        endsym: spacey
        i: 0
        min: 12345
        name: sym
        r: 1
        rest: ''
        s: 0
        sym: does
      - !!perl/hash:RE_method 
        a: 0
        dba: package_declarator__S_092does
        i: 0
        min: 12345
        name: spacey
        nobind: 1
        r: 1
        rest: ''
        s: 0
      - !!perl/hash:RE_method 
        a: 0
        dba: package_declarator__S_092does
        i: 0
        min: 12345
        name: ws
        nobind: 1
        r: 1
        rest: ''
        s: 0
      - !!perl/hash:RE_method 
        a: 0
        dba: package_declarator__S_092does
        i: 0
        min: 12345
        name: typename
        r: 1
        rest: ''
        s: 0
package_def: !!perl/hash:RE 
  decl: 
    - !!perl/hash:RE_decl 
      a: 0
      dba: package_def
      i: 0
      max: 0
      min: 0
      r: 1
      s: 1
      text: my $longname
    - !!perl/hash:RE_decl 
      a: 0
      dba: package_def
      i: 0
      max: 0
      min: 0
      r: 1
      s: 1
      text: my $IN_DECL is context<rw> = 1
    - !!perl/hash:RE_decl 
      a: 0
      dba: package_def
      i: 0
      max: 0
      min: 0
      r: 1
      s: 1
      text: my $DECLARAND is context<rw>
  kind: rule
  min: 0
  pkg: ~
  re: !!perl/hash:RE_first 
    a: 0
    dba: package_def
    i: 0
    min: 0
    r: 1
    s: 1
    zyg: 
      - !!perl/hash:RE_sequence 
        a: 0
        dba: package_def
        i: 0
        min: 0
        r: 1
        s: 1
        zyg: 
          - !!perl/hash:RE_method 
            min: 0
            name: ws
            nobind: 1
            noquant: 1
            rest: ''
          - !!perl/hash:RE_bracket 
            decl: []

            min: 0
            re: !!perl/hash:RE_sequence 
              a: 0
              dba: package_def
              i: 0
              min: 0
              r: 1
              s: 1
              zyg: 
                - !!perl/hash:RE_quantified_atom 
                  atom: !!perl/hash:RE_bracket 
                    decl: []

                    min: 12345
                    re: !!perl/hash:RE_sequence 
                      a: 0
                      dba: package_def
                      i: 0
                      min: 12345
                      r: 1
                      s: 1
                      zyg: 
                        - !!perl/hash:RE_method 
                          min: 0
                          name: ws
                          nobind: 1
                          noquant: 1
                          rest: ''
                        - !!perl/hash:RE_method 
                          a: 0
                          dba: package_def
                          i: 0
                          min: 12345
                          name: def_module_name
                          r: 1
                          rest: ''
                          s: 1
                        - !!perl/hash:RE_block 
                          a: 0
                          context: void
                          dba: package_def
                          i: 0
                          min: 0
                          r: 1
                          s: 1
                          text: "\n                $longname = $<def_module_name>[0]<longname>;\n                $¢.add_name($longname.Str);\n            "
                        - !!perl/hash:RE_method 
                          min: 0
                          name: ws
                          nobind: 1
                          noquant: 1
                          rest: ''
                  min: 0
                  quant: 
                    - "?"
                    - ":"
                    - ''
                    - 0
                - !!perl/hash:RE_method 
                  min: 0
                  name: ws
                  nobind: 1
                  noquant: 1
                  rest: ''
                - !!perl/hash:RE_quantified_atom 
                  atom: !!perl/hash:RE_method 
                    a: 0
                    dba: package_def
                    i: 0
                    min: 12345
                    name: trait
                    r: 1
                    rest: ''
                    s: 1
                  min: 0
                  quant: 
                    - "*"
                    - ":"
                    - ''
                    - 0
                - !!perl/hash:RE_method 
                  min: 0
                  name: ws
                  nobind: 1
                  noquant: 1
                  rest: ''
                - !!perl/hash:RE_bracket 
                  decl: []

                  min: 0
                  re: !!perl/hash:RE_first 
                    a: 0
                    dba: package_def
                    i: 0
                    min: 0
                    r: 1
                    s: 1
                    zyg: 
                      - !!perl/hash:RE_sequence 
                        a: 0
                        dba: package_def
                        i: 0
                        min: 12345
                        r: 1
                        s: 1
                        zyg: 
                          - !!perl/hash:RE_assertion 
                            assert: "?"
                            min: 0
                            re: !!perl/hash:RE_method_re 
                              a: 0
                              dba: package_def
                              i: 0
                              min: 0
                              name: before
                              nobind: 1
                              r: 1
                              re: !!perl/hash:RE 
                                decl: []

                                min: 1
                                re: !!perl/hash:RE_string 
                                  a: 0
                                  dba: package_def
                                  i: 0
                                  min: 1
                                  r: 1
                                  s: 1
                                  text: "{"
                              s: 1
                          - !!perl/hash:RE_method 
                            min: 0
                            name: ws
                            nobind: 1
                            noquant: 1
                            rest: ''
                          - !!perl/hash:RE_block 
                            a: 0
                            context: void
                            dba: package_def
                            i: 0
                            min: 0
                            r: 1
                            s: 1
                            text: "\n                # figure out the actual full package name (nested in outer package)\n                my $pkg = $*PKGNAME || \"GLOBAL\";\n                my $shortname;\n                if $longname {\n                     $shortname = $longname.<name>.Str;\n                }\n                else {\n                    $shortname = '_anon_';\n                }\n                $*PKGNAME = $pkg ~ '::' ~ $shortname;\n                my $newpkg = $*CURPKG.{$shortname ~ '::'};\n                $newpkg.<PARENT::> = $*CURPKG;\n                $*CURPKG = $newpkg;\n                push @PKGS, $pkg;\n                say \"adding $newpkg \" ~ $*PKGNAME if $*DEBUG +& DEBUG::symtab;\n            "
                          - !!perl/hash:RE_method 
                            min: 0
                            name: ws
                            nobind: 1
                            noquant: 1
                            rest: ''
                          - !!perl/hash:RE_method 
                            a: 0
                            dba: package_def
                            i: 0
                            min: 12345
                            name: block
                            r: 1
                            rest: ''
                            s: 1
                          - !!perl/hash:RE_method 
                            min: 0
                            name: ws
                            nobind: 1
                            noquant: 1
                            rest: ''
                          - !!perl/hash:RE_block 
                            a: 0
                            context: void
                            dba: package_def
                            i: 0
                            min: 0
                            r: 1
                            s: 1
                            text: "\n                $*PKGNAME = pop(@PKGS);\n                $*CURPKG = $*CURPKG.<PARENT::>;\n            "
                          - !!perl/hash:RE_method 
                            min: 0
                            name: ws
                            nobind: 1
                            noquant: 1
                            rest: ''
                          - !!perl/hash:RE_method_internal 
                            args: $S, 'package_def', 'block'
                            max: 0
                            min: 0
                            name: _REDUCE
                          - !!perl/hash:RE_method 
                            min: 0
                            name: ws
                            nobind: 1
                            noquant: 1
                            rest: ''
                      - !!perl/hash:RE_sequence 
                        a: 0
                        dba: package_def
                        i: 0
                        min: 0
                        r: 1
                        s: 1
                        zyg: 
                          - !!perl/hash:RE_assertion 
                            assert: "?"
                            min: 0
                            re: !!perl/hash:RE_method_re 
                              a: 0
                              dba: package_def
                              i: 0
                              min: 0
                              name: before
                              nobind: 1
                              r: 1
                              re: !!perl/hash:RE 
                                decl: []

                                min: 1
                                re: !!perl/hash:RE_string 
                                  a: 0
                                  dba: package_def
                                  i: 0
                                  min: 1
                                  r: 1
                                  s: 1
                                  text: ;
                              s: 1
                          - !!perl/hash:RE_method 
                            min: 0
                            name: ws
                            nobind: 1
                            noquant: 1
                            rest: ''
                          - !!perl/hash:RE_bracket 
                            decl: []

                            min: 0
                            re: !!perl/hash:RE_first 
                              a: 0
                              dba: package_def
                              i: 0
                              min: 0
                              r: 1
                              s: 1
                              zyg: 
                                - !!perl/hash:RE_sequence 
                                  a: 0
                                  dba: package_def
                                  i: 0
                                  min: 0
                                  r: 1
                                  s: 1
                                  zyg: 
                                    - !!perl/hash:RE_assertion 
                                      assert: "?"
                                      min: 0
                                      re: !!perl/hash:RE_block 
                                        a: 0
                                        context: bool
                                        dba: package_def
                                        i: 0
                                        min: 0
                                        nobind: 1
                                        r: 1
                                        s: 1
                                        text: " $*begin_compunit "
                                    - !!perl/hash:RE_method 
                                      min: 0
                                      name: ws
                                      nobind: 1
                                      noquant: 1
                                      rest: ''
                                    - !!perl/hash:RE_block 
                                      a: 0
                                      context: void
                                      dba: package_def
                                      i: 0
                                      min: 0
                                      r: 1
                                      s: 1
                                      text: "\n                    $longname orelse $¢.panic(\"Compilation unit cannot be anonymous\");\n                    my $shortname = $longname.<name>.Str;\n                    $*PKGNAME = $shortname;\n                    my $newpkg = $*CURPKG.{$shortname ~ '::'};\n                    $newpkg.<PARENT::> = $*CURPKG;\n                    $*CURPKG = $newpkg;\n                    $*begin_compunit = 0;\n                "
                                    - !!perl/hash:RE_method 
                                      min: 0
                                      name: ws
                                      nobind: 1
                                      noquant: 1
                                      rest: ''
                                    - !!perl/hash:RE_method_internal 
                                      args: $S, 'package_def', 'semi'
                                      max: 0
                                      min: 0
                                      name: _REDUCE
                                    - !!perl/hash:RE_method 
                                      min: 0
                                      name: ws
                                      nobind: 1
                                      noquant: 1
                                      rest: ''
                                - !!perl/hash:RE_sequence 
                                  a: 0
                                  dba: package_def
                                  i: 0
                                  min: 0
                                  r: 1
                                  s: 1
                                  zyg: 
                                    - !!perl/hash:RE_method 
                                      min: 0
                                      name: panic
                                      nobind: 1
                                      rest: ("Too late for semicolon form of " ~ $*PKGDECL ~ " definition")
                                    - !!perl/hash:RE_method 
                                      min: 0
                                      name: ws
                                      nobind: 1
                                      noquant: 1
                                      rest: ''
                          - !!perl/hash:RE_method 
                            min: 0
                            name: ws
                            nobind: 1
                            noquant: 1
                            rest: ''
                      - !!perl/hash:RE_sequence 
                        a: 0
                        dba: package_def
                        i: 0
                        min: 0
                        r: 1
                        s: 1
                        zyg: 
                          - !!perl/hash:RE_method 
                            min: 0
                            name: panic
                            nobind: 1
                            rest: ("Unable to parse " ~ $*PKGDECL ~ " definition")
                          - !!perl/hash:RE_method 
                            min: 0
                            name: ws
                            nobind: 1
                            noquant: 1
                            rest: ''
                - !!perl/hash:RE_method 
                  min: 0
                  name: ws
                  nobind: 1
                  noquant: 1
                  rest: ''
          - !!perl/hash:RE_method 
            min: 0
            name: ws
            nobind: 1
            noquant: 1
            rest: ''
      - !!perl/hash:RE_sequence 
        a: 0
        dba: package_def
        i: 0
        min: 0
        r: 1
        s: 1
        zyg: 
          - !!perl/hash:RE_method 
            min: 0
            name: ws
            nobind: 1
            noquant: 1
            rest: ''
          - !!perl/hash:RE_method 
            min: 0
            name: panic
            nobind: 1
            rest: ("Malformed $*PKGDECL")
          - !!perl/hash:RE_method 
            min: 0
            name: ws
            nobind: 1
            noquant: 1
            rest: ''
param_sep: !!perl/hash:RE 
  decl: []

  kind: rule
  min: 1
  pkg: ~
  re: !!perl/hash:RE_sequence 
    a: 0
    dba: param_sep
    i: 0
    min: 1
    r: 1
    s: 1
    zyg: 
      - !!perl/hash:RE_method 
        min: 0
        name: ws
        nobind: 1
        noquant: 1
        rest: ''
      - !!perl/hash:RE_bracket 
        decl: []

        min: 1
        re: &51 !!perl/hash:RE_any 
          a: 0
          altname: param_sep_01
          dba: param_sep
          i: 0
          min: 1
          name: param_sep_01
          r: 1
          s: 1
          zyg: 
            - !!perl/hash:RE_string 
              a: 0
              alt: param_sep_01 0
              dba: param_sep
              i: 0
              min: 1
              r: 1
              s: 1
              text: ","
            - !!perl/hash:RE_string 
              a: 0
              alt: param_sep_01 1
              dba: param_sep
              i: 0
              min: 1
              r: 1
              s: 1
              text: ":"
            - !!perl/hash:RE_string 
              a: 0
              alt: param_sep_01 2
              dba: param_sep
              i: 0
              min: 1
              r: 1
              s: 1
              text: ;
            - !!perl/hash:RE_string 
              a: 0
              alt: param_sep_01 3
              dba: param_sep
              i: 0
              min: 2
              r: 1
              s: 1
              text: ;;
      - !!perl/hash:RE_method 
        min: 0
        name: ws
        nobind: 1
        noquant: 1
        rest: ''
param_sep_01: *51
param_var: !!perl/hash:RE 
  decl: []

  kind: token
  min: 12345
  pkg: ~
  re: !!perl/hash:RE_bracket 
    decl: []

    min: 12345
    re: &115 !!perl/hash:RE_any 
      a: 0
      altname: param_var_01
      dba: formal parameter
      i: 0
      min: 12345
      name: param_var_01
      r: 1
      s: 0
      zyg: 
        - !!perl/hash:RE_sequence 
          a: 0
          alt: param_var_01 0
          dba: formal parameter
          i: 0
          min: 12347
          r: 1
          s: 0
          zyg: 
            - !!perl/hash:RE_string 
              a: 0
              dba: formal parameter
              i: 0
              min: 1
              r: 1
              s: 0
              text: "["
            - !!perl/hash:RE_meta 
              a: 0
              dba: formal parameter
              extra: "local $::GOAL = ']' "
              i: 0
              min: 0
              r: 1
              s: 0
              text: "::"
            - !!perl/hash:RE_method 
              a: 0
              dba: formal parameter
              i: 0
              min: 12345
              name: signature
              r: 1
              rest: ''
              s: 0
            - !!perl/hash:RE_bracket 
              decl: []

              min: 1
              re: !!perl/hash:RE_first 
                a: 0
                dba: formal parameter
                i: 0
                min: 1
                r: 1
                s: 0
                zyg: 
                  - !!perl/hash:RE_string 
                    a: 0
                    dba: formal parameter
                    i: 0
                    min: 1
                    r: 1
                    s: 0
                    text: "]"
                  - !!perl/hash:RE_method 
                    min: 0
                    name: FAILGOAL
                    nobind: 1
                    rest: (']' , 'formal parameter')
        - !!perl/hash:RE_sequence 
          a: 0
          alt: param_var_01 1
          dba: formal parameter
          i: 0
          min: 12347
          r: 1
          s: 0
          zyg: 
            - !!perl/hash:RE_string 
              a: 0
              dba: formal parameter
              i: 0
              min: 1
              r: 1
              s: 0
              text: (
            - !!perl/hash:RE_meta 
              a: 0
              dba: formal parameter
              extra: "local $::GOAL = ')' "
              i: 0
              min: 0
              r: 1
              s: 0
              text: "::"
            - !!perl/hash:RE_method 
              a: 0
              dba: formal parameter
              i: 0
              min: 12345
              name: signature
              r: 1
              rest: ''
              s: 0
            - !!perl/hash:RE_bracket 
              decl: []

              min: 1
              re: !!perl/hash:RE_first 
                a: 0
                dba: formal parameter
                i: 0
                min: 1
                r: 1
                s: 0
                zyg: 
                  - !!perl/hash:RE_string 
                    a: 0
                    dba: formal parameter
                    i: 0
                    min: 1
                    r: 1
                    s: 0
                    text: )
                  - !!perl/hash:RE_method 
                    min: 0
                    name: FAILGOAL
                    nobind: 1
                    rest: (')' , 'formal parameter')
        - !!perl/hash:RE_sequence 
          a: 0
          alt: param_var_01 2
          dba: formal parameter
          i: 0
          min: 12345
          r: 1
          s: 0
          zyg: 
            - !!perl/hash:RE_method 
              a: 0
              dba: formal parameter
              i: 0
              min: 12345
              name: sigil
              r: 1
              rest: ''
              s: 0
            - !!perl/hash:RE_quantified_atom 
              atom: !!perl/hash:RE_bracket 
                decl: []

                min: 12345
                re: !!perl/hash:RE_sequence 
                  a: 0
                  dba: formal parameter
                  i: 0
                  min: 12345
                  r: 1
                  s: 0
                  zyg: 
                    - !!perl/hash:RE_assertion 
                      assert: "?"
                      min: 0
                      re: !!perl/hash:RE_method_re 
                        a: 0
                        dba: formal parameter
                        i: 0
                        min: 0
                        name: before
                        nobind: 1
                        r: 1
                        re: !!perl/hash:RE 
                          decl: []

                          min: 12346
                          re: !!perl/hash:RE_sequence 
                            a: 0
                            dba: formal parameter
                            i: 0
                            min: 12346
                            r: 1
                            s: 0
                            zyg: 
                              - !!perl/hash:RE_method 
                                a: 0
                                dba: formal parameter
                                i: 0
                                min: 12345
                                name: twigil
                                nobind: 1
                                r: 1
                                rest: ''
                                s: 0
                              - !!perl/hash:RE_meta 
                                a: 0
                                dba: formal parameter
                                i: 0
                                min: 1
                                r: 1
                                s: 0
                                text: \w
                        s: 0
                    - !!perl/hash:RE_method 
                      a: 0
                      dba: formal parameter
                      i: 0
                      min: 12345
                      name: twigil
                      r: 1
                      rest: ''
                      s: 0
              min: 0
              quant: 
                - "?"
                - ":"
                - ''
                - 0
            - !!perl/hash:RE_quantified_atom 
              atom: !!perl/hash:RE_bracket 
                decl: []

                min: 1
                re: !!perl/hash:RE_first 
                  a: 0
                  dba: formal parameter
                  i: 0
                  min: 1
                  r: 1
                  s: 0
                  zyg: 
                    - !!perl/hash:RE_sequence 
                      a: 0
                      dba: formal parameter
                      i: 0
                      min: 12345
                      r: 1
                      s: 0
                      zyg: 
                        - !!perl/hash:RE_assertion 
                          assert: "?"
                          min: 0
                          re: !!perl/hash:RE_block 
                            a: 0
                            context: bool
                            dba: formal parameter
                            i: 0
                            min: 0
                            nobind: 1
                            r: 1
                            s: 0
                            text: " $<sigil>.Str eq '&' "
                        - !!perl/hash:RE_assertion 
                          assert: "?"
                          min: 0
                          re: !!perl/hash:RE_method 
                            a: 0
                            dba: formal parameter
                            i: 0
                            min: 12345
                            name: ident
                            nobind: 1
                            r: 1
                            rest: ''
                            s: 0
                        - !!perl/hash:RE_block 
                          a: 0
                          context: void
                          dba: formal parameter
                          i: 0
                          min: 0
                          r: 1
                          s: 0
                          text: ''
                        - !!perl/hash:RE_bindnamed 
                          a: 0
                          atom: !!perl/hash:RE_method 
                            a: 0
                            dba: formal parameter
                            i: 0
                            min: 12345
                            name: sublongname
                            nobind: 1
                            r: 1
                            rest: ''
                            s: 0
                          dba: formal parameter
                          i: 0
                          min: 12345
                          r: 1
                          s: 0
                          var: name
                    - !!perl/hash:RE_sequence 
                      a: 0
                      dba: formal parameter
                      i: 0
                      min: 12345
                      r: 1
                      s: 0
                      zyg: 
                        - !!perl/hash:RE_assertion 
                          assert: "?"
                          min: 0
                          re: !!perl/hash:RE_block 
                            a: 0
                            context: bool
                            dba: formal parameter
                            i: 0
                            min: 0
                            nobind: 1
                            r: 1
                            s: 0
                            text: " $<sigil>.Str eq '@' || $<sigil>.Str eq '%' "
                        - !!perl/hash:RE_bindnamed 
                          a: 0
                          atom: !!perl/hash:RE_quantified_atom 
                            atom: !!perl/hash:RE_method 
                              a: 0
                              dba: formal parameter
                              i: 0
                              min: 12345
                              name: identifier
                              r: 1
                              rest: ''
                              s: 0
                            min: 0
                            nobind: 1
                            quant: 
                              - "?"
                              - ":"
                              - ''
                              - 0
                          dba: formal parameter
                          i: 0
                          min: 0
                          r: 1
                          s: 0
                          var: name
                        - !!perl/hash:RE_assertion 
                          assert: "?"
                          min: 0
                          re: !!perl/hash:RE_method_re 
                            a: 0
                            dba: formal parameter
                            i: 0
                            min: 0
                            name: before
                            nobind: 1
                            r: 1
                            re: !!perl/hash:RE 
                              decl: []

                              min: 1
                              re: !!perl/hash:RE_cclass 
                                a: 0
                                dba: formal parameter
                                i: 0
                                min: 1
                                r: 1
                                s: 0
                                text: "[ \\< \\( \\[ \\{ ]"
                            s: 0
                        - !!perl/hash:RE_method 
                          a: 0
                          dba: formal parameter
                          i: 0
                          min: 12345
                          name: postcircumfix
                          r: 1
                          rest: ''
                          s: 0
                    - !!perl/hash:RE_bindnamed 
                      a: 0
                      atom: !!perl/hash:RE_method 
                        a: 0
                        dba: formal parameter
                        i: 0
                        min: 12345
                        name: identifier
                        nobind: 1
                        r: 1
                        rest: ''
                        s: 0
                      dba: formal parameter
                      i: 0
                      min: 12345
                      r: 1
                      s: 0
                      var: name
                    - !!perl/hash:RE_bindnamed 
                      a: 0
                      atom: !!perl/hash:RE_bracket 
                        decl: []

                        min: 1
                        nobind: 1
                        re: !!perl/hash:RE_cclass 
                          a: 0
                          dba: formal parameter
                          i: 0
                          min: 1
                          r: 1
                          s: 0
                          text: "[/!]"
                      dba: formal parameter
                      i: 0
                      min: 1
                      r: 1
                      s: 0
                      var: name
              min: 0
              quant: 
                - "?"
                - ":"
                - ''
                - 0
            - !!perl/hash:RE_block 
              a: 0
              context: void
              dba: formal parameter
              i: 0
              min: 0
              r: 1
              s: 0
              text: "\n            my $vname = $<sigil>.Str;\n            my $t = $<twigil>;\n            my $twigil = '';\n            $twigil = $t.[0].Str if @$t;\n            $vname ~= $twigil;\n            my $n = try { $<name>[0].Str } // '';\n            $vname ~= $n;\n            given $twigil {\n                when '' {\n                    self.add_my_variable($vname) if $n ne '';\n                }\n                when '.' {\n                }\n                when '!' {\n                }\n                default {\n                    self.worry(\"Illegal to use $twigil twigil in signature\");\n                }\n            }\n        "
param_var_01: *115
parameter: !!perl/hash:RE 
  decl: 
    - !!perl/hash:RE_decl 
      a: 0
      dba: parameter
      i: 0
      max: 0
      min: 0
      r: 1
      s: 0
      text: my $kind
    - !!perl/hash:RE_decl 
      a: 0
      dba: parameter
      i: 0
      max: 0
      min: 0
      r: 1
      s: 0
      text: my $quant = ''
    - !!perl/hash:RE_decl 
      a: 0
      dba: parameter
      i: 0
      max: 0
      min: 0
      r: 1
      s: 0
      text: my $q
  kind: token
  min: 12345
  pkg: ~
  re: !!perl/hash:RE_sequence 
    a: 0
    dba: parameter
    i: 0
    min: 12345
    r: 1
    s: 0
    zyg: 
      - !!perl/hash:RE_bracket 
        decl: []

        min: 12345
        re: &40 !!perl/hash:RE_any 
          a: 0
          altname: parameter_01
          dba: parameter
          i: 0
          min: 12345
          name: parameter_01
          r: 1
          s: 0
          zyg: 
            - !!perl/hash:RE_sequence 
              a: 0
              alt: parameter_01 0
              dba: parameter
              i: 0
              min: 12345
              r: 1
              s: 0
              zyg: 
                - !!perl/hash:RE_quantified_atom 
                  atom: !!perl/hash:RE_method 
                    a: 0
                    dba: parameter
                    i: 0
                    min: 12345
                    name: type_constraint
                    r: 1
                    rest: ''
                    s: 0
                  min: 12345
                  quant: 
                    - +
                    - ":"
                    - ''
                    - 1
                - !!perl/hash:RE_block 
                  a: 0
                  context: void
                  dba: parameter
                  i: 0
                  min: 0
                  r: 1
                  s: 0
                  text: "\n            my $t = $<type_constraint>;\n            @$t > 1 and $¢.panic(\"Multiple prefix constraints not yet supported\")\n        "
                - !!perl/hash:RE_bracket 
                  decl: []

                  min: 0
                  re: &58 !!perl/hash:RE_any 
                    a: 0
                    altname: parameter_02
                    dba: parameter
                    i: 0
                    min: 0
                    name: parameter_02
                    r: 1
                    s: 0
                    zyg: 
                      - !!perl/hash:RE_sequence 
                        a: 0
                        alt: parameter_02 0
                        dba: parameter
                        i: 0
                        min: 12346
                        r: 1
                        s: 0
                        zyg: 
                          - !!perl/hash:RE_string 
                            a: 0
                            dba: parameter
                            i: 0
                            min: 1
                            r: 1
                            s: 0
                            text: "*"
                          - !!perl/hash:RE_method 
                            a: 0
                            dba: parameter
                            i: 0
                            min: 12345
                            name: param_var
                            r: 1
                            rest: ''
                            s: 0
                          - !!perl/hash:RE_block 
                            a: 0
                            context: void
                            dba: parameter
                            i: 0
                            min: 0
                            r: 1
                            s: 0
                            text: " $quant = '*'; $kind = '*'; "
                      - !!perl/hash:RE_sequence 
                        a: 0
                        alt: parameter_02 1
                        dba: parameter
                        i: 0
                        min: 12346
                        r: 1
                        s: 0
                        zyg: 
                          - !!perl/hash:RE_string 
                            a: 0
                            dba: parameter
                            i: 0
                            min: 1
                            r: 1
                            s: 0
                            text: "|"
                          - !!perl/hash:RE_method 
                            a: 0
                            dba: parameter
                            i: 0
                            min: 12345
                            name: param_var
                            r: 1
                            rest: ''
                            s: 0
                          - !!perl/hash:RE_block 
                            a: 0
                            context: void
                            dba: parameter
                            i: 0
                            min: 0
                            r: 1
                            s: 0
                            text: " $quant = '|'; $kind = '*'; "
                      - !!perl/hash:RE_sequence 
                        a: 0
                        alt: parameter_02 2
                        dba: parameter
                        i: 0
                        min: 12346
                        r: 1
                        s: 0
                        zyg: 
                          - !!perl/hash:RE_string 
                            a: 0
                            dba: parameter
                            i: 0
                            min: 1
                            r: 1
                            s: 0
                            text: \
                          - !!perl/hash:RE_method 
                            a: 0
                            dba: parameter
                            i: 0
                            min: 12345
                            name: param_var
                            r: 1
                            rest: ''
                            s: 0
                          - !!perl/hash:RE_block 
                            a: 0
                            context: void
                            dba: parameter
                            i: 0
                            min: 0
                            r: 1
                            s: 0
                            text: " $quant = '\\\\'; $kind = '!'; "
                      - !!perl/hash:RE_sequence 
                        a: 0
                        alt: parameter_02 3
                        dba: parameter
                        i: 0
                        min: 12345
                        r: 1
                        s: 0
                        zyg: 
                          - !!perl/hash:RE_bracket 
                            decl: []

                            min: 12345
                            re: &93 !!perl/hash:RE_any 
                              a: 0
                              altname: parameter_03
                              dba: parameter
                              i: 0
                              min: 12345
                              name: parameter_03
                              r: 1
                              s: 0
                              zyg: 
                                - !!perl/hash:RE_sequence 
                                  a: 0
                                  alt: parameter_03 0
                                  dba: parameter
                                  i: 0
                                  min: 12345
                                  r: 1
                                  s: 0
                                  zyg: 
                                    - !!perl/hash:RE_method 
                                      a: 0
                                      dba: parameter
                                      i: 0
                                      min: 12345
                                      name: param_var
                                      r: 1
                                      rest: ''
                                      s: 0
                                    - !!perl/hash:RE_block 
                                      a: 0
                                      context: void
                                      dba: parameter
                                      i: 0
                                      min: 0
                                      r: 1
                                      s: 0
                                      text: " $quant = ''; $kind = '!'; "
                                - !!perl/hash:RE_sequence 
                                  a: 0
                                  alt: parameter_03 1
                                  dba: parameter
                                  i: 0
                                  min: 12345
                                  r: 1
                                  s: 0
                                  zyg: 
                                    - !!perl/hash:RE_method 
                                      a: 0
                                      dba: parameter
                                      i: 0
                                      min: 12345
                                      name: named_param
                                      r: 1
                                      rest: ''
                                      s: 0
                                    - !!perl/hash:RE_block 
                                      a: 0
                                      context: void
                                      dba: parameter
                                      i: 0
                                      min: 0
                                      r: 1
                                      s: 0
                                      text: " $quant = ''; $kind = '*'; "
                          - !!perl/hash:RE_bracket 
                            decl: []

                            min: 0
                            re: &112 !!perl/hash:RE_any 
                              a: 0
                              altname: parameter_04
                              dba: parameter
                              i: 0
                              min: 0
                              name: parameter_04
                              r: 1
                              s: 0
                              zyg: 
                                - !!perl/hash:RE_sequence 
                                  a: 0
                                  alt: parameter_04 0
                                  dba: parameter
                                  i: 0
                                  min: 1
                                  r: 1
                                  s: 0
                                  zyg: 
                                    - !!perl/hash:RE_string 
                                      a: 0
                                      dba: parameter
                                      i: 0
                                      min: 1
                                      r: 1
                                      s: 0
                                      text: "?"
                                    - !!perl/hash:RE_block 
                                      a: 0
                                      context: void
                                      dba: parameter
                                      i: 0
                                      min: 0
                                      r: 1
                                      s: 0
                                      text: " $quant = '?'; $kind = '?' "
                                - !!perl/hash:RE_sequence 
                                  a: 0
                                  alt: parameter_04 1
                                  dba: parameter
                                  i: 0
                                  min: 1
                                  r: 1
                                  s: 0
                                  zyg: 
                                    - !!perl/hash:RE_string 
                                      a: 0
                                      dba: parameter
                                      i: 0
                                      min: 1
                                      r: 1
                                      s: 0
                                      text: "!"
                                    - !!perl/hash:RE_block 
                                      a: 0
                                      context: void
                                      dba: parameter
                                      i: 0
                                      min: 0
                                      r: 1
                                      s: 0
                                      text: " $quant = '!'; $kind //= '!' "
                                - !!perl/hash:RE_assertion 
                                  alt: parameter_04 2
                                  assert: "?"
                                  min: 0
                                  re: !!perl/hash:RE_noop 
                                    a: 0
                                    dba: parameter
                                    i: 0
                                    min: 0
                                    nobind: 1
                                    r: 1
                                    s: 0
                      - !!perl/hash:RE_sequence 
                        a: 0
                        alt: parameter_02 4
                        dba: parameter
                        i: 0
                        min: 0
                        r: 1
                        s: 0
                        zyg: 
                          - !!perl/hash:RE_assertion 
                            assert: "?"
                            min: 0
                            re: !!perl/hash:RE_noop 
                              a: 0
                              dba: parameter
                              i: 0
                              min: 0
                              nobind: 1
                              r: 1
                              s: 0
                          - !!perl/hash:RE_block 
                            a: 0
                            context: void
                            dba: parameter
                            i: 0
                            min: 0
                            r: 1
                            s: 0
                            text: " $quant = ''; $kind = '!' "
            - !!perl/hash:RE_sequence 
              a: 0
              alt: parameter_01 1
              dba: parameter
              i: 0
              min: 12346
              r: 1
              s: 0
              zyg: 
                - !!perl/hash:RE_string 
                  a: 0
                  dba: parameter
                  i: 0
                  min: 1
                  r: 1
                  s: 0
                  text: "*"
                - !!perl/hash:RE_method 
                  a: 0
                  dba: parameter
                  i: 0
                  min: 12345
                  name: param_var
                  r: 1
                  rest: ''
                  s: 0
                - !!perl/hash:RE_block 
                  a: 0
                  context: void
                  dba: parameter
                  i: 0
                  min: 0
                  r: 1
                  s: 0
                  text: " $quant = '*'; $kind = '*'; "
            - !!perl/hash:RE_sequence 
              a: 0
              alt: parameter_01 2
              dba: parameter
              i: 0
              min: 12346
              r: 1
              s: 0
              zyg: 
                - !!perl/hash:RE_string 
                  a: 0
                  dba: parameter
                  i: 0
                  min: 1
                  r: 1
                  s: 0
                  text: "|"
                - !!perl/hash:RE_method 
                  a: 0
                  dba: parameter
                  i: 0
                  min: 12345
                  name: param_var
                  r: 1
                  rest: ''
                  s: 0
                - !!perl/hash:RE_block 
                  a: 0
                  context: void
                  dba: parameter
                  i: 0
                  min: 0
                  r: 1
                  s: 0
                  text: " $quant = '|'; $kind = '*'; "
            - !!perl/hash:RE_sequence 
              a: 0
              alt: parameter_01 3
              dba: parameter
              i: 0
              min: 12346
              r: 1
              s: 0
              zyg: 
                - !!perl/hash:RE_string 
                  a: 0
                  dba: parameter
                  i: 0
                  min: 1
                  r: 1
                  s: 0
                  text: \
                - !!perl/hash:RE_method 
                  a: 0
                  dba: parameter
                  i: 0
                  min: 12345
                  name: param_var
                  r: 1
                  rest: ''
                  s: 0
                - !!perl/hash:RE_block 
                  a: 0
                  context: void
                  dba: parameter
                  i: 0
                  min: 0
                  r: 1
                  s: 0
                  text: " $quant = '\\\\'; $kind = '!'; "
            - !!perl/hash:RE_sequence 
              a: 0
              alt: parameter_01 4
              dba: parameter
              i: 0
              min: 12345
              r: 1
              s: 0
              zyg: 
                - !!perl/hash:RE_bracket 
                  decl: []

                  min: 12345
                  re: &10 !!perl/hash:RE_any 
                    a: 0
                    altname: parameter_05
                    dba: parameter
                    i: 0
                    min: 12345
                    name: parameter_05
                    r: 1
                    s: 0
                    zyg: 
                      - !!perl/hash:RE_sequence 
                        a: 0
                        alt: parameter_05 0
                        dba: parameter
                        i: 0
                        min: 12345
                        r: 1
                        s: 0
                        zyg: 
                          - !!perl/hash:RE_method 
                            a: 0
                            dba: parameter
                            i: 0
                            min: 12345
                            name: param_var
                            r: 1
                            rest: ''
                            s: 0
                          - !!perl/hash:RE_block 
                            a: 0
                            context: void
                            dba: parameter
                            i: 0
                            min: 0
                            r: 1
                            s: 0
                            text: " $quant = ''; $kind = '!'; "
                      - !!perl/hash:RE_sequence 
                        a: 0
                        alt: parameter_05 1
                        dba: parameter
                        i: 0
                        min: 12345
                        r: 1
                        s: 0
                        zyg: 
                          - !!perl/hash:RE_method 
                            a: 0
                            dba: parameter
                            i: 0
                            min: 12345
                            name: named_param
                            r: 1
                            rest: ''
                            s: 0
                          - !!perl/hash:RE_block 
                            a: 0
                            context: void
                            dba: parameter
                            i: 0
                            min: 0
                            r: 1
                            s: 0
                            text: " $quant = ''; $kind = '*'; "
                - !!perl/hash:RE_bracket 
                  decl: []

                  min: 0
                  re: &11 !!perl/hash:RE_any 
                    a: 0
                    altname: parameter_06
                    dba: parameter
                    i: 0
                    min: 0
                    name: parameter_06
                    r: 1
                    s: 0
                    zyg: 
                      - !!perl/hash:RE_sequence 
                        a: 0
                        alt: parameter_06 0
                        dba: parameter
                        i: 0
                        min: 1
                        r: 1
                        s: 0
                        zyg: 
                          - !!perl/hash:RE_string 
                            a: 0
                            dba: parameter
                            i: 0
                            min: 1
                            r: 1
                            s: 0
                            text: "?"
                          - !!perl/hash:RE_block 
                            a: 0
                            context: void
                            dba: parameter
                            i: 0
                            min: 0
                            r: 1
                            s: 0
                            text: " $quant = '?'; $kind = '?' "
                      - !!perl/hash:RE_sequence 
                        a: 0
                        alt: parameter_06 1
                        dba: parameter
                        i: 0
                        min: 1
                        r: 1
                        s: 0
                        zyg: 
                          - !!perl/hash:RE_string 
                            a: 0
                            dba: parameter
                            i: 0
                            min: 1
                            r: 1
                            s: 0
                            text: "!"
                          - !!perl/hash:RE_block 
                            a: 0
                            context: void
                            dba: parameter
                            i: 0
                            min: 0
                            r: 1
                            s: 0
                            text: " $quant = '!'; $kind //= '!' "
                      - !!perl/hash:RE_assertion 
                        alt: parameter_06 2
                        assert: "?"
                        min: 0
                        re: !!perl/hash:RE_noop 
                          a: 0
                          dba: parameter
                          i: 0
                          min: 0
                          nobind: 1
                          r: 1
                          s: 0
      - !!perl/hash:RE_quantified_atom 
        atom: !!perl/hash:RE_method 
          a: 0
          dba: parameter
          i: 0
          min: 12345
          name: trait
          r: 1
          rest: ''
          s: 0
        min: 0
        quant: 
          - "*"
          - ":"
          - ''
          - 0
      - !!perl/hash:RE_quantified_atom 
        atom: !!perl/hash:RE_method 
          a: 0
          dba: parameter
          i: 0
          min: 12345
          name: post_constraint
          r: 1
          rest: ''
          s: 0
        min: 0
        quant: 
          - "*"
          - ":"
          - ''
          - 0
      - !!perl/hash:RE_quantified_atom 
        atom: !!perl/hash:RE_bracket 
          decl: []

          min: 12345
          re: !!perl/hash:RE_sequence 
            a: 0
            dba: parameter
            i: 0
            min: 12345
            r: 1
            s: 0
            zyg: 
              - !!perl/hash:RE_method 
                a: 0
                dba: parameter
                i: 0
                min: 12345
                name: default_value
                r: 1
                rest: ''
                s: 0
              - !!perl/hash:RE_block 
                a: 0
                context: void
                dba: parameter
                i: 0
                min: 0
                r: 1
                s: 0
                text: "\n            given $quant {\n              when '!' { $¢.panic(\"Can't put a default on a required parameter\") }\n              when '*' { $¢.panic(\"Can't put a default on a slurpy parameter\") }\n              when '|' { $¢.panic(\"Can't put a default on an slurpy capture parameter\") }\n              when '\\\\' { $¢.panic(\"Can't put a default on a capture parameter\") }\n            }\n            $kind = '?' if $kind eq '!';\n        "
        min: 0
        quant: 
          - "?"
          - ":"
          - ''
          - 0
      - !!perl/hash:RE_block 
        a: 0
        context: void
        dba: parameter
        i: 0
        min: 0
        r: 1
        s: 0
        text: "\n        $<quant> = $quant;\n        $<kind> = $kind;\n    "
      - !!perl/hash:RE_block 
        a: 0
        context: void
        dba: parameter
        i: 0
        min: 0
        r: 1
        s: 0
        text: "\n        given $kind {\n            when '!' {\n                given $*zone {\n                    when 'posopt' {\n$¢.panic(\"Can't put required parameter after optional parameters\");\n                    }\n                    when 'var' {\n$¢.panic(\"Can't put required parameter after variadic parameters\");\n                    }\n                }\n            }\n            when '?' {\n                given $*zone {\n                    when 'posreq' { $*zone = 'posopt' }\n                    when 'var' {\n$¢.panic(\"Can't put optional positional parameter after variadic parameters\");\n                    }\n                }\n            }\n            when '*' {\n                $*zone = 'var';\n            }\n        }\n    "
parameter_01: *40
parameter_02: *58
parameter_03: *93
parameter_04: *112
parameter_05: *10
parameter_06: *11
pblock: !!perl/hash:RE 
  decl: []

  kind: token
  min: 24690
  pkg: ~
  re: !!perl/hash:RE_sequence 
    a: 0
    dba: parameterized block
    i: 0
    min: 24690
    r: 1
    s: 0
    zyg: 
      - !!perl/hash:RE_bracket 
        decl: []

        min: 0
        re: !!perl/hash:RE_first 
          a: 0
          dba: parameterized block
          i: 0
          min: 0
          r: 1
          s: 0
          zyg: 
            - !!perl/hash:RE_assertion 
              assert: "?"
              min: 0
              re: !!perl/hash:RE_method_re 
                a: 0
                dba: parameterized block
                i: 0
                min: 0
                name: before
                nobind: 1
                r: 1
                re: !!perl/hash:RE 
                  decl: []

                  min: 1
                  re: &68 !!perl/hash:RE_any 
                    a: 0
                    altname: pblock_02
                    dba: parameterized block
                    i: 0
                    min: 1
                    name: pblock_02
                    r: 1
                    s: 0
                    zyg: 
                      - !!perl/hash:RE_method 
                        a: 0
                        alt: pblock_02 0
                        dba: parameterized block
                        i: 0
                        min: 12345
                        name: lambda
                        nobind: 1
                        r: 1
                        rest: ''
                        s: 0
                      - !!perl/hash:RE_string 
                        a: 0
                        alt: pblock_02 1
                        dba: parameterized block
                        i: 0
                        min: 1
                        r: 1
                        s: 0
                        text: "{"
                s: 0
            - !!perl/hash:RE_block 
              a: 0
              context: void
              dba: parameterized block
              i: 0
              min: 0
              r: 1
              s: 0
              text: "\n            if $*BORG and $*BORG.<block> {\n                if $*BORG.<name> {\n                    my $m = \"Function '\" ~ $BORG.<name> ~ \"' needs parens to avoid gobbling block\" ~ $*BORG.<culprit>.locmess;\n                    $*BORG.<block>.panic($m ~ \"\\nMissing block (apparently gobbled by '\" ~ $BORG.<name> ~ \"')\");\n                }\n                else {\n                    my $m = \"Expression needs parens to avoid gobbling block\" ~ $*BORG.<culprit>.locmess;\n                    $*BORG.<block>.panic($m ~ \"\\nMissing block (apparently gobbled by expression)\");\n                }\n            }\n            elsif %*MYSTERY {\n                $¢.panic(\"Missing block (apparently gobbled by undeclared routine?)\");\n            }\n            else {\n                $¢.panic(\"Missing block\");\n            }\n        "
      - !!perl/hash:RE_bracket 
        decl: []

        min: 24690
        re: &69 !!perl/hash:RE_any 
          a: 0
          altname: pblock_04
          dba: parameterized block
          i: 0
          min: 24690
          name: pblock_04
          r: 1
          s: 0
          zyg: 
            - !!perl/hash:RE_sequence 
              a: 0
              alt: pblock_04 0
              dba: parameterized block
              i: 0
              min: 49380
              r: 1
              s: 0
              zyg: 
                - !!perl/hash:RE_method 
                  a: 0
                  dba: parameterized block
                  i: 0
                  min: 12345
                  name: lambda
                  r: 1
                  rest: ''
                  s: 0
                - !!perl/hash:RE_method 
                  a: 0
                  dba: parameterized block
                  i: 0
                  min: 12345
                  name: newpad
                  nobind: 1
                  r: 1
                  rest: ''
                  s: 0
                - !!perl/hash:RE_method 
                  a: 0
                  dba: parameterized block
                  i: 0
                  min: 12345
                  name: signature
                  r: 1
                  rest: ''
                  s: 0
                - !!perl/hash:RE_method 
                  a: 0
                  dba: parameterized block
                  i: 0
                  min: 12345
                  name: blockoid
                  r: 1
                  rest: ''
                  s: 0
            - !!perl/hash:RE_sequence 
              a: 0
              alt: pblock_04 1
              dba: parameterized block
              i: 0
              min: 24690
              r: 1
              s: 0
              zyg: 
                - !!perl/hash:RE_assertion 
                  assert: "?"
                  min: 0
                  re: !!perl/hash:RE_method_re 
                    a: 0
                    dba: parameterized block
                    i: 0
                    min: 0
                    name: before
                    nobind: 1
                    r: 1
                    re: !!perl/hash:RE 
                      decl: []

                      min: 1
                      re: !!perl/hash:RE_string 
                        a: 0
                        dba: parameterized block
                        i: 0
                        min: 1
                        r: 1
                        s: 0
                        text: "{"
                    s: 0
                - !!perl/hash:RE_method 
                  a: 0
                  dba: parameterized block
                  i: 0
                  min: 12345
                  name: newpad
                  nobind: 1
                  r: 1
                  rest: ''
                  s: 0
                - !!perl/hash:RE_method 
                  a: 0
                  dba: parameterized block
                  i: 0
                  min: 12345
                  name: blockoid
                  r: 1
                  rest: ''
                  s: 0
pblock_02: *68
pblock_04: *69
pod_comment: !!perl/hash:RE 
  decl: []

  kind: token
  min: 1
  pkg: ~
  re: !!perl/hash:RE_sequence 
    a: 0
    dba: pod_comment
    i: 0
    min: 1
    r: 1
    s: 0
    zyg: 
      - !!perl/hash:RE_meta 
        a: 0
        dba: pod_comment
        i: 0
        min: 0
        r: 1
        s: 0
        text: "^^"
      - !!perl/hash:RE_string 
        a: 0
        dba: pod_comment
        i: 0
        min: 1
        r: 1
        s: 0
        text: =
      - !!perl/hash:RE_quantified_atom 
        atom: !!perl/hash:RE_method 
          a: 0
          dba: pod_comment
          i: 0
          min: 12345
          name: unsp
          nobind: 1
          r: 1
          rest: ''
          s: 0
        min: 0
        quant: 
          - "?"
          - ":"
          - ''
          - 0
      - !!perl/hash:RE_bracket 
        decl: []

        min: 0
        re: &25 !!perl/hash:RE_any 
          a: 0
          altname: pod_comment_01
          dba: pod_comment
          i: 0
          min: 0
          name: pod_comment_01
          r: 1
          s: 0
          zyg: 
            - !!perl/hash:RE_sequence 
              a: 0
              alt: pod_comment_01 0
              dba: pod_comment
              i: 0
              min: 12351
              r: 1
              s: 0
              zyg: 
                - !!perl/hash:RE_string 
                  a: 0
                  dba: pod_comment
                  i: 0
                  min: 5
                  r: 1
                  s: 0
                  text: begin
                - !!perl/hash:RE_quantified_atom 
                  atom: !!perl/hash:RE_meta 
                    a: 0
                    dba: pod_comment
                    i: 0
                    min: 1
                    r: 1
                    s: 0
                    text: \h
                  min: 1
                  quant: 
                    - +
                    - ":"
                    - ''
                    - 1
                - !!perl/hash:RE_method 
                  a: 0
                  dba: pod_comment
                  i: 0
                  min: 12345
                  name: identifier
                  r: 1
                  rest: ''
                  s: 0
                - !!perl/hash:RE_meta 
                  a: 0
                  dba: pod_comment
                  i: 0
                  min: 0
                  r: 1
                  s: 0
                  text: "::"
                - !!perl/hash:RE_bracket 
                  decl: []

                  min: 0
                  re: !!perl/hash:RE_first 
                    a: 0
                    dba: pod_comment
                    i: 0
                    min: 0
                    r: 1
                    s: 0
                    zyg: 
                      - !!perl/hash:RE_sequence 
                        a: 0
                        dba: pod_comment
                        i: 0
                        min: 7
                        r: 1
                        s: 0
                        zyg: 
                          - !!perl/hash:RE_meta 
                            a: 0
                            dba: pod_comment
                            i: 0
                            min: 1
                            r: 1
                            s: 0
                            text: .*?
                          - !!perl/hash:RE_double 
                            a: 0
                            dba: pod_comment
                            i: 0
                            min: 2
                            r: 1
                            s: 0
                            text: \n=
                          - !!perl/hash:RE_quantified_atom 
                            atom: !!perl/hash:RE_method 
                              a: 0
                              dba: pod_comment
                              i: 0
                              min: 12345
                              name: unsp
                              nobind: 1
                              r: 1
                              rest: ''
                              s: 0
                            min: 0
                            quant: 
                              - "?"
                              - ":"
                              - ''
                              - 0
                          - !!perl/hash:RE_string 
                            a: 0
                            dba: pod_comment
                            i: 0
                            min: 3
                            r: 1
                            s: 0
                            text: end
                          - !!perl/hash:RE_quantified_atom 
                            atom: !!perl/hash:RE_meta 
                              a: 0
                              dba: pod_comment
                              i: 0
                              min: 1
                              r: 1
                              s: 0
                              text: \h
                            min: 1
                            quant: 
                              - +
                              - ":"
                              - ''
                              - 1
                          - !!perl/hash:RE_var 
                            a: 0
                            dba: pod_comment
                            i: 0
                            min: 0
                            r: 1
                            s: 0
                            var: $<identifier>
                          - !!perl/hash:RE_meta 
                            a: 0
                            dba: pod_comment
                            i: 0
                            min: 0
                            r: 1
                            s: 0
                            text: »
                          - !!perl/hash:RE_quantified_atom 
                            atom: !!perl/hash:RE_meta 
                              a: 0
                              dba: pod_comment
                              i: 0
                              min: 1
                              r: 1
                              s: 0
                              text: \N
                            min: 0
                            quant: 
                              - "*"
                              - ":"
                              - ''
                              - 0
                          - !!perl/hash:RE_method_internal 
                            args: $S, 'pod_comment', 'tagged'
                            max: 0
                            min: 0
                            name: _REDUCE
                      - !!perl/hash:RE_sequence 
                        a: 0
                        dba: pod_comment
                        i: 0
                        min: 1
                        r: 1
                        s: 0
                        zyg: 
                          - !!perl/hash:RE_assertion 
                            assert: "?"
                            min: 0
                            re: !!perl/hash:RE_block 
                              a: 0
                              context: bool
                              dba: pod_comment
                              i: 0
                              min: 0
                              nobind: 1
                              r: 1
                              s: 0
                              text: " $<identifier>.Str eq 'END'"
                          - !!perl/hash:RE_meta 
                            a: 0
                            dba: pod_comment
                            i: 0
                            min: 1
                            r: 1
                            s: 0
                            text: .*
                          - !!perl/hash:RE_method_internal 
                            args: $S, 'pod_comment', 'end'
                            max: 0
                            min: 0
                            name: _REDUCE
                      - !!perl/hash:RE_block 
                        a: 0
                        context: void
                        dba: pod_comment
                        i: 0
                        min: 0
                        r: 1
                        s: 0
                        text: " my $id = $<identifier>.Str; self.panic(\"=begin $id without matching =end $id\"); "
            - !!perl/hash:RE_sequence 
              a: 0
              alt: pod_comment_01 1
              dba: pod_comment
              i: 0
              min: 5
              r: 1
              s: 0
              zyg: 
                - !!perl/hash:RE_string 
                  a: 0
                  dba: pod_comment
                  i: 0
                  min: 5
                  r: 1
                  s: 0
                  text: begin
                - !!perl/hash:RE_meta 
                  a: 0
                  dba: pod_comment
                  i: 0
                  min: 0
                  r: 1
                  s: 0
                  text: »
                - !!perl/hash:RE_meta 
                  a: 0
                  dba: pod_comment
                  i: 0
                  min: 0
                  r: 1
                  s: 0
                  text: "::"
                - !!perl/hash:RE_quantified_atom 
                  atom: !!perl/hash:RE_meta 
                    a: 0
                    dba: pod_comment
                    i: 0
                    min: 1
                    r: 1
                    s: 0
                    text: \h
                  min: 0
                  quant: 
                    - "*"
                    - ":"
                    - ''
                    - 0
                - !!perl/hash:RE_bracket 
                  decl: []

                  min: 0
                  re: !!perl/hash:RE_first 
                    a: 0
                    dba: pod_comment
                    i: 0
                    min: 0
                    r: 1
                    s: 0
                    zyg: 
                      - !!perl/hash:RE_meta 
                        a: 0
                        dba: pod_comment
                        i: 0
                        min: 0
                        r: 1
                        s: 0
                        text: $$
                      - !!perl/hash:RE_string 
                        a: 0
                        dba: pod_comment
                        i: 0
                        min: 1
                        r: 1
                        s: 0
                        text: "#"
                      - !!perl/hash:RE_method 
                        min: 0
                        name: panic
                        nobind: 1
                        rest: ("Unrecognized token after =begin")
                - !!perl/hash:RE_bracket 
                  decl: []

                  min: 0
                  re: !!perl/hash:RE_first 
                    a: 0
                    dba: pod_comment
                    i: 0
                    min: 0
                    r: 1
                    s: 0
                    zyg: 
                      - !!perl/hash:RE_sequence 
                        a: 0
                        dba: pod_comment
                        i: 0
                        min: 6
                        r: 1
                        s: 0
                        zyg: 
                          - !!perl/hash:RE_meta 
                            a: 0
                            dba: pod_comment
                            i: 0
                            min: 1
                            r: 1
                            s: 0
                            text: .*?
                          - !!perl/hash:RE_double 
                            a: 0
                            dba: pod_comment
                            i: 0
                            min: 2
                            r: 1
                            s: 0
                            text: \n=
                          - !!perl/hash:RE_quantified_atom 
                            atom: !!perl/hash:RE_method 
                              a: 0
                              dba: pod_comment
                              i: 0
                              min: 12345
                              name: unsp
                              nobind: 1
                              r: 1
                              rest: ''
                              s: 0
                            min: 0
                            quant: 
                              - "?"
                              - ":"
                              - ''
                              - 0
                          - !!perl/hash:RE_string 
                            a: 0
                            dba: pod_comment
                            i: 0
                            min: 3
                            r: 1
                            s: 0
                            text: end
                          - !!perl/hash:RE_meta 
                            a: 0
                            dba: pod_comment
                            i: 0
                            min: 0
                            r: 1
                            s: 0
                            text: »
                          - !!perl/hash:RE_quantified_atom 
                            atom: !!perl/hash:RE_meta 
                              a: 0
                              dba: pod_comment
                              i: 0
                              min: 1
                              r: 1
                              s: 0
                              text: \N
                            min: 0
                            quant: 
                              - "*"
                              - ":"
                              - ''
                              - 0
                      - !!perl/hash:RE_block 
                        a: 0
                        context: void
                        dba: pod_comment
                        i: 0
                        min: 0
                        r: 1
                        s: 0
                        text: " self.panic(\"=begin without matching =end\"); "
                - !!perl/hash:RE_method_internal 
                  args: $S, 'pod_comment', 'anon'
                  max: 0
                  min: 0
                  name: _REDUCE
            - !!perl/hash:RE_sequence 
              a: 0
              alt: pod_comment_01 2
              dba: pod_comment
              i: 0
              min: 4
              r: 1
              s: 0
              zyg: 
                - !!perl/hash:RE_string 
                  a: 0
                  dba: pod_comment
                  i: 0
                  min: 3
                  r: 1
                  s: 0
                  text: for
                - !!perl/hash:RE_meta 
                  a: 0
                  dba: pod_comment
                  i: 0
                  min: 0
                  r: 1
                  s: 0
                  text: »
                - !!perl/hash:RE_meta 
                  a: 0
                  dba: pod_comment
                  i: 0
                  min: 0
                  r: 1
                  s: 0
                  text: "::"
                - !!perl/hash:RE_quantified_atom 
                  atom: !!perl/hash:RE_meta 
                    a: 0
                    dba: pod_comment
                    i: 0
                    min: 1
                    r: 1
                    s: 0
                    text: \h
                  min: 0
                  quant: 
                    - "*"
                    - ":"
                    - ''
                    - 0
                - !!perl/hash:RE_bracket 
                  decl: []

                  min: 0
                  re: !!perl/hash:RE_first 
                    a: 0
                    dba: pod_comment
                    i: 0
                    min: 0
                    r: 1
                    s: 0
                    zyg: 
                      - !!perl/hash:RE_method 
                        a: 0
                        dba: pod_comment
                        i: 0
                        min: 12345
                        name: identifier
                        r: 1
                        rest: ''
                        s: 0
                      - !!perl/hash:RE_meta 
                        a: 0
                        dba: pod_comment
                        i: 0
                        min: 0
                        r: 1
                        s: 0
                        text: $$
                      - !!perl/hash:RE_string 
                        a: 0
                        dba: pod_comment
                        i: 0
                        min: 1
                        r: 1
                        s: 0
                        text: "#"
                      - !!perl/hash:RE_method 
                        min: 0
                        name: panic
                        nobind: 1
                        rest: ("Unrecognized token after =for")
                - !!perl/hash:RE_bracket 
                  decl: []

                  min: 1
                  re: !!perl/hash:RE_first 
                    a: 0
                    dba: pod_comment
                    i: 0
                    min: 1
                    r: 1
                    s: 0
                    zyg: 
                      - !!perl/hash:RE_sequence 
                        a: 0
                        dba: pod_comment
                        i: 0
                        min: 1
                        r: 1
                        s: 0
                        zyg: 
                          - !!perl/hash:RE_meta 
                            a: 0
                            dba: pod_comment
                            i: 0
                            min: 1
                            r: 1
                            s: 0
                            text: .*?
                          - !!perl/hash:RE_meta 
                            a: 0
                            dba: pod_comment
                            i: 0
                            min: 0
                            r: 1
                            s: 0
                            text: "^^"
                          - !!perl/hash:RE_quantified_atom 
                            atom: !!perl/hash:RE_meta 
                              a: 0
                              dba: pod_comment
                              i: 0
                              min: 1
                              r: 1
                              s: 0
                              text: \h
                            min: 0
                            quant: 
                              - "*"
                              - ":"
                              - ''
                              - 0
                          - !!perl/hash:RE_meta 
                            a: 0
                            dba: pod_comment
                            i: 0
                            min: 0
                            r: 1
                            s: 0
                            text: $$
                      - !!perl/hash:RE_meta 
                        a: 0
                        dba: pod_comment
                        i: 0
                        min: 1
                        r: 1
                        s: 0
                        text: .*
            - !!perl/hash:RE_sequence 
              a: 0
              alt: pod_comment_01 3
              dba: pod_comment
              i: 0
              min: 0
              r: 1
              s: 0
              zyg: 
                - !!perl/hash:RE_meta 
                  a: 0
                  dba: pod_comment
                  i: 0
                  min: 0
                  r: 1
                  s: 0
                  text: "::"
                - !!perl/hash:RE_quantified_atom 
                  atom: !!perl/hash:RE_bracket 
                    decl: []

                    min: 0
                    re: !!perl/hash:RE_sequence 
                      a: 0
                      dba: pod_comment
                      i: 0
                      min: 0
                      r: 1
                      s: 0
                      zyg: 
                        - !!perl/hash:RE_assertion 
                          assert: "?"
                          min: 0
                          re: !!perl/hash:RE_method_re 
                            a: 0
                            dba: pod_comment
                            i: 0
                            min: 0
                            name: before
                            nobind: 1
                            r: 1
                            re: !!perl/hash:RE 
                              decl: []

                              min: 5
                              re: !!perl/hash:RE_sequence 
                                a: 0
                                dba: pod_comment
                                i: 0
                                min: 5
                                r: 1
                                s: 0
                                zyg: 
                                  - !!perl/hash:RE_meta 
                                    a: 0
                                    dba: pod_comment
                                    i: 0
                                    min: 1
                                    r: 1
                                    s: 0
                                    text: .*?
                                  - !!perl/hash:RE_meta 
                                    a: 0
                                    dba: pod_comment
                                    i: 0
                                    min: 0
                                    r: 1
                                    s: 0
                                    text: "^^"
                                  - !!perl/hash:RE_string 
                                    a: 0
                                    dba: pod_comment
                                    i: 0
                                    min: 4
                                    r: 1
                                    s: 0
                                    text: =cut
                                  - !!perl/hash:RE_meta 
                                    a: 0
                                    dba: pod_comment
                                    i: 0
                                    min: 0
                                    r: 1
                                    s: 0
                                    text: »
                            s: 0
                        - !!perl/hash:RE_method 
                          min: 0
                          name: panic
                          nobind: 1
                          rest: ("Obsolete pod format, please use =begin/=end instead")
                  min: 0
                  quant: 
                    - "?"
                    - ":"
                    - ''
                    - 0
                - !!perl/hash:RE_bracket 
                  decl: []

                  min: 0
                  re: !!perl/hash:RE_first 
                    a: 0
                    dba: pod_comment
                    i: 0
                    min: 0
                    r: 1
                    s: 0
                    zyg: 
                      - !!perl/hash:RE_method 
                        a: 0
                        dba: pod_comment
                        i: 0
                        min: 12345
                        name: alpha
                        r: 1
                        rest: ''
                        s: 0
                      - !!perl/hash:RE_meta 
                        a: 0
                        dba: pod_comment
                        i: 0
                        min: 1
                        r: 1
                        s: 0
                        text: \s
                      - !!perl/hash:RE_method 
                        min: 0
                        name: panic
                        nobind: 1
                        rest: ("Illegal pod directive")
                - !!perl/hash:RE_quantified_atom 
                  atom: !!perl/hash:RE_meta 
                    a: 0
                    dba: pod_comment
                    i: 0
                    min: 1
                    r: 1
                    s: 0
                    text: \N
                  min: 0
                  quant: 
                    - "*"
                    - ":"
                    - ''
                    - 0
                - !!perl/hash:RE_method_internal 
                  args: $S, 'pod_comment', 'misc'
                  max: 0
                  min: 0
                  name: _REDUCE
pod_comment_01: *25
post_constraint: !!perl/hash:RE 
  decl: []

  kind: rule
  min: 5
  pkg: ~
  re: !!perl/hash:RE_sequence 
    a: 0
    dba: constraint
    i: 0
    min: 5
    r: 1
    s: 1
    zyg: 
      - !!perl/hash:RE_method 
        min: 0
        name: ws
        nobind: 1
        noquant: 1
        rest: ''
      - !!perl/hash:RE_method 
        min: 0
        name: ws
        nobind: 1
        noquant: 1
        rest: ''
      - !!perl/hash:RE_bracket 
        decl: []

        min: 5
        re: &85 !!perl/hash:RE_any 
          a: 0
          altname: post_constraint_01
          dba: constraint
          i: 0
          min: 5
          name: post_constraint_01
          r: 1
          s: 1
          zyg: 
            - !!perl/hash:RE_sequence 
              a: 0
              alt: post_constraint_01 0
              dba: constraint
              i: 0
              min: 12347
              r: 1
              s: 1
              zyg: 
                - !!perl/hash:RE_string 
                  a: 0
                  dba: constraint
                  i: 0
                  min: 1
                  r: 1
                  s: 1
                  text: "["
                - !!perl/hash:RE_method 
                  min: 0
                  name: ws
                  nobind: 1
                  noquant: 1
                  rest: ''
                - !!perl/hash:RE_meta 
                  a: 0
                  dba: constraint
                  extra: local $::GOAL = ']'
                  i: 0
                  min: 0
                  r: 1
                  s: 1
                  text: "::"
                - !!perl/hash:RE_method 
                  a: 0
                  dba: constraint
                  i: 0
                  min: 12345
                  name: signature
                  r: 1
                  rest: ''
                  s: 1
                - !!perl/hash:RE_bracket 
                  decl: []

                  min: 1
                  re: !!perl/hash:RE_first 
                    a: 0
                    dba: constraint
                    i: 0
                    min: 1
                    r: 1
                    s: 1
                    zyg: 
                      - !!perl/hash:RE_string 
                        a: 0
                        dba: constraint
                        i: 0
                        min: 1
                        r: 1
                        s: 1
                        text: "]"
                      - !!perl/hash:RE_method 
                        min: 0
                        name: FAILGOAL
                        nobind: 1
                        rest: (']', 'constraint')
                - !!perl/hash:RE_method 
                  min: 0
                  name: ws
                  nobind: 1
                  noquant: 1
                  rest: ''
            - !!perl/hash:RE_sequence 
              a: 0
              alt: post_constraint_01 1
              dba: constraint
              i: 0
              min: 12347
              r: 1
              s: 1
              zyg: 
                - !!perl/hash:RE_string 
                  a: 0
                  dba: constraint
                  i: 0
                  min: 1
                  r: 1
                  s: 1
                  text: (
                - !!perl/hash:RE_method 
                  min: 0
                  name: ws
                  nobind: 1
                  noquant: 1
                  rest: ''
                - !!perl/hash:RE_meta 
                  a: 0
                  dba: constraint
                  extra: local $::GOAL = ')'
                  i: 0
                  min: 0
                  r: 1
                  s: 1
                  text: "::"
                - !!perl/hash:RE_method 
                  a: 0
                  dba: constraint
                  i: 0
                  min: 12345
                  name: signature
                  r: 1
                  rest: ''
                  s: 1
                - !!perl/hash:RE_bracket 
                  decl: []

                  min: 1
                  re: !!perl/hash:RE_first 
                    a: 0
                    dba: constraint
                    i: 0
                    min: 1
                    r: 1
                    s: 1
                    zyg: 
                      - !!perl/hash:RE_string 
                        a: 0
                        dba: constraint
                        i: 0
                        min: 1
                        r: 1
                        s: 1
                        text: )
                      - !!perl/hash:RE_method 
                        min: 0
                        name: FAILGOAL
                        nobind: 1
                        rest: (')', 'constraint')
                - !!perl/hash:RE_method 
                  min: 0
                  name: ws
                  nobind: 1
                  noquant: 1
                  rest: ''
            - !!perl/hash:RE_sequence 
              a: 0
              alt: post_constraint_01 2
              dba: constraint
              i: 0
              min: 5
              r: 1
              s: 1
              zyg: 
                - !!perl/hash:RE_string 
                  a: 0
                  dba: constraint
                  i: 0
                  min: 5
                  r: 1
                  s: 1
                  text: where
                - !!perl/hash:RE_method 
                  min: 0
                  name: ws
                  nobind: 1
                  noquant: 1
                  rest: ''
                - !!perl/hash:RE_method 
                  min: 0
                  name: EXPR
                  rest: (item %chaining)
                - !!perl/hash:RE_method 
                  min: 0
                  name: ws
                  nobind: 1
                  noquant: 1
                  rest: ''
      - !!perl/hash:RE_method 
        min: 0
        name: ws
        nobind: 1
        noquant: 1
        rest: ''
post_constraint_01: *85
postcircumfix__S_293Paren_Thesis: !!perl/hash:RE 
  decl: []

  kind: token
  min: 12347
  pkg: STD::Methodcall
  re: !!perl/hash:RE_sequence 
    a: 0
    dba: argument list
    i: 0
    min: 12347
    r: 1
    s: 0
    zyg: 
      - !!perl/hash:RE_string 
        a: 0
        dba: argument list
        i: 0
        min: 1
        r: 1
        s: 0
        text: (
      - !!perl/hash:RE_meta 
        a: 0
        dba: argument list
        extra: "local $::GOAL = ')' "
        i: 0
        min: 0
        r: 1
        s: 0
        text: "::"
      - !!perl/hash:RE_method 
        a: 0
        dba: argument list
        i: 0
        min: 12345
        name: semiarglist
        r: 1
        rest: ''
        s: 0
      - !!perl/hash:RE_bracket 
        decl: []

        min: 1
        re: !!perl/hash:RE_first 
          a: 0
          dba: argument list
          i: 0
          min: 1
          r: 1
          s: 0
          zyg: 
            - !!perl/hash:RE_string 
              a: 0
              dba: argument list
              i: 0
              min: 1
              r: 1
              s: 0
              text: )
            - !!perl/hash:RE_method 
              min: 0
              name: FAILGOAL
              nobind: 1
              rest: (')' , 'argument list')
postcircumfix__S_294Bra_Ket: !!perl/hash:RE 
  decl: []

  kind: token
  min: 12347
  pkg: STD::Methodcall
  re: !!perl/hash:RE_sequence 
    a: 0
    dba: subscript
    i: 0
    min: 12347
    r: 1
    s: 0
    zyg: 
      - !!perl/hash:RE_string 
        a: 0
        dba: subscript
        i: 0
        min: 1
        r: 1
        s: 0
        text: "["
      - !!perl/hash:RE_meta 
        a: 0
        dba: subscript
        extra: "local $::GOAL = ']' "
        i: 0
        min: 0
        r: 1
        s: 0
        text: "::"
      - !!perl/hash:RE_method 
        a: 0
        dba: subscript
        i: 0
        min: 12345
        name: semilist
        r: 1
        rest: ''
        s: 0
      - !!perl/hash:RE_bracket 
        decl: []

        min: 1
        re: !!perl/hash:RE_first 
          a: 0
          dba: subscript
          i: 0
          min: 1
          r: 1
          s: 0
          zyg: 
            - !!perl/hash:RE_string 
              a: 0
              dba: subscript
              i: 0
              min: 1
              r: 1
              s: 0
              text: "]"
            - !!perl/hash:RE_method 
              min: 0
              name: FAILGOAL
              nobind: 1
              rest: (']' , 'subscript')
      - !!perl/hash:RE_block 
        a: 0
        context: void
        dba: subscript
        i: 0
        min: 0
        r: 1
        s: 0
        text: " $<semilist>.Str ~~ /^\\s*\\-[1]\\s*$/ and $¢.obs(\"[-1] subscript to access final element\",\"[*-1]\") "
postcircumfix__S_295Cur_Ly: !!perl/hash:RE 
  decl: []

  kind: token
  min: 12347
  pkg: STD::Methodcall
  re: !!perl/hash:RE_sequence 
    a: 0
    dba: subscript
    i: 0
    min: 12347
    r: 1
    s: 0
    zyg: 
      - !!perl/hash:RE_string 
        a: 0
        dba: subscript
        i: 0
        min: 1
        r: 1
        s: 0
        text: "{"
      - !!perl/hash:RE_meta 
        a: 0
        dba: subscript
        extra: "local $::GOAL = '}' "
        i: 0
        min: 0
        r: 1
        s: 0
        text: "::"
      - !!perl/hash:RE_method 
        a: 0
        dba: subscript
        i: 0
        min: 12345
        name: semilist
        r: 1
        rest: ''
        s: 0
      - !!perl/hash:RE_bracket 
        decl: []

        min: 1
        re: !!perl/hash:RE_first 
          a: 0
          dba: subscript
          i: 0
          min: 1
          r: 1
          s: 0
          zyg: 
            - !!perl/hash:RE_string 
              a: 0
              dba: subscript
              i: 0
              min: 1
              r: 1
              s: 0
              text: "}"
            - !!perl/hash:RE_method 
              min: 0
              name: FAILGOAL
              nobind: 1
              rest: ('}' , 'subscript')
postcircumfix__S_296Lt_Gt: !!perl/hash:RE 
  decl: []

  kind: token
  min: 1
  pkg: STD::Methodcall
  re: !!perl/hash:RE_sequence 
    a: 0
    dba: postcircumfix__S_296Lt_Gt
    i: 0
    min: 1
    r: 1
    s: 0
    zyg: 
      - !!perl/hash:RE_string 
        a: 0
        dba: postcircumfix__S_296Lt_Gt
        i: 0
        min: 1
        r: 1
        s: 0
        text: <
      - !!perl/hash:RE_method 
        min: 0
        name: nibble
        rest: ($¢.cursor_fresh( %*LANG<Q> ).tweak(:q).tweak(:w).balanced('<','>'))
      - !!perl/hash:RE_bracket 
        decl: []

        min: 0
        re: !!perl/hash:RE_first 
          a: 0
          dba: postcircumfix__S_296Lt_Gt
          i: 0
          min: 0
          r: 1
          s: 0
          zyg: 
            - !!perl/hash:RE_string 
              a: 0
              dba: postcircumfix__S_296Lt_Gt
              i: 0
              min: 1
              r: 1
              s: 0
              text: ">"
            - !!perl/hash:RE_method 
              min: 0
              name: panic
              nobind: 1
              rest: ("Unable to parse quote-words subscript; couldn't find right angle quote")
postcircumfix__S_297LtLt_GtGt: !!perl/hash:RE 
  decl: []

  kind: token
  min: 2
  pkg: STD::Methodcall
  re: !!perl/hash:RE_sequence 
    a: 0
    dba: postcircumfix__S_297LtLt_GtGt
    i: 0
    min: 2
    r: 1
    s: 0
    zyg: 
      - !!perl/hash:RE_string 
        a: 0
        dba: postcircumfix__S_297LtLt_GtGt
        i: 0
        min: 2
        r: 1
        s: 0
        text: <<
      - !!perl/hash:RE_method 
        min: 0
        name: nibble
        rest: ($¢.cursor_fresh( %*LANG<Q> ).tweak(:qq).tweak(:ww).balanced('<<','>>'))
      - !!perl/hash:RE_bracket 
        decl: []

        min: 0
        re: !!perl/hash:RE_first 
          a: 0
          dba: postcircumfix__S_297LtLt_GtGt
          i: 0
          min: 0
          r: 1
          s: 0
          zyg: 
            - !!perl/hash:RE_string 
              a: 0
              dba: postcircumfix__S_297LtLt_GtGt
              i: 0
              min: 2
              r: 1
              s: 0
              text: ">>"
            - !!perl/hash:RE_method 
              min: 0
              name: panic
              nobind: 1
              rest: ("Unable to parse quote-words subscript; couldn't find right double-angle quote")
postcircumfix__S_298Fre_Nch: !!perl/hash:RE 
  decl: []

  kind: token
  min: 1
  pkg: STD::Methodcall
  re: !!perl/hash:RE_sequence 
    a: 0
    dba: postcircumfix__S_298Fre_Nch
    i: 0
    min: 1
    r: 1
    s: 0
    zyg: 
      - !!perl/hash:RE_string 
        a: 0
        dba: postcircumfix__S_298Fre_Nch
        i: 0
        min: 1
        r: 1
        s: 0
        text: «
      - !!perl/hash:RE_method 
        min: 0
        name: nibble
        rest: ($¢.cursor_fresh( %*LANG<Q> ).tweak(:qq).tweak(:ww).balanced('«','»'))
      - !!perl/hash:RE_bracket 
        decl: []

        min: 0
        re: !!perl/hash:RE_first 
          a: 0
          dba: postcircumfix__S_298Fre_Nch
          i: 0
          min: 0
          r: 1
          s: 0
          zyg: 
            - !!perl/hash:RE_string 
              a: 0
              dba: postcircumfix__S_298Fre_Nch
              i: 0
              min: 1
              r: 1
              s: 0
              text: »
            - !!perl/hash:RE_method 
              min: 0
              name: panic
              nobind: 1
              rest: ("Unable to parse quote-words subscript; couldn't find right double-angle quote")
postfix__S_301i: !!perl/hash:RE 
  decl: []

  kind: token
  min: 12345
  pkg: STD::Methodcall
  re: !!perl/hash:RE_sequence 
    a: 0
    dba: postfix__S_301i
    i: 0
    min: 12345
    r: 1
    s: 0
    zyg: 
      - !!perl/hash:RE_method 
        a: 0
        dba: postfix__S_301i
        i: 0
        min: 12345
        name: sym
        r: 1
        rest: ''
        s: 0
        sym: i
      - !!perl/hash:RE_meta 
        a: 0
        dba: postfix__S_301i
        i: 0
        min: 0
        r: 1
        s: 0
        text: »
postfix__S_303MinusGt: !!perl/hash:RE 
  decl: []

  kind: token
  min: 2
  pkg: ~
  re: !!perl/hash:RE_sequence 
    a: 0
    dba: postfix__S_303MinusGt
    i: 0
    min: 2
    r: 1
    s: 0
    zyg: 
      - !!perl/hash:RE_string 
        a: 0
        dba: postfix__S_303MinusGt
        i: 0
        min: 2
        r: 1
        s: 0
        text: ->
      - !!perl/hash:RE_method 
        min: 0
        name: obs
        nobind: 1
        rest: ('-> to call a method', '.')
postfix__S_304PlusPlus: !!perl/hash:RE 
  decl: []

  kind: token
  min: 12345
  pkg: STD::Autoincrement
  re: !!perl/hash:RE_method 
    a: 0
    dba: postfix__S_304PlusPlus
    i: 0
    min: 12345
    name: sym
    r: 1
    rest: ''
    s: 0
    sym: ++
postfix__S_305MinusMinus: !!perl/hash:RE 
  decl: []

  kind: token
  min: 12345
  pkg: STD::Autoincrement
  re: !!perl/hash:RE_method 
    a: 0
    dba: postfix__S_305MinusMinus
    i: 0
    min: 12345
    name: sym
    r: 1
    rest: ''
    s: 0
    sym: --
postfix_prefix_meta_operator__S_286Nch: !!perl/hash:RE 
  decl: []

  kind: token
  min: 2
  pkg: ~
  re: !!perl/hash:RE_sequence 
    a: 0
    dba: postfix_prefix_meta_operator__S_286Nch
    i: 0
    min: 2
    r: 1
    s: 0
    zyg: 
      - !!perl/hash:RE_bracket 
        decl: []

        min: 2
        re: &52 !!perl/hash:RE_any 
          a: 0
          altname: postfix_prefix_meta_operator__S_286Nch_01
          dba: postfix_prefix_meta_operator__S_286Nch
          i: 0
          min: 2
          name: postfix_prefix_meta_operator__S_286Nch_01
          r: 1
          s: 0
          zyg: 
            - !!perl/hash:RE_method 
              a: 0
              alt: postfix_prefix_meta_operator__S_286Nch_01 0
              dba: postfix_prefix_meta_operator__S_286Nch
              i: 0
              min: 12345
              name: sym
              r: 1
              rest: ''
              s: 0
              sym: »
            - !!perl/hash:RE_string 
              a: 0
              alt: postfix_prefix_meta_operator__S_286Nch_01 1
              dba: postfix_prefix_meta_operator__S_286Nch
              i: 0
              min: 2
              r: 1
              s: 0
              text: ">>"
      - !!perl/hash:RE_bracket 
        decl: []

        min: 0
        re: !!perl/hash:RE_first 
          a: 0
          dba: postfix_prefix_meta_operator__S_286Nch
          i: 0
          min: 0
          r: 1
          s: 0
          zyg: 
            - !!perl/hash:RE_assertion 
              assert: "!"
              min: 0
              re: !!perl/hash:RE_block 
                a: 0
                context: bool
                dba: postfix_prefix_meta_operator__S_286Nch
                i: 0
                min: 0
                nobind: 1
                r: 1
                s: 0
                text: " $*QSIGIL "
            - !!perl/hash:RE_assertion 
              assert: "!"
              min: 0
              re: !!perl/hash:RE_method_re 
                a: 0
                dba: postfix_prefix_meta_operator__S_286Nch
                i: 0
                min: 0
                name: before
                nobind: 1
                r: 1
                re: !!perl/hash:RE 
                  decl: []

                  min: 1
                  re: !!perl/hash:RE_string 
                    a: 0
                    dba: postfix_prefix_meta_operator__S_286Nch
                    i: 0
                    min: 1
                    r: 1
                    s: 0
                    text: (
                s: 0
postfix_prefix_meta_operator__S_286Nch_01: *52
postop: !!perl/hash:RE 
  decl: []

  kind: token
  min: 12345
  pkg: ~
  re: &13 !!perl/hash:RE_any 
    a: 0
    altname: postop_00
    dba: postop
    i: 0
    min: 12345
    name: postop_00
    r: 1
    s: 0
    zyg: 
      - !!perl/hash:RE_sequence 
        a: 0
        alt: postop_00 0
        dba: postop
        i: 0
        min: 12345
        r: 1
        s: 0
        zyg: 
          - !!perl/hash:RE_method 
            a: 0
            dba: postop
            i: 0
            min: 12345
            name: postfix
            r: 1
            rest: ''
            s: 0
          - !!perl/hash:RE_block 
            a: 0
            context: void
            dba: postop
            i: 0
            min: 0
            r: 1
            s: 0
            text: " $<O> := $<postfix><O>; $<sym> := $<postfix><sym>; "
      - !!perl/hash:RE_sequence 
        a: 0
        alt: postop_00 1
        dba: postop
        i: 0
        min: 12345
        r: 1
        s: 0
        zyg: 
          - !!perl/hash:RE_method 
            a: 0
            dba: postop
            i: 0
            min: 12345
            name: postcircumfix
            r: 1
            rest: ''
            s: 0
          - !!perl/hash:RE_block 
            a: 0
            context: void
            dba: postop
            i: 0
            min: 0
            r: 1
            s: 0
            text: " $<O> := $<postcircumfix><O>; $<sym> := $<postcircumfix><sym>; "
postop_00: *13
prefix__S_306PlusPlus: !!perl/hash:RE 
  decl: []

  kind: token
  min: 12345
  pkg: STD::Autoincrement
  re: !!perl/hash:RE_method 
    a: 0
    dba: prefix__S_306PlusPlus
    i: 0
    min: 12345
    name: sym
    r: 1
    rest: ''
    s: 0
    sym: ++
prefix__S_307MinusMinus: !!perl/hash:RE 
  decl: []

  kind: token
  min: 12345
  pkg: STD::Autoincrement
  re: !!perl/hash:RE_method 
    a: 0
    dba: prefix__S_307MinusMinus
    i: 0
    min: 12345
    name: sym
    r: 1
    rest: ''
    s: 0
    sym: --
prefix__S_309Bang: !!perl/hash:RE 
  decl: []

  kind: token
  min: 12345
  pkg: STD::Symbolic_unary
  re: !!perl/hash:RE_method 
    a: 0
    dba: prefix__S_309Bang
    i: 0
    min: 12345
    name: sym
    r: 1
    rest: ''
    s: 0
    sym: "!"
prefix__S_310Plus: !!perl/hash:RE 
  decl: []

  kind: token
  min: 12345
  pkg: STD::Symbolic_unary
  re: !!perl/hash:RE_method 
    a: 0
    dba: prefix__S_310Plus
    i: 0
    min: 12345
    name: sym
    r: 1
    rest: ''
    s: 0
    sym: +
prefix__S_311Minus: !!perl/hash:RE 
  decl: []

  kind: token
  min: 12345
  pkg: STD::Symbolic_unary
  re: !!perl/hash:RE_method 
    a: 0
    dba: prefix__S_311Minus
    i: 0
    min: 12345
    name: sym
    r: 1
    rest: ''
    s: 0
    sym: "-"
prefix__S_312TildeTilde: !!perl/hash:RE 
  decl: []

  kind: token
  min: 24690
  pkg: STD::Symbolic_unary
  re: !!perl/hash:RE_sequence 
    a: 0
    dba: prefix__S_312TildeTilde
    i: 0
    min: 24690
    r: 1
    s: 0
    zyg: 
      - !!perl/hash:RE_method 
        a: 0
        dba: prefix__S_312TildeTilde
        i: 0
        min: 12345
        name: sym
        r: 1
        rest: ''
        s: 0
        sym: ~~
      - !!perl/hash:RE_method 
        a: 0
        dba: prefix__S_312TildeTilde
        i: 0
        min: 12345
        name: badinfix
        nobind: 1
        r: 1
        rest: ''
        s: 0
prefix__S_313Tilde: !!perl/hash:RE 
  decl: []

  kind: token
  min: 12345
  pkg: STD::Symbolic_unary
  re: !!perl/hash:RE_method 
    a: 0
    dba: prefix__S_313Tilde
    i: 0
    min: 12345
    name: sym
    r: 1
    rest: ''
    s: 0
    sym: '~'
prefix__S_314QuestionQuestion: !!perl/hash:RE 
  decl: []

  kind: token
  min: 24690
  pkg: STD::Symbolic_unary
  re: !!perl/hash:RE_sequence 
    a: 0
    dba: prefix__S_314QuestionQuestion
    i: 0
    min: 24690
    r: 1
    s: 0
    zyg: 
      - !!perl/hash:RE_method 
        a: 0
        dba: prefix__S_314QuestionQuestion
        i: 0
        min: 12345
        name: sym
        r: 1
        rest: ''
        s: 0
        sym: ??
      - !!perl/hash:RE_method 
        a: 0
        dba: prefix__S_314QuestionQuestion
        i: 0
        min: 12345
        name: badinfix
        nobind: 1
        r: 1
        rest: ''
        s: 0
prefix__S_315Question: !!perl/hash:RE 
  decl: []

  kind: token
  min: 12345
  pkg: STD::Symbolic_unary
  re: !!perl/hash:RE_method 
    a: 0
    dba: prefix__S_315Question
    i: 0
    min: 12345
    name: sym
    r: 1
    rest: ''
    s: 0
    sym: "?"
prefix__S_316TildeCaret: !!perl/hash:RE 
  decl: []

  kind: token
  min: 12345
  pkg: STD::Symbolic_unary
  re: !!perl/hash:RE_method 
    a: 0
    dba: prefix__S_316TildeCaret
    i: 0
    min: 12345
    name: sym
    r: 1
    rest: ''
    s: 0
    sym: ~^
prefix__S_317PlusCaret: !!perl/hash:RE 
  decl: []

  kind: token
  min: 12345
  pkg: STD::Symbolic_unary
  re: !!perl/hash:RE_method 
    a: 0
    dba: prefix__S_317PlusCaret
    i: 0
    min: 12345
    name: sym
    r: 1
    rest: ''
    s: 0
    sym: +^
prefix__S_318QuestionCaret: !!perl/hash:RE 
  decl: []

  kind: token
  min: 12345
  pkg: STD::Symbolic_unary
  re: !!perl/hash:RE_method 
    a: 0
    dba: prefix__S_318QuestionCaret
    i: 0
    min: 12345
    name: sym
    r: 1
    rest: ''
    s: 0
    sym: ?^
prefix__S_319CaretCaret: !!perl/hash:RE 
  decl: []

  kind: token
  min: 24690
  pkg: STD::Symbolic_unary
  re: !!perl/hash:RE_sequence 
    a: 0
    dba: prefix__S_319CaretCaret
    i: 0
    min: 24690
    r: 1
    s: 0
    zyg: 
      - !!perl/hash:RE_method 
        a: 0
        dba: prefix__S_319CaretCaret
        i: 0
        min: 12345
        name: sym
        r: 1
        rest: ''
        s: 0
        sym: "^^"
      - !!perl/hash:RE_method 
        a: 0
        dba: prefix__S_319CaretCaret
        i: 0
        min: 12345
        name: badinfix
        nobind: 1
        r: 1
        rest: ''
        s: 0
prefix__S_320Caret: !!perl/hash:RE 
  decl: []

  kind: token
  min: 12345
  pkg: STD::Symbolic_unary
  re: !!perl/hash:RE_method 
    a: 0
    dba: prefix__S_320Caret
    i: 0
    min: 12345
    name: sym
    r: 1
    rest: ''
    s: 0
    sym: "^"
prefix__S_321VertVert: !!perl/hash:RE 
  decl: []

  kind: token
  min: 24690
  pkg: STD::Symbolic_unary
  re: !!perl/hash:RE_sequence 
    a: 0
    dba: prefix__S_321VertVert
    i: 0
    min: 24690
    r: 1
    s: 0
    zyg: 
      - !!perl/hash:RE_method 
        a: 0
        dba: prefix__S_321VertVert
        i: 0
        min: 12345
        name: sym
        r: 1
        rest: ''
        s: 0
        sym: "||"
      - !!perl/hash:RE_method 
        a: 0
        dba: prefix__S_321VertVert
        i: 0
        min: 12345
        name: badinfix
        nobind: 1
        r: 1
        rest: ''
        s: 0
prefix__S_322Vert: !!perl/hash:RE 
  decl: []

  kind: token
  min: 12345
  pkg: STD::Symbolic_unary
  re: !!perl/hash:RE_method 
    a: 0
    dba: prefix__S_322Vert
    i: 0
    min: 12345
    name: sym
    r: 1
    rest: ''
    s: 0
    sym: "|"
prefix__S_352sleep: !!perl/hash:RE 
  decl: []

  kind: token
  min: 12345
  pkg: STD::Named_unary
  re: !!perl/hash:RE_sequence 
    a: 0
    dba: prefix__S_352sleep
    i: 0
    min: 12345
    r: 1
    s: 0
    zyg: 
      - !!perl/hash:RE_method 
        a: 0
        dba: prefix__S_352sleep
        i: 0
        min: 12345
        name: sym
        r: 1
        rest: ''
        s: 0
        sym: sleep
      - !!perl/hash:RE_meta 
        a: 0
        dba: prefix__S_352sleep
        i: 0
        min: 0
        r: 1
        s: 0
        text: »
      - !!perl/hash:RE_assertion 
        assert: "?"
        min: 0
        re: !!perl/hash:RE_method_re 
          a: 0
          dba: prefix__S_352sleep
          i: 0
          min: 0
          name: before
          nobind: 1
          r: 1
          re: !!perl/hash:RE 
            decl: []

            min: 0
            re: !!perl/hash:RE_quantified_atom 
              atom: !!perl/hash:RE_meta 
                a: 0
                dba: prefix__S_352sleep
                i: 0
                min: 1
                r: 1
                s: 0
                text: \s
              min: 0
              quant: 
                - "*"
                - ":"
                - ''
                - 0
          s: 0
prefix__S_353abs: !!perl/hash:RE 
  decl: []

  kind: token
  min: 12345
  pkg: STD::Named_unary
  re: !!perl/hash:RE_sequence 
    a: 0
    dba: prefix__S_353abs
    i: 0
    min: 12345
    r: 1
    s: 0
    zyg: 
      - !!perl/hash:RE_method 
        a: 0
        dba: prefix__S_353abs
        i: 0
        min: 12345
        name: sym
        r: 1
        rest: ''
        s: 0
        sym: abs
      - !!perl/hash:RE_meta 
        a: 0
        dba: prefix__S_353abs
        i: 0
        min: 0
        r: 1
        s: 0
        text: »
      - !!perl/hash:RE_assertion 
        assert: "?"
        min: 0
        re: !!perl/hash:RE_method_re 
          a: 0
          dba: prefix__S_353abs
          i: 0
          min: 0
          name: before
          nobind: 1
          r: 1
          re: !!perl/hash:RE 
            decl: []

            min: 0
            re: !!perl/hash:RE_quantified_atom 
              atom: !!perl/hash:RE_meta 
                a: 0
                dba: prefix__S_353abs
                i: 0
                min: 1
                r: 1
                s: 0
                text: \s
              min: 0
              quant: 
                - "*"
                - ":"
                - ''
                - 0
          s: 0
prefix__S_354let: !!perl/hash:RE 
  decl: []

  kind: token
  min: 12345
  pkg: STD::Named_unary
  re: !!perl/hash:RE_sequence 
    a: 0
    dba: prefix__S_354let
    i: 0
    min: 12345
    r: 1
    s: 0
    zyg: 
      - !!perl/hash:RE_method 
        a: 0
        dba: prefix__S_354let
        i: 0
        min: 12345
        name: sym
        r: 1
        rest: ''
        s: 0
        sym: let
      - !!perl/hash:RE_meta 
        a: 0
        dba: prefix__S_354let
        i: 0
        min: 0
        r: 1
        s: 0
        text: »
      - !!perl/hash:RE_assertion 
        assert: "?"
        min: 0
        re: !!perl/hash:RE_method_re 
          a: 0
          dba: prefix__S_354let
          i: 0
          min: 0
          name: before
          nobind: 1
          r: 1
          re: !!perl/hash:RE 
            decl: []

            min: 0
            re: !!perl/hash:RE_quantified_atom 
              atom: !!perl/hash:RE_meta 
                a: 0
                dba: prefix__S_354let
                i: 0
                min: 1
                r: 1
                s: 0
                text: \s
              min: 0
              quant: 
                - "*"
                - ":"
                - ''
                - 0
          s: 0
prefix__S_355temp: !!perl/hash:RE 
  decl: []

  kind: token
  min: 12345
  pkg: STD::Named_unary
  re: !!perl/hash:RE_sequence 
    a: 0
    dba: prefix__S_355temp
    i: 0
    min: 12345
    r: 1
    s: 0
    zyg: 
      - !!perl/hash:RE_method 
        a: 0
        dba: prefix__S_355temp
        i: 0
        min: 12345
        name: sym
        r: 1
        rest: ''
        s: 0
        sym: temp
      - !!perl/hash:RE_meta 
        a: 0
        dba: prefix__S_355temp
        i: 0
        min: 0
        r: 1
        s: 0
        text: »
      - !!perl/hash:RE_assertion 
        assert: "?"
        min: 0
        re: !!perl/hash:RE_method_re 
          a: 0
          dba: prefix__S_355temp
          i: 0
          min: 0
          name: before
          nobind: 1
          r: 1
          re: !!perl/hash:RE 
            decl: []

            min: 0
            re: !!perl/hash:RE_quantified_atom 
              atom: !!perl/hash:RE_meta 
                a: 0
                dba: prefix__S_355temp
                i: 0
                min: 1
                r: 1
                s: 0
                text: \s
              min: 0
              quant: 
                - "*"
                - ":"
                - ''
                - 0
          s: 0
prefix__S_406true: !!perl/hash:RE 
  decl: []

  kind: token
  min: 12345
  pkg: STD::Loose_unary
  re: !!perl/hash:RE_sequence 
    a: 0
    dba: prefix__S_406true
    i: 0
    min: 12345
    r: 1
    s: 0
    zyg: 
      - !!perl/hash:RE_method 
        a: 0
        dba: prefix__S_406true
        i: 0
        min: 12345
        name: sym
        r: 1
        rest: ''
        s: 0
        sym: 'true'
      - !!perl/hash:RE_meta 
        a: 0
        dba: prefix__S_406true
        i: 0
        min: 0
        r: 1
        s: 0
        text: »
prefix__S_407not: !!perl/hash:RE 
  decl: []

  kind: token
  min: 12345
  pkg: STD::Loose_unary
  re: !!perl/hash:RE_sequence 
    a: 0
    dba: prefix__S_407not
    i: 0
    min: 12345
    r: 1
    s: 0
    zyg: 
      - !!perl/hash:RE_method 
        a: 0
        dba: prefix__S_407not
        i: 0
        min: 12345
        name: sym
        r: 1
        rest: ''
        s: 0
        sym: not
      - !!perl/hash:RE_meta 
        a: 0
        dba: prefix__S_407not
        i: 0
        min: 0
        r: 1
        s: 0
        text: »
prefix_circumfix_meta_operator__S_284reduce: !!perl/hash:RE 
  decl: 
    - !!perl/hash:RE_decl 
      a: 0
      dba: prefix_circumfix_meta_operator__S_284reduce
      i: 0
      max: 0
      min: 0
      r: 0
      s: 0
      text: my $IN_REDUCE is context<rw> = 1
  kind: regex
  min: 2
  pkg: STD::List_prefix
  re: !!perl/hash:RE_sequence 
    a: 0
    dba: prefix_circumfix_meta_operator__S_284reduce
    i: 0
    min: 2
    r: 0
    s: 0
    zyg: 
      - !!perl/hash:RE_assertion 
        assert: "?"
        min: 0
        re: !!perl/hash:RE_method_re 
          a: 0
          dba: prefix_circumfix_meta_operator__S_284reduce
          i: 0
          min: 0
          name: before
          nobind: 1
          r: 0
          re: !!perl/hash:RE 
            decl: []

            min: 3
            re: !!perl/hash:RE_sequence 
              a: 0
              dba: prefix_circumfix_meta_operator__S_284reduce
              i: 0
              min: 3
              r: 0
              s: 0
              zyg: 
                - !!perl/hash:RE_string 
                  a: 0
                  dba: prefix_circumfix_meta_operator__S_284reduce
                  i: 0
                  min: 1
                  r: 0
                  s: 0
                  text: "["
                - !!perl/hash:RE_quantified_atom 
                  atom: !!perl/hash:RE_meta 
                    a: 0
                    dba: prefix_circumfix_meta_operator__S_284reduce
                    i: 0
                    min: 1
                    r: 0
                    s: 0
                    text: \S
                  min: 1
                  quant: 
                    - +
                    - "!"
                    - ''
                    - 1
                - !!perl/hash:RE_string 
                  a: 0
                  dba: prefix_circumfix_meta_operator__S_284reduce
                  i: 0
                  min: 1
                  r: 0
                  s: 0
                  text: "]"
          s: 0
      - !!perl/hash:RE_bindnamed 
        a: 0
        atom: !!perl/hash:RE_paren 
          decl: []

          min: 1
          nobind: 1
          re: !!perl/hash:RE_sequence 
            a: 0
            dba: prefix_circumfix_meta_operator__S_284reduce
            i: 0
            min: 1
            r: 0
            s: 0
            zyg: 
              - !!perl/hash:RE_string 
                a: 0
                dba: prefix_circumfix_meta_operator__S_284reduce
                i: 0
                min: 1
                r: 0
                s: 0
                text: "["
              - !!perl/hash:RE_bracket 
                decl: []

                min: 0
                re: !!perl/hash:RE_first 
                  a: 0
                  dba: prefix_circumfix_meta_operator__S_284reduce
                  i: 0
                  min: 0
                  r: 0
                  s: 0
                  zyg: 
                    - !!perl/hash:RE_sequence 
                      a: 0
                      dba: prefix_circumfix_meta_operator__S_284reduce
                      i: 0
                      min: 0
                      r: 0
                      s: 0
                      zyg: 
                        - !!perl/hash:RE_bindnamed 
                          a: 0
                          atom: !!perl/hash:RE_method 
                            min: 0
                            name: infixish
                            nobind: 1
                            rest: (1)
                          dba: prefix_circumfix_meta_operator__S_284reduce
                          i: 0
                          min: 0
                          r: 0
                          s: 0
                          var: op
                        - !!perl/hash:RE_assertion 
                          assert: "?"
                          min: 0
                          re: !!perl/hash:RE_method_re 
                            a: 0
                            dba: prefix_circumfix_meta_operator__S_284reduce
                            i: 0
                            min: 0
                            name: before
                            nobind: 1
                            r: 0
                            re: !!perl/hash:RE 
                              decl: []

                              min: 1
                              re: !!perl/hash:RE_string 
                                a: 0
                                dba: prefix_circumfix_meta_operator__S_284reduce
                                i: 0
                                min: 1
                                r: 0
                                s: 0
                                text: "]"
                            s: 0
                    - !!perl/hash:RE_sequence 
                      a: 0
                      dba: prefix_circumfix_meta_operator__S_284reduce
                      i: 0
                      min: 1
                      r: 0
                      s: 0
                      zyg: 
                        - !!perl/hash:RE_string 
                          a: 0
                          dba: prefix_circumfix_meta_operator__S_284reduce
                          i: 0
                          min: 1
                          r: 0
                          s: 0
                          text: \
                        - !!perl/hash:RE_bindnamed 
                          a: 0
                          atom: !!perl/hash:RE_method 
                            min: 0
                            name: infixish
                            nobind: 1
                            rest: (1)
                          dba: prefix_circumfix_meta_operator__S_284reduce
                          i: 0
                          min: 0
                          r: 0
                          s: 0
                          var: op
                        - !!perl/hash:RE_assertion 
                          assert: "?"
                          min: 0
                          re: !!perl/hash:RE_method_re 
                            a: 0
                            dba: prefix_circumfix_meta_operator__S_284reduce
                            i: 0
                            min: 0
                            name: before
                            nobind: 1
                            r: 0
                            re: !!perl/hash:RE 
                              decl: []

                              min: 1
                              re: !!perl/hash:RE_string 
                                a: 0
                                dba: prefix_circumfix_meta_operator__S_284reduce
                                i: 0
                                min: 1
                                r: 0
                                s: 0
                                text: "]"
                            s: 0
                    - !!perl/hash:RE_assertion 
                      assert: "!"
                      min: 0
                      re: !!perl/hash:RE_noop 
                        a: 0
                        dba: prefix_circumfix_meta_operator__S_284reduce
                        i: 0
                        min: 0
                        nobind: 1
                        r: 0
                        s: 0
        dba: prefix_circumfix_meta_operator__S_284reduce
        i: 0
        min: 1
        r: 0
        s: 0
        var: s
      - !!perl/hash:RE_bracket 
        decl: []

        min: 0
        re: !!perl/hash:RE_first 
          a: 0
          dba: prefix_circumfix_meta_operator__S_284reduce
          i: 0
          min: 0
          r: 0
          s: 0
          zyg: 
            - !!perl/hash:RE_assertion 
              assert: "?"
              min: 0
              re: !!perl/hash:RE_noop 
                a: 0
                dba: prefix_circumfix_meta_operator__S_284reduce
                i: 0
                min: 0
                nobind: 1
                r: 0
                s: 0
            - !!perl/hash:RE_sequence 
              a: 0
              dba: prefix_circumfix_meta_operator__S_284reduce
              i: 0
              min: 0
              r: 0
              s: 0
              zyg: 
                - !!perl/hash:RE_method 
                  min: 0
                  name: worry
                  nobind: 1
                  rest: ("Malformed reduce")
                - !!perl/hash:RE_assertion 
                  assert: "!"
                  min: 0
                  re: !!perl/hash:RE_noop 
                    a: 0
                    dba: prefix_circumfix_meta_operator__S_284reduce
                    i: 0
                    min: 0
                    nobind: 1
                    r: 0
                    s: 0
      - !!perl/hash:RE_string 
        a: 0
        dba: prefix_circumfix_meta_operator__S_284reduce
        i: 0
        min: 1
        r: 0
        s: 0
        text: "]"
      - !!perl/hash:RE_bracket 
        decl: []

        min: 0
        re: &42 !!perl/hash:RE_any 
          a: 0
          altname: prefix_circumfix_meta_operator__S_284reduce_10
          dba: prefix_circumfix_meta_operator__S_284reduce
          i: 0
          min: 0
          name: prefix_circumfix_meta_operator__S_284reduce_10
          r: 0
          s: 0
          zyg: 
            - !!perl/hash:RE_string 
              a: 0
              alt: prefix_circumfix_meta_operator__S_284reduce_10 0
              dba: prefix_circumfix_meta_operator__S_284reduce
              i: 0
              min: 1
              r: 0
              s: 0
              text: «
            - !!perl/hash:RE_assertion 
              alt: prefix_circumfix_meta_operator__S_284reduce_10 1
              assert: "?"
              min: 0
              re: !!perl/hash:RE_noop 
                a: 0
                dba: prefix_circumfix_meta_operator__S_284reduce
                i: 0
                min: 0
                nobind: 1
                r: 0
                s: 0
      - !!perl/hash:RE_method 
        min: 0
        name: can_meta
        nobind: 1
        rest: ($<s><op>, "reduce")
      - !!perl/hash:RE_bracket 
        decl: []

        min: 0
        re: !!perl/hash:RE_first 
          a: 0
          dba: prefix_circumfix_meta_operator__S_284reduce
          i: 0
          min: 0
          r: 0
          s: 0
          zyg: 
            - !!perl/hash:RE_assertion 
              assert: "!"
              min: 0
              re: !!perl/hash:RE_block 
                a: 0
                context: bool
                dba: prefix_circumfix_meta_operator__S_284reduce
                i: 0
                min: 0
                nobind: 1
                r: 0
                s: 0
                text: " $<s><op><O><diffy> "
            - !!perl/hash:RE_assertion 
              assert: "?"
              min: 0
              re: !!perl/hash:RE_block 
                a: 0
                context: bool
                dba: prefix_circumfix_meta_operator__S_284reduce
                i: 0
                min: 0
                nobind: 1
                r: 0
                s: 0
                text: " $<s><op><O><assoc> eq 'chain' "
            - !!perl/hash:RE_method 
              min: 0
              name: panic
              nobind: 1
              rest: ("Can't reduce " ~ $<s><op><sym> ~ " because " ~ $<s><op><O><dba> ~ " operators are diffy and not chaining")
      - !!perl/hash:RE_block 
        a: 0
        context: void
        dba: prefix_circumfix_meta_operator__S_284reduce
        i: 0
        min: 0
        r: 0
        s: 0
        text: " $<O> = $<s><op><O>; $<O><prec>:delete; $<O><assoc> = 'unary'; $<O><uassoc> = 'left'; "
      - !!perl/hash:RE_block 
        a: 0
        context: void
        dba: prefix_circumfix_meta_operator__S_284reduce
        i: 0
        min: 0
        r: 0
        s: 0
        text: " $<sym> = $<s>.Str; "
      - !!perl/hash:RE_bracket 
        decl: []

        min: 0
        re: !!perl/hash:RE_first 
          a: 0
          dba: prefix_circumfix_meta_operator__S_284reduce
          i: 0
          min: 0
          r: 0
          s: 0
          zyg: 
            - !!perl/hash:RE_assertion 
              assert: "?"
              min: 0
              re: !!perl/hash:RE_method_re 
                a: 0
                dba: prefix_circumfix_meta_operator__S_284reduce
                i: 0
                min: 0
                name: before
                nobind: 1
                r: 0
                re: !!perl/hash:RE 
                  decl: []

                  min: 1
                  re: !!perl/hash:RE_string 
                    a: 0
                    dba: prefix_circumfix_meta_operator__S_284reduce
                    i: 0
                    min: 1
                    r: 0
                    s: 0
                    text: (
                s: 0
            - !!perl/hash:RE_assertion 
              assert: "?"
              min: 0
              re: !!perl/hash:RE_method_re 
                a: 0
                dba: prefix_circumfix_meta_operator__S_284reduce
                i: 0
                min: 0
                name: before
                nobind: 1
                r: 0
                re: !!perl/hash:RE 
                  decl: []

                  min: 1
                  re: !!perl/hash:RE_sequence 
                    a: 0
                    dba: prefix_circumfix_meta_operator__S_284reduce
                    i: 0
                    min: 1
                    r: 0
                    s: 0
                    zyg: 
                      - !!perl/hash:RE_quantified_atom 
                        atom: !!perl/hash:RE_meta 
                          a: 0
                          dba: prefix_circumfix_meta_operator__S_284reduce
                          i: 0
                          min: 1
                          r: 0
                          s: 0
                          text: \s
                        min: 1
                        quant: 
                          - +
                          - "!"
                          - ''
                          - 1
                      - !!perl/hash:RE_quantified_atom 
                        atom: !!perl/hash:RE_bracket 
                          decl: []

                          min: 0
                          re: !!perl/hash:RE_sequence 
                            a: 0
                            dba: prefix_circumfix_meta_operator__S_284reduce
                            i: 0
                            min: 0
                            r: 0
                            s: 0
                            zyg: 
                              - !!perl/hash:RE_assertion 
                                assert: "?"
                                min: 0
                                re: !!perl/hash:RE_method 
                                  a: 0
                                  dba: prefix_circumfix_meta_operator__S_284reduce
                                  i: 0
                                  min: 12345
                                  name: stdstopper
                                  nobind: 1
                                  r: 0
                                  rest: ''
                                  s: 0
                              - !!perl/hash:RE_block 
                                a: 0
                                context: void
                                dba: prefix_circumfix_meta_operator__S_284reduce
                                i: 0
                                min: 0
                                r: 0
                                s: 0
                                text: " $<O><noun> = 1 "
                        min: 0
                        quant: 
                          - "?"
                          - "!"
                          - ''
                          - 0
                s: 0
            - !!perl/hash:RE_block 
              a: 0
              context: void
              dba: prefix_circumfix_meta_operator__S_284reduce
              i: 0
              min: 0
              r: 0
              s: 0
              text: " $<O><noun> = 1 "
prefix_circumfix_meta_operator__S_284reduce_10: *42
prefix_postfix_meta_operator__S_285Fre: !!perl/hash:RE 
  decl: []

  kind: token
  min: 2
  pkg: ~
  re: &31 !!perl/hash:RE_any 
    a: 0
    altname: prefix_postfix_meta_operator__S_285Fre_00
    dba: prefix_postfix_meta_operator__S_285Fre
    i: 0
    min: 2
    name: prefix_postfix_meta_operator__S_285Fre_00
    r: 1
    s: 0
    zyg: 
      - !!perl/hash:RE_method 
        a: 0
        alt: prefix_postfix_meta_operator__S_285Fre_00 0
        dba: prefix_postfix_meta_operator__S_285Fre
        i: 0
        min: 12345
        name: sym
        r: 1
        rest: ''
        s: 0
        sym: «
      - !!perl/hash:RE_string 
        a: 0
        alt: prefix_postfix_meta_operator__S_285Fre_00 1
        dba: prefix_postfix_meta_operator__S_285Fre
        i: 0
        min: 2
        r: 1
        s: 0
        text: <<
prefix_postfix_meta_operator__S_285Fre_00: *31
privop: !!perl/hash:RE 
  decl: []

  kind: token
  min: 12346
  pkg: STD::Methodcall
  re: !!perl/hash:RE_sequence 
    a: 0
    dba: privop
    i: 0
    min: 12346
    r: 1
    s: 0
    zyg: 
      - !!perl/hash:RE_string 
        a: 0
        dba: privop
        i: 0
        min: 1
        r: 1
        s: 0
        text: "!"
      - !!perl/hash:RE_method 
        a: 0
        dba: privop
        i: 0
        min: 12345
        name: methodop
        r: 1
        rest: ''
        s: 0
quasiquibble: !!perl/hash:RE 
  decl: 
    - !!perl/hash:RE_decl 
      a: 0
      dba: quasiquibble
      i: 0
      max: 0
      min: 0
      r: 1
      s: 0
      text: my ($lang, $start, $stop)
    - !!perl/hash:RE_decl 
      a: 0
      dba: quasiquibble
      i: 0
      max: 0
      min: 0
      r: 1
      s: 0
      text: my $QUASIMODO is context = 0
  kind: token
  min: 12345
  pkg: ~
  re: !!perl/hash:RE_sequence 
    a: 0
    dba: quasiquibble
    i: 0
    min: 12345
    r: 1
    s: 0
    zyg: 
      - !!perl/hash:RE_method 
        min: 0
        name: babble
        rest: ($l)
      - !!perl/hash:RE_block 
        a: 0
        context: void
        dba: quasiquibble
        i: 0
        min: 0
        r: 1
        s: 0
        text: " my $B = $<babble><B>; ($lang,$start,$stop) = @$B; "
      - !!perl/hash:RE_bracket 
        decl: []

        min: 12345
        re: !!perl/hash:RE_first 
          a: 0
          dba: quasiquibble
          i: 0
          min: 12345
          r: 1
          s: 0
          zyg: 
            - !!perl/hash:RE_sequence 
              a: 0
              dba: quasiquibble
              i: 0
              min: 12345
              r: 1
              s: 0
              zyg: 
                - !!perl/hash:RE_assertion 
                  assert: "?"
                  min: 0
                  re: !!perl/hash:RE_block 
                    a: 0
                    context: bool
                    dba: quasiquibble
                    i: 0
                    min: 0
                    nobind: 1
                    r: 1
                    s: 0
                    text: " $start eq '{' "
                - !!perl/hash:RE_bracket 
                  decl: []

                  min: 12345
                  re: !!perl/hash:RE_sequence 
                    a: 0
                    dba: quasiquibble
                    i: 0
                    lang: ($lang)
                    min: 12345
                    r: 1
                    s: 0
                    zyg: 
                      - !!perl/hash:RE_decl 
                        a: 0
                        dba: quasiquibble
                        i: 0
                        lang: ($lang)
                        max: 0
                        min: 0
                        noquant: 1
                        r: 1
                        s: 0
                        text: "my $newlang = ($lang);  $C = $C->cursor_fresh($newlang); "
                      - !!perl/hash:RE_method 
                        a: 0
                        dba: quasiquibble
                        i: 0
                        lang: ($lang)
                        min: 12345
                        name: block
                        r: 1
                        rest: ''
                        s: 0
            - !!perl/hash:RE_sequence 
              a: 0
              dba: quasiquibble
              i: 0
              min: 12345
              r: 1
              s: 0
              zyg: 
                - !!perl/hash:RE_var 
                  a: 0
                  dba: quasiquibble
                  i: 0
                  min: 0
                  r: 1
                  s: 0
                  var: $start
                - !!perl/hash:RE_bracket 
                  decl: []

                  min: 12345
                  re: !!perl/hash:RE_sequence 
                    a: 0
                    dba: quasiquibble
                    i: 0
                    lang: ($lang)
                    min: 12345
                    r: 1
                    s: 0
                    zyg: 
                      - !!perl/hash:RE_decl 
                        a: 0
                        dba: quasiquibble
                        i: 0
                        lang: ($lang)
                        max: 0
                        min: 0
                        noquant: 1
                        r: 1
                        s: 0
                        text: "my $newlang = ($lang);  $C = $C->cursor_fresh($newlang); "
                      - !!perl/hash:RE_method 
                        a: 0
                        dba: quasiquibble
                        i: 0
                        lang: ($lang)
                        min: 12345
                        name: statementlist
                        r: 1
                        rest: ''
                        s: 0
                - !!perl/hash:RE_bracket 
                  decl: []

                  min: 0
                  re: !!perl/hash:RE_first 
                    a: 0
                    dba: quasiquibble
                    i: 0
                    min: 0
                    r: 1
                    s: 0
                    zyg: 
                      - !!perl/hash:RE_var 
                        a: 0
                        dba: quasiquibble
                        i: 0
                        min: 0
                        r: 1
                        s: 0
                        var: $stop
                      - !!perl/hash:RE_method 
                        min: 0
                        name: panic
                        nobind: 1
                        rest: ("Couldn't find terminator $stop")
quibble: !!perl/hash:RE 
  decl: 
    - !!perl/hash:RE_decl 
      a: 0
      dba: quibble
      i: 0
      max: 0
      min: 0
      r: 1
      s: 0
      text: my ($lang, $start, $stop)
  kind: token
  min: 0
  pkg: ~
  re: !!perl/hash:RE_sequence 
    a: 0
    dba: quibble
    i: 0
    min: 0
    r: 1
    s: 0
    zyg: 
      - !!perl/hash:RE_method 
        min: 0
        name: babble
        rest: ($l)
      - !!perl/hash:RE_block 
        a: 0
        context: void
        dba: quibble
        i: 0
        min: 0
        r: 1
        s: 0
        text: " my $B = $<babble><B>; ($lang,$start,$stop) = @$B; "
      - !!perl/hash:RE_var 
        a: 0
        dba: quibble
        i: 0
        min: 0
        r: 1
        s: 0
        var: $start
      - !!perl/hash:RE_method 
        min: 0
        name: nibble
        rest: ($lang)
      - !!perl/hash:RE_bracket 
        decl: []

        min: 0
        re: !!perl/hash:RE_first 
          a: 0
          dba: quibble
          i: 0
          min: 0
          r: 1
          s: 0
          zyg: 
            - !!perl/hash:RE_var 
              a: 0
              dba: quibble
              i: 0
              min: 0
              r: 1
              s: 0
              var: $stop
            - !!perl/hash:RE_method 
              min: 0
              name: panic
              nobind: 1
              rest: ("Couldn't find terminator $stop")
      - !!perl/hash:RE_block 
        a: 0
        context: void
        dba: quibble
        i: 0
        min: 0
        r: 1
        s: 0
        text: "\n        if $lang<_herelang> {\n            push @herestub_queue,\n                ::Herestub.new(\n                    delim => $<nibble><nibbles>[0]<TEXT>,\n                    orignode => $¢,\n                    lang => $lang<_herelang>,\n                );\n        }\n    "
quote__S_193Single_Single: !!perl/hash:RE 
  decl: []

  kind: token
  min: 2
  pkg: ~
  re: !!perl/hash:RE_sequence 
    a: 0
    dba: quote__S_193Single_Single
    i: 0
    min: 2
    r: 1
    s: 0
    zyg: 
      - !!perl/hash:RE_double 
        a: 0
        dba: quote__S_193Single_Single
        i: 0
        min: 1
        r: 1
        s: 0
        text: "'"
      - !!perl/hash:RE_method 
        min: 0
        name: nibble
        rest: ($¢.cursor_fresh( %*LANG<Q> ).tweak(:q).unbalanced("'"))
      - !!perl/hash:RE_double 
        a: 0
        dba: quote__S_193Single_Single
        i: 0
        min: 1
        r: 1
        s: 0
        text: "'"
quote__S_194Double_Double: !!perl/hash:RE 
  decl: []

  kind: token
  min: 2
  pkg: ~
  re: !!perl/hash:RE_sequence 
    a: 0
    dba: quote__S_194Double_Double
    i: 0
    min: 2
    r: 1
    s: 0
    zyg: 
      - !!perl/hash:RE_string 
        a: 0
        dba: quote__S_194Double_Double
        i: 0
        min: 1
        r: 1
        s: 0
        text: "\""
      - !!perl/hash:RE_method 
        min: 0
        name: nibble
        rest: ($¢.cursor_fresh( %*LANG<Q> ).tweak(:qq).unbalanced('"'))
      - !!perl/hash:RE_string 
        a: 0
        dba: quote__S_194Double_Double
        i: 0
        min: 1
        r: 1
        s: 0
        text: "\""
quote__S_198SlashSlash: !!perl/hash:RE 
  decl: []

  kind: token
  min: 2
  pkg: ~
  re: !!perl/hash:RE_sequence 
    a: 0
    dba: quote__S_198SlashSlash
    i: 0
    min: 2
    r: 1
    s: 0
    zyg: 
      - !!perl/hash:RE_string 
        a: 0
        dba: quote__S_198SlashSlash
        i: 0
        min: 1
        r: 1
        s: 0
        text: /
      - !!perl/hash:RE_quantified_atom 
        atom: !!perl/hash:RE_meta 
          a: 0
          dba: quote__S_198SlashSlash
          i: 0
          min: 1
          r: 1
          s: 0
          text: \s
        min: 0
        quant: 
          - "*"
          - ":"
          - ''
          - 0
      - !!perl/hash:RE_string 
        a: 0
        dba: quote__S_198SlashSlash
        i: 0
        min: 1
        r: 1
        s: 0
        text: /
      - !!perl/hash:RE_method 
        min: 0
        name: panic
        nobind: 1
        rest: ("Null regex not allowed")
quote__S_199Slash_Slash: !!perl/hash:RE 
  decl: []

  kind: token
  min: 1
  pkg: ~
  re: !!perl/hash:RE_sequence 
    a: 0
    dba: quote__S_199Slash_Slash
    i: 0
    min: 1
    r: 1
    s: 0
    zyg: 
      - !!perl/hash:RE_string 
        a: 0
        dba: quote__S_199Slash_Slash
        i: 0
        min: 1
        r: 1
        s: 0
        text: /
      - !!perl/hash:RE_method 
        min: 0
        name: nibble
        rest: ( $¢.cursor_fresh( %*LANG<Regex> ).unbalanced("/") )
      - !!perl/hash:RE_bracket 
        decl: []

        min: 0
        re: !!perl/hash:RE_first 
          a: 0
          dba: quote__S_199Slash_Slash
          i: 0
          min: 0
          r: 1
          s: 0
          zyg: 
            - !!perl/hash:RE_string 
              a: 0
              dba: quote__S_199Slash_Slash
              i: 0
              min: 1
              r: 1
              s: 0
              text: /
            - !!perl/hash:RE_method 
              min: 0
              name: panic
              nobind: 1
              rest: ("Unable to parse regex; couldn't find final '/'")
      - !!perl/hash:RE_quantified_atom 
        atom: !!perl/hash:RE_method 
          a: 0
          dba: quote__S_199Slash_Slash
          i: 0
          min: 12345
          name: old_rx_mods
          nobind: 1
          r: 1
          rest: ''
          s: 0
        min: 0
        quant: 
          - "?"
          - ":"
          - ''
          - 0
quote__S_200qq: !!perl/hash:RE 
  decl: 
    - !!perl/hash:RE_decl 
      a: 0
      dba: quote__S_200qq
      i: 0
      max: 0
      min: 0
      r: 1
      s: 0
      text: my $qm
  kind: token
  min: 12347
  pkg: ~
  re: !!perl/hash:RE_sequence 
    a: 0
    dba: quote__S_200qq
    i: 0
    min: 12347
    r: 1
    s: 0
    zyg: 
      - !!perl/hash:RE_string 
        a: 0
        dba: quote__S_200qq
        i: 0
        min: 2
        r: 1
        s: 0
        text: qq
      - !!perl/hash:RE_bracket 
        decl: []

        min: 12345
        re: &83 !!perl/hash:RE_any 
          a: 0
          altname: quote__S_200qq_01
          dba: quote__S_200qq
          i: 0
          min: 12345
          name: quote__S_200qq_01
          r: 1
          s: 0
          zyg: 
            - !!perl/hash:RE_sequence 
              a: 0
              alt: quote__S_200qq_01 0
              dba: quote__S_200qq
              i: 0
              min: 24690
              r: 1
              s: 0
              zyg: 
                - !!perl/hash:RE_method 
                  a: 0
                  dba: quote__S_200qq
                  i: 0
                  min: 12345
                  name: quote_mod
                  r: 1
                  rest: ''
                  s: 0
                - !!perl/hash:RE_meta 
                  a: 0
                  dba: quote__S_200qq
                  i: 0
                  min: 0
                  r: 1
                  s: 0
                  text: »
                - !!perl/hash:RE_assertion 
                  assert: "!"
                  min: 0
                  re: !!perl/hash:RE_method_re 
                    a: 0
                    dba: quote__S_200qq
                    i: 0
                    min: 0
                    name: before
                    nobind: 1
                    r: 1
                    re: !!perl/hash:RE 
                      decl: []

                      min: 1
                      re: !!perl/hash:RE_string 
                        a: 0
                        dba: quote__S_200qq
                        i: 0
                        min: 1
                        r: 1
                        s: 0
                        text: (
                    s: 0
                - !!perl/hash:RE_block 
                  a: 0
                  context: void
                  dba: quote__S_200qq
                  i: 0
                  min: 0
                  r: 1
                  s: 0
                  text: " $qm = $<quote_mod>.Str "
                - !!perl/hash:RE_method 
                  a: 0
                  dba: quote__S_200qq
                  i: 0
                  min: 12345
                  name: ws
                  nobind: 1
                  r: 1
                  rest: ''
                  s: 0
                - !!perl/hash:RE_method 
                  min: 0
                  name: quibble
                  rest: ($¢.cursor_fresh( %*LANG<Q> ).tweak(:qq).tweak($qm => 1))
            - !!perl/hash:RE_sequence 
              a: 0
              alt: quote__S_200qq_01 1
              dba: quote__S_200qq
              i: 0
              min: 12345
              r: 1
              s: 0
              zyg: 
                - !!perl/hash:RE_meta 
                  a: 0
                  dba: quote__S_200qq
                  i: 0
                  min: 0
                  r: 1
                  s: 0
                  text: »
                - !!perl/hash:RE_assertion 
                  assert: "!"
                  min: 0
                  re: !!perl/hash:RE_method_re 
                    a: 0
                    dba: quote__S_200qq
                    i: 0
                    min: 0
                    name: before
                    nobind: 1
                    r: 1
                    re: !!perl/hash:RE 
                      decl: []

                      min: 1
                      re: !!perl/hash:RE_string 
                        a: 0
                        dba: quote__S_200qq
                        i: 0
                        min: 1
                        r: 1
                        s: 0
                        text: (
                    s: 0
                - !!perl/hash:RE_method 
                  a: 0
                  dba: quote__S_200qq
                  i: 0
                  min: 12345
                  name: ws
                  nobind: 1
                  r: 1
                  rest: ''
                  s: 0
                - !!perl/hash:RE_method 
                  min: 0
                  name: quibble
                  rest: ($¢.cursor_fresh( %*LANG<Q> ).tweak(:qq))
quote__S_200qq_01: *83
quote__S_201q: !!perl/hash:RE 
  decl: 
    - !!perl/hash:RE_decl 
      a: 0
      dba: quote__S_201q
      i: 0
      max: 0
      min: 0
      r: 1
      s: 0
      text: my $qm
  kind: token
  min: 12346
  pkg: ~
  re: !!perl/hash:RE_sequence 
    a: 0
    dba: quote__S_201q
    i: 0
    min: 12346
    r: 1
    s: 0
    zyg: 
      - !!perl/hash:RE_string 
        a: 0
        dba: quote__S_201q
        i: 0
        min: 1
        r: 1
        s: 0
        text: q
      - !!perl/hash:RE_bracket 
        decl: []

        min: 12345
        re: &134 !!perl/hash:RE_any 
          a: 0
          altname: quote__S_201q_01
          dba: quote__S_201q
          i: 0
          min: 12345
          name: quote__S_201q_01
          r: 1
          s: 0
          zyg: 
            - !!perl/hash:RE_sequence 
              a: 0
              alt: quote__S_201q_01 0
              dba: quote__S_201q
              i: 0
              min: 12345
              r: 1
              s: 0
              zyg: 
                - !!perl/hash:RE_method 
                  a: 0
                  dba: quote__S_201q
                  i: 0
                  min: 12345
                  name: quote_mod
                  r: 1
                  rest: ''
                  s: 0
                - !!perl/hash:RE_meta 
                  a: 0
                  dba: quote__S_201q
                  i: 0
                  min: 0
                  r: 1
                  s: 0
                  text: »
                - !!perl/hash:RE_assertion 
                  assert: "!"
                  min: 0
                  re: !!perl/hash:RE_method_re 
                    a: 0
                    dba: quote__S_201q
                    i: 0
                    min: 0
                    name: before
                    nobind: 1
                    r: 1
                    re: !!perl/hash:RE 
                      decl: []

                      min: 1
                      re: !!perl/hash:RE_string 
                        a: 0
                        dba: quote__S_201q
                        i: 0
                        min: 1
                        r: 1
                        s: 0
                        text: (
                    s: 0
                - !!perl/hash:RE_block 
                  a: 0
                  context: void
                  dba: quote__S_201q
                  i: 0
                  min: 0
                  r: 1
                  s: 0
                  text: " $qm = $<quote_mod>.Str "
                - !!perl/hash:RE_method 
                  min: 0
                  name: quibble
                  rest: ($¢.cursor_fresh( %*LANG<Q> ).tweak(:q).tweak($qm => 1))
            - !!perl/hash:RE_sequence 
              a: 0
              alt: quote__S_201q_01 1
              dba: quote__S_201q
              i: 0
              min: 12345
              r: 1
              s: 0
              zyg: 
                - !!perl/hash:RE_meta 
                  a: 0
                  dba: quote__S_201q
                  i: 0
                  min: 0
                  r: 1
                  s: 0
                  text: »
                - !!perl/hash:RE_assertion 
                  assert: "!"
                  min: 0
                  re: !!perl/hash:RE_method_re 
                    a: 0
                    dba: quote__S_201q
                    i: 0
                    min: 0
                    name: before
                    nobind: 1
                    r: 1
                    re: !!perl/hash:RE 
                      decl: []

                      min: 1
                      re: !!perl/hash:RE_string 
                        a: 0
                        dba: quote__S_201q
                        i: 0
                        min: 1
                        r: 1
                        s: 0
                        text: (
                    s: 0
                - !!perl/hash:RE_method 
                  a: 0
                  dba: quote__S_201q
                  i: 0
                  min: 12345
                  name: ws
                  nobind: 1
                  r: 1
                  rest: ''
                  s: 0
                - !!perl/hash:RE_method 
                  min: 0
                  name: quibble
                  rest: ($¢.cursor_fresh( %*LANG<Q> ).tweak(:q))
quote__S_201q_01: *134
quote__S_202Q: !!perl/hash:RE 
  decl: 
    - !!perl/hash:RE_decl 
      a: 0
      dba: quote__S_202Q
      i: 0
      max: 0
      min: 0
      r: 1
      s: 0
      text: my $qm
  kind: token
  min: 12346
  pkg: ~
  re: !!perl/hash:RE_sequence 
    a: 0
    dba: quote__S_202Q
    i: 0
    min: 12346
    r: 1
    s: 0
    zyg: 
      - !!perl/hash:RE_string 
        a: 0
        dba: quote__S_202Q
        i: 0
        min: 1
        r: 1
        s: 0
        text: Q
      - !!perl/hash:RE_bracket 
        decl: []

        min: 12345
        re: &122 !!perl/hash:RE_any 
          a: 0
          altname: quote__S_202Q_01
          dba: quote__S_202Q
          i: 0
          min: 12345
          name: quote__S_202Q_01
          r: 1
          s: 0
          zyg: 
            - !!perl/hash:RE_sequence 
              a: 0
              alt: quote__S_202Q_01 0
              dba: quote__S_202Q
              i: 0
              min: 12345
              r: 1
              s: 0
              zyg: 
                - !!perl/hash:RE_method 
                  a: 0
                  dba: quote__S_202Q
                  i: 0
                  min: 12345
                  name: quote_mod
                  r: 1
                  rest: ''
                  s: 0
                - !!perl/hash:RE_meta 
                  a: 0
                  dba: quote__S_202Q
                  i: 0
                  min: 0
                  r: 1
                  s: 0
                  text: »
                - !!perl/hash:RE_assertion 
                  assert: "!"
                  min: 0
                  re: !!perl/hash:RE_method_re 
                    a: 0
                    dba: quote__S_202Q
                    i: 0
                    min: 0
                    name: before
                    nobind: 1
                    r: 1
                    re: !!perl/hash:RE 
                      decl: []

                      min: 1
                      re: !!perl/hash:RE_string 
                        a: 0
                        dba: quote__S_202Q
                        i: 0
                        min: 1
                        r: 1
                        s: 0
                        text: (
                    s: 0
                - !!perl/hash:RE_block 
                  a: 0
                  context: void
                  dba: quote__S_202Q
                  i: 0
                  min: 0
                  r: 1
                  s: 0
                  text: " $qm = $<quote_mod>.Str "
                - !!perl/hash:RE_method 
                  min: 0
                  name: quibble
                  rest: ($¢.cursor_fresh( %*LANG<Q> ).tweak($qm => 1))
            - !!perl/hash:RE_sequence 
              a: 0
              alt: quote__S_202Q_01 1
              dba: quote__S_202Q
              i: 0
              min: 12345
              r: 1
              s: 0
              zyg: 
                - !!perl/hash:RE_meta 
                  a: 0
                  dba: quote__S_202Q
                  i: 0
                  min: 0
                  r: 1
                  s: 0
                  text: »
                - !!perl/hash:RE_assertion 
                  assert: "!"
                  min: 0
                  re: !!perl/hash:RE_method_re 
                    a: 0
                    dba: quote__S_202Q
                    i: 0
                    min: 0
                    name: before
                    nobind: 1
                    r: 1
                    re: !!perl/hash:RE 
                      decl: []

                      min: 1
                      re: !!perl/hash:RE_string 
                        a: 0
                        dba: quote__S_202Q
                        i: 0
                        min: 1
                        r: 1
                        s: 0
                        text: (
                    s: 0
                - !!perl/hash:RE_method 
                  a: 0
                  dba: quote__S_202Q
                  i: 0
                  min: 12345
                  name: ws
                  nobind: 1
                  r: 1
                  rest: ''
                  s: 0
                - !!perl/hash:RE_method 
                  min: 0
                  name: quibble
                  rest: ($¢.cursor_fresh( %*LANG<Q> ))
quote__S_202Q_01: *122
quote__S_213rx: !!perl/hash:RE 
  decl: []

  kind: token
  min: 12345
  pkg: ~
  re: !!perl/hash:RE_sequence 
    a: 0
    dba: quote__S_213rx
    i: 0
    min: 12345
    r: 1
    s: 0
    zyg: 
      - !!perl/hash:RE_method 
        a: 0
        dba: quote__S_213rx
        i: 0
        min: 12345
        name: sym
        r: 1
        rest: ''
        s: 0
        sym: rx
      - !!perl/hash:RE_meta 
        a: 0
        dba: quote__S_213rx
        i: 0
        min: 0
        r: 1
        s: 0
        text: »
      - !!perl/hash:RE_assertion 
        assert: "!"
        min: 0
        re: !!perl/hash:RE_method_re 
          a: 0
          dba: quote__S_213rx
          i: 0
          min: 0
          name: before
          nobind: 1
          r: 1
          re: !!perl/hash:RE 
            decl: []

            min: 1
            re: !!perl/hash:RE_string 
              a: 0
              dba: quote__S_213rx
              i: 0
              min: 1
              r: 1
              s: 0
              text: (
          s: 0
      - !!perl/hash:RE_method 
        min: 0
        name: quibble
        rest: ( $¢.cursor_fresh( %*LANG<Regex> ) )
      - !!perl/hash:RE_assertion 
        assert: "!"
        min: 0
        re: !!perl/hash:RE_method 
          a: 0
          dba: quote__S_213rx
          i: 0
          min: 12345
          name: old_rx_mods
          nobind: 1
          r: 1
          rest: ''
          s: 0
quote__S_214m: !!perl/hash:RE 
  decl: []

  kind: token
  min: 12345
  pkg: ~
  re: !!perl/hash:RE_sequence 
    a: 0
    dba: quote__S_214m
    i: 0
    min: 12345
    r: 1
    s: 0
    zyg: 
      - !!perl/hash:RE_method 
        a: 0
        dba: quote__S_214m
        i: 0
        min: 12345
        name: sym
        r: 1
        rest: ''
        s: 0
        sym: m
      - !!perl/hash:RE_meta 
        a: 0
        dba: quote__S_214m
        i: 0
        min: 0
        r: 1
        s: 0
        text: »
      - !!perl/hash:RE_assertion 
        assert: "!"
        min: 0
        re: !!perl/hash:RE_method_re 
          a: 0
          dba: quote__S_214m
          i: 0
          min: 0
          name: before
          nobind: 1
          r: 1
          re: !!perl/hash:RE 
            decl: []

            min: 1
            re: !!perl/hash:RE_string 
              a: 0
              dba: quote__S_214m
              i: 0
              min: 1
              r: 1
              s: 0
              text: (
          s: 0
      - !!perl/hash:RE_method 
        min: 0
        name: quibble
        rest: ( $¢.cursor_fresh( %*LANG<Regex> ) )
      - !!perl/hash:RE_assertion 
        assert: "!"
        min: 0
        re: !!perl/hash:RE_method 
          a: 0
          dba: quote__S_214m
          i: 0
          min: 12345
          name: old_rx_mods
          nobind: 1
          r: 1
          rest: ''
          s: 0
quote__S_215mm: !!perl/hash:RE 
  decl: []

  kind: token
  min: 12345
  pkg: ~
  re: !!perl/hash:RE_sequence 
    a: 0
    dba: quote__S_215mm
    i: 0
    min: 12345
    r: 1
    s: 0
    zyg: 
      - !!perl/hash:RE_method 
        a: 0
        dba: quote__S_215mm
        i: 0
        min: 12345
        name: sym
        r: 1
        rest: ''
        s: 0
        sym: mm
      - !!perl/hash:RE_meta 
        a: 0
        dba: quote__S_215mm
        i: 0
        min: 0
        r: 1
        s: 0
        text: »
      - !!perl/hash:RE_assertion 
        assert: "!"
        min: 0
        re: !!perl/hash:RE_method_re 
          a: 0
          dba: quote__S_215mm
          i: 0
          min: 0
          name: before
          nobind: 1
          r: 1
          re: !!perl/hash:RE 
            decl: []

            min: 1
            re: !!perl/hash:RE_string 
              a: 0
              dba: quote__S_215mm
              i: 0
              min: 1
              r: 1
              s: 0
              text: (
          s: 0
      - !!perl/hash:RE_method 
        min: 0
        name: quibble
        rest: ( $¢.cursor_fresh( %*LANG<Regex> ).tweak(:s))
      - !!perl/hash:RE_assertion 
        assert: "!"
        min: 0
        re: !!perl/hash:RE_method 
          a: 0
          dba: quote__S_215mm
          i: 0
          min: 12345
          name: old_rx_mods
          nobind: 1
          r: 1
          rest: ''
          s: 0
quote__S_216s: !!perl/hash:RE 
  decl: []

  kind: token
  min: 12345
  pkg: ~
  re: !!perl/hash:RE_sequence 
    a: 0
    dba: quote__S_216s
    i: 0
    min: 12345
    r: 1
    s: 0
    zyg: 
      - !!perl/hash:RE_method 
        a: 0
        dba: quote__S_216s
        i: 0
        min: 12345
        name: sym
        r: 1
        rest: ''
        s: 0
        sym: s
      - !!perl/hash:RE_meta 
        a: 0
        dba: quote__S_216s
        i: 0
        min: 0
        r: 1
        s: 0
        text: »
      - !!perl/hash:RE_assertion 
        assert: "!"
        min: 0
        re: !!perl/hash:RE_method_re 
          a: 0
          dba: quote__S_216s
          i: 0
          min: 0
          name: before
          nobind: 1
          r: 1
          re: !!perl/hash:RE 
            decl: []

            min: 1
            re: !!perl/hash:RE_string 
              a: 0
              dba: quote__S_216s
              i: 0
              min: 1
              r: 1
              s: 0
              text: (
          s: 0
      - !!perl/hash:RE_bindnamed 
        a: 0
        atom: !!perl/hash:RE_method 
          min: 0
          name: sibble
          nobind: 1
          rest: ( $¢.cursor_fresh( %*LANG<Regex> ), $¢.cursor_fresh( %*LANG<Q> ).tweak(:qq))
        dba: quote__S_216s
        i: 0
        min: 0
        r: 1
        s: 0
        var: pat
      - !!perl/hash:RE_assertion 
        assert: "!"
        min: 0
        re: !!perl/hash:RE_method 
          a: 0
          dba: quote__S_216s
          i: 0
          min: 12345
          name: old_rx_mods
          nobind: 1
          r: 1
          rest: ''
          s: 0
quote__S_217ss: !!perl/hash:RE 
  decl: []

  kind: token
  min: 12345
  pkg: ~
  re: !!perl/hash:RE_sequence 
    a: 0
    dba: quote__S_217ss
    i: 0
    min: 12345
    r: 1
    s: 0
    zyg: 
      - !!perl/hash:RE_method 
        a: 0
        dba: quote__S_217ss
        i: 0
        min: 12345
        name: sym
        r: 1
        rest: ''
        s: 0
        sym: ss
      - !!perl/hash:RE_meta 
        a: 0
        dba: quote__S_217ss
        i: 0
        min: 0
        r: 1
        s: 0
        text: »
      - !!perl/hash:RE_assertion 
        assert: "!"
        min: 0
        re: !!perl/hash:RE_method_re 
          a: 0
          dba: quote__S_217ss
          i: 0
          min: 0
          name: before
          nobind: 1
          r: 1
          re: !!perl/hash:RE 
            decl: []

            min: 1
            re: !!perl/hash:RE_string 
              a: 0
              dba: quote__S_217ss
              i: 0
              min: 1
              r: 1
              s: 0
              text: (
          s: 0
      - !!perl/hash:RE_bindnamed 
        a: 0
        atom: !!perl/hash:RE_method 
          min: 0
          name: sibble
          nobind: 1
          rest: ( $¢.cursor_fresh( %*LANG<Regex> ).tweak(:s), $¢.cursor_fresh( %*LANG<Q> ).tweak(:qq))
        dba: quote__S_217ss
        i: 0
        min: 0
        r: 1
        s: 0
        var: pat
      - !!perl/hash:RE_assertion 
        assert: "!"
        min: 0
        re: !!perl/hash:RE_method 
          a: 0
          dba: quote__S_217ss
          i: 0
          min: 12345
          name: old_rx_mods
          nobind: 1
          r: 1
          rest: ''
          s: 0
quote__S_218tr: !!perl/hash:RE 
  decl: []

  kind: token
  min: 12345
  pkg: ~
  re: !!perl/hash:RE_sequence 
    a: 0
    dba: quote__S_218tr
    i: 0
    min: 12345
    r: 1
    s: 0
    zyg: 
      - !!perl/hash:RE_method 
        a: 0
        dba: quote__S_218tr
        i: 0
        min: 12345
        name: sym
        r: 1
        rest: ''
        s: 0
        sym: tr
      - !!perl/hash:RE_meta 
        a: 0
        dba: quote__S_218tr
        i: 0
        min: 0
        r: 1
        s: 0
        text: »
      - !!perl/hash:RE_assertion 
        assert: "!"
        min: 0
        re: !!perl/hash:RE_method_re 
          a: 0
          dba: quote__S_218tr
          i: 0
          min: 0
          name: before
          nobind: 1
          r: 1
          re: !!perl/hash:RE 
            decl: []

            min: 1
            re: !!perl/hash:RE_string 
              a: 0
              dba: quote__S_218tr
              i: 0
              min: 1
              r: 1
              s: 0
              text: (
          s: 0
      - !!perl/hash:RE_bindnamed 
        a: 0
        atom: !!perl/hash:RE_method 
          min: 0
          name: tribble
          nobind: 1
          rest: ( $¢.cursor_fresh( %*LANG<Q> ).tweak(:q))
        dba: quote__S_218tr
        i: 0
        min: 0
        r: 1
        s: 0
        var: pat
      - !!perl/hash:RE_assertion 
        assert: "!"
        min: 0
        re: !!perl/hash:RE_method 
          a: 0
          dba: quote__S_218tr
          i: 0
          min: 12345
          name: old_tr_mods
          nobind: 1
          r: 1
          rest: ''
          s: 0
quote__S_219quasi: !!perl/hash:RE 
  decl: []

  kind: token
  min: 12345
  pkg: ~
  re: !!perl/hash:RE_sequence 
    a: 0
    dba: quote__S_219quasi
    i: 0
    min: 12345
    r: 1
    s: 0
    zyg: 
      - !!perl/hash:RE_method 
        a: 0
        dba: quote__S_219quasi
        i: 0
        min: 12345
        name: sym
        r: 1
        rest: ''
        s: 0
        sym: quasi
      - !!perl/hash:RE_meta 
        a: 0
        dba: quote__S_219quasi
        i: 0
        min: 0
        r: 1
        s: 0
        text: »
      - !!perl/hash:RE_assertion 
        assert: "!"
        min: 0
        re: !!perl/hash:RE_method_re 
          a: 0
          dba: quote__S_219quasi
          i: 0
          min: 0
          name: before
          nobind: 1
          r: 1
          re: !!perl/hash:RE 
            decl: []

            min: 1
            re: !!perl/hash:RE_string 
              a: 0
              dba: quote__S_219quasi
              i: 0
              min: 1
              r: 1
              s: 0
              text: (
          s: 0
      - !!perl/hash:RE_method 
        min: 0
        name: quasiquibble
        rest: ($¢.cursor_fresh( %*LANG<Quasi> ))
quote_mod__S_203w: !!perl/hash:RE 
  decl: []

  kind: token
  min: 12345
  pkg: ~
  re: !!perl/hash:RE_method 
    a: 0
    dba: quote_mod__S_203w
    i: 0
    min: 12345
    name: sym
    r: 1
    rest: ''
    s: 0
    sym: w
quote_mod__S_204ww: !!perl/hash:RE 
  decl: []

  kind: token
  min: 12345
  pkg: ~
  re: !!perl/hash:RE_method 
    a: 0
    dba: quote_mod__S_204ww
    i: 0
    min: 12345
    name: sym
    r: 1
    rest: ''
    s: 0
    sym: ww
quote_mod__S_205x: !!perl/hash:RE 
  decl: []

  kind: token
  min: 12345
  pkg: ~
  re: !!perl/hash:RE_method 
    a: 0
    dba: quote_mod__S_205x
    i: 0
    min: 12345
    name: sym
    r: 1
    rest: ''
    s: 0
    sym: x
quote_mod__S_206to: !!perl/hash:RE 
  decl: []

  kind: token
  min: 12345
  pkg: ~
  re: !!perl/hash:RE_method 
    a: 0
    dba: quote_mod__S_206to
    i: 0
    min: 12345
    name: sym
    r: 1
    rest: ''
    s: 0
    sym: to
quote_mod__S_207s: !!perl/hash:RE 
  decl: []

  kind: token
  min: 12345
  pkg: ~
  re: !!perl/hash:RE_method 
    a: 0
    dba: quote_mod__S_207s
    i: 0
    min: 12345
    name: sym
    r: 1
    rest: ''
    s: 0
    sym: s
quote_mod__S_208a: !!perl/hash:RE 
  decl: []

  kind: token
  min: 12345
  pkg: ~
  re: !!perl/hash:RE_method 
    a: 0
    dba: quote_mod__S_208a
    i: 0
    min: 12345
    name: sym
    r: 1
    rest: ''
    s: 0
    sym: a
quote_mod__S_209h: !!perl/hash:RE 
  decl: []

  kind: token
  min: 12345
  pkg: ~
  re: !!perl/hash:RE_method 
    a: 0
    dba: quote_mod__S_209h
    i: 0
    min: 12345
    name: sym
    r: 1
    rest: ''
    s: 0
    sym: h
quote_mod__S_210f: !!perl/hash:RE 
  decl: []

  kind: token
  min: 12345
  pkg: ~
  re: !!perl/hash:RE_method 
    a: 0
    dba: quote_mod__S_210f
    i: 0
    min: 12345
    name: sym
    r: 1
    rest: ''
    s: 0
    sym: f
quote_mod__S_211c: !!perl/hash:RE 
  decl: []

  kind: token
  min: 12345
  pkg: ~
  re: !!perl/hash:RE_method 
    a: 0
    dba: quote_mod__S_211c
    i: 0
    min: 12345
    name: sym
    r: 1
    rest: ''
    s: 0
    sym: c
quote_mod__S_212b: !!perl/hash:RE 
  decl: []

  kind: token
  min: 12345
  pkg: ~
  re: !!perl/hash:RE_method 
    a: 0
    dba: quote_mod__S_212b
    i: 0
    min: 12345
    name: sym
    r: 1
    rest: ''
    s: 0
    sym: b
quotepair: !!perl/hash:RE 
  decl: 
    - !!perl/hash:RE_decl 
      a: 0
      dba: quotepair
      i: 0
      max: 0
      min: 0
      r: 1
      s: 0
      text: my $key
    - !!perl/hash:RE_decl 
      a: 0
      dba: quotepair
      i: 0
      max: 0
      min: 0
      r: 1
      s: 0
      text: my $value
  kind: token
  min: 3
  pkg: ~
  re: !!perl/hash:RE_sequence 
    a: 0
    dba: colon pair (restricted)
    i: 0
    min: 3
    r: 1
    s: 0
    zyg: 
      - !!perl/hash:RE_string 
        a: 0
        dba: quotepair
        i: 0
        min: 1
        r: 1
        s: 0
        text: ":"
      - !!perl/hash:RE_bracket 
        decl: []

        min: 2
        re: &33 !!perl/hash:RE_any 
          a: 0
          altname: quotepair_01
          dba: colon pair (restricted)
          i: 0
          min: 2
          name: quotepair_01
          r: 1
          s: 0
          zyg: 
            - !!perl/hash:RE_sequence 
              a: 0
              alt: quotepair_01 0
              dba: colon pair (restricted)
              i: 0
              min: 12346
              r: 1
              s: 0
              zyg: 
                - !!perl/hash:RE_string 
                  a: 0
                  dba: colon pair (restricted)
                  i: 0
                  min: 1
                  r: 1
                  s: 0
                  text: "!"
                - !!perl/hash:RE_method 
                  a: 0
                  dba: colon pair (restricted)
                  i: 0
                  min: 12345
                  name: identifier
                  r: 1
                  rest: ''
                  s: 0
                - !!perl/hash:RE_block 
                  a: 0
                  context: void
                  dba: colon pair (restricted)
                  i: 0
                  min: 0
                  r: 1
                  s: 0
                  text: " $key = $<identifier>.Str; $value = 0; "
                - !!perl/hash:RE_method_internal 
                  args: $S, 'quotepair', 'false'
                  max: 0
                  min: 0
                  name: _REDUCE
            - !!perl/hash:RE_sequence 
              a: 0
              alt: quotepair_01 1
              dba: colon pair (restricted)
              i: 0
              min: 12345
              r: 1
              s: 0
              zyg: 
                - !!perl/hash:RE_method 
                  a: 0
                  dba: colon pair (restricted)
                  i: 0
                  min: 12345
                  name: identifier
                  r: 1
                  rest: ''
                  s: 0
                - !!perl/hash:RE_block 
                  a: 0
                  context: void
                  dba: colon pair (restricted)
                  i: 0
                  min: 0
                  r: 1
                  s: 0
                  text: " $key = $<identifier>.Str; "
                - !!perl/hash:RE_bracket 
                  decl: []

                  min: 0
                  re: !!perl/hash:RE_first 
                    a: 0
                    dba: colon pair (restricted)
                    i: 0
                    min: 0
                    r: 1
                    s: 0
                    zyg: 
                      - !!perl/hash:RE_sequence 
                        a: 0
                        dba: colon pair (restricted)
                        i: 0
                        min: 12345
                        r: 1
                        s: 0
                        zyg: 
                          - !!perl/hash:RE_quantified_atom 
                            atom: !!perl/hash:RE_method 
                              a: 0
                              dba: colon pair (restricted)
                              i: 0
                              min: 12345
                              name: unsp
                              nobind: 1
                              r: 1
                              rest: ''
                              s: 0
                            min: 0
                            quant: 
                              - "?"
                              - ":"
                              - ''
                              - 0
                          - !!perl/hash:RE_assertion 
                            assert: "?"
                            min: 0
                            re: !!perl/hash:RE_method_re 
                              a: 0
                              dba: colon pair (restricted)
                              i: 0
                              min: 0
                              name: before
                              nobind: 1
                              r: 1
                              re: !!perl/hash:RE 
                                decl: []

                                min: 1
                                re: !!perl/hash:RE_string 
                                  a: 0
                                  dba: colon pair (restricted)
                                  i: 0
                                  min: 1
                                  r: 1
                                  s: 0
                                  text: (
                              s: 0
                          - !!perl/hash:RE_method 
                            a: 0
                            dba: colon pair (restricted)
                            i: 0
                            min: 12345
                            name: circumfix
                            r: 1
                            rest: ''
                            s: 0
                          - !!perl/hash:RE_block 
                            a: 0
                            context: void
                            dba: colon pair (restricted)
                            i: 0
                            min: 0
                            r: 1
                            s: 0
                            text: " $value = $<circumfix>; "
                      - !!perl/hash:RE_block 
                        a: 0
                        context: void
                        dba: colon pair (restricted)
                        i: 0
                        min: 0
                        r: 1
                        s: 0
                        text: " $value = 1; "
                - !!perl/hash:RE_method_internal 
                  args: $S, 'quotepair', 'value'
                  max: 0
                  min: 0
                  name: _REDUCE
            - !!perl/hash:RE_sequence 
              a: 0
              alt: quotepair_01 2
              dba: colon pair (restricted)
              i: 0
              min: 2
              r: 1
              s: 0
              zyg: 
                - !!perl/hash:RE_bindnamed 
                  a: 0
                  atom: !!perl/hash:RE_paren 
                    decl: []

                    min: 1
                    nobind: 1
                    re: !!perl/hash:RE_quantified_atom 
                      atom: !!perl/hash:RE_meta 
                        a: 0
                        dba: colon pair (restricted)
                        i: 0
                        min: 1
                        r: 1
                        s: 0
                        text: \d
                      min: 1
                      quant: 
                        - +
                        - ":"
                        - ''
                        - 1
                  dba: colon pair (restricted)
                  i: 0
                  min: 1
                  r: 1
                  s: 0
                  var: 'n'
                - !!perl/hash:RE_bindnamed 
                  a: 0
                  atom: !!perl/hash:RE_paren 
                    decl: []

                    min: 1
                    nobind: 1
                    re: !!perl/hash:RE_quantified_atom 
                      atom: !!perl/hash:RE_cclass 
                        a: 0
                        dba: colon pair (restricted)
                        i: 0
                        min: 1
                        r: 1
                        s: 0
                        text: "[a..z]"
                      min: 1
                      quant: 
                        - +
                        - ":"
                        - ''
                        - 1
                  dba: colon pair (restricted)
                  i: 0
                  min: 1
                  r: 1
                  s: 0
                  var: id
                - !!perl/hash:RE_block 
                  a: 0
                  context: void
                  dba: colon pair (restricted)
                  i: 0
                  min: 0
                  r: 1
                  s: 0
                  text: " $key = $<id>.Str; $value = $<n>.Str; "
                - !!perl/hash:RE_method_internal 
                  args: $S, 'quotepair', 'nth'
                  max: 0
                  min: 0
                  name: _REDUCE
      - !!perl/hash:RE_block 
        a: 0
        context: void
        dba: colon pair (restricted)
        i: 0
        min: 0
        r: 1
        s: 0
        text: " $<k> = $key; $<v> = $value; "
quotepair_01: *33
rad_number: !!perl/hash:RE 
  decl: []

  kind: token
  min: 5
  pkg: ~
  re: !!perl/hash:RE_sequence 
    a: 0
    dba: number in radix notation
    i: 0
    min: 5
    r: 1
    s: 0
    zyg: 
      - !!perl/hash:RE_string 
        a: 0
        dba: rad_number
        i: 0
        min: 1
        r: 1
        s: 0
        text: ":"
      - !!perl/hash:RE_bindnamed 
        a: 0
        atom: !!perl/hash:RE_bracket 
          decl: []

          min: 1
          nobind: 1
          re: !!perl/hash:RE_quantified_atom 
            atom: !!perl/hash:RE_meta 
              a: 0
              dba: rad_number
              i: 0
              min: 1
              r: 1
              s: 0
              text: \d
            min: 1
            quant: 
              - +
              - ":"
              - ''
              - 1
        dba: rad_number
        i: 0
        min: 1
        r: 1
        s: 0
        var: radix
      - !!perl/hash:RE_quantified_atom 
        atom: !!perl/hash:RE_method 
          a: 0
          dba: rad_number
          i: 0
          min: 12345
          name: unsp
          nobind: 1
          r: 1
          rest: ''
          s: 0
        min: 0
        quant: 
          - "?"
          - ":"
          - ''
          - 0
      - !!perl/hash:RE_block 
        a: 0
        context: void
        dba: rad_number
        i: 0
        min: 0
        r: 1
        s: 0
        text: ''
      - !!perl/hash:RE_bracket 
        decl: []

        min: 3
        re: !!perl/hash:RE_first 
          a: 0
          dba: number in radix notation
          i: 0
          min: 3
          r: 1
          s: 0
          zyg: 
            - !!perl/hash:RE_sequence 
              a: 0
              dba: number in radix notation
              i: 0
              min: 3
              r: 1
              s: 0
              zyg: 
                - !!perl/hash:RE_string 
                  a: 0
                  dba: number in radix notation
                  i: 0
                  min: 1
                  r: 1
                  s: 0
                  text: <
                - !!perl/hash:RE_bindnamed 
                  a: 0
                  atom: !!perl/hash:RE_bracket 
                    decl: []

                    min: 1
                    nobind: 1
                    re: !!perl/hash:RE_sequence 
                      a: 0
                      dba: number in radix notation
                      i: 0
                      min: 1
                      r: 1
                      s: 0
                      zyg: 
                        - !!perl/hash:RE_quantified_atom 
                          atom: !!perl/hash:RE_cclass 
                            a: 0
                            dba: number in radix notation
                            i: 0
                            min: 1
                            r: 1
                            s: 0
                            text: "[ 0..9 a..z A..Z ]"
                          min: 1
                          quant: 
                            - +
                            - ":"
                            - ''
                            - 1
                        - !!perl/hash:RE_quantified_atom 
                          atom: !!perl/hash:RE_bracket 
                            decl: []

                            min: 2
                            re: !!perl/hash:RE_sequence 
                              a: 0
                              dba: number in radix notation
                              i: 0
                              min: 2
                              r: 1
                              s: 0
                              zyg: 
                                - !!perl/hash:RE_string 
                                  a: 0
                                  dba: number in radix notation
                                  i: 0
                                  min: 1
                                  r: 1
                                  s: 0
                                  text: _
                                - !!perl/hash:RE_quantified_atom 
                                  atom: !!perl/hash:RE_cclass 
                                    a: 0
                                    dba: number in radix notation
                                    i: 0
                                    min: 1
                                    r: 1
                                    s: 0
                                    text: "[ 0..9 a..z A..Z ]"
                                  min: 1
                                  quant: 
                                    - +
                                    - ":"
                                    - ''
                                    - 1
                          min: 0
                          quant: 
                            - "*"
                            - ":"
                            - ''
                            - 0
                  dba: number in radix notation
                  i: 0
                  min: 1
                  r: 1
                  s: 0
                  var: intpart
                - !!perl/hash:RE_bindnamed 
                  a: 0
                  atom: !!perl/hash:RE_quantified_atom 
                    atom: !!perl/hash:RE_bracket 
                      decl: []

                      min: 2
                      re: !!perl/hash:RE_sequence 
                        a: 0
                        dba: number in radix notation
                        i: 0
                        min: 2
                        r: 1
                        s: 0
                        zyg: 
                          - !!perl/hash:RE_string 
                            a: 0
                            dba: number in radix notation
                            i: 0
                            min: 1
                            r: 1
                            s: 0
                            text: .
                          - !!perl/hash:RE_quantified_atom 
                            atom: !!perl/hash:RE_cclass 
                              a: 0
                              dba: number in radix notation
                              i: 0
                              min: 1
                              r: 1
                              s: 0
                              text: "[ 0..9 a..z A..Z ]"
                            min: 1
                            quant: 
                              - +
                              - ":"
                              - ''
                              - 1
                          - !!perl/hash:RE_quantified_atom 
                            atom: !!perl/hash:RE_bracket 
                              decl: []

                              min: 2
                              re: !!perl/hash:RE_sequence 
                                a: 0
                                dba: number in radix notation
                                i: 0
                                min: 2
                                r: 1
                                s: 0
                                zyg: 
                                  - !!perl/hash:RE_string 
                                    a: 0
                                    dba: number in radix notation
                                    i: 0
                                    min: 1
                                    r: 1
                                    s: 0
                                    text: _
                                  - !!perl/hash:RE_quantified_atom 
                                    atom: !!perl/hash:RE_cclass 
                                      a: 0
                                      dba: number in radix notation
                                      i: 0
                                      min: 1
                                      r: 1
                                      s: 0
                                      text: "[ 0..9 a..z A..Z ]"
                                    min: 1
                                    quant: 
                                      - +
                                      - ":"
                                      - ''
                                      - 1
                            min: 0
                            quant: 
                              - "*"
                              - ":"
                              - ''
                              - 0
                    min: 0
                    nobind: 1
                    quant: 
                      - "?"
                      - ":"
                      - ''
                      - 0
                  dba: number in radix notation
                  i: 0
                  min: 0
                  r: 1
                  s: 0
                  var: fracpart
                - !!perl/hash:RE_quantified_atom 
                  atom: !!perl/hash:RE_bracket 
                    decl: []

                    min: 24693
                    re: !!perl/hash:RE_sequence 
                      a: 0
                      dba: number in radix notation
                      i: 0
                      min: 24693
                      r: 1
                      s: 0
                      zyg: 
                        - !!perl/hash:RE_string 
                          a: 0
                          dba: number in radix notation
                          i: 0
                          min: 1
                          r: 1
                          s: 0
                          text: "*"
                        - !!perl/hash:RE_bindnamed 
                          a: 0
                          atom: !!perl/hash:RE_method 
                            a: 0
                            dba: number in radix notation
                            i: 0
                            min: 12345
                            name: radint
                            nobind: 1
                            r: 1
                            rest: ''
                            s: 0
                          dba: number in radix notation
                          i: 0
                          min: 12345
                          r: 1
                          s: 0
                          var: base
                        - !!perl/hash:RE_string 
                          a: 0
                          dba: number in radix notation
                          i: 0
                          min: 2
                          r: 1
                          s: 0
                          text: "**"
                        - !!perl/hash:RE_bindnamed 
                          a: 0
                          atom: !!perl/hash:RE_method 
                            a: 0
                            dba: number in radix notation
                            i: 0
                            min: 12345
                            name: radint
                            nobind: 1
                            r: 1
                            rest: ''
                            s: 0
                          dba: number in radix notation
                          i: 0
                          min: 12345
                          r: 1
                          s: 0
                          var: exp
                  min: 0
                  quant: 
                    - "?"
                    - ":"
                    - ''
                    - 0
                - !!perl/hash:RE_string 
                  a: 0
                  dba: number in radix notation
                  i: 0
                  min: 1
                  r: 1
                  s: 0
                  text: ">"
            - !!perl/hash:RE_sequence 
              a: 0
              dba: number in radix notation
              i: 0
              min: 12345
              r: 1
              s: 0
              zyg: 
                - !!perl/hash:RE_assertion 
                  assert: "?"
                  min: 0
                  re: !!perl/hash:RE_method_re 
                    a: 0
                    dba: number in radix notation
                    i: 0
                    min: 0
                    name: before
                    nobind: 1
                    r: 1
                    re: !!perl/hash:RE 
                      decl: []

                      min: 1
                      re: !!perl/hash:RE_string 
                        a: 0
                        dba: number in radix notation
                        i: 0
                        min: 1
                        r: 1
                        s: 0
                        text: "["
                    s: 0
                - !!perl/hash:RE_method 
                  a: 0
                  dba: number in radix notation
                  i: 0
                  min: 12345
                  name: circumfix
                  r: 1
                  rest: ''
                  s: 0
            - !!perl/hash:RE_sequence 
              a: 0
              dba: number in radix notation
              i: 0
              min: 12345
              r: 1
              s: 0
              zyg: 
                - !!perl/hash:RE_assertion 
                  assert: "?"
                  min: 0
                  re: !!perl/hash:RE_method_re 
                    a: 0
                    dba: number in radix notation
                    i: 0
                    min: 0
                    name: before
                    nobind: 1
                    r: 1
                    re: !!perl/hash:RE 
                      decl: []

                      min: 1
                      re: !!perl/hash:RE_string 
                        a: 0
                        dba: number in radix notation
                        i: 0
                        min: 1
                        r: 1
                        s: 0
                        text: (
                    s: 0
                - !!perl/hash:RE_method 
                  a: 0
                  dba: number in radix notation
                  i: 0
                  min: 12345
                  name: circumfix
                  r: 1
                  rest: ''
                  s: 0
radint: !!perl/hash:RE 
  decl: []

  kind: token
  min: 12345
  pkg: ~
  re: !!perl/hash:RE_bracket 
    decl: []

    min: 12345
    re: &101 !!perl/hash:RE_any 
      a: 0
      altname: radint_01
      dba: radint
      i: 0
      min: 12345
      name: radint_01
      r: 1
      s: 0
      zyg: 
        - !!perl/hash:RE_method 
          a: 0
          alt: radint_01 0
          dba: radint
          i: 0
          min: 12345
          name: integer
          r: 1
          rest: ''
          s: 0
        - !!perl/hash:RE_sequence 
          a: 0
          alt: radint_01 1
          dba: radint
          i: 0
          min: 12345
          r: 1
          s: 0
          zyg: 
            - !!perl/hash:RE_assertion 
              assert: "?"
              min: 0
              re: !!perl/hash:RE_method_re 
                a: 0
                dba: radint
                i: 0
                min: 0
                name: before
                nobind: 1
                r: 1
                re: !!perl/hash:RE 
                  decl: []

                  min: 1
                  re: !!perl/hash:RE_string 
                    a: 0
                    dba: radint
                    i: 0
                    min: 1
                    r: 1
                    s: 0
                    text: ":"
                s: 0
            - !!perl/hash:RE_method 
              a: 0
              dba: radint
              i: 0
              min: 12345
              name: rad_number
              r: 1
              rest: ''
              s: 0
            - !!perl/hash:RE_assertion 
              assert: "?"
              min: 0
              re: !!perl/hash:RE_block 
                a: 0
                context: bool
                dba: radint
                i: 0
                min: 0
                nobind: 1
                r: 1
                s: 0
                text: "\n                        defined $<rad_number><intpart>\n                        and\n                        not defined $<rad_number><fracpart>\n                    "
radint_01: *101
regex_block: !!perl/hash:RE 
  decl: 
    - !!perl/hash:RE_decl 
      a: 0
      dba: regex_block
      i: 0
      max: 0
      min: 0
      r: 1
      s: 0
      text: temp %*LANG
    - !!perl/hash:RE_decl 
      a: 0
      dba: regex_block
      i: 0
      max: 0
      min: 0
      r: 1
      s: 0
      text: my $lang = %*LANG<Regex>
    - !!perl/hash:RE_decl 
      a: 0
      dba: regex_block
      i: 0
      max: 0
      min: 0
      r: 1
      s: 0
      text: my $GOAL is context = '}'
  kind: token
  min: 1
  pkg: ~
  re: !!perl/hash:RE_sequence 
    a: 0
    dba: regex_block
    i: 0
    min: 1
    r: 1
    s: 0
    zyg: 
      - !!perl/hash:RE_quantified_atom 
        atom: !!perl/hash:RE_bracket 
          decl: []

          min: 24690
          re: !!perl/hash:RE_sequence 
            a: 0
            dba: regex_block
            i: 0
            min: 24690
            r: 1
            s: 0
            zyg: 
              - !!perl/hash:RE_method 
                a: 0
                dba: regex_block
                i: 0
                min: 12345
                name: quotepair
                r: 1
                rest: ''
                s: 0
              - !!perl/hash:RE_method 
                a: 0
                dba: regex_block
                i: 0
                min: 12345
                name: ws
                nobind: 1
                r: 1
                rest: ''
                s: 0
              - !!perl/hash:RE_block 
                a: 0
                context: void
                dba: regex_block
                i: 0
                min: 0
                r: 1
                s: 0
                text: "\n            my $kv = $<quotepair>[*-1];\n            $lang = $lang.tweak($kv.<k>, $kv.<v>)\n                or self.panic(\"Unrecognized adverb :\" ~ $kv.<k> ~ '(' ~ $kv.<v> ~ ')');\n        "
        min: 0
        quant: 
          - "*"
          - ":"
          - ''
          - 0
      - !!perl/hash:RE_string 
        a: 0
        dba: regex_block
        i: 0
        min: 1
        r: 1
        s: 0
        text: "{"
      - !!perl/hash:RE_method 
        min: 0
        name: nibble
        rest: ( $¢.cursor_fresh($lang).unbalanced('}') )
      - !!perl/hash:RE_bracket 
        decl: []

        min: 0
        re: !!perl/hash:RE_first 
          a: 0
          dba: regex_block
          i: 0
          min: 0
          r: 1
          s: 0
          zyg: 
            - !!perl/hash:RE_string 
              a: 0
              dba: regex_block
              i: 0
              min: 1
              r: 1
              s: 0
              text: "}"
            - !!perl/hash:RE_method 
              min: 0
              name: panic
              nobind: 1
              rest: ("Unable to parse regex; couldn't find right brace")
      - !!perl/hash:RE_bracket 
        decl: []

        min: 0
        re: &22 !!perl/hash:RE_any 
          a: 0
          altname: regex_block_04
          dba: regex_block
          i: 0
          min: 0
          name: regex_block_04
          r: 1
          s: 0
          zyg: 
            - !!perl/hash:RE_sequence 
              a: 0
              alt: regex_block_04 0
              dba: regex_block
              i: 0
              min: 0
              r: 1
              s: 0
              zyg: 
                - !!perl/hash:RE_assertion 
                  assert: "?"
                  min: 0
                  re: !!perl/hash:RE_method_re 
                    a: 0
                    dba: regex_block
                    i: 0
                    min: 0
                    name: before
                    nobind: 1
                    r: 1
                    re: !!perl/hash:RE 
                      decl: []

                      min: 0
                      re: !!perl/hash:RE_sequence 
                        a: 0
                        dba: regex_block
                        i: 0
                        min: 0
                        r: 1
                        s: 0
                        zyg: 
                          - !!perl/hash:RE_quantified_atom 
                            atom: !!perl/hash:RE_meta 
                              a: 0
                              dba: regex_block
                              i: 0
                              min: 1
                              r: 1
                              s: 0
                              text: \h
                            min: 0
                            quant: 
                              - "*"
                              - ":"
                              - ''
                              - 0
                          - !!perl/hash:RE_meta 
                            a: 0
                            dba: regex_block
                            i: 0
                            min: 0
                            r: 1
                            s: 0
                            text: $$
                    s: 0
                - !!perl/hash:RE_block 
                  a: 0
                  context: void
                  dba: regex_block
                  i: 0
                  min: 0
                  r: 1
                  s: 0
                  text: " @*MEMOS[$¢.pos]<endstmt> = 2; "
                - !!perl/hash:RE_method_internal 
                  args: $S, 'regex_block', 'endstmt simple '
                  max: 0
                  min: 0
                  name: _REDUCE
            - !!perl/hash:RE_sequence 
              a: 0
              alt: regex_block_04 1
              dba: regex_block
              i: 0
              min: 0
              r: 1
              s: 0
              zyg: 
                - !!perl/hash:RE_quantified_atom 
                  atom: !!perl/hash:RE_meta 
                    a: 0
                    dba: regex_block
                    i: 0
                    min: 1
                    r: 1
                    s: 0
                    text: \h
                  min: 0
                  quant: 
                    - "*"
                    - ":"
                    - ''
                    - 0
                - !!perl/hash:RE_assertion 
                  assert: "?"
                  min: 0
                  re: !!perl/hash:RE_method_re 
                    a: 0
                    dba: regex_block
                    i: 0
                    min: 0
                    name: before
                    nobind: 1
                    r: 1
                    re: !!perl/hash:RE 
                      decl: []

                      min: 1
                      re: !!perl/hash:RE_cclass 
                        a: 0
                        dba: regex_block
                        i: 0
                        min: 1
                        r: 1
                        s: 0
                        text: "[\\\\,:]"
                    s: 0
                - !!perl/hash:RE_method_internal 
                  args: $S, 'regex_block', 'normal '
                  max: 0
                  min: 0
                  name: _REDUCE
            - !!perl/hash:RE_sequence 
              a: 0
              alt: regex_block_04 2
              dba: regex_block
              i: 0
              min: 0
              r: 1
              s: 0
              zyg: 
                - !!perl/hash:RE_quantified_atom 
                  atom: !!perl/hash:RE_method 
                    a: 0
                    dba: regex_block
                    i: 0
                    min: 12345
                    name: unv
                    nobind: 1
                    r: 1
                    rest: ''
                    s: 0
                  min: 0
                  quant: 
                    - "?"
                    - ":"
                    - ''
                    - 0
                - !!perl/hash:RE_meta 
                  a: 0
                  dba: regex_block
                  i: 0
                  min: 0
                  r: 1
                  s: 0
                  text: $$
                - !!perl/hash:RE_block 
                  a: 0
                  context: void
                  dba: regex_block
                  i: 0
                  min: 0
                  r: 1
                  s: 0
                  text: " @*MEMOS[$¢.pos]<endstmt> = 2; "
                - !!perl/hash:RE_method_internal 
                  args: $S, 'regex_block', 'endstmt complex'
                  max: 0
                  min: 0
                  name: _REDUCE
            - !!perl/hash:RE_sequence 
              a: 0
              alt: regex_block_04 3
              dba: regex_block
              i: 0
              min: 0
              r: 1
              s: 0
              zyg: 
                - !!perl/hash:RE_block 
                  a: 0
                  context: void
                  dba: regex_block
                  i: 0
                  min: 0
                  r: 1
                  s: 0
                  text: ''
                - !!perl/hash:RE_quantified_atom 
                  atom: !!perl/hash:RE_method 
                    a: 0
                    dba: regex_block
                    i: 0
                    min: 12345
                    name: unsp
                    nobind: 1
                    r: 1
                    rest: ''
                    s: 0
                  min: 0
                  quant: 
                    - "?"
                    - ":"
                    - ''
                    - 0
                - !!perl/hash:RE_block 
                  a: 0
                  context: void
                  dba: regex_block
                  i: 0
                  min: 0
                  r: 1
                  s: 0
                  text: " @*MEMOS[$¢.pos]<endargs> = 1; "
                - !!perl/hash:RE_method_internal 
                  args: $S, 'regex_block', 'endargs'
                  max: 0
                  min: 0
                  name: _REDUCE
regex_block_04: *22
regex_declarator__S_101regex: !!perl/hash:RE 
  decl: []

  kind: token
  min: 37035
  pkg: ~
  re: !!perl/hash:RE_sequence 
    a: 0
    dba: regex_declarator__S_101regex
    i: 0
    min: 37035
    r: 1
    s: 0
    zyg: 
      - !!perl/hash:RE_method 
        a: 0
        dba: regex_declarator__S_101regex
        endsym: spacey
        i: 0
        min: 12345
        name: sym
        r: 1
        rest: ''
        s: 0
        sym: regex
      - !!perl/hash:RE_method 
        a: 0
        dba: regex_declarator__S_101regex
        i: 0
        min: 12345
        name: spacey
        nobind: 1
        r: 1
        rest: ''
        s: 0
      - !!perl/hash:RE_method 
        a: 0
        dba: regex_declarator__S_101regex
        i: 0
        min: 12345
        name: regex_def
        r: 1
        rest: ''
        s: 0
regex_declarator__S_102token: !!perl/hash:RE 
  decl: []

  kind: token
  min: 37035
  pkg: ~
  re: !!perl/hash:RE_sequence 
    a: 0
    dba: regex_declarator__S_102token
    i: 0
    min: 37035
    r: 1
    s: 0
    zyg: 
      - !!perl/hash:RE_method 
        a: 0
        dba: regex_declarator__S_102token
        endsym: spacey
        i: 0
        min: 12345
        name: sym
        r: 1
        rest: ''
        s: 0
        sym: token
      - !!perl/hash:RE_method 
        a: 0
        dba: regex_declarator__S_102token
        i: 0
        min: 12345
        name: spacey
        nobind: 1
        r: 1
        rest: ''
        s: 0
      - !!perl/hash:RE_method 
        a: 0
        dba: regex_declarator__S_102token
        i: 0
        min: 12345
        name: regex_def
        r: 1
        rest: ''
        s: 0
regex_declarator__S_103rule: !!perl/hash:RE 
  decl: []

  kind: token
  min: 37035
  pkg: ~
  re: !!perl/hash:RE_sequence 
    a: 0
    dba: regex_declarator__S_103rule
    i: 0
    min: 37035
    r: 1
    s: 0
    zyg: 
      - !!perl/hash:RE_method 
        a: 0
        dba: regex_declarator__S_103rule
        endsym: spacey
        i: 0
        min: 12345
        name: sym
        r: 1
        rest: ''
        s: 0
        sym: rule
      - !!perl/hash:RE_method 
        a: 0
        dba: regex_declarator__S_103rule
        i: 0
        min: 12345
        name: spacey
        nobind: 1
        r: 1
        rest: ''
        s: 0
      - !!perl/hash:RE_method 
        a: 0
        dba: regex_declarator__S_103rule
        i: 0
        min: 12345
        name: regex_def
        r: 1
        rest: ''
        s: 0
regex_def: !!perl/hash:RE 
  decl: 
    - !!perl/hash:RE_decl 
      a: 0
      dba: regex_def
      i: 0
      max: 0
      min: 0
      r: 1
      s: 1
      text: my $IN_DECL is context<rw> = 1
    - !!perl/hash:RE_decl 
      a: 0
      dba: regex_def
      i: 0
      max: 0
      min: 0
      r: 1
      s: 1
      text: my $DECLARAND is context<rw>
  kind: rule
  min: 0
  pkg: ~
  re: !!perl/hash:RE_first 
    a: 0
    dba: regex_def
    i: 0
    min: 0
    r: 1
    s: 1
    zyg: 
      - !!perl/hash:RE_sequence 
        a: 0
        dba: regex_def
        i: 0
        min: 37035
        r: 1
        s: 1
        zyg: 
          - !!perl/hash:RE_method 
            min: 0
            name: ws
            nobind: 1
            noquant: 1
            rest: ''
          - !!perl/hash:RE_bracket 
            decl: []

            min: 37035
            re: !!perl/hash:RE_sequence 
              a: 0
              dba: regex_def
              i: 0
              min: 37035
              r: 1
              s: 0
              zyg: 
                - !!perl/hash:RE_quantified_atom 
                  atom: !!perl/hash:RE_bracket 
                    decl: []

                    min: 1
                    re: &86 !!perl/hash:RE_any 
                      a: 0
                      altname: regex_def_02
                      dba: regex_def
                      i: 0
                      min: 1
                      name: regex_def_02
                      r: 1
                      s: 1
                      zyg: 
                        - !!perl/hash:RE_sequence 
                          a: 0
                          alt: regex_def_02 0
                          dba: regex_def
                          i: 0
                          min: 1
                          r: 1
                          s: 1
                          zyg: 
                            - !!perl/hash:RE_method 
                              min: 0
                              name: ws
                              nobind: 1
                              noquant: 1
                              rest: ''
                            - !!perl/hash:RE_string 
                              a: 0
                              dba: regex_def
                              i: 0
                              min: 1
                              r: 1
                              s: 1
                              text: "&"
                            - !!perl/hash:RE_quantified_atom 
                              atom: !!perl/hash:RE_method 
                                a: 0
                                dba: regex_def
                                i: 0
                                min: 12345
                                name: deflongname
                                r: 1
                                rest: ''
                                s: 1
                              min: 0
                              quant: 
                                - "?"
                                - ":"
                                - ''
                                - 0
                            - !!perl/hash:RE_method 
                              min: 0
                              name: ws
                              nobind: 1
                              noquant: 1
                              rest: ''
                        - !!perl/hash:RE_sequence 
                          a: 0
                          alt: regex_def_02 1
                          dba: regex_def
                          i: 0
                          min: 12345
                          r: 1
                          s: 1
                          zyg: 
                            - !!perl/hash:RE_method 
                              min: 0
                              name: ws
                              nobind: 1
                              noquant: 1
                              rest: ''
                            - !!perl/hash:RE_method 
                              a: 0
                              dba: regex_def
                              i: 0
                              min: 12345
                              name: deflongname
                              r: 1
                              rest: ''
                              s: 1
                            - !!perl/hash:RE_method 
                              min: 0
                              name: ws
                              nobind: 1
                              noquant: 1
                              rest: ''
                  min: 0
                  quant: 
                    - "?"
                    - ":"
                    - ''
                    - 0
                - !!perl/hash:RE_method 
                  min: 0
                  name: ws
                  nobind: 1
                  noquant: 1
                  rest: ''
                - !!perl/hash:RE_method 
                  a: 0
                  dba: regex_def
                  i: 0
                  min: 12345
                  name: newpad
                  nobind: 1
                  r: 1
                  rest: ''
                  s: 1
                - !!perl/hash:RE_method 
                  min: 0
                  name: ws
                  nobind: 1
                  noquant: 1
                  rest: ''
                - !!perl/hash:RE_quantified_atom 
                  atom: !!perl/hash:RE_bracket 
                    decl: []

                    min: 12345
                    re: &18 !!perl/hash:RE_any 
                      a: 0
                      altname: regex_def_03
                      dba: regex_def
                      i: 0
                      min: 12345
                      name: regex_def_03
                      r: 1
                      s: 1
                      zyg: 
                        - !!perl/hash:RE_sequence 
                          a: 0
                          alt: regex_def_03 0
                          dba: regex_def
                          i: 0
                          min: 12347
                          r: 1
                          s: 1
                          zyg: 
                            - !!perl/hash:RE_method 
                              min: 0
                              name: ws
                              nobind: 1
                              noquant: 1
                              rest: ''
                            - !!perl/hash:RE_bracket 
                              decl: []

                              min: 12347
                              re: !!perl/hash:RE_sequence 
                                a: 0
                                dba: regex_def
                                i: 0
                                min: 12347
                                r: 1
                                s: 1
                                zyg: 
                                  - !!perl/hash:RE_quantified_atom 
                                    atom: !!perl/hash:RE_string 
                                      a: 0
                                      dba: regex_def
                                      i: 0
                                      min: 1
                                      r: 1
                                      s: 1
                                      text: ":"
                                    min: 0
                                    quant: 
                                      - "?"
                                      - ":"
                                      - ''
                                      - 0
                                  - !!perl/hash:RE_string 
                                    a: 0
                                    dba: regex_def
                                    i: 0
                                    min: 1
                                    r: 1
                                    s: 1
                                    text: (
                                  - !!perl/hash:RE_method 
                                    min: 0
                                    name: ws
                                    nobind: 1
                                    noquant: 1
                                    rest: ''
                                  - !!perl/hash:RE_method 
                                    a: 0
                                    dba: regex_def
                                    i: 0
                                    min: 12345
                                    name: signature
                                    r: 1
                                    rest: ''
                                    s: 1
                                  - !!perl/hash:RE_method 
                                    min: 0
                                    name: ws
                                    nobind: 1
                                    noquant: 1
                                    rest: ''
                                  - !!perl/hash:RE_string 
                                    a: 0
                                    dba: regex_def
                                    i: 0
                                    min: 1
                                    r: 1
                                    s: 1
                                    text: )
                            - !!perl/hash:RE_method 
                              min: 0
                              name: ws
                              nobind: 1
                              noquant: 1
                              rest: ''
                        - !!perl/hash:RE_sequence 
                          a: 0
                          alt: regex_def_03 1
                          dba: regex_def
                          i: 0
                          min: 12345
                          r: 1
                          s: 1
                          zyg: 
                            - !!perl/hash:RE_method 
                              min: 0
                              name: ws
                              nobind: 1
                              noquant: 1
                              rest: ''
                            - !!perl/hash:RE_method 
                              a: 0
                              dba: regex_def
                              i: 0
                              min: 12345
                              name: trait
                              r: 1
                              rest: ''
                              s: 1
                            - !!perl/hash:RE_method 
                              min: 0
                              name: ws
                              nobind: 1
                              noquant: 1
                              rest: ''
                  min: 0
                  quant: 
                    - "*"
                    - ":"
                    - ''
                    - 0
                - !!perl/hash:RE_method 
                  min: 0
                  name: ws
                  nobind: 1
                  noquant: 1
                  rest: ''
                - !!perl/hash:RE_block 
                  a: 0
                  context: void
                  dba: regex_def
                  i: 0
                  min: 0
                  r: 1
                  s: 1
                  text: " $*IN_DECL = 0; "
                - !!perl/hash:RE_method 
                  min: 0
                  name: ws
                  nobind: 1
                  noquant: 1
                  rest: ''
                - !!perl/hash:RE_method 
                  a: 0
                  dba: regex_def
                  i: 0
                  min: 12345
                  name: finishpad
                  nobind: 1
                  r: 1
                  rest: ''
                  s: 1
                - !!perl/hash:RE_method 
                  min: 0
                  name: ws
                  nobind: 1
                  noquant: 1
                  rest: ''
                - !!perl/hash:RE_method 
                  a: 0
                  dba: regex_def
                  i: 0
                  min: 12345
                  name: regex_block
                  r: 1
                  rest: ''
                  s: 1
          - !!perl/hash:RE_method 
            min: 0
            name: ws
            nobind: 1
            noquant: 1
            rest: ''
      - !!perl/hash:RE_sequence 
        a: 0
        dba: regex_def
        i: 0
        min: 0
        r: 1
        s: 1
        zyg: 
          - !!perl/hash:RE_method 
            min: 0
            name: ws
            nobind: 1
            noquant: 1
            rest: ''
          - !!perl/hash:RE_method 
            min: 0
            name: panic
            nobind: 1
            rest: ("Malformed regex")
          - !!perl/hash:RE_method 
            min: 0
            name: ws
            nobind: 1
            noquant: 1
            rest: ''
regex_def_02: *86
regex_def_03: *18
routine_declarator__S_097sub: !!perl/hash:RE 
  decl: []

  kind: token
  min: 37035
  pkg: ~
  re: !!perl/hash:RE_sequence 
    a: 0
    dba: routine_declarator__S_097sub
    i: 0
    min: 37035
    r: 1
    s: 0
    zyg: 
      - !!perl/hash:RE_method 
        a: 0
        dba: routine_declarator__S_097sub
        endsym: endid
        i: 0
        min: 12345
        name: sym
        r: 1
        rest: ''
        s: 0
        sym: sub
      - !!perl/hash:RE_method 
        a: 0
        dba: routine_declarator__S_097sub
        i: 0
        min: 12345
        name: endid
        nobind: 1
        r: 1
        rest: ''
        s: 0
      - !!perl/hash:RE_method 
        a: 0
        dba: routine_declarator__S_097sub
        i: 0
        min: 12345
        name: routine_def
        r: 1
        rest: ''
        s: 0
routine_declarator__S_098method: !!perl/hash:RE 
  decl: []

  kind: token
  min: 37035
  pkg: ~
  re: !!perl/hash:RE_sequence 
    a: 0
    dba: routine_declarator__S_098method
    i: 0
    min: 37035
    r: 1
    s: 0
    zyg: 
      - !!perl/hash:RE_method 
        a: 0
        dba: routine_declarator__S_098method
        endsym: endid
        i: 0
        min: 12345
        name: sym
        r: 1
        rest: ''
        s: 0
        sym: method
      - !!perl/hash:RE_method 
        a: 0
        dba: routine_declarator__S_098method
        i: 0
        min: 12345
        name: endid
        nobind: 1
        r: 1
        rest: ''
        s: 0
      - !!perl/hash:RE_method 
        a: 0
        dba: routine_declarator__S_098method
        i: 0
        min: 12345
        name: method_def
        r: 1
        rest: ''
        s: 0
routine_declarator__S_099submethod: !!perl/hash:RE 
  decl: []

  kind: token
  min: 37035
  pkg: ~
  re: !!perl/hash:RE_sequence 
    a: 0
    dba: routine_declarator__S_099submethod
    i: 0
    min: 37035
    r: 1
    s: 0
    zyg: 
      - !!perl/hash:RE_method 
        a: 0
        dba: routine_declarator__S_099submethod
        endsym: endid
        i: 0
        min: 12345
        name: sym
        r: 1
        rest: ''
        s: 0
        sym: submethod
      - !!perl/hash:RE_method 
        a: 0
        dba: routine_declarator__S_099submethod
        i: 0
        min: 12345
        name: endid
        nobind: 1
        r: 1
        rest: ''
        s: 0
      - !!perl/hash:RE_method 
        a: 0
        dba: routine_declarator__S_099submethod
        i: 0
        min: 12345
        name: method_def
        r: 1
        rest: ''
        s: 0
routine_declarator__S_100macro: !!perl/hash:RE 
  decl: []

  kind: token
  min: 37035
  pkg: ~
  re: !!perl/hash:RE_sequence 
    a: 0
    dba: routine_declarator__S_100macro
    i: 0
    min: 37035
    r: 1
    s: 0
    zyg: 
      - !!perl/hash:RE_method 
        a: 0
        dba: routine_declarator__S_100macro
        endsym: endid
        i: 0
        min: 12345
        name: sym
        r: 1
        rest: ''
        s: 0
        sym: macro
      - !!perl/hash:RE_method 
        a: 0
        dba: routine_declarator__S_100macro
        i: 0
        min: 12345
        name: endid
        nobind: 1
        r: 1
        rest: ''
        s: 0
      - !!perl/hash:RE_method 
        a: 0
        dba: routine_declarator__S_100macro
        i: 0
        min: 12345
        name: macro_def
        r: 1
        rest: ''
        s: 0
routine_def: !!perl/hash:RE 
  decl: 
    - !!perl/hash:RE_decl 
      a: 0
      dba: routine_def
      i: 0
      max: 0
      min: 0
      r: 1
      s: 1
      text: my $IN_DECL is context<rw> = 1
    - !!perl/hash:RE_decl 
      a: 0
      dba: routine_def
      i: 0
      max: 0
      min: 0
      r: 1
      s: 1
      text: my $DECLARAND is context<rw>
  kind: rule
  min: 0
  pkg: ~
  re: !!perl/hash:RE_first 
    a: 0
    dba: routine_def
    i: 0
    min: 0
    r: 1
    s: 1
    zyg: 
      - !!perl/hash:RE_sequence 
        a: 0
        dba: routine_def
        i: 0
        min: 24690
        r: 1
        s: 1
        zyg: 
          - !!perl/hash:RE_method 
            min: 0
            name: ws
            nobind: 1
            noquant: 1
            rest: ''
          - !!perl/hash:RE_bracket 
            decl: []

            min: 24690
            re: !!perl/hash:RE_sequence 
              a: 0
              dba: routine_def
              i: 0
              min: 24690
              r: 1
              s: 0
              zyg: 
                - !!perl/hash:RE_quantified_atom 
                  atom: !!perl/hash:RE_bracket 
                    decl: []

                    min: 1
                    re: &114 !!perl/hash:RE_any 
                      a: 0
                      altname: routine_def_02
                      dba: routine_def
                      i: 0
                      min: 1
                      name: routine_def_02
                      r: 1
                      s: 1
                      zyg: 
                        - !!perl/hash:RE_sequence 
                          a: 0
                          alt: routine_def_02 0
                          dba: routine_def
                          i: 0
                          min: 1
                          r: 1
                          s: 1
                          zyg: 
                            - !!perl/hash:RE_method 
                              min: 0
                              name: ws
                              nobind: 1
                              noquant: 1
                              rest: ''
                            - !!perl/hash:RE_string 
                              a: 0
                              dba: routine_def
                              i: 0
                              min: 1
                              r: 1
                              s: 1
                              text: "&"
                            - !!perl/hash:RE_quantified_atom 
                              atom: !!perl/hash:RE_method 
                                a: 0
                                dba: routine_def
                                i: 0
                                min: 12345
                                name: deflongname
                                r: 1
                                rest: ''
                                s: 1
                              min: 0
                              quant: 
                                - "?"
                                - ":"
                                - ''
                                - 0
                            - !!perl/hash:RE_method 
                              min: 0
                              name: ws
                              nobind: 1
                              noquant: 1
                              rest: ''
                        - !!perl/hash:RE_sequence 
                          a: 0
                          alt: routine_def_02 1
                          dba: routine_def
                          i: 0
                          min: 12345
                          r: 1
                          s: 1
                          zyg: 
                            - !!perl/hash:RE_method 
                              min: 0
                              name: ws
                              nobind: 1
                              noquant: 1
                              rest: ''
                            - !!perl/hash:RE_method 
                              a: 0
                              dba: routine_def
                              i: 0
                              min: 12345
                              name: deflongname
                              r: 1
                              rest: ''
                              s: 1
                            - !!perl/hash:RE_method 
                              min: 0
                              name: ws
                              nobind: 1
                              noquant: 1
                              rest: ''
                  min: 0
                  quant: 
                    - "?"
                    - ":"
                    - ''
                    - 0
                - !!perl/hash:RE_method 
                  min: 0
                  name: ws
                  nobind: 1
                  noquant: 1
                  rest: ''
                - !!perl/hash:RE_method 
                  a: 0
                  dba: routine_def
                  i: 0
                  min: 12345
                  name: newpad
                  nobind: 1
                  r: 1
                  rest: ''
                  s: 1
                - !!perl/hash:RE_method 
                  min: 0
                  name: ws
                  nobind: 1
                  noquant: 1
                  rest: ''
                - !!perl/hash:RE_quantified_atom 
                  atom: !!perl/hash:RE_bracket 
                    decl: []

                    min: 12345
                    re: &90 !!perl/hash:RE_any 
                      a: 0
                      altname: routine_def_03
                      dba: routine_def
                      i: 0
                      min: 12345
                      name: routine_def_03
                      r: 1
                      s: 1
                      zyg: 
                        - !!perl/hash:RE_sequence 
                          a: 0
                          alt: routine_def_03 0
                          dba: routine_def
                          i: 0
                          min: 12345
                          r: 1
                          s: 1
                          zyg: 
                            - !!perl/hash:RE_method 
                              min: 0
                              name: ws
                              nobind: 1
                              noquant: 1
                              rest: ''
                            - !!perl/hash:RE_method 
                              a: 0
                              dba: routine_def
                              i: 0
                              min: 12345
                              name: multisig
                              r: 1
                              rest: ''
                              s: 1
                            - !!perl/hash:RE_method 
                              min: 0
                              name: ws
                              nobind: 1
                              noquant: 1
                              rest: ''
                        - !!perl/hash:RE_sequence 
                          a: 0
                          alt: routine_def_03 1
                          dba: routine_def
                          i: 0
                          min: 12345
                          r: 1
                          s: 1
                          zyg: 
                            - !!perl/hash:RE_method 
                              min: 0
                              name: ws
                              nobind: 1
                              noquant: 1
                              rest: ''
                            - !!perl/hash:RE_method 
                              a: 0
                              dba: routine_def
                              i: 0
                              min: 12345
                              name: trait
                              r: 1
                              rest: ''
                              s: 1
                            - !!perl/hash:RE_method 
                              min: 0
                              name: ws
                              nobind: 1
                              noquant: 1
                              rest: ''
                  min: 0
                  quant: 
                    - "*"
                    - ":"
                    - ''
                    - 0
                - !!perl/hash:RE_method 
                  min: 0
                  name: ws
                  nobind: 1
                  noquant: 1
                  rest: ''
                - !!perl/hash:RE_assertion 
                  assert: "!"
                  min: 0
                  re: !!perl/hash:RE_block 
                    a: 0
                    context: bool
                    dba: routine_def
                    i: 0
                    min: 0
                    nobind: 1
                    r: 1
                    s: 1
                    text: "\n            $*IN_DECL = 0;\n        "
                - !!perl/hash:RE_method 
                  min: 0
                  name: ws
                  nobind: 1
                  noquant: 1
                  rest: ''
                - !!perl/hash:RE_method 
                  a: 0
                  dba: routine_def
                  i: 0
                  min: 12345
                  name: blockoid
                  r: 1
                  rest: ''
                  s: 1
          - !!perl/hash:RE_method 
            min: 0
            name: ws
            nobind: 1
            noquant: 1
            rest: ''
      - !!perl/hash:RE_sequence 
        a: 0
        dba: routine_def
        i: 0
        min: 0
        r: 1
        s: 1
        zyg: 
          - !!perl/hash:RE_method 
            min: 0
            name: ws
            nobind: 1
            noquant: 1
            rest: ''
          - !!perl/hash:RE_method 
            min: 0
            name: panic
            nobind: 1
            rest: ("Malformed routine")
          - !!perl/hash:RE_method 
            min: 0
            name: ws
            nobind: 1
            noquant: 1
            rest: ''
routine_def_02: *114
routine_def_03: *90
scope_declarator__S_076my: !!perl/hash:RE 
  decl: []

  kind: token
  min: 37035
  pkg: ~
  re: !!perl/hash:RE_sequence 
    a: 0
    dba: scope_declarator__S_076my
    i: 0
    min: 37035
    r: 1
    s: 0
    zyg: 
      - !!perl/hash:RE_method 
        a: 0
        dba: scope_declarator__S_076my
        endsym: nofun
        i: 0
        min: 12345
        name: sym
        r: 1
        rest: ''
        s: 0
        sym: my
      - !!perl/hash:RE_method 
        a: 0
        dba: scope_declarator__S_076my
        i: 0
        min: 12345
        name: nofun
        nobind: 1
        r: 1
        rest: ''
        s: 0
      - !!perl/hash:RE_block 
        a: 0
        context: void
        dba: scope_declarator__S_076my
        i: 0
        min: 0
        r: 1
        s: 0
        text: " $*SCOPE = $<sym> "
      - !!perl/hash:RE_method 
        a: 0
        dba: scope_declarator__S_076my
        i: 0
        min: 12345
        name: scoped
        r: 1
        rest: ''
        s: 0
scope_declarator__S_077our: !!perl/hash:RE 
  decl: []

  kind: token
  min: 37035
  pkg: ~
  re: !!perl/hash:RE_sequence 
    a: 0
    dba: scope_declarator__S_077our
    i: 0
    min: 37035
    r: 1
    s: 0
    zyg: 
      - !!perl/hash:RE_method 
        a: 0
        dba: scope_declarator__S_077our
        endsym: nofun
        i: 0
        min: 12345
        name: sym
        r: 1
        rest: ''
        s: 0
        sym: our
      - !!perl/hash:RE_method 
        a: 0
        dba: scope_declarator__S_077our
        i: 0
        min: 12345
        name: nofun
        nobind: 1
        r: 1
        rest: ''
        s: 0
      - !!perl/hash:RE_block 
        a: 0
        context: void
        dba: scope_declarator__S_077our
        i: 0
        min: 0
        r: 1
        s: 0
        text: " $*SCOPE = $<sym> "
      - !!perl/hash:RE_method 
        a: 0
        dba: scope_declarator__S_077our
        i: 0
        min: 12345
        name: scoped
        r: 1
        rest: ''
        s: 0
scope_declarator__S_078state: !!perl/hash:RE 
  decl: []

  kind: token
  min: 37035
  pkg: ~
  re: !!perl/hash:RE_sequence 
    a: 0
    dba: scope_declarator__S_078state
    i: 0
    min: 37035
    r: 1
    s: 0
    zyg: 
      - !!perl/hash:RE_method 
        a: 0
        dba: scope_declarator__S_078state
        endsym: nofun
        i: 0
        min: 12345
        name: sym
        r: 1
        rest: ''
        s: 0
        sym: state
      - !!perl/hash:RE_method 
        a: 0
        dba: scope_declarator__S_078state
        i: 0
        min: 12345
        name: nofun
        nobind: 1
        r: 1
        rest: ''
        s: 0
      - !!perl/hash:RE_block 
        a: 0
        context: void
        dba: scope_declarator__S_078state
        i: 0
        min: 0
        r: 1
        s: 0
        text: " $*SCOPE = $<sym> "
      - !!perl/hash:RE_method 
        a: 0
        dba: scope_declarator__S_078state
        i: 0
        min: 12345
        name: scoped
        r: 1
        rest: ''
        s: 0
scope_declarator__S_079constant: !!perl/hash:RE 
  decl: []

  kind: token
  min: 37035
  pkg: ~
  re: !!perl/hash:RE_sequence 
    a: 0
    dba: scope_declarator__S_079constant
    i: 0
    min: 37035
    r: 1
    s: 0
    zyg: 
      - !!perl/hash:RE_method 
        a: 0
        dba: scope_declarator__S_079constant
        endsym: nofun
        i: 0
        min: 12345
        name: sym
        r: 1
        rest: ''
        s: 0
        sym: constant
      - !!perl/hash:RE_method 
        a: 0
        dba: scope_declarator__S_079constant
        i: 0
        min: 12345
        name: nofun
        nobind: 1
        r: 1
        rest: ''
        s: 0
      - !!perl/hash:RE_block 
        a: 0
        context: void
        dba: scope_declarator__S_079constant
        i: 0
        min: 0
        r: 1
        s: 0
        text: " $*SCOPE = $<sym> "
      - !!perl/hash:RE_method 
        a: 0
        dba: scope_declarator__S_079constant
        i: 0
        min: 12345
        name: scoped
        r: 1
        rest: ''
        s: 0
scope_declarator__S_080has: !!perl/hash:RE 
  decl: []

  kind: token
  min: 37035
  pkg: ~
  re: !!perl/hash:RE_sequence 
    a: 0
    dba: scope_declarator__S_080has
    i: 0
    min: 37035
    r: 1
    s: 0
    zyg: 
      - !!perl/hash:RE_method 
        a: 0
        dba: scope_declarator__S_080has
        endsym: nofun
        i: 0
        min: 12345
        name: sym
        r: 1
        rest: ''
        s: 0
        sym: has
      - !!perl/hash:RE_method 
        a: 0
        dba: scope_declarator__S_080has
        i: 0
        min: 12345
        name: nofun
        nobind: 1
        r: 1
        rest: ''
        s: 0
      - !!perl/hash:RE_block 
        a: 0
        context: void
        dba: scope_declarator__S_080has
        i: 0
        min: 0
        r: 1
        s: 0
        text: " $*SCOPE = $<sym> "
      - !!perl/hash:RE_method 
        a: 0
        dba: scope_declarator__S_080has
        i: 0
        min: 12345
        name: scoped
        r: 1
        rest: ''
        s: 0
scope_declarator__S_081augment: !!perl/hash:RE 
  decl: []

  kind: token
  min: 37035
  pkg: ~
  re: !!perl/hash:RE_sequence 
    a: 0
    dba: scope_declarator__S_081augment
    i: 0
    min: 37035
    r: 1
    s: 0
    zyg: 
      - !!perl/hash:RE_method 
        a: 0
        dba: scope_declarator__S_081augment
        endsym: nofun
        i: 0
        min: 12345
        name: sym
        r: 1
        rest: ''
        s: 0
        sym: augment
      - !!perl/hash:RE_method 
        a: 0
        dba: scope_declarator__S_081augment
        i: 0
        min: 12345
        name: nofun
        nobind: 1
        r: 1
        rest: ''
        s: 0
      - !!perl/hash:RE_block 
        a: 0
        context: void
        dba: scope_declarator__S_081augment
        i: 0
        min: 0
        r: 1
        s: 0
        text: " $*SCOPE = $<sym> "
      - !!perl/hash:RE_method 
        a: 0
        dba: scope_declarator__S_081augment
        i: 0
        min: 12345
        name: scoped
        r: 1
        rest: ''
        s: 0
scope_declarator__S_082supersede: !!perl/hash:RE 
  decl: []

  kind: token
  min: 37035
  pkg: ~
  re: !!perl/hash:RE_sequence 
    a: 0
    dba: scope_declarator__S_082supersede
    i: 0
    min: 37035
    r: 1
    s: 0
    zyg: 
      - !!perl/hash:RE_method 
        a: 0
        dba: scope_declarator__S_082supersede
        endsym: nofun
        i: 0
        min: 12345
        name: sym
        r: 1
        rest: ''
        s: 0
        sym: supersede
      - !!perl/hash:RE_method 
        a: 0
        dba: scope_declarator__S_082supersede
        i: 0
        min: 12345
        name: nofun
        nobind: 1
        r: 1
        rest: ''
        s: 0
      - !!perl/hash:RE_block 
        a: 0
        context: void
        dba: scope_declarator__S_082supersede
        i: 0
        min: 0
        r: 1
        s: 0
        text: " $*SCOPE = $<sym> "
      - !!perl/hash:RE_method 
        a: 0
        dba: scope_declarator__S_082supersede
        i: 0
        min: 12345
        name: scoped
        r: 1
        rest: ''
        s: 0
scoped: !!perl/hash:RE 
  decl: []

  kind: rule
  min: 0
  pkg: ~
  re: !!perl/hash:RE_first 
    a: 0
    dba: scoped declarator
    i: 0
    min: 0
    r: 1
    s: 1
    zyg: 
      - !!perl/hash:RE_sequence 
        a: 0
        dba: scoped declarator
        i: 0
        min: 12345
        r: 1
        s: 1
        zyg: 
          - !!perl/hash:RE_method 
            min: 0
            name: ws
            nobind: 1
            noquant: 1
            rest: ''
          - !!perl/hash:RE_method 
            min: 0
            name: ws
            nobind: 1
            noquant: 1
            rest: ''
          - !!perl/hash:RE_bracket 
            decl: []

            min: 12345
            re: &56 !!perl/hash:RE_any 
              a: 0
              altname: scoped_01
              dba: scoped declarator
              i: 0
              min: 12345
              name: scoped_01
              r: 1
              s: 1
              zyg: 
                - !!perl/hash:RE_sequence 
                  a: 0
                  alt: scoped_01 0
                  dba: scoped declarator
                  i: 0
                  min: 12345
                  r: 1
                  s: 1
                  zyg: 
                    - !!perl/hash:RE_method 
                      a: 0
                      dba: scoped declarator
                      i: 0
                      min: 12345
                      name: declarator
                      r: 1
                      rest: ''
                      s: 1
                    - !!perl/hash:RE_method 
                      min: 0
                      name: ws
                      nobind: 1
                      noquant: 1
                      rest: ''
                - !!perl/hash:RE_sequence 
                  a: 0
                  alt: scoped_01 1
                  dba: scoped declarator
                  i: 0
                  min: 12345
                  r: 1
                  s: 1
                  zyg: 
                    - !!perl/hash:RE_method 
                      a: 0
                      dba: scoped declarator
                      i: 0
                      min: 12345
                      name: regex_declarator
                      r: 1
                      rest: ''
                      s: 1
                    - !!perl/hash:RE_method 
                      min: 0
                      name: ws
                      nobind: 1
                      noquant: 1
                      rest: ''
                - !!perl/hash:RE_sequence 
                  a: 0
                  alt: scoped_01 2
                  dba: scoped declarator
                  i: 0
                  min: 12345
                  r: 1
                  s: 1
                  zyg: 
                    - !!perl/hash:RE_method 
                      a: 0
                      dba: scoped declarator
                      i: 0
                      min: 12345
                      name: package_declarator
                      r: 1
                      rest: ''
                      s: 1
                    - !!perl/hash:RE_method 
                      min: 0
                      name: ws
                      nobind: 1
                      noquant: 1
                      rest: ''
                - !!perl/hash:RE_sequence 
                  a: 0
                  alt: scoped_01 3
                  dba: scoped declarator
                  i: 0
                  min: 24690
                  r: 1
                  s: 1
                  zyg: 
                    - !!perl/hash:RE_quantified_atom 
                      atom: !!perl/hash:RE_method 
                        a: 0
                        dba: scoped declarator
                        i: 0
                        min: 12345
                        name: typename
                        r: 1
                        rest: ''
                        s: 1
                      min: 12345
                      quant: 
                        - +
                        - ":"
                        - ''
                        - 1
                    - !!perl/hash:RE_method 
                      min: 0
                      name: ws
                      nobind: 1
                      noquant: 1
                      rest: ''
                    - !!perl/hash:RE_block 
                      a: 0
                      context: void
                      dba: scoped declarator
                      i: 0
                      min: 0
                      r: 1
                      s: 1
                      text: "\n            my $t = $<typename>;\n            @$t > 1 and $¢.panic(\"Multiple prefix constraints not yet supported\")\n        "
                    - !!perl/hash:RE_method 
                      min: 0
                      name: ws
                      nobind: 1
                      noquant: 1
                      rest: ''
                    - !!perl/hash:RE_method 
                      a: 0
                      dba: scoped declarator
                      i: 0
                      min: 12345
                      name: multi_declarator
                      r: 1
                      rest: ''
                      s: 1
                    - !!perl/hash:RE_method 
                      min: 0
                      name: ws
                      nobind: 1
                      noquant: 1
                      rest: ''
                - !!perl/hash:RE_sequence 
                  a: 0
                  alt: scoped_01 4
                  dba: scoped declarator
                  i: 0
                  min: 12345
                  r: 1
                  s: 1
                  zyg: 
                    - !!perl/hash:RE_method 
                      a: 0
                      dba: scoped declarator
                      i: 0
                      min: 12345
                      name: multi_declarator
                      r: 1
                      rest: ''
                      s: 1
                    - !!perl/hash:RE_method 
                      min: 0
                      name: ws
                      nobind: 1
                      noquant: 1
                      rest: ''
          - !!perl/hash:RE_method 
            min: 0
            name: ws
            nobind: 1
            noquant: 1
            rest: ''
      - !!perl/hash:RE_sequence 
        a: 0
        dba: scoped declarator
        i: 0
        min: 12345
        r: 1
        s: 1
        zyg: 
          - !!perl/hash:RE_method 
            min: 0
            name: ws
            nobind: 1
            noquant: 1
            rest: ''
          - !!perl/hash:RE_assertion 
            assert: "?"
            min: 0
            re: !!perl/hash:RE_method_re 
              a: 0
              dba: scoped declarator
              i: 0
              min: 0
              name: before
              nobind: 1
              r: 1
              re: !!perl/hash:RE 
                decl: []

                min: 1
                re: !!perl/hash:RE_cclass 
                  a: 0
                  dba: scoped declarator
                  i: 0
                  min: 1
                  r: 1
                  s: 1
                  text: "[A..Z]"
              s: 1
          - !!perl/hash:RE_method 
            a: 0
            dba: scoped declarator
            i: 0
            min: 12345
            name: longname
            r: 1
            rest: ''
            s: 1
          - !!perl/hash:RE_block 
            a: 0
            context: void
            dba: scoped declarator
            i: 0
            min: 0
            r: 1
            s: 1
            text: "\n            my $t = $<longname>.Str;\n            if not $¢.is_known($t) {\n                $¢.panic(\"In \\\"$*SCOPE\\\" declaration, typename $t must be predeclared (or marked as declarative with :: prefix)\");\n            }\n        "
          - !!perl/hash:RE_method 
            min: 0
            name: ws
            nobind: 1
            noquant: 1
            rest: ''
          - !!perl/hash:RE_assertion 
            assert: "!"
            min: 0
            re: !!perl/hash:RE_noop 
              a: 0
              dba: scoped declarator
              i: 0
              min: 0
              nobind: 1
              r: 1
              s: 1
          - !!perl/hash:RE_method 
            min: 0
            name: ws
            nobind: 1
            noquant: 1
            rest: ''
      - !!perl/hash:RE_sequence 
        a: 0
        dba: scoped declarator
        i: 0
        min: 0
        r: 1
        s: 1
        zyg: 
          - !!perl/hash:RE_method 
            min: 0
            name: ws
            nobind: 1
            noquant: 1
            rest: ''
          - !!perl/hash:RE_method 
            min: 0
            name: panic
            nobind: 1
            rest: ("Malformed $*SCOPE")
          - !!perl/hash:RE_method 
            min: 0
            name: ws
            nobind: 1
            noquant: 1
            rest: ''
scoped_01: *56
semiarglist: !!perl/hash:RE 
  decl: []

  kind: token
  min: 24690
  pkg: ~
  re: !!perl/hash:RE_sequence 
    a: 0
    dba: semiarglist
    i: 0
    min: 24690
    r: 1
    s: 0
    zyg: 
      - !!perl/hash:RE_quantified_atom 
        atom: !!perl/hash:RE_method 
          a: 0
          dba: semiarglist
          i: 0
          min: 12345
          name: arglist
          r: 1
          rest: ''
          s: 0
        min: 12345
        quant: 
          - "**"
          - ":"
          - !!perl/hash:RE_string 
            a: 0
            dba: semiarglist
            i: 0
            min: 1
            r: 1
            s: 0
            text: ;
          - 1
      - !!perl/hash:RE_method 
        a: 0
        dba: semiarglist
        i: 0
        min: 12345
        name: ws
        nobind: 1
        r: 1
        rest: ''
        s: 0
semilist: !!perl/hash:RE 
  decl: 
    - !!perl/hash:RE_decl 
      a: 0
      dba: semilist
      i: 0
      max: 0
      min: 0
      r: 1
      s: 1
      text: my $INVOCANT_OK is context<rw> = 0
  kind: rule
  min: 0
  pkg: ~
  re: !!perl/hash:RE_sequence 
    a: 0
    dba: semicolon list
    i: 0
    min: 0
    r: 1
    s: 1
    zyg: 
      - !!perl/hash:RE_method 
        min: 0
        name: ws
        nobind: 1
        noquant: 1
        rest: ''
      - !!perl/hash:RE_method 
        min: 0
        name: ws
        nobind: 1
        noquant: 1
        rest: ''
      - !!perl/hash:RE_bracket 
        decl: []

        min: 0
        re: &41 !!perl/hash:RE_any 
          a: 0
          altname: semilist_01
          dba: semicolon list
          i: 0
          min: 0
          name: semilist_01
          r: 1
          s: 1
          zyg: 
            - !!perl/hash:RE_sequence 
              a: 0
              alt: semilist_01 0
              dba: semicolon list
              i: 0
              min: 0
              r: 1
              s: 1
              zyg: 
                - !!perl/hash:RE_assertion 
                  assert: "?"
                  min: 0
                  re: !!perl/hash:RE_method_re 
                    a: 0
                    dba: semicolon list
                    i: 0
                    min: 0
                    name: before
                    nobind: 1
                    r: 1
                    re: !!perl/hash:RE 
                      decl: []

                      min: 1
                      re: !!perl/hash:RE_sequence 
                        a: 0
                        dba: semicolon list
                        i: 0
                        min: 1
                        r: 1
                        s: 1
                        zyg: 
                          - !!perl/hash:RE_cclass 
                            a: 0
                            dba: semicolon list
                            i: 0
                            min: 1
                            r: 1
                            s: 1
                            text: "[\\)\\]\\}]"
                          - !!perl/hash:RE_method 
                            min: 0
                            name: ws
                            nobind: 1
                            noquant: 1
                            rest: ''
                    s: 1
                - !!perl/hash:RE_method 
                  min: 0
                  name: ws
                  nobind: 1
                  noquant: 1
                  rest: ''
            - !!perl/hash:RE_sequence 
              a: 0
              alt: semilist_01 1
              dba: semicolon list
              i: 0
              min: 0
              r: 1
              s: 1
              zyg: 
                - !!perl/hash:RE_quantified_atom 
                  atom: !!perl/hash:RE_bracket 
                    decl: []

                    min: 24690
                    re: !!perl/hash:RE_sequence 
                      a: 0
                      dba: semicolon list
                      i: 0
                      min: 24690
                      r: 1
                      s: 1
                      zyg: 
                        - !!perl/hash:RE_method 
                          a: 0
                          dba: semicolon list
                          i: 0
                          min: 12345
                          name: statement
                          r: 1
                          rest: ''
                          s: 1
                        - !!perl/hash:RE_method 
                          a: 0
                          dba: semicolon list
                          i: 0
                          min: 12345
                          name: eat_terminator
                          r: 1
                          rest: ''
                          s: 1
                        - !!perl/hash:RE_method 
                          min: 0
                          name: ws
                          nobind: 1
                          noquant: 1
                          rest: ''
                  min: 0
                  quant: 
                    - "*"
                    - ":"
                    - ''
                    - 0
                - !!perl/hash:RE_method 
                  min: 0
                  name: ws
                  nobind: 1
                  noquant: 1
                  rest: ''
      - !!perl/hash:RE_method 
        min: 0
        name: ws
        nobind: 1
        noquant: 1
        rest: ''
semilist_01: *41
sibble: !!perl/hash:RE 
  decl: 
    - !!perl/hash:RE_decl 
      a: 0
      dba: sibble
      i: 0
      max: 0
      min: 0
      r: 1
      s: 0
      text: my ($lang, $start, $stop)
  kind: token
  min: 0
  pkg: ~
  re: !!perl/hash:RE_sequence 
    a: 0
    dba: sibble
    i: 0
    min: 0
    r: 1
    s: 0
    zyg: 
      - !!perl/hash:RE_method 
        min: 0
        name: babble
        rest: ($l)
      - !!perl/hash:RE_block 
        a: 0
        context: void
        dba: sibble
        i: 0
        min: 0
        r: 1
        s: 0
        text: " my $B = $<babble><B>; ($lang,$start,$stop) = @$B; "
      - !!perl/hash:RE_var 
        a: 0
        dba: sibble
        i: 0
        min: 0
        r: 1
        s: 0
        var: $start
      - !!perl/hash:RE_bindnamed 
        a: 0
        atom: !!perl/hash:RE_method 
          min: 0
          name: nibble
          nobind: 1
          rest: ($lang)
        dba: sibble
        i: 0
        min: 0
        r: 1
        s: 0
        var: left
      - !!perl/hash:RE_bracket 
        decl: []

        min: 0
        re: !!perl/hash:RE_first 
          a: 0
          dba: sibble
          i: 0
          min: 0
          r: 1
          s: 0
          zyg: 
            - !!perl/hash:RE_var 
              a: 0
              dba: sibble
              i: 0
              min: 0
              r: 1
              s: 0
              var: $stop
            - !!perl/hash:RE_method 
              min: 0
              name: panic
              nobind: 1
              rest: ("Couldn't find terminator $stop")
      - !!perl/hash:RE_bracket 
        decl: []

        min: 0
        re: !!perl/hash:RE_first 
          a: 0
          dba: sibble
          i: 0
          min: 0
          r: 1
          s: 0
          zyg: 
            - !!perl/hash:RE_sequence 
              a: 0
              dba: sibble
              i: 0
              min: 24690
              r: 1
              s: 0
              zyg: 
                - !!perl/hash:RE_assertion 
                  assert: "?"
                  min: 0
                  re: !!perl/hash:RE_block 
                    a: 0
                    context: bool
                    dba: sibble
                    i: 0
                    min: 0
                    nobind: 1
                    r: 1
                    s: 0
                    text: " $start ne $stop "
                - !!perl/hash:RE_method 
                  a: 0
                  dba: sibble
                  i: 0
                  min: 12345
                  name: ws
                  nobind: 1
                  r: 1
                  rest: ''
                  s: 0
                - !!perl/hash:RE_bracket 
                  decl: []

                  min: 0
                  re: !!perl/hash:RE_first 
                    a: 0
                    dba: sibble
                    i: 0
                    min: 0
                    r: 1
                    s: 0
                    zyg: 
                      - !!perl/hash:RE_method 
                        a: 0
                        dba: sibble
                        i: 0
                        min: 12345
                        name: infixish
                        r: 1
                        rest: ''
                        s: 0
                      - !!perl/hash:RE_method 
                        min: 0
                        name: panic
                        rest: ("Missing assignment operator")
                - !!perl/hash:RE_bracket 
                  decl: []

                  min: 0
                  re: !!perl/hash:RE_first 
                    a: 0
                    dba: sibble
                    i: 0
                    min: 0
                    r: 1
                    s: 0
                    zyg: 
                      - !!perl/hash:RE_assertion 
                        assert: "?"
                        min: 0
                        re: !!perl/hash:RE_block 
                          a: 0
                          context: bool
                          dba: sibble
                          i: 0
                          min: 0
                          nobind: 1
                          r: 1
                          s: 0
                          text: " $<infixish>.Str eq '=' || $<infixish>.<infix_postfix_meta_operator> "
                      - !!perl/hash:RE_method 
                        min: 0
                        name: panic
                        nobind: 1
                        rest: ("Malformed assignment operator")
                - !!perl/hash:RE_method 
                  a: 0
                  dba: sibble
                  i: 0
                  min: 12345
                  name: ws
                  nobind: 1
                  r: 1
                  rest: ''
                  s: 0
                - !!perl/hash:RE_bindnamed 
                  a: 0
                  atom: !!perl/hash:RE_method 
                    min: 0
                    name: EXPR
                    nobind: 1
                    rest: (item %item_assignment)
                  dba: sibble
                  i: 0
                  min: 0
                  r: 1
                  s: 0
                  var: right
            - !!perl/hash:RE_sequence 
              a: 0
              dba: sibble
              i: 0
              min: 0
              r: 1
              s: 0
              zyg: 
                - !!perl/hash:RE_block 
                  a: 0
                  context: void
                  dba: sibble
                  i: 0
                  min: 0
                  r: 1
                  s: 0
                  text: " $lang = $lang2.unbalanced($stop); "
                - !!perl/hash:RE_bindnamed 
                  a: 0
                  atom: !!perl/hash:RE_method 
                    min: 0
                    name: nibble
                    nobind: 1
                    rest: ($lang)
                  dba: sibble
                  i: 0
                  min: 0
                  r: 1
                  s: 0
                  var: right
                - !!perl/hash:RE_var 
                  a: 0
                  dba: sibble
                  i: 0
                  min: 0
                  r: 1
                  s: 0
                  var: $stop
sigil__S_172Dollar: !!perl/hash:RE 
  decl: []

  kind: token
  min: 12345
  pkg: ~
  re: !!perl/hash:RE_method 
    a: 0
    dba: sigil__S_172Dollar
    i: 0
    min: 12345
    name: sym
    r: 1
    rest: ''
    s: 0
    sym: $
sigil__S_173AtAt: !!perl/hash:RE 
  decl: []

  kind: token
  min: 12345
  pkg: ~
  re: !!perl/hash:RE_method 
    a: 0
    dba: sigil__S_173AtAt
    i: 0
    min: 12345
    name: sym
    r: 1
    rest: ''
    s: 0
    sym: "@@"
sigil__S_174At: !!perl/hash:RE 
  decl: []

  kind: token
  min: 12345
  pkg: ~
  re: !!perl/hash:RE_method 
    a: 0
    dba: sigil__S_174At
    i: 0
    min: 12345
    name: sym
    r: 1
    rest: ''
    s: 0
    sym: "@"
sigil__S_175Percent: !!perl/hash:RE 
  decl: []

  kind: token
  min: 12345
  pkg: ~
  re: !!perl/hash:RE_method 
    a: 0
    dba: sigil__S_175Percent
    i: 0
    min: 12345
    name: sym
    r: 1
    rest: ''
    s: 0
    sym: "%"
sigil__S_176Amp: !!perl/hash:RE 
  decl: []

  kind: token
  min: 12345
  pkg: ~
  re: !!perl/hash:RE_method 
    a: 0
    dba: sigil__S_176Amp
    i: 0
    min: 12345
    name: sym
    r: 1
    rest: ''
    s: 0
    sym: "&"
signature: !!perl/hash:RE 
  decl: 
    - !!perl/hash:RE_decl 
      a: 0
      dba: signature
      i: 0
      max: 0
      min: 0
      r: 1
      s: 0
      text: my $IN_DECL is context<rw> = 1
    - !!perl/hash:RE_decl 
      a: 0
      dba: signature
      i: 0
      max: 0
      min: 0
      r: 1
      s: 0
      text: my $zone is context<rw> = 'posreq'
    - !!perl/hash:RE_decl 
      a: 0
      dba: signature
      i: 0
      max: 0
      min: 0
      r: 1
      s: 0
      text: my $startpos = self.pos
  kind: token
  min: 24690
  pkg: ~
  re: !!perl/hash:RE_sequence 
    a: 0
    dba: signature
    i: 0
    min: 24690
    r: 1
    s: 0
    zyg: 
      - !!perl/hash:RE_method 
        a: 0
        dba: signature
        i: 0
        min: 12345
        name: ws
        nobind: 1
        r: 1
        rest: ''
        s: 0
      - !!perl/hash:RE_quantified_atom 
        atom: !!perl/hash:RE_bracket 
          decl: []

          min: 0
          re: &64 !!perl/hash:RE_any 
            a: 0
            altname: signature_01
            dba: signature
            i: 0
            min: 0
            name: signature_01
            r: 1
            s: 0
            zyg: 
              - !!perl/hash:RE_assertion 
                alt: signature_01 0
                assert: "?"
                min: 0
                re: !!perl/hash:RE_method_re 
                  a: 0
                  dba: signature
                  i: 0
                  min: 0
                  name: before
                  nobind: 1
                  r: 1
                  re: !!perl/hash:RE 
                    decl: []

                    min: 1
                    re: &9 !!perl/hash:RE_any 
                      a: 0
                      altname: signature_02
                      dba: signature
                      i: 0
                      min: 1
                      name: signature_02
                      r: 1
                      s: 0
                      zyg: 
                        - !!perl/hash:RE_string 
                          a: 0
                          alt: signature_02 0
                          dba: signature
                          i: 0
                          min: 3
                          r: 1
                          s: 0
                          text: -->
                        - !!perl/hash:RE_string 
                          a: 0
                          alt: signature_02 1
                          dba: signature
                          i: 0
                          min: 1
                          r: 1
                          s: 0
                          text: )
                        - !!perl/hash:RE_string 
                          a: 0
                          alt: signature_02 2
                          dba: signature
                          i: 0
                          min: 1
                          r: 1
                          s: 0
                          text: "]"
                        - !!perl/hash:RE_string 
                          a: 0
                          alt: signature_02 3
                          dba: signature
                          i: 0
                          min: 1
                          r: 1
                          s: 0
                          text: "{"
                        - !!perl/hash:RE_sequence 
                          a: 0
                          alt: signature_02 4
                          dba: signature
                          i: 0
                          min: 2
                          r: 1
                          s: 0
                          zyg: 
                            - !!perl/hash:RE_string 
                              a: 0
                              dba: signature
                              i: 0
                              min: 1
                              r: 1
                              s: 0
                              text: ":"
                            - !!perl/hash:RE_meta 
                              a: 0
                              dba: signature
                              i: 0
                              min: 1
                              r: 1
                              s: 0
                              text: \s
                  s: 0
              - !!perl/hash:RE_method 
                a: 0
                alt: signature_01 1
                dba: signature
                i: 0
                min: 12345
                name: parameter
                r: 1
                rest: ''
                s: 0
        min: 0
        quant: 
          - "**"
          - ":"
          - !!perl/hash:RE_method 
            a: 0
            dba: signature
            i: 0
            min: 12345
            name: param_sep
            r: 1
            rest: ''
            s: 0
          - 1
      - !!perl/hash:RE_method 
        a: 0
        dba: signature
        i: 0
        min: 12345
        name: ws
        nobind: 1
        r: 1
        rest: ''
        s: 0
      - !!perl/hash:RE_block 
        a: 0
        context: void
        dba: signature
        i: 0
        min: 0
        r: 1
        s: 0
        text: " $*IN_DECL = 0; "
      - !!perl/hash:RE_quantified_atom 
        atom: !!perl/hash:RE_bracket 
          decl: []

          min: 24693
          re: !!perl/hash:RE_sequence 
            a: 0
            dba: signature
            i: 0
            min: 24693
            r: 1
            s: 0
            zyg: 
              - !!perl/hash:RE_string 
                a: 0
                dba: signature
                i: 0
                min: 3
                r: 1
                s: 0
                text: -->
              - !!perl/hash:RE_method 
                a: 0
                dba: signature
                i: 0
                min: 12345
                name: ws
                nobind: 1
                r: 1
                rest: ''
                s: 0
              - !!perl/hash:RE_method 
                a: 0
                dba: signature
                i: 0
                min: 12345
                name: typename
                r: 1
                rest: ''
                s: 0
        min: 0
        quant: 
          - "?"
          - ":"
          - ''
          - 0
      - !!perl/hash:RE_block 
        a: 0
        context: void
        dba: signature
        i: 0
        min: 0
        r: 1
        s: 0
        text: " $*LEFTSIGIL = '@'; $*CURPAD.{'$?GOTSIG'} ~= '(' ~ substr($*ORIG, $startpos, $¢.pos - $startpos) ~ ')'; "
signature_01: *64
signature_02: *9
sigterm: !!perl/hash:RE 
  decl: []

  kind: token
  min: 12348
  pkg: ~
  re: !!perl/hash:RE_sequence 
    a: 0
    dba: signature
    i: 0
    min: 12348
    r: 1
    s: 0
    zyg: 
      - !!perl/hash:RE_string 
        a: 0
        dba: signature
        i: 0
        min: 2
        r: 1
        s: 0
        text: :(
      - !!perl/hash:RE_meta 
        a: 0
        dba: signature
        extra: "local $::GOAL = ')' "
        i: 0
        min: 0
        r: 1
        s: 0
        text: "::"
      - !!perl/hash:RE_method 
        a: 0
        dba: signature
        i: 0
        min: 12345
        name: fakesignature
        r: 1
        rest: ''
        s: 0
      - !!perl/hash:RE_bracket 
        decl: []

        min: 1
        re: !!perl/hash:RE_first 
          a: 0
          dba: signature
          i: 0
          min: 1
          r: 1
          s: 0
          zyg: 
            - !!perl/hash:RE_string 
              a: 0
              dba: signature
              i: 0
              min: 1
              r: 1
              s: 0
              text: )
            - !!perl/hash:RE_method 
              min: 0
              name: FAILGOAL
              nobind: 1
              rest: (')' , 'signature')
spacey: !!perl/hash:RE 
  decl: []

  kind: token
  min: 0
  pkg: ~
  re: !!perl/hash:RE_assertion 
    assert: "?"
    min: 0
    re: !!perl/hash:RE_method_re 
      a: 0
      dba: spacey
      i: 0
      min: 0
      name: before
      nobind: 1
      r: 1
      re: !!perl/hash:RE 
        decl: []

        min: 1
        re: !!perl/hash:RE_cclass 
          a: 0
          dba: spacey
          i: 0
          min: 1
          r: 1
          s: 0
          text: "[ \\s \\# ]"
      s: 0
special_variable__S_128Dollar_a2_: !!perl/hash:RE 
  decl: []

  kind: token
  min: 12345
  pkg: ~
  re: !!perl/hash:RE_method 
    a: 0
    dba: special_variable__S_128Dollar_a2_
    i: 0
    min: 12345
    name: sym
    r: 1
    rest: ''
    s: 0
    sym: $¢
special_variable__S_129DollarBang: !!perl/hash:RE 
  decl: []

  kind: token
  min: 12345
  pkg: ~
  re: !!perl/hash:RE_sequence 
    a: 0
    dba: special_variable__S_129DollarBang
    i: 0
    min: 12345
    r: 1
    s: 0
    zyg: 
      - !!perl/hash:RE_method 
        a: 0
        dba: special_variable__S_129DollarBang
        i: 0
        min: 12345
        name: sym
        r: 1
        rest: ''
        s: 0
        sym: $!
      - !!perl/hash:RE_assertion 
        assert: "!"
        min: 0
        re: !!perl/hash:RE_method_re 
          a: 0
          dba: special_variable__S_129DollarBang
          i: 0
          min: 0
          name: before
          nobind: 1
          r: 1
          re: !!perl/hash:RE 
            decl: []

            min: 1
            re: !!perl/hash:RE_meta 
              a: 0
              dba: special_variable__S_129DollarBang
              i: 0
              min: 1
              r: 1
              s: 0
              text: \w
          s: 0
special_variable__S_130DollarBangCur_Ly: !!perl/hash:RE 
  decl: []

  kind: token
  min: 5
  pkg: ~
  re: !!perl/hash:RE_sequence 
    a: 0
    dba: special_variable__S_130DollarBangCur_Ly
    i: 0
    min: 5
    r: 1
    s: 0
    zyg: 
      - !!perl/hash:RE_bindpos 
        atom: !!perl/hash:RE_paren 
          decl: []

          min: 5
          re: !!perl/hash:RE_sequence 
            a: 0
            dba: special_variable__S_130DollarBangCur_Ly
            i: 0
            min: 5
            r: 1
            s: 0
            zyg: 
              - !!perl/hash:RE_string 
                a: 0
                dba: special_variable__S_130DollarBangCur_Ly
                i: 0
                min: 3
                r: 1
                s: 0
                text: $!{
              - !!perl/hash:RE_meta 
                a: 0
                dba: special_variable__S_130DollarBangCur_Ly
                i: 0
                min: 0
                r: 1
                s: 0
                text: "::"
              - !!perl/hash:RE_bindpos 
                atom: !!perl/hash:RE_paren 
                  decl: []

                  min: 1
                  re: !!perl/hash:RE_meta 
                    a: 0
                    dba: special_variable__S_130DollarBangCur_Ly
                    i: 0
                    min: 1
                    r: 1
                    s: 0
                    text: .*?
                min: 1
                var: 0
              - !!perl/hash:RE_string 
                a: 0
                dba: special_variable__S_130DollarBangCur_Ly
                i: 0
                min: 1
                r: 1
                s: 0
                text: "}"
        min: 5
        var: 0
      - !!perl/hash:RE_method 
        min: 0
        name: obs
        nobind: 1
        rest: ($0.Str ~ " variable", 'smart match against $!')
special_variable__S_131DollarSlash: !!perl/hash:RE 
  decl: []

  kind: token
  min: 12345
  pkg: ~
  re: !!perl/hash:RE_sequence 
    a: 0
    dba: special_variable__S_131DollarSlash
    i: 0
    min: 12345
    r: 1
    s: 0
    zyg: 
      - !!perl/hash:RE_method 
        a: 0
        dba: special_variable__S_131DollarSlash
        i: 0
        min: 12345
        name: sym
        r: 1
        rest: ''
        s: 0
        sym: $/
      - !!perl/hash:RE_quantified_atom 
        atom: !!perl/hash:RE_bracket 
          decl: []

          min: 0
          re: !!perl/hash:RE_sequence 
            a: 0
            dba: special_variable__S_131DollarSlash
            i: 0
            min: 0
            r: 1
            s: 0
            zyg: 
              - !!perl/hash:RE_assertion 
                assert: "?"
                min: 0
                re: !!perl/hash:RE_method_re 
                  a: 0
                  dba: special_variable__S_131DollarSlash
                  i: 0
                  min: 0
                  name: before
                  nobind: 1
                  r: 1
                  re: !!perl/hash:RE 
                    decl: []

                    min: 1
                    re: !!perl/hash:RE_sequence 
                      a: 0
                      dba: special_variable__S_131DollarSlash
                      i: 0
                      min: 1
                      r: 1
                      s: 0
                      zyg: 
                        - !!perl/hash:RE_quantified_atom 
                          atom: !!perl/hash:RE_meta 
                            a: 0
                            dba: special_variable__S_131DollarSlash
                            i: 0
                            min: 1
                            r: 1
                            s: 0
                            text: \h
                          min: 0
                          quant: 
                            - "*"
                            - ":"
                            - ''
                            - 0
                        - !!perl/hash:RE_string 
                          a: 0
                          dba: special_variable__S_131DollarSlash
                          i: 0
                          min: 1
                          r: 1
                          s: 0
                          text: =
                        - !!perl/hash:RE_assertion 
                          assert: "!"
                          min: 0
                          re: !!perl/hash:RE_cclass 
                            a: 0
                            dba: special_variable__S_131DollarSlash
                            i: 0
                            min: 1
                            nobind: 1
                            r: 1
                            s: 0
                            text: "[=]"
                  s: 0
              - !!perl/hash:RE_method 
                min: 0
                name: obs
                nobind: 1
                rest: "('$/ variable as input record separator',\n             \"filehandle's :irs attribute\")"
        min: 0
        quant: 
          - "?"
          - ":"
          - ''
          - 0
special_variable__S_132DollarTilde: !!perl/hash:RE 
  decl: []

  kind: token
  min: 12345
  pkg: ~
  re: !!perl/hash:RE_sequence 
    a: 0
    dba: special_variable__S_132DollarTilde
    i: 0
    min: 12345
    r: 1
    s: 0
    zyg: 
      - !!perl/hash:RE_method 
        a: 0
        dba: special_variable__S_132DollarTilde
        i: 0
        min: 12345
        name: sym
        r: 1
        rest: ''
        s: 0
        sym: $~
      - !!perl/hash:RE_meta 
        a: 0
        dba: special_variable__S_132DollarTilde
        i: 0
        min: 0
        r: 1
        s: 0
        text: "::"
      - !!perl/hash:RE_assertion 
        assert: "?"
        min: 0
        re: !!perl/hash:RE_method_re 
          a: 0
          dba: special_variable__S_132DollarTilde
          i: 0
          min: 0
          name: before
          nobind: 1
          r: 1
          re: !!perl/hash:RE 
            decl: []

            min: 1
            re: &61 !!perl/hash:RE_any 
              a: 0
              altname: special_variable__S_132DollarTilde_01
              dba: special_variable__S_132DollarTilde
              i: 0
              min: 1
              name: special_variable__S_132DollarTilde_01
              r: 1
              s: 0
              zyg: 
                - !!perl/hash:RE_meta 
                  a: 0
                  alt: special_variable__S_132DollarTilde_01 0
                  dba: special_variable__S_132DollarTilde
                  i: 0
                  min: 1
                  r: 1
                  s: 0
                  text: \s
                - !!perl/hash:RE_string 
                  a: 0
                  alt: special_variable__S_132DollarTilde_01 1
                  dba: special_variable__S_132DollarTilde
                  i: 0
                  min: 1
                  r: 1
                  s: 0
                  text: ","
                - !!perl/hash:RE_string 
                  a: 0
                  alt: special_variable__S_132DollarTilde_01 2
                  dba: special_variable__S_132DollarTilde
                  i: 0
                  min: 1
                  r: 1
                  s: 0
                  text: =
                - !!perl/hash:RE_method 
                  a: 0
                  alt: special_variable__S_132DollarTilde_01 3
                  dba: special_variable__S_132DollarTilde
                  i: 0
                  min: 12345
                  name: terminator
                  r: 1
                  rest: ''
                  s: 0
          s: 0
      - !!perl/hash:RE_method 
        min: 0
        name: obs
        nobind: 1
        rest: ('$~ variable', 'Form module')
special_variable__S_132DollarTilde_01: *61
special_variable__S_133DollarGrave: !!perl/hash:RE 
  decl: []

  kind: token
  min: 12345
  pkg: ~
  re: !!perl/hash:RE_sequence 
    a: 0
    dba: special_variable__S_133DollarGrave
    i: 0
    min: 12345
    r: 1
    s: 0
    zyg: 
      - !!perl/hash:RE_method 
        a: 0
        dba: special_variable__S_133DollarGrave
        i: 0
        min: 12345
        name: sym
        r: 1
        rest: ''
        s: 0
        sym: $`
      - !!perl/hash:RE_meta 
        a: 0
        dba: special_variable__S_133DollarGrave
        i: 0
        min: 0
        r: 1
        s: 0
        text: "::"
      - !!perl/hash:RE_assertion 
        assert: "?"
        min: 0
        re: !!perl/hash:RE_method_re 
          a: 0
          dba: special_variable__S_133DollarGrave
          i: 0
          min: 0
          name: before
          nobind: 1
          r: 1
          re: !!perl/hash:RE 
            decl: []

            min: 1
            re: &128 !!perl/hash:RE_any 
              a: 0
              altname: special_variable__S_133DollarGrave_01
              dba: special_variable__S_133DollarGrave
              i: 0
              min: 1
              name: special_variable__S_133DollarGrave_01
              r: 1
              s: 0
              zyg: 
                - !!perl/hash:RE_meta 
                  a: 0
                  alt: special_variable__S_133DollarGrave_01 0
                  dba: special_variable__S_133DollarGrave
                  i: 0
                  min: 1
                  r: 1
                  s: 0
                  text: \s
                - !!perl/hash:RE_string 
                  a: 0
                  alt: special_variable__S_133DollarGrave_01 1
                  dba: special_variable__S_133DollarGrave
                  i: 0
                  min: 1
                  r: 1
                  s: 0
                  text: ","
                - !!perl/hash:RE_method 
                  a: 0
                  alt: special_variable__S_133DollarGrave_01 2
                  dba: special_variable__S_133DollarGrave
                  i: 0
                  min: 12345
                  name: terminator
                  r: 1
                  rest: ''
                  s: 0
          s: 0
      - !!perl/hash:RE_method 
        min: 0
        name: obs
        nobind: 1
        rest: ('$` variable', 'explicit pattern before <(')
special_variable__S_133DollarGrave_01: *128
special_variable__S_134DollarAt: !!perl/hash:RE 
  decl: []

  kind: token
  min: 12345
  pkg: ~
  re: !!perl/hash:RE_sequence 
    a: 0
    dba: special_variable__S_134DollarAt
    i: 0
    min: 12345
    r: 1
    s: 0
    zyg: 
      - !!perl/hash:RE_method 
        a: 0
        dba: special_variable__S_134DollarAt
        i: 0
        min: 12345
        name: sym
        r: 1
        rest: ''
        s: 0
        sym: $@
      - !!perl/hash:RE_meta 
        a: 0
        dba: special_variable__S_134DollarAt
        i: 0
        min: 0
        r: 1
        s: 0
        text: "::"
      - !!perl/hash:RE_method 
        min: 0
        name: obs
        nobind: 1
        rest: ('$@ variable as eval error', '$!')
special_variable__S_135DollarSharp: !!perl/hash:RE 
  decl: []

  kind: token
  min: 12345
  pkg: ~
  re: !!perl/hash:RE_sequence 
    a: 0
    dba: special_variable__S_135DollarSharp
    i: 0
    min: 12345
    r: 1
    s: 0
    zyg: 
      - !!perl/hash:RE_method 
        a: 0
        dba: special_variable__S_135DollarSharp
        i: 0
        min: 12345
        name: sym
        r: 1
        rest: ''
        s: 0
        sym: $#
      - !!perl/hash:RE_meta 
        a: 0
        dba: special_variable__S_135DollarSharp
        i: 0
        min: 0
        r: 1
        s: 0
        text: "::"
      - !!perl/hash:RE_bracket 
        decl: []

        min: 0
        re: !!perl/hash:RE_first 
          a: 0
          dba: special_variable__S_135DollarSharp
          i: 0
          min: 0
          r: 1
          s: 0
          zyg: 
            - !!perl/hash:RE_sequence 
              a: 0
              dba: special_variable__S_135DollarSharp
              i: 0
              min: 1
              r: 1
              s: 0
              zyg: 
                - !!perl/hash:RE_bindpos 
                  atom: !!perl/hash:RE_paren 
                    decl: []

                    min: 1
                    re: !!perl/hash:RE_quantified_atom 
                      atom: !!perl/hash:RE_meta 
                        a: 0
                        dba: special_variable__S_135DollarSharp
                        i: 0
                        min: 1
                        r: 1
                        s: 0
                        text: \w
                      min: 1
                      quant: 
                        - +
                        - ":"
                        - ''
                        - 1
                  min: 1
                  var: 0
                - !!perl/hash:RE_method 
                  min: 0
                  name: obs
                  nobind: 1
                  rest: ("\$#" ~ $0.Str ~ " variable", '@' ~ $0.Str ~ '.end')
            - !!perl/hash:RE_method 
              min: 0
              name: obs
              nobind: 1
              rest: ('$# variable', '.fmt')
special_variable__S_136DollarDollar: !!perl/hash:RE 
  decl: []

  kind: token
  min: 12345
  pkg: ~
  re: !!perl/hash:RE_sequence 
    a: 0
    dba: special_variable__S_136DollarDollar
    i: 0
    min: 12345
    r: 1
    s: 0
    zyg: 
      - !!perl/hash:RE_method 
        a: 0
        dba: special_variable__S_136DollarDollar
        i: 0
        min: 12345
        name: sym
        r: 1
        rest: ''
        s: 0
        sym: $$
      - !!perl/hash:RE_assertion 
        assert: "!"
        min: 0
        re: !!perl/hash:RE_method 
          a: 0
          dba: special_variable__S_136DollarDollar
          i: 0
          min: 12345
          name: alpha
          nobind: 1
          r: 1
          rest: ''
          s: 0
      - !!perl/hash:RE_meta 
        a: 0
        dba: special_variable__S_136DollarDollar
        i: 0
        min: 0
        r: 1
        s: 0
        text: "::"
      - !!perl/hash:RE_assertion 
        assert: "?"
        min: 0
        re: !!perl/hash:RE_method_re 
          a: 0
          dba: special_variable__S_136DollarDollar
          i: 0
          min: 0
          name: before
          nobind: 1
          r: 1
          re: !!perl/hash:RE 
            decl: []

            min: 1
            re: &123 !!perl/hash:RE_any 
              a: 0
              altname: special_variable__S_136DollarDollar_01
              dba: special_variable__S_136DollarDollar
              i: 0
              min: 1
              name: special_variable__S_136DollarDollar_01
              r: 1
              s: 0
              zyg: 
                - !!perl/hash:RE_meta 
                  a: 0
                  alt: special_variable__S_136DollarDollar_01 0
                  dba: special_variable__S_136DollarDollar
                  i: 0
                  min: 1
                  r: 1
                  s: 0
                  text: \s
                - !!perl/hash:RE_string 
                  a: 0
                  alt: special_variable__S_136DollarDollar_01 1
                  dba: special_variable__S_136DollarDollar
                  i: 0
                  min: 1
                  r: 1
                  s: 0
                  text: ","
                - !!perl/hash:RE_method 
                  a: 0
                  alt: special_variable__S_136DollarDollar_01 2
                  dba: special_variable__S_136DollarDollar
                  i: 0
                  min: 12345
                  name: terminator
                  r: 1
                  rest: ''
                  s: 0
          s: 0
      - !!perl/hash:RE_method 
        min: 0
        name: obs
        nobind: 1
        rest: ('$$ variable', '$*PID')
special_variable__S_136DollarDollar_01: *123
special_variable__S_137DollarPercent: !!perl/hash:RE 
  decl: []

  kind: token
  min: 12345
  pkg: ~
  re: !!perl/hash:RE_sequence 
    a: 0
    dba: special_variable__S_137DollarPercent
    i: 0
    min: 12345
    r: 1
    s: 0
    zyg: 
      - !!perl/hash:RE_method 
        a: 0
        dba: special_variable__S_137DollarPercent
        i: 0
        min: 12345
        name: sym
        r: 1
        rest: ''
        s: 0
        sym: $%
      - !!perl/hash:RE_meta 
        a: 0
        dba: special_variable__S_137DollarPercent
        i: 0
        min: 0
        r: 1
        s: 0
        text: "::"
      - !!perl/hash:RE_method 
        min: 0
        name: obs
        nobind: 1
        rest: ('$% variable', 'Form module')
special_variable__S_138DollarCaretX: !!perl/hash:RE 
  decl: []

  kind: token
  min: 12348
  pkg: ~
  re: !!perl/hash:RE_sequence 
    a: 0
    dba: special_variable__S_138DollarCaretX
    i: 0
    min: 12348
    r: 1
    s: 0
    zyg: 
      - !!perl/hash:RE_method 
        a: 0
        dba: special_variable__S_138DollarCaretX
        i: 0
        min: 12345
        name: sigil
        r: 1
        rest: ''
        s: 0
      - !!perl/hash:RE_string 
        a: 0
        dba: special_variable__S_138DollarCaretX
        i: 0
        min: 1
        r: 1
        s: 0
        text: "^"
      - !!perl/hash:RE_bindnamed 
        a: 0
        atom: !!perl/hash:RE_bracket 
          decl: []

          min: 1
          nobind: 1
          re: !!perl/hash:RE_cclass 
            a: 0
            dba: special_variable__S_138DollarCaretX
            i: 0
            min: 1
            r: 1
            s: 0
            text: "[A..Z]"
        dba: special_variable__S_138DollarCaretX
        i: 0
        min: 1
        r: 1
        s: 0
        var: letter
      - !!perl/hash:RE_meta 
        a: 0
        dba: special_variable__S_138DollarCaretX
        i: 0
        min: 1
        r: 1
        s: 0
        text: \W
      - !!perl/hash:RE_method 
        min: 0
        name: obscaret
        nobind: 1
        rest: ($<sigil>.Str ~ '^' ~ $<letter>.Str, $<sigil>.Str, $<letter>.Str)
special_variable__S_139DollarCaret: !!perl/hash:RE 
  decl: []

  kind: token
  min: 12345
  pkg: ~
  re: !!perl/hash:RE_sequence 
    a: 0
    dba: special_variable__S_139DollarCaret
    i: 0
    min: 12345
    r: 1
    s: 0
    zyg: 
      - !!perl/hash:RE_method 
        a: 0
        dba: special_variable__S_139DollarCaret
        i: 0
        min: 12345
        name: sym
        r: 1
        rest: ''
        s: 0
        sym: $^
      - !!perl/hash:RE_meta 
        a: 0
        dba: special_variable__S_139DollarCaret
        i: 0
        min: 0
        r: 1
        s: 0
        text: "::"
      - !!perl/hash:RE_assertion 
        assert: "?"
        min: 0
        re: !!perl/hash:RE_method_re 
          a: 0
          dba: special_variable__S_139DollarCaret
          i: 0
          min: 0
          name: before
          nobind: 1
          r: 1
          re: !!perl/hash:RE 
            decl: []

            min: 1
            re: &75 !!perl/hash:RE_any 
              a: 0
              altname: special_variable__S_139DollarCaret_01
              dba: special_variable__S_139DollarCaret
              i: 0
              min: 1
              name: special_variable__S_139DollarCaret_01
              r: 1
              s: 0
              zyg: 
                - !!perl/hash:RE_meta 
                  a: 0
                  alt: special_variable__S_139DollarCaret_01 0
                  dba: special_variable__S_139DollarCaret
                  i: 0
                  min: 1
                  r: 1
                  s: 0
                  text: \s
                - !!perl/hash:RE_string 
                  a: 0
                  alt: special_variable__S_139DollarCaret_01 1
                  dba: special_variable__S_139DollarCaret
                  i: 0
                  min: 1
                  r: 1
                  s: 0
                  text: ","
                - !!perl/hash:RE_string 
                  a: 0
                  alt: special_variable__S_139DollarCaret_01 2
                  dba: special_variable__S_139DollarCaret
                  i: 0
                  min: 1
                  r: 1
                  s: 0
                  text: =
                - !!perl/hash:RE_method 
                  a: 0
                  alt: special_variable__S_139DollarCaret_01 3
                  dba: special_variable__S_139DollarCaret
                  i: 0
                  min: 12345
                  name: terminator
                  r: 1
                  rest: ''
                  s: 0
          s: 0
      - !!perl/hash:RE_method 
        min: 0
        name: obs
        nobind: 1
        rest: ('$^ variable', 'Form module')
special_variable__S_139DollarCaret_01: *75
special_variable__S_140DollarAmp: !!perl/hash:RE 
  decl: []

  kind: token
  min: 12345
  pkg: ~
  re: !!perl/hash:RE_sequence 
    a: 0
    dba: special_variable__S_140DollarAmp
    i: 0
    min: 12345
    r: 1
    s: 0
    zyg: 
      - !!perl/hash:RE_method 
        a: 0
        dba: special_variable__S_140DollarAmp
        i: 0
        min: 12345
        name: sym
        r: 1
        rest: ''
        s: 0
        sym: $&
      - !!perl/hash:RE_meta 
        a: 0
        dba: special_variable__S_140DollarAmp
        i: 0
        min: 0
        r: 1
        s: 0
        text: "::"
      - !!perl/hash:RE_assertion 
        assert: "?"
        min: 0
        re: !!perl/hash:RE_method_re 
          a: 0
          dba: special_variable__S_140DollarAmp
          i: 0
          min: 0
          name: before
          nobind: 1
          r: 1
          re: !!perl/hash:RE 
            decl: []

            min: 1
            re: &100 !!perl/hash:RE_any 
              a: 0
              altname: special_variable__S_140DollarAmp_01
              dba: special_variable__S_140DollarAmp
              i: 0
              min: 1
              name: special_variable__S_140DollarAmp_01
              r: 1
              s: 0
              zyg: 
                - !!perl/hash:RE_meta 
                  a: 0
                  alt: special_variable__S_140DollarAmp_01 0
                  dba: special_variable__S_140DollarAmp
                  i: 0
                  min: 1
                  r: 1
                  s: 0
                  text: \s
                - !!perl/hash:RE_string 
                  a: 0
                  alt: special_variable__S_140DollarAmp_01 1
                  dba: special_variable__S_140DollarAmp
                  i: 0
                  min: 1
                  r: 1
                  s: 0
                  text: ","
                - !!perl/hash:RE_method 
                  a: 0
                  alt: special_variable__S_140DollarAmp_01 2
                  dba: special_variable__S_140DollarAmp
                  i: 0
                  min: 12345
                  name: terminator
                  r: 1
                  rest: ''
                  s: 0
          s: 0
      - !!perl/hash:RE_method 
        min: 0
        name: obs
        nobind: 1
        rest: ('$& variable', '$/ or $()')
special_variable__S_140DollarAmp_01: *100
special_variable__S_141DollarStar: !!perl/hash:RE 
  decl: []

  kind: token
  min: 12345
  pkg: ~
  re: !!perl/hash:RE_sequence 
    a: 0
    dba: special_variable__S_141DollarStar
    i: 0
    min: 12345
    r: 1
    s: 0
    zyg: 
      - !!perl/hash:RE_method 
        a: 0
        dba: special_variable__S_141DollarStar
        i: 0
        min: 12345
        name: sym
        r: 1
        rest: ''
        s: 0
        sym: $*
      - !!perl/hash:RE_meta 
        a: 0
        dba: special_variable__S_141DollarStar
        i: 0
        min: 0
        r: 1
        s: 0
        text: "::"
      - !!perl/hash:RE_assertion 
        assert: "?"
        min: 0
        re: !!perl/hash:RE_method_re 
          a: 0
          dba: special_variable__S_141DollarStar
          i: 0
          min: 0
          name: before
          nobind: 1
          r: 1
          re: !!perl/hash:RE 
            decl: []

            min: 1
            re: &102 !!perl/hash:RE_any 
              a: 0
              altname: special_variable__S_141DollarStar_01
              dba: special_variable__S_141DollarStar
              i: 0
              min: 1
              name: special_variable__S_141DollarStar_01
              r: 1
              s: 0
              zyg: 
                - !!perl/hash:RE_meta 
                  a: 0
                  alt: special_variable__S_141DollarStar_01 0
                  dba: special_variable__S_141DollarStar
                  i: 0
                  min: 1
                  r: 1
                  s: 0
                  text: \s
                - !!perl/hash:RE_string 
                  a: 0
                  alt: special_variable__S_141DollarStar_01 1
                  dba: special_variable__S_141DollarStar
                  i: 0
                  min: 1
                  r: 1
                  s: 0
                  text: ","
                - !!perl/hash:RE_string 
                  a: 0
                  alt: special_variable__S_141DollarStar_01 2
                  dba: special_variable__S_141DollarStar
                  i: 0
                  min: 1
                  r: 1
                  s: 0
                  text: =
                - !!perl/hash:RE_method 
                  a: 0
                  alt: special_variable__S_141DollarStar_01 3
                  dba: special_variable__S_141DollarStar
                  i: 0
                  min: 12345
                  name: terminator
                  r: 1
                  rest: ''
                  s: 0
          s: 0
      - !!perl/hash:RE_method 
        min: 0
        name: obs
        nobind: 1
        rest: ('$* variable', '^^ and $$')
special_variable__S_141DollarStar_01: *102
special_variable__S_142DollarThesis: !!perl/hash:RE 
  decl: []

  kind: token
  min: 12345
  pkg: ~
  re: !!perl/hash:RE_sequence 
    a: 0
    dba: special_variable__S_142DollarThesis
    i: 0
    min: 12345
    r: 1
    s: 0
    zyg: 
      - !!perl/hash:RE_method 
        a: 0
        dba: special_variable__S_142DollarThesis
        i: 0
        min: 12345
        name: sym
        r: 1
        rest: ''
        s: 0
        sym: $)
      - !!perl/hash:RE_meta 
        a: 0
        dba: special_variable__S_142DollarThesis
        i: 0
        min: 0
        r: 1
        s: 0
        text: "::"
      - !!perl/hash:RE_assertion 
        assert: "?"
        min: 0
        re: !!perl/hash:RE_method_re 
          a: 0
          dba: special_variable__S_142DollarThesis
          i: 0
          min: 0
          name: before
          nobind: 1
          r: 1
          re: !!perl/hash:RE 
            decl: []

            min: 1
            re: &8 !!perl/hash:RE_any 
              a: 0
              altname: special_variable__S_142DollarThesis_01
              dba: special_variable__S_142DollarThesis
              i: 0
              min: 1
              name: special_variable__S_142DollarThesis_01
              r: 1
              s: 0
              zyg: 
                - !!perl/hash:RE_meta 
                  a: 0
                  alt: special_variable__S_142DollarThesis_01 0
                  dba: special_variable__S_142DollarThesis
                  i: 0
                  min: 1
                  r: 1
                  s: 0
                  text: \s
                - !!perl/hash:RE_string 
                  a: 0
                  alt: special_variable__S_142DollarThesis_01 1
                  dba: special_variable__S_142DollarThesis
                  i: 0
                  min: 1
                  r: 1
                  s: 0
                  text: ","
                - !!perl/hash:RE_method 
                  a: 0
                  alt: special_variable__S_142DollarThesis_01 2
                  dba: special_variable__S_142DollarThesis
                  i: 0
                  min: 12345
                  name: terminator
                  r: 1
                  rest: ''
                  s: 0
          s: 0
      - !!perl/hash:RE_method 
        min: 0
        name: obs
        nobind: 1
        rest: ('$) variable', '$*EGID')
special_variable__S_142DollarThesis_01: *8
special_variable__S_143DollarMinus: !!perl/hash:RE 
  decl: []

  kind: token
  min: 12345
  pkg: ~
  re: !!perl/hash:RE_sequence 
    a: 0
    dba: special_variable__S_143DollarMinus
    i: 0
    min: 12345
    r: 1
    s: 0
    zyg: 
      - !!perl/hash:RE_method 
        a: 0
        dba: special_variable__S_143DollarMinus
        i: 0
        min: 12345
        name: sym
        r: 1
        rest: ''
        s: 0
        sym: $-
      - !!perl/hash:RE_meta 
        a: 0
        dba: special_variable__S_143DollarMinus
        i: 0
        min: 0
        r: 1
        s: 0
        text: "::"
      - !!perl/hash:RE_assertion 
        assert: "?"
        min: 0
        re: !!perl/hash:RE_method_re 
          a: 0
          dba: special_variable__S_143DollarMinus
          i: 0
          min: 0
          name: before
          nobind: 1
          r: 1
          re: !!perl/hash:RE 
            decl: []

            min: 1
            re: &95 !!perl/hash:RE_any 
              a: 0
              altname: special_variable__S_143DollarMinus_01
              dba: special_variable__S_143DollarMinus
              i: 0
              min: 1
              name: special_variable__S_143DollarMinus_01
              r: 1
              s: 0
              zyg: 
                - !!perl/hash:RE_meta 
                  a: 0
                  alt: special_variable__S_143DollarMinus_01 0
                  dba: special_variable__S_143DollarMinus
                  i: 0
                  min: 1
                  r: 1
                  s: 0
                  text: \s
                - !!perl/hash:RE_string 
                  a: 0
                  alt: special_variable__S_143DollarMinus_01 1
                  dba: special_variable__S_143DollarMinus
                  i: 0
                  min: 1
                  r: 1
                  s: 0
                  text: ","
                - !!perl/hash:RE_string 
                  a: 0
                  alt: special_variable__S_143DollarMinus_01 2
                  dba: special_variable__S_143DollarMinus
                  i: 0
                  min: 1
                  r: 1
                  s: 0
                  text: =
                - !!perl/hash:RE_method 
                  a: 0
                  alt: special_variable__S_143DollarMinus_01 3
                  dba: special_variable__S_143DollarMinus
                  i: 0
                  min: 12345
                  name: terminator
                  r: 1
                  rest: ''
                  s: 0
          s: 0
      - !!perl/hash:RE_method 
        min: 0
        name: obs
        nobind: 1
        rest: ('$- variable', 'Form module')
special_variable__S_143DollarMinus_01: *95
special_variable__S_144DollarEqual: !!perl/hash:RE 
  decl: []

  kind: token
  min: 12345
  pkg: ~
  re: !!perl/hash:RE_sequence 
    a: 0
    dba: special_variable__S_144DollarEqual
    i: 0
    min: 12345
    r: 1
    s: 0
    zyg: 
      - !!perl/hash:RE_method 
        a: 0
        dba: special_variable__S_144DollarEqual
        i: 0
        min: 12345
        name: sym
        r: 1
        rest: ''
        s: 0
        sym: $=
      - !!perl/hash:RE_meta 
        a: 0
        dba: special_variable__S_144DollarEqual
        i: 0
        min: 0
        r: 1
        s: 0
        text: "::"
      - !!perl/hash:RE_assertion 
        assert: "?"
        min: 0
        re: !!perl/hash:RE_method_re 
          a: 0
          dba: special_variable__S_144DollarEqual
          i: 0
          min: 0
          name: before
          nobind: 1
          r: 1
          re: !!perl/hash:RE 
            decl: []

            min: 1
            re: &65 !!perl/hash:RE_any 
              a: 0
              altname: special_variable__S_144DollarEqual_01
              dba: special_variable__S_144DollarEqual
              i: 0
              min: 1
              name: special_variable__S_144DollarEqual_01
              r: 1
              s: 0
              zyg: 
                - !!perl/hash:RE_meta 
                  a: 0
                  alt: special_variable__S_144DollarEqual_01 0
                  dba: special_variable__S_144DollarEqual
                  i: 0
                  min: 1
                  r: 1
                  s: 0
                  text: \s
                - !!perl/hash:RE_string 
                  a: 0
                  alt: special_variable__S_144DollarEqual_01 1
                  dba: special_variable__S_144DollarEqual
                  i: 0
                  min: 1
                  r: 1
                  s: 0
                  text: ","
                - !!perl/hash:RE_string 
                  a: 0
                  alt: special_variable__S_144DollarEqual_01 2
                  dba: special_variable__S_144DollarEqual
                  i: 0
                  min: 1
                  r: 1
                  s: 0
                  text: =
                - !!perl/hash:RE_method 
                  a: 0
                  alt: special_variable__S_144DollarEqual_01 3
                  dba: special_variable__S_144DollarEqual
                  i: 0
                  min: 12345
                  name: terminator
                  r: 1
                  rest: ''
                  s: 0
          s: 0
      - !!perl/hash:RE_method 
        min: 0
        name: obs
        nobind: 1
        rest: ('$= variable', 'Form module')
special_variable__S_144DollarEqual_01: *65
special_variable__S_145AtPlus: !!perl/hash:RE 
  decl: []

  kind: token
  min: 12345
  pkg: ~
  re: !!perl/hash:RE_sequence 
    a: 0
    dba: special_variable__S_145AtPlus
    i: 0
    min: 12345
    r: 1
    s: 0
    zyg: 
      - !!perl/hash:RE_method 
        a: 0
        dba: special_variable__S_145AtPlus
        i: 0
        min: 12345
        name: sym
        r: 1
        rest: ''
        s: 0
        sym: "@+"
      - !!perl/hash:RE_meta 
        a: 0
        dba: special_variable__S_145AtPlus
        i: 0
        min: 0
        r: 1
        s: 0
        text: "::"
      - !!perl/hash:RE_assertion 
        assert: "?"
        min: 0
        re: !!perl/hash:RE_method_re 
          a: 0
          dba: special_variable__S_145AtPlus
          i: 0
          min: 0
          name: before
          nobind: 1
          r: 1
          re: !!perl/hash:RE 
            decl: []

            min: 1
            re: &21 !!perl/hash:RE_any 
              a: 0
              altname: special_variable__S_145AtPlus_01
              dba: special_variable__S_145AtPlus
              i: 0
              min: 1
              name: special_variable__S_145AtPlus_01
              r: 1
              s: 0
              zyg: 
                - !!perl/hash:RE_meta 
                  a: 0
                  alt: special_variable__S_145AtPlus_01 0
                  dba: special_variable__S_145AtPlus
                  i: 0
                  min: 1
                  r: 1
                  s: 0
                  text: \s
                - !!perl/hash:RE_string 
                  a: 0
                  alt: special_variable__S_145AtPlus_01 1
                  dba: special_variable__S_145AtPlus
                  i: 0
                  min: 1
                  r: 1
                  s: 0
                  text: ","
                - !!perl/hash:RE_method 
                  a: 0
                  alt: special_variable__S_145AtPlus_01 2
                  dba: special_variable__S_145AtPlus
                  i: 0
                  min: 12345
                  name: terminator
                  r: 1
                  rest: ''
                  s: 0
          s: 0
      - !!perl/hash:RE_method 
        min: 0
        name: obs
        nobind: 1
        rest: ('@+ variable', '.to method')
special_variable__S_145AtPlus_01: *21
special_variable__S_146PercentPlus: !!perl/hash:RE 
  decl: []

  kind: token
  min: 12345
  pkg: ~
  re: !!perl/hash:RE_sequence 
    a: 0
    dba: special_variable__S_146PercentPlus
    i: 0
    min: 12345
    r: 1
    s: 0
    zyg: 
      - !!perl/hash:RE_method 
        a: 0
        dba: special_variable__S_146PercentPlus
        i: 0
        min: 12345
        name: sym
        r: 1
        rest: ''
        s: 0
        sym: "%+"
      - !!perl/hash:RE_meta 
        a: 0
        dba: special_variable__S_146PercentPlus
        i: 0
        min: 0
        r: 1
        s: 0
        text: "::"
      - !!perl/hash:RE_assertion 
        assert: "?"
        min: 0
        re: !!perl/hash:RE_method_re 
          a: 0
          dba: special_variable__S_146PercentPlus
          i: 0
          min: 0
          name: before
          nobind: 1
          r: 1
          re: !!perl/hash:RE 
            decl: []

            min: 1
            re: &57 !!perl/hash:RE_any 
              a: 0
              altname: special_variable__S_146PercentPlus_01
              dba: special_variable__S_146PercentPlus
              i: 0
              min: 1
              name: special_variable__S_146PercentPlus_01
              r: 1
              s: 0
              zyg: 
                - !!perl/hash:RE_meta 
                  a: 0
                  alt: special_variable__S_146PercentPlus_01 0
                  dba: special_variable__S_146PercentPlus
                  i: 0
                  min: 1
                  r: 1
                  s: 0
                  text: \s
                - !!perl/hash:RE_string 
                  a: 0
                  alt: special_variable__S_146PercentPlus_01 1
                  dba: special_variable__S_146PercentPlus
                  i: 0
                  min: 1
                  r: 1
                  s: 0
                  text: ","
                - !!perl/hash:RE_method 
                  a: 0
                  alt: special_variable__S_146PercentPlus_01 2
                  dba: special_variable__S_146PercentPlus
                  i: 0
                  min: 12345
                  name: terminator
                  r: 1
                  rest: ''
                  s: 0
          s: 0
      - !!perl/hash:RE_method 
        min: 0
        name: obs
        nobind: 1
        rest: ('%+ variable', '.to method')
special_variable__S_146PercentPlus_01: *57
special_variable__S_147DollarPlusBra_Ket: !!perl/hash:RE 
  decl: []

  kind: token
  min: 3
  pkg: ~
  re: !!perl/hash:RE_sequence 
    a: 0
    dba: special_variable__S_147DollarPlusBra_Ket
    i: 0
    min: 3
    r: 1
    s: 0
    zyg: 
      - !!perl/hash:RE_string 
        a: 0
        dba: special_variable__S_147DollarPlusBra_Ket
        i: 0
        min: 3
        r: 1
        s: 0
        text: $+[
      - !!perl/hash:RE_method 
        min: 0
        name: obs
        nobind: 1
        rest: ('@+ variable', '.to method')
special_variable__S_148AtPlusBra_Ket: !!perl/hash:RE 
  decl: []

  kind: token
  min: 3
  pkg: ~
  re: !!perl/hash:RE_sequence 
    a: 0
    dba: special_variable__S_148AtPlusBra_Ket
    i: 0
    min: 3
    r: 1
    s: 0
    zyg: 
      - !!perl/hash:RE_string 
        a: 0
        dba: special_variable__S_148AtPlusBra_Ket
        i: 0
        min: 3
        r: 1
        s: 0
        text: "@+["
      - !!perl/hash:RE_method 
        min: 0
        name: obs
        nobind: 1
        rest: ('@+ variable', '.to method')
special_variable__S_149AtPlusCur_Ly: !!perl/hash:RE 
  decl: []

  kind: token
  min: 3
  pkg: ~
  re: !!perl/hash:RE_sequence 
    a: 0
    dba: special_variable__S_149AtPlusCur_Ly
    i: 0
    min: 3
    r: 1
    s: 0
    zyg: 
      - !!perl/hash:RE_string 
        a: 0
        dba: special_variable__S_149AtPlusCur_Ly
        i: 0
        min: 3
        r: 1
        s: 0
        text: "@+{"
      - !!perl/hash:RE_method 
        min: 0
        name: obs
        nobind: 1
        rest: ('%+ variable', '.to method')
special_variable__S_150AtMinus: !!perl/hash:RE 
  decl: []

  kind: token
  min: 12345
  pkg: ~
  re: !!perl/hash:RE_sequence 
    a: 0
    dba: special_variable__S_150AtMinus
    i: 0
    min: 12345
    r: 1
    s: 0
    zyg: 
      - !!perl/hash:RE_method 
        a: 0
        dba: special_variable__S_150AtMinus
        i: 0
        min: 12345
        name: sym
        r: 1
        rest: ''
        s: 0
        sym: "@-"
      - !!perl/hash:RE_meta 
        a: 0
        dba: special_variable__S_150AtMinus
        i: 0
        min: 0
        r: 1
        s: 0
        text: "::"
      - !!perl/hash:RE_assertion 
        assert: "?"
        min: 0
        re: !!perl/hash:RE_method_re 
          a: 0
          dba: special_variable__S_150AtMinus
          i: 0
          min: 0
          name: before
          nobind: 1
          r: 1
          re: !!perl/hash:RE 
            decl: []

            min: 1
            re: &96 !!perl/hash:RE_any 
              a: 0
              altname: special_variable__S_150AtMinus_01
              dba: special_variable__S_150AtMinus
              i: 0
              min: 1
              name: special_variable__S_150AtMinus_01
              r: 1
              s: 0
              zyg: 
                - !!perl/hash:RE_meta 
                  a: 0
                  alt: special_variable__S_150AtMinus_01 0
                  dba: special_variable__S_150AtMinus
                  i: 0
                  min: 1
                  r: 1
                  s: 0
                  text: \s
                - !!perl/hash:RE_string 
                  a: 0
                  alt: special_variable__S_150AtMinus_01 1
                  dba: special_variable__S_150AtMinus
                  i: 0
                  min: 1
                  r: 1
                  s: 0
                  text: ","
                - !!perl/hash:RE_method 
                  a: 0
                  alt: special_variable__S_150AtMinus_01 2
                  dba: special_variable__S_150AtMinus
                  i: 0
                  min: 12345
                  name: terminator
                  r: 1
                  rest: ''
                  s: 0
          s: 0
      - !!perl/hash:RE_method 
        min: 0
        name: obs
        nobind: 1
        rest: ('@- variable', '.from method')
special_variable__S_150AtMinus_01: *96
special_variable__S_151PercentMinus: !!perl/hash:RE 
  decl: []

  kind: token
  min: 12345
  pkg: ~
  re: !!perl/hash:RE_sequence 
    a: 0
    dba: special_variable__S_151PercentMinus
    i: 0
    min: 12345
    r: 1
    s: 0
    zyg: 
      - !!perl/hash:RE_method 
        a: 0
        dba: special_variable__S_151PercentMinus
        i: 0
        min: 12345
        name: sym
        r: 1
        rest: ''
        s: 0
        sym: "%-"
      - !!perl/hash:RE_meta 
        a: 0
        dba: special_variable__S_151PercentMinus
        i: 0
        min: 0
        r: 1
        s: 0
        text: "::"
      - !!perl/hash:RE_assertion 
        assert: "?"
        min: 0
        re: !!perl/hash:RE_method_re 
          a: 0
          dba: special_variable__S_151PercentMinus
          i: 0
          min: 0
          name: before
          nobind: 1
          r: 1
          re: !!perl/hash:RE 
            decl: []

            min: 1
            re: &99 !!perl/hash:RE_any 
              a: 0
              altname: special_variable__S_151PercentMinus_01
              dba: special_variable__S_151PercentMinus
              i: 0
              min: 1
              name: special_variable__S_151PercentMinus_01
              r: 1
              s: 0
              zyg: 
                - !!perl/hash:RE_meta 
                  a: 0
                  alt: special_variable__S_151PercentMinus_01 0
                  dba: special_variable__S_151PercentMinus
                  i: 0
                  min: 1
                  r: 1
                  s: 0
                  text: \s
                - !!perl/hash:RE_string 
                  a: 0
                  alt: special_variable__S_151PercentMinus_01 1
                  dba: special_variable__S_151PercentMinus
                  i: 0
                  min: 1
                  r: 1
                  s: 0
                  text: ","
                - !!perl/hash:RE_method 
                  a: 0
                  alt: special_variable__S_151PercentMinus_01 2
                  dba: special_variable__S_151PercentMinus
                  i: 0
                  min: 12345
                  name: terminator
                  r: 1
                  rest: ''
                  s: 0
          s: 0
      - !!perl/hash:RE_method 
        min: 0
        name: obs
        nobind: 1
        rest: ('%- variable', '.from method')
special_variable__S_151PercentMinus_01: *99
special_variable__S_152DollarMinusBra_Ket: !!perl/hash:RE 
  decl: []

  kind: token
  min: 3
  pkg: ~
  re: !!perl/hash:RE_sequence 
    a: 0
    dba: special_variable__S_152DollarMinusBra_Ket
    i: 0
    min: 3
    r: 1
    s: 0
    zyg: 
      - !!perl/hash:RE_string 
        a: 0
        dba: special_variable__S_152DollarMinusBra_Ket
        i: 0
        min: 3
        r: 1
        s: 0
        text: $-[
      - !!perl/hash:RE_method 
        min: 0
        name: obs
        nobind: 1
        rest: ('@- variable', '.from method')
special_variable__S_153AtMinusBra_Ket: !!perl/hash:RE 
  decl: []

  kind: token
  min: 3
  pkg: ~
  re: !!perl/hash:RE_sequence 
    a: 0
    dba: special_variable__S_153AtMinusBra_Ket
    i: 0
    min: 3
    r: 1
    s: 0
    zyg: 
      - !!perl/hash:RE_string 
        a: 0
        dba: special_variable__S_153AtMinusBra_Ket
        i: 0
        min: 3
        r: 1
        s: 0
        text: "@-["
      - !!perl/hash:RE_method 
        min: 0
        name: obs
        nobind: 1
        rest: ('@- variable', '.from method')
special_variable__S_154PercentMinusCur_Ly: !!perl/hash:RE 
  decl: []

  kind: token
  min: 3
  pkg: ~
  re: !!perl/hash:RE_sequence 
    a: 0
    dba: special_variable__S_154PercentMinusCur_Ly
    i: 0
    min: 3
    r: 1
    s: 0
    zyg: 
      - !!perl/hash:RE_string 
        a: 0
        dba: special_variable__S_154PercentMinusCur_Ly
        i: 0
        min: 3
        r: 1
        s: 0
        text: "@-{"
      - !!perl/hash:RE_method 
        min: 0
        name: obs
        nobind: 1
        rest: ('%- variable', '.from method')
special_variable__S_155DollarPlus: !!perl/hash:RE 
  decl: []

  kind: token
  min: 12345
  pkg: ~
  re: !!perl/hash:RE_sequence 
    a: 0
    dba: special_variable__S_155DollarPlus
    i: 0
    min: 12345
    r: 1
    s: 0
    zyg: 
      - !!perl/hash:RE_method 
        a: 0
        dba: special_variable__S_155DollarPlus
        i: 0
        min: 12345
        name: sym
        r: 1
        rest: ''
        s: 0
        sym: $+
      - !!perl/hash:RE_meta 
        a: 0
        dba: special_variable__S_155DollarPlus
        i: 0
        min: 0
        r: 1
        s: 0
        text: "::"
      - !!perl/hash:RE_assertion 
        assert: "?"
        min: 0
        re: !!perl/hash:RE_method_re 
          a: 0
          dba: special_variable__S_155DollarPlus
          i: 0
          min: 0
          name: before
          nobind: 1
          r: 1
          re: !!perl/hash:RE 
            decl: []

            min: 1
            re: &1 !!perl/hash:RE_any 
              a: 0
              altname: special_variable__S_155DollarPlus_01
              dba: special_variable__S_155DollarPlus
              i: 0
              min: 1
              name: special_variable__S_155DollarPlus_01
              r: 1
              s: 0
              zyg: 
                - !!perl/hash:RE_meta 
                  a: 0
                  alt: special_variable__S_155DollarPlus_01 0
                  dba: special_variable__S_155DollarPlus
                  i: 0
                  min: 1
                  r: 1
                  s: 0
                  text: \s
                - !!perl/hash:RE_string 
                  a: 0
                  alt: special_variable__S_155DollarPlus_01 1
                  dba: special_variable__S_155DollarPlus
                  i: 0
                  min: 1
                  r: 1
                  s: 0
                  text: ","
                - !!perl/hash:RE_method 
                  a: 0
                  alt: special_variable__S_155DollarPlus_01 2
                  dba: special_variable__S_155DollarPlus
                  i: 0
                  min: 12345
                  name: terminator
                  r: 1
                  rest: ''
                  s: 0
          s: 0
      - !!perl/hash:RE_method 
        min: 0
        name: obs
        nobind: 1
        rest: ('$+ variable', 'Form module')
special_variable__S_155DollarPlus_01: *1
special_variable__S_156DollarCurCaret_Ly: !!perl/hash:RE 
  decl: []

  kind: token
  min: 12349
  pkg: ~
  re: !!perl/hash:RE_sequence 
    a: 0
    dba: special_variable__S_156DollarCurCaret_Ly
    i: 0
    min: 12349
    r: 1
    s: 0
    zyg: 
      - !!perl/hash:RE_method 
        a: 0
        dba: special_variable__S_156DollarCurCaret_Ly
        i: 0
        min: 12345
        name: sigil
        r: 1
        rest: ''
        s: 0
      - !!perl/hash:RE_string 
        a: 0
        dba: special_variable__S_156DollarCurCaret_Ly
        i: 0
        min: 2
        r: 1
        s: 0
        text: "{^"
      - !!perl/hash:RE_meta 
        a: 0
        dba: special_variable__S_156DollarCurCaret_Ly
        i: 0
        min: 0
        r: 1
        s: 0
        text: "::"
      - !!perl/hash:RE_bindnamed 
        a: 0
        atom: !!perl/hash:RE_bracket 
          decl: []

          min: 1
          nobind: 1
          re: !!perl/hash:RE_meta 
            a: 0
            dba: special_variable__S_156DollarCurCaret_Ly
            i: 0
            min: 1
            r: 1
            s: 0
            text: .*?
        dba: special_variable__S_156DollarCurCaret_Ly
        i: 0
        min: 1
        r: 1
        s: 0
        var: text
      - !!perl/hash:RE_string 
        a: 0
        dba: special_variable__S_156DollarCurCaret_Ly
        i: 0
        min: 1
        r: 1
        s: 0
        text: "}"
      - !!perl/hash:RE_method 
        min: 0
        name: obscaret
        nobind: 1
        rest: ($<sigil>.Str ~ '{^' ~ $<text>.Str ~ '}', $<sigil>.Str, $<text>.Str)
special_variable__S_157ColonColonCur_Ly: !!perl/hash:RE 
  decl: []

  kind: token
  min: 2
  pkg: ~
  re: !!perl/hash:RE_sequence 
    a: 0
    dba: special_variable__S_157ColonColonCur_Ly
    i: 0
    min: 2
    r: 1
    s: 0
    zyg: 
      - !!perl/hash:RE_string 
        a: 0
        dba: special_variable__S_157ColonColonCur_Ly
        i: 0
        min: 2
        r: 1
        s: 0
        text: "::"
      - !!perl/hash:RE_assertion 
        assert: "?"
        min: 0
        re: !!perl/hash:RE_method_re 
          a: 0
          dba: special_variable__S_157ColonColonCur_Ly
          i: 0
          min: 0
          name: before
          nobind: 1
          r: 1
          re: !!perl/hash:RE 
            decl: []

            min: 1
            re: !!perl/hash:RE_string 
              a: 0
              dba: special_variable__S_157ColonColonCur_Ly
              i: 0
              min: 1
              r: 1
              s: 0
              text: "{"
          s: 0
special_variable__S_158DollarCur_Ly: !!perl/hash:RE 
  decl: []

  kind: regex
  min: 12348
  pkg: ~
  re: !!perl/hash:RE_sequence 
    a: 0
    dba: special_variable__S_158DollarCur_Ly
    i: 0
    min: 12348
    r: 0
    s: 0
    zyg: 
      - !!perl/hash:RE_method 
        a: 0
        dba: special_variable__S_158DollarCur_Ly
        i: 0
        min: 12345
        name: sigil
        r: 0
        rest: ''
        s: 0
      - !!perl/hash:RE_string 
        a: 0
        dba: special_variable__S_158DollarCur_Ly
        i: 0
        min: 1
        r: 0
        s: 0
        text: "{"
      - !!perl/hash:RE_block 
        a: 0
        context: void
        dba: special_variable__S_158DollarCur_Ly
        i: 0
        min: 0
        r: 0
        s: 0
        text: ''
      - !!perl/hash:RE_bindnamed 
        a: 0
        atom: !!perl/hash:RE_bracket 
          decl: []

          min: 1
          nobind: 1
          re: !!perl/hash:RE_meta 
            a: 0
            dba: special_variable__S_158DollarCur_Ly
            i: 0
            min: 1
            r: 0
            s: 0
            text: .*?
        dba: special_variable__S_158DollarCur_Ly
        i: 0
        min: 1
        r: 0
        s: 0
        var: text
      - !!perl/hash:RE_string 
        a: 0
        dba: special_variable__S_158DollarCur_Ly
        i: 0
        min: 1
        r: 0
        s: 0
        text: "}"
      - !!perl/hash:RE_block 
        a: 0
        context: void
        dba: special_variable__S_158DollarCur_Ly
        i: 0
        min: 0
        r: 0
        s: 0
        text: "\n        my $sigil = $<sigil>.Str;\n        my $text = $<text>.Str;\n        my $bad = $sigil ~ '{' ~ $text ~ '}';\n        $text = $text - 1 if $text ~~ /^\\d+$/;\n        if $text !~~ /^(\\w|\\:)+$/ {\n            $¢.obs($bad, $sigil ~ '(' ~ $text ~ ')');\n        }\n        elsif $*QSIGIL {\n            $¢.obs($bad, '{' ~ $sigil ~ $text ~ '}');\n        }\n        else {\n            $¢.obs($bad, $sigil ~ $text);\n        }\n    "
special_variable__S_159DollarBra: !!perl/hash:RE 
  decl: []

  kind: token
  min: 12345
  pkg: ~
  re: !!perl/hash:RE_sequence 
    a: 0
    dba: special_variable__S_159DollarBra
    i: 0
    min: 12345
    r: 1
    s: 0
    zyg: 
      - !!perl/hash:RE_method 
        a: 0
        dba: special_variable__S_159DollarBra
        i: 0
        min: 12345
        name: sym
        r: 1
        rest: ''
        s: 0
        sym: $[
      - !!perl/hash:RE_meta 
        a: 0
        dba: special_variable__S_159DollarBra
        i: 0
        min: 0
        r: 1
        s: 0
        text: "::"
      - !!perl/hash:RE_assertion 
        assert: "?"
        min: 0
        re: !!perl/hash:RE_method_re 
          a: 0
          dba: special_variable__S_159DollarBra
          i: 0
          min: 0
          name: before
          nobind: 1
          r: 1
          re: !!perl/hash:RE 
            decl: []

            min: 1
            re: &92 !!perl/hash:RE_any 
              a: 0
              altname: special_variable__S_159DollarBra_01
              dba: special_variable__S_159DollarBra
              i: 0
              min: 1
              name: special_variable__S_159DollarBra_01
              r: 1
              s: 0
              zyg: 
                - !!perl/hash:RE_meta 
                  a: 0
                  alt: special_variable__S_159DollarBra_01 0
                  dba: special_variable__S_159DollarBra
                  i: 0
                  min: 1
                  r: 1
                  s: 0
                  text: \s
                - !!perl/hash:RE_string 
                  a: 0
                  alt: special_variable__S_159DollarBra_01 1
                  dba: special_variable__S_159DollarBra
                  i: 0
                  min: 1
                  r: 1
                  s: 0
                  text: ","
                - !!perl/hash:RE_string 
                  a: 0
                  alt: special_variable__S_159DollarBra_01 2
                  dba: special_variable__S_159DollarBra
                  i: 0
                  min: 1
                  r: 1
                  s: 0
                  text: =
                - !!perl/hash:RE_method 
                  a: 0
                  alt: special_variable__S_159DollarBra_01 3
                  dba: special_variable__S_159DollarBra
                  i: 0
                  min: 12345
                  name: terminator
                  r: 1
                  rest: ''
                  s: 0
          s: 0
      - !!perl/hash:RE_method 
        min: 0
        name: obs
        nobind: 1
        rest: ('$[ variable', 'user-defined array indices')
special_variable__S_159DollarBra_01: *92
special_variable__S_160DollarKet: !!perl/hash:RE 
  decl: []

  kind: token
  min: 12345
  pkg: ~
  re: !!perl/hash:RE_sequence 
    a: 0
    dba: special_variable__S_160DollarKet
    i: 0
    min: 12345
    r: 1
    s: 0
    zyg: 
      - !!perl/hash:RE_method 
        a: 0
        dba: special_variable__S_160DollarKet
        i: 0
        min: 12345
        name: sym
        r: 1
        rest: ''
        s: 0
        sym: $]
      - !!perl/hash:RE_meta 
        a: 0
        dba: special_variable__S_160DollarKet
        i: 0
        min: 0
        r: 1
        s: 0
        text: "::"
      - !!perl/hash:RE_assertion 
        assert: "?"
        min: 0
        re: !!perl/hash:RE_method_re 
          a: 0
          dba: special_variable__S_160DollarKet
          i: 0
          min: 0
          name: before
          nobind: 1
          r: 1
          re: !!perl/hash:RE 
            decl: []

            min: 1
            re: &97 !!perl/hash:RE_any 
              a: 0
              altname: special_variable__S_160DollarKet_01
              dba: special_variable__S_160DollarKet
              i: 0
              min: 1
              name: special_variable__S_160DollarKet_01
              r: 1
              s: 0
              zyg: 
                - !!perl/hash:RE_meta 
                  a: 0
                  alt: special_variable__S_160DollarKet_01 0
                  dba: special_variable__S_160DollarKet
                  i: 0
                  min: 1
                  r: 1
                  s: 0
                  text: \s
                - !!perl/hash:RE_string 
                  a: 0
                  alt: special_variable__S_160DollarKet_01 1
                  dba: special_variable__S_160DollarKet
                  i: 0
                  min: 1
                  r: 1
                  s: 0
                  text: ","
                - !!perl/hash:RE_method 
                  a: 0
                  alt: special_variable__S_160DollarKet_01 2
                  dba: special_variable__S_160DollarKet
                  i: 0
                  min: 12345
                  name: terminator
                  r: 1
                  rest: ''
                  s: 0
          s: 0
      - !!perl/hash:RE_method 
        min: 0
        name: obs
        nobind: 1
        rest: ('$] variable', '$*PERL_VERSION')
special_variable__S_160DollarKet_01: *97
special_variable__S_161DollarBack: !!perl/hash:RE 
  decl: []

  kind: token
  min: 12345
  pkg: ~
  re: !!perl/hash:RE_sequence 
    a: 0
    dba: special_variable__S_161DollarBack
    i: 0
    min: 12345
    r: 1
    s: 0
    zyg: 
      - !!perl/hash:RE_method 
        a: 0
        dba: special_variable__S_161DollarBack
        i: 0
        min: 12345
        name: sym
        r: 1
        rest: ''
        s: 0
        sym: $\
      - !!perl/hash:RE_meta 
        a: 0
        dba: special_variable__S_161DollarBack
        i: 0
        min: 0
        r: 1
        s: 0
        text: "::"
      - !!perl/hash:RE_assertion 
        assert: "?"
        min: 0
        re: !!perl/hash:RE_method_re 
          a: 0
          dba: special_variable__S_161DollarBack
          i: 0
          min: 0
          name: before
          nobind: 1
          r: 1
          re: !!perl/hash:RE 
            decl: []

            min: 1
            re: &82 !!perl/hash:RE_any 
              a: 0
              altname: special_variable__S_161DollarBack_01
              dba: special_variable__S_161DollarBack
              i: 0
              min: 1
              name: special_variable__S_161DollarBack_01
              r: 1
              s: 0
              zyg: 
                - !!perl/hash:RE_meta 
                  a: 0
                  alt: special_variable__S_161DollarBack_01 0
                  dba: special_variable__S_161DollarBack
                  i: 0
                  min: 1
                  r: 1
                  s: 0
                  text: \s
                - !!perl/hash:RE_string 
                  a: 0
                  alt: special_variable__S_161DollarBack_01 1
                  dba: special_variable__S_161DollarBack
                  i: 0
                  min: 1
                  r: 1
                  s: 0
                  text: ","
                - !!perl/hash:RE_string 
                  a: 0
                  alt: special_variable__S_161DollarBack_01 2
                  dba: special_variable__S_161DollarBack
                  i: 0
                  min: 1
                  r: 1
                  s: 0
                  text: =
                - !!perl/hash:RE_method 
                  a: 0
                  alt: special_variable__S_161DollarBack_01 3
                  dba: special_variable__S_161DollarBack
                  i: 0
                  min: 12345
                  name: terminator
                  r: 1
                  rest: ''
                  s: 0
          s: 0
      - !!perl/hash:RE_method 
        min: 0
        name: obs
        nobind: 1
        rest: ('$\\ variable', "the filehandle's :ors attribute")
special_variable__S_161DollarBack_01: *82
special_variable__S_162DollarVert: !!perl/hash:RE 
  decl: []

  kind: token
  min: 12345
  pkg: ~
  re: !!perl/hash:RE_sequence 
    a: 0
    dba: special_variable__S_162DollarVert
    i: 0
    min: 12345
    r: 1
    s: 0
    zyg: 
      - !!perl/hash:RE_method 
        a: 0
        dba: special_variable__S_162DollarVert
        i: 0
        min: 12345
        name: sym
        r: 1
        rest: ''
        s: 0
        sym: $|
      - !!perl/hash:RE_meta 
        a: 0
        dba: special_variable__S_162DollarVert
        i: 0
        min: 0
        r: 1
        s: 0
        text: "::"
      - !!perl/hash:RE_assertion 
        assert: "?"
        min: 0
        re: !!perl/hash:RE_method_re 
          a: 0
          dba: special_variable__S_162DollarVert
          i: 0
          min: 0
          name: before
          nobind: 1
          r: 1
          re: !!perl/hash:RE 
            decl: []

            min: 1
            re: &133 !!perl/hash:RE_any 
              a: 0
              altname: special_variable__S_162DollarVert_01
              dba: special_variable__S_162DollarVert
              i: 0
              min: 1
              name: special_variable__S_162DollarVert_01
              r: 1
              s: 0
              zyg: 
                - !!perl/hash:RE_meta 
                  a: 0
                  alt: special_variable__S_162DollarVert_01 0
                  dba: special_variable__S_162DollarVert
                  i: 0
                  min: 1
                  r: 1
                  s: 0
                  text: \s
                - !!perl/hash:RE_string 
                  a: 0
                  alt: special_variable__S_162DollarVert_01 1
                  dba: special_variable__S_162DollarVert
                  i: 0
                  min: 1
                  r: 1
                  s: 0
                  text: ","
                - !!perl/hash:RE_string 
                  a: 0
                  alt: special_variable__S_162DollarVert_01 2
                  dba: special_variable__S_162DollarVert
                  i: 0
                  min: 1
                  r: 1
                  s: 0
                  text: =
                - !!perl/hash:RE_method 
                  a: 0
                  alt: special_variable__S_162DollarVert_01 3
                  dba: special_variable__S_162DollarVert
                  i: 0
                  min: 12345
                  name: terminator
                  r: 1
                  rest: ''
                  s: 0
          s: 0
      - !!perl/hash:RE_method 
        min: 0
        name: obs
        nobind: 1
        rest: ('$| variable', ':autoflush on open')
special_variable__S_162DollarVert_01: *133
special_variable__S_163DollarColon: !!perl/hash:RE 
  decl: []

  kind: token
  min: 12345
  pkg: ~
  re: !!perl/hash:RE_sequence 
    a: 0
    dba: special_variable__S_163DollarColon
    i: 0
    min: 12345
    r: 1
    s: 0
    zyg: 
      - !!perl/hash:RE_method 
        a: 0
        dba: special_variable__S_163DollarColon
        i: 0
        min: 12345
        name: sym
        r: 1
        rest: ''
        s: 0
        sym: "$:"
      - !!perl/hash:RE_assertion 
        assert: "?"
        min: 0
        re: !!perl/hash:RE_method_re 
          a: 0
          dba: special_variable__S_163DollarColon
          i: 0
          min: 0
          name: before
          nobind: 1
          r: 1
          re: !!perl/hash:RE 
            decl: []

            min: 1
            re: !!perl/hash:RE_cclass 
              a: 0
              dba: special_variable__S_163DollarColon
              i: 0
              min: 1
              r: 1
              s: 0
              text: "[\\x20\\t\\n\\],=)}]"
          s: 0
      - !!perl/hash:RE_method 
        min: 0
        name: obs
        nobind: 1
        rest: "('$: variable', 'Form module')"
special_variable__S_164DollarSemi: !!perl/hash:RE 
  decl: []

  kind: token
  min: 12345
  pkg: ~
  re: !!perl/hash:RE_sequence 
    a: 0
    dba: special_variable__S_164DollarSemi
    i: 0
    min: 12345
    r: 1
    s: 0
    zyg: 
      - !!perl/hash:RE_method 
        a: 0
        dba: special_variable__S_164DollarSemi
        i: 0
        min: 12345
        name: sym
        r: 1
        rest: ''
        s: 0
        sym: $;
      - !!perl/hash:RE_meta 
        a: 0
        dba: special_variable__S_164DollarSemi
        i: 0
        min: 0
        r: 1
        s: 0
        text: "::"
      - !!perl/hash:RE_assertion 
        assert: "?"
        min: 0
        re: !!perl/hash:RE_method_re 
          a: 0
          dba: special_variable__S_164DollarSemi
          i: 0
          min: 0
          name: before
          nobind: 1
          r: 1
          re: !!perl/hash:RE 
            decl: []

            min: 1
            re: &110 !!perl/hash:RE_any 
              a: 0
              altname: special_variable__S_164DollarSemi_01
              dba: special_variable__S_164DollarSemi
              i: 0
              min: 1
              name: special_variable__S_164DollarSemi_01
              r: 1
              s: 0
              zyg: 
                - !!perl/hash:RE_meta 
                  a: 0
                  alt: special_variable__S_164DollarSemi_01 0
                  dba: special_variable__S_164DollarSemi
                  i: 0
                  min: 1
                  r: 1
                  s: 0
                  text: \s
                - !!perl/hash:RE_string 
                  a: 0
                  alt: special_variable__S_164DollarSemi_01 1
                  dba: special_variable__S_164DollarSemi
                  i: 0
                  min: 1
                  r: 1
                  s: 0
                  text: ","
                - !!perl/hash:RE_string 
                  a: 0
                  alt: special_variable__S_164DollarSemi_01 2
                  dba: special_variable__S_164DollarSemi
                  i: 0
                  min: 1
                  r: 1
                  s: 0
                  text: =
                - !!perl/hash:RE_method 
                  a: 0
                  alt: special_variable__S_164DollarSemi_01 3
                  dba: special_variable__S_164DollarSemi
                  i: 0
                  min: 12345
                  name: terminator
                  r: 1
                  rest: ''
                  s: 0
          s: 0
      - !!perl/hash:RE_method 
        min: 0
        name: obs
        nobind: 1
        rest: ('$; variable', 'real multidimensional hashes')
special_variable__S_164DollarSemi_01: *110
special_variable__S_165DollarSingle: !!perl/hash:RE 
  decl: []

  kind: token
  min: 12345
  pkg: ~
  re: !!perl/hash:RE_sequence 
    a: 0
    dba: special_variable__S_165DollarSingle
    i: 0
    min: 12345
    r: 1
    s: 0
    zyg: 
      - !!perl/hash:RE_method 
        a: 0
        dba: special_variable__S_165DollarSingle
        i: 0
        min: 12345
        name: sym
        r: 1
        rest: ''
        s: 0
        sym: $'
      - !!perl/hash:RE_meta 
        a: 0
        dba: special_variable__S_165DollarSingle
        i: 0
        min: 0
        r: 1
        s: 0
        text: "::"
      - !!perl/hash:RE_assertion 
        assert: "?"
        min: 0
        re: !!perl/hash:RE_method_re 
          a: 0
          dba: special_variable__S_165DollarSingle
          i: 0
          min: 0
          name: before
          nobind: 1
          r: 1
          re: !!perl/hash:RE 
            decl: []

            min: 1
            re: &53 !!perl/hash:RE_any 
              a: 0
              altname: special_variable__S_165DollarSingle_01
              dba: special_variable__S_165DollarSingle
              i: 0
              min: 1
              name: special_variable__S_165DollarSingle_01
              r: 1
              s: 0
              zyg: 
                - !!perl/hash:RE_meta 
                  a: 0
                  alt: special_variable__S_165DollarSingle_01 0
                  dba: special_variable__S_165DollarSingle
                  i: 0
                  min: 1
                  r: 1
                  s: 0
                  text: \s
                - !!perl/hash:RE_string 
                  a: 0
                  alt: special_variable__S_165DollarSingle_01 1
                  dba: special_variable__S_165DollarSingle
                  i: 0
                  min: 1
                  r: 1
                  s: 0
                  text: ","
                - !!perl/hash:RE_method 
                  a: 0
                  alt: special_variable__S_165DollarSingle_01 2
                  dba: special_variable__S_165DollarSingle
                  i: 0
                  min: 12345
                  name: terminator
                  r: 1
                  rest: ''
                  s: 0
          s: 0
      - !!perl/hash:RE_method 
        min: 0
        name: obs
        nobind: 1
        rest: ('$' ~ "'" ~ 'variable', "explicit pattern after )\x3E")
special_variable__S_165DollarSingle_01: *53
special_variable__S_166DollarDouble: !!perl/hash:RE 
  decl: []

  kind: token
  min: 12345
  pkg: ~
  re: !!perl/hash:RE_sequence 
    a: 0
    dba: special_variable__S_166DollarDouble
    i: 0
    min: 12345
    r: 1
    s: 0
    zyg: 
      - !!perl/hash:RE_method 
        a: 0
        dba: special_variable__S_166DollarDouble
        i: 0
        min: 12345
        name: sym
        r: 1
        rest: ''
        s: 0
        sym: $"
      - !!perl/hash:RE_assertion 
        assert: "!"
        min: 0
        re: !!perl/hash:RE_block 
          a: 0
          context: bool
          dba: special_variable__S_166DollarDouble
          i: 0
          min: 0
          nobind: 1
          r: 1
          s: 0
          text: " $*QSIGIL "
      - !!perl/hash:RE_meta 
        a: 0
        dba: special_variable__S_166DollarDouble
        i: 0
        min: 0
        r: 1
        s: 0
        text: "::"
      - !!perl/hash:RE_assertion 
        assert: "?"
        min: 0
        re: !!perl/hash:RE_method_re 
          a: 0
          dba: special_variable__S_166DollarDouble
          i: 0
          min: 0
          name: before
          nobind: 1
          r: 1
          re: !!perl/hash:RE 
            decl: []

            min: 1
            re: &103 !!perl/hash:RE_any 
              a: 0
              altname: special_variable__S_166DollarDouble_01
              dba: special_variable__S_166DollarDouble
              i: 0
              min: 1
              name: special_variable__S_166DollarDouble_01
              r: 1
              s: 0
              zyg: 
                - !!perl/hash:RE_meta 
                  a: 0
                  alt: special_variable__S_166DollarDouble_01 0
                  dba: special_variable__S_166DollarDouble
                  i: 0
                  min: 1
                  r: 1
                  s: 0
                  text: \s
                - !!perl/hash:RE_string 
                  a: 0
                  alt: special_variable__S_166DollarDouble_01 1
                  dba: special_variable__S_166DollarDouble
                  i: 0
                  min: 1
                  r: 1
                  s: 0
                  text: ","
                - !!perl/hash:RE_string 
                  a: 0
                  alt: special_variable__S_166DollarDouble_01 2
                  dba: special_variable__S_166DollarDouble
                  i: 0
                  min: 1
                  r: 1
                  s: 0
                  text: =
                - !!perl/hash:RE_method 
                  a: 0
                  alt: special_variable__S_166DollarDouble_01 3
                  dba: special_variable__S_166DollarDouble
                  i: 0
                  min: 12345
                  name: terminator
                  r: 1
                  rest: ''
                  s: 0
          s: 0
      - !!perl/hash:RE_method 
        min: 0
        name: obs
        nobind: 1
        rest: ('$" variable', '.join() method')
special_variable__S_166DollarDouble_01: *103
special_variable__S_167DollarComma: !!perl/hash:RE 
  decl: []

  kind: token
  min: 12345
  pkg: ~
  re: !!perl/hash:RE_sequence 
    a: 0
    dba: special_variable__S_167DollarComma
    i: 0
    min: 12345
    r: 1
    s: 0
    zyg: 
      - !!perl/hash:RE_method 
        a: 0
        dba: special_variable__S_167DollarComma
        i: 0
        min: 12345
        name: sym
        r: 1
        rest: ''
        s: 0
        sym: $,
      - !!perl/hash:RE_meta 
        a: 0
        dba: special_variable__S_167DollarComma
        i: 0
        min: 0
        r: 1
        s: 0
        text: "::"
      - !!perl/hash:RE_assertion 
        assert: "?"
        min: 0
        re: !!perl/hash:RE_method_re 
          a: 0
          dba: special_variable__S_167DollarComma
          i: 0
          min: 0
          name: before
          nobind: 1
          r: 1
          re: !!perl/hash:RE 
            decl: []

            min: 1
            re: &72 !!perl/hash:RE_any 
              a: 0
              altname: special_variable__S_167DollarComma_01
              dba: special_variable__S_167DollarComma
              i: 0
              min: 1
              name: special_variable__S_167DollarComma_01
              r: 1
              s: 0
              zyg: 
                - !!perl/hash:RE_meta 
                  a: 0
                  alt: special_variable__S_167DollarComma_01 0
                  dba: special_variable__S_167DollarComma
                  i: 0
                  min: 1
                  r: 1
                  s: 0
                  text: \s
                - !!perl/hash:RE_string 
                  a: 0
                  alt: special_variable__S_167DollarComma_01 1
                  dba: special_variable__S_167DollarComma
                  i: 0
                  min: 1
                  r: 1
                  s: 0
                  text: ","
                - !!perl/hash:RE_method 
                  a: 0
                  alt: special_variable__S_167DollarComma_01 2
                  dba: special_variable__S_167DollarComma
                  i: 0
                  min: 12345
                  name: terminator
                  r: 1
                  rest: ''
                  s: 0
          s: 0
      - !!perl/hash:RE_method 
        min: 0
        name: obs
        nobind: 1
        rest: ('$, variable', ".join() method")
special_variable__S_167DollarComma_01: *72
special_variable__S_168DollarLt: !!perl/hash:RE 
  decl: []

  kind: token
  min: 12345
  pkg: ~
  re: !!perl/hash:RE_sequence 
    a: 0
    dba: special_variable__S_168DollarLt
    i: 0
    min: 12345
    r: 1
    s: 0
    zyg: 
      - !!perl/hash:RE_method 
        a: 0
        dba: special_variable__S_168DollarLt
        i: 0
        min: 12345
        name: sym
        r: 1
        rest: ''
        s: 0
        sym: "['$<']"
      - !!perl/hash:RE_meta 
        a: 0
        dba: special_variable__S_168DollarLt
        i: 0
        min: 0
        r: 1
        s: 0
        text: "::"
      - !!perl/hash:RE_assertion 
        assert: "!"
        min: 0
        re: !!perl/hash:RE_method_re 
          a: 0
          dba: special_variable__S_168DollarLt
          i: 0
          min: 0
          name: before
          nobind: 1
          r: 1
          re: !!perl/hash:RE 
            decl: []

            min: 2
            re: !!perl/hash:RE_sequence 
              a: 0
              dba: special_variable__S_168DollarLt
              i: 0
              min: 2
              r: 1
              s: 0
              zyg: 
                - !!perl/hash:RE_quantified_atom 
                  atom: !!perl/hash:RE_meta 
                    a: 0
                    dba: special_variable__S_168DollarLt
                    i: 0
                    min: 1
                    r: 1
                    s: 0
                    text: \s
                  min: 0
                  quant: 
                    - "*"
                    - ":"
                    - ''
                    - 0
                - !!perl/hash:RE_quantified_atom 
                  atom: !!perl/hash:RE_meta 
                    a: 0
                    dba: special_variable__S_168DollarLt
                    i: 0
                    min: 1
                    r: 1
                    s: 0
                    text: \w
                  min: 1
                  quant: 
                    - +
                    - ":"
                    - ''
                    - 1
                - !!perl/hash:RE_quantified_atom 
                  atom: !!perl/hash:RE_meta 
                    a: 0
                    dba: special_variable__S_168DollarLt
                    i: 0
                    min: 1
                    r: 1
                    s: 0
                    text: \s
                  min: 0
                  quant: 
                    - "*"
                    - ":"
                    - ''
                    - 0
                - !!perl/hash:RE_string 
                  a: 0
                  dba: special_variable__S_168DollarLt
                  i: 0
                  min: 1
                  r: 1
                  s: 0
                  text: ">"
          s: 0
      - !!perl/hash:RE_method 
        min: 0
        name: obs
        nobind: 1
        rest: ('$< variable', '$*UID')
special_variable__S_169DollarGt: !!perl/hash:RE 
  decl: []

  kind: token
  min: 12345
  pkg: ~
  re: !!perl/hash:RE_sequence 
    a: 0
    dba: special_variable__S_169DollarGt
    i: 0
    min: 12345
    r: 1
    s: 0
    zyg: 
      - !!perl/hash:RE_method 
        a: 0
        dba: special_variable__S_169DollarGt
        i: 0
        min: 12345
        name: sym
        r: 1
        rest: ''
        s: 0
        sym: $>
      - !!perl/hash:RE_meta 
        a: 0
        dba: special_variable__S_169DollarGt
        i: 0
        min: 0
        r: 1
        s: 0
        text: "::"
      - !!perl/hash:RE_assertion 
        assert: "?"
        min: 0
        re: !!perl/hash:RE_method_re 
          a: 0
          dba: special_variable__S_169DollarGt
          i: 0
          min: 0
          name: before
          nobind: 1
          r: 1
          re: !!perl/hash:RE 
            decl: []

            min: 1
            re: &136 !!perl/hash:RE_any 
              a: 0
              altname: special_variable__S_169DollarGt_01
              dba: special_variable__S_169DollarGt
              i: 0
              min: 1
              name: special_variable__S_169DollarGt_01
              r: 1
              s: 0
              zyg: 
                - !!perl/hash:RE_meta 
                  a: 0
                  alt: special_variable__S_169DollarGt_01 0
                  dba: special_variable__S_169DollarGt
                  i: 0
                  min: 1
                  r: 1
                  s: 0
                  text: \s
                - !!perl/hash:RE_string 
                  a: 0
                  alt: special_variable__S_169DollarGt_01 1
                  dba: special_variable__S_169DollarGt
                  i: 0
                  min: 1
                  r: 1
                  s: 0
                  text: ","
                - !!perl/hash:RE_method 
                  a: 0
                  alt: special_variable__S_169DollarGt_01 2
                  dba: special_variable__S_169DollarGt
                  i: 0
                  min: 12345
                  name: terminator
                  r: 1
                  rest: ''
                  s: 0
          s: 0
      - !!perl/hash:RE_method 
        min: 0
        name: obs
        nobind: 1
        rest: ('$> variable', '$*EUID')
special_variable__S_169DollarGt_01: *136
special_variable__S_170DollarDot: !!perl/hash:RE 
  decl: []

  kind: token
  min: 12345
  pkg: ~
  re: !!perl/hash:RE_sequence 
    a: 0
    dba: special_variable__S_170DollarDot
    i: 0
    min: 12345
    r: 1
    s: 0
    zyg: 
      - !!perl/hash:RE_method 
        a: 0
        dba: special_variable__S_170DollarDot
        i: 0
        min: 12345
        name: sym
        r: 1
        rest: ''
        s: 0
        sym: $.
      - !!perl/hash:RE_meta 
        a: 0
        dba: special_variable__S_170DollarDot
        i: 0
        min: 0
        r: 1
        s: 0
        text: "::"
      - !!perl/hash:RE_assertion 
        assert: "?"
        min: 0
        re: !!perl/hash:RE_method_re 
          a: 0
          dba: special_variable__S_170DollarDot
          i: 0
          min: 0
          name: before
          nobind: 1
          r: 1
          re: !!perl/hash:RE 
            decl: []

            min: 1
            re: &70 !!perl/hash:RE_any 
              a: 0
              altname: special_variable__S_170DollarDot_01
              dba: special_variable__S_170DollarDot
              i: 0
              min: 1
              name: special_variable__S_170DollarDot_01
              r: 1
              s: 0
              zyg: 
                - !!perl/hash:RE_meta 
                  a: 0
                  alt: special_variable__S_170DollarDot_01 0
                  dba: special_variable__S_170DollarDot
                  i: 0
                  min: 1
                  r: 1
                  s: 0
                  text: \s
                - !!perl/hash:RE_string 
                  a: 0
                  alt: special_variable__S_170DollarDot_01 1
                  dba: special_variable__S_170DollarDot
                  i: 0
                  min: 1
                  r: 1
                  s: 0
                  text: ","
                - !!perl/hash:RE_method 
                  a: 0
                  alt: special_variable__S_170DollarDot_01 2
                  dba: special_variable__S_170DollarDot
                  i: 0
                  min: 12345
                  name: terminator
                  r: 1
                  rest: ''
                  s: 0
          s: 0
      - !!perl/hash:RE_method 
        min: 0
        name: obs
        nobind: 1
        rest: ('$. variable', "filehandle's .line method")
special_variable__S_170DollarDot_01: *70
special_variable__S_171DollarQuestion: !!perl/hash:RE 
  decl: []

  kind: token
  min: 12345
  pkg: ~
  re: !!perl/hash:RE_sequence 
    a: 0
    dba: special_variable__S_171DollarQuestion
    i: 0
    min: 12345
    r: 1
    s: 0
    zyg: 
      - !!perl/hash:RE_method 
        a: 0
        dba: special_variable__S_171DollarQuestion
        i: 0
        min: 12345
        name: sym
        r: 1
        rest: ''
        s: 0
        sym: $?
      - !!perl/hash:RE_meta 
        a: 0
        dba: special_variable__S_171DollarQuestion
        i: 0
        min: 0
        r: 1
        s: 0
        text: "::"
      - !!perl/hash:RE_assertion 
        assert: "?"
        min: 0
        re: !!perl/hash:RE_method_re 
          a: 0
          dba: special_variable__S_171DollarQuestion
          i: 0
          min: 0
          name: before
          nobind: 1
          r: 1
          re: !!perl/hash:RE 
            decl: []

            min: 1
            re: &24 !!perl/hash:RE_any 
              a: 0
              altname: special_variable__S_171DollarQuestion_01
              dba: special_variable__S_171DollarQuestion
              i: 0
              min: 1
              name: special_variable__S_171DollarQuestion_01
              r: 1
              s: 0
              zyg: 
                - !!perl/hash:RE_meta 
                  a: 0
                  alt: special_variable__S_171DollarQuestion_01 0
                  dba: special_variable__S_171DollarQuestion
                  i: 0
                  min: 1
                  r: 1
                  s: 0
                  text: \s
                - !!perl/hash:RE_string 
                  a: 0
                  alt: special_variable__S_171DollarQuestion_01 1
                  dba: special_variable__S_171DollarQuestion
                  i: 0
                  min: 1
                  r: 1
                  s: 0
                  text: ","
                - !!perl/hash:RE_method 
                  a: 0
                  alt: special_variable__S_171DollarQuestion_01 2
                  dba: special_variable__S_171DollarQuestion
                  i: 0
                  min: 12345
                  name: terminator
                  r: 1
                  rest: ''
                  s: 0
          s: 0
      - !!perl/hash:RE_method 
        min: 0
        name: obs
        nobind: 1
        rest: ('$? variable as child error', '$!')
special_variable__S_171DollarQuestion_01: *24
starter: !!perl/hash:RE 
  decl: []

  kind: token
  min: 0
  pkg: ~
  re: !!perl/hash:RE_assertion 
    assert: "!"
    min: 0
    re: !!perl/hash:RE_noop 
      a: 0
      dba: starter
      i: 0
      min: 0
      nobind: 1
      r: 1
      s: 0
statement: !!perl/hash:RE 
  decl: 
    - !!perl/hash:RE_decl 
      a: 0
      dba: statement
      i: 0
      max: 0
      min: 0
      r: 1
      s: 0
      text: my $endargs is context = -1
    - !!perl/hash:RE_decl 
      a: 0
      dba: statement
      i: 0
      max: 0
      min: 0
      r: 1
      s: 0
      text: my $QSIGIL is context<rw> = 0
  kind: token
  min: 0
  pkg: ~
  re: !!perl/hash:RE_sequence 
    a: 0
    dba: statement
    i: 0
    min: 0
    r: 1
    s: 0
    zyg: 
      - !!perl/hash:RE_assertion 
        assert: "!"
        min: 0
        re: !!perl/hash:RE_method_re 
          a: 0
          dba: statement
          i: 0
          min: 0
          name: before
          nobind: 1
          r: 1
          re: !!perl/hash:RE 
            decl: []

            min: 1
            re: !!perl/hash:RE_cclass 
              a: 0
              dba: statement
              i: 0
              min: 1
              r: 1
              s: 0
              text: "[\\)\\]\\}]"
          s: 0
      - !!perl/hash:RE_assertion 
        assert: "!"
        min: 0
        re: !!perl/hash:RE_assertion 
          assert: "!"
          min: 0
          nobind: 1
          re: !!perl/hash:RE_block 
            a: 0
            context: bool
            dba: statement
            i: 0
            min: 0
            nobind: 1
            r: 1
            s: 0
            text: " $¢ = %*LANG<MAIN>.bless($¢); "
      - !!perl/hash:RE_bracket 
        decl: []

        min: 0
        re: &37 !!perl/hash:RE_any 
          a: 0
          altname: statement_02
          dba: statement end
          i: 0
          min: 0
          name: statement_02
          r: 1
          s: 0
          zyg: 
            - !!perl/hash:RE_sequence 
              a: 0
              alt: statement_02 0
              dba: statement
              i: 0
              min: 24690
              r: 1
              s: 0
              zyg: 
                - !!perl/hash:RE_method 
                  a: 0
                  dba: statement
                  i: 0
                  min: 12345
                  name: label
                  r: 1
                  rest: ''
                  s: 0
                - !!perl/hash:RE_method 
                  a: 0
                  dba: statement
                  i: 0
                  min: 12345
                  name: statement
                  r: 1
                  rest: ''
                  s: 0
                - !!perl/hash:RE_method_internal 
                  args: $S, 'statement', 'label'
                  max: 0
                  min: 0
                  name: _REDUCE
            - !!perl/hash:RE_sequence 
              a: 0
              alt: statement_02 1
              dba: statement
              i: 0
              min: 12345
              r: 1
              s: 0
              zyg: 
                - !!perl/hash:RE_method 
                  a: 0
                  dba: statement
                  i: 0
                  min: 12345
                  name: statement_control
                  r: 1
                  rest: ''
                  s: 0
                - !!perl/hash:RE_method_internal 
                  args: $S, 'statement', 'control'
                  max: 0
                  min: 0
                  name: _REDUCE
            - !!perl/hash:RE_sequence 
              a: 0
              alt: statement_02 2
              dba: statement end
              i: 0
              min: 12345
              r: 1
              s: 0
              zyg: 
                - !!perl/hash:RE_method 
                  a: 0
                  dba: statement
                  i: 0
                  min: 12345
                  name: EXPR
                  r: 1
                  rest: ''
                  s: 0
                - !!perl/hash:RE_method_internal 
                  args: $S, 'statement', 'expr'
                  max: 0
                  min: 0
                  name: _REDUCE
                - !!perl/hash:RE_bracket 
                  decl: []

                  min: 0
                  re: !!perl/hash:RE_first 
                    a: 0
                    dba: statement modifier
                    i: 0
                    min: 0
                    r: 1
                    s: 0
                    zyg: 
                      - !!perl/hash:RE_assertion 
                        assert: "?"
                        min: 0
                        re: !!perl/hash:RE_block 
                          a: 0
                          context: bool
                          dba: statement end
                          i: 0
                          min: 0
                          nobind: 1
                          r: 1
                          s: 0
                          text: " (@*MEMOS[$¢.pos]<endstmt> // 0) == 2 "
                      - !!perl/hash:RE_sequence 
                        a: 0
                        dba: statement modifier
                        i: 0
                        min: 12345
                        r: 1
                        s: 0
                        zyg: 
                          - !!perl/hash:RE_method 
                            a: 0
                            dba: statement modifier
                            i: 0
                            min: 12345
                            name: ws
                            nobind: 1
                            r: 1
                            rest: ''
                            s: 0
                          - !!perl/hash:RE_quantified_atom 
                            atom: !!perl/hash:RE_bracket 
                              decl: []

                              min: 12345
                              re: &132 !!perl/hash:RE_any 
                                a: 0
                                altname: statement_05
                                dba: statement modifier loop
                                i: 0
                                min: 12345
                                name: statement_05
                                r: 1
                                s: 0
                                zyg: 
                                  - !!perl/hash:RE_sequence 
                                    a: 0
                                    alt: statement_05 0
                                    dba: statement modifier
                                    i: 0
                                    min: 12345
                                    r: 1
                                    s: 0
                                    zyg: 
                                      - !!perl/hash:RE_method 
                                        a: 0
                                        dba: statement modifier
                                        i: 0
                                        min: 12345
                                        name: statement_mod_loop
                                        r: 1
                                        rest: ''
                                        s: 0
                                      - !!perl/hash:RE_method_internal 
                                        args: $S, 'statement', 'mod loop'
                                        max: 0
                                        min: 0
                                        name: _REDUCE
                                      - !!perl/hash:RE_block 
                                        a: 0
                                        context: void
                                        dba: statement modifier
                                        i: 0
                                        min: 0
                                        r: 1
                                        s: 0
                                        text: "\n                    my $sp = $<EXPR><statement_prefix>;\n                    if $sp and $sp<sym> eq 'do' {\n                       my $s = $<statement_mod_loop>[0]<sym>;\n                       $¢.obs(\"do...$s\" ,\"repeat...$s\");\n                    }\n                "
                                  - !!perl/hash:RE_sequence 
                                    a: 0
                                    alt: statement_05 1
                                    dba: statement modifier loop
                                    i: 0
                                    min: 12345
                                    r: 1
                                    s: 0
                                    zyg: 
                                      - !!perl/hash:RE_method 
                                        a: 0
                                        dba: statement modifier
                                        i: 0
                                        min: 12345
                                        name: statement_mod_cond
                                        r: 1
                                        rest: ''
                                        s: 0
                                      - !!perl/hash:RE_method_internal 
                                        args: $S, 'statement', 'mod cond'
                                        max: 0
                                        min: 0
                                        name: _REDUCE
                                      - !!perl/hash:RE_bracket 
                                        decl: []

                                        min: 0
                                        re: !!perl/hash:RE_first 
                                          a: 0
                                          dba: statement modifier loop
                                          i: 0
                                          min: 0
                                          r: 1
                                          s: 0
                                          zyg: 
                                            - !!perl/hash:RE_assertion 
                                              assert: "?"
                                              min: 0
                                              re: !!perl/hash:RE_block 
                                                a: 0
                                                context: bool
                                                dba: statement modifier loop
                                                i: 0
                                                min: 0
                                                nobind: 1
                                                r: 1
                                                s: 0
                                                text: " (@*MEMOS[$¢.pos]<endstmt> // 0) == 2 "
                                            - !!perl/hash:RE_sequence 
                                              a: 0
                                              dba: statement modifier loop
                                              i: 0
                                              min: 12345
                                              r: 1
                                              s: 0
                                              zyg: 
                                                - !!perl/hash:RE_method 
                                                  a: 0
                                                  dba: statement modifier loop
                                                  i: 0
                                                  min: 12345
                                                  name: ws
                                                  nobind: 1
                                                  r: 1
                                                  rest: ''
                                                  s: 0
                                                - !!perl/hash:RE_quantified_atom 
                                                  atom: !!perl/hash:RE_method 
                                                    a: 0
                                                    dba: statement modifier loop
                                                    i: 0
                                                    min: 12345
                                                    name: statement_mod_loop
                                                    r: 1
                                                    rest: ''
                                                    s: 0
                                                  min: 0
                                                  quant: 
                                                    - "?"
                                                    - ":"
                                                    - ''
                                                    - 0
                                                - !!perl/hash:RE_method_internal 
                                                  args: $S, 'statement', 'mod condloop'
                                                  max: 0
                                                  min: 0
                                                  name: _REDUCE
                            min: 0
                            quant: 
                              - "?"
                              - ":"
                              - ''
                              - 0
                - !!perl/hash:RE_method_internal 
                  args: $S, 'statement', 'modexpr'
                  max: 0
                  min: 0
                  name: _REDUCE
            - !!perl/hash:RE_sequence 
              a: 0
              alt: statement_02 3
              dba: statement end
              i: 0
              min: 0
              r: 1
              s: 0
              zyg: 
                - !!perl/hash:RE_assertion 
                  assert: "?"
                  min: 0
                  re: !!perl/hash:RE_method_re 
                    a: 0
                    dba: statement end
                    i: 0
                    min: 0
                    name: before
                    nobind: 1
                    r: 1
                    re: !!perl/hash:RE 
                      decl: []

                      min: 1
                      re: !!perl/hash:RE_string 
                        a: 0
                        dba: statement end
                        i: 0
                        min: 1
                        r: 1
                        s: 0
                        text: ;
                    s: 0
                - !!perl/hash:RE_method_internal 
                  args: $S, 'statement', 'null'
                  max: 0
                  min: 0
                  name: _REDUCE
      - !!perl/hash:RE_quantified_atom 
        atom: !!perl/hash:RE_bracket 
          decl: []

          min: 0
          re: !!perl/hash:RE_sequence 
            a: 0
            dba: statement
            i: 0
            min: 0
            r: 1
            s: 0
            zyg: 
              - !!perl/hash:RE_assertion 
                assert: "?"
                min: 0
                re: !!perl/hash:RE_block 
                  a: 0
                  context: bool
                  dba: statement
                  i: 0
                  min: 0
                  nobind: 1
                  r: 1
                  s: 0
                  text: " (@*MEMOS[@*MEMOS[$¢.pos]<ws>//$¢.pos]<endargs>//0) == 1 "
              - !!perl/hash:RE_quantified_atom 
                atom: !!perl/hash:RE_meta 
                  a: 0
                  dba: statement
                  i: 0
                  min: 1
                  r: 1
                  s: 0
                  text: \h
                min: 0
                quant: 
                  - "*"
                  - ":"
                  - ''
                  - 0
              - !!perl/hash:RE_assertion 
                assert: "!"
                min: 0
                re: !!perl/hash:RE_method_re 
                  a: 0
                  dba: statement
                  i: 0
                  min: 0
                  name: before
                  nobind: 1
                  r: 1
                  re: !!perl/hash:RE 
                    decl: []

                    min: 1
                    re: &84 !!perl/hash:RE_any 
                      a: 0
                      altname: statement_10
                      dba: statement
                      i: 0
                      min: 1
                      name: statement_10
                      r: 1
                      s: 0
                      zyg: 
                        - !!perl/hash:RE_string 
                          a: 0
                          alt: statement_10 0
                          dba: statement
                          i: 0
                          min: 1
                          r: 1
                          s: 0
                          text: ;
                        - !!perl/hash:RE_string 
                          a: 0
                          alt: statement_10 1
                          dba: statement
                          i: 0
                          min: 1
                          r: 1
                          s: 0
                          text: )
                        - !!perl/hash:RE_string 
                          a: 0
                          alt: statement_10 2
                          dba: statement
                          i: 0
                          min: 1
                          r: 1
                          s: 0
                          text: "]"
                        - !!perl/hash:RE_string 
                          a: 0
                          alt: statement_10 3
                          dba: statement
                          i: 0
                          min: 1
                          r: 1
                          s: 0
                          text: "}"
                  s: 0
              - !!perl/hash:RE_assertion 
                assert: "!"
                min: 0
                re: !!perl/hash:RE_method 
                  a: 0
                  dba: statement
                  i: 0
                  min: 12345
                  name: infixstopper
                  nobind: 1
                  r: 1
                  rest: ''
                  s: 0
              - !!perl/hash:RE_method 
                min: 0
                name: panic
                nobind: 1
                rest: ("Statements must be separated with semicolon")
        min: 0
        quant: 
          - "?"
          - ":"
          - ''
          - 0
statement_02: *37
statement_05: *132
statement_10: *84
statement_control__S_036need: !!perl/hash:RE 
  decl: 
    - !!perl/hash:RE_decl 
      a: 0
      dba: statement_control__S_036need
      i: 0
      max: 0
      min: 0
      r: 1
      s: 0
      text: my $longname
  kind: token
  min: 37035
  pkg: ~
  re: !!perl/hash:RE_sequence 
    a: 0
    dba: statement_control__S_036need
    i: 0
    min: 37035
    r: 1
    s: 1
    zyg: 
      - !!perl/hash:RE_method 
        a: 0
        dba: statement_control__S_036need
        endsym: spacey
        i: 0
        min: 12345
        name: sym
        r: 1
        rest: ''
        s: 0
        sym: need
      - !!perl/hash:RE_method 
        a: 0
        dba: statement_control__S_036need
        i: 0
        min: 12345
        name: spacey
        nobind: 1
        r: 1
        rest: ''
        s: 0
      - !!perl/hash:RE_method 
        min: 0
        name: ws
        nobind: 1
        noquant: 1
        rest: ''
      - !!perl/hash:RE_quantified_atom 
        atom: !!perl/hash:RE_bracket 
          decl: []

          min: 12345
          re: &131 !!perl/hash:RE_any 
            a: 0
            altname: statement_control__S_036need_01
            dba: statement_control__S_036need
            i: 0
            min: 12345
            name: statement_control__S_036need_01
            r: 1
            s: 1
            zyg: 
              - !!perl/hash:RE_sequence 
                a: 0
                alt: statement_control__S_036need_01 0
                dba: statement_control__S_036need
                i: 0
                min: 12345
                r: 1
                s: 1
                zyg: 
                  - !!perl/hash:RE_method 
                    a: 0
                    dba: statement_control__S_036need
                    i: 0
                    min: 12345
                    name: version
                    r: 1
                    rest: ''
                    s: 1
                  - !!perl/hash:RE_method 
                    min: 0
                    name: ws
                    nobind: 1
                    noquant: 1
                    rest: ''
              - !!perl/hash:RE_sequence 
                a: 0
                alt: statement_control__S_036need_01 1
                dba: statement_control__S_036need
                i: 0
                min: 12345
                r: 1
                s: 1
                zyg: 
                  - !!perl/hash:RE_method 
                    a: 0
                    dba: statement_control__S_036need
                    i: 0
                    min: 12345
                    name: module_name
                    r: 1
                    rest: ''
                    s: 1
                  - !!perl/hash:RE_method 
                    min: 0
                    name: ws
                    nobind: 1
                    noquant: 1
                    rest: ''
                  - !!perl/hash:RE_block 
                    a: 0
                    context: void
                    dba: statement_control__S_036need
                    i: 0
                    min: 0
                    r: 1
                    s: 1
                    text: "\n            my $SCOPE is context = 'use';\n            $longname = $<module_name>[*-1]<longname>.Str;\n            $¢.do_need($longname);\n        "
                  - !!perl/hash:RE_method 
                    min: 0
                    name: ws
                    nobind: 1
                    noquant: 1
                    rest: ''
        min: 12345
        quant: 
          - "**"
          - ":"
          - !!perl/hash:RE_string 
            a: 0
            dba: statement_control__S_036need
            i: 0
            min: 1
            r: 1
            s: 1
            text: ","
          - 1
      - !!perl/hash:RE_method 
        min: 0
        name: ws
        nobind: 1
        noquant: 1
        rest: ''
statement_control__S_036need_01: *131
statement_control__S_037use: !!perl/hash:RE 
  decl: 
    - !!perl/hash:RE_decl 
      a: 0
      dba: statement_control__S_037use
      i: 0
      max: 0
      min: 0
      r: 1
      s: 0
      text: my $longname
    - !!perl/hash:RE_decl 
      a: 0
      dba: statement_control__S_037use
      i: 0
      max: 0
      min: 0
      r: 1
      s: 0
      text: my $SCOPE is context = 'use'
  kind: token
  min: 61725
  pkg: ~
  re: !!perl/hash:RE_sequence 
    a: 0
    dba: statement_control__S_037use
    i: 0
    min: 61725
    r: 1
    s: 0
    zyg: 
      - !!perl/hash:RE_method 
        a: 0
        dba: statement_control__S_037use
        endsym: spacey
        i: 0
        min: 12345
        name: sym
        r: 1
        rest: ''
        s: 0
        sym: use
      - !!perl/hash:RE_method 
        a: 0
        dba: statement_control__S_037use
        i: 0
        min: 12345
        name: spacey
        nobind: 1
        r: 1
        rest: ''
        s: 0
      - !!perl/hash:RE_method 
        a: 0
        dba: statement_control__S_037use
        i: 0
        min: 12345
        name: ws
        nobind: 1
        r: 1
        rest: ''
        s: 0
      - !!perl/hash:RE_bracket 
        decl: []

        min: 12345
        re: &87 !!perl/hash:RE_any 
          a: 0
          altname: statement_control__S_037use_01
          dba: statement_control__S_037use
          i: 0
          min: 12345
          name: statement_control__S_037use_01
          r: 1
          s: 0
          zyg: 
            - !!perl/hash:RE_method 
              a: 0
              alt: statement_control__S_037use_01 0
              dba: statement_control__S_037use
              i: 0
              min: 12345
              name: version
              r: 1
              rest: ''
              s: 0
            - !!perl/hash:RE_sequence 
              a: 0
              alt: statement_control__S_037use_01 1
              dba: statement_control__S_037use
              i: 0
              min: 12345
              r: 1
              s: 0
              zyg: 
                - !!perl/hash:RE_method 
                  a: 0
                  dba: statement_control__S_037use
                  i: 0
                  min: 12345
                  name: module_name
                  r: 1
                  rest: ''
                  s: 0
                - !!perl/hash:RE_block 
                  a: 0
                  context: void
                  dba: statement_control__S_037use
                  i: 0
                  min: 0
                  r: 1
                  s: 0
                  text: "\n            $longname = $<module_name><longname>.Str;\n        "
                - !!perl/hash:RE_bracket 
                  decl: []

                  min: 0
                  re: !!perl/hash:RE_first 
                    a: 0
                    dba: statement_control__S_037use
                    i: 0
                    min: 0
                    r: 1
                    s: 0
                    zyg: 
                      - !!perl/hash:RE_sequence 
                        a: 0
                        dba: statement_control__S_037use
                        i: 0
                        min: 24690
                        r: 1
                        s: 0
                        zyg: 
                          - !!perl/hash:RE_method 
                            a: 0
                            dba: statement_control__S_037use
                            i: 0
                            min: 12345
                            name: spacey
                            nobind: 1
                            r: 1
                            rest: ''
                            s: 0
                          - !!perl/hash:RE_method 
                            a: 0
                            dba: statement_control__S_037use
                            i: 0
                            min: 12345
                            name: arglist
                            r: 1
                            rest: ''
                            s: 0
                          - !!perl/hash:RE_block 
                            a: 0
                            context: void
                            dba: statement_control__S_037use
                            i: 0
                            min: 0
                            r: 1
                            s: 0
                            text: "\n                $¢.do_use($longname, $<arglist>);\n            "
                      - !!perl/hash:RE_block 
                        a: 0
                        context: void
                        dba: statement_control__S_037use
                        i: 0
                        min: 0
                        r: 1
                        s: 0
                        text: " $¢.do_use($longname, ''); "
      - !!perl/hash:RE_method 
        a: 0
        dba: statement_control__S_037use
        i: 0
        min: 12345
        name: ws
        nobind: 1
        r: 1
        rest: ''
        s: 0
statement_control__S_037use_01: *87
statement_control__S_038no: !!perl/hash:RE 
  decl: []

  kind: token
  min: 61725
  pkg: ~
  re: !!perl/hash:RE_sequence 
    a: 0
    dba: statement_control__S_038no
    i: 0
    min: 61725
    r: 1
    s: 0
    zyg: 
      - !!perl/hash:RE_method 
        a: 0
        dba: statement_control__S_038no
        endsym: spacey
        i: 0
        min: 12345
        name: sym
        r: 1
        rest: ''
        s: 0
        sym: 'no'
      - !!perl/hash:RE_method 
        a: 0
        dba: statement_control__S_038no
        i: 0
        min: 12345
        name: spacey
        nobind: 1
        r: 1
        rest: ''
        s: 0
      - !!perl/hash:RE_method 
        a: 0
        dba: statement_control__S_038no
        i: 0
        min: 12345
        name: ws
        nobind: 1
        r: 1
        rest: ''
        s: 0
      - !!perl/hash:RE_method 
        a: 0
        dba: statement_control__S_038no
        i: 0
        min: 12345
        name: module_name
        r: 1
        rest: ''
        s: 0
      - !!perl/hash:RE_quantified_atom 
        atom: !!perl/hash:RE_bracket 
          decl: []

          min: 24690
          re: !!perl/hash:RE_sequence 
            a: 0
            dba: statement_control__S_038no
            i: 0
            min: 24690
            r: 1
            s: 0
            zyg: 
              - !!perl/hash:RE_method 
                a: 0
                dba: statement_control__S_038no
                i: 0
                min: 12345
                name: spacey
                nobind: 1
                r: 1
                rest: ''
                s: 0
              - !!perl/hash:RE_method 
                a: 0
                dba: statement_control__S_038no
                i: 0
                min: 12345
                name: arglist
                r: 1
                rest: ''
                s: 0
        min: 0
        quant: 
          - "?"
          - ":"
          - ''
          - 0
      - !!perl/hash:RE_method 
        a: 0
        dba: statement_control__S_038no
        i: 0
        min: 12345
        name: ws
        nobind: 1
        r: 1
        rest: ''
        s: 0
statement_control__S_039if: !!perl/hash:RE 
  decl: []

  kind: token
  min: 37035
  pkg: ~
  re: !!perl/hash:RE_sequence 
    a: 0
    dba: statement_control__S_039if
    i: 0
    min: 37035
    r: 1
    s: 1
    zyg: 
      - !!perl/hash:RE_method 
        a: 0
        dba: statement_control__S_039if
        endsym: spacey
        i: 0
        min: 12345
        name: sym
        r: 1
        rest: ''
        s: 0
        sym: if
      - !!perl/hash:RE_method 
        a: 0
        dba: statement_control__S_039if
        i: 0
        min: 12345
        name: spacey
        nobind: 1
        r: 1
        rest: ''
        s: 0
      - !!perl/hash:RE_method 
        min: 0
        name: ws
        nobind: 1
        noquant: 1
        rest: ''
      - !!perl/hash:RE_method 
        a: 0
        dba: statement_control__S_039if
        i: 0
        min: 12345
        name: xblock
        r: 1
        rest: ''
        s: 1
      - !!perl/hash:RE_method 
        min: 0
        name: ws
        nobind: 1
        noquant: 1
        rest: ''
      - !!perl/hash:RE_quantified_atom 
        atom: !!perl/hash:RE_bracket 
          decl: []

          min: 12350
          re: !!perl/hash:RE_sequence 
            a: 0
            dba: statement_control__S_039if
            i: 0
            min: 12350
            r: 1
            s: 1
            zyg: 
              - !!perl/hash:RE_method 
                min: 0
                name: ws
                nobind: 1
                noquant: 1
                rest: ''
              - !!perl/hash:RE_bracket 
                decl: []

                min: 0
                re: !!perl/hash:RE_first 
                  a: 0
                  dba: statement_control__S_039if
                  i: 0
                  min: 0
                  r: 1
                  s: 1
                  zyg: 
                    - !!perl/hash:RE_sequence 
                      a: 0
                      dba: statement_control__S_039if
                      i: 0
                      min: 0
                      r: 1
                      s: 1
                      zyg: 
                        - !!perl/hash:RE_assertion 
                          assert: "!"
                          min: 0
                          re: !!perl/hash:RE_method_re 
                            a: 0
                            dba: statement_control__S_039if
                            i: 0
                            min: 0
                            name: before
                            nobind: 1
                            r: 1
                            re: !!perl/hash:RE 
                              decl: []

                              min: 6
                              re: !!perl/hash:RE_sequence 
                                a: 0
                                dba: statement_control__S_039if
                                i: 0
                                min: 6
                                r: 1
                                s: 1
                                zyg: 
                                  - !!perl/hash:RE_string 
                                    a: 0
                                    dba: statement_control__S_039if
                                    i: 0
                                    min: 4
                                    r: 1
                                    s: 1
                                    text: else
                                  - !!perl/hash:RE_quantified_atom 
                                    atom: !!perl/hash:RE_meta 
                                      a: 0
                                      dba: statement_control__S_039if
                                      i: 0
                                      min: 1
                                      r: 1
                                      s: 1
                                      text: \s
                                    min: 0
                                    quant: 
                                      - "*"
                                      - ":"
                                      - ''
                                      - 0
                                  - !!perl/hash:RE_string 
                                    a: 0
                                    dba: statement_control__S_039if
                                    i: 0
                                    min: 2
                                    r: 1
                                    s: 1
                                    text: if
                            s: 1
                        - !!perl/hash:RE_method 
                          min: 0
                          name: ws
                          nobind: 1
                          noquant: 1
                          rest: ''
                    - !!perl/hash:RE_sequence 
                      a: 0
                      dba: statement_control__S_039if
                      i: 0
                      min: 0
                      r: 1
                      s: 1
                      zyg: 
                        - !!perl/hash:RE_method 
                          min: 0
                          name: panic
                          nobind: 1
                          rest: ("Please use 'elsif'")
                        - !!perl/hash:RE_method 
                          min: 0
                          name: ws
                          nobind: 1
                          noquant: 1
                          rest: ''
              - !!perl/hash:RE_method 
                min: 0
                name: ws
                nobind: 1
                noquant: 1
                rest: ''
              - !!perl/hash:RE_string 
                a: 0
                dba: statement_control__S_039if
                i: 0
                min: 5
                r: 1
                s: 1
                text: elsif
              - !!perl/hash:RE_assertion 
                assert: "?"
                min: 0
                re: !!perl/hash:RE_method 
                  a: 0
                  dba: statement_control__S_039if
                  i: 0
                  min: 12345
                  name: spacey
                  nobind: 1
                  r: 1
                  rest: ''
                  s: 1
              - !!perl/hash:RE_method 
                min: 0
                name: ws
                nobind: 1
                noquant: 1
                rest: ''
              - !!perl/hash:RE_bindnamed 
                a: 0
                atom: !!perl/hash:RE_method 
                  a: 0
                  dba: statement_control__S_039if
                  i: 0
                  min: 12345
                  name: xblock
                  nobind: 1
                  r: 1
                  rest: ''
                  s: 1
                dba: statement_control__S_039if
                i: 0
                min: 12345
                r: 1
                s: 1
                var: elsif
              - !!perl/hash:RE_method 
                min: 0
                name: ws
                nobind: 1
                noquant: 1
                rest: ''
              - !!perl/hash:RE_method_internal 
                args: $S, 'statement_control__S_039if', 'elsif'
                max: 0
                min: 0
                name: _REDUCE
              - !!perl/hash:RE_method 
                min: 0
                name: ws
                nobind: 1
                noquant: 1
                rest: ''
        min: 0
        quant: 
          - "*"
          - ":"
          - ''
          - 0
      - !!perl/hash:RE_method 
        min: 0
        name: ws
        nobind: 1
        noquant: 1
        rest: ''
      - !!perl/hash:RE_quantified_atom 
        atom: !!perl/hash:RE_bracket 
          decl: []

          min: 12349
          re: !!perl/hash:RE_sequence 
            a: 0
            dba: statement_control__S_039if
            i: 0
            min: 12349
            r: 1
            s: 1
            zyg: 
              - !!perl/hash:RE_method 
                min: 0
                name: ws
                nobind: 1
                noquant: 1
                rest: ''
              - !!perl/hash:RE_string 
                a: 0
                dba: statement_control__S_039if
                i: 0
                min: 4
                r: 1
                s: 1
                text: else
              - !!perl/hash:RE_assertion 
                assert: "?"
                min: 0
                re: !!perl/hash:RE_method 
                  a: 0
                  dba: statement_control__S_039if
                  i: 0
                  min: 12345
                  name: spacey
                  nobind: 1
                  r: 1
                  rest: ''
                  s: 1
              - !!perl/hash:RE_method 
                min: 0
                name: ws
                nobind: 1
                noquant: 1
                rest: ''
              - !!perl/hash:RE_bindnamed 
                a: 0
                atom: !!perl/hash:RE_method 
                  a: 0
                  dba: statement_control__S_039if
                  i: 0
                  min: 12345
                  name: pblock
                  nobind: 1
                  r: 1
                  rest: ''
                  s: 1
                dba: statement_control__S_039if
                i: 0
                min: 12345
                r: 1
                s: 1
                var: else
              - !!perl/hash:RE_method 
                min: 0
                name: ws
                nobind: 1
                noquant: 1
                rest: ''
              - !!perl/hash:RE_method_internal 
                args: $S, 'statement_control__S_039if', 'else'
                max: 0
                min: 0
                name: _REDUCE
              - !!perl/hash:RE_method 
                min: 0
                name: ws
                nobind: 1
                noquant: 1
                rest: ''
        min: 0
        quant: 
          - "?"
          - ":"
          - ''
          - 0
      - !!perl/hash:RE_method 
        min: 0
        name: ws
        nobind: 1
        noquant: 1
        rest: ''
statement_control__S_040unless: !!perl/hash:RE 
  decl: []

  kind: token
  min: 37035
  pkg: ~
  re: !!perl/hash:RE_sequence 
    a: 0
    dba: statement_control__S_040unless
    i: 0
    min: 37035
    r: 1
    s: 1
    zyg: 
      - !!perl/hash:RE_method 
        a: 0
        dba: statement_control__S_040unless
        endsym: spacey
        i: 0
        min: 12345
        name: sym
        r: 1
        rest: ''
        s: 0
        sym: unless
      - !!perl/hash:RE_method 
        a: 0
        dba: statement_control__S_040unless
        i: 0
        min: 12345
        name: spacey
        nobind: 1
        r: 1
        rest: ''
        s: 0
      - !!perl/hash:RE_method 
        min: 0
        name: ws
        nobind: 1
        noquant: 1
        rest: ''
      - !!perl/hash:RE_method 
        a: 0
        dba: statement_control__S_040unless
        i: 0
        min: 12345
        name: xblock
        r: 1
        rest: ''
        s: 1
      - !!perl/hash:RE_method 
        min: 0
        name: ws
        nobind: 1
        noquant: 1
        rest: ''
      - !!perl/hash:RE_bracket 
        decl: []

        min: 0
        re: !!perl/hash:RE_first 
          a: 0
          dba: statement_control__S_040unless
          i: 0
          min: 0
          r: 1
          s: 1
          zyg: 
            - !!perl/hash:RE_sequence 
              a: 0
              dba: statement_control__S_040unless
              i: 0
              min: 0
              r: 1
              s: 1
              zyg: 
                - !!perl/hash:RE_assertion 
                  assert: "!"
                  min: 0
                  re: !!perl/hash:RE_method_re 
                    a: 0
                    dba: statement_control__S_040unless
                    i: 0
                    min: 0
                    name: before
                    nobind: 1
                    r: 1
                    re: !!perl/hash:RE 
                      decl: []

                      min: 4
                      re: !!perl/hash:RE_string 
                        a: 0
                        dba: statement_control__S_040unless
                        i: 0
                        min: 4
                        r: 1
                        s: 1
                        text: else
                    s: 1
                - !!perl/hash:RE_method 
                  min: 0
                  name: ws
                  nobind: 1
                  noquant: 1
                  rest: ''
            - !!perl/hash:RE_sequence 
              a: 0
              dba: statement_control__S_040unless
              i: 0
              min: 0
              r: 1
              s: 1
              zyg: 
                - !!perl/hash:RE_method 
                  min: 0
                  name: panic
                  nobind: 1
                  rest: ("unless does not take \"else\" in Perl 6; please rewrite using \"if\"")
                - !!perl/hash:RE_method 
                  min: 0
                  name: ws
                  nobind: 1
                  noquant: 1
                  rest: ''
      - !!perl/hash:RE_method 
        min: 0
        name: ws
        nobind: 1
        noquant: 1
        rest: ''
statement_control__S_041while: !!perl/hash:RE 
  decl: []

  kind: token
  min: 37035
  pkg: ~
  re: !!perl/hash:RE_sequence 
    a: 0
    dba: statement_control__S_041while
    i: 0
    min: 37035
    r: 1
    s: 1
    zyg: 
      - !!perl/hash:RE_method 
        a: 0
        dba: statement_control__S_041while
        endsym: spacey
        i: 0
        min: 12345
        name: sym
        r: 1
        rest: ''
        s: 0
        sym: while
      - !!perl/hash:RE_method 
        a: 0
        dba: statement_control__S_041while
        i: 0
        min: 12345
        name: spacey
        nobind: 1
        r: 1
        rest: ''
        s: 0
      - !!perl/hash:RE_method 
        min: 0
        name: ws
        nobind: 1
        noquant: 1
        rest: ''
      - !!perl/hash:RE_quantified_atom 
        atom: !!perl/hash:RE_bracket 
          decl: []

          min: 0
          re: !!perl/hash:RE_sequence 
            a: 0
            dba: statement_control__S_041while
            i: 0
            min: 0
            r: 1
            s: 1
            zyg: 
              - !!perl/hash:RE_method 
                min: 0
                name: ws
                nobind: 1
                noquant: 1
                rest: ''
              - !!perl/hash:RE_assertion 
                assert: "?"
                min: 0
                re: !!perl/hash:RE_method_re 
                  a: 0
                  dba: statement_control__S_041while
                  i: 0
                  min: 0
                  name: before
                  nobind: 1
                  r: 1
                  re: !!perl/hash:RE 
                    decl: []

                    min: 5
                    re: !!perl/hash:RE_sequence 
                      a: 0
                      dba: statement_control__S_041while
                      i: 0
                      min: 5
                      r: 1
                      s: 1
                      zyg: 
                        - !!perl/hash:RE_string 
                          a: 0
                          dba: statement_control__S_041while
                          i: 0
                          min: 1
                          r: 1
                          s: 1
                          text: (
                        - !!perl/hash:RE_method 
                          min: 0
                          name: ws
                          nobind: 1
                          noquant: 1
                          rest: ''
                        - !!perl/hash:RE_quantified_atom 
                          atom: !!perl/hash:RE_bracket 
                            decl: []

                            min: 3
                            re: !!perl/hash:RE_sequence 
                              a: 0
                              dba: statement_control__S_041while
                              i: 0
                              min: 3
                              r: 1
                              s: 1
                              zyg: 
                                - !!perl/hash:RE_quantified_atom 
                                  atom: !!perl/hash:RE_string 
                                    a: 0
                                    dba: statement_control__S_041while
                                    i: 0
                                    min: 2
                                    r: 1
                                    s: 1
                                    text: my
                                  min: 0
                                  quant: 
                                    - "?"
                                    - ":"
                                    - ''
                                    - 0
                                - !!perl/hash:RE_method 
                                  min: 0
                                  name: ws
                                  nobind: 1
                                  noquant: 1
                                  rest: ''
                                - !!perl/hash:RE_string 
                                  a: 0
                                  dba: statement_control__S_041while
                                  i: 0
                                  min: 1
                                  r: 1
                                  s: 1
                                  text: $
                                - !!perl/hash:RE_quantified_atom 
                                  atom: !!perl/hash:RE_meta 
                                    a: 0
                                    dba: statement_control__S_041while
                                    i: 0
                                    min: 1
                                    r: 1
                                    s: 1
                                    text: \w
                                  min: 1
                                  quant: 
                                    - +
                                    - ":"
                                    - ''
                                    - 1
                                - !!perl/hash:RE_method 
                                  min: 0
                                  name: ws
                                  nobind: 1
                                  noquant: 1
                                  rest: ''
                                - !!perl/hash:RE_string 
                                  a: 0
                                  dba: statement_control__S_041while
                                  i: 0
                                  min: 1
                                  r: 1
                                  s: 1
                                  text: =
                          min: 0
                          quant: 
                            - "?"
                            - ":"
                            - ''
                            - 0
                        - !!perl/hash:RE_method 
                          min: 0
                          name: ws
                          nobind: 1
                          noquant: 1
                          rest: ''
                        - !!perl/hash:RE_string 
                          a: 0
                          dba: statement_control__S_041while
                          i: 0
                          min: 1
                          r: 1
                          s: 1
                          text: <
                        - !!perl/hash:RE_method 
                          min: 0
                          name: ws
                          nobind: 1
                          noquant: 1
                          rest: ''
                        - !!perl/hash:RE_quantified_atom 
                          atom: !!perl/hash:RE_string 
                            a: 0
                            dba: statement_control__S_041while
                            i: 0
                            min: 1
                            r: 1
                            s: 1
                            text: $
                          min: 0
                          quant: 
                            - "?"
                            - ":"
                            - ''
                            - 0
                        - !!perl/hash:RE_quantified_atom 
                          atom: !!perl/hash:RE_meta 
                            a: 0
                            dba: statement_control__S_041while
                            i: 0
                            min: 1
                            r: 1
                            s: 1
                            text: \w
                          min: 1
                          quant: 
                            - +
                            - ":"
                            - ''
                            - 1
                        - !!perl/hash:RE_method 
                          min: 0
                          name: ws
                          nobind: 1
                          noquant: 1
                          rest: ''
                        - !!perl/hash:RE_string 
                          a: 0
                          dba: statement_control__S_041while
                          i: 0
                          min: 1
                          r: 1
                          s: 1
                          text: ">"
                        - !!perl/hash:RE_method 
                          min: 0
                          name: ws
                          nobind: 1
                          noquant: 1
                          rest: ''
                        - !!perl/hash:RE_string 
                          a: 0
                          dba: statement_control__S_041while
                          i: 0
                          min: 1
                          r: 1
                          s: 1
                          text: )
                  s: 1
              - !!perl/hash:RE_method 
                min: 0
                name: ws
                nobind: 1
                noquant: 1
                rest: ''
              - !!perl/hash:RE_method 
                min: 0
                name: panic
                nobind: 1
                rest: ("This appears to be Perl 5 code")
              - !!perl/hash:RE_method 
                min: 0
                name: ws
                nobind: 1
                noquant: 1
                rest: ''
        min: 0
        quant: 
          - "?"
          - ":"
          - ''
          - 0
      - !!perl/hash:RE_method 
        min: 0
        name: ws
        nobind: 1
        noquant: 1
        rest: ''
      - !!perl/hash:RE_method 
        a: 0
        dba: statement_control__S_041while
        i: 0
        min: 12345
        name: xblock
        r: 1
        rest: ''
        s: 1
      - !!perl/hash:RE_method 
        min: 0
        name: ws
        nobind: 1
        noquant: 1
        rest: ''
statement_control__S_042until: !!perl/hash:RE 
  decl: []

  kind: token
  min: 37035
  pkg: ~
  re: !!perl/hash:RE_sequence 
    a: 0
    dba: statement_control__S_042until
    i: 0
    min: 37035
    r: 1
    s: 1
    zyg: 
      - !!perl/hash:RE_method 
        a: 0
        dba: statement_control__S_042until
        endsym: spacey
        i: 0
        min: 12345
        name: sym
        r: 1
        rest: ''
        s: 0
        sym: until
      - !!perl/hash:RE_method 
        a: 0
        dba: statement_control__S_042until
        i: 0
        min: 12345
        name: spacey
        nobind: 1
        r: 1
        rest: ''
        s: 0
      - !!perl/hash:RE_method 
        min: 0
        name: ws
        nobind: 1
        noquant: 1
        rest: ''
      - !!perl/hash:RE_method 
        a: 0
        dba: statement_control__S_042until
        i: 0
        min: 12345
        name: xblock
        r: 1
        rest: ''
        s: 1
      - !!perl/hash:RE_method 
        min: 0
        name: ws
        nobind: 1
        noquant: 1
        rest: ''
statement_control__S_043repeat: !!perl/hash:RE 
  decl: []

  kind: token
  min: 37040
  pkg: ~
  re: !!perl/hash:RE_sequence 
    a: 0
    dba: statement_control__S_043repeat
    i: 0
    min: 37040
    r: 1
    s: 1
    zyg: 
      - !!perl/hash:RE_method 
        a: 0
        dba: statement_control__S_043repeat
        endsym: spacey
        i: 0
        min: 12345
        name: sym
        r: 1
        rest: ''
        s: 0
        sym: repeat
      - !!perl/hash:RE_method 
        a: 0
        dba: statement_control__S_043repeat
        i: 0
        min: 12345
        name: spacey
        nobind: 1
        r: 1
        rest: ''
        s: 0
      - !!perl/hash:RE_method 
        min: 0
        name: ws
        nobind: 1
        noquant: 1
        rest: ''
      - !!perl/hash:RE_bracket 
        decl: []

        min: 12350
        re: &117 !!perl/hash:RE_any 
          a: 0
          altname: statement_control__S_043repeat_01
          dba: statement_control__S_043repeat
          i: 0
          min: 12350
          name: statement_control__S_043repeat_01
          r: 1
          s: 1
          zyg: 
            - !!perl/hash:RE_sequence 
              a: 0
              alt: statement_control__S_043repeat_01 0
              dba: statement_control__S_043repeat
              i: 0
              min: 12350
              r: 1
              s: 1
              zyg: 
                - !!perl/hash:RE_bindpos 
                  atom: !!perl/hash:RE_paren 
                    decl: []

                    min: 5
                    re: &6 !!perl/hash:RE_any 
                      a: 0
                      altname: statement_control__S_043repeat_02
                      dba: statement_control__S_043repeat
                      i: 0
                      min: 5
                      name: statement_control__S_043repeat_02
                      r: 1
                      s: 1
                      zyg: 
                        - !!perl/hash:RE_string 
                          a: 0
                          alt: statement_control__S_043repeat_02 0
                          dba: statement_control__S_043repeat
                          i: 0
                          min: 5
                          r: 1
                          s: 1
                          text: while
                        - !!perl/hash:RE_string 
                          a: 0
                          alt: statement_control__S_043repeat_02 1
                          dba: statement_control__S_043repeat
                          i: 0
                          min: 5
                          r: 1
                          s: 1
                          text: until
                  min: 5
                  var: 0
                - !!perl/hash:RE_method 
                  min: 0
                  name: ws
                  nobind: 1
                  noquant: 1
                  rest: ''
                - !!perl/hash:RE_method 
                  a: 0
                  dba: statement_control__S_043repeat
                  i: 0
                  min: 12345
                  name: xblock
                  r: 1
                  rest: ''
                  s: 1
                - !!perl/hash:RE_method 
                  min: 0
                  name: ws
                  nobind: 1
                  noquant: 1
                  rest: ''
            - !!perl/hash:RE_sequence 
              a: 0
              alt: statement_control__S_043repeat_01 1
              dba: statement_control__S_043repeat
              i: 0
              min: 24695
              r: 1
              s: 1
              zyg: 
                - !!perl/hash:RE_method 
                  a: 0
                  dba: statement_control__S_043repeat
                  i: 0
                  min: 12345
                  name: block
                  r: 1
                  rest: ''
                  s: 1
                - !!perl/hash:RE_method 
                  min: 0
                  name: ws
                  nobind: 1
                  noquant: 1
                  rest: ''
                - !!perl/hash:RE_method_internal 
                  args: $S, 'statement_control__S_043repeat', 'block wu'
                  max: 0
                  min: 0
                  name: _REDUCE
                - !!perl/hash:RE_method 
                  min: 0
                  name: ws
                  nobind: 1
                  noquant: 1
                  rest: ''
                - !!perl/hash:RE_bindpos 
                  atom: !!perl/hash:RE_paren 
                    decl: []

                    min: 5
                    re: &130 !!perl/hash:RE_any 
                      a: 0
                      altname: statement_control__S_043repeat_03
                      dba: statement_control__S_043repeat
                      i: 0
                      min: 5
                      name: statement_control__S_043repeat_03
                      r: 1
                      s: 1
                      zyg: 
                        - !!perl/hash:RE_string 
                          a: 0
                          alt: statement_control__S_043repeat_03 0
                          dba: statement_control__S_043repeat
                          i: 0
                          min: 5
                          r: 1
                          s: 1
                          text: while
                        - !!perl/hash:RE_string 
                          a: 0
                          alt: statement_control__S_043repeat_03 1
                          dba: statement_control__S_043repeat
                          i: 0
                          min: 5
                          r: 1
                          s: 1
                          text: until
                  min: 5
                  var: 1
                - !!perl/hash:RE_method 
                  min: 0
                  name: ws
                  nobind: 1
                  noquant: 1
                  rest: ''
                - !!perl/hash:RE_method 
                  a: 0
                  dba: statement_control__S_043repeat
                  i: 0
                  min: 12345
                  name: EXPR
                  r: 1
                  rest: ''
                  s: 1
                - !!perl/hash:RE_method 
                  min: 0
                  name: ws
                  nobind: 1
                  noquant: 1
                  rest: ''
                - !!perl/hash:RE_method_internal 
                  args: $S, 'statement_control__S_043repeat', 'expr wu'
                  max: 0
                  min: 0
                  name: _REDUCE
                - !!perl/hash:RE_method 
                  min: 0
                  name: ws
                  nobind: 1
                  noquant: 1
                  rest: ''
      - !!perl/hash:RE_method 
        min: 0
        name: ws
        nobind: 1
        noquant: 1
        rest: ''
statement_control__S_043repeat_01: *117
statement_control__S_043repeat_02: *6
statement_control__S_043repeat_03: *130
statement_control__S_044loop: !!perl/hash:RE 
  decl: []

  kind: token
  min: 37035
  pkg: ~
  re: !!perl/hash:RE_sequence 
    a: 0
    dba: statement_control__S_044loop
    i: 0
    min: 37035
    r: 1
    s: 1
    zyg: 
      - !!perl/hash:RE_method 
        a: 0
        dba: statement_control__S_044loop
        endsym: spacey
        i: 0
        min: 12345
        name: sym
        r: 1
        rest: ''
        s: 0
        sym: loop
      - !!perl/hash:RE_method 
        a: 0
        dba: statement_control__S_044loop
        i: 0
        min: 12345
        name: spacey
        nobind: 1
        r: 1
        rest: ''
        s: 0
      - !!perl/hash:RE_method 
        min: 0
        name: ws
        nobind: 1
        noquant: 1
        rest: ''
      - !!perl/hash:RE_bindnamed 
        a: 0
        atom: !!perl/hash:RE_quantified_atom 
          atom: !!perl/hash:RE_paren 
            decl: []

            min: 4
            re: !!perl/hash:RE_sequence 
              a: 0
              dba: statement_control__S_044loop
              i: 0
              min: 4
              r: 1
              s: 1
              zyg: 
                - !!perl/hash:RE_method 
                  min: 0
                  name: ws
                  nobind: 1
                  noquant: 1
                  rest: ''
                - !!perl/hash:RE_string 
                  a: 0
                  dba: statement_control__S_044loop
                  i: 0
                  min: 1
                  r: 1
                  s: 1
                  text: (
                - !!perl/hash:RE_method 
                  min: 0
                  name: ws
                  nobind: 1
                  noquant: 1
                  rest: ''
                - !!perl/hash:RE_bindnamed 
                  a: 0
                  atom: !!perl/hash:RE_quantified_atom 
                    atom: !!perl/hash:RE_method 
                      a: 0
                      dba: statement_control__S_044loop
                      i: 0
                      min: 12345
                      name: EXPR
                      r: 1
                      rest: ''
                      s: 1
                    min: 0
                    nobind: 1
                    quant: 
                      - "?"
                      - ":"
                      - ''
                      - 0
                  dba: statement_control__S_044loop
                  i: 0
                  min: 0
                  r: 1
                  s: 1
                  var: e1
                - !!perl/hash:RE_method 
                  min: 0
                  name: ws
                  nobind: 1
                  noquant: 1
                  rest: ''
                - !!perl/hash:RE_string 
                  a: 0
                  dba: statement_control__S_044loop
                  i: 0
                  min: 1
                  r: 1
                  s: 1
                  text: ;
                - !!perl/hash:RE_method 
                  min: 0
                  name: ws
                  nobind: 1
                  noquant: 1
                  rest: ''
                - !!perl/hash:RE_method_internal 
                  args: $S, 'statement_control__S_044loop', 'e1'
                  max: 0
                  min: 0
                  name: _REDUCE
                - !!perl/hash:RE_method 
                  min: 0
                  name: ws
                  nobind: 1
                  noquant: 1
                  rest: ''
                - !!perl/hash:RE_bindnamed 
                  a: 0
                  atom: !!perl/hash:RE_quantified_atom 
                    atom: !!perl/hash:RE_method 
                      a: 0
                      dba: statement_control__S_044loop
                      i: 0
                      min: 12345
                      name: EXPR
                      r: 1
                      rest: ''
                      s: 1
                    min: 0
                    nobind: 1
                    quant: 
                      - "?"
                      - ":"
                      - ''
                      - 0
                  dba: statement_control__S_044loop
                  i: 0
                  min: 0
                  r: 1
                  s: 1
                  var: e2
                - !!perl/hash:RE_method 
                  min: 0
                  name: ws
                  nobind: 1
                  noquant: 1
                  rest: ''
                - !!perl/hash:RE_string 
                  a: 0
                  dba: statement_control__S_044loop
                  i: 0
                  min: 1
                  r: 1
                  s: 1
                  text: ;
                - !!perl/hash:RE_method 
                  min: 0
                  name: ws
                  nobind: 1
                  noquant: 1
                  rest: ''
                - !!perl/hash:RE_method_internal 
                  args: $S, 'statement_control__S_044loop', 'e2'
                  max: 0
                  min: 0
                  name: _REDUCE
                - !!perl/hash:RE_method 
                  min: 0
                  name: ws
                  nobind: 1
                  noquant: 1
                  rest: ''
                - !!perl/hash:RE_bindnamed 
                  a: 0
                  atom: !!perl/hash:RE_quantified_atom 
                    atom: !!perl/hash:RE_method 
                      a: 0
                      dba: statement_control__S_044loop
                      i: 0
                      min: 12345
                      name: EXPR
                      r: 1
                      rest: ''
                      s: 1
                    min: 0
                    nobind: 1
                    quant: 
                      - "?"
                      - ":"
                      - ''
                      - 0
                  dba: statement_control__S_044loop
                  i: 0
                  min: 0
                  r: 1
                  s: 1
                  var: e3
                - !!perl/hash:RE_method 
                  min: 0
                  name: ws
                  nobind: 1
                  noquant: 1
                  rest: ''
                - !!perl/hash:RE_method_internal 
                  args: $S, 'statement_control__S_044loop', 'e3'
                  max: 0
                  min: 0
                  name: _REDUCE
                - !!perl/hash:RE_method 
                  min: 0
                  name: ws
                  nobind: 1
                  noquant: 1
                  rest: ''
                - !!perl/hash:RE_string 
                  a: 0
                  dba: statement_control__S_044loop
                  i: 0
                  min: 1
                  r: 1
                  s: 1
                  text: )
                - !!perl/hash:RE_method 
                  min: 0
                  name: ws
                  nobind: 1
                  noquant: 1
                  rest: ''
                - !!perl/hash:RE_method_internal 
                  args: $S, 'statement_control__S_044loop', 'eee'
                  max: 0
                  min: 0
                  name: _REDUCE
                - !!perl/hash:RE_method 
                  min: 0
                  name: ws
                  nobind: 1
                  noquant: 1
                  rest: ''
          min: 0
          nobind: 1
          quant: 
            - "?"
            - ":"
            - ''
            - 0
        dba: statement_control__S_044loop
        i: 0
        min: 0
        r: 1
        s: 1
        var: eee
      - !!perl/hash:RE_method 
        min: 0
        name: ws
        nobind: 1
        noquant: 1
        rest: ''
      - !!perl/hash:RE_method 
        a: 0
        dba: statement_control__S_044loop
        i: 0
        min: 12345
        name: block
        r: 1
        rest: ''
        s: 1
      - !!perl/hash:RE_method 
        min: 0
        name: ws
        nobind: 1
        noquant: 1
        rest: ''
      - !!perl/hash:RE_method_internal 
        args: $S, 'statement_control__S_044loop', 'block'
        max: 0
        min: 0
        name: _REDUCE
      - !!perl/hash:RE_method 
        min: 0
        name: ws
        nobind: 1
        noquant: 1
        rest: ''
statement_control__S_045for: !!perl/hash:RE 
  decl: []

  kind: token
  min: 37035
  pkg: ~
  re: !!perl/hash:RE_sequence 
    a: 0
    dba: statement_control__S_045for
    i: 0
    min: 37035
    r: 1
    s: 1
    zyg: 
      - !!perl/hash:RE_method 
        a: 0
        dba: statement_control__S_045for
        endsym: spacey
        i: 0
        min: 12345
        name: sym
        r: 1
        rest: ''
        s: 0
        sym: for
      - !!perl/hash:RE_method 
        a: 0
        dba: statement_control__S_045for
        i: 0
        min: 12345
        name: spacey
        nobind: 1
        r: 1
        rest: ''
        s: 0
      - !!perl/hash:RE_method 
        min: 0
        name: ws
        nobind: 1
        noquant: 1
        rest: ''
      - !!perl/hash:RE_quantified_atom 
        atom: !!perl/hash:RE_bracket 
          decl: []

          min: 0
          re: !!perl/hash:RE_sequence 
            a: 0
            dba: statement_control__S_045for
            i: 0
            min: 0
            r: 1
            s: 1
            zyg: 
              - !!perl/hash:RE_method 
                min: 0
                name: ws
                nobind: 1
                noquant: 1
                rest: ''
              - !!perl/hash:RE_assertion 
                assert: "?"
                min: 0
                re: !!perl/hash:RE_method_re 
                  a: 0
                  dba: statement_control__S_045for
                  i: 0
                  min: 0
                  name: before
                  nobind: 1
                  r: 1
                  re: !!perl/hash:RE 
                    decl: []

                    min: 3
                    re: !!perl/hash:RE_sequence 
                      a: 0
                      dba: statement_control__S_045for
                      i: 0
                      min: 3
                      r: 1
                      s: 1
                      zyg: 
                        - !!perl/hash:RE_quantified_atom 
                          atom: !!perl/hash:RE_string 
                            a: 0
                            dba: statement_control__S_045for
                            i: 0
                            min: 2
                            r: 1
                            s: 1
                            text: my
                          min: 0
                          quant: 
                            - "?"
                            - ":"
                            - ''
                            - 0
                        - !!perl/hash:RE_method 
                          min: 0
                          name: ws
                          nobind: 1
                          noquant: 1
                          rest: ''
                        - !!perl/hash:RE_string 
                          a: 0
                          dba: statement_control__S_045for
                          i: 0
                          min: 1
                          r: 1
                          s: 1
                          text: $
                        - !!perl/hash:RE_quantified_atom 
                          atom: !!perl/hash:RE_meta 
                            a: 0
                            dba: statement_control__S_045for
                            i: 0
                            min: 1
                            r: 1
                            s: 1
                            text: \w
                          min: 1
                          quant: 
                            - +
                            - ":"
                            - ''
                            - 1
                        - !!perl/hash:RE_method 
                          min: 0
                          name: ws
                          nobind: 1
                          noquant: 1
                          rest: ''
                        - !!perl/hash:RE_string 
                          a: 0
                          dba: statement_control__S_045for
                          i: 0
                          min: 1
                          r: 1
                          s: 1
                          text: (
                        - !!perl/hash:RE_method 
                          min: 0
                          name: ws
                          nobind: 1
                          noquant: 1
                          rest: ''
                  s: 1
              - !!perl/hash:RE_method 
                min: 0
                name: ws
                nobind: 1
                noquant: 1
                rest: ''
              - !!perl/hash:RE_method 
                min: 0
                name: panic
                nobind: 1
                rest: ("This appears to be Perl 5 code")
              - !!perl/hash:RE_method 
                min: 0
                name: ws
                nobind: 1
                noquant: 1
                rest: ''
        min: 0
        quant: 
          - "?"
          - ":"
          - ''
          - 0
      - !!perl/hash:RE_method 
        min: 0
        name: ws
        nobind: 1
        noquant: 1
        rest: ''
      - !!perl/hash:RE_quantified_atom 
        atom: !!perl/hash:RE_bracket 
          decl: []

          min: 0
          re: !!perl/hash:RE_sequence 
            a: 0
            dba: statement_control__S_045for
            i: 0
            min: 0
            r: 1
            s: 1
            zyg: 
              - !!perl/hash:RE_method 
                min: 0
                name: ws
                nobind: 1
                noquant: 1
                rest: ''
              - !!perl/hash:RE_assertion 
                assert: "?"
                min: 0
                re: !!perl/hash:RE_method_re 
                  a: 0
                  dba: statement_control__S_045for
                  i: 0
                  min: 0
                  name: before
                  nobind: 1
                  r: 1
                  re: !!perl/hash:RE 
                    decl: []

                    min: 4
                    re: !!perl/hash:RE_sequence 
                      a: 0
                      dba: statement_control__S_045for
                      i: 0
                      min: 4
                      r: 1
                      s: 1
                      zyg: 
                        - !!perl/hash:RE_string 
                          a: 0
                          dba: statement_control__S_045for
                          i: 0
                          min: 1
                          r: 1
                          s: 1
                          text: (
                        - !!perl/hash:RE_method 
                          min: 0
                          name: ws
                          nobind: 1
                          noquant: 1
                          rest: ''
                        - !!perl/hash:RE_quantified_atom 
                          atom: !!perl/hash:RE_method 
                            a: 0
                            dba: statement_control__S_045for
                            i: 0
                            min: 12345
                            name: EXPR
                            nobind: 1
                            r: 1
                            rest: ''
                            s: 1
                          min: 0
                          quant: 
                            - "?"
                            - ":"
                            - ''
                            - 0
                        - !!perl/hash:RE_method 
                          min: 0
                          name: ws
                          nobind: 1
                          noquant: 1
                          rest: ''
                        - !!perl/hash:RE_string 
                          a: 0
                          dba: statement_control__S_045for
                          i: 0
                          min: 1
                          r: 1
                          s: 1
                          text: ;
                        - !!perl/hash:RE_method 
                          min: 0
                          name: ws
                          nobind: 1
                          noquant: 1
                          rest: ''
                        - !!perl/hash:RE_quantified_atom 
                          atom: !!perl/hash:RE_method 
                            a: 0
                            dba: statement_control__S_045for
                            i: 0
                            min: 12345
                            name: EXPR
                            nobind: 1
                            r: 1
                            rest: ''
                            s: 1
                          min: 0
                          quant: 
                            - "?"
                            - ":"
                            - ''
                            - 0
                        - !!perl/hash:RE_method 
                          min: 0
                          name: ws
                          nobind: 1
                          noquant: 1
                          rest: ''
                        - !!perl/hash:RE_string 
                          a: 0
                          dba: statement_control__S_045for
                          i: 0
                          min: 1
                          r: 1
                          s: 1
                          text: ;
                        - !!perl/hash:RE_method 
                          min: 0
                          name: ws
                          nobind: 1
                          noquant: 1
                          rest: ''
                        - !!perl/hash:RE_quantified_atom 
                          atom: !!perl/hash:RE_method 
                            a: 0
                            dba: statement_control__S_045for
                            i: 0
                            min: 12345
                            name: EXPR
                            nobind: 1
                            r: 1
                            rest: ''
                            s: 1
                          min: 0
                          quant: 
                            - "?"
                            - ":"
                            - ''
                            - 0
                        - !!perl/hash:RE_method 
                          min: 0
                          name: ws
                          nobind: 1
                          noquant: 1
                          rest: ''
                        - !!perl/hash:RE_string 
                          a: 0
                          dba: statement_control__S_045for
                          i: 0
                          min: 1
                          r: 1
                          s: 1
                          text: )
                        - !!perl/hash:RE_method 
                          min: 0
                          name: ws
                          nobind: 1
                          noquant: 1
                          rest: ''
                  s: 1
              - !!perl/hash:RE_method 
                min: 0
                name: ws
                nobind: 1
                noquant: 1
                rest: ''
              - !!perl/hash:RE_method 
                min: 0
                name: obs
                nobind: 1
                rest: ('C-style "for (;;)" loop', '"loop (;;)"')
              - !!perl/hash:RE_method 
                min: 0
                name: ws
                nobind: 1
                noquant: 1
                rest: ''
        min: 0
        quant: 
          - "?"
          - ":"
          - ''
          - 0
      - !!perl/hash:RE_method 
        min: 0
        name: ws
        nobind: 1
        noquant: 1
        rest: ''
      - !!perl/hash:RE_method 
        a: 0
        dba: statement_control__S_045for
        i: 0
        min: 12345
        name: xblock
        r: 1
        rest: ''
        s: 1
      - !!perl/hash:RE_method 
        min: 0
        name: ws
        nobind: 1
        noquant: 1
        rest: ''
statement_control__S_046given: !!perl/hash:RE 
  decl: []

  kind: token
  min: 37035
  pkg: ~
  re: !!perl/hash:RE_sequence 
    a: 0
    dba: statement_control__S_046given
    i: 0
    min: 37035
    r: 1
    s: 1
    zyg: 
      - !!perl/hash:RE_method 
        a: 0
        dba: statement_control__S_046given
        endsym: spacey
        i: 0
        min: 12345
        name: sym
        r: 1
        rest: ''
        s: 0
        sym: given
      - !!perl/hash:RE_method 
        a: 0
        dba: statement_control__S_046given
        i: 0
        min: 12345
        name: spacey
        nobind: 1
        r: 1
        rest: ''
        s: 0
      - !!perl/hash:RE_method 
        min: 0
        name: ws
        nobind: 1
        noquant: 1
        rest: ''
      - !!perl/hash:RE_method 
        a: 0
        dba: statement_control__S_046given
        i: 0
        min: 12345
        name: xblock
        r: 1
        rest: ''
        s: 1
      - !!perl/hash:RE_method 
        min: 0
        name: ws
        nobind: 1
        noquant: 1
        rest: ''
statement_control__S_047when: !!perl/hash:RE 
  decl: []

  kind: token
  min: 37035
  pkg: ~
  re: !!perl/hash:RE_sequence 
    a: 0
    dba: statement_control__S_047when
    i: 0
    min: 37035
    r: 1
    s: 1
    zyg: 
      - !!perl/hash:RE_method 
        a: 0
        dba: statement_control__S_047when
        endsym: spacey
        i: 0
        min: 12345
        name: sym
        r: 1
        rest: ''
        s: 0
        sym: when
      - !!perl/hash:RE_method 
        a: 0
        dba: statement_control__S_047when
        i: 0
        min: 12345
        name: spacey
        nobind: 1
        r: 1
        rest: ''
        s: 0
      - !!perl/hash:RE_method 
        min: 0
        name: ws
        nobind: 1
        noquant: 1
        rest: ''
      - !!perl/hash:RE_method 
        a: 0
        dba: statement_control__S_047when
        i: 0
        min: 12345
        name: xblock
        r: 1
        rest: ''
        s: 1
      - !!perl/hash:RE_method 
        min: 0
        name: ws
        nobind: 1
        noquant: 1
        rest: ''
statement_control__S_048default: !!perl/hash:RE 
  decl: []

  kind: rule
  min: 37035
  pkg: ~
  re: !!perl/hash:RE_sequence 
    a: 0
    dba: statement_control__S_048default
    i: 0
    min: 37035
    r: 1
    s: 1
    zyg: 
      - !!perl/hash:RE_method 
        a: 0
        dba: statement_control__S_048default
        endsym: spacey
        i: 0
        min: 12345
        name: sym
        r: 1
        rest: ''
        s: 1
        sym: default
      - !!perl/hash:RE_method 
        a: 0
        dba: statement_control__S_048default
        i: 0
        min: 12345
        name: spacey
        nobind: 1
        r: 1
        rest: ''
        s: 1
      - !!perl/hash:RE_method 
        min: 0
        name: ws
        nobind: 1
        noquant: 1
        rest: ''
      - !!perl/hash:RE_method 
        a: 0
        dba: statement_control__S_048default
        i: 0
        min: 12345
        name: block
        r: 1
        rest: ''
        s: 1
      - !!perl/hash:RE_method 
        min: 0
        name: ws
        nobind: 1
        noquant: 1
        rest: ''
statement_control__S_055END: !!perl/hash:RE 
  decl: []

  kind: rule
  min: 37035
  pkg: ~
  re: !!perl/hash:RE_sequence 
    a: 0
    dba: statement_control__S_055END
    i: 0
    min: 37035
    r: 1
    s: 1
    zyg: 
      - !!perl/hash:RE_method 
        a: 0
        dba: statement_control__S_055END
        endsym: spacey
        i: 0
        min: 12345
        name: sym
        r: 1
        rest: ''
        s: 1
        sym: END
      - !!perl/hash:RE_method 
        a: 0
        dba: statement_control__S_055END
        i: 0
        min: 12345
        name: spacey
        nobind: 1
        r: 1
        rest: ''
        s: 1
      - !!perl/hash:RE_method 
        min: 0
        name: ws
        nobind: 1
        noquant: 1
        rest: ''
      - !!perl/hash:RE_method 
        a: 0
        dba: statement_control__S_055END
        i: 0
        min: 12345
        name: block
        r: 1
        rest: ''
        s: 1
      - !!perl/hash:RE_method 
        min: 0
        name: ws
        nobind: 1
        noquant: 1
        rest: ''
statement_control__S_056LEAVE: !!perl/hash:RE 
  decl: []

  kind: rule
  min: 37035
  pkg: ~
  re: !!perl/hash:RE_sequence 
    a: 0
    dba: statement_control__S_056LEAVE
    i: 0
    min: 37035
    r: 1
    s: 1
    zyg: 
      - !!perl/hash:RE_method 
        a: 0
        dba: statement_control__S_056LEAVE
        endsym: spacey
        i: 0
        min: 12345
        name: sym
        r: 1
        rest: ''
        s: 1
        sym: LEAVE
      - !!perl/hash:RE_method 
        a: 0
        dba: statement_control__S_056LEAVE
        i: 0
        min: 12345
        name: spacey
        nobind: 1
        r: 1
        rest: ''
        s: 1
      - !!perl/hash:RE_method 
        min: 0
        name: ws
        nobind: 1
        noquant: 1
        rest: ''
      - !!perl/hash:RE_method 
        a: 0
        dba: statement_control__S_056LEAVE
        i: 0
        min: 12345
        name: block
        r: 1
        rest: ''
        s: 1
      - !!perl/hash:RE_method 
        min: 0
        name: ws
        nobind: 1
        noquant: 1
        rest: ''
statement_control__S_057KEEP: !!perl/hash:RE 
  decl: []

  kind: rule
  min: 37035
  pkg: ~
  re: !!perl/hash:RE_sequence 
    a: 0
    dba: statement_control__S_057KEEP
    i: 0
    min: 37035
    r: 1
    s: 1
    zyg: 
      - !!perl/hash:RE_method 
        a: 0
        dba: statement_control__S_057KEEP
        endsym: spacey
        i: 0
        min: 12345
        name: sym
        r: 1
        rest: ''
        s: 1
        sym: KEEP
      - !!perl/hash:RE_method 
        a: 0
        dba: statement_control__S_057KEEP
        i: 0
        min: 12345
        name: spacey
        nobind: 1
        r: 1
        rest: ''
        s: 1
      - !!perl/hash:RE_method 
        min: 0
        name: ws
        nobind: 1
        noquant: 1
        rest: ''
      - !!perl/hash:RE_method 
        a: 0
        dba: statement_control__S_057KEEP
        i: 0
        min: 12345
        name: block
        r: 1
        rest: ''
        s: 1
      - !!perl/hash:RE_method 
        min: 0
        name: ws
        nobind: 1
        noquant: 1
        rest: ''
statement_control__S_058UNDO: !!perl/hash:RE 
  decl: []

  kind: rule
  min: 37035
  pkg: ~
  re: !!perl/hash:RE_sequence 
    a: 0
    dba: statement_control__S_058UNDO
    i: 0
    min: 37035
    r: 1
    s: 1
    zyg: 
      - !!perl/hash:RE_method 
        a: 0
        dba: statement_control__S_058UNDO
        endsym: spacey
        i: 0
        min: 12345
        name: sym
        r: 1
        rest: ''
        s: 1
        sym: UNDO
      - !!perl/hash:RE_method 
        a: 0
        dba: statement_control__S_058UNDO
        i: 0
        min: 12345
        name: spacey
        nobind: 1
        r: 1
        rest: ''
        s: 1
      - !!perl/hash:RE_method 
        min: 0
        name: ws
        nobind: 1
        noquant: 1
        rest: ''
      - !!perl/hash:RE_method 
        a: 0
        dba: statement_control__S_058UNDO
        i: 0
        min: 12345
        name: block
        r: 1
        rest: ''
        s: 1
      - !!perl/hash:RE_method 
        min: 0
        name: ws
        nobind: 1
        noquant: 1
        rest: ''
statement_control__S_059NEXT: !!perl/hash:RE 
  decl: []

  kind: rule
  min: 37035
  pkg: ~
  re: !!perl/hash:RE_sequence 
    a: 0
    dba: statement_control__S_059NEXT
    i: 0
    min: 37035
    r: 1
    s: 1
    zyg: 
      - !!perl/hash:RE_method 
        a: 0
        dba: statement_control__S_059NEXT
        endsym: spacey
        i: 0
        min: 12345
        name: sym
        r: 1
        rest: ''
        s: 1
        sym: NEXT
      - !!perl/hash:RE_method 
        a: 0
        dba: statement_control__S_059NEXT
        i: 0
        min: 12345
        name: spacey
        nobind: 1
        r: 1
        rest: ''
        s: 1
      - !!perl/hash:RE_method 
        min: 0
        name: ws
        nobind: 1
        noquant: 1
        rest: ''
      - !!perl/hash:RE_method 
        a: 0
        dba: statement_control__S_059NEXT
        i: 0
        min: 12345
        name: block
        r: 1
        rest: ''
        s: 1
      - !!perl/hash:RE_method 
        min: 0
        name: ws
        nobind: 1
        noquant: 1
        rest: ''
statement_control__S_060LAST: !!perl/hash:RE 
  decl: []

  kind: rule
  min: 37035
  pkg: ~
  re: !!perl/hash:RE_sequence 
    a: 0
    dba: statement_control__S_060LAST
    i: 0
    min: 37035
    r: 1
    s: 1
    zyg: 
      - !!perl/hash:RE_method 
        a: 0
        dba: statement_control__S_060LAST
        endsym: spacey
        i: 0
        min: 12345
        name: sym
        r: 1
        rest: ''
        s: 1
        sym: LAST
      - !!perl/hash:RE_method 
        a: 0
        dba: statement_control__S_060LAST
        i: 0
        min: 12345
        name: spacey
        nobind: 1
        r: 1
        rest: ''
        s: 1
      - !!perl/hash:RE_method 
        min: 0
        name: ws
        nobind: 1
        noquant: 1
        rest: ''
      - !!perl/hash:RE_method 
        a: 0
        dba: statement_control__S_060LAST
        i: 0
        min: 12345
        name: block
        r: 1
        rest: ''
        s: 1
      - !!perl/hash:RE_method 
        min: 0
        name: ws
        nobind: 1
        noquant: 1
        rest: ''
statement_control__S_061PRE: !!perl/hash:RE 
  decl: []

  kind: rule
  min: 37035
  pkg: ~
  re: !!perl/hash:RE_sequence 
    a: 0
    dba: statement_control__S_061PRE
    i: 0
    min: 37035
    r: 1
    s: 1
    zyg: 
      - !!perl/hash:RE_method 
        a: 0
        dba: statement_control__S_061PRE
        endsym: spacey
        i: 0
        min: 12345
        name: sym
        r: 1
        rest: ''
        s: 1
        sym: PRE
      - !!perl/hash:RE_method 
        a: 0
        dba: statement_control__S_061PRE
        i: 0
        min: 12345
        name: spacey
        nobind: 1
        r: 1
        rest: ''
        s: 1
      - !!perl/hash:RE_method 
        min: 0
        name: ws
        nobind: 1
        noquant: 1
        rest: ''
      - !!perl/hash:RE_method 
        a: 0
        dba: statement_control__S_061PRE
        i: 0
        min: 12345
        name: block
        r: 1
        rest: ''
        s: 1
      - !!perl/hash:RE_method 
        min: 0
        name: ws
        nobind: 1
        noquant: 1
        rest: ''
statement_control__S_062POST: !!perl/hash:RE 
  decl: []

  kind: rule
  min: 37035
  pkg: ~
  re: !!perl/hash:RE_sequence 
    a: 0
    dba: statement_control__S_062POST
    i: 0
    min: 37035
    r: 1
    s: 1
    zyg: 
      - !!perl/hash:RE_method 
        a: 0
        dba: statement_control__S_062POST
        endsym: spacey
        i: 0
        min: 12345
        name: sym
        r: 1
        rest: ''
        s: 1
        sym: POST
      - !!perl/hash:RE_method 
        a: 0
        dba: statement_control__S_062POST
        i: 0
        min: 12345
        name: spacey
        nobind: 1
        r: 1
        rest: ''
        s: 1
      - !!perl/hash:RE_method 
        min: 0
        name: ws
        nobind: 1
        noquant: 1
        rest: ''
      - !!perl/hash:RE_method 
        a: 0
        dba: statement_control__S_062POST
        i: 0
        min: 12345
        name: block
        r: 1
        rest: ''
        s: 1
      - !!perl/hash:RE_method 
        min: 0
        name: ws
        nobind: 1
        noquant: 1
        rest: ''
statement_control__S_063CATCH: !!perl/hash:RE 
  decl: []

  kind: rule
  min: 37035
  pkg: ~
  re: !!perl/hash:RE_sequence 
    a: 0
    dba: statement_control__S_063CATCH
    i: 0
    min: 37035
    r: 1
    s: 1
    zyg: 
      - !!perl/hash:RE_method 
        a: 0
        dba: statement_control__S_063CATCH
        endsym: spacey
        i: 0
        min: 12345
        name: sym
        r: 1
        rest: ''
        s: 1
        sym: CATCH
      - !!perl/hash:RE_method 
        a: 0
        dba: statement_control__S_063CATCH
        i: 0
        min: 12345
        name: spacey
        nobind: 1
        r: 1
        rest: ''
        s: 1
      - !!perl/hash:RE_method 
        min: 0
        name: ws
        nobind: 1
        noquant: 1
        rest: ''
      - !!perl/hash:RE_method 
        a: 0
        dba: statement_control__S_063CATCH
        i: 0
        min: 12345
        name: block
        r: 1
        rest: ''
        s: 1
      - !!perl/hash:RE_method 
        min: 0
        name: ws
        nobind: 1
        noquant: 1
        rest: ''
statement_control__S_064CONTROL: !!perl/hash:RE 
  decl: []

  kind: rule
  min: 37035
  pkg: ~
  re: !!perl/hash:RE_sequence 
    a: 0
    dba: statement_control__S_064CONTROL
    i: 0
    min: 37035
    r: 1
    s: 1
    zyg: 
      - !!perl/hash:RE_method 
        a: 0
        dba: statement_control__S_064CONTROL
        endsym: spacey
        i: 0
        min: 12345
        name: sym
        r: 1
        rest: ''
        s: 1
        sym: CONTROL
      - !!perl/hash:RE_method 
        a: 0
        dba: statement_control__S_064CONTROL
        i: 0
        min: 12345
        name: spacey
        nobind: 1
        r: 1
        rest: ''
        s: 1
      - !!perl/hash:RE_method 
        min: 0
        name: ws
        nobind: 1
        noquant: 1
        rest: ''
      - !!perl/hash:RE_method 
        a: 0
        dba: statement_control__S_064CONTROL
        i: 0
        min: 12345
        name: block
        r: 1
        rest: ''
        s: 1
      - !!perl/hash:RE_method 
        min: 0
        name: ws
        nobind: 1
        noquant: 1
        rest: ''
statement_control__S_065TEMP: !!perl/hash:RE 
  decl: []

  kind: rule
  min: 37035
  pkg: ~
  re: !!perl/hash:RE_sequence 
    a: 0
    dba: statement_control__S_065TEMP
    i: 0
    min: 37035
    r: 1
    s: 1
    zyg: 
      - !!perl/hash:RE_method 
        a: 0
        dba: statement_control__S_065TEMP
        endsym: spacey
        i: 0
        min: 12345
        name: sym
        r: 1
        rest: ''
        s: 1
        sym: TEMP
      - !!perl/hash:RE_method 
        a: 0
        dba: statement_control__S_065TEMP
        i: 0
        min: 12345
        name: spacey
        nobind: 1
        r: 1
        rest: ''
        s: 1
      - !!perl/hash:RE_method 
        min: 0
        name: ws
        nobind: 1
        noquant: 1
        rest: ''
      - !!perl/hash:RE_method 
        a: 0
        dba: statement_control__S_065TEMP
        i: 0
        min: 12345
        name: block
        r: 1
        rest: ''
        s: 1
      - !!perl/hash:RE_method 
        min: 0
        name: ws
        nobind: 1
        noquant: 1
        rest: ''
statement_mod_cond__S_066if: !!perl/hash:RE 
  decl: []

  kind: rule
  min: 37035
  pkg: ~
  re: !!perl/hash:RE_sequence 
    a: 0
    dba: statement_mod_cond__S_066if
    i: 0
    min: 37035
    r: 1
    s: 1
    zyg: 
      - !!perl/hash:RE_method 
        a: 0
        dba: statement_mod_cond__S_066if
        endsym: nofun
        i: 0
        min: 12345
        name: sym
        r: 1
        rest: ''
        s: 1
        sym: if
      - !!perl/hash:RE_method 
        a: 0
        dba: statement_mod_cond__S_066if
        i: 0
        min: 12345
        name: nofun
        nobind: 1
        r: 1
        rest: ''
        s: 1
      - !!perl/hash:RE_method 
        min: 0
        name: ws
        nobind: 1
        noquant: 1
        rest: ''
      - !!perl/hash:RE_method 
        a: 0
        dba: statement_mod_cond__S_066if
        i: 0
        min: 12345
        name: modifier_expr
        r: 1
        rest: ''
        s: 1
      - !!perl/hash:RE_method 
        min: 0
        name: ws
        nobind: 1
        noquant: 1
        rest: ''
statement_mod_cond__S_067unless: !!perl/hash:RE 
  decl: []

  kind: rule
  min: 37035
  pkg: ~
  re: !!perl/hash:RE_sequence 
    a: 0
    dba: statement_mod_cond__S_067unless
    i: 0
    min: 37035
    r: 1
    s: 1
    zyg: 
      - !!perl/hash:RE_method 
        a: 0
        dba: statement_mod_cond__S_067unless
        endsym: nofun
        i: 0
        min: 12345
        name: sym
        r: 1
        rest: ''
        s: 1
        sym: unless
      - !!perl/hash:RE_method 
        a: 0
        dba: statement_mod_cond__S_067unless
        i: 0
        min: 12345
        name: nofun
        nobind: 1
        r: 1
        rest: ''
        s: 1
      - !!perl/hash:RE_method 
        min: 0
        name: ws
        nobind: 1
        noquant: 1
        rest: ''
      - !!perl/hash:RE_method 
        a: 0
        dba: statement_mod_cond__S_067unless
        i: 0
        min: 12345
        name: modifier_expr
        r: 1
        rest: ''
        s: 1
      - !!perl/hash:RE_method 
        min: 0
        name: ws
        nobind: 1
        noquant: 1
        rest: ''
statement_mod_cond__S_068when: !!perl/hash:RE 
  decl: []

  kind: rule
  min: 37035
  pkg: ~
  re: !!perl/hash:RE_sequence 
    a: 0
    dba: statement_mod_cond__S_068when
    i: 0
    min: 37035
    r: 1
    s: 1
    zyg: 
      - !!perl/hash:RE_method 
        a: 0
        dba: statement_mod_cond__S_068when
        endsym: nofun
        i: 0
        min: 12345
        name: sym
        r: 1
        rest: ''
        s: 1
        sym: when
      - !!perl/hash:RE_method 
        a: 0
        dba: statement_mod_cond__S_068when
        i: 0
        min: 12345
        name: nofun
        nobind: 1
        r: 1
        rest: ''
        s: 1
      - !!perl/hash:RE_method 
        min: 0
        name: ws
        nobind: 1
        noquant: 1
        rest: ''
      - !!perl/hash:RE_method 
        a: 0
        dba: statement_mod_cond__S_068when
        i: 0
        min: 12345
        name: modifier_expr
        r: 1
        rest: ''
        s: 1
      - !!perl/hash:RE_method 
        min: 0
        name: ws
        nobind: 1
        noquant: 1
        rest: ''
statement_mod_loop__S_069while: !!perl/hash:RE 
  decl: []

  kind: rule
  min: 37035
  pkg: ~
  re: !!perl/hash:RE_sequence 
    a: 0
    dba: statement_mod_loop__S_069while
    i: 0
    min: 37035
    r: 1
    s: 1
    zyg: 
      - !!perl/hash:RE_method 
        a: 0
        dba: statement_mod_loop__S_069while
        endsym: nofun
        i: 0
        min: 12345
        name: sym
        r: 1
        rest: ''
        s: 1
        sym: while
      - !!perl/hash:RE_method 
        a: 0
        dba: statement_mod_loop__S_069while
        i: 0
        min: 12345
        name: nofun
        nobind: 1
        r: 1
        rest: ''
        s: 1
      - !!perl/hash:RE_method 
        min: 0
        name: ws
        nobind: 1
        noquant: 1
        rest: ''
      - !!perl/hash:RE_method 
        a: 0
        dba: statement_mod_loop__S_069while
        i: 0
        min: 12345
        name: modifier_expr
        r: 1
        rest: ''
        s: 1
      - !!perl/hash:RE_method 
        min: 0
        name: ws
        nobind: 1
        noquant: 1
        rest: ''
statement_mod_loop__S_070until: !!perl/hash:RE 
  decl: []

  kind: rule
  min: 37035
  pkg: ~
  re: !!perl/hash:RE_sequence 
    a: 0
    dba: statement_mod_loop__S_070until
    i: 0
    min: 37035
    r: 1
    s: 1
    zyg: 
      - !!perl/hash:RE_method 
        a: 0
        dba: statement_mod_loop__S_070until
        endsym: nofun
        i: 0
        min: 12345
        name: sym
        r: 1
        rest: ''
        s: 1
        sym: until
      - !!perl/hash:RE_method 
        a: 0
        dba: statement_mod_loop__S_070until
        i: 0
        min: 12345
        name: nofun
        nobind: 1
        r: 1
        rest: ''
        s: 1
      - !!perl/hash:RE_method 
        min: 0
        name: ws
        nobind: 1
        noquant: 1
        rest: ''
      - !!perl/hash:RE_method 
        a: 0
        dba: statement_mod_loop__S_070until
        i: 0
        min: 12345
        name: modifier_expr
        r: 1
        rest: ''
        s: 1
      - !!perl/hash:RE_method 
        min: 0
        name: ws
        nobind: 1
        noquant: 1
        rest: ''
statement_mod_loop__S_071for: !!perl/hash:RE 
  decl: []

  kind: rule
  min: 37035
  pkg: ~
  re: !!perl/hash:RE_sequence 
    a: 0
    dba: statement_mod_loop__S_071for
    i: 0
    min: 37035
    r: 1
    s: 1
    zyg: 
      - !!perl/hash:RE_method 
        a: 0
        dba: statement_mod_loop__S_071for
        endsym: nofun
        i: 0
        min: 12345
        name: sym
        r: 1
        rest: ''
        s: 1
        sym: for
      - !!perl/hash:RE_method 
        a: 0
        dba: statement_mod_loop__S_071for
        i: 0
        min: 12345
        name: nofun
        nobind: 1
        r: 1
        rest: ''
        s: 1
      - !!perl/hash:RE_method 
        min: 0
        name: ws
        nobind: 1
        noquant: 1
        rest: ''
      - !!perl/hash:RE_method 
        a: 0
        dba: statement_mod_loop__S_071for
        i: 0
        min: 12345
        name: modifier_expr
        r: 1
        rest: ''
        s: 1
      - !!perl/hash:RE_method 
        min: 0
        name: ws
        nobind: 1
        noquant: 1
        rest: ''
statement_mod_loop__S_072given: !!perl/hash:RE 
  decl: []

  kind: rule
  min: 37035
  pkg: ~
  re: !!perl/hash:RE_sequence 
    a: 0
    dba: statement_mod_loop__S_072given
    i: 0
    min: 37035
    r: 1
    s: 1
    zyg: 
      - !!perl/hash:RE_method 
        a: 0
        dba: statement_mod_loop__S_072given
        endsym: nofun
        i: 0
        min: 12345
        name: sym
        r: 1
        rest: ''
        s: 1
        sym: given
      - !!perl/hash:RE_method 
        a: 0
        dba: statement_mod_loop__S_072given
        i: 0
        min: 12345
        name: nofun
        nobind: 1
        r: 1
        rest: ''
        s: 1
      - !!perl/hash:RE_method 
        min: 0
        name: ws
        nobind: 1
        noquant: 1
        rest: ''
      - !!perl/hash:RE_method 
        a: 0
        dba: statement_mod_loop__S_072given
        i: 0
        min: 12345
        name: modifier_expr
        r: 1
        rest: ''
        s: 1
      - !!perl/hash:RE_method 
        min: 0
        name: ws
        nobind: 1
        noquant: 1
        rest: ''
statement_prefix__S_049BEGIN: !!perl/hash:RE 
  decl: []

  kind: token
  min: 24690
  pkg: ~
  re: !!perl/hash:RE_sequence 
    a: 0
    dba: statement_prefix__S_049BEGIN
    i: 0
    min: 24690
    r: 1
    s: 0
    zyg: 
      - !!perl/hash:RE_method 
        a: 0
        dba: statement_prefix__S_049BEGIN
        i: 0
        min: 12345
        name: sym
        r: 1
        rest: ''
        s: 0
        sym: BEGIN
      - !!perl/hash:RE_method 
        a: 0
        dba: statement_prefix__S_049BEGIN
        i: 0
        min: 12345
        name: blorst
        r: 1
        rest: ''
        s: 0
statement_prefix__S_050CHECK: !!perl/hash:RE 
  decl: []

  kind: token
  min: 24690
  pkg: ~
  re: !!perl/hash:RE_sequence 
    a: 0
    dba: statement_prefix__S_050CHECK
    i: 0
    min: 24690
    r: 1
    s: 0
    zyg: 
      - !!perl/hash:RE_method 
        a: 0
        dba: statement_prefix__S_050CHECK
        i: 0
        min: 12345
        name: sym
        r: 1
        rest: ''
        s: 0
        sym: CHECK
      - !!perl/hash:RE_method 
        a: 0
        dba: statement_prefix__S_050CHECK
        i: 0
        min: 12345
        name: blorst
        r: 1
        rest: ''
        s: 0
statement_prefix__S_051INIT: !!perl/hash:RE 
  decl: []

  kind: token
  min: 24690
  pkg: ~
  re: !!perl/hash:RE_sequence 
    a: 0
    dba: statement_prefix__S_051INIT
    i: 0
    min: 24690
    r: 1
    s: 0
    zyg: 
      - !!perl/hash:RE_method 
        a: 0
        dba: statement_prefix__S_051INIT
        i: 0
        min: 12345
        name: sym
        r: 1
        rest: ''
        s: 0
        sym: INIT
      - !!perl/hash:RE_method 
        a: 0
        dba: statement_prefix__S_051INIT
        i: 0
        min: 12345
        name: blorst
        r: 1
        rest: ''
        s: 0
statement_prefix__S_052START: !!perl/hash:RE 
  decl: []

  kind: token
  min: 24690
  pkg: ~
  re: !!perl/hash:RE_sequence 
    a: 0
    dba: statement_prefix__S_052START
    i: 0
    min: 24690
    r: 1
    s: 0
    zyg: 
      - !!perl/hash:RE_method 
        a: 0
        dba: statement_prefix__S_052START
        i: 0
        min: 12345
        name: sym
        r: 1
        rest: ''
        s: 0
        sym: START
      - !!perl/hash:RE_method 
        a: 0
        dba: statement_prefix__S_052START
        i: 0
        min: 12345
        name: blorst
        r: 1
        rest: ''
        s: 0
statement_prefix__S_053ENTER: !!perl/hash:RE 
  decl: []

  kind: token
  min: 24690
  pkg: ~
  re: !!perl/hash:RE_sequence 
    a: 0
    dba: statement_prefix__S_053ENTER
    i: 0
    min: 24690
    r: 1
    s: 0
    zyg: 
      - !!perl/hash:RE_method 
        a: 0
        dba: statement_prefix__S_053ENTER
        i: 0
        min: 12345
        name: sym
        r: 1
        rest: ''
        s: 0
        sym: ENTER
      - !!perl/hash:RE_method 
        a: 0
        dba: statement_prefix__S_053ENTER
        i: 0
        min: 12345
        name: blorst
        r: 1
        rest: ''
        s: 0
statement_prefix__S_054FIRST: !!perl/hash:RE 
  decl: []

  kind: token
  min: 24690
  pkg: ~
  re: !!perl/hash:RE_sequence 
    a: 0
    dba: statement_prefix__S_054FIRST
    i: 0
    min: 24690
    r: 1
    s: 0
    zyg: 
      - !!perl/hash:RE_method 
        a: 0
        dba: statement_prefix__S_054FIRST
        i: 0
        min: 12345
        name: sym
        r: 1
        rest: ''
        s: 0
        sym: FIRST
      - !!perl/hash:RE_method 
        a: 0
        dba: statement_prefix__S_054FIRST
        i: 0
        min: 12345
        name: blorst
        r: 1
        rest: ''
        s: 0
statement_prefix__S_255try: !!perl/hash:RE 
  decl: []

  kind: token
  min: 24690
  pkg: ~
  re: !!perl/hash:RE_sequence 
    a: 0
    dba: statement_prefix__S_255try
    i: 0
    min: 24690
    r: 1
    s: 0
    zyg: 
      - !!perl/hash:RE_method 
        a: 0
        dba: statement_prefix__S_255try
        i: 0
        min: 12345
        name: sym
        r: 1
        rest: ''
        s: 0
        sym: try
      - !!perl/hash:RE_method 
        a: 0
        dba: statement_prefix__S_255try
        i: 0
        min: 12345
        name: blorst
        r: 1
        rest: ''
        s: 0
statement_prefix__S_256gather: !!perl/hash:RE 
  decl: []

  kind: token
  min: 24690
  pkg: ~
  re: !!perl/hash:RE_sequence 
    a: 0
    dba: statement_prefix__S_256gather
    i: 0
    min: 24690
    r: 1
    s: 0
    zyg: 
      - !!perl/hash:RE_method 
        a: 0
        dba: statement_prefix__S_256gather
        i: 0
        min: 12345
        name: sym
        r: 1
        rest: ''
        s: 0
        sym: gather
      - !!perl/hash:RE_method 
        a: 0
        dba: statement_prefix__S_256gather
        i: 0
        min: 12345
        name: blorst
        r: 1
        rest: ''
        s: 0
statement_prefix__S_257contend: !!perl/hash:RE 
  decl: []

  kind: token
  min: 24690
  pkg: ~
  re: !!perl/hash:RE_sequence 
    a: 0
    dba: statement_prefix__S_257contend
    i: 0
    min: 24690
    r: 1
    s: 0
    zyg: 
      - !!perl/hash:RE_method 
        a: 0
        dba: statement_prefix__S_257contend
        i: 0
        min: 12345
        name: sym
        r: 1
        rest: ''
        s: 0
        sym: contend
      - !!perl/hash:RE_method 
        a: 0
        dba: statement_prefix__S_257contend
        i: 0
        min: 12345
        name: blorst
        r: 1
        rest: ''
        s: 0
statement_prefix__S_258async: !!perl/hash:RE 
  decl: []

  kind: token
  min: 24690
  pkg: ~
  re: !!perl/hash:RE_sequence 
    a: 0
    dba: statement_prefix__S_258async
    i: 0
    min: 24690
    r: 1
    s: 0
    zyg: 
      - !!perl/hash:RE_method 
        a: 0
        dba: statement_prefix__S_258async
        i: 0
        min: 12345
        name: sym
        r: 1
        rest: ''
        s: 0
        sym: async
      - !!perl/hash:RE_method 
        a: 0
        dba: statement_prefix__S_258async
        i: 0
        min: 12345
        name: blorst
        r: 1
        rest: ''
        s: 0
statement_prefix__S_259maybe: !!perl/hash:RE 
  decl: []

  kind: token
  min: 24690
  pkg: ~
  re: !!perl/hash:RE_sequence 
    a: 0
    dba: statement_prefix__S_259maybe
    i: 0
    min: 24690
    r: 1
    s: 0
    zyg: 
      - !!perl/hash:RE_method 
        a: 0
        dba: statement_prefix__S_259maybe
        i: 0
        min: 12345
        name: sym
        r: 1
        rest: ''
        s: 0
        sym: maybe
      - !!perl/hash:RE_method 
        a: 0
        dba: statement_prefix__S_259maybe
        i: 0
        min: 12345
        name: blorst
        r: 1
        rest: ''
        s: 0
statement_prefix__S_260lazy: !!perl/hash:RE 
  decl: []

  kind: token
  min: 24690
  pkg: ~
  re: !!perl/hash:RE_sequence 
    a: 0
    dba: statement_prefix__S_260lazy
    i: 0
    min: 24690
    r: 1
    s: 0
    zyg: 
      - !!perl/hash:RE_method 
        a: 0
        dba: statement_prefix__S_260lazy
        i: 0
        min: 12345
        name: sym
        r: 1
        rest: ''
        s: 0
        sym: lazy
      - !!perl/hash:RE_method 
        a: 0
        dba: statement_prefix__S_260lazy
        i: 0
        min: 12345
        name: blorst
        r: 1
        rest: ''
        s: 0
statement_prefix__S_261do: !!perl/hash:RE 
  decl: []

  kind: token
  min: 24690
  pkg: ~
  re: !!perl/hash:RE_sequence 
    a: 0
    dba: statement_prefix__S_261do
    i: 0
    min: 24690
    r: 1
    s: 0
    zyg: 
      - !!perl/hash:RE_method 
        a: 0
        dba: statement_prefix__S_261do
        i: 0
        min: 12345
        name: sym
        r: 1
        rest: ''
        s: 0
        sym: do
      - !!perl/hash:RE_method 
        a: 0
        dba: statement_prefix__S_261do
        i: 0
        min: 12345
        name: blorst
        r: 1
        rest: ''
        s: 0
statement_prefix__S_262lift: !!perl/hash:RE 
  decl: 
    - !!perl/hash:RE_decl 
      a: 0
      dba: statement_prefix__S_262lift
      i: 0
      max: 0
      min: 0
      r: 1
      s: 0
      text: my $QUASIMODO is context = 1
  kind: token
  min: 24690
  pkg: ~
  re: !!perl/hash:RE_sequence 
    a: 0
    dba: statement_prefix__S_262lift
    i: 0
    min: 24690
    r: 1
    s: 0
    zyg: 
      - !!perl/hash:RE_method 
        a: 0
        dba: statement_prefix__S_262lift
        i: 0
        min: 12345
        name: sym
        r: 1
        rest: ''
        s: 0
        sym: lift
      - !!perl/hash:RE_method 
        a: 0
        dba: statement_prefix__S_262lift
        i: 0
        min: 12345
        name: blorst
        r: 1
        rest: ''
        s: 0
statementlist: !!perl/hash:RE 
  decl: 
    - !!perl/hash:RE_decl 
      a: 0
      dba: statementlist
      i: 0
      max: 0
      min: 0
      r: 1
      s: 1
      text: my $INVOCANT_OK is context<rw> = 0
  kind: rule
  min: 0
  pkg: ~
  re: !!perl/hash:RE_sequence 
    a: 0
    dba: statement list
    i: 0
    min: 0
    r: 1
    s: 1
    zyg: 
      - !!perl/hash:RE_method 
        min: 0
        name: ws
        nobind: 1
        noquant: 1
        rest: ''
      - !!perl/hash:RE_method 
        min: 0
        name: ws
        nobind: 1
        noquant: 1
        rest: ''
      - !!perl/hash:RE_bracket 
        decl: []

        min: 0
        re: &34 !!perl/hash:RE_any 
          a: 0
          altname: statementlist_01
          dba: statement list
          i: 0
          min: 0
          name: statementlist_01
          r: 1
          s: 1
          zyg: 
            - !!perl/hash:RE_sequence 
              a: 0
              alt: statementlist_01 0
              dba: statement list
              i: 0
              min: 0
              r: 1
              s: 1
              zyg: 
                - !!perl/hash:RE_meta 
                  a: 0
                  dba: statement list
                  i: 0
                  min: 0
                  r: 1
                  s: 1
                  text: $
                - !!perl/hash:RE_method 
                  min: 0
                  name: ws
                  nobind: 1
                  noquant: 1
                  rest: ''
            - !!perl/hash:RE_sequence 
              a: 0
              alt: statementlist_01 1
              dba: statement list
              i: 0
              min: 0
              r: 1
              s: 1
              zyg: 
                - !!perl/hash:RE_assertion 
                  assert: "?"
                  min: 0
                  re: !!perl/hash:RE_method_re 
                    a: 0
                    dba: statement list
                    i: 0
                    min: 0
                    name: before
                    nobind: 1
                    r: 1
                    re: !!perl/hash:RE 
                      decl: []

                      min: 1
                      re: !!perl/hash:RE_sequence 
                        a: 0
                        dba: statement list
                        i: 0
                        min: 1
                        r: 1
                        s: 1
                        zyg: 
                          - !!perl/hash:RE_cclass 
                            a: 0
                            dba: statement list
                            i: 0
                            min: 1
                            r: 1
                            s: 1
                            text: "[\\)\\]\\}]"
                          - !!perl/hash:RE_method 
                            min: 0
                            name: ws
                            nobind: 1
                            noquant: 1
                            rest: ''
                    s: 1
                - !!perl/hash:RE_method 
                  min: 0
                  name: ws
                  nobind: 1
                  noquant: 1
                  rest: ''
            - !!perl/hash:RE_sequence 
              a: 0
              alt: statementlist_01 2
              dba: statement list
              i: 0
              min: 0
              r: 1
              s: 1
              zyg: 
                - !!perl/hash:RE_quantified_atom 
                  atom: !!perl/hash:RE_bracket 
                    decl: []

                    min: 24690
                    re: !!perl/hash:RE_sequence 
                      a: 0
                      dba: statement list
                      i: 0
                      min: 24690
                      r: 1
                      s: 1
                      zyg: 
                        - !!perl/hash:RE_method 
                          a: 0
                          dba: statement list
                          i: 0
                          min: 12345
                          name: statement
                          r: 1
                          rest: ''
                          s: 1
                        - !!perl/hash:RE_method 
                          a: 0
                          dba: statement list
                          i: 0
                          min: 12345
                          name: eat_terminator
                          r: 1
                          rest: ''
                          s: 1
                        - !!perl/hash:RE_method 
                          min: 0
                          name: ws
                          nobind: 1
                          noquant: 1
                          rest: ''
                  min: 0
                  quant: 
                    - "*"
                    - ":"
                    - ''
                    - 0
                - !!perl/hash:RE_method 
                  min: 0
                  name: ws
                  nobind: 1
                  noquant: 1
                  rest: ''
      - !!perl/hash:RE_method 
        min: 0
        name: ws
        nobind: 1
        noquant: 1
        rest: ''
statementlist_01: *34
stdstopper: !!perl/hash:RE 
  decl: 
    - !!perl/hash:RE_decl 
      a: 0
      dba: stdstopper
      i: 0
      max: 0
      min: 0
      r: 0
      s: 0
      text: my @stub = return self if @*MEMOS[self.pos]<endstmt> :exists
  kind: regex
  min: 0
  pkg: ~
  re: !!perl/hash:RE_sequence 
    a: 0
    dba: standard stopper
    i: 0
    min: 0
    r: 0
    s: 0
    zyg: 
      - !!perl/hash:RE_bracket 
        decl: []

        min: 0
        re: &49 !!perl/hash:RE_any 
          a: 0
          altname: stdstopper_01
          dba: standard stopper
          i: 0
          min: 0
          name: stdstopper_01
          r: 0
          s: 0
          zyg: 
            - !!perl/hash:RE_assertion 
              alt: stdstopper_01 0
              assert: "?"
              min: 0
              re: !!perl/hash:RE_method 
                a: 0
                dba: standard stopper
                i: 0
                min: 12345
                name: terminator
                nobind: 1
                r: 0
                rest: ''
                s: 0
            - !!perl/hash:RE_assertion 
              alt: stdstopper_01 1
              assert: "?"
              min: 0
              re: !!perl/hash:RE_method 
                a: 0
                dba: standard stopper
                i: 0
                min: 12345
                name: unitstopper
                nobind: 1
                r: 0
                rest: ''
                s: 0
            - !!perl/hash:RE_meta 
              a: 0
              alt: stdstopper_01 2
              dba: standard stopper
              i: 0
              min: 0
              r: 0
              s: 0
              text: $
      - !!perl/hash:RE_block 
        a: 0
        context: void
        dba: standard stopper
        i: 0
        min: 0
        r: 0
        s: 0
        text: " @*MEMOS[$¢.pos]<endstmt> ||= 1; "
stdstopper_01: *49
stopper: !!perl/hash:RE 
  decl: []

  kind: token
  min: 0
  pkg: ~
  re: !!perl/hash:RE_assertion 
    assert: "!"
    min: 0
    re: !!perl/hash:RE_noop 
      a: 0
      dba: stopper
      i: 0
      min: 0
      nobind: 1
      r: 1
      s: 0
sublongname: !!perl/hash:RE 
  decl: []

  kind: token
  min: 12345
  pkg: ~
  re: !!perl/hash:RE_sequence 
    a: 0
    dba: sublongname
    i: 0
    min: 12345
    r: 1
    s: 0
    zyg: 
      - !!perl/hash:RE_method 
        a: 0
        dba: sublongname
        i: 0
        min: 12345
        name: subshortname
        r: 1
        rest: ''
        s: 0
      - !!perl/hash:RE_quantified_atom 
        atom: !!perl/hash:RE_method 
          a: 0
          dba: sublongname
          i: 0
          min: 12345
          name: sigterm
          r: 1
          rest: ''
          s: 0
        min: 0
        quant: 
          - "?"
          - ":"
          - ''
          - 0
subshortname: !!perl/hash:RE 
  decl: []

  kind: token
  min: 12345
  pkg: ~
  re: !!perl/hash:RE_bracket 
    decl: []

    min: 12345
    re: &29 !!perl/hash:RE_any 
      a: 0
      altname: subshortname_01
      dba: subshortname
      i: 0
      min: 12345
      name: subshortname_01
      r: 1
      s: 0
      zyg: 
        - !!perl/hash:RE_sequence 
          a: 0
          alt: subshortname_01 0
          dba: subshortname
          i: 0
          min: 12345
          r: 1
          s: 0
          zyg: 
            - !!perl/hash:RE_method 
              a: 0
              dba: subshortname
              i: 0
              min: 12345
              name: category
              r: 1
              rest: ''
              s: 0
            - !!perl/hash:RE_quantified_atom 
              atom: !!perl/hash:RE_bracket 
                decl: []

                min: 12345
                re: !!perl/hash:RE_sequence 
                  a: 0
                  dba: subshortname
                  i: 0
                  min: 12345
                  r: 1
                  s: 0
                  zyg: 
                    - !!perl/hash:RE_quantified_atom 
                      atom: !!perl/hash:RE_method 
                        a: 0
                        dba: subshortname
                        i: 0
                        min: 12345
                        name: colonpair
                        r: 1
                        rest: ''
                        s: 0
                      min: 12345
                      quant: 
                        - +
                        - ":"
                        - ''
                        - 1
                    - !!perl/hash:RE_block 
                      a: 0
                      context: void
                      dba: subshortname
                      i: 0
                      min: 0
                      r: 1
                      s: 0
                      text: " $¢.add_macro($<category>) if $*IN_DECL; "
              min: 0
              quant: 
                - "?"
                - ":"
                - ''
                - 0
        - !!perl/hash:RE_method 
          a: 0
          alt: subshortname_01 1
          dba: subshortname
          i: 0
          min: 12345
          name: desigilname
          r: 1
          rest: ''
          s: 0
subshortname_01: *29
term__S_263YOU_ARE_HERE: !!perl/hash:RE 
  decl: []

  kind: token
  min: 24690
  pkg: STD::Term
  re: !!perl/hash:RE_sequence 
    a: 0
    dba: term__S_263YOU_ARE_HERE
    i: 0
    min: 24690
    r: 1
    s: 0
    zyg: 
      - !!perl/hash:RE_method 
        a: 0
        dba: term__S_263YOU_ARE_HERE
        i: 0
        min: 12345
        name: sym
        r: 1
        rest: ''
        s: 0
        sym: YOU_ARE_HERE
      - !!perl/hash:RE_method 
        a: 0
        dba: term__S_263YOU_ARE_HERE
        i: 0
        min: 12345
        name: you_are_here
        nobind: 1
        r: 1
        rest: ''
        s: 0
term__S_264new: !!perl/hash:RE 
  decl: []

  kind: token
  min: 12349
  pkg: STD::Term
  re: !!perl/hash:RE_sequence 
    a: 0
    dba: term__S_264new
    i: 0
    min: 12349
    r: 1
    s: 0
    zyg: 
      - !!perl/hash:RE_string 
        a: 0
        dba: term__S_264new
        i: 0
        min: 3
        r: 1
        s: 0
        text: new
      - !!perl/hash:RE_quantified_atom 
        atom: !!perl/hash:RE_meta 
          a: 0
          dba: term__S_264new
          i: 0
          min: 1
          r: 1
          s: 0
          text: \h
        min: 1
        quant: 
          - +
          - ":"
          - ''
          - 1
      - !!perl/hash:RE_method 
        a: 0
        dba: term__S_264new
        i: 0
        min: 12345
        name: longname
        r: 1
        rest: ''
        s: 0
      - !!perl/hash:RE_quantified_atom 
        atom: !!perl/hash:RE_meta 
          a: 0
          dba: term__S_264new
          i: 0
          min: 1
          r: 1
          s: 0
          text: \h
        min: 0
        quant: 
          - "*"
          - ":"
          - ''
          - 0
      - !!perl/hash:RE_assertion 
        assert: "!"
        min: 0
        re: !!perl/hash:RE_method_re 
          a: 0
          dba: term__S_264new
          i: 0
          min: 0
          name: before
          nobind: 1
          r: 1
          re: !!perl/hash:RE 
            decl: []

            min: 1
            re: !!perl/hash:RE_string 
              a: 0
              dba: term__S_264new
              i: 0
              min: 1
              r: 1
              s: 0
              text: ":"
          s: 0
      - !!perl/hash:RE_method 
        min: 0
        name: obs
        nobind: 1
        rest: ("C++ constructor syntax", "method call syntax")
term__S_265ColonColonQuestionIDENT: !!perl/hash:RE 
  decl: []

  kind: token
  min: 12348
  pkg: STD::Term
  re: !!perl/hash:RE_sequence 
    a: 0
    dba: term__S_265ColonColonQuestionIDENT
    i: 0
    min: 12348
    r: 1
    s: 0
    zyg: 
      - !!perl/hash:RE_bindnamed 
        a: 0
        atom: !!perl/hash:RE_bracket 
          decl: []

          min: 12348
          nobind: 1
          re: !!perl/hash:RE_sequence 
            a: 0
            dba: term__S_265ColonColonQuestionIDENT
            i: 0
            min: 12348
            r: 1
            s: 0
            zyg: 
              - !!perl/hash:RE_string 
                a: 0
                dba: term__S_265ColonColonQuestionIDENT
                i: 0
                min: 3
                r: 1
                s: 0
                text: ::?
              - !!perl/hash:RE_method 
                a: 0
                dba: term__S_265ColonColonQuestionIDENT
                i: 0
                min: 12345
                name: identifier
                r: 1
                rest: ''
                s: 0
        dba: term__S_265ColonColonQuestionIDENT
        i: 0
        min: 12348
        r: 1
        s: 0
        var: sym
      - !!perl/hash:RE_meta 
        a: 0
        dba: term__S_265ColonColonQuestionIDENT
        i: 0
        min: 0
        r: 1
        s: 0
        text: »
term__S_266undef: !!perl/hash:RE 
  decl: []

  kind: token
  min: 12345
  pkg: STD::Term
  re: !!perl/hash:RE_sequence 
    a: 0
    dba: term__S_266undef
    i: 0
    min: 12345
    r: 1
    s: 0
    zyg: 
      - !!perl/hash:RE_method 
        a: 0
        dba: term__S_266undef
        i: 0
        min: 12345
        name: sym
        r: 1
        rest: ''
        s: 0
        sym: undef
      - !!perl/hash:RE_meta 
        a: 0
        dba: term__S_266undef
        i: 0
        min: 0
        r: 1
        s: 0
        text: »
      - !!perl/hash:RE_quantified_atom 
        atom: !!perl/hash:RE_bracket 
          decl: []

          min: 0
          re: !!perl/hash:RE_sequence 
            a: 0
            dba: term__S_266undef
            i: 0
            min: 0
            r: 1
            s: 0
            zyg: 
              - !!perl/hash:RE_assertion 
                assert: "?"
                min: 0
                re: !!perl/hash:RE_method_re 
                  a: 0
                  dba: term__S_266undef
                  i: 0
                  min: 0
                  name: before
                  nobind: 1
                  r: 1
                  re: !!perl/hash:RE 
                    decl: []

                    min: 2
                    re: !!perl/hash:RE_sequence 
                      a: 0
                      dba: term__S_266undef
                      i: 0
                      min: 2
                      r: 1
                      s: 0
                      zyg: 
                        - !!perl/hash:RE_quantified_atom 
                          atom: !!perl/hash:RE_meta 
                            a: 0
                            dba: term__S_266undef
                            i: 0
                            min: 1
                            r: 1
                            s: 0
                            text: \h
                          min: 0
                          quant: 
                            - "*"
                            - ":"
                            - ''
                            - 0
                        - !!perl/hash:RE_string 
                          a: 0
                          dba: term__S_266undef
                          i: 0
                          min: 2
                          r: 1
                          s: 0
                          text: $/
                  s: 0
              - !!perl/hash:RE_method 
                min: 0
                name: obs
                nobind: 1
                rest: "('$/ variable as input record separator',\n             \"the filehandle's .slurp method\")"
        min: 0
        quant: 
          - "?"
          - ":"
          - ''
          - 0
      - !!perl/hash:RE_quantified_atom 
        atom: !!perl/hash:RE_bracket 
          decl: []

          min: 0
          re: !!perl/hash:RE_sequence 
            a: 0
            dba: term__S_266undef
            i: 0
            min: 0
            r: 1
            s: 0
            zyg: 
              - !!perl/hash:RE_assertion 
                assert: "?"
                min: 0
                re: !!perl/hash:RE_method_re 
                  a: 0
                  dba: term__S_266undef
                  i: 0
                  min: 0
                  name: before
                  nobind: 1
                  r: 1
                  re: !!perl/hash:RE 
                    decl: []

                    min: 12346
                    re: !!perl/hash:RE_sequence 
                      a: 0
                      dba: term__S_266undef
                      i: 0
                      min: 12346
                      r: 1
                      s: 0
                      zyg: 
                        - !!perl/hash:RE_quantified_atom 
                          atom: !!perl/hash:RE_meta 
                            a: 0
                            dba: term__S_266undef
                            i: 0
                            min: 1
                            r: 1
                            s: 0
                            text: \h
                          min: 0
                          quant: 
                            - "*"
                            - ":"
                            - ''
                            - 0
                        - !!perl/hash:RE_method 
                          a: 0
                          dba: term__S_266undef
                          i: 0
                          min: 12345
                          name: sigil
                          r: 1
                          rest: ''
                          s: 0
                        - !!perl/hash:RE_quantified_atom 
                          atom: !!perl/hash:RE_method 
                            a: 0
                            dba: term__S_266undef
                            i: 0
                            min: 12345
                            name: twigil
                            r: 1
                            rest: ''
                            s: 0
                          min: 0
                          quant: 
                            - "?"
                            - ":"
                            - ''
                            - 0
                        - !!perl/hash:RE_meta 
                          a: 0
                          dba: term__S_266undef
                          i: 0
                          min: 1
                          r: 1
                          s: 0
                          text: \w
                  s: 0
              - !!perl/hash:RE_method 
                min: 0
                name: obs
                nobind: 1
                rest: ('undef as a verb', 'undefine function')
        min: 0
        quant: 
          - "?"
          - ":"
          - ''
          - 0
term__S_267continue: !!perl/hash:RE 
  decl: []

  kind: token
  min: 12345
  pkg: STD::Term
  re: !!perl/hash:RE_sequence 
    a: 0
    dba: term__S_267continue
    i: 0
    min: 12345
    r: 1
    s: 0
    zyg: 
      - !!perl/hash:RE_method 
        a: 0
        dba: term__S_267continue
        i: 0
        min: 12345
        name: sym
        r: 1
        rest: ''
        s: 0
        sym: continue
      - !!perl/hash:RE_meta 
        a: 0
        dba: term__S_267continue
        i: 0
        min: 0
        r: 1
        s: 0
        text: »
term__S_268self: !!perl/hash:RE 
  decl: []

  kind: token
  min: 12345
  pkg: STD::Term
  re: !!perl/hash:RE_sequence 
    a: 0
    dba: term__S_268self
    i: 0
    min: 12345
    r: 1
    s: 0
    zyg: 
      - !!perl/hash:RE_method 
        a: 0
        dba: term__S_268self
        i: 0
        min: 12345
        name: sym
        r: 1
        rest: ''
        s: 0
        sym: self
      - !!perl/hash:RE_meta 
        a: 0
        dba: term__S_268self
        i: 0
        min: 0
        r: 1
        s: 0
        text: »
term__S_269defer: !!perl/hash:RE 
  decl: []

  kind: token
  min: 12345
  pkg: STD::Term
  re: !!perl/hash:RE_sequence 
    a: 0
    dba: term__S_269defer
    i: 0
    min: 12345
    r: 1
    s: 0
    zyg: 
      - !!perl/hash:RE_method 
        a: 0
        dba: term__S_269defer
        i: 0
        min: 12345
        name: sym
        r: 1
        rest: ''
        s: 0
        sym: defer
      - !!perl/hash:RE_meta 
        a: 0
        dba: term__S_269defer
        i: 0
        min: 0
        r: 1
        s: 0
        text: »
term__S_270rand: !!perl/hash:RE 
  decl: []

  kind: token
  min: 12345
  pkg: STD::Term
  re: !!perl/hash:RE_sequence 
    a: 0
    dba: term__S_270rand
    i: 0
    min: 12345
    r: 1
    s: 0
    zyg: 
      - !!perl/hash:RE_method 
        a: 0
        dba: term__S_270rand
        i: 0
        min: 12345
        name: sym
        r: 1
        rest: ''
        s: 0
        sym: rand
      - !!perl/hash:RE_meta 
        a: 0
        dba: term__S_270rand
        i: 0
        min: 0
        r: 1
        s: 0
        text: »
      - !!perl/hash:RE_quantified_atom 
        atom: !!perl/hash:RE_bracket 
          decl: []

          min: 0
          re: !!perl/hash:RE_sequence 
            a: 0
            dba: term__S_270rand
            i: 0
            min: 0
            r: 1
            s: 0
            zyg: 
              - !!perl/hash:RE_assertion 
                assert: "?"
                min: 0
                re: !!perl/hash:RE_method_re 
                  a: 0
                  dba: term__S_270rand
                  i: 0
                  min: 0
                  name: before
                  nobind: 1
                  r: 1
                  re: !!perl/hash:RE 
                    decl: []

                    min: 1
                    re: !!perl/hash:RE_sequence 
                      a: 0
                      dba: term__S_270rand
                      i: 0
                      min: 1
                      r: 1
                      s: 0
                      zyg: 
                        - !!perl/hash:RE_quantified_atom 
                          atom: !!perl/hash:RE_string 
                            a: 0
                            dba: term__S_270rand
                            i: 0
                            min: 1
                            r: 1
                            s: 0
                            text: (
                          min: 0
                          quant: 
                            - "?"
                            - ":"
                            - ''
                            - 0
                        - !!perl/hash:RE_quantified_atom 
                          atom: !!perl/hash:RE_meta 
                            a: 0
                            dba: term__S_270rand
                            i: 0
                            min: 1
                            r: 1
                            s: 0
                            text: \h
                          min: 0
                          quant: 
                            - "*"
                            - ":"
                            - ''
                            - 0
                        - !!perl/hash:RE_bracket 
                          decl: []

                          min: 1
                          re: &48 !!perl/hash:RE_any 
                            a: 0
                            altname: term__S_270rand_03
                            dba: term__S_270rand
                            i: 0
                            min: 1
                            name: term__S_270rand_03
                            r: 1
                            s: 0
                            zyg: 
                              - !!perl/hash:RE_meta 
                                a: 0
                                alt: term__S_270rand_03 0
                                dba: term__S_270rand
                                i: 0
                                min: 1
                                r: 1
                                s: 0
                                text: \d
                              - !!perl/hash:RE_string 
                                a: 0
                                alt: term__S_270rand_03 1
                                dba: term__S_270rand
                                i: 0
                                min: 1
                                r: 1
                                s: 0
                                text: $
                  s: 0
              - !!perl/hash:RE_method 
                min: 0
                name: obs
                nobind: 1
                rest: ('rand(N)', 'N.rand or (1..N).pick')
        min: 0
        quant: 
          - "?"
          - ":"
          - ''
          - 0
      - !!perl/hash:RE_quantified_atom 
        atom: !!perl/hash:RE_bracket 
          decl: []

          min: 0
          re: !!perl/hash:RE_sequence 
            a: 0
            dba: term__S_270rand
            i: 0
            min: 0
            r: 1
            s: 0
            zyg: 
              - !!perl/hash:RE_assertion 
                assert: "?"
                min: 0
                re: !!perl/hash:RE_method_re 
                  a: 0
                  dba: term__S_270rand
                  i: 0
                  min: 0
                  name: before
                  nobind: 1
                  r: 1
                  re: !!perl/hash:RE 
                    decl: []

                    min: 2
                    re: !!perl/hash:RE_string 
                      a: 0
                      dba: term__S_270rand
                      i: 0
                      min: 2
                      r: 1
                      s: 0
                      text: ()
                  s: 0
              - !!perl/hash:RE_method 
                min: 0
                name: obs
                nobind: 1
                rest: ('rand()', 'rand')
        min: 0
        quant: 
          - "?"
          - ":"
          - ''
          - 0
term__S_270rand_03: *48
term__S_271e: !!perl/hash:RE 
  decl: []

  kind: token
  min: 12345
  pkg: STD::Term
  re: !!perl/hash:RE_sequence 
    a: 0
    dba: term__S_271e
    i: 0
    min: 12345
    r: 1
    s: 0
    zyg: 
      - !!perl/hash:RE_method 
        a: 0
        dba: term__S_271e
        i: 0
        min: 12345
        name: sym
        r: 1
        rest: ''
        s: 0
        sym: e
      - !!perl/hash:RE_meta 
        a: 0
        dba: term__S_271e
        i: 0
        min: 0
        r: 1
        s: 0
        text: »
term__S_272i: !!perl/hash:RE 
  decl: []

  kind: token
  min: 12345
  pkg: STD::Term
  re: !!perl/hash:RE_sequence 
    a: 0
    dba: term__S_272i
    i: 0
    min: 12345
    r: 1
    s: 0
    zyg: 
      - !!perl/hash:RE_method 
        a: 0
        dba: term__S_272i
        i: 0
        min: 12345
        name: sym
        r: 1
        rest: ''
        s: 0
        sym: i
      - !!perl/hash:RE_meta 
        a: 0
        dba: term__S_272i
        i: 0
        min: 0
        r: 1
        s: 0
        text: »
term__S_273pi: !!perl/hash:RE 
  decl: []

  kind: token
  min: 12345
  pkg: STD::Term
  re: !!perl/hash:RE_sequence 
    a: 0
    dba: term__S_273pi
    i: 0
    min: 12345
    r: 1
    s: 0
    zyg: 
      - !!perl/hash:RE_method 
        a: 0
        dba: term__S_273pi
        i: 0
        min: 12345
        name: sym
        r: 1
        rest: ''
        s: 0
        sym: pi
      - !!perl/hash:RE_meta 
        a: 0
        dba: term__S_273pi
        i: 0
        min: 0
        r: 1
        s: 0
        text: »
term__S_274Inf: !!perl/hash:RE 
  decl: []

  kind: token
  min: 12345
  pkg: STD::Term
  re: !!perl/hash:RE_sequence 
    a: 0
    dba: term__S_274Inf
    i: 0
    min: 12345
    r: 1
    s: 0
    zyg: 
      - !!perl/hash:RE_method 
        a: 0
        dba: term__S_274Inf
        i: 0
        min: 12345
        name: sym
        r: 1
        rest: ''
        s: 0
        sym: Inf
      - !!perl/hash:RE_meta 
        a: 0
        dba: term__S_274Inf
        i: 0
        min: 0
        r: 1
        s: 0
        text: »
term__S_275NaN: !!perl/hash:RE 
  decl: []

  kind: token
  min: 12345
  pkg: STD::Term
  re: !!perl/hash:RE_sequence 
    a: 0
    dba: term__S_275NaN
    i: 0
    min: 12345
    r: 1
    s: 0
    zyg: 
      - !!perl/hash:RE_method 
        a: 0
        dba: term__S_275NaN
        i: 0
        min: 12345
        name: sym
        r: 1
        rest: ''
        s: 0
        sym: NaN
      - !!perl/hash:RE_meta 
        a: 0
        dba: term__S_275NaN
        i: 0
        min: 0
        r: 1
        s: 0
        text: »
term__S_276Star: !!perl/hash:RE 
  decl: []

  kind: token
  min: 12345
  pkg: STD::Term
  re: !!perl/hash:RE_method 
    a: 0
    dba: term__S_276Star
    i: 0
    min: 12345
    name: sym
    r: 1
    rest: ''
    s: 0
    sym: "*"
term__S_277StarStar: !!perl/hash:RE 
  decl: []

  kind: token
  min: 12345
  pkg: STD::Term
  re: !!perl/hash:RE_method 
    a: 0
    dba: term__S_277StarStar
    i: 0
    min: 12345
    name: sym
    r: 1
    rest: ''
    s: 0
    sym: "**"
term__S_299lambda: !!perl/hash:RE 
  decl: []

  kind: token
  min: 12345
  pkg: STD::Term
  re: !!perl/hash:RE_sequence 
    a: 0
    dba: term__S_299lambda
    i: 0
    min: 12345
    r: 1
    s: 0
    zyg: 
      - !!perl/hash:RE_assertion 
        assert: "?"
        min: 0
        re: !!perl/hash:RE_method_re 
          a: 0
          dba: term__S_299lambda
          i: 0
          min: 0
          name: before
          nobind: 1
          r: 1
          re: !!perl/hash:RE 
            decl: []

            min: 12345
            re: !!perl/hash:RE_method 
              a: 0
              dba: term__S_299lambda
              i: 0
              min: 12345
              name: lambda
              nobind: 1
              r: 1
              rest: ''
              s: 0
          s: 0
      - !!perl/hash:RE_method 
        a: 0
        dba: term__S_299lambda
        i: 0
        min: 12345
        name: pblock
        r: 1
        rest: ''
        s: 0
      - !!perl/hash:RE_block 
        a: 0
        context: void
        dba: term__S_299lambda
        i: 0
        min: 0
        r: 1
        s: 0
        text: "\n        if $*BORG {\n            $*BORG.<block> = $<pblock>;\n        }\n    "
term__S_414DotDotDot: !!perl/hash:RE 
  decl: []

  kind: token
  min: 12345
  pkg: STD::List_prefix
  re: !!perl/hash:RE_sequence 
    a: 0
    dba: term__S_414DotDotDot
    i: 0
    min: 12345
    r: 1
    s: 0
    zyg: 
      - !!perl/hash:RE_method 
        a: 0
        dba: term__S_414DotDotDot
        i: 0
        min: 12345
        name: sym
        r: 1
        rest: ''
        s: 0
        sym: ...
      - !!perl/hash:RE_quantified_atom 
        atom: !!perl/hash:RE_method 
          a: 0
          dba: term__S_414DotDotDot
          i: 0
          min: 12345
          name: args
          r: 1
          rest: ''
          s: 0
        min: 0
        quant: 
          - "?"
          - ":"
          - ''
          - 0
term__S_415QuestionQuestionQuestion: !!perl/hash:RE 
  decl: []

  kind: token
  min: 12345
  pkg: STD::List_prefix
  re: !!perl/hash:RE_sequence 
    a: 0
    dba: term__S_415QuestionQuestionQuestion
    i: 0
    min: 12345
    r: 1
    s: 0
    zyg: 
      - !!perl/hash:RE_method 
        a: 0
        dba: term__S_415QuestionQuestionQuestion
        i: 0
        min: 12345
        name: sym
        r: 1
        rest: ''
        s: 0
        sym: ???
      - !!perl/hash:RE_quantified_atom 
        atom: !!perl/hash:RE_method 
          a: 0
          dba: term__S_415QuestionQuestionQuestion
          i: 0
          min: 12345
          name: args
          r: 1
          rest: ''
          s: 0
        min: 0
        quant: 
          - "?"
          - ":"
          - ''
          - 0
term__S_416BangBangBang: !!perl/hash:RE 
  decl: []

  kind: token
  min: 12345
  pkg: STD::List_prefix
  re: !!perl/hash:RE_sequence 
    a: 0
    dba: term__S_416BangBangBang
    i: 0
    min: 12345
    r: 1
    s: 0
    zyg: 
      - !!perl/hash:RE_method 
        a: 0
        dba: term__S_416BangBangBang
        i: 0
        min: 12345
        name: sym
        r: 1
        rest: ''
        s: 0
        sym: "!!!"
      - !!perl/hash:RE_quantified_atom 
        atom: !!perl/hash:RE_method 
          a: 0
          dba: term__S_416BangBangBang
          i: 0
          min: 12345
          name: args
          r: 1
          rest: ''
          s: 0
        min: 0
        quant: 
          - "?"
          - ":"
          - ''
          - 0
term__S_417identifier: !!perl/hash:RE 
  decl: 
    - !!perl/hash:RE_decl 
      a: 0
      dba: term__S_417identifier
      i: 0
      max: 0
      min: 0
      r: 1
      s: 0
      text: my $name
    - !!perl/hash:RE_decl 
      a: 0
      dba: term__S_417identifier
      i: 0
      max: 0
      min: 0
      r: 1
      s: 0
      text: my $pos
  kind: token
  min: 12345
  pkg: STD::Term
  re: !!perl/hash:RE_sequence 
    a: 0
    dba: term__S_417identifier
    i: 0
    min: 12345
    r: 1
    s: 0
    zyg: 
      - !!perl/hash:RE_method 
        a: 0
        dba: term__S_417identifier
        i: 0
        min: 12345
        name: identifier
        r: 1
        rest: ''
        s: 0
      - !!perl/hash:RE_assertion 
        assert: "?"
        min: 0
        re: !!perl/hash:RE_method_re 
          a: 0
          dba: term__S_417identifier
          i: 0
          min: 0
          name: before
          nobind: 1
          r: 1
          re: !!perl/hash:RE 
            decl: []

            min: 0
            re: !!perl/hash:RE_quantified_atom 
              atom: !!perl/hash:RE_bracket 
                decl: []

                min: 1
                re: &109 !!perl/hash:RE_any 
                  a: 0
                  altname: term__S_417identifier_02
                  dba: term__S_417identifier
                  i: 0
                  min: 1
                  name: term__S_417identifier_02
                  r: 1
                  s: 0
                  zyg: 
                    - !!perl/hash:RE_method 
                      a: 0
                      alt: term__S_417identifier_02 0
                      dba: term__S_417identifier
                      i: 0
                      min: 12345
                      name: unsp
                      r: 1
                      rest: ''
                      s: 0
                    - !!perl/hash:RE_string 
                      a: 0
                      alt: term__S_417identifier_02 1
                      dba: term__S_417identifier
                      i: 0
                      min: 1
                      r: 1
                      s: 0
                      text: (
              min: 0
              quant: 
                - "?"
                - ":"
                - ''
                - 0
          s: 0
      - !!perl/hash:RE_block 
        a: 0
        context: void
        dba: term__S_417identifier
        i: 0
        min: 0
        r: 1
        s: 0
        text: " $name = $<identifier>.Str; $pos = $¢.pos; "
      - !!perl/hash:RE_method 
        min: 0
        name: args
        rest: ( $¢.is_name($name) )
      - !!perl/hash:RE_block 
        a: 0
        context: void
        dba: term__S_417identifier
        i: 0
        min: 0
        r: 1
        s: 0
        text: " self.add_mystery($name,$pos) unless $<args><invocant>; "
      - !!perl/hash:RE_block 
        a: 0
        context: void
        dba: term__S_417identifier
        i: 0
        min: 0
        r: 1
        s: 0
        text: "\n        if $*BORG and $*BORG.<block> {\n            if not $*BORG.<name> {\n                $*BORG.<culprit> = $<identifier>.cursor($pos);\n                $*BORG.<name> = $name;\n            }\n        }\n    "
term__S_417identifier_02: *109
term__S_418opfunc: !!perl/hash:RE 
  decl: []

  kind: token
  min: 37035
  pkg: STD::Term
  re: !!perl/hash:RE_sequence 
    a: 0
    dba: term__S_418opfunc
    i: 0
    min: 37035
    r: 1
    s: 0
    zyg: 
      - !!perl/hash:RE_method 
        a: 0
        dba: term__S_418opfunc
        i: 0
        min: 12345
        name: category
        r: 1
        rest: ''
        s: 0
      - !!perl/hash:RE_quantified_atom 
        atom: !!perl/hash:RE_method 
          a: 0
          dba: term__S_418opfunc
          i: 0
          min: 12345
          name: colonpair
          r: 1
          rest: ''
          s: 0
        min: 12345
        quant: 
          - +
          - ":"
          - ''
          - 1
      - !!perl/hash:RE_method 
        a: 0
        dba: term__S_418opfunc
        i: 0
        min: 12345
        name: args
        r: 1
        rest: ''
        s: 0
term__S_419name: !!perl/hash:RE 
  decl: 
    - !!perl/hash:RE_decl 
      a: 0
      dba: term__S_419name
      i: 0
      max: 0
      min: 0
      r: 1
      s: 0
      text: my $name
    - !!perl/hash:RE_decl 
      a: 0
      dba: term__S_419name
      i: 0
      max: 0
      min: 0
      r: 1
      s: 0
      text: my $pos
  kind: token
  min: 12345
  pkg: STD::Term
  re: !!perl/hash:RE_sequence 
    a: 0
    dba: term__S_419name
    i: 0
    min: 12345
    r: 1
    s: 0
    zyg: 
      - !!perl/hash:RE_method 
        a: 0
        dba: term__S_419name
        i: 0
        min: 12345
        name: longname
        r: 1
        rest: ''
        s: 0
      - !!perl/hash:RE_block 
        a: 0
        context: void
        dba: term__S_419name
        i: 0
        min: 0
        r: 1
        s: 0
        text: "\n        $name = $<longname>.Str;\n        $pos = $¢.pos;\n    "
      - !!perl/hash:RE_bracket 
        decl: []

        min: 0
        re: !!perl/hash:RE_first 
          a: 0
          dba: type parameter
          i: 0
          min: 0
          r: 1
          s: 0
          zyg: 
            - !!perl/hash:RE_sequence 
              a: 0
              dba: type parameter
              i: 0
              min: 0
              r: 1
              s: 0
              zyg: 
                - !!perl/hash:RE_assertion 
                  assert: "?"
                  min: 0
                  re: !!perl/hash:RE_block 
                    a: 0
                    context: bool
                    dba: term__S_419name
                    i: 0
                    min: 0
                    nobind: 1
                    r: 1
                    s: 0
                    text: "\n            $¢.is_name($<longname>.Str) or substr($<longname>.Str,0,2) eq '::'\n        "
                - !!perl/hash:RE_quantified_atom 
                  atom: !!perl/hash:RE_method 
                    a: 0
                    dba: term__S_419name
                    i: 0
                    min: 12345
                    name: unsp
                    nobind: 1
                    r: 1
                    rest: ''
                    s: 0
                  min: 0
                  quant: 
                    - "?"
                    - ":"
                    - ''
                    - 0
                - !!perl/hash:RE_quantified_atom 
                  atom: !!perl/hash:RE_bracket 
                    decl: []

                    min: 12345
                    re: !!perl/hash:RE_sequence 
                      a: 0
                      dba: term__S_419name
                      i: 0
                      min: 12345
                      r: 1
                      s: 0
                      zyg: 
                        - !!perl/hash:RE_assertion 
                          assert: "?"
                          min: 0
                          re: !!perl/hash:RE_method_re 
                            a: 0
                            dba: term__S_419name
                            i: 0
                            min: 0
                            name: before
                            nobind: 1
                            r: 1
                            re: !!perl/hash:RE 
                              decl: []

                              min: 1
                              re: !!perl/hash:RE_string 
                                a: 0
                                dba: term__S_419name
                                i: 0
                                min: 1
                                r: 1
                                s: 0
                                text: "["
                            s: 0
                        - !!perl/hash:RE_method 
                          a: 0
                          dba: term__S_419name
                          i: 0
                          min: 12345
                          name: postcircumfix
                          r: 1
                          rest: ''
                          s: 0
                  min: 0
                  quant: 
                    - "?"
                    - ":"
                    - ''
                    - 0
                - !!perl/hash:RE_quantified_atom 
                  atom: !!perl/hash:RE_bracket 
                    decl: []

                    min: 12347
                    re: !!perl/hash:RE_sequence 
                      a: 0
                      dba: type parameter
                      i: 0
                      min: 12347
                      r: 1
                      s: 0
                      zyg: 
                        - !!perl/hash:RE_string 
                          a: 0
                          dba: type parameter
                          i: 0
                          min: 2
                          r: 1
                          s: 0
                          text: "::"
                        - !!perl/hash:RE_assertion 
                          assert: "?"
                          min: 0
                          re: !!perl/hash:RE_method_re 
                            a: 0
                            dba: type parameter
                            i: 0
                            min: 0
                            name: before
                            nobind: 1
                            r: 1
                            re: !!perl/hash:RE 
                              decl: []

                              min: 1
                              re: !!perl/hash:RE_bracket 
                                decl: []

                                min: 1
                                re: &4 !!perl/hash:RE_any 
                                  a: 0
                                  altname: term__S_419name_06
                                  dba: type parameter
                                  i: 0
                                  min: 1
                                  name: term__S_419name_06
                                  r: 1
                                  s: 0
                                  zyg: 
                                    - !!perl/hash:RE_string 
                                      a: 0
                                      alt: term__S_419name_06 0
                                      dba: type parameter
                                      i: 0
                                      min: 1
                                      r: 1
                                      s: 0
                                      text: «
                                    - !!perl/hash:RE_string 
                                      a: 0
                                      alt: term__S_419name_06 1
                                      dba: type parameter
                                      i: 0
                                      min: 1
                                      r: 1
                                      s: 0
                                      text: <
                                    - !!perl/hash:RE_string 
                                      a: 0
                                      alt: term__S_419name_06 2
                                      dba: type parameter
                                      i: 0
                                      min: 1
                                      r: 1
                                      s: 0
                                      text: "{"
                                    - !!perl/hash:RE_string 
                                      a: 0
                                      alt: term__S_419name_06 3
                                      dba: type parameter
                                      i: 0
                                      min: 2
                                      r: 1
                                      s: 0
                                      text: <<
                            s: 0
                        - !!perl/hash:RE_method 
                          a: 0
                          dba: type parameter
                          i: 0
                          min: 12345
                          name: postcircumfix
                          r: 1
                          rest: ''
                          s: 0
                        - !!perl/hash:RE_method_internal 
                          args: $S, 'term__S_419name', 'packagevar '
                          max: 0
                          min: 0
                          name: _REDUCE
                  min: 0
                  quant: 
                    - "?"
                    - ":"
                    - ''
                    - 0
                - !!perl/hash:RE_method_internal 
                  args: $S, 'term__S_419name', 'typename'
                  max: 0
                  min: 0
                  name: _REDUCE
            - !!perl/hash:RE_sequence 
              a: 0
              dba: type parameter
              i: 0
              min: 12345
              r: 1
              s: 0
              zyg: 
                - !!perl/hash:RE_method 
                  a: 0
                  dba: type parameter
                  i: 0
                  min: 12345
                  name: args
                  r: 1
                  rest: ''
                  s: 0
                - !!perl/hash:RE_block 
                  a: 0
                  context: void
                  dba: type parameter
                  i: 0
                  min: 0
                  r: 1
                  s: 0
                  text: " self.add_mystery($name,$pos) unless $<args><invocant>; "
                - !!perl/hash:RE_block 
                  a: 0
                  context: void
                  dba: type parameter
                  i: 0
                  min: 0
                  r: 1
                  s: 0
                  text: "\n            if $*BORG and $*BORG.<block> {\n                if not $*BORG.<name> {\n                    $*BORG.<culprit> = $<longname>.cursor($pos);\n                    $*BORG.<name> //= $name;\n                }\n            }\n        "
term__S_419name_06: *4
term__S_605miscbad: !!perl/hash:RE 
  decl: []

  kind: token
  min: 12345
  pkg: ~
  re: !!perl/hash:RE_sequence 
    a: 0
    dba: term__S_605miscbad
    i: 0
    min: 12345
    r: 1
    s: 0
    zyg: 
      - !!perl/hash:RE_block 
        a: 0
        context: void
        dba: term__S_605miscbad
        i: 0
        min: 0
        r: 1
        s: 0
        text: ''
      - !!perl/hash:RE_assertion 
        assert: "!"
        min: 0
        re: !!perl/hash:RE_block 
          a: 0
          context: bool
          dba: term__S_605miscbad
          i: 0
          min: 0
          nobind: 1
          r: 1
          s: 0
          text: " $*QSIGIL "
      - !!perl/hash:RE_method 
        a: 0
        dba: term__S_605miscbad
        i: 0
        min: 12345
        name: infixish
        r: 1
        rest: ''
        s: 0
      - !!perl/hash:RE_method 
        min: 0
        name: badinfix
        nobind: 1
        rest: ($<infixish>.Str)
terminator__S_429Semi: !!perl/hash:RE 
  decl: []

  kind: token
  min: 1
  pkg: STD::Terminator
  re: !!perl/hash:RE_string 
    a: 0
    dba: terminator__S_429Semi
    i: 0
    min: 1
    r: 1
    s: 0
    text: ;
terminator__S_430if: !!perl/hash:RE 
  decl: []

  kind: token
  min: 12347
  pkg: STD::Terminator
  re: !!perl/hash:RE_sequence 
    a: 0
    dba: terminator__S_430if
    i: 0
    min: 12347
    r: 1
    s: 0
    zyg: 
      - !!perl/hash:RE_string 
        a: 0
        dba: terminator__S_430if
        i: 0
        min: 2
        r: 1
        s: 0
        text: if
      - !!perl/hash:RE_meta 
        a: 0
        dba: terminator__S_430if
        i: 0
        min: 0
        r: 1
        s: 0
        text: »
      - !!perl/hash:RE_method 
        a: 0
        dba: terminator__S_430if
        i: 0
        min: 12345
        name: nofun
        nobind: 1
        r: 1
        rest: ''
        s: 0
terminator__S_431unless: !!perl/hash:RE 
  decl: []

  kind: token
  min: 12351
  pkg: STD::Terminator
  re: !!perl/hash:RE_sequence 
    a: 0
    dba: terminator__S_431unless
    i: 0
    min: 12351
    r: 1
    s: 0
    zyg: 
      - !!perl/hash:RE_string 
        a: 0
        dba: terminator__S_431unless
        i: 0
        min: 6
        r: 1
        s: 0
        text: unless
      - !!perl/hash:RE_meta 
        a: 0
        dba: terminator__S_431unless
        i: 0
        min: 0
        r: 1
        s: 0
        text: »
      - !!perl/hash:RE_method 
        a: 0
        dba: terminator__S_431unless
        i: 0
        min: 12345
        name: nofun
        nobind: 1
        r: 1
        rest: ''
        s: 0
terminator__S_432while: !!perl/hash:RE 
  decl: []

  kind: token
  min: 12350
  pkg: STD::Terminator
  re: !!perl/hash:RE_sequence 
    a: 0
    dba: terminator__S_432while
    i: 0
    min: 12350
    r: 1
    s: 0
    zyg: 
      - !!perl/hash:RE_string 
        a: 0
        dba: terminator__S_432while
        i: 0
        min: 5
        r: 1
        s: 0
        text: while
      - !!perl/hash:RE_meta 
        a: 0
        dba: terminator__S_432while
        i: 0
        min: 0
        r: 1
        s: 0
        text: »
      - !!perl/hash:RE_method 
        a: 0
        dba: terminator__S_432while
        i: 0
        min: 12345
        name: nofun
        nobind: 1
        r: 1
        rest: ''
        s: 0
terminator__S_433until: !!perl/hash:RE 
  decl: []

  kind: token
  min: 12350
  pkg: STD::Terminator
  re: !!perl/hash:RE_sequence 
    a: 0
    dba: terminator__S_433until
    i: 0
    min: 12350
    r: 1
    s: 0
    zyg: 
      - !!perl/hash:RE_string 
        a: 0
        dba: terminator__S_433until
        i: 0
        min: 5
        r: 1
        s: 0
        text: until
      - !!perl/hash:RE_meta 
        a: 0
        dba: terminator__S_433until
        i: 0
        min: 0
        r: 1
        s: 0
        text: »
      - !!perl/hash:RE_method 
        a: 0
        dba: terminator__S_433until
        i: 0
        min: 12345
        name: nofun
        nobind: 1
        r: 1
        rest: ''
        s: 0
terminator__S_434for: !!perl/hash:RE 
  decl: []

  kind: token
  min: 12348
  pkg: STD::Terminator
  re: !!perl/hash:RE_sequence 
    a: 0
    dba: terminator__S_434for
    i: 0
    min: 12348
    r: 1
    s: 0
    zyg: 
      - !!perl/hash:RE_string 
        a: 0
        dba: terminator__S_434for
        i: 0
        min: 3
        r: 1
        s: 0
        text: for
      - !!perl/hash:RE_meta 
        a: 0
        dba: terminator__S_434for
        i: 0
        min: 0
        r: 1
        s: 0
        text: »
      - !!perl/hash:RE_method 
        a: 0
        dba: terminator__S_434for
        i: 0
        min: 12345
        name: nofun
        nobind: 1
        r: 1
        rest: ''
        s: 0
terminator__S_435given: !!perl/hash:RE 
  decl: []

  kind: token
  min: 12350
  pkg: STD::Terminator
  re: !!perl/hash:RE_sequence 
    a: 0
    dba: terminator__S_435given
    i: 0
    min: 12350
    r: 1
    s: 0
    zyg: 
      - !!perl/hash:RE_string 
        a: 0
        dba: terminator__S_435given
        i: 0
        min: 5
        r: 1
        s: 0
        text: given
      - !!perl/hash:RE_meta 
        a: 0
        dba: terminator__S_435given
        i: 0
        min: 0
        r: 1
        s: 0
        text: »
      - !!perl/hash:RE_method 
        a: 0
        dba: terminator__S_435given
        i: 0
        min: 12345
        name: nofun
        nobind: 1
        r: 1
        rest: ''
        s: 0
terminator__S_436when: !!perl/hash:RE 
  decl: []

  kind: token
  min: 12349
  pkg: STD::Terminator
  re: !!perl/hash:RE_sequence 
    a: 0
    dba: terminator__S_436when
    i: 0
    min: 12349
    r: 1
    s: 0
    zyg: 
      - !!perl/hash:RE_string 
        a: 0
        dba: terminator__S_436when
        i: 0
        min: 4
        r: 1
        s: 0
        text: when
      - !!perl/hash:RE_meta 
        a: 0
        dba: terminator__S_436when
        i: 0
        min: 0
        r: 1
        s: 0
        text: »
      - !!perl/hash:RE_method 
        a: 0
        dba: terminator__S_436when
        i: 0
        min: 12345
        name: nofun
        nobind: 1
        r: 1
        rest: ''
        s: 0
terminator__S_437MinusMinusGt: !!perl/hash:RE 
  decl: []

  kind: token
  min: 3
  pkg: STD::Terminator
  re: !!perl/hash:RE_sequence 
    a: 0
    dba: terminator__S_437MinusMinusGt
    i: 0
    min: 3
    r: 1
    s: 0
    zyg: 
      - !!perl/hash:RE_string 
        a: 0
        dba: terminator__S_437MinusMinusGt
        i: 0
        min: 3
        r: 1
        s: 0
        text: -->
      - !!perl/hash:RE_method_internal 
        args: $S, 'terminator__S_437MinusMinusGt'
        max: 0
        min: 0
        name: _REDUCE
terminator__S_438Thesis: !!perl/hash:RE 
  decl: []

  kind: token
  min: 12345
  pkg: STD::Terminator
  re: !!perl/hash:RE_method 
    a: 0
    dba: terminator__S_438Thesis
    i: 0
    min: 12345
    name: sym
    r: 1
    rest: ''
    s: 0
    sym: )
terminator__S_439Ket: !!perl/hash:RE 
  decl: []

  kind: token
  min: 1
  pkg: STD::Terminator
  re: !!perl/hash:RE_string 
    a: 0
    dba: terminator__S_439Ket
    i: 0
    min: 1
    r: 1
    s: 0
    text: "]"
terminator__S_440Ly: !!perl/hash:RE 
  decl: []

  kind: token
  min: 1
  pkg: STD::Terminator
  re: !!perl/hash:RE_string 
    a: 0
    dba: terminator__S_440Ly
    i: 0
    min: 1
    r: 1
    s: 0
    text: "}"
terminator__S_441BangBang: !!perl/hash:RE 
  decl: []

  kind: token
  min: 2
  pkg: STD::Terminator
  re: !!perl/hash:RE_sequence 
    a: 0
    dba: terminator__S_441BangBang
    i: 0
    min: 2
    r: 1
    s: 0
    zyg: 
      - !!perl/hash:RE_string 
        a: 0
        dba: terminator__S_441BangBang
        i: 0
        min: 2
        r: 1
        s: 0
        text: "!!"
      - !!perl/hash:RE_assertion 
        assert: "?"
        min: 0
        re: !!perl/hash:RE_block 
          a: 0
          context: bool
          dba: terminator__S_441BangBang
          i: 0
          min: 0
          nobind: 1
          r: 1
          s: 0
          text: " $*GOAL eq '!!' "
termish: !!perl/hash:RE 
  decl: 
    - !!perl/hash:RE_decl 
      a: 0
      dba: termish
      i: 0
      max: 0
      min: 0
      r: 1
      s: 0
      text: my $SCOPE is context<rw> = "our"
    - !!perl/hash:RE_decl 
      a: 0
      dba: termish
      i: 0
      max: 0
      min: 0
      r: 1
      s: 0
      text: my $VAR is context<rw>
  kind: token
  min: 12345
  pkg: ~
  re: !!perl/hash:RE_sequence 
    a: 0
    dba: postfix
    i: 0
    min: 12345
    r: 1
    s: 0
    zyg: 
      - !!perl/hash:RE_bracket 
        decl: []

        min: 12345
        re: &43 !!perl/hash:RE_any 
          a: 0
          altname: termish_01
          dba: prefix or noun
          i: 0
          min: 12345
          name: termish_01
          r: 1
          s: 0
          zyg: 
            - !!perl/hash:RE_sequence 
              a: 0
              alt: termish_01 0
              dba: prefix or noun
              i: 0
              min: 12345
              r: 1
              s: 0
              zyg: 
                - !!perl/hash:RE_method 
                  a: 0
                  dba: prefix or noun
                  i: 0
                  min: 12345
                  name: PRE
                  r: 1
                  rest: ''
                  s: 0
                - !!perl/hash:RE_quantified_atom 
                  atom: !!perl/hash:RE_bracket 
                    decl: []

                    min: 12345
                    re: !!perl/hash:RE_sequence 
                      a: 0
                      dba: prefix or noun
                      i: 0
                      min: 12345
                      r: 1
                      s: 0
                      zyg: 
                        - !!perl/hash:RE_assertion 
                          assert: "!"
                          min: 0
                          re: !!perl/hash:RE_block 
                            a: 0
                            context: bool
                            dba: prefix or noun
                            i: 0
                            min: 0
                            nobind: 1
                            r: 1
                            s: 0
                            text: " my $p = $<PRE>; my @p = @$p; @p[*-1]<O><noun> and $<noun> = pop @$p "
                        - !!perl/hash:RE_method 
                          a: 0
                          dba: prefix or noun
                          i: 0
                          min: 12345
                          name: PRE
                          r: 1
                          rest: ''
                          s: 0
                  min: 0
                  quant: 
                    - "*"
                    - ":"
                    - ''
                    - 0
                - !!perl/hash:RE_bracket 
                  decl: []

                  min: 0
                  re: !!perl/hash:RE_first 
                    a: 0
                    dba: prefix or noun
                    i: 0
                    min: 0
                    r: 1
                    s: 0
                    zyg: 
                      - !!perl/hash:RE_assertion 
                        assert: "?"
                        min: 0
                        re: !!perl/hash:RE_block 
                          a: 0
                          context: bool
                          dba: prefix or noun
                          i: 0
                          min: 0
                          nobind: 1
                          r: 1
                          s: 0
                          text: " $<noun> "
                      - !!perl/hash:RE_method 
                        a: 0
                        dba: prefix or noun
                        i: 0
                        min: 12345
                        name: noun
                        r: 1
                        rest: ''
                        s: 0
            - !!perl/hash:RE_method 
              a: 0
              alt: termish_01 1
              dba: prefix or noun
              i: 0
              min: 12345
              name: noun
              r: 1
              rest: ''
              s: 0
      - !!perl/hash:RE_bracket 
        decl: []

        min: 0
        re: !!perl/hash:RE_first 
          a: 0
          dba: postfix
          i: 0
          min: 0
          r: 1
          s: 0
          zyg: 
            - !!perl/hash:RE_sequence 
              a: 0
              dba: postfix
              i: 0
              min: 0
              r: 1
              s: 0
              zyg: 
                - !!perl/hash:RE_assertion 
                  assert: "?"
                  min: 0
                  re: !!perl/hash:RE_block 
                    a: 0
                    context: bool
                    dba: postfix
                    i: 0
                    min: 0
                    nobind: 1
                    r: 1
                    s: 0
                    text: " $*QSIGIL "
                - !!perl/hash:RE_bracket 
                  decl: []

                  min: 0
                  re: !!perl/hash:RE_first 
                    a: 0
                    dba: postfix
                    i: 0
                    min: 0
                    r: 1
                    s: 0
                    zyg: 
                      - !!perl/hash:RE_sequence 
                        a: 0
                        dba: postfix
                        i: 0
                        min: 0
                        r: 1
                        s: 0
                        zyg: 
                          - !!perl/hash:RE_assertion 
                            assert: "?"
                            min: 0
                            re: !!perl/hash:RE_block 
                              a: 0
                              context: bool
                              dba: postfix
                              i: 0
                              min: 0
                              nobind: 1
                              r: 1
                              s: 0
                              text: " $*QSIGIL eq '$' "
                          - !!perl/hash:RE_quantified_atom 
                            atom: !!perl/hash:RE_bracket 
                              decl: []

                              min: 12345
                              re: !!perl/hash:RE_sequence 
                                a: 0
                                dba: postfix
                                i: 0
                                min: 12345
                                r: 1
                                s: 0
                                zyg: 
                                  - !!perl/hash:RE_quantified_atom 
                                    atom: !!perl/hash:RE_method 
                                      a: 0
                                      dba: postfix
                                      i: 0
                                      min: 12345
                                      name: POST
                                      r: 1
                                      rest: ''
                                      s: 0
                                    min: 12345
                                    quant: 
                                      - +
                                      - "!"
                                      - ''
                                      - 1
                                  - !!perl/hash:RE_assertion 
                                    assert: "?"
                                    min: 0
                                    re: !!perl/hash:RE_method_re 
                                      a: 0
                                      dba: postfix
                                      i: 0
                                      min: 0
                                      name: after
                                      nobind: 1
                                      r: 1
                                      re: !!perl/hash:RE 
                                        decl: []

                                        min: 1
                                        re: !!perl/hash:RE_cclass 
                                          a: 0
                                          dba: postfix
                                          i: 0
                                          min: 1
                                          r: 1
                                          s: 0
                                          text: "[ \\] } > ) ]"
                                      s: 0
                            min: 0
                            quant: 
                              - "?"
                              - ":"
                              - ''
                              - 0
                      - !!perl/hash:RE_sequence 
                        a: 0
                        dba: postfix
                        i: 0
                        min: 12345
                        r: 1
                        s: 0
                        zyg: 
                          - !!perl/hash:RE_quantified_atom 
                            atom: !!perl/hash:RE_method 
                              a: 0
                              dba: postfix
                              i: 0
                              min: 12345
                              name: POST
                              r: 1
                              rest: ''
                              s: 0
                            min: 12345
                            quant: 
                              - +
                              - "!"
                              - ''
                              - 1
                          - !!perl/hash:RE_assertion 
                            assert: "?"
                            min: 0
                            re: !!perl/hash:RE_method_re 
                              a: 0
                              dba: postfix
                              i: 0
                              min: 0
                              name: after
                              nobind: 1
                              r: 1
                              re: !!perl/hash:RE 
                                decl: []

                                min: 1
                                re: !!perl/hash:RE_cclass 
                                  a: 0
                                  dba: postfix
                                  i: 0
                                  min: 1
                                  r: 1
                                  s: 0
                                  text: "[ \\] } > ) ]"
                              s: 0
                      - !!perl/hash:RE_block 
                        a: 0
                        context: void
                        dba: postfix
                        i: 0
                        min: 0
                        r: 1
                        s: 0
                        text: " $VAR = 0; "
            - !!perl/hash:RE_sequence 
              a: 0
              dba: postfix
              i: 0
              min: 0
              r: 1
              s: 0
              zyg: 
                - !!perl/hash:RE_assertion 
                  assert: "!"
                  min: 0
                  re: !!perl/hash:RE_block 
                    a: 0
                    context: bool
                    dba: postfix
                    i: 0
                    min: 0
                    nobind: 1
                    r: 1
                    s: 0
                    text: " $*QSIGIL "
                - !!perl/hash:RE_quantified_atom 
                  atom: !!perl/hash:RE_method 
                    a: 0
                    dba: postfix
                    i: 0
                    min: 12345
                    name: POST
                    r: 1
                    rest: ''
                    s: 0
                  min: 0
                  quant: 
                    - "*"
                    - ":"
                    - ''
                    - 0
      - !!perl/hash:RE_block 
        a: 0
        context: void
        dba: postfix
        i: 0
        min: 0
        r: 1
        s: 0
        text: "\n        self.check_variable($VAR) if $VAR;\n        $¢.<~CAPS> = $<noun><~CAPS>;\n    "
termish_01: *43
trait: !!perl/hash:RE 
  decl: 
    - !!perl/hash:RE_decl 
      a: 0
      dba: trait
      i: 0
      max: 0
      min: 0
      r: 1
      s: 1
      text: my $IN_DECL is context<rw> = 0
  kind: rule
  min: 12345
  pkg: ~
  re: !!perl/hash:RE_sequence 
    a: 0
    dba: trait
    i: 0
    min: 12345
    r: 1
    s: 1
    zyg: 
      - !!perl/hash:RE_method 
        min: 0
        name: ws
        nobind: 1
        noquant: 1
        rest: ''
      - !!perl/hash:RE_bracket 
        decl: []

        min: 12345
        re: &67 !!perl/hash:RE_any 
          a: 0
          altname: trait_01
          dba: trait
          i: 0
          min: 12345
          name: trait_01
          r: 1
          s: 1
          zyg: 
            - !!perl/hash:RE_sequence 
              a: 0
              alt: trait_01 0
              dba: trait
              i: 0
              min: 12345
              r: 1
              s: 1
              zyg: 
                - !!perl/hash:RE_method 
                  a: 0
                  dba: trait
                  i: 0
                  min: 12345
                  name: trait_mod
                  r: 1
                  rest: ''
                  s: 1
                - !!perl/hash:RE_method 
                  min: 0
                  name: ws
                  nobind: 1
                  noquant: 1
                  rest: ''
            - !!perl/hash:RE_sequence 
              a: 0
              alt: trait_01 1
              dba: trait
              i: 0
              min: 12345
              r: 1
              s: 1
              zyg: 
                - !!perl/hash:RE_method 
                  a: 0
                  dba: trait
                  i: 0
                  min: 12345
                  name: colonpair
                  r: 1
                  rest: ''
                  s: 1
                - !!perl/hash:RE_method 
                  min: 0
                  name: ws
                  nobind: 1
                  noquant: 1
                  rest: ''
      - !!perl/hash:RE_method 
        min: 0
        name: ws
        nobind: 1
        noquant: 1
        rest: ''
trait_01: *67
trait_mod__S_104is: !!perl/hash:RE 
  decl: []

  kind: token
  min: 37035
  pkg: ~
  re: !!perl/hash:RE_sequence 
    a: 0
    dba: trait_mod__S_104is
    i: 0
    min: 37035
    r: 1
    s: 1
    zyg: 
      - !!perl/hash:RE_method 
        a: 0
        dba: trait_mod__S_104is
        endsym: spacey
        i: 0
        min: 12345
        name: sym
        r: 1
        rest: ''
        s: 0
        sym: is
      - !!perl/hash:RE_method 
        a: 0
        dba: trait_mod__S_104is
        i: 0
        min: 12345
        name: spacey
        nobind: 1
        r: 1
        rest: ''
        s: 0
      - !!perl/hash:RE_method 
        min: 0
        name: ws
        nobind: 1
        noquant: 1
        rest: ''
      - !!perl/hash:RE_method 
        a: 0
        dba: trait_mod__S_104is
        i: 0
        min: 12345
        name: longname
        r: 1
        rest: ''
        s: 1
      - !!perl/hash:RE_quantified_atom 
        atom: !!perl/hash:RE_method 
          a: 0
          dba: trait_mod__S_104is
          i: 0
          min: 12345
          name: circumfix
          r: 1
          rest: ''
          s: 1
        min: 0
        quant: 
          - "?"
          - ":"
          - ''
          - 0
      - !!perl/hash:RE_method 
        min: 0
        name: ws
        nobind: 1
        noquant: 1
        rest: ''
      - !!perl/hash:RE_block 
        a: 0
        context: void
        dba: trait_mod__S_104is
        i: 0
        min: 0
        r: 1
        s: 1
        text: "\n        if $*DECLARAND {\n            my $traitname = $<longname>.Str;\n            # XXX eventually will use multiple dispatch\n            $*DECLARAND{$traitname} = self.gettrait($traitname, $<circumfix>);\n        }\n    "
      - !!perl/hash:RE_method 
        min: 0
        name: ws
        nobind: 1
        noquant: 1
        rest: ''
trait_mod__S_105hides: !!perl/hash:RE 
  decl: []

  kind: token
  min: 37035
  pkg: ~
  re: !!perl/hash:RE_sequence 
    a: 0
    dba: trait_mod__S_105hides
    i: 0
    min: 37035
    r: 1
    s: 1
    zyg: 
      - !!perl/hash:RE_method 
        a: 0
        dba: trait_mod__S_105hides
        endsym: spacey
        i: 0
        min: 12345
        name: sym
        r: 1
        rest: ''
        s: 0
        sym: hides
      - !!perl/hash:RE_method 
        a: 0
        dba: trait_mod__S_105hides
        i: 0
        min: 12345
        name: spacey
        nobind: 1
        r: 1
        rest: ''
        s: 0
      - !!perl/hash:RE_method 
        min: 0
        name: ws
        nobind: 1
        noquant: 1
        rest: ''
      - !!perl/hash:RE_method 
        a: 0
        dba: trait_mod__S_105hides
        i: 0
        min: 12345
        name: module_name
        r: 1
        rest: ''
        s: 1
      - !!perl/hash:RE_method 
        min: 0
        name: ws
        nobind: 1
        noquant: 1
        rest: ''
trait_mod__S_106does: !!perl/hash:RE 
  decl: 
    - !!perl/hash:RE_decl 
      a: 0
      dba: trait_mod__S_106does
      i: 0
      max: 0
      min: 0
      r: 1
      s: 0
      text: my $PKGDECL is context = 'role'
  kind: token
  min: 37035
  pkg: ~
  re: !!perl/hash:RE_sequence 
    a: 0
    dba: trait_mod__S_106does
    i: 0
    min: 37035
    r: 1
    s: 1
    zyg: 
      - !!perl/hash:RE_method 
        a: 0
        dba: trait_mod__S_106does
        endsym: spacey
        i: 0
        min: 12345
        name: sym
        r: 1
        rest: ''
        s: 0
        sym: does
      - !!perl/hash:RE_method 
        a: 0
        dba: trait_mod__S_106does
        i: 0
        min: 12345
        name: spacey
        nobind: 1
        r: 1
        rest: ''
        s: 0
      - !!perl/hash:RE_method 
        min: 0
        name: ws
        nobind: 1
        noquant: 1
        rest: ''
      - !!perl/hash:RE_method 
        a: 0
        dba: trait_mod__S_106does
        i: 0
        min: 12345
        name: module_name
        r: 1
        rest: ''
        s: 1
      - !!perl/hash:RE_method 
        min: 0
        name: ws
        nobind: 1
        noquant: 1
        rest: ''
trait_mod__S_107will: !!perl/hash:RE 
  decl: []

  kind: token
  min: 49380
  pkg: ~
  re: !!perl/hash:RE_sequence 
    a: 0
    dba: trait_mod__S_107will
    i: 0
    min: 49380
    r: 1
    s: 1
    zyg: 
      - !!perl/hash:RE_method 
        a: 0
        dba: trait_mod__S_107will
        endsym: spacey
        i: 0
        min: 12345
        name: sym
        r: 1
        rest: ''
        s: 0
        sym: will
      - !!perl/hash:RE_method 
        a: 0
        dba: trait_mod__S_107will
        i: 0
        min: 12345
        name: spacey
        nobind: 1
        r: 1
        rest: ''
        s: 0
      - !!perl/hash:RE_method 
        min: 0
        name: ws
        nobind: 1
        noquant: 1
        rest: ''
      - !!perl/hash:RE_method 
        a: 0
        dba: trait_mod__S_107will
        i: 0
        min: 12345
        name: identifier
        r: 1
        rest: ''
        s: 1
      - !!perl/hash:RE_method 
        min: 0
        name: ws
        nobind: 1
        noquant: 1
        rest: ''
      - !!perl/hash:RE_method 
        a: 0
        dba: trait_mod__S_107will
        i: 0
        min: 12345
        name: block
        r: 1
        rest: ''
        s: 1
      - !!perl/hash:RE_method 
        min: 0
        name: ws
        nobind: 1
        noquant: 1
        rest: ''
trait_mod__S_108of: !!perl/hash:RE 
  decl: []

  kind: token
  min: 37035
  pkg: ~
  re: !!perl/hash:RE_sequence 
    a: 0
    dba: trait_mod__S_108of
    i: 0
    min: 37035
    r: 1
    s: 1
    zyg: 
      - !!perl/hash:RE_method 
        a: 0
        dba: trait_mod__S_108of
        endsym: spacey
        i: 0
        min: 12345
        name: sym
        r: 1
        rest: ''
        s: 0
        sym: of
      - !!perl/hash:RE_method 
        a: 0
        dba: trait_mod__S_108of
        i: 0
        min: 12345
        name: spacey
        nobind: 1
        r: 1
        rest: ''
        s: 0
      - !!perl/hash:RE_method 
        min: 0
        name: ws
        nobind: 1
        noquant: 1
        rest: ''
      - !!perl/hash:RE_method 
        a: 0
        dba: trait_mod__S_108of
        i: 0
        min: 12345
        name: typename
        r: 1
        rest: ''
        s: 1
      - !!perl/hash:RE_method 
        min: 0
        name: ws
        nobind: 1
        noquant: 1
        rest: ''
trait_mod__S_109as: !!perl/hash:RE 
  decl: []

  kind: token
  min: 37035
  pkg: ~
  re: !!perl/hash:RE_sequence 
    a: 0
    dba: trait_mod__S_109as
    i: 0
    min: 37035
    r: 1
    s: 1
    zyg: 
      - !!perl/hash:RE_method 
        a: 0
        dba: trait_mod__S_109as
        endsym: spacey
        i: 0
        min: 12345
        name: sym
        r: 1
        rest: ''
        s: 0
        sym: as
      - !!perl/hash:RE_method 
        a: 0
        dba: trait_mod__S_109as
        i: 0
        min: 12345
        name: spacey
        nobind: 1
        r: 1
        rest: ''
        s: 0
      - !!perl/hash:RE_method 
        min: 0
        name: ws
        nobind: 1
        noquant: 1
        rest: ''
      - !!perl/hash:RE_method 
        a: 0
        dba: trait_mod__S_109as
        i: 0
        min: 12345
        name: typename
        r: 1
        rest: ''
        s: 1
      - !!perl/hash:RE_method 
        min: 0
        name: ws
        nobind: 1
        noquant: 1
        rest: ''
trait_mod__S_110returns: !!perl/hash:RE 
  decl: []

  kind: token
  min: 37035
  pkg: ~
  re: !!perl/hash:RE_sequence 
    a: 0
    dba: trait_mod__S_110returns
    i: 0
    min: 37035
    r: 1
    s: 1
    zyg: 
      - !!perl/hash:RE_method 
        a: 0
        dba: trait_mod__S_110returns
        endsym: spacey
        i: 0
        min: 12345
        name: sym
        r: 1
        rest: ''
        s: 0
        sym: returns
      - !!perl/hash:RE_method 
        a: 0
        dba: trait_mod__S_110returns
        i: 0
        min: 12345
        name: spacey
        nobind: 1
        r: 1
        rest: ''
        s: 0
      - !!perl/hash:RE_method 
        min: 0
        name: ws
        nobind: 1
        noquant: 1
        rest: ''
      - !!perl/hash:RE_method 
        a: 0
        dba: trait_mod__S_110returns
        i: 0
        min: 12345
        name: typename
        r: 1
        rest: ''
        s: 1
      - !!perl/hash:RE_method 
        min: 0
        name: ws
        nobind: 1
        noquant: 1
        rest: ''
trait_mod__S_111handles: !!perl/hash:RE 
  decl: []

  kind: token
  min: 37035
  pkg: ~
  re: !!perl/hash:RE_sequence 
    a: 0
    dba: trait_mod__S_111handles
    i: 0
    min: 37035
    r: 1
    s: 1
    zyg: 
      - !!perl/hash:RE_method 
        a: 0
        dba: trait_mod__S_111handles
        endsym: spacey
        i: 0
        min: 12345
        name: sym
        r: 1
        rest: ''
        s: 0
        sym: handles
      - !!perl/hash:RE_method 
        a: 0
        dba: trait_mod__S_111handles
        i: 0
        min: 12345
        name: spacey
        nobind: 1
        r: 1
        rest: ''
        s: 0
      - !!perl/hash:RE_method 
        min: 0
        name: ws
        nobind: 1
        noquant: 1
        rest: ''
      - !!perl/hash:RE_method 
        a: 0
        dba: trait_mod__S_111handles
        i: 0
        min: 12345
        name: noun
        r: 1
        rest: ''
        s: 1
      - !!perl/hash:RE_method 
        min: 0
        name: ws
        nobind: 1
        noquant: 1
        rest: ''
tribble: !!perl/hash:RE 
  decl: 
    - !!perl/hash:RE_decl 
      a: 0
      dba: tribble
      i: 0
      max: 0
      min: 0
      r: 1
      s: 0
      text: my ($lang, $start, $stop)
  kind: token
  min: 0
  pkg: ~
  re: !!perl/hash:RE_sequence 
    a: 0
    dba: tribble
    i: 0
    min: 0
    r: 1
    s: 0
    zyg: 
      - !!perl/hash:RE_method 
        min: 0
        name: babble
        rest: ($l)
      - !!perl/hash:RE_block 
        a: 0
        context: void
        dba: tribble
        i: 0
        min: 0
        r: 1
        s: 0
        text: " my $B = $<babble><B>; ($lang,$start,$stop) = @$B; "
      - !!perl/hash:RE_var 
        a: 0
        dba: tribble
        i: 0
        min: 0
        r: 1
        s: 0
        var: $start
      - !!perl/hash:RE_bindnamed 
        a: 0
        atom: !!perl/hash:RE_method 
          min: 0
          name: nibble
          nobind: 1
          rest: ($lang)
        dba: tribble
        i: 0
        min: 0
        r: 1
        s: 0
        var: left
      - !!perl/hash:RE_bracket 
        decl: []

        min: 0
        re: !!perl/hash:RE_first 
          a: 0
          dba: tribble
          i: 0
          min: 0
          r: 1
          s: 0
          zyg: 
            - !!perl/hash:RE_var 
              a: 0
              dba: tribble
              i: 0
              min: 0
              r: 1
              s: 0
              var: $stop
            - !!perl/hash:RE_method 
              min: 0
              name: panic
              nobind: 1
              rest: ("Couldn't find terminator $stop")
      - !!perl/hash:RE_bracket 
        decl: []

        min: 0
        re: !!perl/hash:RE_first 
          a: 0
          dba: tribble
          i: 0
          min: 0
          r: 1
          s: 0
          zyg: 
            - !!perl/hash:RE_sequence 
              a: 0
              dba: tribble
              i: 0
              min: 12345
              r: 1
              s: 0
              zyg: 
                - !!perl/hash:RE_assertion 
                  assert: "?"
                  min: 0
                  re: !!perl/hash:RE_block 
                    a: 0
                    context: bool
                    dba: tribble
                    i: 0
                    min: 0
                    nobind: 1
                    r: 1
                    s: 0
                    text: " $start ne $stop "
                - !!perl/hash:RE_method 
                  a: 0
                  dba: tribble
                  i: 0
                  min: 12345
                  name: ws
                  nobind: 1
                  r: 1
                  rest: ''
                  s: 0
                - !!perl/hash:RE_method 
                  min: 0
                  name: quibble
                  rest: ($lang2)
            - !!perl/hash:RE_sequence 
              a: 0
              dba: tribble
              i: 0
              min: 0
              r: 1
              s: 0
              zyg: 
                - !!perl/hash:RE_block 
                  a: 0
                  context: void
                  dba: tribble
                  i: 0
                  min: 0
                  r: 1
                  s: 0
                  text: " $lang = $lang2.unbalanced($stop); "
                - !!perl/hash:RE_bindnamed 
                  a: 0
                  atom: !!perl/hash:RE_method 
                    min: 0
                    name: nibble
                    nobind: 1
                    rest: ($lang)
                  dba: tribble
                  i: 0
                  min: 0
                  r: 1
                  s: 0
                  var: right
                - !!perl/hash:RE_var 
                  a: 0
                  dba: tribble
                  i: 0
                  min: 0
                  r: 1
                  s: 0
                  var: $stop
twigil__S_177Dot: !!perl/hash:RE 
  decl: []

  kind: token
  min: 12345
  pkg: ~
  re: !!perl/hash:RE_method 
    a: 0
    dba: twigil__S_177Dot
    i: 0
    min: 12345
    name: sym
    r: 1
    rest: ''
    s: 0
    sym: .
twigil__S_178Bang: !!perl/hash:RE 
  decl: []

  kind: token
  min: 12345
  pkg: ~
  re: !!perl/hash:RE_method 
    a: 0
    dba: twigil__S_178Bang
    i: 0
    min: 12345
    name: sym
    r: 1
    rest: ''
    s: 0
    sym: "!"
twigil__S_179Caret: !!perl/hash:RE 
  decl: []

  kind: token
  min: 12345
  pkg: ~
  re: !!perl/hash:RE_method 
    a: 0
    dba: twigil__S_179Caret
    i: 0
    min: 12345
    name: sym
    r: 1
    rest: ''
    s: 0
    sym: "^"
twigil__S_180Colon: !!perl/hash:RE 
  decl: []

  kind: token
  min: 12345
  pkg: ~
  re: !!perl/hash:RE_sequence 
    a: 0
    dba: twigil__S_180Colon
    i: 0
    min: 12345
    r: 1
    s: 0
    zyg: 
      - !!perl/hash:RE_method 
        a: 0
        dba: twigil__S_180Colon
        i: 0
        min: 12345
        name: sym
        r: 1
        rest: ''
        s: 0
        sym: ":"
      - !!perl/hash:RE_assertion 
        assert: "!"
        min: 0
        re: !!perl/hash:RE_method_re 
          a: 0
          dba: twigil__S_180Colon
          i: 0
          min: 0
          name: before
          nobind: 1
          r: 1
          re: !!perl/hash:RE 
            decl: []

            min: 1
            re: !!perl/hash:RE_string 
              a: 0
              dba: twigil__S_180Colon
              i: 0
              min: 1
              r: 1
              s: 0
              text: ":"
          s: 0
twigil__S_181Star: !!perl/hash:RE 
  decl: []

  kind: token
  min: 12345
  pkg: ~
  re: !!perl/hash:RE_method 
    a: 0
    dba: twigil__S_181Star
    i: 0
    min: 12345
    name: sym
    r: 1
    rest: ''
    s: 0
    sym: "*"
twigil__S_182Plus: !!perl/hash:RE 
  decl: []

  kind: token
  min: 12345
  pkg: ~
  re: !!perl/hash:RE_sequence 
    a: 0
    dba: twigil__S_182Plus
    i: 0
    min: 12345
    r: 1
    s: 0
    zyg: 
      - !!perl/hash:RE_method 
        a: 0
        dba: twigil__S_182Plus
        i: 0
        min: 12345
        name: sym
        r: 1
        rest: ''
        s: 0
        sym: +
      - !!perl/hash:RE_assertion 
        assert: "!"
        min: 0
        re: !!perl/hash:RE_assertion 
          assert: "!"
          min: 0
          nobind: 1
          re: !!perl/hash:RE_method 
            min: 0
            name: worry
            nobind: 1
            rest: ("The + twigil is deprecated, use the * twigil instead")
twigil__S_183Question: !!perl/hash:RE 
  decl: []

  kind: token
  min: 12345
  pkg: ~
  re: !!perl/hash:RE_method 
    a: 0
    dba: twigil__S_183Question
    i: 0
    min: 12345
    name: sym
    r: 1
    rest: ''
    s: 0
    sym: "?"
twigil__S_184Equal: !!perl/hash:RE 
  decl: []

  kind: token
  min: 12345
  pkg: ~
  re: !!perl/hash:RE_method 
    a: 0
    dba: twigil__S_184Equal
    i: 0
    min: 12345
    name: sym
    r: 1
    rest: ''
    s: 0
    sym: =
twigil__S_185Tilde: !!perl/hash:RE 
  decl: []

  kind: token
  min: 12345
  pkg: ~
  re: !!perl/hash:RE_method 
    a: 0
    dba: twigil__S_185Tilde
    i: 0
    min: 12345
    name: sym
    r: 1
    rest: ''
    s: 0
    sym: '~'
type_constraint: !!perl/hash:RE 
  decl: []

  kind: token
  min: 24690
  pkg: ~
  re: !!perl/hash:RE_sequence 
    a: 0
    dba: type_constraint
    i: 0
    min: 24690
    r: 1
    s: 0
    zyg: 
      - !!perl/hash:RE_bracket 
        decl: []

        min: 12345
        re: &15 !!perl/hash:RE_any 
          a: 0
          altname: type_constraint_01
          dba: type_constraint
          i: 0
          min: 12345
          name: type_constraint_01
          r: 1
          s: 0
          zyg: 
            - !!perl/hash:RE_method 
              a: 0
              alt: type_constraint_01 0
              dba: type_constraint
              i: 0
              min: 12345
              name: value
              r: 1
              rest: ''
              s: 0
            - !!perl/hash:RE_method 
              a: 0
              alt: type_constraint_01 1
              dba: type_constraint
              i: 0
              min: 12345
              name: typename
              r: 1
              rest: ''
              s: 0
            - !!perl/hash:RE_sequence 
              a: 0
              alt: type_constraint_01 2
              dba: type_constraint
              i: 0
              min: 12350
              r: 1
              s: 0
              zyg: 
                - !!perl/hash:RE_string 
                  a: 0
                  dba: type_constraint
                  i: 0
                  min: 5
                  r: 1
                  s: 0
                  text: where
                - !!perl/hash:RE_method 
                  a: 0
                  dba: type_constraint
                  i: 0
                  min: 12345
                  name: ws
                  nobind: 1
                  r: 1
                  rest: ''
                  s: 0
                - !!perl/hash:RE_method 
                  min: 0
                  name: EXPR
                  rest: (item %chaining)
      - !!perl/hash:RE_method 
        a: 0
        dba: type_constraint
        i: 0
        min: 12345
        name: ws
        nobind: 1
        r: 1
        rest: ''
        s: 0
type_constraint_01: *15
type_declarator__S_253subset: !!perl/hash:RE 
  decl: []

  kind: token
  min: 0
  pkg: ~
  re: !!perl/hash:RE_first 
    a: 0
    dba: type_declarator__S_253subset
    i: 0
    min: 0
    r: 1
    s: 1
    zyg: 
      - !!perl/hash:RE_sequence 
        a: 0
        dba: type_declarator__S_253subset
        i: 0
        min: 37035
        r: 1
        s: 1
        zyg: 
          - !!perl/hash:RE_method 
            a: 0
            dba: type_declarator__S_253subset
            endsym: spacey
            i: 0
            min: 12345
            name: sym
            r: 1
            rest: ''
            s: 0
            sym: subset
          - !!perl/hash:RE_method 
            a: 0
            dba: type_declarator__S_253subset
            i: 0
            min: 12345
            name: spacey
            nobind: 1
            r: 1
            rest: ''
            s: 0
          - !!perl/hash:RE_method 
            min: 0
            name: ws
            nobind: 1
            noquant: 1
            rest: ''
          - !!perl/hash:RE_bracket 
            decl: []

            min: 12345
            re: !!perl/hash:RE_sequence 
              a: 0
              dba: type_declarator__S_253subset
              i: 0
              min: 12345
              r: 1
              s: 1
              zyg: 
                - !!perl/hash:RE_method 
                  a: 0
                  dba: type_declarator__S_253subset
                  i: 0
                  min: 12345
                  name: longname
                  r: 1
                  rest: ''
                  s: 1
                - !!perl/hash:RE_method 
                  min: 0
                  name: ws
                  nobind: 1
                  noquant: 1
                  rest: ''
                - !!perl/hash:RE_block 
                  a: 0
                  context: void
                  dba: type_declarator__S_253subset
                  i: 0
                  min: 0
                  r: 1
                  s: 1
                  text: " $¢.add_name($<longname>.Str); "
                - !!perl/hash:RE_method 
                  min: 0
                  name: ws
                  nobind: 1
                  noquant: 1
                  rest: ''
                - !!perl/hash:RE_quantified_atom 
                  atom: !!perl/hash:RE_bracket 
                    decl: []

                    min: 24692
                    re: !!perl/hash:RE_sequence 
                      a: 0
                      dba: type_declarator__S_253subset
                      i: 0
                      min: 24692
                      r: 1
                      s: 1
                      zyg: 
                        - !!perl/hash:RE_method 
                          min: 0
                          name: ws
                          nobind: 1
                          noquant: 1
                          rest: ''
                        - !!perl/hash:RE_string 
                          a: 0
                          dba: type_declarator__S_253subset
                          i: 0
                          min: 2
                          r: 1
                          s: 1
                          text: of
                        - !!perl/hash:RE_method 
                          min: 0
                          name: ws
                          nobind: 1
                          noquant: 1
                          rest: ''
                        - !!perl/hash:RE_method 
                          a: 0
                          dba: type_declarator__S_253subset
                          i: 0
                          min: 12345
                          name: ws
                          nobind: 1
                          r: 1
                          rest: ''
                          s: 1
                        - !!perl/hash:RE_method 
                          min: 0
                          name: ws
                          nobind: 1
                          noquant: 1
                          rest: ''
                        - !!perl/hash:RE_method 
                          a: 0
                          dba: type_declarator__S_253subset
                          i: 0
                          min: 12345
                          name: typename
                          r: 1
                          rest: ''
                          s: 1
                        - !!perl/hash:RE_method 
                          min: 0
                          name: ws
                          nobind: 1
                          noquant: 1
                          rest: ''
                  min: 0
                  quant: 
                    - "?"
                    - ":"
                    - ''
                    - 0
                - !!perl/hash:RE_method 
                  min: 0
                  name: ws
                  nobind: 1
                  noquant: 1
                  rest: ''
                - !!perl/hash:RE_quantified_atom 
                  atom: !!perl/hash:RE_method 
                    a: 0
                    dba: type_declarator__S_253subset
                    i: 0
                    min: 12345
                    name: trait
                    r: 1
                    rest: ''
                    s: 1
                  min: 0
                  quant: 
                    - "*"
                    - ":"
                    - ''
                    - 0
                - !!perl/hash:RE_method 
                  min: 0
                  name: ws
                  nobind: 1
                  noquant: 1
                  rest: ''
                - !!perl/hash:RE_quantified_atom 
                  atom: !!perl/hash:RE_bracket 
                    decl: []

                    min: 5
                    re: !!perl/hash:RE_sequence 
                      a: 0
                      dba: type_declarator__S_253subset
                      i: 0
                      min: 5
                      r: 1
                      s: 1
                      zyg: 
                        - !!perl/hash:RE_string 
                          a: 0
                          dba: type_declarator__S_253subset
                          i: 0
                          min: 5
                          r: 1
                          s: 1
                          text: where
                        - !!perl/hash:RE_method 
                          min: 0
                          name: ws
                          nobind: 1
                          noquant: 1
                          rest: ''
                        - !!perl/hash:RE_method 
                          min: 0
                          name: EXPR
                          rest: (item %chaining)
                        - !!perl/hash:RE_method 
                          min: 0
                          name: ws
                          nobind: 1
                          noquant: 1
                          rest: ''
                  min: 0
                  quant: 
                    - "?"
                    - ":"
                    - ''
                    - 0
                - !!perl/hash:RE_method 
                  min: 0
                  name: ws
                  nobind: 1
                  noquant: 1
                  rest: ''
          - !!perl/hash:RE_method 
            min: 0
            name: ws
            nobind: 1
            noquant: 1
            rest: ''
      - !!perl/hash:RE_sequence 
        a: 0
        dba: type_declarator__S_253subset
        i: 0
        min: 0
        r: 1
        s: 1
        zyg: 
          - !!perl/hash:RE_method 
            min: 0
            name: ws
            nobind: 1
            noquant: 1
            rest: ''
          - !!perl/hash:RE_method 
            min: 0
            name: panic
            nobind: 1
            rest: ("Malformed subset")
          - !!perl/hash:RE_method 
            min: 0
            name: ws
            nobind: 1
            noquant: 1
            rest: ''
type_declarator__S_254enum: !!perl/hash:RE 
  decl: []

  kind: token
  min: 86415
  pkg: ~
  re: !!perl/hash:RE_sequence 
    a: 0
    dba: type_declarator__S_254enum
    i: 0
    min: 86415
    r: 1
    s: 0
    zyg: 
      - !!perl/hash:RE_method 
        a: 0
        dba: type_declarator__S_254enum
        endsym: spacey
        i: 0
        min: 12345
        name: sym
        r: 1
        rest: ''
        s: 0
        sym: enum
      - !!perl/hash:RE_method 
        a: 0
        dba: type_declarator__S_254enum
        i: 0
        min: 12345
        name: spacey
        nobind: 1
        r: 1
        rest: ''
        s: 0
      - !!perl/hash:RE_method 
        a: 0
        dba: type_declarator__S_254enum
        i: 0
        min: 12345
        name: ws
        nobind: 1
        r: 1
        rest: ''
        s: 0
      - !!perl/hash:RE_method 
        a: 0
        dba: type_declarator__S_254enum
        i: 0
        min: 12345
        name: longname
        r: 1
        rest: ''
        s: 0
      - !!perl/hash:RE_method 
        a: 0
        dba: type_declarator__S_254enum
        i: 0
        min: 12345
        name: ws
        nobind: 1
        r: 1
        rest: ''
        s: 0
      - !!perl/hash:RE_quantified_atom 
        atom: !!perl/hash:RE_method 
          a: 0
          dba: type_declarator__S_254enum
          i: 0
          min: 12345
          name: trait
          r: 1
          rest: ''
          s: 0
        min: 0
        quant: 
          - "*"
          - ":"
          - ''
          - 0
      - !!perl/hash:RE_assertion 
        assert: "?"
        min: 0
        re: !!perl/hash:RE_method_re 
          a: 0
          dba: type_declarator__S_254enum
          i: 0
          min: 0
          name: before
          nobind: 1
          r: 1
          re: !!perl/hash:RE 
            decl: []

            min: 1
            re: !!perl/hash:RE_cclass 
              a: 0
              dba: type_declarator__S_254enum
              i: 0
              min: 1
              r: 1
              s: 0
              text: "[ < ( « ]"
          s: 0
      - !!perl/hash:RE_method 
        a: 0
        dba: type_declarator__S_254enum
        i: 0
        min: 12345
        name: noun
        r: 1
        rest: ''
        s: 0
      - !!perl/hash:RE_method 
        a: 0
        dba: type_declarator__S_254enum
        i: 0
        min: 12345
        name: ws
        nobind: 1
        r: 1
        rest: ''
        s: 0
      - !!perl/hash:RE_block 
        a: 0
        context: void
        dba: type_declarator__S_254enum
        i: 0
        min: 0
        r: 1
        s: 0
        text: " $¢.add_name($<longname>.Str); $¢.add_enum($<longname>.Str, $<noun>.Str); "
typename: !!perl/hash:RE 
  decl: []

  kind: token
  min: 24690
  pkg: ~
  re: !!perl/hash:RE_sequence 
    a: 0
    dba: typename
    i: 0
    min: 24690
    r: 1
    s: 0
    zyg: 
      - !!perl/hash:RE_bracket 
        decl: []

        min: 12345
        re: &119 !!perl/hash:RE_any 
          a: 0
          altname: typename_01
          dba: typename
          i: 0
          min: 12345
          name: typename_01
          r: 1
          s: 0
          zyg: 
            - !!perl/hash:RE_sequence 
              a: 0
              alt: typename_01 0
              dba: typename
              i: 0
              min: 12348
              r: 1
              s: 0
              zyg: 
                - !!perl/hash:RE_string 
                  a: 0
                  dba: typename
                  i: 0
                  min: 3
                  r: 1
                  s: 0
                  text: ::?
                - !!perl/hash:RE_method 
                  a: 0
                  dba: typename
                  i: 0
                  min: 12345
                  name: identifier
                  r: 1
                  rest: ''
                  s: 0
            - !!perl/hash:RE_sequence 
              a: 0
              alt: typename_01 1
              dba: typename
              i: 0
              min: 12345
              r: 1
              s: 0
              zyg: 
                - !!perl/hash:RE_method 
                  a: 0
                  dba: typename
                  i: 0
                  min: 12345
                  name: longname
                  r: 1
                  rest: ''
                  s: 0
                - !!perl/hash:RE_assertion 
                  assert: "?"
                  min: 0
                  re: !!perl/hash:RE_block 
                    a: 0
                    context: bool
                    dba: typename
                    i: 0
                    min: 0
                    nobind: 1
                    r: 1
                    s: 0
                    text: "\n        my $longname = $<longname>.Str;\n        if substr($longname, 0, 2) eq '::' {\n            $¢.add_my_name(substr($longname, 2));\n        }\n        else {\n            $¢.is_name($longname)\n        }\n      "
      - !!perl/hash:RE_quantified_atom 
        atom: !!perl/hash:RE_method 
          a: 0
          dba: typename
          i: 0
          min: 12345
          name: unsp
          nobind: 1
          r: 1
          rest: ''
          s: 0
        min: 0
        quant: 
          - "?"
          - ":"
          - ''
          - 0
      - !!perl/hash:RE_quantified_atom 
        atom: !!perl/hash:RE_bracket 
          decl: []

          min: 12345
          re: !!perl/hash:RE_sequence 
            a: 0
            dba: typename
            i: 0
            min: 12345
            r: 1
            s: 0
            zyg: 
              - !!perl/hash:RE_assertion 
                assert: "?"
                min: 0
                re: !!perl/hash:RE_method_re 
                  a: 0
                  dba: typename
                  i: 0
                  min: 0
                  name: before
                  nobind: 1
                  r: 1
                  re: !!perl/hash:RE 
                    decl: []

                    min: 1
                    re: !!perl/hash:RE_string 
                      a: 0
                      dba: typename
                      i: 0
                      min: 1
                      r: 1
                      s: 0
                      text: "["
                  s: 0
              - !!perl/hash:RE_method 
                a: 0
                dba: typename
                i: 0
                min: 12345
                name: postcircumfix
                r: 1
                rest: ''
                s: 0
        min: 0
        quant: 
          - "?"
          - ":"
          - ''
          - 0
      - !!perl/hash:RE_method 
        a: 0
        dba: typename
        i: 0
        min: 12345
        name: ws
        nobind: 1
        r: 1
        rest: ''
        s: 0
      - !!perl/hash:RE_quantified_atom 
        atom: !!perl/hash:RE_bracket 
          decl: []

          min: 24692
          re: !!perl/hash:RE_sequence 
            a: 0
            dba: typename
            i: 0
            min: 24692
            r: 1
            s: 0
            zyg: 
              - !!perl/hash:RE_string 
                a: 0
                dba: typename
                i: 0
                min: 2
                r: 1
                s: 0
                text: of
              - !!perl/hash:RE_method 
                a: 0
                dba: typename
                i: 0
                min: 12345
                name: ws
                nobind: 1
                r: 1
                rest: ''
                s: 0
              - !!perl/hash:RE_method 
                a: 0
                dba: typename
                i: 0
                min: 12345
                name: typename
                r: 1
                rest: ''
                s: 0
        min: 0
        quant: 
          - "?"
          - ":"
          - ''
          - 0
typename_01: *119
unitstopper: !!perl/hash:RE 
  decl: []

  kind: token
  min: 0
  pkg: ~
  re: !!perl/hash:RE_meta 
    a: 0
    dba: unitstopper
    i: 0
    min: 0
    r: 1
    s: 0
    text: $
unsp: !!perl/hash:RE 
  decl: []

  kind: token
  min: 1
  pkg: ~
  re: !!perl/hash:RE_sequence 
    a: 0
    dba: unspace
    i: 0
    min: 1
    r: 1
    s: 0
    zyg: 
      - !!perl/hash:RE_string 
        a: 0
        dba: unsp
        i: 0
        min: 1
        r: 1
        s: 0
        text: \
      - !!perl/hash:RE_assertion 
        assert: "?"
        min: 0
        re: !!perl/hash:RE_method_re 
          a: 0
          dba: unsp
          i: 0
          min: 0
          name: before
          nobind: 1
          r: 1
          re: !!perl/hash:RE 
            decl: []

            min: 1
            re: !!perl/hash:RE_bracket 
              decl: []

              min: 1
              re: &35 !!perl/hash:RE_any 
                a: 0
                altname: unsp_02
                dba: unsp
                i: 0
                min: 1
                name: unsp_02
                r: 1
                s: 0
                zyg: 
                  - !!perl/hash:RE_meta 
                    a: 0
                    alt: unsp_02 0
                    dba: unsp
                    i: 0
                    min: 1
                    r: 1
                    s: 0
                    text: \s
                  - !!perl/hash:RE_string 
                    a: 0
                    alt: unsp_02 1
                    dba: unsp
                    i: 0
                    min: 1
                    r: 1
                    s: 0
                    text: "#"
          s: 0
      - !!perl/hash:RE_quantified_atom 
        atom: !!perl/hash:RE_bracket 
          decl: []

          min: 0
          re: &20 !!perl/hash:RE_any 
            a: 0
            altname: unsp_03
            dba: unspace
            i: 0
            min: 0
            name: unsp_03
            r: 1
            s: 0
            zyg: 
              - !!perl/hash:RE_sequence 
                a: 0
                alt: unsp_03 0
                dba: unspace
                i: 0
                min: 12345
                r: 1
                s: 0
                zyg: 
                  - !!perl/hash:RE_method 
                    a: 0
                    dba: unspace
                    i: 0
                    min: 12345
                    name: vws
                    nobind: 1
                    r: 1
                    rest: ''
                    s: 0
                  - !!perl/hash:RE_method_internal 
                    args: $S, 'unsp', 'vwhite'
                    max: 0
                    min: 0
                    name: _REDUCE
              - !!perl/hash:RE_sequence 
                a: 0
                alt: unsp_03 1
                dba: unspace
                i: 0
                min: 12345
                r: 1
                s: 0
                zyg: 
                  - !!perl/hash:RE_method 
                    a: 0
                    dba: unspace
                    i: 0
                    min: 12345
                    name: unv
                    nobind: 1
                    r: 1
                    rest: ''
                    s: 0
                  - !!perl/hash:RE_method_internal 
                    args: $S, 'unsp', 'unv'
                    max: 0
                    min: 0
                    name: _REDUCE
              - !!perl/hash:RE_sequence 
                a: 0
                alt: unsp_03 2
                dba: unspace
                i: 0
                min: 0
                r: 1
                s: 0
                zyg: 
                  - !!perl/hash:RE_meta 
                    a: 0
                    dba: unspace
                    i: 0
                    min: 0
                    r: 1
                    s: 0
                    text: $
                  - !!perl/hash:RE_block 
                    a: 0
                    context: void
                    dba: unspace
                    i: 0
                    min: 0
                    r: 1
                    s: 0
                    text: " $¢.moreinput "
        min: 0
        quant: 
          - "*"
          - ":"
          - ''
          - 0
unsp_02: *35
unsp_03: *20
unspacey: !!perl/hash:RE 
  decl: []

  kind: token
  min: 0
  pkg: ~
  re: !!perl/hash:RE_quantified_atom 
    atom: !!perl/hash:RE_method 
      a: 0
      dba: unspacey
      i: 0
      min: 12345
      name: unsp
      nobind: 1
      r: 1
      rest: ''
      s: 0
    min: 0
    quant: 
      - "?"
      - ":"
      - ''
      - 0
unv: !!perl/hash:RE 
  decl: []

  kind: token
  min: 1
  pkg: ~
  re: !!perl/hash:RE_bracket 
    decl: []

    min: 1
    re: &3 !!perl/hash:RE_any 
      a: 0
      altname: unv_01
      dba: horizontal whitespace
      i: 0
      min: 1
      name: unv_01
      r: 1
      s: 0
      zyg: 
        - !!perl/hash:RE_sequence 
          a: 0
          alt: unv_01 0
          dba: horizontal whitespace
          i: 0
          min: 1
          r: 1
          s: 0
          zyg: 
            - !!perl/hash:RE_quantified_atom 
              atom: !!perl/hash:RE_meta 
                a: 0
                dba: horizontal whitespace
                i: 0
                min: 1
                r: 1
                s: 0
                text: \h
              min: 1
              quant: 
                - +
                - ":"
                - ''
                - 1
            - !!perl/hash:RE_method_internal 
              args: $S, 'unv', 'hwhite'
              max: 0
              min: 0
              name: _REDUCE
        - !!perl/hash:RE_sequence 
          a: 0
          alt: unv_01 1
          dba: horizontal whitespace
          i: 0
          min: 12345
          r: 1
          s: 0
          zyg: 
            - !!perl/hash:RE_assertion 
              assert: "?"
              min: 0
              re: !!perl/hash:RE_method_re 
                a: 0
                dba: horizontal whitespace
                i: 0
                min: 0
                name: before
                nobind: 1
                r: 1
                re: !!perl/hash:RE 
                  decl: []

                  min: 1
                  re: !!perl/hash:RE_string 
                    a: 0
                    dba: horizontal whitespace
                    i: 0
                    min: 1
                    r: 1
                    s: 0
                    text: =
                s: 0
            - !!perl/hash:RE_meta 
              a: 0
              dba: horizontal whitespace
              i: 0
              min: 0
              r: 1
              s: 0
              text: "^^"
            - !!perl/hash:RE_method 
              a: 0
              dba: horizontal whitespace
              i: 0
              min: 12345
              name: pod_comment
              nobind: 1
              r: 1
              rest: ''
              s: 0
            - !!perl/hash:RE_method_internal 
              args: $S, 'unv', 'pod'
              max: 0
              min: 0
              name: _REDUCE
        - !!perl/hash:RE_sequence 
          a: 0
          alt: unv_01 2
          dba: horizontal whitespace
          i: 0
          min: 1
          r: 1
          s: 0
          zyg: 
            - !!perl/hash:RE_quantified_atom 
              atom: !!perl/hash:RE_meta 
                a: 0
                dba: horizontal whitespace
                i: 0
                min: 1
                r: 1
                s: 0
                text: \h
              min: 0
              quant: 
                - "*"
                - ":"
                - ''
                - 0
            - !!perl/hash:RE_string 
              a: 0
              dba: horizontal whitespace
              i: 0
              min: 1
              r: 1
              s: 0
              text: "#"
            - !!perl/hash:RE_bracket 
              decl: []

              min: 0
              re: &50 !!perl/hash:RE_any 
                a: 0
                altname: unv_03
                dba: horizontal whitespace
                i: 0
                min: 0
                name: unv_03
                r: 1
                s: 0
                zyg: 
                  - !!perl/hash:RE_sequence 
                    a: 0
                    alt: unv_03 0
                    dba: horizontal whitespace
                    i: 0
                    min: 0
                    r: 1
                    s: 0
                    zyg: 
                      - !!perl/hash:RE_assertion 
                        assert: "?"
                        min: 0
                        re: !!perl/hash:RE_method 
                          a: 0
                          dba: horizontal whitespace
                          i: 0
                          min: 12345
                          name: opener
                          nobind: 1
                          r: 1
                          rest: ''
                          s: 0
                      - !!perl/hash:RE_bracket 
                        decl: []

                        min: 0
                        re: !!perl/hash:RE_first 
                          a: 0
                          dba: horizontal whitespace
                          i: 0
                          min: 0
                          r: 1
                          s: 0
                          zyg: 
                            - !!perl/hash:RE_assertion 
                              assert: "!"
                              min: 0
                              re: !!perl/hash:RE_method_re 
                                a: 0
                                dba: horizontal whitespace
                                i: 0
                                min: 0
                                name: after
                                nobind: 1
                                r: 1
                                re: !!perl/hash:RE 
                                  decl: []

                                  min: 1
                                  re: !!perl/hash:RE_sequence 
                                    a: 0
                                    dba: horizontal whitespace
                                    i: 0
                                    min: 1
                                    r: 1
                                    s: 0
                                    zyg: 
                                      - !!perl/hash:RE_meta 
                                        a: 0
                                        dba: horizontal whitespace
                                        i: 0
                                        min: 0
                                        r: 1
                                        s: 0
                                        text: "^^"
                                      - !!perl/hash:RE_meta 
                                        a: 0
                                        dba: horizontal whitespace
                                        i: 0
                                        min: 1
                                        r: 1
                                        s: 0
                                        text: .
                                s: 0
                            - !!perl/hash:RE_method 
                              min: 0
                              name: panic
                              nobind: 1
                              rest: ("Can't use embedded comments in column 1")
                      - !!perl/hash:RE_method 
                        min: 0
                        name: quibble
                        nobind: 1
                        rest: ($¢.cursor_fresh( %*LANG<Q> ))
                      - !!perl/hash:RE_method_internal 
                        args: $S, 'unv', 'embedded'
                        max: 0
                        min: 0
                        name: _REDUCE
                  - !!perl/hash:RE_sequence 
                    a: 0
                    alt: unv_03 1
                    dba: horizontal whitespace
                    i: 0
                    min: 0
                    r: 1
                    s: 0
                    zyg: 
                      - !!perl/hash:RE_block 
                        a: 0
                        context: void
                        dba: horizontal whitespace
                        i: 0
                        min: 0
                        r: 1
                        s: 0
                        text: ''
                      - !!perl/hash:RE_quantified_atom 
                        atom: !!perl/hash:RE_meta 
                          a: 0
                          dba: horizontal whitespace
                          i: 0
                          min: 1
                          r: 1
                          s: 0
                          text: \N
                        min: 0
                        quant: 
                          - "*"
                          - ":"
                          - ''
                          - 0
                      - !!perl/hash:RE_method_internal 
                        args: $S, 'unv', 'end'
                        max: 0
                        min: 0
                        name: _REDUCE
unv_01: *3
unv_03: *50
value__S_186quote: !!perl/hash:RE 
  decl: []

  kind: token
  min: 12345
  pkg: ~
  re: !!perl/hash:RE_method 
    a: 0
    dba: value__S_186quote
    i: 0
    min: 12345
    name: quote
    r: 1
    rest: ''
    s: 0
value__S_187number: !!perl/hash:RE 
  decl: []

  kind: token
  min: 12345
  pkg: ~
  re: !!perl/hash:RE_method 
    a: 0
    dba: value__S_187number
    i: 0
    min: 12345
    name: number
    r: 1
    rest: ''
    s: 0
value__S_188version: !!perl/hash:RE 
  decl: []

  kind: token
  min: 12345
  pkg: ~
  re: !!perl/hash:RE_method 
    a: 0
    dba: value__S_188version
    i: 0
    min: 12345
    name: version
    r: 1
    rest: ''
    s: 0
variable: !!perl/hash:RE 
  decl: 
    - !!perl/hash:RE_decl 
      a: 0
      dba: variable
      i: 0
      max: 0
      min: 0
      r: 1
      s: 0
      text: my $IN_META is context<rw> = 0
    - !!perl/hash:RE_decl 
      a: 0
      dba: variable
      i: 0
      max: 0
      min: 0
      r: 1
      s: 0
      text: my $sigil = ''
    - !!perl/hash:RE_decl 
      a: 0
      dba: variable
      i: 0
      max: 0
      min: 0
      r: 1
      s: 0
      text: my $twigil = ''
    - !!perl/hash:RE_decl 
      a: 0
      dba: variable
      i: 0
      max: 0
      min: 0
      r: 1
      s: 0
      text: my $name
  kind: token
  min: 0
  pkg: ~
  re: !!perl/hash:RE_sequence 
    a: 0
    dba: variable
    i: 0
    min: 0
    r: 1
    s: 0
    zyg: 
      - !!perl/hash:RE_assertion 
        assert: "?"
        min: 0
        re: !!perl/hash:RE_method_re 
          a: 0
          dba: variable
          i: 0
          min: 0
          name: before
          nobind: 1
          r: 1
          re: !!perl/hash:RE 
            decl: []

            min: 12345
            re: !!perl/hash:RE_sequence 
              a: 0
              dba: variable
              i: 0
              min: 12345
              r: 1
              s: 0
              zyg: 
                - !!perl/hash:RE_method 
                  a: 0
                  dba: variable
                  i: 0
                  min: 12345
                  name: sigil
                  r: 1
                  rest: ''
                  s: 0
                - !!perl/hash:RE_block 
                  a: 0
                  context: void
                  dba: variable
                  i: 0
                  min: 0
                  r: 1
                  s: 0
                  text: "\n        $sigil = $<sigil>.Str;\n        $*LEFTSIGIL ||= $sigil;\n    "
          s: 0
      - !!perl/hash:RE_block 
        a: 0
        context: void
        dba: variable
        i: 0
        min: 0
        r: 1
        s: 0
        text: ''
      - !!perl/hash:RE_bracket 
        decl: []

        min: 0
        re: !!perl/hash:RE_first 
          a: 0
          dba: variable
          i: 0
          min: 0
          r: 1
          s: 0
          zyg: 
            - !!perl/hash:RE_sequence 
              a: 0
              dba: variable
              i: 0
              min: 24690
              r: 1
              s: 0
              zyg: 
                - !!perl/hash:RE_method 
                  a: 0
                  dba: variable
                  i: 0
                  min: 12345
                  name: sigil
                  r: 1
                  rest: ''
                  s: 0
                - !!perl/hash:RE_quantified_atom 
                  atom: !!perl/hash:RE_method 
                    a: 0
                    dba: variable
                    i: 0
                    min: 12345
                    name: twigil
                    r: 1
                    rest: ''
                    s: 0
                  min: 0
                  quant: 
                    - "?"
                    - ":"
                    - ''
                    - 0
                - !!perl/hash:RE_assertion 
                  assert: "?"
                  min: 0
                  re: !!perl/hash:RE_method_re 
                    a: 0
                    dba: variable
                    i: 0
                    min: 0
                    name: before
                    nobind: 1
                    r: 1
                    re: !!perl/hash:RE 
                      decl: []

                      min: 3
                      re: !!perl/hash:RE_sequence 
                        a: 0
                        dba: variable
                        i: 0
                        min: 3
                        r: 1
                        s: 0
                        zyg: 
                          - !!perl/hash:RE_string 
                            a: 0
                            dba: variable
                            i: 0
                            min: 2
                            r: 1
                            s: 0
                            text: "::"
                          - !!perl/hash:RE_bracket 
                            decl: []

                            min: 1
                            re: &78 !!perl/hash:RE_any 
                              a: 0
                              altname: variable_04
                              dba: variable
                              i: 0
                              min: 1
                              name: variable_04
                              r: 1
                              s: 0
                              zyg: 
                                - !!perl/hash:RE_string 
                                  a: 0
                                  alt: variable_04 0
                                  dba: variable
                                  i: 0
                                  min: 1
                                  r: 1
                                  s: 0
                                  text: "{"
                                - !!perl/hash:RE_string 
                                  a: 0
                                  alt: variable_04 1
                                  dba: variable
                                  i: 0
                                  min: 1
                                  r: 1
                                  s: 0
                                  text: <
                                - !!perl/hash:RE_string 
                                  a: 0
                                  alt: variable_04 2
                                  dba: variable
                                  i: 0
                                  min: 1
                                  r: 1
                                  s: 0
                                  text: (
                    s: 0
                - !!perl/hash:RE_method 
                  a: 0
                  dba: variable
                  i: 0
                  min: 12345
                  name: longname
                  r: 1
                  rest: ''
                  s: 0
            - !!perl/hash:RE_sequence 
              a: 0
              dba: variable
              i: 0
              min: 3
              r: 1
              s: 0
              zyg: 
                - !!perl/hash:RE_string 
                  a: 0
                  dba: variable
                  i: 0
                  min: 1
                  r: 1
                  s: 0
                  text: "&"
                - !!perl/hash:RE_bracket 
                  decl: []

                  min: 2
                  re: &79 !!perl/hash:RE_any 
                    a: 0
                    altname: variable_06
                    dba: infix noun
                    i: 0
                    min: 2
                    name: variable_06
                    r: 1
                    s: 0
                    zyg: 
                      - !!perl/hash:RE_sequence 
                        a: 0
                        alt: variable_06 0
                        dba: variable
                        i: 0
                        min: 12345
                        r: 1
                        s: 0
                        zyg: 
                          - !!perl/hash:RE_quantified_atom 
                            atom: !!perl/hash:RE_method 
                              a: 0
                              dba: variable
                              i: 0
                              min: 12345
                              name: twigil
                              r: 1
                              rest: ''
                              s: 0
                            min: 0
                            quant: 
                              - "?"
                              - ":"
                              - ''
                              - 0
                          - !!perl/hash:RE_method 
                            a: 0
                            dba: variable
                            i: 0
                            min: 12345
                            name: sublongname
                            r: 1
                            rest: ''
                            s: 0
                          - !!perl/hash:RE_block 
                            a: 0
                            context: void
                            dba: variable
                            i: 0
                            min: 0
                            r: 1
                            s: 0
                            text: " $name = $<sublongname>.Str "
                          - !!perl/hash:RE_method_internal 
                            args: $S, 'variable', 'subnoun'
                            max: 0
                            min: 0
                            name: _REDUCE
                      - !!perl/hash:RE_sequence 
                        a: 0
                        alt: variable_06 1
                        dba: infix noun
                        i: 0
                        min: 2
                        r: 1
                        s: 0
                        zyg: 
                          - !!perl/hash:RE_string 
                            a: 0
                            dba: infix noun
                            i: 0
                            min: 1
                            r: 1
                            s: 0
                            text: "["
                          - !!perl/hash:RE_meta 
                            a: 0
                            dba: infix noun
                            extra: "local $::GOAL = ']' "
                            i: 0
                            min: 0
                            r: 1
                            s: 0
                            text: "::"
                          - !!perl/hash:RE_method 
                            min: 0
                            name: infixish
                            rest: (1)
                          - !!perl/hash:RE_bracket 
                            decl: []

                            min: 1
                            re: !!perl/hash:RE_first 
                              a: 0
                              dba: infix noun
                              i: 0
                              min: 1
                              r: 1
                              s: 0
                              zyg: 
                                - !!perl/hash:RE_string 
                                  a: 0
                                  dba: infix noun
                                  i: 0
                                  min: 1
                                  r: 1
                                  s: 0
                                  text: "]"
                                - !!perl/hash:RE_method 
                                  min: 0
                                  name: FAILGOAL
                                  nobind: 1
                                  rest: (']' , 'infix noun')
            - !!perl/hash:RE_sequence 
              a: 0
              dba: variable
              i: 0
              min: 3
              r: 1
              s: 0
              zyg: 
                - !!perl/hash:RE_string 
                  a: 0
                  dba: variable
                  i: 0
                  min: 3
                  r: 1
                  s: 0
                  text: "$::"
                - !!perl/hash:RE_quantified_atom 
                  atom: !!perl/hash:RE_method 
                    a: 0
                    dba: variable
                    i: 0
                    min: 12345
                    name: name
                    r: 1
                    rest: ''
                    s: 0
                  min: 0
                  quant: 
                    - "?"
                    - ":"
                    - ''
                    - 0
            - !!perl/hash:RE_sequence 
              a: 0
              dba: variable
              i: 0
              min: 12347
              r: 1
              s: 0
              zyg: 
                - !!perl/hash:RE_string 
                  a: 0
                  dba: variable
                  i: 0
                  min: 2
                  r: 1
                  s: 0
                  text: "$:"
                - !!perl/hash:RE_method 
                  a: 0
                  dba: variable
                  i: 0
                  min: 12345
                  name: name
                  r: 1
                  rest: ''
                  s: 0
            - !!perl/hash:RE_bracket 
              decl: []

              min: 0
              re: &80 !!perl/hash:RE_any 
                a: 0
                altname: variable_10
                dba: variable
                i: 0
                min: 0
                name: variable_10
                r: 1
                s: 0
                zyg: 
                  - !!perl/hash:RE_sequence 
                    a: 0
                    alt: variable_10 0
                    dba: variable
                    i: 0
                    min: 24690
                    r: 1
                    s: 0
                    zyg: 
                      - !!perl/hash:RE_method 
                        a: 0
                        dba: variable
                        i: 0
                        min: 12345
                        name: sigil
                        r: 1
                        rest: ''
                        s: 0
                      - !!perl/hash:RE_quantified_atom 
                        atom: !!perl/hash:RE_method 
                          a: 0
                          dba: variable
                          i: 0
                          min: 12345
                          name: twigil
                          r: 1
                          rest: ''
                          s: 0
                        min: 0
                        quant: 
                          - "?"
                          - ":"
                          - ''
                          - 0
                      - !!perl/hash:RE_method 
                        a: 0
                        dba: variable
                        i: 0
                        min: 12345
                        name: desigilname
                        r: 1
                        rest: ''
                        s: 0
                      - !!perl/hash:RE_block 
                        a: 0
                        context: void
                        dba: variable
                        i: 0
                        min: 0
                        r: 1
                        s: 0
                        text: " $name = $<desigilname>.Str "
                      - !!perl/hash:RE_method_internal 
                        args: $S, 'variable', 'desigilname'
                        max: 0
                        min: 0
                        name: _REDUCE
                  - !!perl/hash:RE_sequence 
                    a: 0
                    alt: variable_10 1
                    dba: variable
                    i: 0
                    min: 12345
                    r: 1
                    s: 0
                    zyg: 
                      - !!perl/hash:RE_method 
                        a: 0
                        dba: variable
                        i: 0
                        min: 12345
                        name: special_variable
                        r: 1
                        rest: ''
                        s: 0
                      - !!perl/hash:RE_method_internal 
                        args: $S, 'variable', 'special'
                        max: 0
                        min: 0
                        name: _REDUCE
                  - !!perl/hash:RE_sequence 
                    a: 0
                    alt: variable_10 2
                    dba: variable
                    i: 0
                    min: 12346
                    r: 1
                    s: 0
                    zyg: 
                      - !!perl/hash:RE_method 
                        a: 0
                        dba: variable
                        i: 0
                        min: 12345
                        name: sigil
                        r: 1
                        rest: ''
                        s: 0
                      - !!perl/hash:RE_bindnamed 
                        a: 0
                        atom: !!perl/hash:RE_bracket 
                          decl: []

                          min: 1
                          nobind: 1
                          re: !!perl/hash:RE_quantified_atom 
                            atom: !!perl/hash:RE_meta 
                              a: 0
                              dba: variable
                              i: 0
                              min: 1
                              r: 1
                              s: 0
                              text: \d
                            min: 1
                            quant: 
                              - +
                              - ":"
                              - ''
                              - 1
                        dba: variable
                        i: 0
                        min: 1
                        r: 1
                        s: 0
                        var: index
                      - !!perl/hash:RE_method_internal 
                        args: $S, 'variable', '$0'
                        max: 0
                        min: 0
                        name: _REDUCE
                  - !!perl/hash:RE_sequence 
                    a: 0
                    alt: variable_10 3
                    dba: variable
                    i: 0
                    min: 24690
                    r: 1
                    s: 0
                    zyg: 
                      - !!perl/hash:RE_method 
                        a: 0
                        dba: variable
                        i: 0
                        min: 12345
                        name: sigil
                        r: 1
                        rest: ''
                        s: 0
                      - !!perl/hash:RE_assertion 
                        assert: "?"
                        min: 0
                        re: !!perl/hash:RE_method_re 
                          a: 0
                          dba: variable
                          i: 0
                          min: 0
                          name: before
                          nobind: 1
                          r: 1
                          re: !!perl/hash:RE 
                            decl: []

                            min: 1
                            re: &73 !!perl/hash:RE_any 
                              a: 0
                              altname: variable_12
                              dba: variable
                              i: 0
                              min: 1
                              name: variable_12
                              r: 1
                              s: 0
                              zyg: 
                                - !!perl/hash:RE_string 
                                  a: 0
                                  alt: variable_12 0
                                  dba: variable
                                  i: 0
                                  min: 1
                                  r: 1
                                  s: 0
                                  text: <
                                - !!perl/hash:RE_string 
                                  a: 0
                                  alt: variable_12 1
                                  dba: variable
                                  i: 0
                                  min: 1
                                  r: 1
                                  s: 0
                                  text: (
                          s: 0
                      - !!perl/hash:RE_method 
                        a: 0
                        dba: variable
                        i: 0
                        min: 12345
                        name: postcircumfix
                        r: 1
                        rest: ''
                        s: 0
                      - !!perl/hash:RE_method_internal 
                        args: $S, 'variable', '$()'
                        max: 0
                        min: 0
                        name: _REDUCE
                  - !!perl/hash:RE_sequence 
                    a: 0
                    alt: variable_10 4
                    dba: variable
                    i: 0
                    min: 12345
                    r: 1
                    s: 0
                    zyg: 
                      - !!perl/hash:RE_method 
                        a: 0
                        dba: variable
                        i: 0
                        min: 12345
                        name: sigil
                        r: 1
                        rest: ''
                        s: 0
                      - !!perl/hash:RE_assertion 
                        assert: "?"
                        min: 0
                        re: !!perl/hash:RE_block 
                          a: 0
                          context: bool
                          dba: variable
                          i: 0
                          min: 0
                          nobind: 1
                          r: 1
                          s: 0
                          text: " $*IN_DECL "
                      - !!perl/hash:RE_method_internal 
                        args: $S, 'variable', 'anondecl'
                        max: 0
                        min: 0
                        name: _REDUCE
                  - !!perl/hash:RE_sequence 
                    a: 0
                    alt: variable_10 5
                    dba: variable
                    i: 0
                    min: 0
                    r: 1
                    s: 0
                    zyg: 
                      - !!perl/hash:RE_assertion 
                        assert: "?"
                        min: 0
                        re: !!perl/hash:RE_noop 
                          a: 0
                          dba: variable
                          i: 0
                          min: 0
                          nobind: 1
                          r: 1
                          s: 0
                      - !!perl/hash:RE_block 
                        a: 0
                        context: void
                        dba: variable
                        i: 0
                        min: 0
                        r: 1
                        s: 0
                        text: "\n            if $*QSIGIL {\n                return ();\n            }\n            else {\n                $¢.panic(\"Anonymous variable requires declarator\");\n            }\n          "
      - !!perl/hash:RE_block 
        a: 0
        context: void
        dba: variable
        i: 0
        min: 0
        r: 1
        s: 0
        text: " my $t = $<twigil>; $twigil = $t.[0].Str if @$t; "
      - !!perl/hash:RE_quantified_atom 
        atom: !!perl/hash:RE_bracket 
          decl: []

          min: 12345
          re: !!perl/hash:RE_sequence 
            a: 0
            dba: variable
            i: 0
            min: 12345
            r: 1
            s: 0
            zyg: 
              - !!perl/hash:RE_assertion 
                assert: "?"
                min: 0
                re: !!perl/hash:RE_block 
                  a: 0
                  context: bool
                  dba: variable
                  i: 0
                  min: 0
                  nobind: 1
                  r: 1
                  s: 0
                  text: " $twigil eq '.' "
              - !!perl/hash:RE_bracket 
                decl: []

                min: 0
                re: &81 !!perl/hash:RE_any 
                  a: 0
                  altname: variable_14
                  dba: variable
                  i: 0
                  min: 0
                  name: variable_14
                  r: 1
                  s: 0
                  zyg: 
                    - !!perl/hash:RE_method 
                      a: 0
                      alt: variable_14 0
                      dba: variable
                      i: 0
                      min: 12345
                      name: unsp
                      nobind: 1
                      r: 1
                      rest: ''
                      s: 0
                    - !!perl/hash:RE_string 
                      a: 0
                      alt: variable_14 1
                      dba: variable
                      i: 0
                      min: 1
                      r: 1
                      s: 0
                      text: \
                    - !!perl/hash:RE_assertion 
                      alt: variable_14 2
                      assert: "?"
                      min: 0
                      re: !!perl/hash:RE_noop 
                        a: 0
                        dba: variable
                        i: 0
                        min: 0
                        nobind: 1
                        r: 1
                        s: 0
              - !!perl/hash:RE_assertion 
                assert: "?"
                min: 0
                re: !!perl/hash:RE_method_re 
                  a: 0
                  dba: variable
                  i: 0
                  min: 0
                  name: before
                  nobind: 1
                  r: 1
                  re: !!perl/hash:RE 
                    decl: []

                    min: 1
                    re: !!perl/hash:RE_string 
                      a: 0
                      dba: variable
                      i: 0
                      min: 1
                      r: 1
                      s: 0
                      text: (
                  s: 0
              - !!perl/hash:RE_method 
                a: 0
                dba: variable
                i: 0
                min: 12345
                name: postcircumfix
                r: 1
                rest: ''
                s: 0
              - !!perl/hash:RE_method_internal 
                args: $S, 'variable', 'methcall'
                max: 0
                min: 0
                name: _REDUCE
        min: 0
        quant: 
          - "?"
          - ":"
          - ''
          - 0
variable_04: *78
variable_06: *79
variable_10: *80
variable_12: *73
variable_14: *81
variable_declarator: !!perl/hash:RE 
  decl: 
    - !!perl/hash:RE_decl 
      a: 0
      dba: variable_declarator
      i: 0
      max: 0
      min: 0
      r: 1
      s: 0
      text: my $IN_DECL is context<rw> = 1
    - !!perl/hash:RE_decl 
      a: 0
      dba: variable_declarator
      i: 0
      max: 0
      min: 0
      r: 1
      s: 0
      text: my $DECLARAND is context<rw>
  kind: token
  min: 24690
  pkg: ~
  re: !!perl/hash:RE_sequence 
    a: 0
    dba: variable_declarator
    i: 0
    min: 24690
    r: 1
    s: 0
    zyg: 
      - !!perl/hash:RE_method 
        a: 0
        dba: variable_declarator
        i: 0
        min: 12345
        name: variable
        r: 1
        rest: ''
        s: 0
      - !!perl/hash:RE_block 
        a: 0
        context: void
        dba: variable_declarator
        i: 0
        min: 0
        r: 1
        s: 0
        text: " $*IN_DECL = 0; self.add_variable($<variable>.Str) "
      - !!perl/hash:RE_quantified_atom 
        atom: !!perl/hash:RE_bracket 
          decl: []

          min: 0
          re: !!perl/hash:RE_sequence 
            a: 0
            dba: variable_declarator
            i: 0
            min: 0
            r: 1
            s: 0
            zyg: 
              - !!perl/hash:RE_quantified_atom 
                atom: !!perl/hash:RE_method 
                  a: 0
                  dba: variable_declarator
                  i: 0
                  min: 12345
                  name: unsp
                  nobind: 1
                  r: 1
                  rest: ''
                  s: 0
                min: 0
                quant: 
                  - "?"
                  - ":"
                  - ''
                  - 0
              - !!perl/hash:RE_bindnamed 
                a: 0
                atom: !!perl/hash:RE_quantified_atom 
                  atom: !!perl/hash:RE_bracket 
                    decl: []

                    min: 12345
                    re: &62 !!perl/hash:RE_any 
                      a: 0
                      altname: variable_declarator_02
                      dba: shape definition
                      i: 0
                      min: 12345
                      name: variable_declarator_02
                      r: 1
                      s: 0
                      zyg: 
                        - !!perl/hash:RE_sequence 
                          a: 0
                          alt: variable_declarator_02 0
                          dba: variable_declarator
                          i: 0
                          min: 12347
                          r: 1
                          s: 0
                          zyg: 
                            - !!perl/hash:RE_string 
                              a: 0
                              dba: variable_declarator
                              i: 0
                              min: 1
                              r: 1
                              s: 0
                              text: (
                            - !!perl/hash:RE_meta 
                              a: 0
                              dba: variable_declarator
                              extra: "local $::GOAL = ')' "
                              i: 0
                              min: 0
                              r: 1
                              s: 0
                              text: "::"
                            - !!perl/hash:RE_method 
                              a: 0
                              dba: variable_declarator
                              i: 0
                              min: 12345
                              name: signature
                              r: 1
                              rest: ''
                              s: 0
                            - !!perl/hash:RE_bracket 
                              decl: []

                              min: 1
                              re: !!perl/hash:RE_first 
                                a: 0
                                dba: variable_declarator
                                i: 0
                                min: 1
                                r: 1
                                s: 0
                                zyg: 
                                  - !!perl/hash:RE_string 
                                    a: 0
                                    dba: variable_declarator
                                    i: 0
                                    min: 1
                                    r: 1
                                    s: 0
                                    text: )
                                  - !!perl/hash:RE_method 
                                    min: 0
                                    name: FAILGOAL
                                    nobind: 1
                                    rest: (')' , 'variable_declarator')
                        - !!perl/hash:RE_sequence 
                          a: 0
                          alt: variable_declarator_02 1
                          dba: shape definition
                          i: 0
                          min: 12347
                          r: 1
                          s: 0
                          zyg: 
                            - !!perl/hash:RE_string 
                              a: 0
                              dba: shape definition
                              i: 0
                              min: 1
                              r: 1
                              s: 0
                              text: "["
                            - !!perl/hash:RE_meta 
                              a: 0
                              dba: shape definition
                              extra: "local $::GOAL = ']' "
                              i: 0
                              min: 0
                              r: 1
                              s: 0
                              text: "::"
                            - !!perl/hash:RE_method 
                              a: 0
                              dba: shape definition
                              i: 0
                              min: 12345
                              name: semilist
                              r: 1
                              rest: ''
                              s: 0
                            - !!perl/hash:RE_bracket 
                              decl: []

                              min: 1
                              re: !!perl/hash:RE_first 
                                a: 0
                                dba: shape definition
                                i: 0
                                min: 1
                                r: 1
                                s: 0
                                zyg: 
                                  - !!perl/hash:RE_string 
                                    a: 0
                                    dba: shape definition
                                    i: 0
                                    min: 1
                                    r: 1
                                    s: 0
                                    text: "]"
                                  - !!perl/hash:RE_method 
                                    min: 0
                                    name: FAILGOAL
                                    nobind: 1
                                    rest: (']' , 'shape definition')
                        - !!perl/hash:RE_sequence 
                          a: 0
                          alt: variable_declarator_02 2
                          dba: shape definition
                          i: 0
                          min: 12347
                          r: 1
                          s: 0
                          zyg: 
                            - !!perl/hash:RE_string 
                              a: 0
                              dba: shape definition
                              i: 0
                              min: 1
                              r: 1
                              s: 0
                              text: "{"
                            - !!perl/hash:RE_meta 
                              a: 0
                              dba: shape definition
                              extra: "local $::GOAL = '}' "
                              i: 0
                              min: 0
                              r: 1
                              s: 0
                              text: "::"
                            - !!perl/hash:RE_method 
                              a: 0
                              dba: shape definition
                              i: 0
                              min: 12345
                              name: semilist
                              r: 1
                              rest: ''
                              s: 0
                            - !!perl/hash:RE_bracket 
                              decl: []

                              min: 1
                              re: !!perl/hash:RE_first 
                                a: 0
                                dba: shape definition
                                i: 0
                                min: 1
                                r: 1
                                s: 0
                                zyg: 
                                  - !!perl/hash:RE_string 
                                    a: 0
                                    dba: shape definition
                                    i: 0
                                    min: 1
                                    r: 1
                                    s: 0
                                    text: "}"
                                  - !!perl/hash:RE_method 
                                    min: 0
                                    name: FAILGOAL
                                    nobind: 1
                                    rest: ('}' , 'shape definition')
                        - !!perl/hash:RE_sequence 
                          a: 0
                          alt: variable_declarator_02 3
                          dba: shape definition
                          i: 0
                          min: 12345
                          r: 1
                          s: 0
                          zyg: 
                            - !!perl/hash:RE_assertion 
                              assert: "?"
                              min: 0
                              re: !!perl/hash:RE_method_re 
                                a: 0
                                dba: shape definition
                                i: 0
                                min: 0
                                name: before
                                nobind: 1
                                r: 1
                                re: !!perl/hash:RE 
                                  decl: []

                                  min: 1
                                  re: !!perl/hash:RE_string 
                                    a: 0
                                    dba: shape definition
                                    i: 0
                                    min: 1
                                    r: 1
                                    s: 0
                                    text: <
                                s: 0
                            - !!perl/hash:RE_method 
                              a: 0
                              dba: shape definition
                              i: 0
                              min: 12345
                              name: postcircumfix
                              r: 1
                              rest: ''
                              s: 0
                  min: 0
                  nobind: 1
                  quant: 
                    - "*"
                    - ":"
                    - ''
                    - 0
                dba: variable_declarator
                i: 0
                min: 0
                r: 1
                s: 0
                var: shape
        min: 0
        quant: 
          - "?"
          - ":"
          - ''
          - 0
      - !!perl/hash:RE_method 
        a: 0
        dba: variable_declarator
        i: 0
        min: 12345
        name: ws
        nobind: 1
        r: 1
        rest: ''
        s: 0
      - !!perl/hash:RE_quantified_atom 
        atom: !!perl/hash:RE_method 
          a: 0
          dba: variable_declarator
          i: 0
          min: 12345
          name: trait
          r: 1
          rest: ''
          s: 0
        min: 0
        quant: 
          - "*"
          - ":"
          - ''
          - 0
variable_declarator_02: *62
version__S_075v: !!perl/hash:RE 
  decl: []

  kind: token
  min: 12346
  pkg: ~
  re: !!perl/hash:RE_sequence 
    a: 0
    dba: version__S_075v
    i: 0
    min: 12346
    r: 1
    s: 0
    zyg: 
      - !!perl/hash:RE_string 
        a: 0
        dba: version__S_075v
        i: 0
        min: 1
        r: 1
        s: 0
        text: v
      - !!perl/hash:RE_assertion 
        assert: "?"
        min: 0
        re: !!perl/hash:RE_method_re 
          a: 0
          dba: version__S_075v
          i: 0
          min: 0
          name: before
          nobind: 1
          r: 1
          re: !!perl/hash:RE 
            decl: []

            min: 1
            re: !!perl/hash:RE_quantified_atom 
              atom: !!perl/hash:RE_meta 
                a: 0
                dba: version__S_075v
                i: 0
                min: 1
                r: 1
                s: 0
                text: \d
              min: 1
              quant: 
                - +
                - ":"
                - ''
                - 1
          s: 0
      - !!perl/hash:RE_meta 
        a: 0
        dba: version__S_075v
        i: 0
        min: 0
        r: 1
        s: 0
        text: "::"
      - !!perl/hash:RE_quantified_atom 
        atom: !!perl/hash:RE_method 
          a: 0
          dba: version__S_075v
          i: 0
          min: 12345
          name: vnum
          r: 1
          rest: ''
          s: 0
        min: 12345
        quant: 
          - "**"
          - ":"
          - !!perl/hash:RE_string 
            a: 0
            dba: version__S_075v
            i: 0
            min: 1
            r: 1
            s: 0
            text: .
          - 1
      - !!perl/hash:RE_quantified_atom 
        atom: !!perl/hash:RE_string 
          a: 0
          dba: version__S_075v
          i: 0
          min: 1
          r: 1
          s: 0
          text: +
        min: 0
        quant: 
          - "?"
          - ":"
          - ''
          - 0
vnum: !!perl/hash:RE 
  decl: []

  kind: token
  min: 1
  pkg: ~
  re: &108 !!perl/hash:RE_any 
    a: 0
    altname: vnum_00
    dba: vnum
    i: 0
    min: 1
    name: vnum_00
    r: 1
    s: 0
    zyg: 
      - !!perl/hash:RE_quantified_atom 
        alt: vnum_00 0
        atom: !!perl/hash:RE_meta 
          a: 0
          dba: vnum
          i: 0
          min: 1
          r: 1
          s: 0
          text: \d
        min: 1
        quant: 
          - +
          - ":"
          - ''
          - 1
      - !!perl/hash:RE_string 
        a: 0
        alt: vnum_00 1
        dba: vnum
        i: 0
        min: 1
        r: 1
        s: 0
        text: "*"
vnum_00: *108
vws: !!perl/hash:RE 
  decl: []

  kind: token
  min: 1
  pkg: ~
  re: !!perl/hash:RE_sequence 
    a: 0
    dba: vertical whitespace
    i: 0
    min: 1
    r: 1
    s: 0
    zyg: 
      - !!perl/hash:RE_meta 
        a: 0
        dba: vertical whitespace
        i: 0
        min: 1
        r: 1
        s: 0
        text: \v
      - !!perl/hash:RE_quantified_atom 
        atom: !!perl/hash:RE_bracket 
          decl: []

          min: 9
          re: !!perl/hash:RE_sequence 
            a: 0
            dba: vertical whitespace
            i: 0
            min: 9
            r: 1
            s: 0
            zyg: 
              - !!perl/hash:RE_string 
                a: 0
                dba: vertical whitespace
                i: 0
                min: 9
                r: 1
                s: 0
                text: "#DEBUG -1"
              - !!perl/hash:RE_block 
                a: 0
                context: void
                dba: vertical whitespace
                i: 0
                min: 0
                r: 1
                s: 0
                text: " say \"DEBUG\"; $STD::DEBUG = $*DEBUG = -1; "
        min: 0
        quant: 
          - "?"
          - ":"
          - ''
          - 0
ws: !!perl/hash:RE 
  decl: 
    - !!perl/hash:RE_decl 
      a: 0
      dba: ws
      i: 0
      max: 0
      min: 0
      r: 1
      s: 0
      text: my @stub = return self if @*MEMOS[self.pos]<ws> :exists
    - !!perl/hash:RE_decl 
      a: 0
      dba: ws
      i: 0
      max: 0
      min: 0
      r: 1
      s: 0
      text: my $startpos = self.pos
  kind: token
  min: 0
  pkg: ~
  re: !!perl/hash:RE_first 
    a: 0
    dba: whitespace
    i: 0
    min: 0
    r: 1
    s: 0
    zyg: 
      - !!perl/hash:RE_bracket 
        decl: []

        min: 0
        re: &32 !!perl/hash:RE_any 
          a: 0
          altname: ws_01
          dba: whitespace
          i: 0
          min: 0
          name: ws_01
          r: 1
          s: 0
          zyg: 
            - !!perl/hash:RE_sequence 
              a: 0
              alt: ws_01 0
              dba: whitespace
              i: 0
              min: 1
              r: 1
              s: 0
              zyg: 
                - !!perl/hash:RE_quantified_atom 
                  atom: !!perl/hash:RE_meta 
                    a: 0
                    dba: whitespace
                    i: 0
                    min: 1
                    r: 1
                    s: 0
                    text: \h
                  min: 1
                  quant: 
                    - +
                    - ":"
                    - ''
                    - 1
                - !!perl/hash:RE_assertion 
                  assert: "!"
                  min: 0
                  re: !!perl/hash:RE_cclass 
                    a: 0
                    dba: whitespace
                    i: 0
                    min: 1
                    nobind: 1
                    r: 1
                    s: 0
                    text: "[#\\s\\\\]"
                - !!perl/hash:RE_block 
                  a: 0
                  context: void
                  dba: whitespace
                  i: 0
                  min: 0
                  r: 1
                  s: 0
                  text: " @*MEMOS[$¢.pos]<ws> = $startpos; "
            - !!perl/hash:RE_sequence 
              a: 0
              alt: ws_01 1
              dba: whitespace
              i: 0
              min: 0
              r: 1
              s: 0
              zyg: 
                - !!perl/hash:RE_assertion 
                  assert: "?"
                  min: 0
                  re: !!perl/hash:RE_method_re 
                    a: 0
                    dba: whitespace
                    i: 0
                    min: 0
                    name: before
                    nobind: 1
                    r: 1
                    re: !!perl/hash:RE 
                      decl: []

                      min: 1
                      re: !!perl/hash:RE_meta 
                        a: 0
                        dba: whitespace
                        i: 0
                        min: 1
                        r: 1
                        s: 0
                        text: \w
                    s: 0
                - !!perl/hash:RE_assertion 
                  assert: "?"
                  min: 0
                  re: !!perl/hash:RE_method_re 
                    a: 0
                    dba: whitespace
                    i: 0
                    min: 0
                    name: after
                    nobind: 1
                    r: 1
                    re: !!perl/hash:RE 
                      decl: []

                      min: 1
                      re: !!perl/hash:RE_meta 
                        a: 0
                        dba: whitespace
                        i: 0
                        min: 1
                        r: 1
                        s: 0
                        text: \w
                    s: 0
                - !!perl/hash:RE_meta 
                  a: 0
                  dba: whitespace
                  i: 0
                  min: 0
                  r: 1
                  s: 0
                  text: ":::"
                - !!perl/hash:RE_block 
                  a: 0
                  context: void
                  dba: whitespace
                  i: 0
                  min: 0
                  r: 1
                  s: 0
                  text: " @*MEMOS[$startpos]<ws> = undef; "
                - !!perl/hash:RE_method 
                  min: 0
                  name: panic
                  nobind: 1
                  rest: ("Whitespace is required between alphanumeric tokens")
      - !!perl/hash:RE_sequence 
        a: 0
        dba: whitespace
        i: 0
        min: 0
        r: 1
        s: 0
        zyg: 
          - !!perl/hash:RE_quantified_atom 
            atom: !!perl/hash:RE_bracket 
              decl: []

              min: 0
              re: &129 !!perl/hash:RE_any 
                a: 0
                altname: ws_05
                dba: whitespace
                i: 0
                min: 0
                name: ws_05
                r: 1
                s: 0
                zyg: 
                  - !!perl/hash:RE_method 
                    a: 0
                    alt: ws_05 0
                    dba: whitespace
                    i: 0
                    min: 12345
                    name: unsp
                    nobind: 1
                    r: 1
                    rest: ''
                    s: 0
                  - !!perl/hash:RE_sequence 
                    a: 0
                    alt: ws_05 1
                    dba: whitespace
                    i: 0
                    min: 24690
                    r: 1
                    s: 0
                    zyg: 
                      - !!perl/hash:RE_method 
                        a: 0
                        dba: whitespace
                        i: 0
                        min: 12345
                        name: vws
                        nobind: 1
                        r: 1
                        rest: ''
                        s: 0
                      - !!perl/hash:RE_method 
                        a: 0
                        dba: whitespace
                        i: 0
                        min: 12345
                        name: heredoc
                        nobind: 1
                        r: 1
                        rest: ''
                        s: 0
                  - !!perl/hash:RE_method 
                    a: 0
                    alt: ws_05 2
                    dba: whitespace
                    i: 0
                    min: 12345
                    name: unv
                    nobind: 1
                    r: 1
                    rest: ''
                    s: 0
                  - !!perl/hash:RE_sequence 
                    a: 0
                    alt: ws_05 3
                    dba: whitespace
                    i: 0
                    min: 0
                    r: 1
                    s: 0
                    zyg: 
                      - !!perl/hash:RE_meta 
                        a: 0
                        dba: whitespace
                        i: 0
                        min: 0
                        r: 1
                        s: 0
                        text: $
                      - !!perl/hash:RE_block 
                        a: 0
                        context: void
                        dba: whitespace
                        i: 0
                        min: 0
                        r: 1
                        s: 0
                        text: " $¢.moreinput "
            min: 0
            quant: 
              - "*"
              - ":"
              - ''
              - 0
          - !!perl/hash:RE_block 
            a: 0
            context: void
            dba: whitespace
            i: 0
            min: 0
            r: 1
            s: 0
            text: "\n        if ($¢.pos == $startpos) {\n            @*MEMOS[$¢.pos]<ws> = undef;\n        }\n        else {\n            @*MEMOS[$¢.pos]<ws> = $startpos;\n            @*MEMOS[$¢.pos]<endstmt> = @*MEMOS[$startpos]<endstmt>\n                if @*MEMOS[$startpos]<endstmt> :exists;\n        }\n    "
ws_01: *32
ws_05: *129
xblock: !!perl/hash:RE 
  decl: 
    - !!perl/hash:RE_decl 
      a: 0
      dba: xblock
      i: 0
      max: 0
      min: 0
      r: 1
      s: 0
      text: my $GOAL is context = '{'
    - !!perl/hash:RE_decl 
      a: 0
      dba: xblock
      i: 0
      max: 0
      min: 0
      r: 1
      s: 0
      text: my $BORG is context = {}
  kind: token
  min: 37035
  pkg: ~
  re: !!perl/hash:RE_sequence 
    a: 0
    dba: xblock
    i: 0
    min: 37035
    r: 1
    s: 0
    zyg: 
      - !!perl/hash:RE_method 
        a: 0
        dba: xblock
        i: 0
        min: 12345
        name: EXPR
        r: 1
        rest: ''
        s: 0
      - !!perl/hash:RE_block 
        a: 0
        context: void
        dba: xblock
        i: 0
        min: 0
        r: 1
        s: 0
        text: " $BORG.<culprit> //= $<EXPR>.cursor(self.pos) "
      - !!perl/hash:RE_method 
        a: 0
        dba: xblock
        i: 0
        min: 12345
        name: ws
        nobind: 1
        r: 1
        rest: ''
        s: 0
      - !!perl/hash:RE_method 
        a: 0
        dba: xblock
        i: 0
        min: 12345
        name: pblock
        r: 1
        rest: ''
        s: 0
RETREE_END
}

1;
# vim: sw=4 ft=perl
