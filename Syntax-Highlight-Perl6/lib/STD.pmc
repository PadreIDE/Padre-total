use 5.010;
use utf8;
{ package STD;
use Moose ':all' => { -prefix => "moose_" };
use Encode;
moose_extends('Cursor');
our $ALLROLES = { 'STD', 1 };
our $REGEXES = {
ALL => [ qw/alnumint apostrophe babble backslash begid binint binints category charname charnames charspec circumfix comment dec_number decint decints dotty embeddedblock endid escale escape hexint hexints ident identifier infix infix_circumfix_meta_operator infix_postfix_meta_operator infix_prefix_meta_operator integer is_ok longname module_name morename multi_declarator name nibbler nofun octint octints opener package_declarator pod_comment postcircumfix postfix postfix_prefix_meta_operator prefix prefix_circumfix_meta_operator prefix_postfix_meta_operator quibble quote quote_mod quotepair rad_number radint regex_declarator routine_declarator scope_declarator sigil spacey special_variable starter statement_control statement_mod_cond statement_mod_loop statement_prefix stdstopper stopper strtonum term terminator trait_mod twigil type_declarator unitstopper unsp unspacey unv value version vws ws/ ],
category => [ qw/category__S_000category__PEEK category__S_001sigil__PEEK category__S_002twigil__PEEK category__S_003special_variable__PEEK category__S_004comment__PEEK category__S_005version__PEEK category__S_006module_name__PEEK category__S_007value__PEEK category__S_008term__PEEK category__S_009strtonum__PEEK category__S_010quote__PEEK category__S_011prefix__PEEK category__S_012infix__PEEK category__S_013postfix__PEEK category__S_014dotty__PEEK category__S_015circumfix__PEEK category__S_016postcircumfix__PEEK category__S_017quote_mod__PEEK category__S_018trait_mod__PEEK category__S_019type_declarator__PEEK category__S_020scope_declarator__PEEK category__S_021package_declarator__PEEK category__S_022multi_declarator__PEEK category__S_023routine_declarator__PEEK category__S_024regex_declarator__PEEK category__S_025statement_prefix__PEEK category__S_026statement_control__PEEK category__S_027statement_mod_cond__PEEK category__S_028statement_mod_loop__PEEK category__S_029infix_prefix_meta_operator__PEEK category__S_030infix_postfix_meta_operator__PEEK category__S_031infix_circumfix_meta_operator__PEEK category__S_032postfix_prefix_meta_operator__PEEK category__S_033prefix_postfix_meta_operator__PEEK category__S_034prefix_circumfix_meta_operator__PEEK category__S_035terminator__PEEK/ ],
circumfix => [ qw/circumfix__S_051Fre_Nch__PEEK circumfix__S_052LtLt_GtGt__PEEK circumfix__S_053Lt_Gt__PEEK/ ],
comment => [ qw/comment__S_054SharpGraveParenDotDotDotThesis__PEEK comment__S_055SharpParenDotDotDotThesis__PEEK comment__S_056SharpEqualParenDotDotDotThesis__PEEK comment__S_057SharpEqual__PEEK comment__S_058Sharp__PEEK/ ],
escape => [ qw/escape__S_048none__PEEK/ ],
quote => [ qw/quote__S_049Single_Single__PEEK quote__S_050Double_Double__PEEK/ ],
sigil => [ qw/sigil__S_036Dollar__PEEK sigil__S_037At__PEEK sigil__S_038Percent__PEEK sigil__S_039Amp__PEEK/ ],
term => [ qw/term__S_062miscbad__PEEK/ ],
terminator => [ qw/terminator__S_059Thesis__PEEK terminator__S_060Ket__PEEK terminator__S_061Ly__PEEK/ ],
twigil => [ qw/twigil__S_040Dot__PEEK twigil__S_041Bang__PEEK twigil__S_042Caret__PEEK twigil__S_043Colon__PEEK twigil__S_044Star__PEEK twigil__S_045Question__PEEK twigil__S_046Equal__PEEK twigil__S_047Tilde__PEEK/ ],
};


no warnings 'qw', 'recursion';
my $retree;

$DB::deep = $DB::deep = 1000; # suppress used-once warning

use YAML::XS;

$SIG{__WARN__} = sub { die @_,"   statement started at line ", 'Cursor'->lineof($::LASTSTATE), "
" } if $::DEBUG;

$retree = YAML::XS::Load(Encode::encode_utf8(<<'RETREE_END'));
---
alnumint: !!perl/hash:RE_ast
  dba: alnumint
  dic: STD
  re: !!perl/hash:RE_bracket
    re: !!perl/hash:RE_sequence
      zyg:
      - !!perl/hash:RE_quantified_atom
        atom: !!perl/hash:RE_cclass
          i: 0
          text: '[ 0..9 a..z A..Z ]'
        quant:
        - +
      - !!perl/hash:RE_quantified_atom
        atom: !!perl/hash:RE_bracket
          re: !!perl/hash:RE_sequence
            zyg:
            - !!perl/hash:RE_string
              i: 0
              text: _
            - !!perl/hash:RE_quantified_atom
              atom: !!perl/hash:RE_cclass
                i: 0
                text: '[ 0..9 a..z A..Z ]'
              quant:
              - +
        quant:
        - '*'
apostrophe: !!perl/hash:RE_ast
  dba: apostrophe
  dic: STD
  re: !!perl/hash:RE_cclass
    i: 0
    text: '[ '' \- ]'
babble: !!perl/hash:RE_ast
  dba: babble
  dic: STD
  re: !!perl/hash:RE_sequence
    zyg:
    - !!perl/hash:RE_method
      name: ws
      rest: ''
    - !!perl/hash:RE_quantified_atom
      atom: !!perl/hash:RE_bracket
        re: !!perl/hash:RE_sequence
          zyg:
          - !!perl/hash:RE_method
            name: quotepair
            rest: ''
          - !!perl/hash:RE_method
            name: ws
            rest: ''
          - !!perl/hash:RE_block {}
      quant:
      - '*'
    - !!perl/hash:RE_block {}
backslash:*:
  dic: STD
begid: !!perl/hash:RE_ast
  dba: begid
  dic: STD
  re: !!perl/hash:RE_assertion
    assert: '?'
    re: !!perl/hash:RE_method_re
      name: before
      nobind: 1
      re: !!perl/hash:RE_meta
        min: 1
        text: \w
binint: !!perl/hash:RE_ast
  dba: binint
  dic: STD
  re: !!perl/hash:RE_sequence
    zyg:
    - !!perl/hash:RE_quantified_atom
      atom: !!perl/hash:RE_cclass
        i: 0
        text: '[ 0..1 ]'
      quant:
      - +
    - !!perl/hash:RE_quantified_atom
      atom: !!perl/hash:RE_bracket
        re: !!perl/hash:RE_sequence
          zyg:
          - !!perl/hash:RE_string
            i: 0
            text: _
          - !!perl/hash:RE_quantified_atom
            atom: !!perl/hash:RE_cclass
              i: 0
              text: '[ 0..1 ]'
            quant:
            - +
      quant:
      - '*'
binints: !!perl/hash:RE_ast
  dba: binints
  dic: STD
  re: !!perl/hash:RE_quantified_atom
    atom: !!perl/hash:RE_bracket
      re: !!perl/hash:RE_sequence
        zyg:
        - !!perl/hash:RE_method
          name: ws
          rest: ''
        - !!perl/hash:RE_method
          name: binint
          rest: ''
        - !!perl/hash:RE_method
          name: ws
          rest: ''
    quant:
    - '**'
    - ':'
    - !!perl/hash:RE_string
      a: 0
      dba: binints
      dic: STD
      i: 0
      i_needed: 1
      r: 1
      s: 0
      text: ','
category:*:
  dic: STD
category__S_000category: !!perl/hash:RE_ast
  dba: category
  dic: STD
  re: !!perl/hash:RE_method
    i: 0
    name: sym
    rest: ''
    sym: category
category__S_001sigil: !!perl/hash:RE_ast
  dba: category
  dic: STD
  re: !!perl/hash:RE_method
    i: 0
    name: sym
    rest: ''
    sym: sigil
category__S_002twigil: !!perl/hash:RE_ast
  dba: category
  dic: STD
  re: !!perl/hash:RE_method
    i: 0
    name: sym
    rest: ''
    sym: twigil
category__S_003special_variable: !!perl/hash:RE_ast
  dba: category
  dic: STD
  re: !!perl/hash:RE_method
    i: 0
    name: sym
    rest: ''
    sym: special_variable
category__S_004comment: !!perl/hash:RE_ast
  dba: category
  dic: STD
  re: !!perl/hash:RE_method
    i: 0
    name: sym
    rest: ''
    sym: comment
category__S_005version: !!perl/hash:RE_ast
  dba: category
  dic: STD
  re: !!perl/hash:RE_method
    i: 0
    name: sym
    rest: ''
    sym: version
category__S_006module_name: !!perl/hash:RE_ast
  dba: category
  dic: STD
  re: !!perl/hash:RE_method
    i: 0
    name: sym
    rest: ''
    sym: module_name
category__S_007value: !!perl/hash:RE_ast
  dba: category
  dic: STD
  re: !!perl/hash:RE_method
    i: 0
    name: sym
    rest: ''
    sym: value
category__S_008term: !!perl/hash:RE_ast
  dba: category
  dic: STD
  re: !!perl/hash:RE_method
    i: 0
    name: sym
    rest: ''
    sym: term
category__S_009strtonum: !!perl/hash:RE_ast
  dba: category
  dic: STD
  re: !!perl/hash:RE_method
    i: 0
    name: sym
    rest: ''
    sym: strtonum
category__S_010quote: !!perl/hash:RE_ast
  dba: category
  dic: STD
  re: !!perl/hash:RE_method
    i: 0
    name: sym
    rest: ''
    sym: quote
category__S_011prefix: !!perl/hash:RE_ast
  dba: category
  dic: STD
  re: !!perl/hash:RE_method
    i: 0
    name: sym
    rest: ''
    sym: prefix
category__S_012infix: !!perl/hash:RE_ast
  dba: category
  dic: STD
  re: !!perl/hash:RE_method
    i: 0
    name: sym
    rest: ''
    sym: infix
category__S_013postfix: !!perl/hash:RE_ast
  dba: category
  dic: STD
  re: !!perl/hash:RE_method
    i: 0
    name: sym
    rest: ''
    sym: postfix
category__S_014dotty: !!perl/hash:RE_ast
  dba: category
  dic: STD
  re: !!perl/hash:RE_method
    i: 0
    name: sym
    rest: ''
    sym: dotty
category__S_015circumfix: !!perl/hash:RE_ast
  dba: category
  dic: STD
  re: !!perl/hash:RE_method
    i: 0
    name: sym
    rest: ''
    sym: circumfix
category__S_016postcircumfix: !!perl/hash:RE_ast
  dba: category
  dic: STD
  re: !!perl/hash:RE_method
    i: 0
    name: sym
    rest: ''
    sym: postcircumfix
category__S_017quote_mod: !!perl/hash:RE_ast
  dba: category
  dic: STD
  re: !!perl/hash:RE_method
    i: 0
    name: sym
    rest: ''
    sym: quote_mod
category__S_018trait_mod: !!perl/hash:RE_ast
  dba: category
  dic: STD
  re: !!perl/hash:RE_method
    i: 0
    name: sym
    rest: ''
    sym: trait_mod
category__S_019type_declarator: !!perl/hash:RE_ast
  dba: category
  dic: STD
  re: !!perl/hash:RE_method
    i: 0
    name: sym
    rest: ''
    sym: type_declarator
category__S_020scope_declarator: !!perl/hash:RE_ast
  dba: category
  dic: STD
  re: !!perl/hash:RE_method
    i: 0
    name: sym
    rest: ''
    sym: scope_declarator
category__S_021package_declarator: !!perl/hash:RE_ast
  dba: category
  dic: STD
  re: !!perl/hash:RE_method
    i: 0
    name: sym
    rest: ''
    sym: package_declarator
category__S_022multi_declarator: !!perl/hash:RE_ast
  dba: category
  dic: STD
  re: !!perl/hash:RE_method
    i: 0
    name: sym
    rest: ''
    sym: multi_declarator
category__S_023routine_declarator: !!perl/hash:RE_ast
  dba: category
  dic: STD
  re: !!perl/hash:RE_method
    i: 0
    name: sym
    rest: ''
    sym: routine_declarator
category__S_024regex_declarator: !!perl/hash:RE_ast
  dba: category
  dic: STD
  re: !!perl/hash:RE_method
    i: 0
    name: sym
    rest: ''
    sym: regex_declarator
category__S_025statement_prefix: !!perl/hash:RE_ast
  dba: category
  dic: STD
  re: !!perl/hash:RE_method
    i: 0
    name: sym
    rest: ''
    sym: statement_prefix
category__S_026statement_control: !!perl/hash:RE_ast
  dba: category
  dic: STD
  re: !!perl/hash:RE_method
    i: 0
    name: sym
    rest: ''
    sym: statement_control
category__S_027statement_mod_cond: !!perl/hash:RE_ast
  dba: category
  dic: STD
  re: !!perl/hash:RE_method
    i: 0
    name: sym
    rest: ''
    sym: statement_mod_cond
category__S_028statement_mod_loop: !!perl/hash:RE_ast
  dba: category
  dic: STD
  re: !!perl/hash:RE_method
    i: 0
    name: sym
    rest: ''
    sym: statement_mod_loop
category__S_029infix_prefix_meta_operator: !!perl/hash:RE_ast
  dba: category
  dic: STD
  re: !!perl/hash:RE_method
    i: 0
    name: sym
    rest: ''
    sym: infix_prefix_meta_operator
category__S_030infix_postfix_meta_operator: !!perl/hash:RE_ast
  dba: category
  dic: STD
  re: !!perl/hash:RE_method
    i: 0
    name: sym
    rest: ''
    sym: infix_postfix_meta_operator
category__S_031infix_circumfix_meta_operator: !!perl/hash:RE_ast
  dba: category
  dic: STD
  re: !!perl/hash:RE_method
    i: 0
    name: sym
    rest: ''
    sym: infix_circumfix_meta_operator
category__S_032postfix_prefix_meta_operator: !!perl/hash:RE_ast
  dba: category
  dic: STD
  re: !!perl/hash:RE_method
    i: 0
    name: sym
    rest: ''
    sym: postfix_prefix_meta_operator
category__S_033prefix_postfix_meta_operator: !!perl/hash:RE_ast
  dba: category
  dic: STD
  re: !!perl/hash:RE_method
    i: 0
    name: sym
    rest: ''
    sym: prefix_postfix_meta_operator
category__S_034prefix_circumfix_meta_operator: !!perl/hash:RE_ast
  dba: category
  dic: STD
  re: !!perl/hash:RE_method
    i: 0
    name: sym
    rest: ''
    sym: prefix_circumfix_meta_operator
category__S_035terminator: !!perl/hash:RE_ast
  dba: category
  dic: STD
  re: !!perl/hash:RE_method
    i: 0
    name: sym
    rest: ''
    sym: terminator
charname: !!perl/hash:RE_ast
  dba: charname
  dic: STD
  re: !!perl/hash:RE_first
    zyg:
    - !!perl/hash:RE_bracket
      re: &1 !!perl/hash:RE_any
        altname: charname_0
        dba: charname
        dic: STD
        zyg:
        - !!perl/hash:RE_method
          alt: charname_0 0
          name: radint
          rest: ''
        - !!perl/hash:RE_sequence
          alt: charname_0 1
          zyg:
          - !!perl/hash:RE_method
            name: alpha
            rest: ''
          - !!perl/hash:RE_meta
            text: .*?
          - !!perl/hash:RE_assertion
            assert: '?'
            re: !!perl/hash:RE_method_re
              name: before
              nobind: 1
              re: !!perl/hash:RE_sequence
                zyg:
                - !!perl/hash:RE_quantified_atom
                  atom: !!perl/hash:RE_meta
                    min: 1
                    text: \s
                  quant:
                  - '*'
                - !!perl/hash:RE_bracket
                  re: &2 !!perl/hash:RE_any
                    altname: charname_1
                    dba: charname
                    dic: STD
                    zyg:
                    - !!perl/hash:RE_string
                      alt: charname_1 0
                      i: 0
                      text: ','
                    - !!perl/hash:RE_string
                      alt: charname_1 1
                      i: 0
                      text: '#'
                    - !!perl/hash:RE_string
                      alt: charname_1 2
                      i: 0
                      text: ']'
    - !!perl/hash:RE_sequence
      zyg:
      - !!perl/hash:RE_method
        name: sorry
        rest: 1
      - !!perl/hash:RE_meta
        text: .*?
      - !!perl/hash:RE_assertion
        assert: '?'
        re: !!perl/hash:RE_method
          name: terminator
          rest: ''
charname_0: *1
charname_1: *2
charnames: !!perl/hash:RE_ast
  dba: charnames
  dic: STD
  re: !!perl/hash:RE_sequence
    zyg:
    - !!perl/hash:RE_quantified_atom
      atom: !!perl/hash:RE_meta
        min: 1
        text: \s
      quant:
      - '*'
    - !!perl/hash:RE_quantified_atom
      atom: !!perl/hash:RE_bracket
        re: !!perl/hash:RE_sequence
          zyg:
          - !!perl/hash:RE_method
            name: charname
            rest: ''
          - !!perl/hash:RE_method
            name: ws
            rest: ''
      quant:
      - '**'
      - ':'
      - !!perl/hash:RE_bracket
        a: 0
        dba: charnames
        decl: []
        dic: STD
        i: 0
        r: 1
        re: !!perl/hash:RE_sequence
          a: 0
          dba: charnames
          dic: STD
          i: 0
          r: 1
          s: 0
          zyg:
          - !!perl/hash:RE_string
            a: 0
            dba: charnames
            dic: STD
            i: 0
            i_needed: 1
            r: 1
            s: 0
            text: ','
          - !!perl/hash:RE_quantified_atom
            a: 0
            atom: !!perl/hash:RE_meta
              a: 0
              dba: charnames
              dic: STD
              i: 0
              min: 1
              r: 1
              s: 0
              text: \s
            dba: charnames
            dic: STD
            i: 0
            quant:
            - '*'
            - ':'
            - ''
            - 0
            r: 1
            s: 0
        s: 0
charspec: !!perl/hash:RE_ast
  dba: charspec
  dic: STD
  re: !!perl/hash:RE_bracket
    re: &3 !!perl/hash:RE_any
      altname: charspec_0
      dba: character name
      dic: STD
      zyg:
      - !!perl/hash:RE_bracket
        alt: charspec_0 0
        re: !!perl/hash:RE_sequence
          zyg:
          - !!perl/hash:RE_string
            i: 0
            text: '['
          - !!perl/hash:RE_block {}
          - !!perl/hash:RE_method
            name: charnames
            rest: ''
          - !!perl/hash:RE_bracket
            re: !!perl/hash:RE_first
              zyg:
              - !!perl/hash:RE_string
                i: 0
                text: ']'
              - !!perl/hash:RE_method
                name: FAILGOAL
                rest: 1
      - !!perl/hash:RE_quantified_atom
        alt: charspec_0 1
        atom: !!perl/hash:RE_meta
          min: 1
          text: \d
        quant:
        - +
      - !!perl/hash:RE_cclass
        alt: charspec_0 2
        i: 0
        text: '[ ?..Z \\.._ ]'
      - !!perl/hash:RE_sequence
        alt: charspec_0 3
        zyg:
        - !!perl/hash:RE_assertion
          assert: '?'
          re: !!perl/hash:RE_noop
            nobind: 1
        - !!perl/hash:RE_method
          name: sorry
          rest: 1
        - !!perl/hash:RE_meta
          min: 1
          text: .
charspec_0: *3
circumfix:*:
  dic: STD
circumfix__S_051Fre_Nch: !!perl/hash:RE_ast
  dba: shell-quote words
  dic: STD
  re: !!perl/hash:RE_bracket
    re: !!perl/hash:RE_sequence
      zyg:
      - !!perl/hash:RE_string
        i: 0
        text: «
      - !!perl/hash:RE_block {}
      - !!perl/hash:RE_method
        name: nibble
        rest: 1
      - !!perl/hash:RE_bracket
        re: !!perl/hash:RE_first
          zyg:
          - !!perl/hash:RE_string
            i: 0
            text: »
          - !!perl/hash:RE_method
            name: FAILGOAL
            rest: 1
circumfix__S_052LtLt_GtGt: !!perl/hash:RE_ast
  dba: shell-quote words
  dic: STD
  re: !!perl/hash:RE_bracket
    re: !!perl/hash:RE_sequence
      zyg:
      - !!perl/hash:RE_string
        i: 0
        text: <<
      - !!perl/hash:RE_block {}
      - !!perl/hash:RE_method
        name: nibble
        rest: 1
      - !!perl/hash:RE_bracket
        re: !!perl/hash:RE_first
          zyg:
          - !!perl/hash:RE_string
            i: 0
            text: '>>'
          - !!perl/hash:RE_method
            name: FAILGOAL
            rest: 1
circumfix__S_053Lt_Gt: !!perl/hash:RE_ast
  dba: quote words
  dic: STD
  re: !!perl/hash:RE_bracket
    re: !!perl/hash:RE_sequence
      zyg:
      - !!perl/hash:RE_string
        i: 0
        text: <
      - !!perl/hash:RE_block {}
      - !!perl/hash:RE_bracket
        re: !!perl/hash:RE_sequence
          zyg:
          - !!perl/hash:RE_quantified_atom
            atom: !!perl/hash:RE_bracket
              re: !!perl/hash:RE_sequence
                zyg:
                - !!perl/hash:RE_assertion
                  assert: '?'
                  re: !!perl/hash:RE_method_re
                    name: before
                    nobind: 1
                    re: !!perl/hash:RE_string
                      i: 0
                      text: STDIN>
                - !!perl/hash:RE_method
                  name: obs
                  rest: 1
            quant:
            - '?'
          - !!perl/hash:RE_quantified_atom
            atom: !!perl/hash:RE_bracket
              re: !!perl/hash:RE_sequence
                zyg:
                - !!perl/hash:RE_assertion
                  assert: '?'
                  re: !!perl/hash:RE_method_re
                    name: before
                    nobind: 1
                    re: !!perl/hash:RE_string
                      i: 0
                      text: '>'
                - !!perl/hash:RE_method
                  name: obs
                  rest: 1
            quant:
            - '?'
          - !!perl/hash:RE_method
            name: nibble
            rest: 1
      - !!perl/hash:RE_bracket
        re: !!perl/hash:RE_first
          zyg:
          - !!perl/hash:RE_string
            i: 0
            text: '>'
          - !!perl/hash:RE_method
            name: FAILGOAL
            rest: 1
comment:*:
  dic: STD
comment__S_054SharpGraveParenDotDotDotThesis: !!perl/hash:RE_ast
  dba: comment
  dic: STD
  re: !!perl/hash:RE_sequence
    zyg:
    - !!perl/hash:RE_string
      i: 0
      text: '#`'
    - !!perl/hash:RE_meta
      text: '::'
    - !!perl/hash:RE_bracket
      re: !!perl/hash:RE_first
        zyg:
        - !!perl/hash:RE_assertion
          assert: '?'
          re: !!perl/hash:RE_method
            name: opener
            rest: ''
        - !!perl/hash:RE_method
          name: panic
          rest: 1
    - !!perl/hash:RE_method
      name: quibble
      rest: 1
comment__S_055SharpParenDotDotDotThesis: !!perl/hash:RE_ast
  dba: comment
  dic: STD
  re: !!perl/hash:RE_sequence
    zyg:
    - !!perl/hash:RE_string
      i: 0
      text: '#'
    - !!perl/hash:RE_assertion
      assert: '?'
      re: !!perl/hash:RE_method
        name: opener
        rest: ''
    - !!perl/hash:RE_method_re
      name: suppose
      nobind: 1
      re: !!perl/hash:RE_sequence
        zyg:
        - !!perl/hash:RE_method
          name: quibble
          rest: 1
        - !!perl/hash:RE_assertion
          assert: '!'
          re: !!perl/hash:RE_method_re
            name: before
            nobind: 1
            re: !!perl/hash:RE_sequence
              zyg:
              - !!perl/hash:RE_quantified_atom
                atom: !!perl/hash:RE_cclass
                  i: 0
                  text: '[,;:]'
                quant:
                - '*'
              - !!perl/hash:RE_quantified_atom
                atom: !!perl/hash:RE_meta
                  min: 1
                  text: \h
                quant:
                - '*'
              - !!perl/hash:RE_bracket
                re: &4 !!perl/hash:RE_any
                  altname: comment__S_055SharpParenDotDotDotThesis_0
                  dba: comment
                  dic: STD
                  zyg:
                  - !!perl/hash:RE_string
                    alt: comment__S_055SharpParenDotDotDotThesis_0 0
                    i: 0
                    text: '#'
                  - !!perl/hash:RE_meta
                    alt: comment__S_055SharpParenDotDotDotThesis_0 1
                    text: $$
    - !!perl/hash:RE_method
      name: worry
      rest: 1
    - !!perl/hash:RE_assertion
      assert: '!'
      re: !!perl/hash:RE_noop
        nobind: 1
comment__S_055SharpParenDotDotDotThesis_0: *4
comment__S_056SharpEqualParenDotDotDotThesis: !!perl/hash:RE_ast
  dba: comment
  dic: STD
  re: !!perl/hash:RE_sequence
    zyg:
    - !!perl/hash:RE_string
      i: 0
      text: '#='
    - !!perl/hash:RE_assertion
      assert: '?'
      re: !!perl/hash:RE_method
        name: opener
        rest: ''
    - !!perl/hash:RE_meta
      text: '::'
    - !!perl/hash:RE_method
      name: quibble
      rest: 1
comment__S_057SharpEqual: !!perl/hash:RE_ast
  dba: comment
  dic: STD
  re: !!perl/hash:RE_sequence
    zyg:
    - !!perl/hash:RE_string
      i: 0
      text: '#='
    - !!perl/hash:RE_meta
      text: '::'
    - !!perl/hash:RE_bindnamed
      atom: !!perl/hash:RE_bracket
        re: !!perl/hash:RE_quantified_atom
          atom: !!perl/hash:RE_meta
            min: 1
            text: \N
          quant:
          - '*'
comment__S_058Sharp: !!perl/hash:RE_ast
  dba: comment
  dic: STD
  re: !!perl/hash:RE_sequence
    zyg:
    - !!perl/hash:RE_string
      i: 0
      text: '#'
    - !!perl/hash:RE_block {}
    - !!perl/hash:RE_quantified_atom
      atom: !!perl/hash:RE_meta
        min: 1
        text: \N
      quant:
      - '*'
dec_number: !!perl/hash:RE_ast
  dba: decimal number
  dic: STD
  re: !!perl/hash:RE_sequence
    zyg:
    - !!perl/hash:RE_bracket
      re: &5 !!perl/hash:RE_any
        altname: dec_number_0
        dba: decimal number
        dic: STD
        zyg:
        - !!perl/hash:RE_sequence
          alt: dec_number_0 0
          zyg:
          - !!perl/hash:RE_bindnamed
            atom: !!perl/hash:RE_bracket
              re: !!perl/hash:RE_sequence
                zyg:
                - !!perl/hash:RE_string
                  i: 0
                  text: .
                - !!perl/hash:RE_bindnamed
                  atom: !!perl/hash:RE_method
                    name: decint
                    rest: ''
          - !!perl/hash:RE_quantified_atom
            atom: !!perl/hash:RE_method
              name: escale
              rest: ''
            quant:
            - '?'
        - !!perl/hash:RE_sequence
          alt: dec_number_0 1
          zyg:
          - !!perl/hash:RE_bindnamed
            atom: !!perl/hash:RE_bracket
              re: !!perl/hash:RE_sequence
                zyg:
                - !!perl/hash:RE_bindnamed
                  atom: !!perl/hash:RE_method
                    name: decint
                    rest: ''
                - !!perl/hash:RE_string
                  i: 0
                  text: .
                - !!perl/hash:RE_bindnamed
                  atom: !!perl/hash:RE_method
                    name: decint
                    rest: ''
          - !!perl/hash:RE_quantified_atom
            atom: !!perl/hash:RE_method
              name: escale
              rest: ''
            quant:
            - '?'
        - !!perl/hash:RE_sequence
          alt: dec_number_0 2
          zyg:
          - !!perl/hash:RE_bindnamed
            atom: !!perl/hash:RE_bracket
              re: !!perl/hash:RE_bindnamed
                atom: !!perl/hash:RE_method
                  name: decint
                  rest: ''
          - !!perl/hash:RE_method
            name: escale
            rest: ''
    - !!perl/hash:RE_quantified_atom
      atom: !!perl/hash:RE_bracket
        re: !!perl/hash:RE_sequence
          zyg:
          - !!perl/hash:RE_assertion
            assert: '?'
            re: !!perl/hash:RE_method_re
              name: before
              nobind: 1
              re: !!perl/hash:RE_sequence
                zyg:
                - !!perl/hash:RE_string
                  i: 0
                  text: .
                - !!perl/hash:RE_meta
                  min: 1
                  text: \d
          - !!perl/hash:RE_method
            name: sorry
            rest: 1
          - !!perl/hash:RE_quantified_atom
            atom: !!perl/hash:RE_bracket
              re: !!perl/hash:RE_sequence
                zyg:
                - !!perl/hash:RE_string
                  i: 0
                  text: .
                - !!perl/hash:RE_quantified_atom
                  atom: !!perl/hash:RE_meta
                    min: 1
                    text: \d
                  quant:
                  - +
            quant:
            - +
      quant:
      - '?'
    - !!perl/hash:RE_quantified_atom
      atom: !!perl/hash:RE_bracket
        re: !!perl/hash:RE_sequence
          zyg:
          - !!perl/hash:RE_assertion
            assert: '?'
            re: !!perl/hash:RE_method_re
              name: before
              nobind: 1
              re: !!perl/hash:RE_sequence
                zyg:
                - !!perl/hash:RE_string
                  i: 0
                  text: _
                - !!perl/hash:RE_quantified_atom
                  atom: !!perl/hash:RE_string
                    i: 0
                    text: _
                  quant:
                  - +
                - !!perl/hash:RE_meta
                  min: 1
                  text: \d
          - !!perl/hash:RE_method
            name: sorry
            rest: 1
      quant:
      - '?'
dec_number_0: *5
decint: !!perl/hash:RE_ast
  dba: decint
  dic: STD
  re: !!perl/hash:RE_sequence
    zyg:
    - !!perl/hash:RE_quantified_atom
      atom: !!perl/hash:RE_meta
        min: 1
        text: \d
      quant:
      - +
    - !!perl/hash:RE_quantified_atom
      atom: !!perl/hash:RE_bracket
        re: !!perl/hash:RE_sequence
          zyg:
          - !!perl/hash:RE_string
            i: 0
            text: _
          - !!perl/hash:RE_quantified_atom
            atom: !!perl/hash:RE_meta
              min: 1
              text: \d
            quant:
            - +
      quant:
      - '*'
decints: !!perl/hash:RE_ast
  dba: decints
  dic: STD
  re: !!perl/hash:RE_quantified_atom
    atom: !!perl/hash:RE_bracket
      re: !!perl/hash:RE_sequence
        zyg:
        - !!perl/hash:RE_method
          name: ws
          rest: ''
        - !!perl/hash:RE_method
          name: decint
          rest: ''
        - !!perl/hash:RE_method
          name: ws
          rest: ''
    quant:
    - '**'
    - ':'
    - !!perl/hash:RE_string
      a: 0
      dba: decints
      dic: STD
      i: 0
      i_needed: 1
      r: 1
      s: 0
      text: ','
dotty:*:
  dic: STD
embeddedblock: !!perl/hash:RE_ast
  dba: embedded block
  dic: STD
  re: !!perl/hash:RE_sequence
    zyg:
    - !!perl/hash:RE_method
      name: newlex
      rest: ''
    - !!perl/hash:RE_method
      name: finishlex
      rest: ''
    - !!perl/hash:RE_string
      i: 0
      text: '{'
    - !!perl/hash:RE_meta
      text: '::'
    - !!perl/hash:RE_bracket
      re: !!perl/hash:RE_sequence
        zyg:
        - !!perl/hash:RE_decl {}
        - !!perl/hash:RE_method
          name: statementlist
          rest: ''
    - !!perl/hash:RE_bracket
      re: !!perl/hash:RE_first
        zyg:
        - !!perl/hash:RE_string
          i: 0
          text: '}'
        - !!perl/hash:RE_method
          name: panic
          rest: 1
endid: !!perl/hash:RE_ast
  dba: endid
  dic: STD
  re: !!perl/hash:RE_assertion
    assert: '?'
    re: !!perl/hash:RE_method_re
      name: before
      nobind: 1
      re: !!perl/hash:RE_cclass
        i: 0
        text: -[ \- \' \w ]
escale: !!perl/hash:RE_ast
  dba: escale
  dic: STD
  re: !!perl/hash:RE_sequence
    zyg:
    - !!perl/hash:RE_cclass
      i: 0
      text: '[Ee]'
    - !!perl/hash:RE_quantified_atom
      atom: !!perl/hash:RE_cclass
        i: 0
        text: '[+\-]'
      quant:
      - '?'
    - !!perl/hash:RE_method
      name: decint
      rest: ''
escape:*:
  dic: STD
escape__S_048none: !!perl/hash:RE_ast
  dba: escape
  dic: STD
  re: !!perl/hash:RE_assertion
    assert: '!'
    re: !!perl/hash:RE_noop
      nobind: 1
hexint: !!perl/hash:RE_ast
  dba: hexint
  dic: STD
  re: !!perl/hash:RE_sequence
    zyg:
    - !!perl/hash:RE_quantified_atom
      atom: !!perl/hash:RE_cclass
        i: 0
        text: '[ 0..9 a..f A..F ]'
      quant:
      - +
    - !!perl/hash:RE_quantified_atom
      atom: !!perl/hash:RE_bracket
        re: !!perl/hash:RE_sequence
          zyg:
          - !!perl/hash:RE_string
            i: 0
            text: _
          - !!perl/hash:RE_quantified_atom
            atom: !!perl/hash:RE_cclass
              i: 0
              text: '[ 0..9 a..f A..F ]'
            quant:
            - +
      quant:
      - '*'
hexints: !!perl/hash:RE_ast
  dba: hexints
  dic: STD
  re: !!perl/hash:RE_quantified_atom
    atom: !!perl/hash:RE_bracket
      re: !!perl/hash:RE_sequence
        zyg:
        - !!perl/hash:RE_method
          name: ws
          rest: ''
        - !!perl/hash:RE_method
          name: hexint
          rest: ''
        - !!perl/hash:RE_method
          name: ws
          rest: ''
    quant:
    - '**'
    - ':'
    - !!perl/hash:RE_string
      a: 0
      dba: hexints
      dic: STD
      i: 0
      i_needed: 1
      r: 1
      s: 0
      text: ','
ident: !!perl/hash:RE_ast
  dba: ident
  dic: STD
  re: !!perl/hash:RE_sequence
    zyg:
    - !!perl/hash:RE_method
      name: alpha
      rest: ''
    - !!perl/hash:RE_quantified_atom
      atom: !!perl/hash:RE_meta
        min: 1
        text: \w
      quant:
      - '*'
identifier: !!perl/hash:RE_ast
  dba: identifier
  dic: STD
  re: !!perl/hash:RE_sequence
    zyg:
    - !!perl/hash:RE_method
      name: ident
      rest: ''
    - !!perl/hash:RE_quantified_atom
      atom: !!perl/hash:RE_bracket
        re: !!perl/hash:RE_sequence
          zyg:
          - !!perl/hash:RE_method
            name: apostrophe
            rest: ''
          - !!perl/hash:RE_method
            name: ident
            rest: ''
      quant:
      - '*'
infix:*:
  dic: STD
infix_circumfix_meta_operator:*:
  dic: STD
infix_postfix_meta_operator:*:
  dic: STD
infix_prefix_meta_operator:*:
  dic: STD
integer: !!perl/hash:RE_ast
  dba: integer
  dic: STD
  re: !!perl/hash:RE_sequence
    zyg:
    - !!perl/hash:RE_bracket
      re: &6 !!perl/hash:RE_any
        altname: integer_0
        dba: integer
        dic: STD
        zyg:
        - !!perl/hash:RE_sequence
          alt: integer_0 0
          zyg:
          - !!perl/hash:RE_string
            i: 0
            text: '0'
          - !!perl/hash:RE_bracket
            re: &7 !!perl/hash:RE_any
              altname: integer_1
              dba: integer
              dic: STD
              zyg:
              - !!perl/hash:RE_sequence
                alt: integer_1 0
                zyg:
                - !!perl/hash:RE_string
                  i: 0
                  text: b
                - !!perl/hash:RE_quantified_atom
                  atom: !!perl/hash:RE_string
                    i: 0
                    text: _
                  quant:
                  - '?'
                - !!perl/hash:RE_method
                  name: binint
                  rest: ''
              - !!perl/hash:RE_sequence
                alt: integer_1 1
                zyg:
                - !!perl/hash:RE_string
                  i: 0
                  text: o
                - !!perl/hash:RE_quantified_atom
                  atom: !!perl/hash:RE_string
                    i: 0
                    text: _
                  quant:
                  - '?'
                - !!perl/hash:RE_method
                  name: octint
                  rest: ''
              - !!perl/hash:RE_sequence
                alt: integer_1 2
                zyg:
                - !!perl/hash:RE_string
                  i: 0
                  text: x
                - !!perl/hash:RE_quantified_atom
                  atom: !!perl/hash:RE_string
                    i: 0
                    text: _
                  quant:
                  - '?'
                - !!perl/hash:RE_method
                  name: hexint
                  rest: ''
              - !!perl/hash:RE_sequence
                alt: integer_1 3
                zyg:
                - !!perl/hash:RE_string
                  i: 0
                  text: d
                - !!perl/hash:RE_quantified_atom
                  atom: !!perl/hash:RE_string
                    i: 0
                    text: _
                  quant:
                  - '?'
                - !!perl/hash:RE_method
                  name: decint
                  rest: ''
              - !!perl/hash:RE_sequence
                alt: integer_1 4
                zyg:
                - !!perl/hash:RE_method
                  name: decint
                  rest: ''
                - !!perl/hash:RE_assertion
                  assert: '!'
                  re: !!perl/hash:RE_assertion
                    assert: '!'
                    nobind: 1
                    re: !!perl/hash:RE_block
                      nobind: 1
        - !!perl/hash:RE_method
          alt: integer_0 1
          name: decint
          rest: ''
    - !!perl/hash:RE_assertion
      assert: '!'
      re: !!perl/hash:RE_assertion
        assert: '!'
        nobind: 1
        re: !!perl/hash:RE_method_re
          name: before
          nobind: 1
          re: !!perl/hash:RE_quantified_atom
            atom: !!perl/hash:RE_bracket
              re: !!perl/hash:RE_sequence
                zyg:
                - !!perl/hash:RE_string
                  i: 0
                  text: .
                - !!perl/hash:RE_assertion
                  assert: '?'
                  re: !!perl/hash:RE_method_re
                    name: before
                    nobind: 1
                    re: &8 !!perl/hash:RE_any
                      altname: integer_2
                      dba: integer
                      dic: STD
                      zyg:
                      - !!perl/hash:RE_meta
                        alt: integer_2 0
                        min: 1
                        text: \s
                      - !!perl/hash:RE_string
                        alt: integer_2 1
                        i: 0
                        text: ','
                      - !!perl/hash:RE_string
                        alt: integer_2 2
                        i: 0
                        text: =
                      - !!perl/hash:RE_method
                        alt: integer_2 3
                        name: terminator
                        rest: ''
                - !!perl/hash:RE_method
                  name: sorry
                  rest: 1
            quant:
            - '?'
    - !!perl/hash:RE_quantified_atom
      atom: !!perl/hash:RE_bracket
        re: !!perl/hash:RE_sequence
          zyg:
          - !!perl/hash:RE_assertion
            assert: '?'
            re: !!perl/hash:RE_method_re
              name: before
              nobind: 1
              re: !!perl/hash:RE_sequence
                zyg:
                - !!perl/hash:RE_string
                  i: 0
                  text: _
                - !!perl/hash:RE_quantified_atom
                  atom: !!perl/hash:RE_string
                    i: 0
                    text: _
                  quant:
                  - +
                - !!perl/hash:RE_meta
                  min: 1
                  text: \d
          - !!perl/hash:RE_method
            name: sorry
            rest: 1
      quant:
      - '?'
integer_0: *6
integer_1: *7
integer_2: *8
is_ok: !!perl/hash:RE_ast
  dba: is_ok
  dic: STD
  re: !!perl/hash:RE_sequence
    zyg:
    - !!perl/hash:RE_quantified_atom
      atom: !!perl/hash:RE_meta
        min: 1
        text: \N
      quant:
      - '*'
    - !!perl/hash:RE_string
      i: 0
      text: '#OK'
    - !!perl/hash:RE_quantified_atom
      atom: !!perl/hash:RE_meta
        min: 1
        text: \h
      quant:
      - '*'
    - !!perl/hash:RE_bindnamed
      atom: !!perl/hash:RE_bracket
        re: !!perl/hash:RE_quantified_atom
          atom: !!perl/hash:RE_meta
            min: 1
            text: \N
          quant:
          - '*'
    - !!perl/hash:RE_quantified_atom
      atom: !!perl/hash:RE_meta
        min: 1
        text: \h
      quant:
      - '*'
    - !!perl/hash:RE_meta
      text: $$
longname: !!perl/hash:RE_ast
  dba: longname
  dic: STD
  re: !!perl/hash:RE_sequence
    zyg:
    - !!perl/hash:RE_method
      name: name
      rest: ''
    - !!perl/hash:RE_block {}
    - !!perl/hash:RE_quantified_atom
      atom: !!perl/hash:RE_bracket
        re: !!perl/hash:RE_sequence
          zyg:
          - !!perl/hash:RE_assertion
            assert: '?'
            re: !!perl/hash:RE_method_re
              name: before
              nobind: 1
              re: !!perl/hash:RE_sequence
                zyg:
                - !!perl/hash:RE_string
                  i: 0
                  text: ':'
                - !!perl/hash:RE_cclass
                  i: 0
                  text: '[ a..z A..Z _ \< \[ \« ]'
          - !!perl/hash:RE_method
            name: colonpair
            rest: ''
      quant:
      - '*'
module_name:*:
  dic: STD
morename: !!perl/hash:RE_ast
  dba: morename
  dic: STD
  re: !!perl/hash:RE_sequence
    zyg:
    - !!perl/hash:RE_string
      i: 0
      text: '::'
    - !!perl/hash:RE_quantified_atom
      atom: !!perl/hash:RE_bracket
        re: !!perl/hash:RE_first
          zyg:
          - !!perl/hash:RE_sequence
            zyg:
            - !!perl/hash:RE_assertion
              assert: '?'
              re: !!perl/hash:RE_method_re
                name: before
                nobind: 1
                re: &9 !!perl/hash:RE_any
                  altname: morename_0
                  dba: morename
                  dic: STD
                  zyg:
                  - !!perl/hash:RE_string
                    alt: morename_0 0
                    i: 0
                    text: (
                  - !!perl/hash:RE_method
                    alt: morename_0 1
                    name: alpha
                    rest: ''
            - !!perl/hash:RE_bracket
              re: &10 !!perl/hash:RE_any
                altname: morename_1
                dba: indirect name
                dic: STD
                zyg:
                - !!perl/hash:RE_method
                  alt: morename_1 0
                  name: identifier
                  rest: ''
                - !!perl/hash:RE_bracket
                  alt: morename_1 1
                  re: !!perl/hash:RE_sequence
                    zyg:
                    - !!perl/hash:RE_string
                      i: 0
                      text: (
                    - !!perl/hash:RE_block {}
                    - !!perl/hash:RE_method
                      name: EXPR
                      rest: ''
                    - !!perl/hash:RE_bracket
                      re: !!perl/hash:RE_first
                        zyg:
                        - !!perl/hash:RE_string
                          i: 0
                          text: )
                        - !!perl/hash:RE_method
                          name: FAILGOAL
                          rest: 1
          - !!perl/hash:RE_sequence
            zyg:
            - !!perl/hash:RE_assertion
              assert: '?'
              re: !!perl/hash:RE_method_re
                name: before
                nobind: 1
                re: !!perl/hash:RE_string
                  i: 0
                  text: '::'
            - !!perl/hash:RE_method
              name: panic
              rest: 1
      quant:
      - '?'
morename_0: *9
morename_1: *10
multi_declarator:*:
  dic: STD
name: !!perl/hash:RE_ast
  dba: name
  dic: STD
  re: !!perl/hash:RE_bracket
    re: &11 !!perl/hash:RE_any
      altname: name_0
      dba: name
      dic: STD
      zyg:
      - !!perl/hash:RE_sequence
        alt: name_0 0
        zyg:
        - !!perl/hash:RE_method
          name: identifier
          rest: ''
        - !!perl/hash:RE_quantified_atom
          atom: !!perl/hash:RE_method
            name: morename
            rest: ''
          quant:
          - '*'
      - !!perl/hash:RE_quantified_atom
        alt: name_0 1
        atom: !!perl/hash:RE_method
          name: morename
          rest: ''
        quant:
        - +
name_0: *11
nibbler: !!perl/hash:RE_ast
  dba: nibbler
  dic: STD
  re: !!perl/hash:RE_sequence
    zyg:
    - !!perl/hash:RE_block {}
    - !!perl/hash:RE_quantified_atom
      atom: !!perl/hash:RE_bracket
        re: !!perl/hash:RE_sequence
          zyg:
          - !!perl/hash:RE_assertion
            assert: '!'
            re: !!perl/hash:RE_method_re
              name: before
              nobind: 1
              re: !!perl/hash:RE_method
                name: stopper
                rest: ''
          - !!perl/hash:RE_bracket
            re: !!perl/hash:RE_first
              zyg:
              - !!perl/hash:RE_sequence
                zyg:
                - !!perl/hash:RE_method
                  name: starter
                  rest: ''
                - !!perl/hash:RE_method
                  name: nibbler
                  rest: ''
                - !!perl/hash:RE_method
                  name: stopper
                  rest: ''
                - !!perl/hash:RE_block {}
              - !!perl/hash:RE_sequence
                zyg:
                - !!perl/hash:RE_method
                  name: escape
                  rest: ''
                - !!perl/hash:RE_block {}
              - !!perl/hash:RE_sequence
                zyg:
                - !!perl/hash:RE_meta
                  min: 1
                  text: .
                - !!perl/hash:RE_block {}
      quant:
      - '*'
    - !!perl/hash:RE_block {}
nofun: !!perl/hash:RE_ast
  dba: nofun
  dic: STD
  re: !!perl/hash:RE_assertion
    assert: '!'
    re: !!perl/hash:RE_method_re
      name: before
      nobind: 1
      re: &12 !!perl/hash:RE_any
        altname: nofun_0
        dba: nofun
        dic: STD
        zyg:
        - !!perl/hash:RE_string
          alt: nofun_0 0
          i: 0
          text: (
        - !!perl/hash:RE_string
          alt: nofun_0 1
          i: 0
          text: .(
        - !!perl/hash:RE_string
          alt: nofun_0 2
          i: 0
          text: \
        - !!perl/hash:RE_string
          alt: nofun_0 3
          i: 0
          text: ''''
        - !!perl/hash:RE_string
          alt: nofun_0 4
          i: 0
          text: '-'
        - !!perl/hash:RE_double
          alt: nofun_0 5
          i: 0
          text: ''''
        - !!perl/hash:RE_meta
          alt: nofun_0 6
          min: 1
          text: \w
nofun_0: *12
octint: !!perl/hash:RE_ast
  dba: octint
  dic: STD
  re: !!perl/hash:RE_sequence
    zyg:
    - !!perl/hash:RE_quantified_atom
      atom: !!perl/hash:RE_cclass
        i: 0
        text: '[ 0..7 ]'
      quant:
      - +
    - !!perl/hash:RE_quantified_atom
      atom: !!perl/hash:RE_bracket
        re: !!perl/hash:RE_sequence
          zyg:
          - !!perl/hash:RE_string
            i: 0
            text: _
          - !!perl/hash:RE_quantified_atom
            atom: !!perl/hash:RE_cclass
              i: 0
              text: '[ 0..7 ]'
            quant:
            - +
      quant:
      - '*'
octints: !!perl/hash:RE_ast
  dba: octints
  dic: STD
  re: !!perl/hash:RE_quantified_atom
    atom: !!perl/hash:RE_bracket
      re: !!perl/hash:RE_sequence
        zyg:
        - !!perl/hash:RE_method
          name: ws
          rest: ''
        - !!perl/hash:RE_method
          name: octint
          rest: ''
        - !!perl/hash:RE_method
          name: ws
          rest: ''
    quant:
    - '**'
    - ':'
    - !!perl/hash:RE_string
      a: 0
      dba: octints
      dic: STD
      i: 0
      i_needed: 1
      r: 1
      s: 0
      text: ','
opener: !!perl/hash:RE_ast
  dba: opener
  dic: STD
  re: !!perl/hash:RE_cclass
    i: 0
    text: "[\n\\x{0028} \\x{003C} \\x{005B} \\x{007B} \\x{00AB} \\x{0F3A} \\x{0F3C}
      \\x{169B} \\x{2018} \\x{201A} \\x{201B}\n\\x{201C} \\x{201E} \\x{201F} \\x{2039}
      \\x{2045} \\x{207D} \\x{208D} \\x{2208} \\x{2209} \\x{220A} \\x{2215}\n\\x{223C}
      \\x{2243} \\x{2252} \\x{2254} \\x{2264} \\x{2266} \\x{2268} \\x{226A} \\x{226E}
      \\x{2270} \\x{2272}\n\\x{2274} \\x{2276} \\x{2278} \\x{227A} \\x{227C} \\x{227E}
      \\x{2280} \\x{2282} \\x{2284} \\x{2286} \\x{2288}\n\\x{228A} \\x{228F} \\x{2291}
      \\x{2298} \\x{22A2} \\x{22A6} \\x{22A8} \\x{22A9} \\x{22AB} \\x{22B0} \\x{22B2}\n\\x{22B4}
      \\x{22B6} \\x{22C9} \\x{22CB} \\x{22D0} \\x{22D6} \\x{22D8} \\x{22DA} \\x{22DC}
      \\x{22DE} \\x{22E0}\n\\x{22E2} \\x{22E4} \\x{22E6} \\x{22E8} \\x{22EA} \\x{22EC}
      \\x{22F0} \\x{22F2} \\x{22F3} \\x{22F4} \\x{22F6}\n\\x{22F7} \\x{2308} \\x{230A}
      \\x{2329} \\x{23B4} \\x{2768} \\x{276A} \\x{276C} \\x{276E} \\x{2770} \\x{2772}\n\\x{2774}
      \\x{27C3} \\x{27C5} \\x{27D5} \\x{27DD} \\x{27E2} \\x{27E4} \\x{27E6} \\x{27E8}
      \\x{27EA} \\x{2983}\n\\x{2985} \\x{2987} \\x{2989} \\x{298B} \\x{298D} \\x{298F}
      \\x{2991} \\x{2993} \\x{2995} \\x{2997} \\x{29C0}\n\\x{29C4} \\x{29CF} \\x{29D1}
      \\x{29D4} \\x{29D8} \\x{29DA} \\x{29F8} \\x{29FC} \\x{2A2B} \\x{2A2D} \\x{2A34}\n\\x{2A3C}
      \\x{2A64} \\x{2A79} \\x{2A7D} \\x{2A7F} \\x{2A81} \\x{2A83} \\x{2A8B} \\x{2A91}
      \\x{2A93} \\x{2A95}\n\\x{2A97} \\x{2A99} \\x{2A9B} \\x{2AA1} \\x{2AA6} \\x{2AA8}
      \\x{2AAA} \\x{2AAC} \\x{2AAF} \\x{2AB3} \\x{2ABB}\n\\x{2ABD} \\x{2ABF} \\x{2AC1}
      \\x{2AC3} \\x{2AC5} \\x{2ACD} \\x{2ACF} \\x{2AD1} \\x{2AD3} \\x{2AD5} \\x{2AEC}\n\\x{2AF7}
      \\x{2AF9} \\x{2E02} \\x{2E04} \\x{2E09} \\x{2E0C} \\x{2E1C} \\x{2E20} \\x{3008}
      \\x{300A} \\x{300C}\n\\x{300E} \\x{3010} \\x{3014} \\x{3016} \\x{3018} \\x{301A}
      \\x{301D} \\x{FD3E} \\x{FE17} \\x{FE35} \\x{FE37}\n\\x{FE39} \\x{FE3B} \\x{FE3D}
      \\x{FE3F} \\x{FE41} \\x{FE43} \\x{FE47} \\x{FE59} \\x{FE5B} \\x{FE5D} \\x{FF08}\n\\x{FF1C}
      \\x{FF3B} \\x{FF5B} \\x{FF5F} \\x{FF62}\n  ]"
package_declarator:*:
  dic: STD
pod_comment: !!perl/hash:RE_ast
  dba: pod_comment
  dic: STD
  re: !!perl/hash:RE_sequence
    zyg:
    - !!perl/hash:RE_meta
      text: ^^
    - !!perl/hash:RE_quantified_atom
      atom: !!perl/hash:RE_meta
        min: 1
        text: \h
      quant:
      - '*'
    - !!perl/hash:RE_string
      i: 0
      text: =
    - !!perl/hash:RE_quantified_atom
      atom: !!perl/hash:RE_method
        name: unsp
        rest: ''
      quant:
      - '?'
    - !!perl/hash:RE_bracket
      re: &13 !!perl/hash:RE_any
        altname: pod_comment_0
        dba: pod_comment
        dic: STD
        zyg:
        - !!perl/hash:RE_sequence
          alt: pod_comment_0 0
          zyg:
          - !!perl/hash:RE_string
            i: 0
            text: begin
          - !!perl/hash:RE_quantified_atom
            atom: !!perl/hash:RE_meta
              min: 1
              text: \h
            quant:
            - +
          - !!perl/hash:RE_method
            name: identifier
            rest: ''
          - !!perl/hash:RE_meta
            text: '::'
          - !!perl/hash:RE_bracket
            re: !!perl/hash:RE_first
              zyg:
              - !!perl/hash:RE_sequence
                zyg:
                - !!perl/hash:RE_meta
                  text: .*?
                - !!perl/hash:RE_double
                  i: 0
                  text: '

'
                - !!perl/hash:RE_bracket
                  re: !!perl/hash:RE_sequence
                    zyg:
                    - !!perl/hash:RE_quantified_atom
                      atom: !!perl/hash:RE_meta
                        min: 1
                        text: \h
                      quant:
                      - '*'
                    - !!perl/hash:RE_string
                      i: 0
                      text: =
                    - !!perl/hash:RE_quantified_atom
                      atom: !!perl/hash:RE_method
                        name: unsp
                        rest: ''
                      quant:
                      - '?'
                    - !!perl/hash:RE_string
                      i: 0
                      text: end
                    - !!perl/hash:RE_quantified_atom
                      atom: !!perl/hash:RE_meta
                        min: 1
                        text: \h
                      quant:
                      - +
                    - !!perl/hash:RE_var
                      var: $M->{'identifier'}
                    - !!perl/hash:RE_meta
                      text: »
                    - !!perl/hash:RE_quantified_atom
                      atom: !!perl/hash:RE_meta
                        min: 1
                        text: \N
                      quant:
                      - '*'
              - !!perl/hash:RE_sequence
                zyg:
                - !!perl/hash:RE_assertion
                  assert: '?'
                  re: !!perl/hash:RE_block
                    nobind: 1
                - !!perl/hash:RE_quantified_atom
                  atom: !!perl/hash:RE_meta
                    min: 1
                    text: .
                  quant:
                  - '*'
              - !!perl/hash:RE_block {}
        - !!perl/hash:RE_sequence
          alt: pod_comment_0 1
          zyg:
          - !!perl/hash:RE_string
            i: 0
            text: begin
          - !!perl/hash:RE_meta
            text: »
          - !!perl/hash:RE_meta
            text: '::'
          - !!perl/hash:RE_quantified_atom
            atom: !!perl/hash:RE_meta
              min: 1
              text: \h
            quant:
            - '*'
          - !!perl/hash:RE_bracket
            re: !!perl/hash:RE_first
              zyg:
              - !!perl/hash:RE_meta
                text: $$
              - !!perl/hash:RE_string
                i: 0
                text: '#'
              - !!perl/hash:RE_sequence
                zyg:
                - !!perl/hash:RE_method
                  name: sorry
                  rest: 1
                - !!perl/hash:RE_quantified_atom
                  atom: !!perl/hash:RE_meta
                    min: 1
                    text: \N
                  quant:
                  - '*'
          - !!perl/hash:RE_bracket
            re: !!perl/hash:RE_first
              zyg:
              - !!perl/hash:RE_sequence
                zyg:
                - !!perl/hash:RE_meta
                  text: .*?
                - !!perl/hash:RE_double
                  i: 0
                  text: '

'
                - !!perl/hash:RE_quantified_atom
                  atom: !!perl/hash:RE_meta
                    min: 1
                    text: \h
                  quant:
                  - '*'
                - !!perl/hash:RE_string
                  i: 0
                  text: =
                - !!perl/hash:RE_quantified_atom
                  atom: !!perl/hash:RE_method
                    name: unsp
                    rest: ''
                  quant:
                  - '?'
                - !!perl/hash:RE_string
                  i: 0
                  text: end
                - !!perl/hash:RE_meta
                  text: »
                - !!perl/hash:RE_quantified_atom
                  atom: !!perl/hash:RE_meta
                    min: 1
                    text: \N
                  quant:
                  - '*'
              - !!perl/hash:RE_block {}
        - !!perl/hash:RE_sequence
          alt: pod_comment_0 2
          zyg:
          - !!perl/hash:RE_string
            i: 0
            text: for
          - !!perl/hash:RE_meta
            text: »
          - !!perl/hash:RE_meta
            text: '::'
          - !!perl/hash:RE_quantified_atom
            atom: !!perl/hash:RE_meta
              min: 1
              text: \h
            quant:
            - '*'
          - !!perl/hash:RE_bracket
            re: !!perl/hash:RE_first
              zyg:
              - !!perl/hash:RE_method
                name: identifier
                rest: ''
              - !!perl/hash:RE_meta
                text: $$
              - !!perl/hash:RE_string
                i: 0
                text: '#'
              - !!perl/hash:RE_sequence
                zyg:
                - !!perl/hash:RE_method
                  name: sorry
                  rest: 1
                - !!perl/hash:RE_quantified_atom
                  atom: !!perl/hash:RE_meta
                    min: 1
                    text: \N
                  quant:
                  - '*'
          - !!perl/hash:RE_bracket
            re: !!perl/hash:RE_first
              zyg:
              - !!perl/hash:RE_sequence
                zyg:
                - !!perl/hash:RE_meta
                  text: .*?
                - !!perl/hash:RE_meta
                  text: ^^
                - !!perl/hash:RE_quantified_atom
                  atom: !!perl/hash:RE_meta
                    min: 1
                    text: \h
                  quant:
                  - '*'
                - !!perl/hash:RE_meta
                  text: $$
              - !!perl/hash:RE_quantified_atom
                atom: !!perl/hash:RE_meta
                  min: 1
                  text: .
                quant:
                - '*'
        - !!perl/hash:RE_sequence
          alt: pod_comment_0 3
          zyg:
          - !!perl/hash:RE_meta
            text: '::'
          - !!perl/hash:RE_quantified_atom
            atom: !!perl/hash:RE_bracket
              re: !!perl/hash:RE_sequence
                zyg:
                - !!perl/hash:RE_assertion
                  assert: '?'
                  re: !!perl/hash:RE_method_re
                    name: before
                    nobind: 1
                    re: !!perl/hash:RE_sequence
                      zyg:
                      - !!perl/hash:RE_meta
                        text: .*?
                      - !!perl/hash:RE_meta
                        text: ^^
                      - !!perl/hash:RE_string
                        i: 0
                        text: =cut
                      - !!perl/hash:RE_meta
                        text: »
                - !!perl/hash:RE_method
                  name: panic
                  rest: 1
            quant:
            - '?'
          - !!perl/hash:RE_bracket
            re: !!perl/hash:RE_first
              zyg:
              - !!perl/hash:RE_method
                name: alpha
                rest: ''
              - !!perl/hash:RE_meta
                min: 1
                text: \s
              - !!perl/hash:RE_method
                name: sorry
                rest: 1
          - !!perl/hash:RE_quantified_atom
            atom: !!perl/hash:RE_meta
              min: 1
              text: \N
            quant:
            - '*'
pod_comment_0: *13
postcircumfix:*:
  dic: STD
postfix:*:
  dic: STD
postfix_prefix_meta_operator:*:
  dic: STD
prefix:*:
  dic: STD
prefix_circumfix_meta_operator:*:
  dic: STD
prefix_postfix_meta_operator:*:
  dic: STD
quibble: !!perl/hash:RE_ast
  dba: quibble
  dic: STD
  re: !!perl/hash:RE_sequence
    zyg:
    - !!perl/hash:RE_method
      name: babble
      rest: 1
    - !!perl/hash:RE_block {}
    - !!perl/hash:RE_var
      var: $start
    - !!perl/hash:RE_method
      name: nibble
      rest: 1
    - !!perl/hash:RE_bracket
      re: !!perl/hash:RE_first
        zyg:
        - !!perl/hash:RE_var
          var: $stop
        - !!perl/hash:RE_method
          name: panic
          rest: 1
    - !!perl/hash:RE_block {}
quote:*:
  dic: STD
quote__S_049Single_Single: !!perl/hash:RE_ast
  dba: single quotes
  dic: STD
  re: !!perl/hash:RE_bracket
    re: !!perl/hash:RE_sequence
      zyg:
      - !!perl/hash:RE_double
        i: 0
        text: ''''
      - !!perl/hash:RE_block {}
      - !!perl/hash:RE_method
        name: nibble
        rest: 1
      - !!perl/hash:RE_bracket
        re: !!perl/hash:RE_first
          zyg:
          - !!perl/hash:RE_string
            i: 0
            text: ''''
          - !!perl/hash:RE_method
            name: FAILGOAL
            rest: 1
quote__S_050Double_Double: !!perl/hash:RE_ast
  dba: double quotes
  dic: STD
  re: !!perl/hash:RE_bracket
    re: !!perl/hash:RE_sequence
      zyg:
      - !!perl/hash:RE_string
        i: 0
        text: '"'
      - !!perl/hash:RE_block {}
      - !!perl/hash:RE_method
        name: nibble
        rest: 1
      - !!perl/hash:RE_bracket
        re: !!perl/hash:RE_first
          zyg:
          - !!perl/hash:RE_string
            i: 0
            text: '"'
          - !!perl/hash:RE_method
            name: FAILGOAL
            rest: 1
quote_mod:*:
  dic: STD
quotepair: !!perl/hash:RE_ast
  dba: colon pair (restricted)
  dic: STD
  re: !!perl/hash:RE_sequence
    zyg:
    - !!perl/hash:RE_string
      i: 0
      text: ':'
    - !!perl/hash:RE_bracket
      re: &14 !!perl/hash:RE_any
        altname: quotepair_0
        dba: colon pair (restricted)
        dic: STD
        zyg:
        - !!perl/hash:RE_sequence
          alt: quotepair_0 0
          zyg:
          - !!perl/hash:RE_string
            i: 0
            text: '!'
          - !!perl/hash:RE_method
            name: identifier
            rest: ''
          - !!perl/hash:RE_quantified_atom
            atom: !!perl/hash:RE_bracket
              re: !!perl/hash:RE_sequence
                zyg:
                - !!perl/hash:RE_assertion
                  assert: '?'
                  re: !!perl/hash:RE_method_re
                    name: before
                    nobind: 1
                    re: !!perl/hash:RE_string
                      i: 0
                      text: (
                - !!perl/hash:RE_method
                  name: sorry
                  rest: 1
                - !!perl/hash:RE_method
                  name: circumfix
                  rest: ''
            quant:
            - '?'
          - !!perl/hash:RE_block {}
        - !!perl/hash:RE_sequence
          alt: quotepair_0 1
          zyg:
          - !!perl/hash:RE_method
            name: identifier
            rest: ''
          - !!perl/hash:RE_block {}
          - !!perl/hash:RE_bracket
            re: !!perl/hash:RE_first
              zyg:
              - !!perl/hash:RE_sequence
                zyg:
                - !!perl/hash:RE_quantified_atom
                  atom: !!perl/hash:RE_method
                    name: unsp
                    rest: ''
                  quant:
                  - '?'
                - !!perl/hash:RE_assertion
                  assert: '?'
                  re: !!perl/hash:RE_method_re
                    name: before
                    nobind: 1
                    re: !!perl/hash:RE_string
                      i: 0
                      text: (
                - !!perl/hash:RE_method
                  name: circumfix
                  rest: ''
                - !!perl/hash:RE_block {}
              - !!perl/hash:RE_block {}
        - !!perl/hash:RE_sequence
          alt: quotepair_0 2
          zyg:
          - !!perl/hash:RE_bindnamed
            atom: !!perl/hash:RE_paren
              re: !!perl/hash:RE_quantified_atom
                atom: !!perl/hash:RE_meta
                  min: 1
                  text: \d
                quant:
                - +
          - !!perl/hash:RE_bindnamed
            atom: !!perl/hash:RE_paren
              re: !!perl/hash:RE_quantified_atom
                atom: !!perl/hash:RE_cclass
                  i: 0
                  text: '[a..z]'
                quant:
                - +
          - !!perl/hash:RE_quantified_atom
            atom: !!perl/hash:RE_bracket
              re: !!perl/hash:RE_sequence
                zyg:
                - !!perl/hash:RE_assertion
                  assert: '?'
                  re: !!perl/hash:RE_method_re
                    name: before
                    nobind: 1
                    re: !!perl/hash:RE_string
                      i: 0
                      text: (
                - !!perl/hash:RE_method
                  name: sorry
                  rest: 1
                - !!perl/hash:RE_method
                  name: circumfix
                  rest: ''
            quant:
            - '?'
          - !!perl/hash:RE_block {}
    - !!perl/hash:RE_block {}
quotepair_0: *14
rad_number: !!perl/hash:RE_ast
  dba: number in radix notation
  dic: STD
  re: !!perl/hash:RE_sequence
    zyg:
    - !!perl/hash:RE_string
      i: 0
      text: ':'
    - !!perl/hash:RE_bindnamed
      atom: !!perl/hash:RE_bracket
        re: !!perl/hash:RE_quantified_atom
          atom: !!perl/hash:RE_meta
            min: 1
            text: \d
          quant:
          - +
    - !!perl/hash:RE_quantified_atom
      atom: !!perl/hash:RE_method
        name: unsp
        rest: ''
      quant:
      - '?'
    - !!perl/hash:RE_block {}
    - !!perl/hash:RE_bracket
      re: !!perl/hash:RE_first
        zyg:
        - !!perl/hash:RE_sequence
          zyg:
          - !!perl/hash:RE_string
            i: 0
            text: <
          - !!perl/hash:RE_bracket
            re: &15 !!perl/hash:RE_any
              altname: rad_number_0
              dba: number in radix notation
              dic: STD
              zyg:
              - !!perl/hash:RE_bindnamed
                alt: rad_number_0 0
                atom: !!perl/hash:RE_bracket
                  re: !!perl/hash:RE_sequence
                    zyg:
                    - !!perl/hash:RE_string
                      i: 0
                      text: .
                    - !!perl/hash:RE_bindnamed
                      atom: !!perl/hash:RE_method
                        name: alnumint
                        rest: ''
              - !!perl/hash:RE_bindnamed
                alt: rad_number_0 1
                atom: !!perl/hash:RE_bracket
                  re: !!perl/hash:RE_sequence
                    zyg:
                    - !!perl/hash:RE_bindnamed
                      atom: !!perl/hash:RE_method
                        name: alnumint
                        rest: ''
                    - !!perl/hash:RE_string
                      i: 0
                      text: .
                    - !!perl/hash:RE_bindnamed
                      atom: !!perl/hash:RE_method
                        name: alnumint
                        rest: ''
              - !!perl/hash:RE_bindnamed
                alt: rad_number_0 2
                atom: !!perl/hash:RE_bracket
                  re: !!perl/hash:RE_bindnamed
                    atom: !!perl/hash:RE_method
                      name: alnumint
                      rest: ''
          - !!perl/hash:RE_quantified_atom
            atom: !!perl/hash:RE_bracket
              re: !!perl/hash:RE_sequence
                zyg:
                - !!perl/hash:RE_string
                  i: 0
                  text: '*'
                - !!perl/hash:RE_bindnamed
                  atom: !!perl/hash:RE_method
                    name: radint
                    rest: ''
                - !!perl/hash:RE_bracket
                  re: !!perl/hash:RE_first
                    zyg:
                    - !!perl/hash:RE_sequence
                      zyg:
                      - !!perl/hash:RE_string
                        i: 0
                        text: '**'
                      - !!perl/hash:RE_bindnamed
                        atom: !!perl/hash:RE_method
                          name: radint
                          rest: ''
                    - !!perl/hash:RE_method
                      name: sorry
                      rest: 1
            quant:
            - '?'
          - !!perl/hash:RE_string
            i: 0
            text: '>'
        - !!perl/hash:RE_sequence
          zyg:
          - !!perl/hash:RE_assertion
            assert: '?'
            re: !!perl/hash:RE_method_re
              name: before
              nobind: 1
              re: !!perl/hash:RE_string
                i: 0
                text: '['
          - !!perl/hash:RE_method
            name: circumfix
            rest: ''
        - !!perl/hash:RE_sequence
          zyg:
          - !!perl/hash:RE_assertion
            assert: '?'
            re: !!perl/hash:RE_method_re
              name: before
              nobind: 1
              re: !!perl/hash:RE_string
                i: 0
                text: (
          - !!perl/hash:RE_method
            name: circumfix
            rest: ''
        - !!perl/hash:RE_method
          name: panic
          rest: 1
rad_number_0: *15
radint: !!perl/hash:RE_ast
  dba: radint
  dic: STD
  re: !!perl/hash:RE_bracket
    re: &16 !!perl/hash:RE_any
      altname: radint_0
      dba: radint
      dic: STD
      zyg:
      - !!perl/hash:RE_method
        alt: radint_0 0
        name: integer
        rest: ''
      - !!perl/hash:RE_sequence
        alt: radint_0 1
        zyg:
        - !!perl/hash:RE_assertion
          assert: '?'
          re: !!perl/hash:RE_method_re
            name: before
            nobind: 1
            re: !!perl/hash:RE_sequence
              zyg:
              - !!perl/hash:RE_string
                i: 0
                text: ':'
              - !!perl/hash:RE_meta
                min: 1
                text: \d
        - !!perl/hash:RE_method
          name: rad_number
          rest: ''
        - !!perl/hash:RE_assertion
          assert: '?'
          re: !!perl/hash:RE_block
            nobind: 1
radint_0: *16
regex_declarator:*:
  dic: STD
routine_declarator:*:
  dic: STD
scope_declarator:*:
  dic: STD
sigil:*:
  dic: STD
sigil__S_036Dollar: !!perl/hash:RE_ast
  dba: sigil
  dic: STD
  re: !!perl/hash:RE_method
    i: 0
    name: sym
    rest: ''
    sym: $
sigil__S_037At: !!perl/hash:RE_ast
  dba: sigil
  dic: STD
  re: !!perl/hash:RE_method
    i: 0
    name: sym
    rest: ''
    sym: '@'
sigil__S_038Percent: !!perl/hash:RE_ast
  dba: sigil
  dic: STD
  re: !!perl/hash:RE_method
    i: 0
    name: sym
    rest: ''
    sym: '%'
sigil__S_039Amp: !!perl/hash:RE_ast
  dba: sigil
  dic: STD
  re: !!perl/hash:RE_method
    i: 0
    name: sym
    rest: ''
    sym: '&'
spacey: !!perl/hash:RE_ast
  dba: spacey
  dic: STD
  re: !!perl/hash:RE_assertion
    assert: '?'
    re: !!perl/hash:RE_method_re
      name: before
      nobind: 1
      re: !!perl/hash:RE_cclass
        i: 0
        text: '[ \s \# ]'
special_variable:*:
  dic: STD
starter: !!perl/hash:RE_ast
  dba: starter
  dic: STD
  re: !!perl/hash:RE_assertion
    assert: '!'
    re: !!perl/hash:RE_noop
      nobind: 1
statement_control:*:
  dic: STD
statement_mod_cond:*:
  dic: STD
statement_mod_loop:*:
  dic: STD
statement_prefix:*:
  dic: STD
stdstopper: !!perl/hash:RE_ast
  dba: standard stopper
  dic: STD
  re: !!perl/hash:RE_sequence
    zyg:
    - !!perl/hash:RE_bracket
      re: &17 !!perl/hash:RE_any
        altname: stdstopper_0
        dba: standard stopper
        dic: STD
        zyg:
        - !!perl/hash:RE_assertion
          alt: stdstopper_0 0
          assert: '?'
          re: !!perl/hash:RE_method
            name: terminator
            rest: ''
        - !!perl/hash:RE_assertion
          alt: stdstopper_0 1
          assert: '?'
          re: !!perl/hash:RE_method
            name: unitstopper
            rest: ''
        - !!perl/hash:RE_assertion
          alt: stdstopper_0 2
          assert: '?'
          re: !!perl/hash:RE_method_re
            name: before
            nobind: 1
            re: !!perl/hash:RE_method
              name: stopper
              rest: ''
        - !!perl/hash:RE_meta
          alt: stdstopper_0 3
          text: $
    - !!perl/hash:RE_block {}
stdstopper_0: *17
stopper: !!perl/hash:RE_ast
  dba: stopper
  dic: STD
  re: !!perl/hash:RE_assertion
    assert: '!'
    re: !!perl/hash:RE_noop
      nobind: 1
strtonum:*:
  dic: STD
term:*:
  dic: STD
term__S_062miscbad: !!perl/hash:RE_ast
  dba: term
  dic: STD
  re: !!perl/hash:RE_sequence
    zyg:
    - !!perl/hash:RE_block {}
    - !!perl/hash:RE_assertion
      assert: '!'
      re: !!perl/hash:RE_block
        nobind: 1
    - !!perl/hash:RE_block {}
    - !!perl/hash:RE_assertion
      assert: '!'
      re: !!perl/hash:RE_noop
        nobind: 1
terminator:*:
  dic: STD
terminator__S_059Thesis: !!perl/hash:RE_ast
  dba: terminator
  dic: STD
  re: !!perl/hash:RE_sequence
    zyg:
    - !!perl/hash:RE_method
      i: 0
      name: sym
      rest: ''
      sym: )
    - !!perl/hash:RE_method
      name: O
      rest: 1
terminator__S_060Ket: !!perl/hash:RE_ast
  dba: terminator
  dic: STD
  re: !!perl/hash:RE_sequence
    zyg:
    - !!perl/hash:RE_string
      i: 0
      text: ']'
    - !!perl/hash:RE_method
      name: O
      rest: 1
terminator__S_061Ly: !!perl/hash:RE_ast
  dba: terminator
  dic: STD
  re: !!perl/hash:RE_sequence
    zyg:
    - !!perl/hash:RE_string
      i: 0
      text: '}'
    - !!perl/hash:RE_method
      name: O
      rest: 1
trait_mod:*:
  dic: STD
twigil:*:
  dic: STD
twigil__S_040Dot: !!perl/hash:RE_ast
  dba: twigil
  dic: STD
  re: !!perl/hash:RE_sequence
    zyg:
    - !!perl/hash:RE_method
      endsym: begid
      i: 0
      name: sym
      rest: ''
      sym: .
    - !!perl/hash:RE_method
      name: begid
      rest: ''
twigil__S_041Bang: !!perl/hash:RE_ast
  dba: twigil
  dic: STD
  re: !!perl/hash:RE_sequence
    zyg:
    - !!perl/hash:RE_method
      endsym: begid
      i: 0
      name: sym
      rest: ''
      sym: '!'
    - !!perl/hash:RE_method
      name: begid
      rest: ''
twigil__S_042Caret: !!perl/hash:RE_ast
  dba: twigil
  dic: STD
  re: !!perl/hash:RE_sequence
    zyg:
    - !!perl/hash:RE_method
      endsym: begid
      i: 0
      name: sym
      rest: ''
      sym: ^
    - !!perl/hash:RE_method
      name: begid
      rest: ''
twigil__S_043Colon: !!perl/hash:RE_ast
  dba: twigil
  dic: STD
  re: !!perl/hash:RE_sequence
    zyg:
    - !!perl/hash:RE_method
      endsym: begid
      i: 0
      name: sym
      rest: ''
      sym: ':'
    - !!perl/hash:RE_method
      name: begid
      rest: ''
twigil__S_044Star: !!perl/hash:RE_ast
  dba: twigil
  dic: STD
  re: !!perl/hash:RE_sequence
    zyg:
    - !!perl/hash:RE_method
      endsym: begid
      i: 0
      name: sym
      rest: ''
      sym: '*'
    - !!perl/hash:RE_method
      name: begid
      rest: ''
twigil__S_045Question: !!perl/hash:RE_ast
  dba: twigil
  dic: STD
  re: !!perl/hash:RE_sequence
    zyg:
    - !!perl/hash:RE_method
      endsym: begid
      i: 0
      name: sym
      rest: ''
      sym: '?'
    - !!perl/hash:RE_method
      name: begid
      rest: ''
twigil__S_046Equal: !!perl/hash:RE_ast
  dba: twigil
  dic: STD
  re: !!perl/hash:RE_sequence
    zyg:
    - !!perl/hash:RE_method
      endsym: begid
      i: 0
      name: sym
      rest: ''
      sym: =
    - !!perl/hash:RE_method
      name: begid
      rest: ''
twigil__S_047Tilde: !!perl/hash:RE_ast
  dba: twigil
  dic: STD
  re: !!perl/hash:RE_sequence
    zyg:
    - !!perl/hash:RE_method
      endsym: begid
      i: 0
      name: sym
      rest: ''
      sym: '~'
    - !!perl/hash:RE_method
      name: begid
      rest: ''
type_declarator:*:
  dic: STD
unitstopper: !!perl/hash:RE_ast
  dba: unitstopper
  dic: STD
  re: !!perl/hash:RE_meta
    text: $
unsp: !!perl/hash:RE_ast
  dba: unspace
  dic: STD
  re: !!perl/hash:RE_sequence
    zyg:
    - !!perl/hash:RE_meta
      min: 1
      text: \\
    - !!perl/hash:RE_assertion
      assert: '?'
      re: !!perl/hash:RE_method_re
        name: before
        nobind: 1
        re: !!perl/hash:RE_bracket
          re: &18 !!perl/hash:RE_any
            altname: unsp_0
            dba: unsp
            dic: STD
            zyg:
            - !!perl/hash:RE_meta
              alt: unsp_0 0
              min: 1
              text: \s
            - !!perl/hash:RE_string
              alt: unsp_0 1
              i: 0
              text: '#'
    - !!perl/hash:RE_quantified_atom
      atom: !!perl/hash:RE_bracket
        re: &19 !!perl/hash:RE_any
          altname: unsp_1
          dba: unspace
          dic: STD
          zyg:
          - !!perl/hash:RE_method
            alt: unsp_1 0
            name: vws
            rest: ''
          - !!perl/hash:RE_method
            alt: unsp_1 1
            name: unv
            rest: ''
          - !!perl/hash:RE_sequence
            alt: unsp_1 2
            zyg:
            - !!perl/hash:RE_meta
              text: $
            - !!perl/hash:RE_block {}
      quant:
      - '*'
unsp_0: *18
unsp_1: *19
unspacey: !!perl/hash:RE_ast
  dba: unspacey
  dic: STD
  re: !!perl/hash:RE_quantified_atom
    atom: !!perl/hash:RE_method
      name: unsp
      rest: ''
    quant:
    - '?'
unv: !!perl/hash:RE_ast
  dba: horizontal whitespace
  dic: STD
  re: !!perl/hash:RE_bracket
    re: &20 !!perl/hash:RE_any
      altname: unv_0
      dba: horizontal whitespace
      dic: STD
      zyg:
      - !!perl/hash:RE_quantified_atom
        alt: unv_0 0
        atom: !!perl/hash:RE_meta
          min: 1
          text: \h
        quant:
        - +
      - !!perl/hash:RE_sequence
        alt: unv_0 1
        zyg:
        - !!perl/hash:RE_assertion
          assert: '?'
          re: !!perl/hash:RE_method_re
            name: before
            nobind: 1
            re: !!perl/hash:RE_sequence
              zyg:
              - !!perl/hash:RE_quantified_atom
                atom: !!perl/hash:RE_meta
                  min: 1
                  text: \h
                quant:
                - '*'
              - !!perl/hash:RE_string
                i: 0
                text: =
              - !!perl/hash:RE_bracket
                re: &21 !!perl/hash:RE_any
                  altname: unv_1
                  dba: horizontal whitespace
                  dic: STD
                  zyg:
                  - !!perl/hash:RE_meta
                    alt: unv_1 0
                    min: 1
                    text: \w
                  - !!perl/hash:RE_string
                    alt: unv_1 1
                    i: 0
                    text: \
        - !!perl/hash:RE_meta
          text: ^^
        - !!perl/hash:RE_method
          name: pod_comment
          rest: ''
      - !!perl/hash:RE_sequence
        alt: unv_0 2
        zyg:
        - !!perl/hash:RE_quantified_atom
          atom: !!perl/hash:RE_meta
            min: 1
            text: \h
          quant:
          - '*'
        - !!perl/hash:RE_method
          name: comment
          rest: ''
unv_0: *20
unv_1: *21
value:*:
  dic: STD
version:*:
  dic: STD
vws: !!perl/hash:RE_ast
  dba: vertical whitespace
  dic: STD
  re: !!perl/hash:RE_quantified_atom
    atom: !!perl/hash:RE_bracket
      re: !!perl/hash:RE_bracket
        re: &22 !!perl/hash:RE_any
          altname: vws_0
          dba: vertical whitespace
          dic: STD
          zyg:
          - !!perl/hash:RE_meta
            alt: vws_0 0
            min: 1
            text: \v
          - !!perl/hash:RE_sequence
            alt: vws_0 1
            zyg:
            - !!perl/hash:RE_string
              i: 0
              text: '#DEBUG -1'
            - !!perl/hash:RE_block {}
            - !!perl/hash:RE_quantified_atom
              atom: !!perl/hash:RE_meta
                min: 1
                text: \V
              quant:
              - '*'
            - !!perl/hash:RE_meta
              min: 1
              text: \v
          - !!perl/hash:RE_sequence
            alt: vws_0 2
            zyg:
            - !!perl/hash:RE_string
              i: 0
              text: <<<<<<<
            - !!perl/hash:RE_meta
              text: '::'
            - !!perl/hash:RE_assertion
              assert: '?'
              re: !!perl/hash:RE_method_re
                name: before
                nobind: 1
                re: !!perl/hash:RE_sequence
                  zyg:
                  - !!perl/hash:RE_bracket
                    re: !!perl/hash:RE_sequence
                      zyg:
                      - !!perl/hash:RE_meta
                        text: .*?
                      - !!perl/hash:RE_meta
                        min: 1
                        text: \v
                      - !!perl/hash:RE_string
                        i: 0
                        text: =======
                  - !!perl/hash:RE_meta
                    text: .*?
                  - !!perl/hash:RE_meta
                    min: 1
                    text: \v
                  - !!perl/hash:RE_string
                    i: 0
                    text: '>>>>>>>'
            - !!perl/hash:RE_method
              name: sorry
              rest: 1
            - !!perl/hash:RE_quantified_atom
              atom: !!perl/hash:RE_meta
                min: 1
                text: \V
              quant:
              - '*'
            - !!perl/hash:RE_meta
              min: 1
              text: \v
          - !!perl/hash:RE_sequence
            alt: vws_0 3
            zyg:
            - !!perl/hash:RE_string
              i: 0
              text: =======
            - !!perl/hash:RE_meta
              text: '::'
            - !!perl/hash:RE_meta
              text: .*?
            - !!perl/hash:RE_meta
              min: 1
              text: \v
            - !!perl/hash:RE_string
              i: 0
              text: '>>>>>>>'
            - !!perl/hash:RE_quantified_atom
              atom: !!perl/hash:RE_meta
                min: 1
                text: \V
              quant:
              - '*'
            - !!perl/hash:RE_meta
              min: 1
              text: \v
    quant:
    - +
vws_0: *22
ws: !!perl/hash:RE_ast
  dba: whitespace
  dic: STD
  re: !!perl/hash:RE_first
    zyg:
    - !!perl/hash:RE_bracket
      re: &23 !!perl/hash:RE_any
        altname: ws_0
        dba: whitespace
        dic: STD
        zyg:
        - !!perl/hash:RE_sequence
          alt: ws_0 0
          zyg:
          - !!perl/hash:RE_quantified_atom
            atom: !!perl/hash:RE_meta
              min: 1
              text: \h
            quant:
            - +
          - !!perl/hash:RE_assertion
            assert: '!'
            re: !!perl/hash:RE_cclass
              i: 0
              nobind: 1
              text: '[\#\s\\]'
          - !!perl/hash:RE_block {}
        - !!perl/hash:RE_sequence
          alt: ws_0 1
          zyg:
          - !!perl/hash:RE_assertion
            assert: '?'
            re: !!perl/hash:RE_method_re
              name: before
              nobind: 1
              re: !!perl/hash:RE_meta
                min: 1
                text: \w
          - !!perl/hash:RE_assertion
            assert: '?'
            re: !!perl/hash:RE_method_re
              name: after
              nobind: 1
              re: !!perl/hash:RE_meta
                min: 1
                text: \w
          - !!perl/hash:RE_meta
            text: ':::'
          - !!perl/hash:RE_block {}
          - !!perl/hash:RE_method
            name: sorry
            rest: 1
    - !!perl/hash:RE_sequence
      zyg:
      - !!perl/hash:RE_quantified_atom
        atom: !!perl/hash:RE_bracket
          re: &24 !!perl/hash:RE_any
            altname: ws_1
            dba: whitespace
            dic: STD
            zyg:
            - !!perl/hash:RE_method
              alt: ws_1 0
              name: unsp
              rest: ''
            - !!perl/hash:RE_sequence
              alt: ws_1 1
              zyg:
              - !!perl/hash:RE_method
                name: vws
                rest: ''
              - !!perl/hash:RE_method
                name: heredoc
                rest: ''
            - !!perl/hash:RE_method
              alt: ws_1 2
              name: unv
              rest: ''
            - !!perl/hash:RE_sequence
              alt: ws_1 3
              zyg:
              - !!perl/hash:RE_meta
                text: $
              - !!perl/hash:RE_block {}
        quant:
        - '*'
      - !!perl/hash:RE_block {}
ws_0: *23
ws_1: *24
RETREE_END
;
use DEBUG;
use NAME;
use Stash;
use Cursor;
our $ALL;
## method p6class ()
sub p6class {
no warnings 'recursion';
my $self = shift;
'STD::P6' };
## method TOP ($STOP = '')
sub TOP {
no warnings 'recursion';
my $self = shift;
my $STOP = @_ ? shift() : '';
my $lang = $self->cursor_fresh( $self->p6class );
if ($STOP) {
local $::GOAL = $STOP;
$lang->unitstop($STOP)->comp_unit;
}
else {
$lang->comp_unit};
};
our %term            = ('dba' => ('term')            , 'prec' => 'z=');
our %methodcall      = ('dba' => ('methodcall')      , 'prec' => 'y=', 'assoc' => 'unary', 'uassoc' => 'left', 'fiddly' => 1, 'pure' => 0);
our %autoincrement   = ('dba' => ('autoincrement')   , 'prec' => 'x=', 'assoc' => 'unary', 'uassoc' => 'non', 'pure' => 0);
our %exponentiation  = ('dba' => ('exponentiation')  , 'prec' => 'w=', 'assoc' => 'right', 'pure' => 1);
our %symbolic_unary  = ('dba' => ('symbolic unary')  , 'prec' => 'v=', 'assoc' => 'unary', 'uassoc' => 'left', 'pure' => 1);
our %multiplicative  = ('dba' => ('multiplicative')  , 'prec' => 'u=', 'assoc' => 'left', 'pure' => 1);
our %additive        = ('dba' => ('additive')        , 'prec' => 't=', 'assoc' => 'left', 'pure' => 1);
our %replication     = ('dba' => ('replication')     , 'prec' => 's=', 'assoc' => 'left', 'pure' => 1);
our %concatenation   = ('dba' => ('concatenation')   , 'prec' => 'r=', 'assoc' => 'list', 'pure' => 1);
our %junctive_and    = ('dba' => ('junctive and')    , 'prec' => 'q=', 'assoc' => 'list', 'pure' => 1);
our %junctive_or     = ('dba' => ('junctive or')     , 'prec' => 'p=', 'assoc' => 'list', 'pure' => 1);
our %named_unary     = ('dba' => ('named unary')     , 'prec' => 'o=', 'assoc' => 'unary', 'uassoc' => 'left', 'pure' => 1);
our %structural      = ('dba' => ('structural infix'), 'prec' => 'n=', 'assoc' => 'non', 'diffy' => 1);
our %chaining        = ('dba' => ('chaining')        , 'prec' => 'm=', 'assoc' => 'chain', 'diffy' => 1, 'iffy' => 1, 'pure' => 1);
our %tight_and       = ('dba' => ('tight and')       , 'prec' => 'l=', 'assoc' => 'list');
our %tight_or        = ('dba' => ('tight or')        , 'prec' => 'k=', 'assoc' => 'list');
our %conditional     = ('dba' => ('conditional')     , 'prec' => 'j=', 'assoc' => 'right', 'fiddly' => 1);
our %item_assignment = ('dba' => ('item assignment') , 'prec' => 'i=', 'assoc' => 'right', 'pure' => 0);
our %list_assignment = ('dba' => ('list assignment') , 'prec' => 'i=', 'assoc' => 'right', 'sub' => 'e=', 'fiddly' => 1, 'pure' => 0);
our %loose_unary     = ('dba' => ('loose unary')     , 'prec' => 'h=', 'assoc' => 'unary', 'uassoc' => 'left', 'pure' => 1);
our %comma           = ('dba' => ('comma')           , 'prec' => 'g=', 'assoc' => 'list', 'nextterm' => 'nulltermish', 'fiddly' => 1, 'pure' => 1);
our %list_infix      = ('dba' => ('list infix')      , 'prec' => 'f=', 'assoc' => 'list', 'pure' => 1);
our %list_prefix     = ('dba' => ('list prefix')     , 'prec' => 'e=', 'assoc' => 'unary', 'uassoc' => 'left');
our %loose_and       = ('dba' => ('loose and')       , 'prec' => 'd=', 'assoc' => 'list');
our %loose_or        = ('dba' => ('loose or')        , 'prec' => 'c=', 'assoc' => 'list');
our %sequencer       = ('dba' => ('sequencer')       , 'prec' => 'b=', 'assoc' => 'list', 'nextterm' => 'statement', 'fiddly' => 1);
our %LOOSEST         = ('dba' => ('LOOSEST')         , 'prec' => 'a=!');
our %terminator      = ('dba' => ('terminator')      , 'prec' => 'a=', 'assoc' => 'list');
our $LOOSEST = "a=!";
our $item_assignment_prec = 'i=';
our $methodcall_prec = 'y=';
local $::endsym = "null";
local $::endargs = -1;
## token category {*}
sub category__PEEK { $_[0]->_AUTOLEXpeek('category:*',$retree); }
sub category {
my $self = shift;
my $subs;

local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;

my $C = $self->cursor_xact('RULE category');
my $S = $C->{'_pos'};

my @result = do {
my ($tag, $try);
my @try;
my $relex;
my $x;
if (my $fate = $C->{'_fate'}) {
if ($fate->[1] eq 'category') {
$C->deb("Fate passed to category: ", ::fatestr($fate)) if $::DEBUG & DEBUG::fates;
($C->{'_fate'}, $tag, $try) = @$fate;
@try = ($try);
$x = 'ALT category';
}
else {
$x = 'ALTLTM category';
}
}
else {
$x = 'ALTLTM category';
}
my $C = $C->cursor_xact($x);
my $xact = $C->{_xact};

my @gather = ();
for (;;) {
unless (@try) {
$relex //= $C->cursor_fate('STD', 'category:*', $retree);
@try = $relex->($C) or last;
}
$try = shift(@try) // next;

if (ref $try) {
($C->{'_fate'}, $tag, $try) = @$try;       # next candidate fate
}

$C->deb("category trying $tag $try") if $::DEBUG & DEBUG::try_processing;
push @gather, $C->$try(@_);
last if @gather;
last if $xact->[-2];  # committed?
}
$self->_MATCHIFYr($S, "category", @gather);
};
@result;
}
;
## token category:category { <sym> }
sub category__S_000category__PEEK { $_[0]->_AUTOLEXpeek('category__S_000category', $retree) }
sub category__S_000category {
no warnings 'recursion';
my $self = shift;


local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;

my $C = $self->cursor_xact("RULE category__S_000category");
my $xact = $C->xact;
my $S = $C->{'_pos'};
$C->{sym} = "category";
$self->_MATCHIFYr($S, "category__S_000category", $C->_EXACT("category"));
}
;
## token category:sigil { <sym> }
sub category__S_001sigil__PEEK { $_[0]->_AUTOLEXpeek('category__S_001sigil', $retree) }
sub category__S_001sigil {
no warnings 'recursion';
my $self = shift;


local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;

my $C = $self->cursor_xact("RULE category__S_001sigil");
my $xact = $C->xact;
my $S = $C->{'_pos'};
$C->{sym} = "sigil";
$self->_MATCHIFYr($S, "category__S_001sigil", $C->_EXACT("sigil"));
}
;
## token sigil {*}
sub sigil__PEEK { $_[0]->_AUTOLEXpeek('sigil:*',$retree); }
sub sigil {
my $self = shift;
my $subs;

local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;

my $C = $self->cursor_xact('RULE sigil');
my $S = $C->{'_pos'};

my @result = do {
my ($tag, $try);
my @try;
my $relex;
my $x;
if (my $fate = $C->{'_fate'}) {
if ($fate->[1] eq 'sigil') {
$C->deb("Fate passed to sigil: ", ::fatestr($fate)) if $::DEBUG & DEBUG::fates;
($C->{'_fate'}, $tag, $try) = @$fate;
@try = ($try);
$x = 'ALT sigil';
}
else {
$x = 'ALTLTM sigil';
}
}
else {
$x = 'ALTLTM sigil';
}
my $C = $C->cursor_xact($x);
my $xact = $C->{_xact};

my @gather = ();
for (;;) {
unless (@try) {
$relex //= $C->cursor_fate('STD', 'sigil:*', $retree);
@try = $relex->($C) or last;
}
$try = shift(@try) // next;

if (ref $try) {
($C->{'_fate'}, $tag, $try) = @$try;       # next candidate fate
}

$C->deb("sigil trying $tag $try") if $::DEBUG & DEBUG::try_processing;
push @gather, $C->$try(@_);
last if @gather;
last if $xact->[-2];  # committed?
}
$self->_MATCHIFYr($S, "sigil", @gather);
};
@result;
}
;
## token category:twigil { <sym> }
sub category__S_002twigil__PEEK { $_[0]->_AUTOLEXpeek('category__S_002twigil', $retree) }
sub category__S_002twigil {
no warnings 'recursion';
my $self = shift;


local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;

my $C = $self->cursor_xact("RULE category__S_002twigil");
my $xact = $C->xact;
my $S = $C->{'_pos'};
$C->{sym} = "twigil";
$self->_MATCHIFYr($S, "category__S_002twigil", $C->_EXACT("twigil"));
}
;
## token twigil (:$*endsym = 'begid') {*}
sub twigil__PEEK { $_[0]->_AUTOLEXpeek('twigil:*',$retree); }
sub twigil {
my $self = shift;
my $subs;

local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;

my $C = $self->cursor_xact('RULE twigil');
my $S = $C->{'_pos'};

my @result = do {
my ($tag, $try);
my @try;
my $relex;
my $x;
if (my $fate = $C->{'_fate'}) {
if ($fate->[1] eq 'twigil') {
$C->deb("Fate passed to twigil: ", ::fatestr($fate)) if $::DEBUG & DEBUG::fates;
($C->{'_fate'}, $tag, $try) = @$fate;
@try = ($try);
$x = 'ALT twigil';
}
else {
$x = 'ALTLTM twigil';
}
}
else {
$x = 'ALTLTM twigil';
}
my $C = $C->cursor_xact($x);
my $xact = $C->{_xact};

my @gather = ();
for (;;) {
unless (@try) {
$relex //= $C->cursor_fate('STD', 'twigil:*', $retree);
@try = $relex->($C) or last;
}
$try = shift(@try) // next;

if (ref $try) {
($C->{'_fate'}, $tag, $try) = @$try;       # next candidate fate
}

$C->deb("twigil trying $tag $try") if $::DEBUG & DEBUG::try_processing;
push @gather, $C->$try(@_);
last if @gather;
last if $xact->[-2];  # committed?
}
$self->_MATCHIFYr($S, "twigil", @gather);
};
@result;
}
;
## token category:special_variable { <sym> }
sub category__S_003special_variable__PEEK { $_[0]->_AUTOLEXpeek('category__S_003special_variable', $retree) }
sub category__S_003special_variable {
no warnings 'recursion';
my $self = shift;


local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;

my $C = $self->cursor_xact("RULE category__S_003special_variable");
my $xact = $C->xact;
my $S = $C->{'_pos'};
$C->{sym} = "special_variable";
$self->_MATCHIFYr($S, "category__S_003special_variable", $C->_EXACT("special_variable"));
}
;
## token special_variable {*}
sub special_variable__PEEK { $_[0]->_AUTOLEXpeek('special_variable:*',$retree); }
sub special_variable {
my $self = shift;
my $subs;

local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;

my $C = $self->cursor_xact('RULE special_variable');
my $S = $C->{'_pos'};

my @result = do {
my ($tag, $try);
my @try;
my $relex;
my $x;
if (my $fate = $C->{'_fate'}) {
if ($fate->[1] eq 'special_variable') {
$C->deb("Fate passed to special_variable: ", ::fatestr($fate)) if $::DEBUG & DEBUG::fates;
($C->{'_fate'}, $tag, $try) = @$fate;
@try = ($try);
$x = 'ALT special_variable';
}
else {
$x = 'ALTLTM special_variable';
}
}
else {
$x = 'ALTLTM special_variable';
}
my $C = $C->cursor_xact($x);
my $xact = $C->{_xact};

my @gather = ();
for (;;) {
unless (@try) {
$relex //= $C->cursor_fate('STD', 'special_variable:*', $retree);
@try = $relex->($C) or last;
}
$try = shift(@try) // next;

if (ref $try) {
($C->{'_fate'}, $tag, $try) = @$try;       # next candidate fate
}

$C->deb("special_variable trying $tag $try") if $::DEBUG & DEBUG::try_processing;
push @gather, $C->$try(@_);
last if @gather;
last if $xact->[-2];  # committed?
}
$self->_MATCHIFYr($S, "special_variable", @gather);
};
@result;
}
;
## token category:comment { <sym> }
sub category__S_004comment__PEEK { $_[0]->_AUTOLEXpeek('category__S_004comment', $retree) }
sub category__S_004comment {
no warnings 'recursion';
my $self = shift;


local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;

my $C = $self->cursor_xact("RULE category__S_004comment");
my $xact = $C->xact;
my $S = $C->{'_pos'};
$C->{sym} = "comment";
$self->_MATCHIFYr($S, "category__S_004comment", $C->_EXACT("comment"));
}
;
## token comment {*}
sub comment__PEEK { $_[0]->_AUTOLEXpeek('comment:*',$retree); }
sub comment {
my $self = shift;
my $subs;

local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;

my $C = $self->cursor_xact('RULE comment');
my $S = $C->{'_pos'};

my @result = do {
my ($tag, $try);
my @try;
my $relex;
my $x;
if (my $fate = $C->{'_fate'}) {
if ($fate->[1] eq 'comment') {
$C->deb("Fate passed to comment: ", ::fatestr($fate)) if $::DEBUG & DEBUG::fates;
($C->{'_fate'}, $tag, $try) = @$fate;
@try = ($try);
$x = 'ALT comment';
}
else {
$x = 'ALTLTM comment';
}
}
else {
$x = 'ALTLTM comment';
}
my $C = $C->cursor_xact($x);
my $xact = $C->{_xact};

my @gather = ();
for (;;) {
unless (@try) {
$relex //= $C->cursor_fate('STD', 'comment:*', $retree);
@try = $relex->($C) or last;
}
$try = shift(@try) // next;

if (ref $try) {
($C->{'_fate'}, $tag, $try) = @$try;       # next candidate fate
}

$C->deb("comment trying $tag $try") if $::DEBUG & DEBUG::try_processing;
push @gather, $C->$try(@_);
last if @gather;
last if $xact->[-2];  # committed?
}
$self->_MATCHIFYr($S, "comment", @gather);
};
@result;
}
;
## token category:version { <sym> }
sub category__S_005version__PEEK { $_[0]->_AUTOLEXpeek('category__S_005version', $retree) }
sub category__S_005version {
no warnings 'recursion';
my $self = shift;


local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;

my $C = $self->cursor_xact("RULE category__S_005version");
my $xact = $C->xact;
my $S = $C->{'_pos'};
$C->{sym} = "version";
$self->_MATCHIFYr($S, "category__S_005version", $C->_EXACT("version"));
}
;
## token version {*}
sub version__PEEK { $_[0]->_AUTOLEXpeek('version:*',$retree); }
sub version {
my $self = shift;
my $subs;

local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;

my $C = $self->cursor_xact('RULE version');
my $S = $C->{'_pos'};

my @result = do {
my ($tag, $try);
my @try;
my $relex;
my $x;
if (my $fate = $C->{'_fate'}) {
if ($fate->[1] eq 'version') {
$C->deb("Fate passed to version: ", ::fatestr($fate)) if $::DEBUG & DEBUG::fates;
($C->{'_fate'}, $tag, $try) = @$fate;
@try = ($try);
$x = 'ALT version';
}
else {
$x = 'ALTLTM version';
}
}
else {
$x = 'ALTLTM version';
}
my $C = $C->cursor_xact($x);
my $xact = $C->{_xact};

my @gather = ();
for (;;) {
unless (@try) {
$relex //= $C->cursor_fate('STD', 'version:*', $retree);
@try = $relex->($C) or last;
}
$try = shift(@try) // next;

if (ref $try) {
($C->{'_fate'}, $tag, $try) = @$try;       # next candidate fate
}

$C->deb("version trying $tag $try") if $::DEBUG & DEBUG::try_processing;
push @gather, $C->$try(@_);
last if @gather;
last if $xact->[-2];  # committed?
}
$self->_MATCHIFYr($S, "version", @gather);
};
@result;
}
;
## token category:module_name { <sym> }
sub category__S_006module_name__PEEK { $_[0]->_AUTOLEXpeek('category__S_006module_name', $retree) }
sub category__S_006module_name {
no warnings 'recursion';
my $self = shift;


local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;

my $C = $self->cursor_xact("RULE category__S_006module_name");
my $xact = $C->xact;
my $S = $C->{'_pos'};
$C->{sym} = "module_name";
$self->_MATCHIFYr($S, "category__S_006module_name", $C->_EXACT("module_name"));
}
;
## token module_name {*}
sub module_name__PEEK { $_[0]->_AUTOLEXpeek('module_name:*',$retree); }
sub module_name {
my $self = shift;
my $subs;

local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;

my $C = $self->cursor_xact('RULE module_name');
my $S = $C->{'_pos'};

my @result = do {
my ($tag, $try);
my @try;
my $relex;
my $x;
if (my $fate = $C->{'_fate'}) {
if ($fate->[1] eq 'module_name') {
$C->deb("Fate passed to module_name: ", ::fatestr($fate)) if $::DEBUG & DEBUG::fates;
($C->{'_fate'}, $tag, $try) = @$fate;
@try = ($try);
$x = 'ALT module_name';
}
else {
$x = 'ALTLTM module_name';
}
}
else {
$x = 'ALTLTM module_name';
}
my $C = $C->cursor_xact($x);
my $xact = $C->{_xact};

my @gather = ();
for (;;) {
unless (@try) {
$relex //= $C->cursor_fate('STD', 'module_name:*', $retree);
@try = $relex->($C) or last;
}
$try = shift(@try) // next;

if (ref $try) {
($C->{'_fate'}, $tag, $try) = @$try;       # next candidate fate
}

$C->deb("module_name trying $tag $try") if $::DEBUG & DEBUG::try_processing;
push @gather, $C->$try(@_);
last if @gather;
last if $xact->[-2];  # committed?
}
$self->_MATCHIFYr($S, "module_name", @gather);
};
@result;
}
;
## token category:value { <sym> }
sub category__S_007value__PEEK { $_[0]->_AUTOLEXpeek('category__S_007value', $retree) }
sub category__S_007value {
no warnings 'recursion';
my $self = shift;


local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;

my $C = $self->cursor_xact("RULE category__S_007value");
my $xact = $C->xact;
my $S = $C->{'_pos'};
$C->{sym} = "value";
$self->_MATCHIFYr($S, "category__S_007value", $C->_EXACT("value"));
}
;
## token value {*}
sub value__PEEK { $_[0]->_AUTOLEXpeek('value:*',$retree); }
sub value {
my $self = shift;
my $subs;

local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;

my $C = $self->cursor_xact('RULE value');
my $S = $C->{'_pos'};

my @result = do {
my ($tag, $try);
my @try;
my $relex;
my $x;
if (my $fate = $C->{'_fate'}) {
if ($fate->[1] eq 'value') {
$C->deb("Fate passed to value: ", ::fatestr($fate)) if $::DEBUG & DEBUG::fates;
($C->{'_fate'}, $tag, $try) = @$fate;
@try = ($try);
$x = 'ALT value';
}
else {
$x = 'ALTLTM value';
}
}
else {
$x = 'ALTLTM value';
}
my $C = $C->cursor_xact($x);
my $xact = $C->{_xact};

my @gather = ();
for (;;) {
unless (@try) {
$relex //= $C->cursor_fate('STD', 'value:*', $retree);
@try = $relex->($C) or last;
}
$try = shift(@try) // next;

if (ref $try) {
($C->{'_fate'}, $tag, $try) = @$try;       # next candidate fate
}

$C->deb("value trying $tag $try") if $::DEBUG & DEBUG::try_processing;
push @gather, $C->$try(@_);
last if @gather;
last if $xact->[-2];  # committed?
}
$self->_MATCHIFYr($S, "value", @gather);
};
@result;
}
;
## token category:term { <sym> }
sub category__S_008term__PEEK { $_[0]->_AUTOLEXpeek('category__S_008term', $retree) }
sub category__S_008term {
no warnings 'recursion';
my $self = shift;


local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;

my $C = $self->cursor_xact("RULE category__S_008term");
my $xact = $C->xact;
my $S = $C->{'_pos'};
$C->{sym} = "term";
$self->_MATCHIFYr($S, "category__S_008term", $C->_EXACT("term"));
}
;
## token term {*}
sub term__PEEK { $_[0]->_AUTOLEXpeek('term:*',$retree); }
sub term {
my $self = shift;
my $subs;

local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;

my $C = $self->cursor_xact('RULE term');
my $S = $C->{'_pos'};

my @result = do {
my ($tag, $try);
my @try;
my $relex;
my $x;
if (my $fate = $C->{'_fate'}) {
if ($fate->[1] eq 'term') {
$C->deb("Fate passed to term: ", ::fatestr($fate)) if $::DEBUG & DEBUG::fates;
($C->{'_fate'}, $tag, $try) = @$fate;
@try = ($try);
$x = 'ALT term';
}
else {
$x = 'ALTLTM term';
}
}
else {
$x = 'ALTLTM term';
}
my $C = $C->cursor_xact($x);
my $xact = $C->{_xact};

my @gather = ();
for (;;) {
unless (@try) {
$relex //= $C->cursor_fate('STD', 'term:*', $retree);
@try = $relex->($C) or last;
}
$try = shift(@try) // next;

if (ref $try) {
($C->{'_fate'}, $tag, $try) = @$try;       # next candidate fate
}

$C->deb("term trying $tag $try") if $::DEBUG & DEBUG::try_processing;
push @gather, $C->$try(@_);
last if @gather;
last if $xact->[-2];  # committed?
}
$self->_MATCHIFYr($S, "term", @gather);
};
@result;
}
;
## token category:strtonum { <sym> }
sub category__S_009strtonum__PEEK { $_[0]->_AUTOLEXpeek('category__S_009strtonum', $retree) }
sub category__S_009strtonum {
no warnings 'recursion';
my $self = shift;


local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;

my $C = $self->cursor_xact("RULE category__S_009strtonum");
my $xact = $C->xact;
my $S = $C->{'_pos'};
$C->{sym} = "strtonum";
$self->_MATCHIFYr($S, "category__S_009strtonum", $C->_EXACT("strtonum"));
}
;
## token strtonum {*}
sub strtonum__PEEK { $_[0]->_AUTOLEXpeek('strtonum:*',$retree); }
sub strtonum {
my $self = shift;
my $subs;

local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;

my $C = $self->cursor_xact('RULE strtonum');
my $S = $C->{'_pos'};

my @result = do {
my ($tag, $try);
my @try;
my $relex;
my $x;
if (my $fate = $C->{'_fate'}) {
if ($fate->[1] eq 'strtonum') {
$C->deb("Fate passed to strtonum: ", ::fatestr($fate)) if $::DEBUG & DEBUG::fates;
($C->{'_fate'}, $tag, $try) = @$fate;
@try = ($try);
$x = 'ALT strtonum';
}
else {
$x = 'ALTLTM strtonum';
}
}
else {
$x = 'ALTLTM strtonum';
}
my $C = $C->cursor_xact($x);
my $xact = $C->{_xact};

my @gather = ();
for (;;) {
unless (@try) {
$relex //= $C->cursor_fate('STD', 'strtonum:*', $retree);
@try = $relex->($C) or last;
}
$try = shift(@try) // next;

if (ref $try) {
($C->{'_fate'}, $tag, $try) = @$try;       # next candidate fate
}

$C->deb("strtonum trying $tag $try") if $::DEBUG & DEBUG::try_processing;
push @gather, $C->$try(@_);
last if @gather;
last if $xact->[-2];  # committed?
}
$self->_MATCHIFYr($S, "strtonum", @gather);
};
@result;
}
;
## token category:quote { <sym> }
sub category__S_010quote__PEEK { $_[0]->_AUTOLEXpeek('category__S_010quote', $retree) }
sub category__S_010quote {
no warnings 'recursion';
my $self = shift;


local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;

my $C = $self->cursor_xact("RULE category__S_010quote");
my $xact = $C->xact;
my $S = $C->{'_pos'};
$C->{sym} = "quote";
$self->_MATCHIFYr($S, "category__S_010quote", $C->_EXACT("quote"));
}
;
## token quote () {*}
sub quote__PEEK { $_[0]->_AUTOLEXpeek('quote:*',$retree); }
sub quote {
my $self = shift;
my $subs;

local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;

my $C = $self->cursor_xact('RULE quote');
my $S = $C->{'_pos'};

my @result = do {
my ($tag, $try);
my @try;
my $relex;
my $x;
if (my $fate = $C->{'_fate'}) {
if ($fate->[1] eq 'quote') {
$C->deb("Fate passed to quote: ", ::fatestr($fate)) if $::DEBUG & DEBUG::fates;
($C->{'_fate'}, $tag, $try) = @$fate;
@try = ($try);
$x = 'ALT quote';
}
else {
$x = 'ALTLTM quote';
}
}
else {
$x = 'ALTLTM quote';
}
my $C = $C->cursor_xact($x);
my $xact = $C->{_xact};

my @gather = ();
for (;;) {
unless (@try) {
$relex //= $C->cursor_fate('STD', 'quote:*', $retree);
@try = $relex->($C) or last;
}
$try = shift(@try) // next;

if (ref $try) {
($C->{'_fate'}, $tag, $try) = @$try;       # next candidate fate
}

$C->deb("quote trying $tag $try") if $::DEBUG & DEBUG::try_processing;
push @gather, $C->$try(@_);
last if @gather;
last if $xact->[-2];  # committed?
}
$self->_MATCHIFYr($S, "quote", @gather);
};
@result;
}
;
## token category:prefix { <sym> }
sub category__S_011prefix__PEEK { $_[0]->_AUTOLEXpeek('category__S_011prefix', $retree) }
sub category__S_011prefix {
no warnings 'recursion';
my $self = shift;


local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;

my $C = $self->cursor_xact("RULE category__S_011prefix");
my $xact = $C->xact;
my $S = $C->{'_pos'};
$C->{sym} = "prefix";
$self->_MATCHIFYr($S, "category__S_011prefix", $C->_EXACT("prefix"));
}
;
## token prefix is unary is defequiv(%symbolic_unary) {*}
sub prefix__PEEK { $_[0]->_AUTOLEXpeek('prefix:*',$retree); }
sub prefix {
my $self = shift;
my $subs;

local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;

my $C = $self->cursor_xact('RULE prefix');
my $S = $C->{'_pos'};

my @result = do {
my ($tag, $try);
my @try;
my $relex;
my $x;
if (my $fate = $C->{'_fate'}) {
if ($fate->[1] eq 'prefix') {
$C->deb("Fate passed to prefix: ", ::fatestr($fate)) if $::DEBUG & DEBUG::fates;
($C->{'_fate'}, $tag, $try) = @$fate;
@try = ($try);
$x = 'ALT prefix';
}
else {
$x = 'ALTLTM prefix';
}
}
else {
$x = 'ALTLTM prefix';
}
my $C = $C->cursor_xact($x);
my $xact = $C->{_xact};

my @gather = ();
for (;;) {
unless (@try) {
$relex //= $C->cursor_fate('STD', 'prefix:*', $retree);
@try = $relex->($C) or last;
}
$try = shift(@try) // next;

if (ref $try) {
($C->{'_fate'}, $tag, $try) = @$try;       # next candidate fate
}

$C->deb("prefix trying $tag $try") if $::DEBUG & DEBUG::try_processing;
push @gather, $C->$try(@_);
last if @gather;
last if $xact->[-2];  # committed?
}
$self->_MATCHIFYr($S, "prefix", @gather);
};
@result;
}
;
## token category:infix { <sym> }
sub category__S_012infix__PEEK { $_[0]->_AUTOLEXpeek('category__S_012infix', $retree) }
sub category__S_012infix {
no warnings 'recursion';
my $self = shift;


local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;

my $C = $self->cursor_xact("RULE category__S_012infix");
my $xact = $C->xact;
my $S = $C->{'_pos'};
$C->{sym} = "infix";
$self->_MATCHIFYr($S, "category__S_012infix", $C->_EXACT("infix"));
}
;
## token infix is binary is defequiv(%additive) {*}
sub infix__PEEK { $_[0]->_AUTOLEXpeek('infix:*',$retree); }
sub infix {
my $self = shift;
my $subs;

local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;

my $C = $self->cursor_xact('RULE infix');
my $S = $C->{'_pos'};

my @result = do {
my ($tag, $try);
my @try;
my $relex;
my $x;
if (my $fate = $C->{'_fate'}) {
if ($fate->[1] eq 'infix') {
$C->deb("Fate passed to infix: ", ::fatestr($fate)) if $::DEBUG & DEBUG::fates;
($C->{'_fate'}, $tag, $try) = @$fate;
@try = ($try);
$x = 'ALT infix';
}
else {
$x = 'ALTLTM infix';
}
}
else {
$x = 'ALTLTM infix';
}
my $C = $C->cursor_xact($x);
my $xact = $C->{_xact};

my @gather = ();
for (;;) {
unless (@try) {
$relex //= $C->cursor_fate('STD', 'infix:*', $retree);
@try = $relex->($C) or last;
}
$try = shift(@try) // next;

if (ref $try) {
($C->{'_fate'}, $tag, $try) = @$try;       # next candidate fate
}

$C->deb("infix trying $tag $try") if $::DEBUG & DEBUG::try_processing;
push @gather, $C->$try(@_);
last if @gather;
last if $xact->[-2];  # committed?
}
$self->_MATCHIFYr($S, "infix", @gather);
};
@result;
}
;
## token category:postfix { <sym> }
sub category__S_013postfix__PEEK { $_[0]->_AUTOLEXpeek('category__S_013postfix', $retree) }
sub category__S_013postfix {
no warnings 'recursion';
my $self = shift;


local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;

my $C = $self->cursor_xact("RULE category__S_013postfix");
my $xact = $C->xact;
my $S = $C->{'_pos'};
$C->{sym} = "postfix";
$self->_MATCHIFYr($S, "category__S_013postfix", $C->_EXACT("postfix"));
}
;
## token postfix is unary is defequiv(%autoincrement) {*}
sub postfix__PEEK { $_[0]->_AUTOLEXpeek('postfix:*',$retree); }
sub postfix {
my $self = shift;
my $subs;

local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;

my $C = $self->cursor_xact('RULE postfix');
my $S = $C->{'_pos'};

my @result = do {
my ($tag, $try);
my @try;
my $relex;
my $x;
if (my $fate = $C->{'_fate'}) {
if ($fate->[1] eq 'postfix') {
$C->deb("Fate passed to postfix: ", ::fatestr($fate)) if $::DEBUG & DEBUG::fates;
($C->{'_fate'}, $tag, $try) = @$fate;
@try = ($try);
$x = 'ALT postfix';
}
else {
$x = 'ALTLTM postfix';
}
}
else {
$x = 'ALTLTM postfix';
}
my $C = $C->cursor_xact($x);
my $xact = $C->{_xact};

my @gather = ();
for (;;) {
unless (@try) {
$relex //= $C->cursor_fate('STD', 'postfix:*', $retree);
@try = $relex->($C) or last;
}
$try = shift(@try) // next;

if (ref $try) {
($C->{'_fate'}, $tag, $try) = @$try;       # next candidate fate
}

$C->deb("postfix trying $tag $try") if $::DEBUG & DEBUG::try_processing;
push @gather, $C->$try(@_);
last if @gather;
last if $xact->[-2];  # committed?
}
$self->_MATCHIFYr($S, "postfix", @gather);
};
@result;
}
;
## token category:dotty { <sym> }
sub category__S_014dotty__PEEK { $_[0]->_AUTOLEXpeek('category__S_014dotty', $retree) }
sub category__S_014dotty {
no warnings 'recursion';
my $self = shift;


local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;

my $C = $self->cursor_xact("RULE category__S_014dotty");
my $xact = $C->xact;
my $S = $C->{'_pos'};
$C->{sym} = "dotty";
$self->_MATCHIFYr($S, "category__S_014dotty", $C->_EXACT("dotty"));
}
;
## token dotty (:$*endsym = 'unspacey') {*}
sub dotty__PEEK { $_[0]->_AUTOLEXpeek('dotty:*',$retree); }
sub dotty {
my $self = shift;
my $subs;

local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;

my $C = $self->cursor_xact('RULE dotty');
my $S = $C->{'_pos'};

my @result = do {
my ($tag, $try);
my @try;
my $relex;
my $x;
if (my $fate = $C->{'_fate'}) {
if ($fate->[1] eq 'dotty') {
$C->deb("Fate passed to dotty: ", ::fatestr($fate)) if $::DEBUG & DEBUG::fates;
($C->{'_fate'}, $tag, $try) = @$fate;
@try = ($try);
$x = 'ALT dotty';
}
else {
$x = 'ALTLTM dotty';
}
}
else {
$x = 'ALTLTM dotty';
}
my $C = $C->cursor_xact($x);
my $xact = $C->{_xact};

my @gather = ();
for (;;) {
unless (@try) {
$relex //= $C->cursor_fate('STD', 'dotty:*', $retree);
@try = $relex->($C) or last;
}
$try = shift(@try) // next;

if (ref $try) {
($C->{'_fate'}, $tag, $try) = @$try;       # next candidate fate
}

$C->deb("dotty trying $tag $try") if $::DEBUG & DEBUG::try_processing;
push @gather, $C->$try(@_);
last if @gather;
last if $xact->[-2];  # committed?
}
$self->_MATCHIFYr($S, "dotty", @gather);
};
@result;
}
;
## token category:circumfix { <sym> }
sub category__S_015circumfix__PEEK { $_[0]->_AUTOLEXpeek('category__S_015circumfix', $retree) }
sub category__S_015circumfix {
no warnings 'recursion';
my $self = shift;


local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;

my $C = $self->cursor_xact("RULE category__S_015circumfix");
my $xact = $C->xact;
my $S = $C->{'_pos'};
$C->{sym} = "circumfix";
$self->_MATCHIFYr($S, "category__S_015circumfix", $C->_EXACT("circumfix"));
}
;
## token circumfix {*}
sub circumfix__PEEK { $_[0]->_AUTOLEXpeek('circumfix:*',$retree); }
sub circumfix {
my $self = shift;
my $subs;

local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;

my $C = $self->cursor_xact('RULE circumfix');
my $S = $C->{'_pos'};

my @result = do {
my ($tag, $try);
my @try;
my $relex;
my $x;
if (my $fate = $C->{'_fate'}) {
if ($fate->[1] eq 'circumfix') {
$C->deb("Fate passed to circumfix: ", ::fatestr($fate)) if $::DEBUG & DEBUG::fates;
($C->{'_fate'}, $tag, $try) = @$fate;
@try = ($try);
$x = 'ALT circumfix';
}
else {
$x = 'ALTLTM circumfix';
}
}
else {
$x = 'ALTLTM circumfix';
}
my $C = $C->cursor_xact($x);
my $xact = $C->{_xact};

my @gather = ();
for (;;) {
unless (@try) {
$relex //= $C->cursor_fate('STD', 'circumfix:*', $retree);
@try = $relex->($C) or last;
}
$try = shift(@try) // next;

if (ref $try) {
($C->{'_fate'}, $tag, $try) = @$try;       # next candidate fate
}

$C->deb("circumfix trying $tag $try") if $::DEBUG & DEBUG::try_processing;
push @gather, $C->$try(@_);
last if @gather;
last if $xact->[-2];  # committed?
}
$self->_MATCHIFYr($S, "circumfix", @gather);
};
@result;
}
;
## token category:postcircumfix { <sym> }
sub category__S_016postcircumfix__PEEK { $_[0]->_AUTOLEXpeek('category__S_016postcircumfix', $retree) }
sub category__S_016postcircumfix {
no warnings 'recursion';
my $self = shift;


local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;

my $C = $self->cursor_xact("RULE category__S_016postcircumfix");
my $xact = $C->xact;
my $S = $C->{'_pos'};
$C->{sym} = "postcircumfix";
$self->_MATCHIFYr($S, "category__S_016postcircumfix", $C->_EXACT("postcircumfix"));
}
;
## token postcircumfix is unary {*}  # unary as far as EXPR knows...
sub postcircumfix__PEEK { $_[0]->_AUTOLEXpeek('postcircumfix:*',$retree); }
sub postcircumfix {
my $self = shift;
my $subs;

local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;

my $C = $self->cursor_xact('RULE postcircumfix');
my $S = $C->{'_pos'};

my @result = do {
my ($tag, $try);
my @try;
my $relex;
my $x;
if (my $fate = $C->{'_fate'}) {
if ($fate->[1] eq 'postcircumfix') {
$C->deb("Fate passed to postcircumfix: ", ::fatestr($fate)) if $::DEBUG & DEBUG::fates;
($C->{'_fate'}, $tag, $try) = @$fate;
@try = ($try);
$x = 'ALT postcircumfix';
}
else {
$x = 'ALTLTM postcircumfix';
}
}
else {
$x = 'ALTLTM postcircumfix';
}
my $C = $C->cursor_xact($x);
my $xact = $C->{_xact};

my @gather = ();
for (;;) {
unless (@try) {
$relex //= $C->cursor_fate('STD', 'postcircumfix:*', $retree);
@try = $relex->($C) or last;
}
$try = shift(@try) // next;

if (ref $try) {
($C->{'_fate'}, $tag, $try) = @$try;       # next candidate fate
}

$C->deb("postcircumfix trying $tag $try") if $::DEBUG & DEBUG::try_processing;
push @gather, $C->$try(@_);
last if @gather;
last if $xact->[-2];  # committed?
}
$self->_MATCHIFYr($S, "postcircumfix", @gather);
};
@result;
}
;
## token category:quote_mod { <sym> }
sub category__S_017quote_mod__PEEK { $_[0]->_AUTOLEXpeek('category__S_017quote_mod', $retree) }
sub category__S_017quote_mod {
no warnings 'recursion';
my $self = shift;


local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;

my $C = $self->cursor_xact("RULE category__S_017quote_mod");
my $xact = $C->xact;
my $S = $C->{'_pos'};
$C->{sym} = "quote_mod";
$self->_MATCHIFYr($S, "category__S_017quote_mod", $C->_EXACT("quote_mod"));
}
;
## token quote_mod {*}
sub quote_mod__PEEK { $_[0]->_AUTOLEXpeek('quote_mod:*',$retree); }
sub quote_mod {
my $self = shift;
my $subs;

local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;

my $C = $self->cursor_xact('RULE quote_mod');
my $S = $C->{'_pos'};

my @result = do {
my ($tag, $try);
my @try;
my $relex;
my $x;
if (my $fate = $C->{'_fate'}) {
if ($fate->[1] eq 'quote_mod') {
$C->deb("Fate passed to quote_mod: ", ::fatestr($fate)) if $::DEBUG & DEBUG::fates;
($C->{'_fate'}, $tag, $try) = @$fate;
@try = ($try);
$x = 'ALT quote_mod';
}
else {
$x = 'ALTLTM quote_mod';
}
}
else {
$x = 'ALTLTM quote_mod';
}
my $C = $C->cursor_xact($x);
my $xact = $C->{_xact};

my @gather = ();
for (;;) {
unless (@try) {
$relex //= $C->cursor_fate('STD', 'quote_mod:*', $retree);
@try = $relex->($C) or last;
}
$try = shift(@try) // next;

if (ref $try) {
($C->{'_fate'}, $tag, $try) = @$try;       # next candidate fate
}

$C->deb("quote_mod trying $tag $try") if $::DEBUG & DEBUG::try_processing;
push @gather, $C->$try(@_);
last if @gather;
last if $xact->[-2];  # committed?
}
$self->_MATCHIFYr($S, "quote_mod", @gather);
};
@result;
}
;
## token category:trait_mod { <sym> }
sub category__S_018trait_mod__PEEK { $_[0]->_AUTOLEXpeek('category__S_018trait_mod', $retree) }
sub category__S_018trait_mod {
no warnings 'recursion';
my $self = shift;


local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;

my $C = $self->cursor_xact("RULE category__S_018trait_mod");
my $xact = $C->xact;
my $S = $C->{'_pos'};
$C->{sym} = "trait_mod";
$self->_MATCHIFYr($S, "category__S_018trait_mod", $C->_EXACT("trait_mod"));
}
;
## token trait_mod (:$*endsym = 'spacey') {*}
sub trait_mod__PEEK { $_[0]->_AUTOLEXpeek('trait_mod:*',$retree); }
sub trait_mod {
my $self = shift;
my $subs;

local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;

my $C = $self->cursor_xact('RULE trait_mod');
my $S = $C->{'_pos'};

my @result = do {
my ($tag, $try);
my @try;
my $relex;
my $x;
if (my $fate = $C->{'_fate'}) {
if ($fate->[1] eq 'trait_mod') {
$C->deb("Fate passed to trait_mod: ", ::fatestr($fate)) if $::DEBUG & DEBUG::fates;
($C->{'_fate'}, $tag, $try) = @$fate;
@try = ($try);
$x = 'ALT trait_mod';
}
else {
$x = 'ALTLTM trait_mod';
}
}
else {
$x = 'ALTLTM trait_mod';
}
my $C = $C->cursor_xact($x);
my $xact = $C->{_xact};

my @gather = ();
for (;;) {
unless (@try) {
$relex //= $C->cursor_fate('STD', 'trait_mod:*', $retree);
@try = $relex->($C) or last;
}
$try = shift(@try) // next;

if (ref $try) {
($C->{'_fate'}, $tag, $try) = @$try;       # next candidate fate
}

$C->deb("trait_mod trying $tag $try") if $::DEBUG & DEBUG::try_processing;
push @gather, $C->$try(@_);
last if @gather;
last if $xact->[-2];  # committed?
}
$self->_MATCHIFYr($S, "trait_mod", @gather);
};
@result;
}
;
## token category:type_declarator { <sym> }
sub category__S_019type_declarator__PEEK { $_[0]->_AUTOLEXpeek('category__S_019type_declarator', $retree) }
sub category__S_019type_declarator {
no warnings 'recursion';
my $self = shift;


local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;

my $C = $self->cursor_xact("RULE category__S_019type_declarator");
my $xact = $C->xact;
my $S = $C->{'_pos'};
$C->{sym} = "type_declarator";
$self->_MATCHIFYr($S, "category__S_019type_declarator", $C->_EXACT("type_declarator"));
}
;
## token type_declarator (:$*endsym = 'spacey') {*}
sub type_declarator__PEEK { $_[0]->_AUTOLEXpeek('type_declarator:*',$retree); }
sub type_declarator {
my $self = shift;
my $subs;

local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;

my $C = $self->cursor_xact('RULE type_declarator');
my $S = $C->{'_pos'};

my @result = do {
my ($tag, $try);
my @try;
my $relex;
my $x;
if (my $fate = $C->{'_fate'}) {
if ($fate->[1] eq 'type_declarator') {
$C->deb("Fate passed to type_declarator: ", ::fatestr($fate)) if $::DEBUG & DEBUG::fates;
($C->{'_fate'}, $tag, $try) = @$fate;
@try = ($try);
$x = 'ALT type_declarator';
}
else {
$x = 'ALTLTM type_declarator';
}
}
else {
$x = 'ALTLTM type_declarator';
}
my $C = $C->cursor_xact($x);
my $xact = $C->{_xact};

my @gather = ();
for (;;) {
unless (@try) {
$relex //= $C->cursor_fate('STD', 'type_declarator:*', $retree);
@try = $relex->($C) or last;
}
$try = shift(@try) // next;

if (ref $try) {
($C->{'_fate'}, $tag, $try) = @$try;       # next candidate fate
}

$C->deb("type_declarator trying $tag $try") if $::DEBUG & DEBUG::try_processing;
push @gather, $C->$try(@_);
last if @gather;
last if $xact->[-2];  # committed?
}
$self->_MATCHIFYr($S, "type_declarator", @gather);
};
@result;
}
;
## token category:scope_declarator { <sym> }
sub category__S_020scope_declarator__PEEK { $_[0]->_AUTOLEXpeek('category__S_020scope_declarator', $retree) }
sub category__S_020scope_declarator {
no warnings 'recursion';
my $self = shift;


local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;

my $C = $self->cursor_xact("RULE category__S_020scope_declarator");
my $xact = $C->xact;
my $S = $C->{'_pos'};
$C->{sym} = "scope_declarator";
$self->_MATCHIFYr($S, "category__S_020scope_declarator", $C->_EXACT("scope_declarator"));
}
;
## token scope_declarator (:$*endsym = 'nofun') {*}
sub scope_declarator__PEEK { $_[0]->_AUTOLEXpeek('scope_declarator:*',$retree); }
sub scope_declarator {
my $self = shift;
my $subs;

local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;

my $C = $self->cursor_xact('RULE scope_declarator');
my $S = $C->{'_pos'};

my @result = do {
my ($tag, $try);
my @try;
my $relex;
my $x;
if (my $fate = $C->{'_fate'}) {
if ($fate->[1] eq 'scope_declarator') {
$C->deb("Fate passed to scope_declarator: ", ::fatestr($fate)) if $::DEBUG & DEBUG::fates;
($C->{'_fate'}, $tag, $try) = @$fate;
@try = ($try);
$x = 'ALT scope_declarator';
}
else {
$x = 'ALTLTM scope_declarator';
}
}
else {
$x = 'ALTLTM scope_declarator';
}
my $C = $C->cursor_xact($x);
my $xact = $C->{_xact};

my @gather = ();
for (;;) {
unless (@try) {
$relex //= $C->cursor_fate('STD', 'scope_declarator:*', $retree);
@try = $relex->($C) or last;
}
$try = shift(@try) // next;

if (ref $try) {
($C->{'_fate'}, $tag, $try) = @$try;       # next candidate fate
}

$C->deb("scope_declarator trying $tag $try") if $::DEBUG & DEBUG::try_processing;
push @gather, $C->$try(@_);
last if @gather;
last if $xact->[-2];  # committed?
}
$self->_MATCHIFYr($S, "scope_declarator", @gather);
};
@result;
}
;
## token category:package_declarator { <sym> }
sub category__S_021package_declarator__PEEK { $_[0]->_AUTOLEXpeek('category__S_021package_declarator', $retree) }
sub category__S_021package_declarator {
no warnings 'recursion';
my $self = shift;


local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;

my $C = $self->cursor_xact("RULE category__S_021package_declarator");
my $xact = $C->xact;
my $S = $C->{'_pos'};
$C->{sym} = "package_declarator";
$self->_MATCHIFYr($S, "category__S_021package_declarator", $C->_EXACT("package_declarator"));
}
;
## token package_declarator (:$*endsym = 'spacey') {*}
sub package_declarator__PEEK { $_[0]->_AUTOLEXpeek('package_declarator:*',$retree); }
sub package_declarator {
my $self = shift;
my $subs;

local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;

my $C = $self->cursor_xact('RULE package_declarator');
my $S = $C->{'_pos'};

my @result = do {
my ($tag, $try);
my @try;
my $relex;
my $x;
if (my $fate = $C->{'_fate'}) {
if ($fate->[1] eq 'package_declarator') {
$C->deb("Fate passed to package_declarator: ", ::fatestr($fate)) if $::DEBUG & DEBUG::fates;
($C->{'_fate'}, $tag, $try) = @$fate;
@try = ($try);
$x = 'ALT package_declarator';
}
else {
$x = 'ALTLTM package_declarator';
}
}
else {
$x = 'ALTLTM package_declarator';
}
my $C = $C->cursor_xact($x);
my $xact = $C->{_xact};

my @gather = ();
for (;;) {
unless (@try) {
$relex //= $C->cursor_fate('STD', 'package_declarator:*', $retree);
@try = $relex->($C) or last;
}
$try = shift(@try) // next;

if (ref $try) {
($C->{'_fate'}, $tag, $try) = @$try;       # next candidate fate
}

$C->deb("package_declarator trying $tag $try") if $::DEBUG & DEBUG::try_processing;
push @gather, $C->$try(@_);
last if @gather;
last if $xact->[-2];  # committed?
}
$self->_MATCHIFYr($S, "package_declarator", @gather);
};
@result;
}
;
## token category:multi_declarator { <sym> }
sub category__S_022multi_declarator__PEEK { $_[0]->_AUTOLEXpeek('category__S_022multi_declarator', $retree) }
sub category__S_022multi_declarator {
no warnings 'recursion';
my $self = shift;


local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;

my $C = $self->cursor_xact("RULE category__S_022multi_declarator");
my $xact = $C->xact;
my $S = $C->{'_pos'};
$C->{sym} = "multi_declarator";
$self->_MATCHIFYr($S, "category__S_022multi_declarator", $C->_EXACT("multi_declarator"));
}
;
## token multi_declarator (:$*endsym = 'spacey') {*}
sub multi_declarator__PEEK { $_[0]->_AUTOLEXpeek('multi_declarator:*',$retree); }
sub multi_declarator {
my $self = shift;
my $subs;

local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;

my $C = $self->cursor_xact('RULE multi_declarator');
my $S = $C->{'_pos'};

my @result = do {
my ($tag, $try);
my @try;
my $relex;
my $x;
if (my $fate = $C->{'_fate'}) {
if ($fate->[1] eq 'multi_declarator') {
$C->deb("Fate passed to multi_declarator: ", ::fatestr($fate)) if $::DEBUG & DEBUG::fates;
($C->{'_fate'}, $tag, $try) = @$fate;
@try = ($try);
$x = 'ALT multi_declarator';
}
else {
$x = 'ALTLTM multi_declarator';
}
}
else {
$x = 'ALTLTM multi_declarator';
}
my $C = $C->cursor_xact($x);
my $xact = $C->{_xact};

my @gather = ();
for (;;) {
unless (@try) {
$relex //= $C->cursor_fate('STD', 'multi_declarator:*', $retree);
@try = $relex->($C) or last;
}
$try = shift(@try) // next;

if (ref $try) {
($C->{'_fate'}, $tag, $try) = @$try;       # next candidate fate
}

$C->deb("multi_declarator trying $tag $try") if $::DEBUG & DEBUG::try_processing;
push @gather, $C->$try(@_);
last if @gather;
last if $xact->[-2];  # committed?
}
$self->_MATCHIFYr($S, "multi_declarator", @gather);
};
@result;
}
;
## token category:routine_declarator { <sym> }
sub category__S_023routine_declarator__PEEK { $_[0]->_AUTOLEXpeek('category__S_023routine_declarator', $retree) }
sub category__S_023routine_declarator {
no warnings 'recursion';
my $self = shift;


local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;

my $C = $self->cursor_xact("RULE category__S_023routine_declarator");
my $xact = $C->xact;
my $S = $C->{'_pos'};
$C->{sym} = "routine_declarator";
$self->_MATCHIFYr($S, "category__S_023routine_declarator", $C->_EXACT("routine_declarator"));
}
;
## token routine_declarator (:$*endsym = 'nofun') {*}
sub routine_declarator__PEEK { $_[0]->_AUTOLEXpeek('routine_declarator:*',$retree); }
sub routine_declarator {
my $self = shift;
my $subs;

local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;

my $C = $self->cursor_xact('RULE routine_declarator');
my $S = $C->{'_pos'};

my @result = do {
my ($tag, $try);
my @try;
my $relex;
my $x;
if (my $fate = $C->{'_fate'}) {
if ($fate->[1] eq 'routine_declarator') {
$C->deb("Fate passed to routine_declarator: ", ::fatestr($fate)) if $::DEBUG & DEBUG::fates;
($C->{'_fate'}, $tag, $try) = @$fate;
@try = ($try);
$x = 'ALT routine_declarator';
}
else {
$x = 'ALTLTM routine_declarator';
}
}
else {
$x = 'ALTLTM routine_declarator';
}
my $C = $C->cursor_xact($x);
my $xact = $C->{_xact};

my @gather = ();
for (;;) {
unless (@try) {
$relex //= $C->cursor_fate('STD', 'routine_declarator:*', $retree);
@try = $relex->($C) or last;
}
$try = shift(@try) // next;

if (ref $try) {
($C->{'_fate'}, $tag, $try) = @$try;       # next candidate fate
}

$C->deb("routine_declarator trying $tag $try") if $::DEBUG & DEBUG::try_processing;
push @gather, $C->$try(@_);
last if @gather;
last if $xact->[-2];  # committed?
}
$self->_MATCHIFYr($S, "routine_declarator", @gather);
};
@result;
}
;
## token category:regex_declarator { <sym> }
sub category__S_024regex_declarator__PEEK { $_[0]->_AUTOLEXpeek('category__S_024regex_declarator', $retree) }
sub category__S_024regex_declarator {
no warnings 'recursion';
my $self = shift;


local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;

my $C = $self->cursor_xact("RULE category__S_024regex_declarator");
my $xact = $C->xact;
my $S = $C->{'_pos'};
$C->{sym} = "regex_declarator";
$self->_MATCHIFYr($S, "category__S_024regex_declarator", $C->_EXACT("regex_declarator"));
}
;
## token regex_declarator (:$*endsym = 'spacey') {*}
sub regex_declarator__PEEK { $_[0]->_AUTOLEXpeek('regex_declarator:*',$retree); }
sub regex_declarator {
my $self = shift;
my $subs;

local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;

my $C = $self->cursor_xact('RULE regex_declarator');
my $S = $C->{'_pos'};

my @result = do {
my ($tag, $try);
my @try;
my $relex;
my $x;
if (my $fate = $C->{'_fate'}) {
if ($fate->[1] eq 'regex_declarator') {
$C->deb("Fate passed to regex_declarator: ", ::fatestr($fate)) if $::DEBUG & DEBUG::fates;
($C->{'_fate'}, $tag, $try) = @$fate;
@try = ($try);
$x = 'ALT regex_declarator';
}
else {
$x = 'ALTLTM regex_declarator';
}
}
else {
$x = 'ALTLTM regex_declarator';
}
my $C = $C->cursor_xact($x);
my $xact = $C->{_xact};

my @gather = ();
for (;;) {
unless (@try) {
$relex //= $C->cursor_fate('STD', 'regex_declarator:*', $retree);
@try = $relex->($C) or last;
}
$try = shift(@try) // next;

if (ref $try) {
($C->{'_fate'}, $tag, $try) = @$try;       # next candidate fate
}

$C->deb("regex_declarator trying $tag $try") if $::DEBUG & DEBUG::try_processing;
push @gather, $C->$try(@_);
last if @gather;
last if $xact->[-2];  # committed?
}
$self->_MATCHIFYr($S, "regex_declarator", @gather);
};
@result;
}
;
## token category:statement_prefix { <sym> }
sub category__S_025statement_prefix__PEEK { $_[0]->_AUTOLEXpeek('category__S_025statement_prefix', $retree) }
sub category__S_025statement_prefix {
no warnings 'recursion';
my $self = shift;


local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;

my $C = $self->cursor_xact("RULE category__S_025statement_prefix");
my $xact = $C->xact;
my $S = $C->{'_pos'};
$C->{sym} = "statement_prefix";
$self->_MATCHIFYr($S, "category__S_025statement_prefix", $C->_EXACT("statement_prefix"));
}
;
## rule  statement_prefix () {*}
sub statement_prefix__PEEK { $_[0]->_AUTOLEXpeek('statement_prefix:*',$retree); }
sub statement_prefix {
my $self = shift;
my $subs;

local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;

my $C = $self->cursor_xact('RULE statement_prefix');
my $S = $C->{'_pos'};

my @result = do {
my ($tag, $try);
my @try;
my $relex;
my $x;
if (my $fate = $C->{'_fate'}) {
if ($fate->[1] eq 'statement_prefix') {
$C->deb("Fate passed to statement_prefix: ", ::fatestr($fate)) if $::DEBUG & DEBUG::fates;
($C->{'_fate'}, $tag, $try) = @$fate;
@try = ($try);
$x = 'ALT statement_prefix';
}
else {
$x = 'ALTLTM statement_prefix';
}
}
else {
$x = 'ALTLTM statement_prefix';
}
my $C = $C->cursor_xact($x);
my $xact = $C->{_xact};

my @gather = ();
for (;;) {
unless (@try) {
$relex //= $C->cursor_fate('STD', 'statement_prefix:*', $retree);
@try = $relex->($C) or last;
}
$try = shift(@try) // next;

if (ref $try) {
($C->{'_fate'}, $tag, $try) = @$try;       # next candidate fate
}

$C->deb("statement_prefix trying $tag $try") if $::DEBUG & DEBUG::try_processing;
push @gather, $C->$try(@_);
last if @gather;
last if $xact->[-2];  # committed?
}
$self->_MATCHIFYr($S, "statement_prefix", @gather);
};
@result;
}
;
## token category:statement_control { <sym> }
sub category__S_026statement_control__PEEK { $_[0]->_AUTOLEXpeek('category__S_026statement_control', $retree) }
sub category__S_026statement_control {
no warnings 'recursion';
my $self = shift;


local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;

my $C = $self->cursor_xact("RULE category__S_026statement_control");
my $xact = $C->xact;
my $S = $C->{'_pos'};
$C->{sym} = "statement_control";
$self->_MATCHIFYr($S, "category__S_026statement_control", $C->_EXACT("statement_control"));
}
;
## rule  statement_control (:$*endsym = 'spacey') {*}
sub statement_control__PEEK { $_[0]->_AUTOLEXpeek('statement_control:*',$retree); }
sub statement_control {
my $self = shift;
my $subs;

local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;

my $C = $self->cursor_xact('RULE statement_control');
my $S = $C->{'_pos'};

my @result = do {
my ($tag, $try);
my @try;
my $relex;
my $x;
if (my $fate = $C->{'_fate'}) {
if ($fate->[1] eq 'statement_control') {
$C->deb("Fate passed to statement_control: ", ::fatestr($fate)) if $::DEBUG & DEBUG::fates;
($C->{'_fate'}, $tag, $try) = @$fate;
@try = ($try);
$x = 'ALT statement_control';
}
else {
$x = 'ALTLTM statement_control';
}
}
else {
$x = 'ALTLTM statement_control';
}
my $C = $C->cursor_xact($x);
my $xact = $C->{_xact};

my @gather = ();
for (;;) {
unless (@try) {
$relex //= $C->cursor_fate('STD', 'statement_control:*', $retree);
@try = $relex->($C) or last;
}
$try = shift(@try) // next;

if (ref $try) {
($C->{'_fate'}, $tag, $try) = @$try;       # next candidate fate
}

$C->deb("statement_control trying $tag $try") if $::DEBUG & DEBUG::try_processing;
push @gather, $C->$try(@_);
last if @gather;
last if $xact->[-2];  # committed?
}
$self->_MATCHIFYr($S, "statement_control", @gather);
};
@result;
}
;
## token category:statement_mod_cond { <sym> }
sub category__S_027statement_mod_cond__PEEK { $_[0]->_AUTOLEXpeek('category__S_027statement_mod_cond', $retree) }
sub category__S_027statement_mod_cond {
no warnings 'recursion';
my $self = shift;


local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;

my $C = $self->cursor_xact("RULE category__S_027statement_mod_cond");
my $xact = $C->xact;
my $S = $C->{'_pos'};
$C->{sym} = "statement_mod_cond";
$self->_MATCHIFYr($S, "category__S_027statement_mod_cond", $C->_EXACT("statement_mod_cond"));
}
;
## rule  statement_mod_cond (:$*endsym = 'nofun') {*}
sub statement_mod_cond__PEEK { $_[0]->_AUTOLEXpeek('statement_mod_cond:*',$retree); }
sub statement_mod_cond {
my $self = shift;
my $subs;

local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;

my $C = $self->cursor_xact('RULE statement_mod_cond');
my $S = $C->{'_pos'};

my @result = do {
my ($tag, $try);
my @try;
my $relex;
my $x;
if (my $fate = $C->{'_fate'}) {
if ($fate->[1] eq 'statement_mod_cond') {
$C->deb("Fate passed to statement_mod_cond: ", ::fatestr($fate)) if $::DEBUG & DEBUG::fates;
($C->{'_fate'}, $tag, $try) = @$fate;
@try = ($try);
$x = 'ALT statement_mod_cond';
}
else {
$x = 'ALTLTM statement_mod_cond';
}
}
else {
$x = 'ALTLTM statement_mod_cond';
}
my $C = $C->cursor_xact($x);
my $xact = $C->{_xact};

my @gather = ();
for (;;) {
unless (@try) {
$relex //= $C->cursor_fate('STD', 'statement_mod_cond:*', $retree);
@try = $relex->($C) or last;
}
$try = shift(@try) // next;

if (ref $try) {
($C->{'_fate'}, $tag, $try) = @$try;       # next candidate fate
}

$C->deb("statement_mod_cond trying $tag $try") if $::DEBUG & DEBUG::try_processing;
push @gather, $C->$try(@_);
last if @gather;
last if $xact->[-2];  # committed?
}
$self->_MATCHIFYr($S, "statement_mod_cond", @gather);
};
@result;
}
;
## token category:statement_mod_loop { <sym> }
sub category__S_028statement_mod_loop__PEEK { $_[0]->_AUTOLEXpeek('category__S_028statement_mod_loop', $retree) }
sub category__S_028statement_mod_loop {
no warnings 'recursion';
my $self = shift;


local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;

my $C = $self->cursor_xact("RULE category__S_028statement_mod_loop");
my $xact = $C->xact;
my $S = $C->{'_pos'};
$C->{sym} = "statement_mod_loop";
$self->_MATCHIFYr($S, "category__S_028statement_mod_loop", $C->_EXACT("statement_mod_loop"));
}
;
## rule  statement_mod_loop (:$*endsym = 'nofun') {*}
sub statement_mod_loop__PEEK { $_[0]->_AUTOLEXpeek('statement_mod_loop:*',$retree); }
sub statement_mod_loop {
my $self = shift;
my $subs;

local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;

my $C = $self->cursor_xact('RULE statement_mod_loop');
my $S = $C->{'_pos'};

my @result = do {
my ($tag, $try);
my @try;
my $relex;
my $x;
if (my $fate = $C->{'_fate'}) {
if ($fate->[1] eq 'statement_mod_loop') {
$C->deb("Fate passed to statement_mod_loop: ", ::fatestr($fate)) if $::DEBUG & DEBUG::fates;
($C->{'_fate'}, $tag, $try) = @$fate;
@try = ($try);
$x = 'ALT statement_mod_loop';
}
else {
$x = 'ALTLTM statement_mod_loop';
}
}
else {
$x = 'ALTLTM statement_mod_loop';
}
my $C = $C->cursor_xact($x);
my $xact = $C->{_xact};

my @gather = ();
for (;;) {
unless (@try) {
$relex //= $C->cursor_fate('STD', 'statement_mod_loop:*', $retree);
@try = $relex->($C) or last;
}
$try = shift(@try) // next;

if (ref $try) {
($C->{'_fate'}, $tag, $try) = @$try;       # next candidate fate
}

$C->deb("statement_mod_loop trying $tag $try") if $::DEBUG & DEBUG::try_processing;
push @gather, $C->$try(@_);
last if @gather;
last if $xact->[-2];  # committed?
}
$self->_MATCHIFYr($S, "statement_mod_loop", @gather);
};
@result;
}
;
## token category:infix_prefix_meta_operator { <sym> }
sub category__S_029infix_prefix_meta_operator__PEEK { $_[0]->_AUTOLEXpeek('category__S_029infix_prefix_meta_operator', $retree) }
sub category__S_029infix_prefix_meta_operator {
no warnings 'recursion';
my $self = shift;


local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;

my $C = $self->cursor_xact("RULE category__S_029infix_prefix_meta_operator");
my $xact = $C->xact;
my $S = $C->{'_pos'};
$C->{sym} = "infix_prefix_meta_operator";
$self->_MATCHIFYr($S, "category__S_029infix_prefix_meta_operator", $C->_EXACT("infix_prefix_meta_operator"));
}
;
## token infix_prefix_meta_operator is binary {*}
sub infix_prefix_meta_operator__PEEK { $_[0]->_AUTOLEXpeek('infix_prefix_meta_operator:*',$retree); }
sub infix_prefix_meta_operator {
my $self = shift;
my $subs;

local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;

my $C = $self->cursor_xact('RULE infix_prefix_meta_operator');
my $S = $C->{'_pos'};

my @result = do {
my ($tag, $try);
my @try;
my $relex;
my $x;
if (my $fate = $C->{'_fate'}) {
if ($fate->[1] eq 'infix_prefix_meta_operator') {
$C->deb("Fate passed to infix_prefix_meta_operator: ", ::fatestr($fate)) if $::DEBUG & DEBUG::fates;
($C->{'_fate'}, $tag, $try) = @$fate;
@try = ($try);
$x = 'ALT infix_prefix_meta_operator';
}
else {
$x = 'ALTLTM infix_prefix_meta_operator';
}
}
else {
$x = 'ALTLTM infix_prefix_meta_operator';
}
my $C = $C->cursor_xact($x);
my $xact = $C->{_xact};

my @gather = ();
for (;;) {
unless (@try) {
$relex //= $C->cursor_fate('STD', 'infix_prefix_meta_operator:*', $retree);
@try = $relex->($C) or last;
}
$try = shift(@try) // next;

if (ref $try) {
($C->{'_fate'}, $tag, $try) = @$try;       # next candidate fate
}

$C->deb("infix_prefix_meta_operator trying $tag $try") if $::DEBUG & DEBUG::try_processing;
push @gather, $C->$try(@_);
last if @gather;
last if $xact->[-2];  # committed?
}
$self->_MATCHIFYr($S, "infix_prefix_meta_operator", @gather);
};
@result;
}
;
## token category:infix_postfix_meta_operator { <sym> }
sub category__S_030infix_postfix_meta_operator__PEEK { $_[0]->_AUTOLEXpeek('category__S_030infix_postfix_meta_operator', $retree) }
sub category__S_030infix_postfix_meta_operator {
no warnings 'recursion';
my $self = shift;


local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;

my $C = $self->cursor_xact("RULE category__S_030infix_postfix_meta_operator");
my $xact = $C->xact;
my $S = $C->{'_pos'};
$C->{sym} = "infix_postfix_meta_operator";
$self->_MATCHIFYr($S, "category__S_030infix_postfix_meta_operator", $C->_EXACT("infix_postfix_meta_operator"));
}
;
## token infix_postfix_meta_operator ($op) is binary {*}
sub infix_postfix_meta_operator__PEEK { $_[0]->_AUTOLEXpeek('infix_postfix_meta_operator:*',$retree); }
sub infix_postfix_meta_operator {
my $self = shift;
my $subs;

local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;

my $C = $self->cursor_xact('RULE infix_postfix_meta_operator');
my $S = $C->{'_pos'};

my @result = do {
my ($tag, $try);
my @try;
my $relex;
my $x;
if (my $fate = $C->{'_fate'}) {
if ($fate->[1] eq 'infix_postfix_meta_operator') {
$C->deb("Fate passed to infix_postfix_meta_operator: ", ::fatestr($fate)) if $::DEBUG & DEBUG::fates;
($C->{'_fate'}, $tag, $try) = @$fate;
@try = ($try);
$x = 'ALT infix_postfix_meta_operator';
}
else {
$x = 'ALTLTM infix_postfix_meta_operator';
}
}
else {
$x = 'ALTLTM infix_postfix_meta_operator';
}
my $C = $C->cursor_xact($x);
my $xact = $C->{_xact};

my @gather = ();
for (;;) {
unless (@try) {
$relex //= $C->cursor_fate('STD', 'infix_postfix_meta_operator:*', $retree);
@try = $relex->($C) or last;
}
$try = shift(@try) // next;

if (ref $try) {
($C->{'_fate'}, $tag, $try) = @$try;       # next candidate fate
}

$C->deb("infix_postfix_meta_operator trying $tag $try") if $::DEBUG & DEBUG::try_processing;
push @gather, $C->$try(@_);
last if @gather;
last if $xact->[-2];  # committed?
}
$self->_MATCHIFYr($S, "infix_postfix_meta_operator", @gather);
};
@result;
}
;
## token category:infix_circumfix_meta_operator { <sym> }
sub category__S_031infix_circumfix_meta_operator__PEEK { $_[0]->_AUTOLEXpeek('category__S_031infix_circumfix_meta_operator', $retree) }
sub category__S_031infix_circumfix_meta_operator {
no warnings 'recursion';
my $self = shift;


local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;

my $C = $self->cursor_xact("RULE category__S_031infix_circumfix_meta_operator");
my $xact = $C->xact;
my $S = $C->{'_pos'};
$C->{sym} = "infix_circumfix_meta_operator";
$self->_MATCHIFYr($S, "category__S_031infix_circumfix_meta_operator", $C->_EXACT("infix_circumfix_meta_operator"));
}
;
## token infix_circumfix_meta_operator is binary {*}
sub infix_circumfix_meta_operator__PEEK { $_[0]->_AUTOLEXpeek('infix_circumfix_meta_operator:*',$retree); }
sub infix_circumfix_meta_operator {
my $self = shift;
my $subs;

local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;

my $C = $self->cursor_xact('RULE infix_circumfix_meta_operator');
my $S = $C->{'_pos'};

my @result = do {
my ($tag, $try);
my @try;
my $relex;
my $x;
if (my $fate = $C->{'_fate'}) {
if ($fate->[1] eq 'infix_circumfix_meta_operator') {
$C->deb("Fate passed to infix_circumfix_meta_operator: ", ::fatestr($fate)) if $::DEBUG & DEBUG::fates;
($C->{'_fate'}, $tag, $try) = @$fate;
@try = ($try);
$x = 'ALT infix_circumfix_meta_operator';
}
else {
$x = 'ALTLTM infix_circumfix_meta_operator';
}
}
else {
$x = 'ALTLTM infix_circumfix_meta_operator';
}
my $C = $C->cursor_xact($x);
my $xact = $C->{_xact};

my @gather = ();
for (;;) {
unless (@try) {
$relex //= $C->cursor_fate('STD', 'infix_circumfix_meta_operator:*', $retree);
@try = $relex->($C) or last;
}
$try = shift(@try) // next;

if (ref $try) {
($C->{'_fate'}, $tag, $try) = @$try;       # next candidate fate
}

$C->deb("infix_circumfix_meta_operator trying $tag $try") if $::DEBUG & DEBUG::try_processing;
push @gather, $C->$try(@_);
last if @gather;
last if $xact->[-2];  # committed?
}
$self->_MATCHIFYr($S, "infix_circumfix_meta_operator", @gather);
};
@result;
}
;
## token category:postfix_prefix_meta_operator { <sym> }
sub category__S_032postfix_prefix_meta_operator__PEEK { $_[0]->_AUTOLEXpeek('category__S_032postfix_prefix_meta_operator', $retree) }
sub category__S_032postfix_prefix_meta_operator {
no warnings 'recursion';
my $self = shift;


local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;

my $C = $self->cursor_xact("RULE category__S_032postfix_prefix_meta_operator");
my $xact = $C->xact;
my $S = $C->{'_pos'};
$C->{sym} = "postfix_prefix_meta_operator";
$self->_MATCHIFYr($S, "category__S_032postfix_prefix_meta_operator", $C->_EXACT("postfix_prefix_meta_operator"));
}
;
## token postfix_prefix_meta_operator is unary {*}
sub postfix_prefix_meta_operator__PEEK { $_[0]->_AUTOLEXpeek('postfix_prefix_meta_operator:*',$retree); }
sub postfix_prefix_meta_operator {
my $self = shift;
my $subs;

local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;

my $C = $self->cursor_xact('RULE postfix_prefix_meta_operator');
my $S = $C->{'_pos'};

my @result = do {
my ($tag, $try);
my @try;
my $relex;
my $x;
if (my $fate = $C->{'_fate'}) {
if ($fate->[1] eq 'postfix_prefix_meta_operator') {
$C->deb("Fate passed to postfix_prefix_meta_operator: ", ::fatestr($fate)) if $::DEBUG & DEBUG::fates;
($C->{'_fate'}, $tag, $try) = @$fate;
@try = ($try);
$x = 'ALT postfix_prefix_meta_operator';
}
else {
$x = 'ALTLTM postfix_prefix_meta_operator';
}
}
else {
$x = 'ALTLTM postfix_prefix_meta_operator';
}
my $C = $C->cursor_xact($x);
my $xact = $C->{_xact};

my @gather = ();
for (;;) {
unless (@try) {
$relex //= $C->cursor_fate('STD', 'postfix_prefix_meta_operator:*', $retree);
@try = $relex->($C) or last;
}
$try = shift(@try) // next;

if (ref $try) {
($C->{'_fate'}, $tag, $try) = @$try;       # next candidate fate
}

$C->deb("postfix_prefix_meta_operator trying $tag $try") if $::DEBUG & DEBUG::try_processing;
push @gather, $C->$try(@_);
last if @gather;
last if $xact->[-2];  # committed?
}
$self->_MATCHIFYr($S, "postfix_prefix_meta_operator", @gather);
};
@result;
}
;
## token category:prefix_postfix_meta_operator { <sym> }
sub category__S_033prefix_postfix_meta_operator__PEEK { $_[0]->_AUTOLEXpeek('category__S_033prefix_postfix_meta_operator', $retree) }
sub category__S_033prefix_postfix_meta_operator {
no warnings 'recursion';
my $self = shift;


local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;

my $C = $self->cursor_xact("RULE category__S_033prefix_postfix_meta_operator");
my $xact = $C->xact;
my $S = $C->{'_pos'};
$C->{sym} = "prefix_postfix_meta_operator";
$self->_MATCHIFYr($S, "category__S_033prefix_postfix_meta_operator", $C->_EXACT("prefix_postfix_meta_operator"));
}
;
## token prefix_postfix_meta_operator is unary {*}
sub prefix_postfix_meta_operator__PEEK { $_[0]->_AUTOLEXpeek('prefix_postfix_meta_operator:*',$retree); }
sub prefix_postfix_meta_operator {
my $self = shift;
my $subs;

local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;

my $C = $self->cursor_xact('RULE prefix_postfix_meta_operator');
my $S = $C->{'_pos'};

my @result = do {
my ($tag, $try);
my @try;
my $relex;
my $x;
if (my $fate = $C->{'_fate'}) {
if ($fate->[1] eq 'prefix_postfix_meta_operator') {
$C->deb("Fate passed to prefix_postfix_meta_operator: ", ::fatestr($fate)) if $::DEBUG & DEBUG::fates;
($C->{'_fate'}, $tag, $try) = @$fate;
@try = ($try);
$x = 'ALT prefix_postfix_meta_operator';
}
else {
$x = 'ALTLTM prefix_postfix_meta_operator';
}
}
else {
$x = 'ALTLTM prefix_postfix_meta_operator';
}
my $C = $C->cursor_xact($x);
my $xact = $C->{_xact};

my @gather = ();
for (;;) {
unless (@try) {
$relex //= $C->cursor_fate('STD', 'prefix_postfix_meta_operator:*', $retree);
@try = $relex->($C) or last;
}
$try = shift(@try) // next;

if (ref $try) {
($C->{'_fate'}, $tag, $try) = @$try;       # next candidate fate
}

$C->deb("prefix_postfix_meta_operator trying $tag $try") if $::DEBUG & DEBUG::try_processing;
push @gather, $C->$try(@_);
last if @gather;
last if $xact->[-2];  # committed?
}
$self->_MATCHIFYr($S, "prefix_postfix_meta_operator", @gather);
};
@result;
}
;
## token category:prefix_circumfix_meta_operator { <sym> }
sub category__S_034prefix_circumfix_meta_operator__PEEK { $_[0]->_AUTOLEXpeek('category__S_034prefix_circumfix_meta_operator', $retree) }
sub category__S_034prefix_circumfix_meta_operator {
no warnings 'recursion';
my $self = shift;


local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;

my $C = $self->cursor_xact("RULE category__S_034prefix_circumfix_meta_operator");
my $xact = $C->xact;
my $S = $C->{'_pos'};
$C->{sym} = "prefix_circumfix_meta_operator";
$self->_MATCHIFYr($S, "category__S_034prefix_circumfix_meta_operator", $C->_EXACT("prefix_circumfix_meta_operator"));
}
;
## token prefix_circumfix_meta_operator is unary {*}
sub prefix_circumfix_meta_operator__PEEK { $_[0]->_AUTOLEXpeek('prefix_circumfix_meta_operator:*',$retree); }
sub prefix_circumfix_meta_operator {
my $self = shift;
my $subs;

local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;

my $C = $self->cursor_xact('RULE prefix_circumfix_meta_operator');
my $S = $C->{'_pos'};

my @result = do {
my ($tag, $try);
my @try;
my $relex;
my $x;
if (my $fate = $C->{'_fate'}) {
if ($fate->[1] eq 'prefix_circumfix_meta_operator') {
$C->deb("Fate passed to prefix_circumfix_meta_operator: ", ::fatestr($fate)) if $::DEBUG & DEBUG::fates;
($C->{'_fate'}, $tag, $try) = @$fate;
@try = ($try);
$x = 'ALT prefix_circumfix_meta_operator';
}
else {
$x = 'ALTLTM prefix_circumfix_meta_operator';
}
}
else {
$x = 'ALTLTM prefix_circumfix_meta_operator';
}
my $C = $C->cursor_xact($x);
my $xact = $C->{_xact};

my @gather = ();
for (;;) {
unless (@try) {
$relex //= $C->cursor_fate('STD', 'prefix_circumfix_meta_operator:*', $retree);
@try = $relex->($C) or last;
}
$try = shift(@try) // next;

if (ref $try) {
($C->{'_fate'}, $tag, $try) = @$try;       # next candidate fate
}

$C->deb("prefix_circumfix_meta_operator trying $tag $try") if $::DEBUG & DEBUG::try_processing;
push @gather, $C->$try(@_);
last if @gather;
last if $xact->[-2];  # committed?
}
$self->_MATCHIFYr($S, "prefix_circumfix_meta_operator", @gather);
};
@result;
}
;
## token category:terminator { <sym> }
sub category__S_035terminator__PEEK { $_[0]->_AUTOLEXpeek('category__S_035terminator', $retree) }
sub category__S_035terminator {
no warnings 'recursion';
my $self = shift;


local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;

my $C = $self->cursor_xact("RULE category__S_035terminator");
my $xact = $C->xact;
my $S = $C->{'_pos'};
$C->{sym} = "terminator";
$self->_MATCHIFYr($S, "category__S_035terminator", $C->_EXACT("terminator"));
}
;
## token terminator {*}
sub terminator__PEEK { $_[0]->_AUTOLEXpeek('terminator:*',$retree); }
sub terminator {
my $self = shift;
my $subs;

local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;

my $C = $self->cursor_xact('RULE terminator');
my $S = $C->{'_pos'};

my @result = do {
my ($tag, $try);
my @try;
my $relex;
my $x;
if (my $fate = $C->{'_fate'}) {
if ($fate->[1] eq 'terminator') {
$C->deb("Fate passed to terminator: ", ::fatestr($fate)) if $::DEBUG & DEBUG::fates;
($C->{'_fate'}, $tag, $try) = @$fate;
@try = ($try);
$x = 'ALT terminator';
}
else {
$x = 'ALTLTM terminator';
}
}
else {
$x = 'ALTLTM terminator';
}
my $C = $C->cursor_xact($x);
my $xact = $C->{_xact};

my @gather = ();
for (;;) {
unless (@try) {
$relex //= $C->cursor_fate('STD', 'terminator:*', $retree);
@try = $relex->($C) or last;
}
$try = shift(@try) // next;

if (ref $try) {
($C->{'_fate'}, $tag, $try) = @$try;       # next candidate fate
}

$C->deb("terminator trying $tag $try") if $::DEBUG & DEBUG::try_processing;
push @gather, $C->$try(@_);
last if @gather;
last if $xact->[-2];  # committed?
}
$self->_MATCHIFYr($S, "terminator", @gather);
};
@result;
}
;
## token unspacey { <.unsp>? }
sub unspacey__PEEK { $_[0]->_AUTOLEXpeek('unspacey', $retree) }
sub unspacey {
no warnings 'recursion';
my $self = shift;


local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;

my $C = $self->cursor_xact("RULE unspacey");
my $xact = $C->xact;
my $S = $C->{'_pos'};
$self->_MATCHIFYr($S, "unspacey", $C->_OPTr(sub {
my $C=shift;
if (my ($C) = ($C->unsp)) { ($C) } else { () }
}));
}
;
## token begid { <?before \w> }
sub begid__PEEK { $_[0]->_AUTOLEXpeek('begid', $retree) }
sub begid {
no warnings 'recursion';
my $self = shift;


local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;

my $C = $self->cursor_xact("RULE begid");
my $xact = $C->xact;
my $S = $C->{'_pos'};
$self->_MATCHIFYr($S, "begid", $C->before(sub {
my $C=shift;
if (my ($C) = ($C->before(sub {
my $C=shift;
$C->_PATTERN(qr/\G\w/)
}))) { ($C) } else { () }
}));
}
;
## token endid { <?before <-[ \- \' \w ]> > }
sub endid__PEEK { $_[0]->_AUTOLEXpeek('endid', $retree) }
sub endid {
no warnings 'recursion';
my $self = shift;


local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;

my $C = $self->cursor_xact("RULE endid");
my $xact = $C->xact;
my $S = $C->{'_pos'};
$self->_MATCHIFYr($S, "endid", $C->before(sub {
my $C=shift;
if (my ($C) = ($C->before(sub {
my $C=shift;
$C->_PATTERN(qr/\G[^\-\'\w]/)
}))) { ($C) } else { () }
}));
}
;
## token spacey { <?before <[ \s \# ]> > }
sub spacey__PEEK { $_[0]->_AUTOLEXpeek('spacey', $retree) }
sub spacey {
no warnings 'recursion';
my $self = shift;


local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;

my $C = $self->cursor_xact("RULE spacey");
my $xact = $C->xact;
my $S = $C->{'_pos'};
$self->_MATCHIFYr($S, "spacey", $C->before(sub {
my $C=shift;
if (my ($C) = ($C->before(sub {
my $C=shift;
$C->_PATTERN(qr/\G[\s\#]/)
}))) { ($C) } else { () }
}));
}
;
## token nofun { <!before '(' | '.(' | '\\' | '\'' | '-' | "'" | \w > }
sub nofun__PEEK { $_[0]->_AUTOLEXpeek('nofun', $retree) }
sub nofun {
no warnings 'recursion';
my $self = shift;


local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;

my $C = $self->cursor_xact("RULE nofun");
my $xact = $C->xact;
my $S = $C->{'_pos'};
$self->_MATCHIFYr($S, "nofun", $C->_NOTBEFORE(sub {
my $C=shift;
if (my ($C) = ($C->before(sub {
my $C=shift;
if (my ($C) = (do {
do {
my ($tag, $try);
my @try;
my $relex;

my $fate;
my $x;
if ($fate = $C->{'_fate'} and $fate->[1] eq 'nofun_0') {
$C->deb("Fate passed to nofun_0: ", ::fatestr($fate)) if $::DEBUG & DEBUG::fates;
($C->{'_fate'}, $tag, $try) = @$fate;
@try = ($try);
$x = 'ALT nofun_0';    # some outer ltm is controlling us
}
else {
$x = 'ALTLTM nofun_0'; # we are top level ltm
}
my $C = $C->cursor_xact($x);
my $xact = $C->{_xact};

my @gather = ();
for (;;) {
unless (@try) {
$relex //= $C->cursor_fate('STD', 'nofun_0', $retree);
@try = $relex->($C) or last;
}
$try = shift(@try) // next;

if (ref $try) {
($C->{'_fate'}, $tag, $try) = @$try;   # next candidate fate
}

$C->deb("nofun_0 trying $tag $try") if $::DEBUG & DEBUG::try_processing;
push @gather, ((
sub {
my $C=shift;
$C->_EXACT("\(")
},
sub {
my $C=shift;
$C->_EXACT("\.\(")
},
sub {
my $C=shift;
$C->_EXACT("\\")
},
sub {
my $C=shift;
$C->_EXACT("\'")
},
sub {
my $C=shift;
$C->_EXACT("\-")
},
sub {
my $C=shift;
$C->_EXACT("\'")
},
sub {
my $C=shift;
$C->_PATTERN(qr/\G\w/)
}
)[$try])->($C);
last if @gather;
last if $xact->[-2];  # committed?
}
@gather;
};

})) { ($C) } else { () }
}))) { ($C) } else { () }
}));
}
;
## token sigil:sym<$>  { <sym> }
sub sigil__S_036Dollar__PEEK { $_[0]->_AUTOLEXpeek('sigil__S_036Dollar', $retree) }
sub sigil__S_036Dollar {
no warnings 'recursion';
my $self = shift;


local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;

my $C = $self->cursor_xact("RULE sigil__S_036Dollar");
my $xact = $C->xact;
my $S = $C->{'_pos'};
$C->{sym} = "\$";
$self->_MATCHIFYr($S, "sigil__S_036Dollar", $C->_EXACT("\$"));
}
;
## token sigil:sym<@>  { <sym> }
sub sigil__S_037At__PEEK { $_[0]->_AUTOLEXpeek('sigil__S_037At', $retree) }
sub sigil__S_037At {
no warnings 'recursion';
my $self = shift;


local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;

my $C = $self->cursor_xact("RULE sigil__S_037At");
my $xact = $C->xact;
my $S = $C->{'_pos'};
$C->{sym} = "\@";
$self->_MATCHIFYr($S, "sigil__S_037At", $C->_EXACT("\@"));
}
;
## token sigil:sym<%>  { <sym> }
sub sigil__S_038Percent__PEEK { $_[0]->_AUTOLEXpeek('sigil__S_038Percent', $retree) }
sub sigil__S_038Percent {
no warnings 'recursion';
my $self = shift;


local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;

my $C = $self->cursor_xact("RULE sigil__S_038Percent");
my $xact = $C->xact;
my $S = $C->{'_pos'};
$C->{sym} = "\%";
$self->_MATCHIFYr($S, "sigil__S_038Percent", $C->_EXACT("\%"));
}
;
## token sigil:sym<&>  { <sym> }
sub sigil__S_039Amp__PEEK { $_[0]->_AUTOLEXpeek('sigil__S_039Amp', $retree) }
sub sigil__S_039Amp {
no warnings 'recursion';
my $self = shift;


local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;

my $C = $self->cursor_xact("RULE sigil__S_039Amp");
my $xact = $C->xact;
my $S = $C->{'_pos'};
$C->{sym} = "\&";
$self->_MATCHIFYr($S, "sigil__S_039Amp", $C->_EXACT("\&"));
}
;
## token twigil:sym<.> { <sym> }
sub twigil__S_040Dot__PEEK { $_[0]->_AUTOLEXpeek('twigil__S_040Dot', $retree) }
sub twigil__S_040Dot {
no warnings 'recursion';
my $self = shift;

;

local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;

my $C = $self->cursor_xact("RULE twigil__S_040Dot");
my $xact = $C->xact;
my $S = $C->{'_pos'};
$C->{sym} = "\.";
$self->_MATCHIFYr($S, "twigil__S_040Dot", do {
my $C = $C;
if (($C) = ($C->_EXACT("\."))
and ($C) = ($C->begid)) {
$C
} else { () }

});
}
;
## token twigil:sym<!> { <sym> }
sub twigil__S_041Bang__PEEK { $_[0]->_AUTOLEXpeek('twigil__S_041Bang', $retree) }
sub twigil__S_041Bang {
no warnings 'recursion';
my $self = shift;

;

local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;

my $C = $self->cursor_xact("RULE twigil__S_041Bang");
my $xact = $C->xact;
my $S = $C->{'_pos'};
$C->{sym} = "\!";
$self->_MATCHIFYr($S, "twigil__S_041Bang", do {
my $C = $C;
if (($C) = ($C->_EXACT("\!"))
and ($C) = ($C->begid)) {
$C
} else { () }

});
}
;
## token twigil:sym<^> { <sym> }
sub twigil__S_042Caret__PEEK { $_[0]->_AUTOLEXpeek('twigil__S_042Caret', $retree) }
sub twigil__S_042Caret {
no warnings 'recursion';
my $self = shift;

;

local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;

my $C = $self->cursor_xact("RULE twigil__S_042Caret");
my $xact = $C->xact;
my $S = $C->{'_pos'};
$C->{sym} = "\^";
$self->_MATCHIFYr($S, "twigil__S_042Caret", do {
my $C = $C;
if (($C) = ($C->_EXACT("\^"))
and ($C) = ($C->begid)) {
$C
} else { () }

});
}
;
## token twigil:sym<:> { <sym> }
sub twigil__S_043Colon__PEEK { $_[0]->_AUTOLEXpeek('twigil__S_043Colon', $retree) }
sub twigil__S_043Colon {
no warnings 'recursion';
my $self = shift;

;

local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;

my $C = $self->cursor_xact("RULE twigil__S_043Colon");
my $xact = $C->xact;
my $S = $C->{'_pos'};
$C->{sym} = "\:";
$self->_MATCHIFYr($S, "twigil__S_043Colon", do {
my $C = $C;
if (($C) = ($C->_EXACT("\:"))
and ($C) = ($C->begid)) {
$C
} else { () }

});
}
;
## token twigil:sym<*> { <sym> }
sub twigil__S_044Star__PEEK { $_[0]->_AUTOLEXpeek('twigil__S_044Star', $retree) }
sub twigil__S_044Star {
no warnings 'recursion';
my $self = shift;

;

local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;

my $C = $self->cursor_xact("RULE twigil__S_044Star");
my $xact = $C->xact;
my $S = $C->{'_pos'};
$C->{sym} = "\*";
$self->_MATCHIFYr($S, "twigil__S_044Star", do {
my $C = $C;
if (($C) = ($C->_EXACT("\*"))
and ($C) = ($C->begid)) {
$C
} else { () }

});
}
;
## token twigil:sym<?> { <sym> }
sub twigil__S_045Question__PEEK { $_[0]->_AUTOLEXpeek('twigil__S_045Question', $retree) }
sub twigil__S_045Question {
no warnings 'recursion';
my $self = shift;

;

local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;

my $C = $self->cursor_xact("RULE twigil__S_045Question");
my $xact = $C->xact;
my $S = $C->{'_pos'};
$C->{sym} = "\?";
$self->_MATCHIFYr($S, "twigil__S_045Question", do {
my $C = $C;
if (($C) = ($C->_EXACT("\?"))
and ($C) = ($C->begid)) {
$C
} else { () }

});
}
;
## token twigil:sym<=> { <sym> }
sub twigil__S_046Equal__PEEK { $_[0]->_AUTOLEXpeek('twigil__S_046Equal', $retree) }
sub twigil__S_046Equal {
no warnings 'recursion';
my $self = shift;

;

local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;

my $C = $self->cursor_xact("RULE twigil__S_046Equal");
my $xact = $C->xact;
my $S = $C->{'_pos'};
$C->{sym} = "\=";
$self->_MATCHIFYr($S, "twigil__S_046Equal", do {
my $C = $C;
if (($C) = ($C->_EXACT("\="))
and ($C) = ($C->begid)) {
$C
} else { () }

});
}
;
## token twigil:sym<~> { <sym> }
sub twigil__S_047Tilde__PEEK { $_[0]->_AUTOLEXpeek('twigil__S_047Tilde', $retree) }
sub twigil__S_047Tilde {
no warnings 'recursion';
my $self = shift;

;

local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;

my $C = $self->cursor_xact("RULE twigil__S_047Tilde");
my $xact = $C->xact;
my $S = $C->{'_pos'};
$C->{sym} = "\~";
$self->_MATCHIFYr($S, "twigil__S_047Tilde", do {
my $C = $C;
if (($C) = ($C->_EXACT("\~"))
and ($C) = ($C->begid)) {
$C
} else { () }

});
}
;
## token stopper { <!> }
sub stopper__PEEK { $_[0]->_AUTOLEXpeek('stopper', $retree) }
sub stopper {
no warnings 'recursion';
my $self = shift;


local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;

my $C = $self->cursor_xact("RULE stopper");
my $xact = $C->xact;
my $S = $C->{'_pos'};
$self->_MATCHIFYr($S, "stopper", $C->_NOTBEFORE(sub {
my $C=shift;
$C
}));
}
;
## regex stdstopper {
sub stdstopper__PEEK { $_[0]->_AUTOLEXpeek('stdstopper', $retree) }
sub stdstopper {
no warnings 'recursion';
my $self = shift;

local $::STUB = $::STUB = return $self if exists $::MEMOS[$self->{'_pos'}]->{'endstmt'};
local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;

my $C = $self->cursor_xact("RULE stdstopper");
my $xact = $C->xact;
my $S = $C->{'_pos'};
$self->_MATCHIFY($S, "stdstopper", LazyMap::lazymap(sub {
my $C=shift;
scalar(do {
$::MEMOS[$C->{'_pos'}]->{'endstmt'} ||= 1}, $C)
},
$C->_BRACKET(sub {
my $C=shift;
do {
my ($tag, $try);
my @try;
my $relex;

my $fate;
my $x;
if ($fate = $C->{'_fate'} and $fate->[1] eq 'stdstopper_0') {
$C->deb("Fate passed to stdstopper_0: ", ::fatestr($fate)) if $::DEBUG & DEBUG::fates;
($C->{'_fate'}, $tag, $try) = @$fate;
@try = ($try);
$x = 'ALT stdstopper_0';    # some outer ltm is controlling us
}
else {
$x = 'ALTLTM stdstopper_0'; # we are top level ltm
}
my $C = $C->cursor_xact($x);
my $xact = $C->{_xact};

my @gather = ();
for (;;) {
unless (@try) {
$relex //= $C->cursor_fate('STD', 'stdstopper_0', $retree);
@try = $relex->($C) or last;
}
$try = shift(@try) // next;

if (ref $try) {
($C->{'_fate'}, $tag, $try) = @$try;   # next candidate fate
}

$C->deb("stdstopper_0 trying $tag $try") if $::DEBUG & DEBUG::try_processing;
push @gather, ((
sub {
my $C=shift;
$C->before(sub {
my $C=shift;
$C->terminator
})
},
sub {
my $C=shift;
$C->before(sub {
my $C=shift;
$C->unitstopper
})
},
sub {
my $C=shift;
$C->before(sub {
my $C=shift;
$C->_SUBSUME(['stopper'], sub {
my $C = shift;
$C->stopper
})
})
},
sub {
my $C=shift;
$C->_PATTERN(qr/\G\z/)
}
)[$try])->($C);
last if @gather;
last if $xact->[-2];  # committed?
}
@gather;
};
})));
}
;
## token longname {
sub longname__PEEK { $_[0]->_AUTOLEXpeek('longname', $retree) }
sub longname {
no warnings 'recursion';
my $self = shift;


local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;

my $C = $self->cursor_xact("RULE longname");
my $xact = $C->xact;
my $S = $C->{'_pos'};
$C->{'colonpair'} = [];
$self->_MATCHIFYr($S, "longname", do {
my $C = $C;
if (($C) = ($C->_SUBSUMEr(['name'], sub {
my $C = shift;
$C->name
}))
and ($C) = (scalar(do {
}, $C))) {
$C->_STARr(sub {
my $C=shift;
if (my ($C) = ($C->_BRACKETr(sub {
my $C=shift;
if (my ($C) = ($C->before(sub {
my $C=shift;
if (my ($C) = ($C->before(sub {
my $C=shift;
$C->_PATTERN(qr/\G\:[a-zA-Z_\<\[\«]/)
}))) { ($C) } else { () }
}))) {
$C->_SUBSUMEr(['colonpair'], sub {
my $C = shift;
$C->colonpair
})
} else { () }
}))) { ($C) } else { () }
})
} else { () }

});
}
;
## token name {
sub name__PEEK { $_[0]->_AUTOLEXpeek('name', $retree) }
sub name {
no warnings 'recursion';
my $self = shift;


local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;

my $C = $self->cursor_xact("RULE name");
my $xact = $C->xact;
my $S = $C->{'_pos'};
$C->{'morename'} = [];
$self->_MATCHIFYr($S, "name", $C->_BRACKETr(sub {
my $C=shift;
do {
my ($tag, $try);
my @try;
my $relex;

my $fate;
my $x;
if ($fate = $C->{'_fate'} and $fate->[1] eq 'name_0') {
$C->deb("Fate passed to name_0: ", ::fatestr($fate)) if $::DEBUG & DEBUG::fates;
($C->{'_fate'}, $tag, $try) = @$fate;
@try = ($try);
$x = 'ALT name_0';    # some outer ltm is controlling us
}
else {
$x = 'ALTLTM name_0'; # we are top level ltm
}
my $C = $C->cursor_xact($x);
my $xact = $C->{_xact};

my @gather = ();
for (;;) {
unless (@try) {
$relex //= $C->cursor_fate('STD', 'name_0', $retree);
@try = $relex->($C) or last;
}
$try = shift(@try) // next;

if (ref $try) {
($C->{'_fate'}, $tag, $try) = @$try;   # next candidate fate
}

$C->deb("name_0 trying $tag $try") if $::DEBUG & DEBUG::try_processing;
push @gather, ((
sub {
my $C=shift;
if (my ($C) = ($C->_SUBSUMEr(['identifier'], sub {
my $C = shift;
$C->identifier
}))) {
$C->_STARr(sub {
my $C=shift;
$C->_SUBSUMEr(['morename'], sub {
my $C = shift;
$C->morename
})
})
} else { () }
},
sub {
my $C=shift;
$C->_PLUSr(sub {
my $C=shift;
$C->_SUBSUMEr(['morename'], sub {
my $C = shift;
$C->morename
})
})
}
)[$try])->($C);
last if @gather;
last if $xact->[-2];  # committed?
}
@gather;
};
}));
}
;
## token morename {
sub morename__PEEK { $_[0]->_AUTOLEXpeek('morename', $retree) }
sub morename {
no warnings 'recursion';
my $self = shift;

local $::QSIGIL = '';
local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;

my $C = $self->cursor_xact("RULE morename");
my $xact = $C->xact;
my $S = $C->{'_pos'};
$C->{'EXPR'} = [];
$C->{'identifier'} = [];
$self->_MATCHIFYr($S, "morename", do {
if (my ($C) = ($C->_EXACT("\:\:"))) {
$C->_OPTr(sub {
my $C=shift;
if (my ($C) = ($C->_BRACKETr(sub {
my $C=shift;
do {    my $C = $C->cursor_xact('ALT ||');
my $xact = $C->xact;
my @gather;
do {
push @gather, do {
my $C = $C;
if (($C) = ($C->before(sub {
my $C=shift;
if (my ($C) = ($C->before(sub {
my $C=shift;
if (my ($C) = (do {
do {
my ($tag, $try);
my @try;
my $relex;

my $fate;
my $x;
if ($fate = $C->{'_fate'} and $fate->[1] eq 'morename_0') {
$C->deb("Fate passed to morename_0: ", ::fatestr($fate)) if $::DEBUG & DEBUG::fates;
($C->{'_fate'}, $tag, $try) = @$fate;
@try = ($try);
$x = 'ALT morename_0';    # some outer ltm is controlling us
}
else {
$x = 'ALTLTM morename_0'; # we are top level ltm
}
my $C = $C->cursor_xact($x);
my $xact = $C->{_xact};

my @gather = ();
for (;;) {
unless (@try) {
$relex //= $C->cursor_fate('STD', 'morename_0', $retree);
@try = $relex->($C) or last;
}
$try = shift(@try) // next;

if (ref $try) {
($C->{'_fate'}, $tag, $try) = @$try;   # next candidate fate
}

$C->deb("morename_0 trying $tag $try") if $::DEBUG & DEBUG::try_processing;
push @gather, ((
sub {
my $C=shift;
$C->_EXACT("\(")
},
sub {
my $C=shift;
$C->_PATTERN(qr/\G[_[:alpha:]]/)
}
)[$try])->($C);
last if @gather;
last if $xact->[-2];  # committed?
}
@gather;
};

})) { ($C) } else { () }
}))) { ($C) } else { () }
}))
and ($C) = ($C->_BRACKETr(sub {
my $C=shift;
do {
my ($tag, $try);
my @try;
my $relex;

my $fate;
my $x;
if ($fate = $C->{'_fate'} and $fate->[1] eq 'morename_1') {
$C->deb("Fate passed to morename_1: ", ::fatestr($fate)) if $::DEBUG & DEBUG::fates;
($C->{'_fate'}, $tag, $try) = @$fate;
@try = ($try);
$x = 'ALT morename_1';    # some outer ltm is controlling us
}
else {
$x = 'ALTLTM morename_1'; # we are top level ltm
}
my $C = $C->cursor_xact($x);
my $xact = $C->{_xact};

my @gather = ();
for (;;) {
unless (@try) {
$relex //= $C->cursor_fate('STD', 'morename_1', $retree);
@try = $relex->($C) or last;
}
$try = shift(@try) // next;

if (ref $try) {
($C->{'_fate'}, $tag, $try) = @$try;   # next candidate fate
}

$C->deb("morename_1 trying $tag $try") if $::DEBUG & DEBUG::try_processing;
push @gather, ((
sub {
my $C=shift;
$C->_SUBSUMEr(['identifier'], sub {
my $C = shift;
$C->identifier
})
},
sub {
my $C=shift;
if (my ($C) = ($C->_BRACKETr(sub {
my $C=shift;
local $::GOAL = "\)";
my $goalpos = $C;
if (($C) = ($C->_EXACT("\("))
and ($C) = (scalar(do {
}, $C))
and ($C) = ($C->_SUBSUMEr(['EXPR'], sub {
my $C = shift;
$C->EXPR
}))
and ($C) = ($C->_BRACKETr(sub {
my $C=shift;
do {    my $C = $C->cursor_xact('ALT ||');
my $xact = $C->xact;
my @gather;
do {
push @gather, $C->_EXACT("\)")
}
or $xact->[-2] or
do {
push @gather, do {
if (my ($C) = ($C->FAILGOAL($::GOAL, 'indirect name', $goalpos))) { ($C) } else { () }

}
};
@gather;
}
}))) {
$C
} else { () }
}))) { ($C) } else { () }
}
)[$try])->($C);
last if @gather;
last if $xact->[-2];  # committed?
}
@gather;
};
}))) {
$C
} else { () }

}
}
or $xact->[-2] or
do {
push @gather, do {
my $C = $C;
if (($C) = ($C->before(sub {
my $C=shift;
if (my ($C) = ($C->before(sub {
my $C=shift;
$C->_EXACT("\:\:")
}))) { ($C) } else { () }
}))
and ($C) = ($C->panic("Name component may not be null"))) {
$C
} else { () }

}
};
@gather;
}
}))) { ($C) } else { () }
})
} else { () }

});
}
;
## method peek_delimiters
sub peek_delimiters {
no warnings 'recursion';
my $self = shift;
my $pos = $self->{'_pos'};
my $startpos = $pos;
my $char = substr($::ORIG,$pos++,1);
if ($char =~ /^\s$/) {
$self->panic("Whitespace character is not allowed as delimiter")}
elsif ($char =~ /^\w$/) {
$self->panic("Alphanumeric character is not allowed as delimiter")}
elsif ($STD::close2open{$char}) {
$self->panic("Use of a closing delimiter for an opener is reserved")}
elsif ($char eq ':') {
$self->panic("Colons may not be used to delimit quoting constructs")};
my $rightbrack = $STD::open2close{$char};
if (not defined $rightbrack) {
return $char, $char};
while (substr($::ORIG,$pos,1) eq $char) {
$pos++}
;
my $len = $pos - $startpos;
my $start = $char x $len;
my $stop = $rightbrack x $len;
return $start, $stop;
};
{     package STD::startstop;
require "mangle.pl";
our %INSTANTIATED;
sub __instantiate__ { my $self = shift;
my ($start, $stop) = @_;
my $mangle = ::mangle($start, $stop);
my $mixin = "STD::startstop::" . $mangle;
return $mixin if $INSTANTIATED{$mixin}++;
::deb("         instantiating $mixin") if $::DEBUG & DEBUG::mixins;
my $eval = "package $mixin" . q{;
	    sub _PARAMS { { '$start' => $start, '$stop' => $stop } }
use Moose::Role ':all' => { -prefix => "moose_" };
use Encode;
our $ALLROLES = { 'STD::startstop', 1 };
our $REGEXES = {
ALL => [ qw/starter stopper/ ],
};


no warnings 'qw', 'recursion';
my $retree;

$DB::deep = $DB::deep = 1000; # suppress used-once warning

use YAML::XS;

$SIG{__WARN__} = sub { die @_,"   statement started at line ", 'Cursor'->lineof($::LASTSTATE), "
" } if $::DEBUG;

$retree = YAML::XS::Load(Encode::encode_utf8(<<'RETREE_END'));
---
starter: !!perl/hash:RE_ast
  dba: starter
  dic: STD::startstop
  re: !!perl/hash:RE_var
    var: $start
stopper: !!perl/hash:RE_ast
  dba: stopper
  dic: STD::startstop
  re: !!perl/hash:RE_var
    var: $stop
RETREE_END
## token starter { $start }
sub starter__PEEK { $_[0]->_AUTOLEXpeek('starter', $retree) }
sub starter {
no warnings 'recursion';
my $self = shift;


local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;

my $C = $self->cursor_xact("RULE starter");
my $xact = $C->xact;
my $S = $C->{'_pos'};
$self->_MATCHIFYr($S, "starter", $C->_EXACT($start));
}
;
## token stopper { $stop }
sub stopper__PEEK { $_[0]->_AUTOLEXpeek('stopper', $retree) }
sub stopper {
no warnings 'recursion';
my $self = shift;


local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;

my $C = $self->cursor_xact("RULE stopper");
my $xact = $C->xact;
my $S = $C->{'_pos'};
$self->_MATCHIFYr($S, "stopper", $C->_EXACT($stop));
}
;
	};
	eval $eval;
	die $@ if $@;
	return $mixin;
}
1; };
{     package STD::stop;
require "mangle.pl";
our %INSTANTIATED;
sub __instantiate__ { my $self = shift;
my ($stop) = @_;
my $mangle = ::mangle($stop);
my $mixin = "STD::stop::" . $mangle;
return $mixin if $INSTANTIATED{$mixin}++;
::deb("         instantiating $mixin") if $::DEBUG & DEBUG::mixins;
my $eval = "package $mixin" . q{;
	    sub _PARAMS { { '$stop' => $stop } }
use Moose::Role ':all' => { -prefix => "moose_" };
use Encode;
our $ALLROLES = { 'STD::stop', 1 };
our $REGEXES = {
ALL => [ qw/starter stopper/ ],
};


no warnings 'qw', 'recursion';
my $retree;

$DB::deep = $DB::deep = 1000; # suppress used-once warning

use YAML::XS;

$SIG{__WARN__} = sub { die @_,"   statement started at line ", 'Cursor'->lineof($::LASTSTATE), "
" } if $::DEBUG;

$retree = YAML::XS::Load(Encode::encode_utf8(<<'RETREE_END'));
---
starter: !!perl/hash:RE_ast
  dba: starter
  dic: STD::stop
  re: !!perl/hash:RE_assertion
    assert: '!'
    re: !!perl/hash:RE_noop
      nobind: 1
stopper: !!perl/hash:RE_ast
  dba: stopper
  dic: STD::stop
  re: !!perl/hash:RE_var
    var: $stop
RETREE_END
## token starter { <!> }
sub starter__PEEK { $_[0]->_AUTOLEXpeek('starter', $retree) }
sub starter {
no warnings 'recursion';
my $self = shift;


local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;

my $C = $self->cursor_xact("RULE starter");
my $xact = $C->xact;
my $S = $C->{'_pos'};
$self->_MATCHIFYr($S, "starter", $C->_NOTBEFORE(sub {
my $C=shift;
$C
}));
}
;
## token stopper { $stop }
sub stopper__PEEK { $_[0]->_AUTOLEXpeek('stopper', $retree) }
sub stopper {
no warnings 'recursion';
my $self = shift;


local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;

my $C = $self->cursor_xact("RULE stopper");
my $xact = $C->xact;
my $S = $C->{'_pos'};
$self->_MATCHIFYr($S, "stopper", $C->_EXACT($stop));
}
;
	};
	eval $eval;
	die $@ if $@;
	return $mixin;
}
1; };
{     package STD::unitstop;
require "mangle.pl";
our %INSTANTIATED;
sub __instantiate__ { my $self = shift;
my ($stop) = @_;
my $mangle = ::mangle($stop);
my $mixin = "STD::unitstop::" . $mangle;
return $mixin if $INSTANTIATED{$mixin}++;
::deb("         instantiating $mixin") if $::DEBUG & DEBUG::mixins;
my $eval = "package $mixin" . q{;
	    sub _PARAMS { { '$stop' => $stop } }
use Moose::Role ':all' => { -prefix => "moose_" };
use Encode;
our $ALLROLES = { 'STD::unitstop', 1 };
our $REGEXES = {
ALL => [ qw/unitstopper/ ],
};


no warnings 'qw', 'recursion';
my $retree;

$DB::deep = $DB::deep = 1000; # suppress used-once warning

use YAML::XS;

$SIG{__WARN__} = sub { die @_,"   statement started at line ", 'Cursor'->lineof($::LASTSTATE), "
" } if $::DEBUG;

$retree = YAML::XS::Load(Encode::encode_utf8(<<'RETREE_END'));
---
unitstopper: !!perl/hash:RE_ast
  dba: unitstopper
  dic: STD::unitstop
  re: !!perl/hash:RE_var
    var: $stop
RETREE_END
## token unitstopper { $stop }
sub unitstopper__PEEK { $_[0]->_AUTOLEXpeek('unitstopper', $retree) }
sub unitstopper {
no warnings 'recursion';
my $self = shift;


local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;

my $C = $self->cursor_xact("RULE unitstopper");
my $xact = $C->xact;
my $S = $C->{'_pos'};
$self->_MATCHIFYr($S, "unitstopper", $C->_EXACT($stop));
}
	};
	eval $eval;
	die $@ if $@;
	return $mixin;
}
1; };
## token unitstopper { $ }
sub unitstopper__PEEK { $_[0]->_AUTOLEXpeek('unitstopper', $retree) }
sub unitstopper {
no warnings 'recursion';
my $self = shift;


local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;

my $C = $self->cursor_xact("RULE unitstopper");
my $xact = $C->xact;
my $S = $C->{'_pos'};
$self->_MATCHIFYr($S, "unitstopper", $C->_PATTERN(qr/\G\z/));
}
;
## method balanced ($start,$stop)
sub balanced {
no warnings 'recursion';
my $self = shift;
die 'Required argument start omitted' unless @_;
my $start = @_ ? shift() : undef;
die 'Required argument stop omitted' unless @_;
my $stop = @_ ? shift() : undef;
$self->mixin( STD::startstop->__instantiate__($start,$stop) )};
## method unbalanced ($stop)
sub unbalanced {
no warnings 'recursion';
my $self = shift;
die 'Required argument stop omitted' unless @_;
my $stop = @_ ? shift() : undef;
$self->mixin( STD::stop->__instantiate__($stop) )};
## method unitstop ($stop)
sub unitstop {
no warnings 'recursion';
my $self = shift;
die 'Required argument stop omitted' unless @_;
my $stop = @_ ? shift() : undef;
$self->mixin( STD::unitstop->__instantiate__($stop) )};
## method truly ($bool,$opt)
sub truly {
no warnings 'recursion';
my $self = shift;
die 'Required argument bool omitted' unless @_;
my $bool = @_ ? shift() : undef;
die 'Required argument opt omitted' unless @_;
my $opt = @_ ? shift() : undef;
return $self if $bool;
$self->sorry("Can't negate $opt adverb");
$self;
};
## token charname {
sub charname__PEEK { $_[0]->_AUTOLEXpeek('charname', $retree) }
sub charname {
no warnings 'recursion';
my $self = shift;


local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;

my $C = $self->cursor_xact("RULE charname");
my $xact = $C->xact;
my $S = $C->{'_pos'};
$self->_MATCHIFYr($S, "charname", do {    my $C = $C->cursor_xact('ALT ||');
my $xact = $C->xact;
my @gather;
do {
push @gather, do {
if (my ($C) = ($C->_BRACKETr(sub {
my $C=shift;
do {
my ($tag, $try);
my @try;
my $relex;

my $fate;
my $x;
if ($fate = $C->{'_fate'} and $fate->[1] eq 'charname_0') {
$C->deb("Fate passed to charname_0: ", ::fatestr($fate)) if $::DEBUG & DEBUG::fates;
($C->{'_fate'}, $tag, $try) = @$fate;
@try = ($try);
$x = 'ALT charname_0';    # some outer ltm is controlling us
}
else {
$x = 'ALTLTM charname_0'; # we are top level ltm
}
my $C = $C->cursor_xact($x);
my $xact = $C->{_xact};

my @gather = ();
for (;;) {
unless (@try) {
$relex //= $C->cursor_fate('STD', 'charname_0', $retree);
@try = $relex->($C) or last;
}
$try = shift(@try) // next;

if (ref $try) {
($C->{'_fate'}, $tag, $try) = @$try;   # next candidate fate
}

$C->deb("charname_0 trying $tag $try") if $::DEBUG & DEBUG::try_processing;
push @gather, ((
sub {
my $C=shift;
$C->_SUBSUMEr(['radint'], sub {
my $C = shift;
$C->radint
})
},
sub {
my $C=shift;
if (my ($C) = (do {
if (my ($C) = ($C->_PATTERN(qr/\G[_[:alpha:]]/))) {
LazyMap::lazymap(sub {
my $C=shift;
if (my ($C) = ($C->before(sub {
my $C=shift;
if (my ($C) = ($C->before(sub {
my $C=shift;
do {
my $C = $C;
if (($C) = ($C->_PATTERN(qr/\G\s*+/))
and ($C) = ($C->_BRACKETr(sub {
my $C=shift;
do {
my ($tag, $try);
my @try;
my $relex;

my $fate;
my $x;
if ($fate = $C->{'_fate'} and $fate->[1] eq 'charname_1') {
$C->deb("Fate passed to charname_1: ", ::fatestr($fate)) if $::DEBUG & DEBUG::fates;
($C->{'_fate'}, $tag, $try) = @$fate;
@try = ($try);
$x = 'ALT charname_1';    # some outer ltm is controlling us
}
else {
$x = 'ALTLTM charname_1'; # we are top level ltm
}
my $C = $C->cursor_xact($x);
my $xact = $C->{_xact};

my @gather = ();
for (;;) {
unless (@try) {
$relex //= $C->cursor_fate('STD', 'charname_1', $retree);
@try = $relex->($C) or last;
}
$try = shift(@try) // next;

if (ref $try) {
($C->{'_fate'}, $tag, $try) = @$try;   # next candidate fate
}

$C->deb("charname_1 trying $tag $try") if $::DEBUG & DEBUG::try_processing;
push @gather, ((
sub {
my $C=shift;
$C->_EXACT("\,")
},
sub {
my $C=shift;
$C->_EXACT("\#")
},
sub {
my $C=shift;
$C->_EXACT("\]")
}
)[$try])->($C);
last if @gather;
last if $xact->[-2];  # committed?
}
@gather;
};
}))) {
$C
} else { () }
};
}))) { ($C) } else { () }
}))) { ($C) } else { () }
},
$C->_SCANf())
} else { () }

})) { ($C) } else { () }
}
)[$try])->($C);
last if @gather;
last if $xact->[-2];  # committed?
}
@gather;
};
}))) { ($C) } else { () }

}
}
or $xact->[-2] or
do {
push @gather, do {
if (my ($C) = (do {
if (my ($C) = ($C->sorry("Unrecognized character name"))) {
LazyMap::lazymap(sub {
my $C=shift;
if (my ($C) = ($C->before(sub {
my $C=shift;
if (my ($C) = ($C->terminator)) { ($C) } else { () }
}))) { ($C) } else { () }
},
$C->_SCANf())
} else { () }

})) { ($C) } else { () }

}
};
@gather;
});
}
;
## token charnames { \s* [<charname><.ws>] ** [','\s*] }
sub charnames__PEEK { $_[0]->_AUTOLEXpeek('charnames', $retree) }
sub charnames {
no warnings 'recursion';
my $self = shift;


local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;

my $C = $self->cursor_xact("RULE charnames");
my $xact = $C->xact;
my $S = $C->{'_pos'};
$C->{'charname'} = [];
$self->_MATCHIFYr($S, "charnames", do {
if (my ($C) = ($C->_PATTERN(qr/\G\s*+/))) {
$C->_REPSEPr( sub {
my $C=shift;
if (my ($C) = ($C->_BRACKETr(sub {
my $C=shift;
$C->_PATTERN(qr/\G\,\s*+/)
}))) { ($C) } else { () }
}, sub {
my $C=shift;
if (my ($C) = ($C->_BRACKETr(sub {
my $C=shift;
if (($C) = ($C->_SUBSUMEr(['charname'], sub {
my $C = shift;
$C->charname
}))
and ($C) = ($C->ws)) {
$C
} else { () }
}))) { ($C) } else { () }
})
} else { () }

});
}
;
## token charspec {
sub charspec__PEEK { $_[0]->_AUTOLEXpeek('charspec', $retree) }
sub charspec {
no warnings 'recursion';
my $self = shift;


local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;

my $C = $self->cursor_xact("RULE charspec");
my $xact = $C->xact;
my $S = $C->{'_pos'};
$self->_MATCHIFYr($S, "charspec", $C->_BRACKETr(sub {
my $C=shift;
do {
my ($tag, $try);
my @try;
my $relex;

my $fate;
my $x;
if ($fate = $C->{'_fate'} and $fate->[1] eq 'charspec_0') {
$C->deb("Fate passed to charspec_0: ", ::fatestr($fate)) if $::DEBUG & DEBUG::fates;
($C->{'_fate'}, $tag, $try) = @$fate;
@try = ($try);
$x = 'ALT charspec_0';    # some outer ltm is controlling us
}
else {
$x = 'ALTLTM charspec_0'; # we are top level ltm
}
my $C = $C->cursor_xact($x);
my $xact = $C->{_xact};

my @gather = ();
for (;;) {
unless (@try) {
$relex //= $C->cursor_fate('STD', 'charspec_0', $retree);
@try = $relex->($C) or last;
}
$try = shift(@try) // next;

if (ref $try) {
($C->{'_fate'}, $tag, $try) = @$try;   # next candidate fate
}

$C->deb("charspec_0 trying $tag $try") if $::DEBUG & DEBUG::try_processing;
push @gather, ((
sub {
my $C=shift;
if (my ($C) = ($C->_BRACKETr(sub {
my $C=shift;
local $::GOAL = "\]";
my $goalpos = $C;
if (($C) = ($C->_EXACT("\["))
and ($C) = (scalar(do {
}, $C))
and ($C) = ($C->_SUBSUMEr(['charnames'], sub {
my $C = shift;
$C->charnames
}))
and ($C) = ($C->_BRACKETr(sub {
my $C=shift;
do {    my $C = $C->cursor_xact('ALT ||');
my $xact = $C->xact;
my @gather;
do {
push @gather, $C->_EXACT("\]")
}
or $xact->[-2] or
do {
push @gather, do {
if (my ($C) = ($C->FAILGOAL($::GOAL, 'character name', $goalpos))) { ($C) } else { () }

}
};
@gather;
}
}))) {
$C
} else { () }
}))) { ($C) } else { () }
},
sub {
my $C=shift;
$C->_PATTERN(qr/\G\d++/)
},
sub {
my $C=shift;
$C->_PATTERN(qr/\G[?-Z\\-_]/)
},
sub {
my $C=shift;
if (($C) = ($C->before(sub {
my $C=shift;
$C
}))
and ($C) = ($C->sorry("Unrecognized \\c character"))) {
$C->cursor_incr()
} else { () }
}
)[$try])->($C);
last if @gather;
last if $xact->[-2];  # committed?
}
@gather;
};
}));
}
;
## token backslash {*}
sub backslash__PEEK { $_[0]->_AUTOLEXpeek('backslash:*',$retree); }
sub backslash {
my $self = shift;
my $subs;

local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;

my $C = $self->cursor_xact('RULE backslash');
my $S = $C->{'_pos'};

my @result = do {
my ($tag, $try);
my @try;
my $relex;
my $x;
if (my $fate = $C->{'_fate'}) {
if ($fate->[1] eq 'backslash') {
$C->deb("Fate passed to backslash: ", ::fatestr($fate)) if $::DEBUG & DEBUG::fates;
($C->{'_fate'}, $tag, $try) = @$fate;
@try = ($try);
$x = 'ALT backslash';
}
else {
$x = 'ALTLTM backslash';
}
}
else {
$x = 'ALTLTM backslash';
}
my $C = $C->cursor_xact($x);
my $xact = $C->{_xact};

my @gather = ();
for (;;) {
unless (@try) {
$relex //= $C->cursor_fate('STD', 'backslash:*', $retree);
@try = $relex->($C) or last;
}
$try = shift(@try) // next;

if (ref $try) {
($C->{'_fate'}, $tag, $try) = @$try;       # next candidate fate
}

$C->deb("backslash trying $tag $try") if $::DEBUG & DEBUG::try_processing;
push @gather, $C->$try(@_);
last if @gather;
last if $xact->[-2];  # committed?
}
$self->_MATCHIFYr($S, "backslash", @gather);
};
@result;
}
;
## token escape {*}
sub escape__PEEK { $_[0]->_AUTOLEXpeek('escape:*',$retree); }
sub escape {
my $self = shift;
my $subs;

local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;

my $C = $self->cursor_xact('RULE escape');
my $S = $C->{'_pos'};

my @result = do {
my ($tag, $try);
my @try;
my $relex;
my $x;
if (my $fate = $C->{'_fate'}) {
if ($fate->[1] eq 'escape') {
$C->deb("Fate passed to escape: ", ::fatestr($fate)) if $::DEBUG & DEBUG::fates;
($C->{'_fate'}, $tag, $try) = @$fate;
@try = ($try);
$x = 'ALT escape';
}
else {
$x = 'ALTLTM escape';
}
}
else {
$x = 'ALTLTM escape';
}
my $C = $C->cursor_xact($x);
my $xact = $C->{_xact};

my @gather = ();
for (;;) {
unless (@try) {
$relex //= $C->cursor_fate('STD', 'escape:*', $retree);
@try = $relex->($C) or last;
}
$try = shift(@try) // next;

if (ref $try) {
($C->{'_fate'}, $tag, $try) = @$try;       # next candidate fate
}

$C->deb("escape trying $tag $try") if $::DEBUG & DEBUG::try_processing;
push @gather, $C->$try(@_);
last if @gather;
last if $xact->[-2];  # committed?
}
$self->_MATCHIFYr($S, "escape", @gather);
};
@result;
}
;
## token starter { <!> }
sub starter__PEEK { $_[0]->_AUTOLEXpeek('starter', $retree) }
sub starter {
no warnings 'recursion';
my $self = shift;


local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;

my $C = $self->cursor_xact("RULE starter");
my $xact = $C->xact;
my $S = $C->{'_pos'};
$self->_MATCHIFYr($S, "starter", $C->_NOTBEFORE(sub {
my $C=shift;
$C
}));
}
;
## token escape:none { <!> }
sub escape__S_048none__PEEK { $_[0]->_AUTOLEXpeek('escape__S_048none', $retree) }
sub escape__S_048none {
no warnings 'recursion';
my $self = shift;


local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;

my $C = $self->cursor_xact("RULE escape__S_048none");
my $xact = $C->xact;
my $S = $C->{'_pos'};
$C->{sym} = "none";
$self->_MATCHIFYr($S, "escape__S_048none", $C->_NOTBEFORE(sub {
my $C=shift;
$C
}));
}
;
## method nibble ($lang)
sub nibble {
no warnings 'recursion';
my $self = shift;
die 'Required argument lang omitted' unless @_;
my $lang = @_ ? shift() : undef;
$self->cursor_fresh($lang)->nibbler};
## token nibbler {
sub nibbler__PEEK { $_[0]->_AUTOLEXpeek('nibbler', $retree) }
sub nibbler {
no warnings 'recursion';
my $self = shift;

my $text = '';my $from = $self->{'_pos'};my $to = $from;my @nibbles = ();my $multiline = 0;
local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;

my $C = $self->cursor_xact("RULE nibbler");
my $xact = $C->xact;
my $S = $C->{'_pos'};
$C->{'escape'} = [];
$C->{'nibbler'} = [];
$C->{'starter'} = [];
$C->{'stopper'} = [];
$self->_MATCHIFYr($S, "nibbler", do {
my $C = $C;
if (($C) = (scalar(do {
$self->from = $self->{'_pos'}}, $C))
and ($C) = ($C->_STARr(sub {
my $C=shift;
if (my ($C) = ($C->_BRACKETr(sub {
my $C=shift;
if (($C) = ($C->_NOTBEFORE(sub {
my $C=shift;
if (my ($C) = ($C->before(sub {
my $C=shift;
$C->{'stopper'} = [];
$C->_SUBSUMEr(['stopper'], sub {
my $C = shift;
$C->stopper
})
}))) { ($C) } else { () }
}))
and ($C) = ($C->_BRACKETr(sub {
my $C=shift;
do {    my $C = $C->cursor_xact('ALT ||');
my $xact = $C->xact;
my @gather;
do {
push @gather, do {
my $C = $C;
if (($C) = ($C->_SUBSUMEr(['starter'], sub {
my $C = shift;
$C->starter
}))
and ($C) = ($C->_SUBSUMEr(['nibbler'], sub {
my $C = shift;
$C->nibbler
}))
and ($C) = ($C->_SUBSUMEr(['stopper'], sub {
my $C = shift;
$C->stopper
}))) {
scalar(do {
my $M = $C;
{
push @nibbles, $C->makestr(TEXT => $text, _from => $from, _pos => $to ) if $from != $to;
my $n = $M->{'nibbler'}->[-1]->{'nibbles'};
my @n = @$n;
push @nibbles, $M->{'starter'};
push @nibbles, @n;
push @nibbles, $M->{'stopper'};
$text = '';
$to = $from = $C->{'_pos'};
}}, $C)
} else { () }

}
}
or $xact->[-2] or
do {
push @gather, do {
if (my ($C) = ($C->_SUBSUMEr(['escape'], sub {
my $C = shift;
$C->escape
}))) {
scalar(do {
my $M = $C;
{
push @nibbles, $C->makestr(TEXT => $text, _from => $from, _pos => $to ) if $from != $to;
push @nibbles, $M->{'escape'}->[-1];
$text = '';
$to = $from = $C->{'_pos'};
}}, $C)
} else { () }

}
}
or $xact->[-2] or
do {
push @gather, do {
if (my ($C) = ($C->cursor_incr())) {
scalar(do {
{
my $ch = substr($::ORIG, $C->{'_pos'}-1, 1);
$text .= $ch;
$to = $C->{'_pos'};
if ($ch =~ "\n") {
$multiline++};
}}, $C)
} else { () }

}
};
@gather;
}
}))) {
$C
} else { () }
}))) { ($C) } else { () }
}))) {
scalar(do {
my $M = $C;
{
push @nibbles, $C->makestr(TEXT => $text, _from => $from, _pos => $to ) if $from != $to or !@nibbles;
$M->{'nibbles'} = \@nibbles;
$self->pos = $C->{'_pos'};
delete $M->{'nibbler'};
delete $M->{'escape'};
delete $M->{'starter'};
delete $M->{'stopper'};
$::LAST_NIBBLE = $C;
$::LAST_NIBBLE_MULTILINE = $C if $multiline;
}}, $C)
} else { () }

});
}
;
## token babble ($l) {
sub babble__PEEK { $_[0]->_AUTOLEXpeek('babble', $retree) }
sub babble {
no warnings 'recursion';
my $self = shift;

die 'Required argument l omitted' unless @_;
my $l = @_ ? shift() : undef;
my $lang = $l;my $start;my $stop;
local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;

my $C = $self->cursor_xact("RULE babble");
my $xact = $C->xact;
my $S = $C->{'_pos'};
$C->{'quotepair'} = [];
$self->_MATCHIFYr($S, "babble", do {
my $C = $C;
if (($C) = ($C->ws)
and ($C) = ($C->_STARr(sub {
my $C=shift;
if (my ($C) = ($C->_BRACKETr(sub {
my $C=shift;
if (($C) = ($C->_SUBSUMEr(['quotepair'], sub {
my $C = shift;
$C->quotepair
}))
and ($C) = ($C->ws)) {
scalar(do {
my $M = $C;
my $kv = $M->{'quotepair'}->[-1];
$lang = ($lang->tweak($kv->{'k'}, $kv->{'v'})
or $lang->sorry("Unrecognized adverb :" . $kv->{'k'} . '(' . $kv->{'v'} . ')'));
}, $C)
} else { () }
}))) { ($C) } else { () }
}))) {
scalar(do {
my $M = $C;
($start,$stop) = $C->peek_delimiters();
$lang = $start ne $stop ? $lang->balanced($start,$stop)
: $lang->unbalanced($stop);
$M->{'B'} = [$lang,$start,$stop];
}, $C)
} else { () }

});
}
;
our @herestub_queue;
{ package STD::Herestub;
use Moose ':all' => { -prefix => "moose_" };
use Encode;
our $ALLROLES = { 'STD::Herestub', 1 };
our $REGEXES = {
ALL => [ qw// ],
};


no warnings 'qw', 'recursion';
my $retree;

$DB::deep = $DB::deep = 1000; # suppress used-once warning

use YAML::XS;

$SIG{__WARN__} = sub { die @_,"   statement started at line ", 'Cursor'->lineof($::LASTSTATE), "
" } if $::DEBUG;

moose_has 'delim' => (isa => 'Str', is => 'rw');
moose_has 'orignode' => (is => 'rw');
moose_has 'lang' => (is => 'rw');
1; };
{ package STD::herestop;
use Moose::Role ':all' => { -prefix => "moose_" };
use Encode;
our $ALLROLES = { 'STD::herestop', 1 };
our $REGEXES = {
ALL => [ qw/stopper/ ],
};


no warnings 'qw', 'recursion';
my $retree;

$DB::deep = $DB::deep = 1000; # suppress used-once warning

use YAML::XS;

$SIG{__WARN__} = sub { die @_,"   statement started at line ", 'Cursor'->lineof($::LASTSTATE), "
" } if $::DEBUG;

$retree = YAML::XS::Load(Encode::encode_utf8(<<'RETREE_END'));
---
stopper: !!perl/hash:RE_ast
  dba: stopper
  dic: STD::herestop
  re: !!perl/hash:RE_sequence
    zyg:
    - !!perl/hash:RE_meta
      text: ^^
    - !!perl/hash:RE_block {}
    - !!perl/hash:RE_bindnamed
      atom: !!perl/hash:RE_paren
        re: !!perl/hash:RE_quantified_atom
          atom: !!perl/hash:RE_meta
            min: 1
            text: \h
          quant:
          - '*'
    - !!perl/hash:RE_var
      var: $::DELIM
    - !!perl/hash:RE_quantified_atom
      atom: !!perl/hash:RE_meta
        min: 1
        text: \h
      quant:
      - '*'
    - !!perl/hash:RE_quantified_atom
      atom: !!perl/hash:RE_method
        name: unv
        rest: ''
      quant:
      - '?'
    - !!perl/hash:RE_meta
      text: $$
    - !!perl/hash:RE_quantified_atom
      atom: !!perl/hash:RE_meta
        min: 1
        text: \v
      quant:
      - '?'
RETREE_END
## token stopper { ^^ {} $<ws>=(\h*?) $*DELIM \h* <.unv>?? $$ \v? }
sub stopper__PEEK { $_[0]->_AUTOLEXpeek('stopper', $retree) }
sub stopper {
no warnings 'recursion';
my $self = shift;


local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;

my $C = $self->cursor_xact("RULE stopper");
my $xact = $C->xact;
my $S = $C->{'_pos'};
$self->_MATCHIFYr($S, "stopper", do {
my $C = $C;
if (($C) = ($C->_PATTERN(qr/\G(?m:^)/))
and ($C) = (scalar(do {
}, $C))
and ($C) = ($C->_SUBSUMEr(['ws'], sub {
my $C = shift;
$C->_PAREN( sub {
my $C=shift;
$C->_STARf(sub {
my $C=shift;
$C->_PATTERN(qr/\G[\x20\t\r]/)
})

})
}))
and ($C) = ($C->_EXACT($::DELIM))
and ($C) = ($C->_PATTERN(qr/\G[\x20\t\r]*+/))) {
LazyMap::lazymap(sub {
my $C=shift;
$C->_PATTERN(qr/\G(?m:$)\n?+/)
},
$C->_OPTf(sub {
my $C=shift;
if (my ($C) = ($C->unv)) { ($C) } else { () }
}))
} else { () }

});
}
1; };
## method heredoc ()
sub heredoc {
no warnings 'recursion';
my $self = shift;
local $::CTX = $self->callm if $::DEBUG & DEBUG::trace_call;
my $here = $self;
while (my $herestub = shift @herestub_queue) {
local $::DELIM = $herestub->delim;
my $lang = $herestub->lang->mixin( 'STD::herestop' );
my $doc;
if (($doc) = $here->nibble($lang)) {
$here = $doc->trim_heredoc();
$herestub->orignode->{'doc'} = $doc;
}
else {
$self->panic("Ending delimiter $::DELIM not found")};
}
;
return $self->cursor($here->{'_pos'});
};
## token quibble ($l) {
sub quibble__PEEK { $_[0]->_AUTOLEXpeek('quibble', $retree) }
sub quibble {
no warnings 'recursion';
my $self = shift;

die 'Required argument l omitted' unless @_;
my $l = @_ ? shift() : undef;
my ($lang, $start, $stop);
local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;

my $C = $self->cursor_xact("RULE quibble");
my $xact = $C->xact;
my $S = $C->{'_pos'};
$self->_MATCHIFYr($S, "quibble", do {
my $C = $C;
if (($C) = ($C->_SUBSUMEr(['babble'], sub {
my $C = shift;
$C->babble($l)
}))
and ($C) = (scalar(do {
my $M = $C;
my $B = $M->{'babble'}->{'B'};
($lang,$start,$stop) = @$B;
}, $C))
and ($C) = ($C->_EXACT($start))
and ($C) = ($C->_SUBSUMEr(['nibble'], sub {
my $C = shift;
$C->nibble($lang)
}))
and ($C) = ($C->_BRACKETr(sub {
my $C=shift;
do {    my $C = $C->cursor_xact('ALT ||');
my $xact = $C->xact;
my @gather;
do {
push @gather, do {
if (my ($C) = ($C->_EXACT($stop))) { ($C) } else { () }

}
}
or $xact->[-2] or
do {
push @gather, do {
if (my ($C) = ($C->panic("Couldn't find terminator $stop"))) { ($C) } else { () }

}
};
@gather;
}
}))) {
scalar(do {
my $M = $C;
{
if ($lang->{'_herelang'}) {
push @herestub_queue,
'STD::Herestub'->new(
delim => $M->{'nibble'}->{'nibbles'}->[0]->{'TEXT'},
orignode => $C,
lang => $lang->{'_herelang'},
)}}}, $C)
} else { () }

});
}
;
## token quotepair {
sub quotepair__PEEK { $_[0]->_AUTOLEXpeek('quotepair', $retree) }
sub quotepair {
no warnings 'recursion';
my $self = shift;

my $key;my $value;
local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;

my $C = $self->cursor_xact("RULE quotepair");
my $xact = $C->xact;
my $S = $C->{'_pos'};
$C->{'circumfix'} = [];
$self->_MATCHIFYr($S, "quotepair", do {
my $C = $C;
if (($C) = ($C->_EXACT("\:"))
and ($C) = ($C->_BRACKETr(sub {
my $C=shift;
do {
my ($tag, $try);
my @try;
my $relex;

my $fate;
my $x;
if ($fate = $C->{'_fate'} and $fate->[1] eq 'quotepair_0') {
$C->deb("Fate passed to quotepair_0: ", ::fatestr($fate)) if $::DEBUG & DEBUG::fates;
($C->{'_fate'}, $tag, $try) = @$fate;
@try = ($try);
$x = 'ALT quotepair_0';    # some outer ltm is controlling us
}
else {
$x = 'ALTLTM quotepair_0'; # we are top level ltm
}
my $C = $C->cursor_xact($x);
my $xact = $C->{_xact};

my @gather = ();
for (;;) {
unless (@try) {
$relex //= $C->cursor_fate('STD', 'quotepair_0', $retree);
@try = $relex->($C) or last;
}
$try = shift(@try) // next;

if (ref $try) {
($C->{'_fate'}, $tag, $try) = @$try;   # next candidate fate
}

$C->deb("quotepair_0 trying $tag $try") if $::DEBUG & DEBUG::try_processing;
push @gather, ((
sub {
my $C=shift;
if (($C) = ($C->_EXACT("\!"))
and ($C) = ($C->_SUBSUMEr(['identifier'], sub {
my $C = shift;
$C->identifier
}))
and ($C) = ($C->_OPTr(sub {
my $C=shift;
if (my ($C) = ($C->_BRACKETr(sub {
my $C=shift;
if (($C) = ($C->before(sub {
my $C=shift;
if (my ($C) = ($C->before(sub {
my $C=shift;
$C->_EXACT("\(")
}))) { ($C) } else { () }
}))
and ($C) = ($C->sorry("Argument not allowed on negated pair"))) {
$C->_SUBSUMEr(['circumfix'], sub {
my $C = shift;
$C->circumfix
})
} else { () }
}))) { ($C) } else { () }
}))) {
scalar(do {
my $M = $C;
$key = $M->{'identifier'}->Str;
$value = 0;
}, $C)
} else { () }
},
sub {
my $C=shift;
if (($C) = ($C->_SUBSUMEr(['identifier'], sub {
my $C = shift;
$C->identifier
}))
and ($C) = (scalar(do {
my $M = $C;
$key = $M->{'identifier'}->Str}, $C))
and ($C) = ($C->_BRACKETr(sub {
my $C=shift;
do {    my $C = $C->cursor_xact('ALT ||');
my $xact = $C->xact;
my @gather;
do {
push @gather, do {
my $C = $C;
if (($C) = ($C->_OPTr(sub {
my $C=shift;
if (my ($C) = ($C->unsp)) { ($C) } else { () }
}))
and ($C) = ($C->before(sub {
my $C=shift;
if (my ($C) = ($C->before(sub {
my $C=shift;
$C->_EXACT("\(")
}))) { ($C) } else { () }
}))
and ($C) = ($C->_SUBSUMEr(['circumfix'], sub {
my $C = shift;
$C->circumfix
}))) {
scalar(do {
my $M = $C;
$value = $M->{'circumfix'}}, $C)
} else { () }

}
}
or $xact->[-2] or
do {
push @gather, scalar(do {
$value = 1}, $C)
};
@gather;
}
}))) {
$C
} else { () }
},
sub {
my $C=shift;
if (($C) = ($C->_SUBSUMEr(['n'], sub {
my $C = shift;
$C->_PAREN( sub {
my $C=shift;
$C->_PATTERN(qr/\G\d++/)

})
}))
and ($C) = ($C->_SUBSUMEr(['id'], sub {
my $C = shift;
$C->_PAREN( sub {
my $C=shift;
$C->_PATTERN(qr/\G(?:[a-z])++/)

})
}))
and ($C) = ($C->_OPTr(sub {
my $C=shift;
if (my ($C) = ($C->_BRACKETr(sub {
my $C=shift;
if (($C) = ($C->before(sub {
my $C=shift;
if (my ($C) = ($C->before(sub {
my $C=shift;
$C->_EXACT("\(")
}))) { ($C) } else { () }
}))
and ($C) = ($C->sorry("2nd argument not allowed on pair"))) {
$C->_SUBSUMEr(['circumfix'], sub {
my $C = shift;
$C->circumfix
})
} else { () }
}))) { ($C) } else { () }
}))) {
scalar(do {
my $M = $C;
$key = $M->{'id'}->Str;
$value = $M->{'n'}->Str;
}, $C)
} else { () }
}
)[$try])->($C);
last if @gather;
last if $xact->[-2];  # committed?
}
@gather;
};
}))) {
scalar(do {
my $M = $C;
$M->{'k'} = $key;
$M->{'v'} = $value;
}, $C)
} else { () }

});
}
;
## token quote:sym<' '>   { :dba('single quotes') "'" ~ "'" <nibble($¢.cursor_fresh( %*LANG<Q> ).tweak(
sub quote__S_049Single_Single__PEEK { $_[0]->_AUTOLEXpeek('quote__S_049Single_Single', $retree) }
sub quote__S_049Single_Single {
no warnings 'recursion';
my $self = shift;


local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;

my $C = $self->cursor_xact("RULE quote__S_049Single_Single");
my $xact = $C->xact;
my $S = $C->{'_pos'};
$C->{sym} = "\'\ \'";
$self->_MATCHIFYr($S, "quote__S_049Single_Single", $C->_BRACKETr(sub {
my $C=shift;
local $::GOAL = "\'";
my $goalpos = $C;
my $newlang = $C->unbalanced($::GOAL);
$C = bless($C, (ref($newlang) || $newlang));
if (($C) = ($C->_EXACT("\'"))
and ($C) = (scalar(do {
}, $C))
and ($C) = ($C->_SUBSUMEr(['nibble'], sub {
my $C = shift;
$C->nibble($C->cursor_fresh( $::LANG{'Q'} )->tweak('q' => 1)->unbalanced("'"))
}))
and ($C) = ($C->_BRACKETr(sub {
my $C=shift;
do {    my $C = $C->cursor_xact('ALT ||');
my $xact = $C->xact;
my @gather;
do {
push @gather, $C->_EXACT("\'")
}
or $xact->[-2] or
do {
push @gather, do {
if (my ($C) = ($C->FAILGOAL($::GOAL, 'single quotes', $goalpos))) { ($C) } else { () }

}
};
@gather;
}
}))) {
$C
} else { () }
}));
}
;
## token quote:sym<" ">   { :dba('double quotes') '"' ~ '"' <nibble($¢.cursor_fresh( %*LANG<Q> ).tweak(
sub quote__S_050Double_Double__PEEK { $_[0]->_AUTOLEXpeek('quote__S_050Double_Double', $retree) }
sub quote__S_050Double_Double {
no warnings 'recursion';
my $self = shift;


local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;

my $C = $self->cursor_xact("RULE quote__S_050Double_Double");
my $xact = $C->xact;
my $S = $C->{'_pos'};
$C->{sym} = "\"\ \"";
$self->_MATCHIFYr($S, "quote__S_050Double_Double", $C->_BRACKETr(sub {
my $C=shift;
local $::GOAL = "\"";
my $goalpos = $C;
my $newlang = $C->unbalanced($::GOAL);
$C = bless($C, (ref($newlang) || $newlang));
if (($C) = ($C->_EXACT("\""))
and ($C) = (scalar(do {
}, $C))
and ($C) = ($C->_SUBSUMEr(['nibble'], sub {
my $C = shift;
$C->nibble($C->cursor_fresh( $::LANG{'Q'} )->tweak('qq' => 1)->unbalanced('"'))
}))
and ($C) = ($C->_BRACKETr(sub {
my $C=shift;
do {    my $C = $C->cursor_xact('ALT ||');
my $xact = $C->xact;
my @gather;
do {
push @gather, $C->_EXACT("\"")
}
or $xact->[-2] or
do {
push @gather, do {
if (my ($C) = ($C->FAILGOAL($::GOAL, 'double quotes', $goalpos))) { ($C) } else { () }

}
};
@gather;
}
}))) {
$C
} else { () }
}));
}
;
## token circumfix:sym<« »>   { :dba('shell-quote words') '«' ~ '»' <nibble($¢.cursor_fresh( %*LANG<Q> 
sub circumfix__S_051Fre_Nch__PEEK { $_[0]->_AUTOLEXpeek('circumfix__S_051Fre_Nch', $retree) }
sub circumfix__S_051Fre_Nch {
no warnings 'recursion';
my $self = shift;


local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;

my $C = $self->cursor_xact("RULE circumfix__S_051Fre_Nch");
my $xact = $C->xact;
my $S = $C->{'_pos'};
$C->{sym} = "«\ »";
$self->_MATCHIFYr($S, "circumfix__S_051Fre_Nch", $C->_BRACKETr(sub {
my $C=shift;
local $::GOAL = "»";
my $goalpos = $C;
my $newlang = $C->unbalanced($::GOAL);
$C = bless($C, (ref($newlang) || $newlang));
if (($C) = ($C->_EXACT("«"))
and ($C) = (scalar(do {
}, $C))
and ($C) = ($C->_SUBSUMEr(['nibble'], sub {
my $C = shift;
$C->nibble($C->cursor_fresh( $::LANG{'Q'} )->tweak('qq' => 1)->tweak('ww' => 1)->balanced('«','»'))
}))
and ($C) = ($C->_BRACKETr(sub {
my $C=shift;
do {    my $C = $C->cursor_xact('ALT ||');
my $xact = $C->xact;
my @gather;
do {
push @gather, $C->_EXACT("»")
}
or $xact->[-2] or
do {
push @gather, do {
if (my ($C) = ($C->FAILGOAL($::GOAL, 'shell-quote words', $goalpos))) { ($C) } else { () }

}
};
@gather;
}
}))) {
$C
} else { () }
}));
}
;
## token circumfix:sym«<< >>» { :dba('shell-quote words') '<<' ~ '>>' <nibble($¢.cursor_fresh( %*LANG<Q
sub circumfix__S_052LtLt_GtGt__PEEK { $_[0]->_AUTOLEXpeek('circumfix__S_052LtLt_GtGt', $retree) }
sub circumfix__S_052LtLt_GtGt {
no warnings 'recursion';
my $self = shift;


local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;

my $C = $self->cursor_xact("RULE circumfix__S_052LtLt_GtGt");
my $xact = $C->xact;
my $S = $C->{'_pos'};
$C->{sym} = "\<\<\ \>\>";
$self->_MATCHIFYr($S, "circumfix__S_052LtLt_GtGt", $C->_BRACKETr(sub {
my $C=shift;
local $::GOAL = "\>\>";
my $goalpos = $C;
my $newlang = $C->unbalanced($::GOAL);
$C = bless($C, (ref($newlang) || $newlang));
if (($C) = ($C->_EXACT("\<\<"))
and ($C) = (scalar(do {
}, $C))
and ($C) = ($C->_SUBSUMEr(['nibble'], sub {
my $C = shift;
$C->nibble($C->cursor_fresh( $::LANG{'Q'} )->tweak('qq' => 1)->tweak('ww' => 1)->balanced('<<','>>'))
}))
and ($C) = ($C->_BRACKETr(sub {
my $C=shift;
do {    my $C = $C->cursor_xact('ALT ||');
my $xact = $C->xact;
my @gather;
do {
push @gather, $C->_EXACT("\>\>")
}
or $xact->[-2] or
do {
push @gather, do {
if (my ($C) = ($C->FAILGOAL($::GOAL, 'shell-quote words', $goalpos))) { ($C) } else { () }

}
};
@gather;
}
}))) {
$C
} else { () }
}));
}
;
## token circumfix:sym«< >»   { :dba('quote words') '<' ~ '>'
sub circumfix__S_053Lt_Gt__PEEK { $_[0]->_AUTOLEXpeek('circumfix__S_053Lt_Gt', $retree) }
sub circumfix__S_053Lt_Gt {
no warnings 'recursion';
my $self = shift;


local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;

my $C = $self->cursor_xact("RULE circumfix__S_053Lt_Gt");
my $xact = $C->xact;
my $S = $C->{'_pos'};
$C->{sym} = "\<\ \>";
$self->_MATCHIFYr($S, "circumfix__S_053Lt_Gt", $C->_BRACKETr(sub {
my $C=shift;
local $::GOAL = "\>";
my $goalpos = $C;
my $newlang = $C->unbalanced($::GOAL);
$C = bless($C, (ref($newlang) || $newlang));
if (($C) = ($C->_EXACT("\<"))
and ($C) = (scalar(do {
}, $C))
and ($C) = ($C->_BRACKETr(sub {
my $C=shift;
if (($C) = ($C->_OPTr(sub {
my $C=shift;
if (my ($C) = ($C->_BRACKETr(sub {
my $C=shift;
if (($C) = ($C->before(sub {
my $C=shift;
if (my ($C) = ($C->before(sub {
my $C=shift;
$C->_EXACT("STDIN\>")
}))) { ($C) } else { () }
}))
and ($C) = ($C->obs('<STDIN>', '$' . '*IN.lines'))) {
$C
} else { () }
}))) { ($C) } else { () }
}))
and ($C) = ($C->_OPTr(sub {
my $C=shift;
if (my ($C) = ($C->_BRACKETr(sub {
my $C=shift;
if (($C) = ($C->before(sub {
my $C=shift;
if (my ($C) = ($C->before(sub {
my $C=shift;
$C->_EXACT("\>")
}))) { ($C) } else { () }
}))
and ($C) = ($C->obs('<>', "lines() to read input,\n  or ('') to represent the null string,\n  or () to represent Nil"))) {
$C
} else { () }
}))) { ($C) } else { () }
}))) {
$C->_SUBSUMEr(['nibble'], sub {
my $C = shift;
$C->nibble($C->cursor_fresh( $::LANG{'Q'} )->tweak('q' => 1)->tweak('w' => 1)->balanced('<','>'))
})
} else { () }
}))
and ($C) = ($C->_BRACKETr(sub {
my $C=shift;
do {    my $C = $C->cursor_xact('ALT ||');
my $xact = $C->xact;
my @gather;
do {
push @gather, $C->_EXACT("\>")
}
or $xact->[-2] or
do {
push @gather, do {
if (my ($C) = ($C->FAILGOAL($::GOAL, 'quote words', $goalpos))) { ($C) } else { () }

}
};
@gather;
}
}))) {
$C
} else { () }
}));
}
;
## token ws {
sub ws__PEEK { $_[0]->_AUTOLEXpeek('ws', $retree) }
sub ws {
no warnings 'recursion';
my $self = shift;

local $::STUB = $::STUB = return $self if exists $::MEMOS[$self->{'_pos'}]->{'ws'};my $startpos = $self->{'_pos'};local $::HIGHEXPECT = {
};
local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;

my $C = $self->cursor_xact("RULE ws");
my $xact = $C->xact;
my $S = $C->{'_pos'};
$self->_MATCHIFYr($S, "ws", do {    my $C = $C->cursor_xact('ALT ||');
my $xact = $C->xact;
my @gather;
do {
push @gather, do {
if (my ($C) = ($C->_BRACKETr(sub {
my $C=shift;
do {
my ($tag, $try);
my @try;
my $relex;

my $fate;
my $x;
if ($fate = $C->{'_fate'} and $fate->[1] eq 'ws_0') {
$C->deb("Fate passed to ws_0: ", ::fatestr($fate)) if $::DEBUG & DEBUG::fates;
($C->{'_fate'}, $tag, $try) = @$fate;
@try = ($try);
$x = 'ALT ws_0';    # some outer ltm is controlling us
}
else {
$x = 'ALTLTM ws_0'; # we are top level ltm
}
my $C = $C->cursor_xact($x);
my $xact = $C->{_xact};

my @gather = ();
for (;;) {
unless (@try) {
$relex //= $C->cursor_fate('STD', 'ws_0', $retree);
@try = $relex->($C) or last;
}
$try = shift(@try) // next;

if (ref $try) {
($C->{'_fate'}, $tag, $try) = @$try;   # next candidate fate
}

$C->deb("ws_0 trying $tag $try") if $::DEBUG & DEBUG::try_processing;
push @gather, ((
sub {
my $C=shift;
if (($C) = ($C->_PATTERN(qr/\G[\x20\t\r]++/))
and ($C) = ($C->_NOTBEFORE(sub {
my $C=shift;
$C->_PATTERN(qr/\G[\#\s\\]/)
}))) {
scalar(do {
$::MEMOS[$C->{'_pos'}]->{'ws'} = $startpos}, $C)
} else { () }
},
sub {
my $C=shift;
if (($C) = ($C->before(sub {
my $C=shift;
if (my ($C) = ($C->before(sub {
my $C=shift;
$C->_PATTERN(qr/\G\w/)
}))) { ($C) } else { () }
}))
and ($C) = ($C->before(sub {
my $C=shift;
if (my ($C) = ($C->after(sub {
my $C=shift;
$C->_PATTERN(qr/\G(?<=\w)/)
}))) { ($C) } else { () }
}))
and ($C) = ($C->_COMMITRULE())
and ($C) = (scalar(do {
delete $::MEMOS[$startpos]->{'ws'}}, $C))
and ($C) = ($C->sorry("Whitespace is required between alphanumeric tokens"))) {
$C
} else { () }
}
)[$try])->($C);
last if @gather;
last if $xact->[-2];  # committed?
}
@gather;
};
}))) { ($C) } else { () }

}
}
or $xact->[-2] or
do {
push @gather, do {
if (my ($C) = ($C->_STARr(sub {
my $C=shift;
if (my ($C) = ($C->_BRACKETr(sub {
my $C=shift;
do {
my ($tag, $try);
my @try;
my $relex;

my $fate;
my $x;
if ($fate = $C->{'_fate'} and $fate->[1] eq 'ws_1') {
$C->deb("Fate passed to ws_1: ", ::fatestr($fate)) if $::DEBUG & DEBUG::fates;
($C->{'_fate'}, $tag, $try) = @$fate;
@try = ($try);
$x = 'ALT ws_1';    # some outer ltm is controlling us
}
else {
$x = 'ALTLTM ws_1'; # we are top level ltm
}
my $C = $C->cursor_xact($x);
my $xact = $C->{_xact};

my @gather = ();
for (;;) {
unless (@try) {
$relex //= $C->cursor_fate('STD', 'ws_1', $retree);
@try = $relex->($C) or last;
}
$try = shift(@try) // next;

if (ref $try) {
($C->{'_fate'}, $tag, $try) = @$try;   # next candidate fate
}

$C->deb("ws_1 trying $tag $try") if $::DEBUG & DEBUG::try_processing;
push @gather, ((
sub {
my $C=shift;
if (my ($C) = ($C->unsp)) { ($C) } else { () }
},
sub {
my $C=shift;
if (($C) = ($C->vws)
and ($C) = ($C->heredoc)) {
$C
} else { () }
},
sub {
my $C=shift;
if (my ($C) = ($C->unv)) { ($C) } else { () }
},
sub {
my $C=shift;
if (my ($C) = ($C->_PATTERN(qr/\G\z/))) {
scalar(do {
$C->moreinput }, $C)
} else { () }
}
)[$try])->($C);
last if @gather;
last if $xact->[-2];  # committed?
}
@gather;
};
}))) { ($C) } else { () }
}))) {
scalar(do {
{
if (($C->{'_pos'} == $startpos)) {
delete $::MEMOS[$C->{'_pos'}]->{'ws'}}
else {
$::MEMOS[$C->{'_pos'}]->{'ws'} = $startpos;
$::MEMOS[$C->{'_pos'}]->{'endstmt'} = $::MEMOS[$startpos]->{'endstmt'}
if exists $::MEMOS[$startpos]->{'endstmt'};
}}}, $C)
} else { () }

}
};
@gather;
});
}
;
## token unsp {
sub unsp__PEEK { $_[0]->_AUTOLEXpeek('unsp', $retree) }
sub unsp {
no warnings 'recursion';
my $self = shift;


local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;

my $C = $self->cursor_xact("RULE unsp");
my $xact = $C->xact;
my $S = $C->{'_pos'};
$self->_MATCHIFYr($S, "unsp", do {
my $C = $C;
if (($C) = ($C->_EXACT("\\"))
and ($C) = ($C->before(sub {
my $C=shift;
if (my ($C) = ($C->before(sub {
my $C=shift;
if (my ($C) = ($C->_BRACKETr(sub {
my $C=shift;
do {
my ($tag, $try);
my @try;
my $relex;

my $fate;
my $x;
if ($fate = $C->{'_fate'} and $fate->[1] eq 'unsp_0') {
$C->deb("Fate passed to unsp_0: ", ::fatestr($fate)) if $::DEBUG & DEBUG::fates;
($C->{'_fate'}, $tag, $try) = @$fate;
@try = ($try);
$x = 'ALT unsp_0';    # some outer ltm is controlling us
}
else {
$x = 'ALTLTM unsp_0'; # we are top level ltm
}
my $C = $C->cursor_xact($x);
my $xact = $C->{_xact};

my @gather = ();
for (;;) {
unless (@try) {
$relex //= $C->cursor_fate('STD', 'unsp_0', $retree);
@try = $relex->($C) or last;
}
$try = shift(@try) // next;

if (ref $try) {
($C->{'_fate'}, $tag, $try) = @$try;   # next candidate fate
}

$C->deb("unsp_0 trying $tag $try") if $::DEBUG & DEBUG::try_processing;
push @gather, ((
sub {
my $C=shift;
$C->_PATTERN(qr/\G\s/)
},
sub {
my $C=shift;
$C->_EXACT("\#")
}
)[$try])->($C);
last if @gather;
last if $xact->[-2];  # committed?
}
@gather;
};
}))) { ($C) } else { () }
}))) { ($C) } else { () }
}))) {
$C->_STARr(sub {
my $C=shift;
if (my ($C) = ($C->_BRACKETr(sub {
my $C=shift;
do {
my ($tag, $try);
my @try;
my $relex;

my $fate;
my $x;
if ($fate = $C->{'_fate'} and $fate->[1] eq 'unsp_1') {
$C->deb("Fate passed to unsp_1: ", ::fatestr($fate)) if $::DEBUG & DEBUG::fates;
($C->{'_fate'}, $tag, $try) = @$fate;
@try = ($try);
$x = 'ALT unsp_1';    # some outer ltm is controlling us
}
else {
$x = 'ALTLTM unsp_1'; # we are top level ltm
}
my $C = $C->cursor_xact($x);
my $xact = $C->{_xact};

my @gather = ();
for (;;) {
unless (@try) {
$relex //= $C->cursor_fate('STD', 'unsp_1', $retree);
@try = $relex->($C) or last;
}
$try = shift(@try) // next;

if (ref $try) {
($C->{'_fate'}, $tag, $try) = @$try;   # next candidate fate
}

$C->deb("unsp_1 trying $tag $try") if $::DEBUG & DEBUG::try_processing;
push @gather, ((
sub {
my $C=shift;
if (my ($C) = ($C->vws)) { ($C) } else { () }
},
sub {
my $C=shift;
if (my ($C) = ($C->unv)) { ($C) } else { () }
},
sub {
my $C=shift;
if (my ($C) = ($C->_PATTERN(qr/\G\z/))) {
scalar(do {
$C->moreinput }, $C)
} else { () }
}
)[$try])->($C);
last if @gather;
last if $xact->[-2];  # committed?
}
@gather;
};
}))) { ($C) } else { () }
})
} else { () }

});
}
;
## token vws {
sub vws__PEEK { $_[0]->_AUTOLEXpeek('vws', $retree) }
sub vws {
no warnings 'recursion';
my $self = shift;


local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;

my $C = $self->cursor_xact("RULE vws");
my $xact = $C->xact;
my $S = $C->{'_pos'};
$self->_MATCHIFYr($S, "vws", $C->_PLUSr(sub {
my $C=shift;
if (my ($C) = ($C->_BRACKETr(sub {
my $C=shift;
$C->_BRACKETr(sub {
my $C=shift;
do {
my ($tag, $try);
my @try;
my $relex;

my $fate;
my $x;
if ($fate = $C->{'_fate'} and $fate->[1] eq 'vws_0') {
$C->deb("Fate passed to vws_0: ", ::fatestr($fate)) if $::DEBUG & DEBUG::fates;
($C->{'_fate'}, $tag, $try) = @$fate;
@try = ($try);
$x = 'ALT vws_0';    # some outer ltm is controlling us
}
else {
$x = 'ALTLTM vws_0'; # we are top level ltm
}
my $C = $C->cursor_xact($x);
my $xact = $C->{_xact};

my @gather = ();
for (;;) {
unless (@try) {
$relex //= $C->cursor_fate('STD', 'vws_0', $retree);
@try = $relex->($C) or last;
}
$try = shift(@try) // next;

if (ref $try) {
($C->{'_fate'}, $tag, $try) = @$try;   # next candidate fate
}

$C->deb("vws_0 trying $tag $try") if $::DEBUG & DEBUG::try_processing;
push @gather, ((
sub {
my $C=shift;
$C->_PATTERN(qr/\G\n/)
},
sub {
my $C=shift;
if (($C) = ($C->_EXACT("\#DEBUG\ \-1"))
and ($C) = (scalar(do {
say "DEBUG";
$::DEBUG = -1;
}, $C))) {
$C->_PATTERN(qr/\G[^\n]*+\n/)
} else { () }
},
sub {
my $C=shift;
if (($C) = ($C->_EXACT("\<\<\<\<\<\<\<"))
and ($C) = ($C->_COMMITLTM())
and ($C) = ($C->before(sub {
my $C=shift;
if (my ($C) = ($C->before(sub {
my $C=shift;
if (my ($C) = (do {
if (my ($C) = ($C->_BRACKETr(sub {
my $C=shift;
LazyMap::lazymap(sub {
my $C=shift;
$C->_PATTERN(qr/\G\n\=\=\=\=\=\=\=/)
},
$C->_SCANf())
}))) {
LazyMap::lazymap(sub {
my $C=shift;
$C->_PATTERN(qr/\G\n\>\>\>\>\>\>\>/)
},
$C->_SCANf())
} else { () }

})) { ($C) } else { () }
}))) { ($C) } else { () }
}))
and ($C) = ($C->sorry('Found a version control conflict marker'))) {
$C->_PATTERN(qr/\G[^\n]*+\n/)
} else { () }
},
sub {
my $C=shift;
if (my ($C) = (do {
my $C = $C;
if (($C) = ($C->_EXACT("\=\=\=\=\=\=\="))
and ($C) = ($C->_COMMITLTM())) {
LazyMap::lazymap(sub {
my $C=shift;
$C->_PATTERN(qr/\G\n\>\>\>\>\>\>\>[^\n]*+\n/)
},
$C->_SCANf())
} else { () }

})) { ($C) } else { () }
}
)[$try])->($C);
last if @gather;
last if $xact->[-2];  # committed?
}
@gather;
};
})
}))) { ($C) } else { () }
}));
}
;
## method moreinput ()
sub moreinput {
no warnings 'recursion';
my $self = shift;
$::moreinput->() if $::moreinput;
$self;
};
## token unv {
sub unv__PEEK { $_[0]->_AUTOLEXpeek('unv', $retree) }
sub unv {
no warnings 'recursion';
my $self = shift;


local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;

my $C = $self->cursor_xact("RULE unv");
my $xact = $C->xact;
my $S = $C->{'_pos'};
$self->_MATCHIFYr($S, "unv", $C->_BRACKETr(sub {
my $C=shift;
do {
my ($tag, $try);
my @try;
my $relex;

my $fate;
my $x;
if ($fate = $C->{'_fate'} and $fate->[1] eq 'unv_0') {
$C->deb("Fate passed to unv_0: ", ::fatestr($fate)) if $::DEBUG & DEBUG::fates;
($C->{'_fate'}, $tag, $try) = @$fate;
@try = ($try);
$x = 'ALT unv_0';    # some outer ltm is controlling us
}
else {
$x = 'ALTLTM unv_0'; # we are top level ltm
}
my $C = $C->cursor_xact($x);
my $xact = $C->{_xact};

my @gather = ();
for (;;) {
unless (@try) {
$relex //= $C->cursor_fate('STD', 'unv_0', $retree);
@try = $relex->($C) or last;
}
$try = shift(@try) // next;

if (ref $try) {
($C->{'_fate'}, $tag, $try) = @$try;   # next candidate fate
}

$C->deb("unv_0 trying $tag $try") if $::DEBUG & DEBUG::try_processing;
push @gather, ((
sub {
my $C=shift;
$C->_PATTERN(qr/\G[\x20\t\r]++/)
},
sub {
my $C=shift;
if (($C) = ($C->before(sub {
my $C=shift;
if (my ($C) = ($C->before(sub {
my $C=shift;
do {
my $C = $C;
if (($C) = ($C->_PATTERN(qr/\G[\x20\t\r]*+\=/))
and ($C) = ($C->_BRACKETr(sub {
my $C=shift;
do {
my ($tag, $try);
my @try;
my $relex;

my $fate;
my $x;
if ($fate = $C->{'_fate'} and $fate->[1] eq 'unv_1') {
$C->deb("Fate passed to unv_1: ", ::fatestr($fate)) if $::DEBUG & DEBUG::fates;
($C->{'_fate'}, $tag, $try) = @$fate;
@try = ($try);
$x = 'ALT unv_1';    # some outer ltm is controlling us
}
else {
$x = 'ALTLTM unv_1'; # we are top level ltm
}
my $C = $C->cursor_xact($x);
my $xact = $C->{_xact};

my @gather = ();
for (;;) {
unless (@try) {
$relex //= $C->cursor_fate('STD', 'unv_1', $retree);
@try = $relex->($C) or last;
}
$try = shift(@try) // next;

if (ref $try) {
($C->{'_fate'}, $tag, $try) = @$try;   # next candidate fate
}

$C->deb("unv_1 trying $tag $try") if $::DEBUG & DEBUG::try_processing;
push @gather, ((
sub {
my $C=shift;
$C->_PATTERN(qr/\G\w/)
},
sub {
my $C=shift;
$C->_EXACT("\\")
}
)[$try])->($C);
last if @gather;
last if $xact->[-2];  # committed?
}
@gather;
};
}))) {
$C
} else { () }
};
}))) { ($C) } else { () }
}))
and ($C) = ($C->_PATTERN(qr/\G(?m:^)/))
and ($C) = ($C->pod_comment)) {
$C
} else { () }
},
sub {
my $C=shift;
if (my ($C) = ($C->_PATTERN(qr/\G[\x20\t\r]*+/))) {
$C->_SUBSUMEr(['comment'], sub {
my $C = shift;
$C->comment
})
} else { () }
}
)[$try])->($C);
last if @gather;
last if $xact->[-2];  # committed?
}
@gather;
};
}));
}
;
## token comment:sym<#`(...)> {
sub comment__S_054SharpGraveParenDotDotDotThesis__PEEK { $_[0]->_AUTOLEXpeek('comment__S_054SharpGraveParenDotDotDotThesis', $retree) }
sub comment__S_054SharpGraveParenDotDotDotThesis {
no warnings 'recursion';
my $self = shift;


local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;

my $C = $self->cursor_xact("RULE comment__S_054SharpGraveParenDotDotDotThesis");
my $xact = $C->xact;
my $S = $C->{'_pos'};
$C->{sym} = "\#\`\(\.\.\.\)";
$self->_MATCHIFYr($S, "comment__S_054SharpGraveParenDotDotDotThesis", do {
my $C = $C;
if (($C) = ($C->_EXACT("\#\`"))
and ($C) = ($C->_COMMITLTM())
and ($C) = ($C->_BRACKETr(sub {
my $C=shift;
do {    my $C = $C->cursor_xact('ALT ||');
my $xact = $C->xact;
my @gather;
do {
push @gather, do {
if (my ($C) = ($C->before(sub {
my $C=shift;
if (my ($C) = ($C->opener)) { ($C) } else { () }
}))) { ($C) } else { () }

}
}
or $xact->[-2] or
do {
push @gather, do {
if (my ($C) = ($C->panic("Opening bracket is required for #` comment"))) { ($C) } else { () }

}
};
@gather;
}
}))
and ($C) = ($C->quibble($C->cursor_fresh( $::LANG{'Q'} )))) {
$C
} else { () }

});
}
;
## token comment:sym<#(...)> {
sub comment__S_055SharpParenDotDotDotThesis__PEEK { $_[0]->_AUTOLEXpeek('comment__S_055SharpParenDotDotDotThesis', $retree) }
sub comment__S_055SharpParenDotDotDotThesis {
no warnings 'recursion';
my $self = shift;


local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;

my $C = $self->cursor_xact("RULE comment__S_055SharpParenDotDotDotThesis");
my $xact = $C->xact;
my $S = $C->{'_pos'};
$C->{sym} = "\#\(\.\.\.\)";
$self->_MATCHIFYr($S, "comment__S_055SharpParenDotDotDotThesis", do {
my $C = $C;
if (($C) = ($C->_EXACT("\#"))
and ($C) = ($C->before(sub {
my $C=shift;
if (my ($C) = ($C->opener)) { ($C) } else { () }
}))
and ($C) = ($C->suppose(sub {
my $C=shift;
do {
my $C = $C;
if (($C) = ($C->_SUBSUMEr(['quibble'], sub {
my $C = shift;
$C->quibble($C->cursor_fresh( $::LANG{'Q'} ))
}))
and ($C) = ($C->_NOTBEFORE(sub {
my $C=shift;
if (my ($C) = ($C->before(sub {
my $C=shift;
do {
my $C = $C;
if (($C) = ($C->_PATTERN(qr/\G(?:[,;:])*+[\x20\t\r]*+/))
and ($C) = ($C->_BRACKETr(sub {
my $C=shift;
do {
my ($tag, $try);
my @try;
my $relex;

my $fate;
my $x;
if ($fate = $C->{'_fate'} and $fate->[1] eq 'comment__S_055SharpParenDotDotDotThesis_0') {
$C->deb("Fate passed to comment__S_055SharpParenDotDotDotThesis_0: ", ::fatestr($fate)) if $::DEBUG & DEBUG::fates;
($C->{'_fate'}, $tag, $try) = @$fate;
@try = ($try);
$x = 'ALT comment__S_055SharpParenDotDotDotThesis_0';    # some outer ltm is controlling us
}
else {
$x = 'ALTLTM comment__S_055SharpParenDotDotDotThesis_0'; # we are top level ltm
}
my $C = $C->cursor_xact($x);
my $xact = $C->{_xact};

my @gather = ();
for (;;) {
unless (@try) {
$relex //= $C->cursor_fate('STD', 'comment__S_055SharpParenDotDotDotThesis_0', $retree);
@try = $relex->($C) or last;
}
$try = shift(@try) // next;

if (ref $try) {
($C->{'_fate'}, $tag, $try) = @$try;   # next candidate fate
}

$C->deb("comment__S_055SharpParenDotDotDotThesis_0 trying $tag $try") if $::DEBUG & DEBUG::try_processing;
push @gather, ((
sub {
my $C=shift;
$C->_EXACT("\#")
},
sub {
my $C=shift;
$C->_PATTERN(qr/\G(?m:$)/)
}
)[$try])->($C);
last if @gather;
last if $xact->[-2];  # committed?
}
@gather;
};
}))) {
$C
} else { () }
};
}))) { ($C) } else { () }
}))) {
$C
} else { () }
};
}))
and ($C) = ($C->worry("Embedded comment seems to be missing backtick"))
and ($C) = ($C->_NOTBEFORE(sub {
my $C=shift;
$C
}))) {
$C
} else { () }

});
}
;
## token comment:sym<#=(...)> {
sub comment__S_056SharpEqualParenDotDotDotThesis__PEEK { $_[0]->_AUTOLEXpeek('comment__S_056SharpEqualParenDotDotDotThesis', $retree) }
sub comment__S_056SharpEqualParenDotDotDotThesis {
no warnings 'recursion';
my $self = shift;


local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;

my $C = $self->cursor_xact("RULE comment__S_056SharpEqualParenDotDotDotThesis");
my $xact = $C->xact;
my $S = $C->{'_pos'};
$C->{sym} = "\#\=\(\.\.\.\)";
$self->_MATCHIFYr($S, "comment__S_056SharpEqualParenDotDotDotThesis", do {
my $C = $C;
if (($C) = ($C->_EXACT("\#\="))
and ($C) = ($C->before(sub {
my $C=shift;
if (my ($C) = ($C->opener)) { ($C) } else { () }
}))
and ($C) = ($C->_COMMITLTM())) {
$C->_SUBSUMEr(['quibble'], sub {
my $C = shift;
$C->quibble($C->cursor_fresh( $::LANG{'Q'} ))
})
} else { () }

});
}
;
## token comment:sym<#=> {
sub comment__S_057SharpEqual__PEEK { $_[0]->_AUTOLEXpeek('comment__S_057SharpEqual', $retree) }
sub comment__S_057SharpEqual {
no warnings 'recursion';
my $self = shift;


local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;

my $C = $self->cursor_xact("RULE comment__S_057SharpEqual");
my $xact = $C->xact;
my $S = $C->{'_pos'};
$C->{sym} = "\#\=";
$self->_MATCHIFYr($S, "comment__S_057SharpEqual", do {
my $C = $C;
if (($C) = ($C->_EXACT("\#\="))
and ($C) = ($C->_COMMITLTM())) {
$C->_SUBSUMEr(['attachment'], sub {
my $C = shift;
$C->_BRACKETr(sub {
my $C=shift;
$C->_STARr(sub {
my $C=shift;
$C->_NOTCHAR( sub { my $C=shift;
$C->_EXACT("\n")
})
})
})
})
} else { () }

});
}
;
## token comment:sym<#> {
sub comment__S_058Sharp__PEEK { $_[0]->_AUTOLEXpeek('comment__S_058Sharp', $retree) }
sub comment__S_058Sharp {
no warnings 'recursion';
my $self = shift;


local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;

my $C = $self->cursor_xact("RULE comment__S_058Sharp");
my $xact = $C->xact;
my $S = $C->{'_pos'};
$C->{sym} = "\#";
$self->_MATCHIFYr($S, "comment__S_058Sharp", do {
my $C = $C;
if (($C) = ($C->_EXACT("\#"))
and ($C) = (scalar(do {
}, $C))) {
$C->_STARr(sub {
my $C=shift;
$C->_NOTCHAR( sub { my $C=shift;
$C->_EXACT("\n")
})
})
} else { () }

});
}
;
## token ident {
sub ident__PEEK { $_[0]->_AUTOLEXpeek('ident', $retree) }
sub ident {
no warnings 'recursion';
my $self = shift;


local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;

my $C = $self->cursor_xact("RULE ident");
my $xact = $C->xact;
my $S = $C->{'_pos'};
$self->_MATCHIFYr($S, "ident", $C->_PATTERN(qr/\G[_[:alpha:]]\w*+/));
}
;
## token apostrophe {
sub apostrophe__PEEK { $_[0]->_AUTOLEXpeek('apostrophe', $retree) }
sub apostrophe {
no warnings 'recursion';
my $self = shift;


local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;

my $C = $self->cursor_xact("RULE apostrophe");
my $xact = $C->xact;
my $S = $C->{'_pos'};
$self->_MATCHIFYr($S, "apostrophe", $C->_PATTERN(qr/\G['\-]/));
}
;
## token identifier {
sub identifier__PEEK { $_[0]->_AUTOLEXpeek('identifier', $retree) }
sub identifier {
no warnings 'recursion';
my $self = shift;


local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;

my $C = $self->cursor_xact("RULE identifier");
my $xact = $C->xact;
my $S = $C->{'_pos'};
$self->_MATCHIFYr($S, "identifier", do {
if (my ($C) = ($C->ident)) {
$C->_STARr(sub {
my $C=shift;
if (my ($C) = ($C->_BRACKETr(sub {
my $C=shift;
if (($C) = ($C->apostrophe)
and ($C) = ($C->ident)) {
$C
} else { () }
}))) { ($C) } else { () }
})
} else { () }

});
}
;
## token pod_comment {
sub pod_comment__PEEK { $_[0]->_AUTOLEXpeek('pod_comment', $retree) }
sub pod_comment {
no warnings 'recursion';
my $self = shift;


local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;

my $C = $self->cursor_xact("RULE pod_comment");
my $xact = $C->xact;
my $S = $C->{'_pos'};
$self->_MATCHIFYr($S, "pod_comment", do {
my $C = $C;
if (($C) = ($C->_PATTERN(qr/\G(?m:^)[\x20\t\r]*+\=/))
and ($C) = ($C->_OPTr(sub {
my $C=shift;
if (my ($C) = ($C->unsp)) { ($C) } else { () }
}))
and ($C) = ($C->_BRACKETr(sub {
my $C=shift;
do {
my ($tag, $try);
my @try;
my $relex;

my $fate;
my $x;
if ($fate = $C->{'_fate'} and $fate->[1] eq 'pod_comment_0') {
$C->deb("Fate passed to pod_comment_0: ", ::fatestr($fate)) if $::DEBUG & DEBUG::fates;
($C->{'_fate'}, $tag, $try) = @$fate;
@try = ($try);
$x = 'ALT pod_comment_0';    # some outer ltm is controlling us
}
else {
$x = 'ALTLTM pod_comment_0'; # we are top level ltm
}
my $C = $C->cursor_xact($x);
my $xact = $C->{_xact};

my @gather = ();
for (;;) {
unless (@try) {
$relex //= $C->cursor_fate('STD', 'pod_comment_0', $retree);
@try = $relex->($C) or last;
}
$try = shift(@try) // next;

if (ref $try) {
($C->{'_fate'}, $tag, $try) = @$try;   # next candidate fate
}

$C->deb("pod_comment_0 trying $tag $try") if $::DEBUG & DEBUG::try_processing;
push @gather, ((
sub {
my $C=shift;
if (($C) = ($C->_PATTERN(qr/\Gbegin[\x20\t\r]++/))
and ($C) = ($C->_SUBSUMEr(['identifier'], sub {
my $C = shift;
$C->identifier
}))
and ($C) = ($C->_COMMITLTM())
and ($C) = ($C->_BRACKETr(sub {
my $C=shift;
do {    my $C = $C->cursor_xact('ALT ||');
my $xact = $C->xact;
my @gather;
do {
push @gather, do {
if (my ($C) = (LazyMap::lazymap(sub {
my $C=shift;
if (($C) = ($C->_EXACT("\n"))
and ($C) = ($C->_BRACKETr(sub {
my $C=shift;
if (($C) = ($C->_PATTERN(qr/\G[\x20\t\r]*+\=/))
and ($C) = ($C->_OPTr(sub {
my $C=shift;
if (my ($C) = ($C->unsp)) { ($C) } else { () }
}))
and ($C) = ($C->_PATTERN(qr/\Gend[\x20\t\r]++/))
and ($C) = ($C->_BACKREFn('identifier'))
and ($C) = ($C->_PATTERN(qr/\G\b/))) {
$C->_STARr(sub {
my $C=shift;
$C->_NOTCHAR( sub { my $C=shift;
$C->_EXACT("\n")
})
})
} else { () }
}))) {
$C
} else { () }
},
$C->_SCANf()))) { ($C) } else { () }

}
}
or $xact->[-2] or
do {
push @gather, do {
if (my ($C) = ($C->before(sub {
my $C=shift;
(($C) x !!do {
my $M = $C;
$M->{'identifier'}->Str eq 'END'})
}))) {
$C->_STARr(sub {
my $C=shift;
$C->cursor_incr()
})
} else { () }

}
}
or $xact->[-2] or
do {
push @gather, scalar(do {
my $M = $C;
my $id = $M->{'identifier'}->Str;
$self->panic("=begin $id without matching =end $id");
}, $C)
};
@gather;
}
}))) {
$C
} else { () }
},
sub {
my $C=shift;
if (($C) = ($C->_PATTERN(qr/\Gbegin\b/))
and ($C) = ($C->_COMMITLTM())
and ($C) = ($C->_PATTERN(qr/\G[\x20\t\r]*+/))
and ($C) = ($C->_BRACKETr(sub {
my $C=shift;
do {    my $C = $C->cursor_xact('ALT ||');
my $xact = $C->xact;
my @gather;
do {
push @gather, $C->_PATTERN(qr/\G(?m:$)/)
}
or $xact->[-2] or
do {
push @gather, $C->_EXACT("\#")
}
or $xact->[-2] or
do {
push @gather, do {
if (my ($C) = ($C->sorry("Unrecognized token after =begin"))) {
$C->_STARr(sub {
my $C=shift;
$C->_NOTCHAR( sub { my $C=shift;
$C->_EXACT("\n")
})
})
} else { () }

}
};
@gather;
}
}))
and ($C) = ($C->_BRACKETr(sub {
my $C=shift;
do {    my $C = $C->cursor_xact('ALT ||');
my $xact = $C->xact;
my @gather;
do {
push @gather, do {
if (my ($C) = (LazyMap::lazymap(sub {
my $C=shift;
if (($C) = ($C->_EXACT("\n"))
and ($C) = ($C->_PATTERN(qr/\G[\x20\t\r]*+\=/))
and ($C) = ($C->_OPTr(sub {
my $C=shift;
if (my ($C) = ($C->unsp)) { ($C) } else { () }
}))
and ($C) = ($C->_PATTERN(qr/\Gend\b/))) {
$C->_STARr(sub {
my $C=shift;
$C->_NOTCHAR( sub { my $C=shift;
$C->_EXACT("\n")
})
})
} else { () }
},
$C->_SCANf()))) { ($C) } else { () }

}
}
or $xact->[-2] or
do {
push @gather, scalar(do {
$self->panic("=begin without matching =end")}, $C)
};
@gather;
}
}))) {
$C
} else { () }
},
sub {
my $C=shift;
if (($C) = ($C->_PATTERN(qr/\Gfor\b/))
and ($C) = ($C->_COMMITLTM())
and ($C) = ($C->_PATTERN(qr/\G[\x20\t\r]*+/))
and ($C) = ($C->_BRACKETr(sub {
my $C=shift;
do {    my $C = $C->cursor_xact('ALT ||');
my $xact = $C->xact;
my @gather;
do {
push @gather, $C->_SUBSUMEr(['identifier'], sub {
my $C = shift;
$C->identifier
})
}
or $xact->[-2] or
do {
push @gather, $C->_PATTERN(qr/\G(?m:$)/)
}
or $xact->[-2] or
do {
push @gather, $C->_EXACT("\#")
}
or $xact->[-2] or
do {
push @gather, do {
if (my ($C) = ($C->sorry("Unrecognized token after =for"))) {
$C->_STARr(sub {
my $C=shift;
$C->_NOTCHAR( sub { my $C=shift;
$C->_EXACT("\n")
})
})
} else { () }

}
};
@gather;
}
}))
and ($C) = ($C->_BRACKETr(sub {
my $C=shift;
do {    my $C = $C->cursor_xact('ALT ||');
my $xact = $C->xact;
my @gather;
do {
push @gather, do {
if (my ($C) = (LazyMap::lazymap(sub {
my $C=shift;
$C->_PATTERN(qr/\G(?m:^)[\x20\t\r]*+(?m:$)/)
},
$C->_SCANf()))) { ($C) } else { () }

}
}
or $xact->[-2] or
do {
push @gather, $C->_STARr(sub {
my $C=shift;
$C->cursor_incr()
})
};
@gather;
}
}))) {
$C
} else { () }
},
sub {
my $C=shift;
if (($C) = ($C->_COMMITLTM())
and ($C) = ($C->_OPTr(sub {
my $C=shift;
if (my ($C) = ($C->_BRACKETr(sub {
my $C=shift;
if (($C) = ($C->before(sub {
my $C=shift;
if (my ($C) = ($C->before(sub {
my $C=shift;
if (my ($C) = (LazyMap::lazymap(sub {
my $C=shift;
$C->_PATTERN(qr/\G(?m:^)\=cut\b/)
},
$C->_SCANf()))) { ($C) } else { () }
}))) { ($C) } else { () }
}))
and ($C) = ($C->panic("Obsolescent pod format, please use =begin/=end instead"))) {
$C
} else { () }
}))) { ($C) } else { () }
}))
and ($C) = ($C->_BRACKETr(sub {
my $C=shift;
do {    my $C = $C->cursor_xact('ALT ||');
my $xact = $C->xact;
my @gather;
do {
push @gather, $C->_PATTERN(qr/\G[_[:alpha:]]/)
}
or $xact->[-2] or
do {
push @gather, $C->_PATTERN(qr/\G\s/)
}
or $xact->[-2] or
do {
push @gather, do {
if (my ($C) = ($C->sorry("Illegal pod directive"))) { ($C) } else { () }

}
};
@gather;
}
}))) {
$C->_STARr(sub {
my $C=shift;
$C->_NOTCHAR( sub { my $C=shift;
$C->_EXACT("\n")
})
})
} else { () }
}
)[$try])->($C);
last if @gather;
last if $xact->[-2];  # committed?
}
@gather;
};
}))) {
$C
} else { () }

});
}
;
## token embeddedblock {
sub embeddedblock__PEEK { $_[0]->_AUTOLEXpeek('embeddedblock', $retree) }
sub embeddedblock {
no warnings 'recursion';
my $self = shift;

local %::LANG = %::LANG;local $::SIGNUM;local $::GOAL = '}';local $::CURLEX = $::CURLEX;
local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;

my $C = $self->cursor_xact("RULE embeddedblock");
my $xact = $C->xact;
my $S = $C->{'_pos'};
$self->_MATCHIFYr($S, "embeddedblock", do {
my $C = $C;
if (($C) = ($C->newlex)
and ($C) = ($C->finishlex)
and ($C) = ($C->_EXACT("\{"))
and ($C) = ($C->_COMMITLTM())
and ($C) = ($C->_BRACKETr(sub {
my $C=shift;
my $newlang = ($::LANG{'MAIN'});
$C = bless($C, (ref($newlang) || $newlang));
$C->_SUBSUMEr(['statementlist'], sub {
my $C = shift;
$C->statementlist
})
}))
and ($C) = ($C->_BRACKETr(sub {
my $C=shift;
do {    my $C = $C->cursor_xact('ALT ||');
my $xact = $C->xact;
my @gather;
do {
push @gather, $C->_EXACT("\}")
}
or $xact->[-2] or
do {
push @gather, do {
if (my ($C) = ($C->panic("Unable to parse statement list; couldn't find right brace"))) { ($C) } else { () }

}
};
@gather;
}
}))) {
$C
} else { () }

});
}
;
## token binints { [<.ws><binint><.ws>] ** ',' }
sub binints__PEEK { $_[0]->_AUTOLEXpeek('binints', $retree) }
sub binints {
no warnings 'recursion';
my $self = shift;


local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;

my $C = $self->cursor_xact("RULE binints");
my $xact = $C->xact;
my $S = $C->{'_pos'};
$C->{'binint'} = [];
$self->_MATCHIFYr($S, "binints", $C->_REPSEPr( sub {
my $C=shift;
$C->_EXACT("\,")
}, sub {
my $C=shift;
if (my ($C) = ($C->_BRACKETr(sub {
my $C=shift;
if (($C) = ($C->ws)
and ($C) = ($C->_SUBSUMEr(['binint'], sub {
my $C = shift;
$C->binint
}))
and ($C) = ($C->ws)) {
$C
} else { () }
}))) { ($C) } else { () }
}));
}
;
## token binint {
sub binint__PEEK { $_[0]->_AUTOLEXpeek('binint', $retree) }
sub binint {
no warnings 'recursion';
my $self = shift;


local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;

my $C = $self->cursor_xact("RULE binint");
my $xact = $C->xact;
my $S = $C->{'_pos'};
$self->_MATCHIFYr($S, "binint", do {
if (my ($C) = ($C->_PATTERN(qr/\G(?:[0-1])++/))) {
$C->_STARr(sub {
my $C=shift;
if (my ($C) = ($C->_BRACKETr(sub {
my $C=shift;
$C->_PATTERN(qr/\G_(?:[0-1])++/)
}))) { ($C) } else { () }
})
} else { () }

});
}
;
## token octints { [<.ws><octint><.ws>] ** ',' }
sub octints__PEEK { $_[0]->_AUTOLEXpeek('octints', $retree) }
sub octints {
no warnings 'recursion';
my $self = shift;


local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;

my $C = $self->cursor_xact("RULE octints");
my $xact = $C->xact;
my $S = $C->{'_pos'};
$C->{'octint'} = [];
$self->_MATCHIFYr($S, "octints", $C->_REPSEPr( sub {
my $C=shift;
$C->_EXACT("\,")
}, sub {
my $C=shift;
if (my ($C) = ($C->_BRACKETr(sub {
my $C=shift;
if (($C) = ($C->ws)
and ($C) = ($C->_SUBSUMEr(['octint'], sub {
my $C = shift;
$C->octint
}))
and ($C) = ($C->ws)) {
$C
} else { () }
}))) { ($C) } else { () }
}));
}
;
## token octint {
sub octint__PEEK { $_[0]->_AUTOLEXpeek('octint', $retree) }
sub octint {
no warnings 'recursion';
my $self = shift;


local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;

my $C = $self->cursor_xact("RULE octint");
my $xact = $C->xact;
my $S = $C->{'_pos'};
$self->_MATCHIFYr($S, "octint", do {
if (my ($C) = ($C->_PATTERN(qr/\G(?:[0-7])++/))) {
$C->_STARr(sub {
my $C=shift;
if (my ($C) = ($C->_BRACKETr(sub {
my $C=shift;
$C->_PATTERN(qr/\G_(?:[0-7])++/)
}))) { ($C) } else { () }
})
} else { () }

});
}
;
## token hexints { [<.ws><hexint><.ws>] ** ',' }
sub hexints__PEEK { $_[0]->_AUTOLEXpeek('hexints', $retree) }
sub hexints {
no warnings 'recursion';
my $self = shift;


local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;

my $C = $self->cursor_xact("RULE hexints");
my $xact = $C->xact;
my $S = $C->{'_pos'};
$C->{'hexint'} = [];
$self->_MATCHIFYr($S, "hexints", $C->_REPSEPr( sub {
my $C=shift;
$C->_EXACT("\,")
}, sub {
my $C=shift;
if (my ($C) = ($C->_BRACKETr(sub {
my $C=shift;
if (($C) = ($C->ws)
and ($C) = ($C->_SUBSUMEr(['hexint'], sub {
my $C = shift;
$C->hexint
}))
and ($C) = ($C->ws)) {
$C
} else { () }
}))) { ($C) } else { () }
}));
}
;
## token hexint {
sub hexint__PEEK { $_[0]->_AUTOLEXpeek('hexint', $retree) }
sub hexint {
no warnings 'recursion';
my $self = shift;


local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;

my $C = $self->cursor_xact("RULE hexint");
my $xact = $C->xact;
my $S = $C->{'_pos'};
$self->_MATCHIFYr($S, "hexint", do {
if (my ($C) = ($C->_PATTERN(qr/\G(?:[0-9a-fA-F])++/))) {
$C->_STARr(sub {
my $C=shift;
if (my ($C) = ($C->_BRACKETr(sub {
my $C=shift;
$C->_PATTERN(qr/\G_(?:[0-9a-fA-F])++/)
}))) { ($C) } else { () }
})
} else { () }

});
}
;
## token decints { [<.ws><decint><.ws>] ** ',' }
sub decints__PEEK { $_[0]->_AUTOLEXpeek('decints', $retree) }
sub decints {
no warnings 'recursion';
my $self = shift;


local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;

my $C = $self->cursor_xact("RULE decints");
my $xact = $C->xact;
my $S = $C->{'_pos'};
$C->{'decint'} = [];
$self->_MATCHIFYr($S, "decints", $C->_REPSEPr( sub {
my $C=shift;
$C->_EXACT("\,")
}, sub {
my $C=shift;
if (my ($C) = ($C->_BRACKETr(sub {
my $C=shift;
if (($C) = ($C->ws)
and ($C) = ($C->_SUBSUMEr(['decint'], sub {
my $C = shift;
$C->decint
}))
and ($C) = ($C->ws)) {
$C
} else { () }
}))) { ($C) } else { () }
}));
}
;
## token decint {
sub decint__PEEK { $_[0]->_AUTOLEXpeek('decint', $retree) }
sub decint {
no warnings 'recursion';
my $self = shift;


local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;

my $C = $self->cursor_xact("RULE decint");
my $xact = $C->xact;
my $S = $C->{'_pos'};
$self->_MATCHIFYr($S, "decint", do {
if (my ($C) = ($C->_PATTERN(qr/\G\d++/))) {
$C->_STARr(sub {
my $C=shift;
if (my ($C) = ($C->_BRACKETr(sub {
my $C=shift;
$C->_PATTERN(qr/\G_\d++/)
}))) { ($C) } else { () }
})
} else { () }

});
}
;
## token integer {
sub integer__PEEK { $_[0]->_AUTOLEXpeek('integer', $retree) }
sub integer {
no warnings 'recursion';
my $self = shift;


local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;

my $C = $self->cursor_xact("RULE integer");
my $xact = $C->xact;
my $S = $C->{'_pos'};
$self->_MATCHIFYr($S, "integer", do {
my $C = $C;
if (($C) = ($C->_BRACKETr(sub {
my $C=shift;
do {
my ($tag, $try);
my @try;
my $relex;

my $fate;
my $x;
if ($fate = $C->{'_fate'} and $fate->[1] eq 'integer_0') {
$C->deb("Fate passed to integer_0: ", ::fatestr($fate)) if $::DEBUG & DEBUG::fates;
($C->{'_fate'}, $tag, $try) = @$fate;
@try = ($try);
$x = 'ALT integer_0';    # some outer ltm is controlling us
}
else {
$x = 'ALTLTM integer_0'; # we are top level ltm
}
my $C = $C->cursor_xact($x);
my $xact = $C->{_xact};

my @gather = ();
for (;;) {
unless (@try) {
$relex //= $C->cursor_fate('STD', 'integer_0', $retree);
@try = $relex->($C) or last;
}
$try = shift(@try) // next;

if (ref $try) {
($C->{'_fate'}, $tag, $try) = @$try;   # next candidate fate
}

$C->deb("integer_0 trying $tag $try") if $::DEBUG & DEBUG::try_processing;
push @gather, ((
sub {
my $C=shift;
if (($C) = ($C->_EXACT("0"))
and ($C) = ($C->_BRACKETr(sub {
my $C=shift;
do {
my ($tag, $try);
my @try;
my $relex;

my $fate;
my $x;
if ($fate = $C->{'_fate'} and $fate->[1] eq 'integer_1') {
$C->deb("Fate passed to integer_1: ", ::fatestr($fate)) if $::DEBUG & DEBUG::fates;
($C->{'_fate'}, $tag, $try) = @$fate;
@try = ($try);
$x = 'ALT integer_1';    # some outer ltm is controlling us
}
else {
$x = 'ALTLTM integer_1'; # we are top level ltm
}
my $C = $C->cursor_xact($x);
my $xact = $C->{_xact};

my @gather = ();
for (;;) {
unless (@try) {
$relex //= $C->cursor_fate('STD', 'integer_1', $retree);
@try = $relex->($C) or last;
}
$try = shift(@try) // next;

if (ref $try) {
($C->{'_fate'}, $tag, $try) = @$try;   # next candidate fate
}

$C->deb("integer_1 trying $tag $try") if $::DEBUG & DEBUG::try_processing;
push @gather, ((
sub {
my $C=shift;
if (my ($C) = ($C->_PATTERN(qr/\Gb_?+/))) {
$C->_SUBSUMEr(['binint'], sub {
my $C = shift;
$C->binint
})
} else { () }
},
sub {
my $C=shift;
if (my ($C) = ($C->_PATTERN(qr/\Go_?+/))) {
$C->_SUBSUMEr(['octint'], sub {
my $C = shift;
$C->octint
})
} else { () }
},
sub {
my $C=shift;
if (my ($C) = ($C->_PATTERN(qr/\Gx_?+/))) {
$C->_SUBSUMEr(['hexint'], sub {
my $C = shift;
$C->hexint
})
} else { () }
},
sub {
my $C=shift;
if (my ($C) = ($C->_PATTERN(qr/\Gd_?+/))) {
$C->_SUBSUMEr(['decint'], sub {
my $C = shift;
$C->decint
})
} else { () }
},
sub {
my $C=shift;
if (($C) = ($C->_SUBSUMEr(['decint'], sub {
my $C = shift;
$C->decint
}))
and ($C) = ($C->_NOTBEFORE(sub {
my $C=shift;
if (my ($C) = ($C->_NOTBEFORE(sub {
my $C=shift;
(($C) x !!do {
my $M = $C;
$C->worry("Leading 0 does not indicate octal in Perl 6; please use 0o" . $M->{'decint'}->Str . " if you mean that") })
}))) { ($C) } else { () }
}))) {
$C
} else { () }
}
)[$try])->($C);
last if @gather;
last if $xact->[-2];  # committed?
}
@gather;
};
}))) {
$C
} else { () }
},
sub {
my $C=shift;
$C->_SUBSUMEr(['decint'], sub {
my $C = shift;
$C->decint
})
}
)[$try])->($C);
last if @gather;
last if $xact->[-2];  # committed?
}
@gather;
};
}))
and ($C) = ($C->_NOTBEFORE(sub {
my $C=shift;
if (my ($C) = ($C->_NOTBEFORE(sub {
my $C=shift;
if (my ($C) = ($C->before(sub {
my $C=shift;
$C->_OPTr(sub {
my $C=shift;
if (my ($C) = ($C->_BRACKETr(sub {
my $C=shift;
if (($C) = ($C->_EXACT("\."))
and ($C) = ($C->before(sub {
my $C=shift;
if (my ($C) = ($C->before(sub {
my $C=shift;
$C->{'terminator'} = [];
if (my ($C) = (do {
do {
my ($tag, $try);
my @try;
my $relex;

my $fate;
my $x;
if ($fate = $C->{'_fate'} and $fate->[1] eq 'integer_2') {
$C->deb("Fate passed to integer_2: ", ::fatestr($fate)) if $::DEBUG & DEBUG::fates;
($C->{'_fate'}, $tag, $try) = @$fate;
@try = ($try);
$x = 'ALT integer_2';    # some outer ltm is controlling us
}
else {
$x = 'ALTLTM integer_2'; # we are top level ltm
}
my $C = $C->cursor_xact($x);
my $xact = $C->{_xact};

my @gather = ();
for (;;) {
unless (@try) {
$relex //= $C->cursor_fate('STD', 'integer_2', $retree);
@try = $relex->($C) or last;
}
$try = shift(@try) // next;

if (ref $try) {
($C->{'_fate'}, $tag, $try) = @$try;   # next candidate fate
}

$C->deb("integer_2 trying $tag $try") if $::DEBUG & DEBUG::try_processing;
push @gather, ((
sub {
my $C=shift;
$C->_PATTERN(qr/\G\s/)
},
sub {
my $C=shift;
$C->_EXACT("\,")
},
sub {
my $C=shift;
$C->_EXACT("\=")
},
sub {
my $C=shift;
$C->_SUBSUMEr(['terminator'], sub {
my $C = shift;
$C->terminator
})
}
)[$try])->($C);
last if @gather;
last if $xact->[-2];  # committed?
}
@gather;
};

})) { ($C) } else { () }
}))) { ($C) } else { () }
}))
and ($C) = ($C->sorry("Decimal point must be followed by digit"))) {
$C
} else { () }
}))) { ($C) } else { () }
})
}))) { ($C) } else { () }
}))) { ($C) } else { () }
}))) {
$C->_OPTr(sub {
my $C=shift;
if (my ($C) = ($C->_BRACKETr(sub {
my $C=shift;
if (($C) = ($C->before(sub {
my $C=shift;
if (my ($C) = ($C->before(sub {
my $C=shift;
$C->_PATTERN(qr/\G__++\d/)
}))) { ($C) } else { () }
}))
and ($C) = ($C->sorry("Only isolated underscores are allowed inside numbers"))) {
$C
} else { () }
}))) { ($C) } else { () }
})
} else { () }

});
}
;
## token radint {
sub radint__PEEK { $_[0]->_AUTOLEXpeek('radint', $retree) }
sub radint {
no warnings 'recursion';
my $self = shift;


local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;

my $C = $self->cursor_xact("RULE radint");
my $xact = $C->xact;
my $S = $C->{'_pos'};
$self->_MATCHIFYr($S, "radint", $C->_BRACKETr(sub {
my $C=shift;
do {
my ($tag, $try);
my @try;
my $relex;

my $fate;
my $x;
if ($fate = $C->{'_fate'} and $fate->[1] eq 'radint_0') {
$C->deb("Fate passed to radint_0: ", ::fatestr($fate)) if $::DEBUG & DEBUG::fates;
($C->{'_fate'}, $tag, $try) = @$fate;
@try = ($try);
$x = 'ALT radint_0';    # some outer ltm is controlling us
}
else {
$x = 'ALTLTM radint_0'; # we are top level ltm
}
my $C = $C->cursor_xact($x);
my $xact = $C->{_xact};

my @gather = ();
for (;;) {
unless (@try) {
$relex //= $C->cursor_fate('STD', 'radint_0', $retree);
@try = $relex->($C) or last;
}
$try = shift(@try) // next;

if (ref $try) {
($C->{'_fate'}, $tag, $try) = @$try;   # next candidate fate
}

$C->deb("radint_0 trying $tag $try") if $::DEBUG & DEBUG::try_processing;
push @gather, ((
sub {
my $C=shift;
$C->_SUBSUMEr(['integer'], sub {
my $C = shift;
$C->integer
})
},
sub {
my $C=shift;
if (($C) = ($C->before(sub {
my $C=shift;
if (my ($C) = ($C->before(sub {
my $C=shift;
$C->_PATTERN(qr/\G\:\d/)
}))) { ($C) } else { () }
}))
and ($C) = ($C->_SUBSUMEr(['rad_number'], sub {
my $C = shift;
$C->rad_number
}))
and ($C) = ($C->before(sub {
my $C=shift;
(($C) x !!do {
my $M = $C;
defined $M->{'rad_number'}->{'intpart'}
and
not defined $M->{'rad_number'}->{'fracpart'}
})
}))) {
$C
} else { () }
}
)[$try])->($C);
last if @gather;
last if $xact->[-2];  # committed?
}
@gather;
};
}));
}
;
## token escale {
sub escale__PEEK { $_[0]->_AUTOLEXpeek('escale', $retree) }
sub escale {
no warnings 'recursion';
my $self = shift;


local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;

my $C = $self->cursor_xact("RULE escale");
my $xact = $C->xact;
my $S = $C->{'_pos'};
$self->_MATCHIFYr($S, "escale", do {
if (my ($C) = ($C->_PATTERN(qr/\G[Ee](?:[+\-])?+/))) {
$C->_SUBSUMEr(['decint'], sub {
my $C = shift;
$C->decint
})
} else { () }

});
}
;
## token dec_number {
sub dec_number__PEEK { $_[0]->_AUTOLEXpeek('dec_number', $retree) }
sub dec_number {
no warnings 'recursion';
my $self = shift;


local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;

my $C = $self->cursor_xact("RULE dec_number");
my $xact = $C->xact;
my $S = $C->{'_pos'};
$C->{'escale'} = [];
$self->_MATCHIFYr($S, "dec_number", do {
my $C = $C;
if (($C) = ($C->_BRACKETr(sub {
my $C=shift;
do {
my ($tag, $try);
my @try;
my $relex;

my $fate;
my $x;
if ($fate = $C->{'_fate'} and $fate->[1] eq 'dec_number_0') {
$C->deb("Fate passed to dec_number_0: ", ::fatestr($fate)) if $::DEBUG & DEBUG::fates;
($C->{'_fate'}, $tag, $try) = @$fate;
@try = ($try);
$x = 'ALT dec_number_0';    # some outer ltm is controlling us
}
else {
$x = 'ALTLTM dec_number_0'; # we are top level ltm
}
my $C = $C->cursor_xact($x);
my $xact = $C->{_xact};

my @gather = ();
for (;;) {
unless (@try) {
$relex //= $C->cursor_fate('STD', 'dec_number_0', $retree);
@try = $relex->($C) or last;
}
$try = shift(@try) // next;

if (ref $try) {
($C->{'_fate'}, $tag, $try) = @$try;   # next candidate fate
}

$C->deb("dec_number_0 trying $tag $try") if $::DEBUG & DEBUG::try_processing;
push @gather, ((
sub {
my $C=shift;
if (my ($C) = ($C->_SUBSUMEr(['coeff'], sub {
my $C = shift;
$C->_BRACKETr(sub {
my $C=shift;
if (my ($C) = ($C->_EXACT("\."))) {
$C->_SUBSUMEr(['frac'], sub {
my $C = shift;
$C->decint
})
} else { () }
})
}))) {
$C->_OPTr(sub {
my $C=shift;
$C->_SUBSUMEr(['escale'], sub {
my $C = shift;
$C->escale
})
})
} else { () }
},
sub {
my $C=shift;
if (my ($C) = ($C->_SUBSUMEr(['coeff'], sub {
my $C = shift;
$C->_BRACKETr(sub {
my $C=shift;
if (($C) = ($C->_SUBSUMEr(['int'], sub {
my $C = shift;
$C->decint
}))
and ($C) = ($C->_EXACT("\."))) {
$C->_SUBSUMEr(['frac'], sub {
my $C = shift;
$C->decint
})
} else { () }
})
}))) {
$C->_OPTr(sub {
my $C=shift;
$C->_SUBSUMEr(['escale'], sub {
my $C = shift;
$C->escale
})
})
} else { () }
},
sub {
my $C=shift;
if (my ($C) = ($C->_SUBSUMEr(['coeff'], sub {
my $C = shift;
$C->_BRACKETr(sub {
my $C=shift;
$C->_SUBSUMEr(['int'], sub {
my $C = shift;
$C->decint
})
})
}))) {
$C->_SUBSUMEr(['escale'], sub {
my $C = shift;
$C->escale
})
} else { () }
}
)[$try])->($C);
last if @gather;
last if $xact->[-2];  # committed?
}
@gather;
};
}))
and ($C) = ($C->_OPTr(sub {
my $C=shift;
if (my ($C) = ($C->_BRACKETr(sub {
my $C=shift;
if (($C) = ($C->before(sub {
my $C=shift;
if (my ($C) = ($C->before(sub {
my $C=shift;
$C->_PATTERN(qr/\G\.\d/)
}))) { ($C) } else { () }
}))
and ($C) = ($C->sorry("Number contains two decimal points (missing 'v' for version number?)"))) {
$C->_PLUSr(sub {
my $C=shift;
if (my ($C) = ($C->_BRACKETr(sub {
my $C=shift;
$C->_PATTERN(qr/\G\.\d++/)
}))) { ($C) } else { () }
})
} else { () }
}))) { ($C) } else { () }
}))) {
$C->_OPTr(sub {
my $C=shift;
if (my ($C) = ($C->_BRACKETr(sub {
my $C=shift;
if (($C) = ($C->before(sub {
my $C=shift;
if (my ($C) = ($C->before(sub {
my $C=shift;
$C->_PATTERN(qr/\G__++\d/)
}))) { ($C) } else { () }
}))
and ($C) = ($C->sorry("Only isolated underscores are allowed inside numbers"))) {
$C
} else { () }
}))) { ($C) } else { () }
})
} else { () }

});
}
;
## token alnumint {
sub alnumint__PEEK { $_[0]->_AUTOLEXpeek('alnumint', $retree) }
sub alnumint {
no warnings 'recursion';
my $self = shift;


local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;

my $C = $self->cursor_xact("RULE alnumint");
my $xact = $C->xact;
my $S = $C->{'_pos'};
$self->_MATCHIFYr($S, "alnumint", $C->_BRACKETr(sub {
my $C=shift;
if (my ($C) = ($C->_PATTERN(qr/\G(?:[0-9a-zA-Z])++/))) {
$C->_STARr(sub {
my $C=shift;
if (my ($C) = ($C->_BRACKETr(sub {
my $C=shift;
$C->_PATTERN(qr/\G_(?:[0-9a-zA-Z])++/)
}))) { ($C) } else { () }
})
} else { () }
}));
}
;
## token rad_number {
sub rad_number__PEEK { $_[0]->_AUTOLEXpeek('rad_number', $retree) }
sub rad_number {
no warnings 'recursion';
my $self = shift;


local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;

my $C = $self->cursor_xact("RULE rad_number");
my $xact = $C->xact;
my $S = $C->{'_pos'};
$C->{'base'} = [];
$C->{'exp'} = [];
$self->_MATCHIFYr($S, "rad_number", do {
my $C = $C;
if (($C) = ($C->_EXACT("\:"))
and ($C) = ($C->_SUBSUMEr(['radix'], sub {
my $C = shift;
$C->_BRACKETr(sub {
my $C=shift;
$C->_PATTERN(qr/\G\d++/)
})
}))
and ($C) = ($C->_OPTr(sub {
my $C=shift;
if (my ($C) = ($C->unsp)) { ($C) } else { () }
}))
and ($C) = (scalar(do {
}, $C))
and ($C) = ($C->_BRACKETr(sub {
my $C=shift;
do {    my $C = $C->cursor_xact('ALT ||');
my $xact = $C->xact;
my @gather;
do {
push @gather, do {
my $C = $C;
if (($C) = ($C->_EXACT("\<"))
and ($C) = ($C->_BRACKETr(sub {
my $C=shift;
do {
my ($tag, $try);
my @try;
my $relex;

my $fate;
my $x;
if ($fate = $C->{'_fate'} and $fate->[1] eq 'rad_number_0') {
$C->deb("Fate passed to rad_number_0: ", ::fatestr($fate)) if $::DEBUG & DEBUG::fates;
($C->{'_fate'}, $tag, $try) = @$fate;
@try = ($try);
$x = 'ALT rad_number_0';    # some outer ltm is controlling us
}
else {
$x = 'ALTLTM rad_number_0'; # we are top level ltm
}
my $C = $C->cursor_xact($x);
my $xact = $C->{_xact};

my @gather = ();
for (;;) {
unless (@try) {
$relex //= $C->cursor_fate('STD', 'rad_number_0', $retree);
@try = $relex->($C) or last;
}
$try = shift(@try) // next;

if (ref $try) {
($C->{'_fate'}, $tag, $try) = @$try;   # next candidate fate
}

$C->deb("rad_number_0 trying $tag $try") if $::DEBUG & DEBUG::try_processing;
push @gather, ((
sub {
my $C=shift;
$C->_SUBSUMEr(['coeff'], sub {
my $C = shift;
$C->_BRACKETr(sub {
my $C=shift;
if (my ($C) = ($C->_EXACT("\."))) {
$C->_SUBSUMEr(['frac'], sub {
my $C = shift;
$C->alnumint
})
} else { () }
})
})
},
sub {
my $C=shift;
$C->_SUBSUMEr(['coeff'], sub {
my $C = shift;
$C->_BRACKETr(sub {
my $C=shift;
if (($C) = ($C->_SUBSUMEr(['int'], sub {
my $C = shift;
$C->alnumint
}))
and ($C) = ($C->_EXACT("\."))) {
$C->_SUBSUMEr(['frac'], sub {
my $C = shift;
$C->alnumint
})
} else { () }
})
})
},
sub {
my $C=shift;
$C->_SUBSUMEr(['coeff'], sub {
my $C = shift;
$C->_BRACKETr(sub {
my $C=shift;
$C->_SUBSUMEr(['int'], sub {
my $C = shift;
$C->alnumint
})
})
})
}
)[$try])->($C);
last if @gather;
last if $xact->[-2];  # committed?
}
@gather;
};
}))
and ($C) = ($C->_OPTr(sub {
my $C=shift;
if (my ($C) = ($C->_BRACKETr(sub {
my $C=shift;
if (($C) = ($C->_EXACT("\*"))
and ($C) = ($C->_SUBSUMEr(['base'], sub {
my $C = shift;
$C->radint
}))
and ($C) = ($C->_BRACKETr(sub {
my $C=shift;
do {    my $C = $C->cursor_xact('ALT ||');
my $xact = $C->xact;
my @gather;
do {
push @gather, do {
if (my ($C) = ($C->_EXACT("\*\*"))) {
$C->_SUBSUMEr(['exp'], sub {
my $C = shift;
$C->radint
})
} else { () }

}
}
or $xact->[-2] or
do {
push @gather, do {
if (my ($C) = ($C->sorry("Base is missing ** exponent part"))) { ($C) } else { () }

}
};
@gather;
}
}))) {
$C
} else { () }
}))) { ($C) } else { () }
}))) {
$C->_EXACT("\>")
} else { () }

}
}
or $xact->[-2] or
do {
push @gather, do {
if (my ($C) = ($C->before(sub {
my $C=shift;
if (my ($C) = ($C->before(sub {
my $C=shift;
$C->_EXACT("\[")
}))) { ($C) } else { () }
}))) {
$C->_SUBSUMEr(['circumfix'], sub {
my $C = shift;
$C->circumfix
})
} else { () }

}
}
or $xact->[-2] or
do {
push @gather, do {
if (my ($C) = ($C->before(sub {
my $C=shift;
if (my ($C) = ($C->before(sub {
my $C=shift;
$C->_EXACT("\(")
}))) { ($C) } else { () }
}))) {
$C->_SUBSUMEr(['circumfix'], sub {
my $C = shift;
$C->circumfix
})
} else { () }

}
}
or $xact->[-2] or
do {
push @gather, do {
if (my ($C) = ($C->panic("Malformed radix number"))) { ($C) } else { () }

}
};
@gather;
}
}))) {
$C
} else { () }

});
}
;
## token terminator:sym<)>
sub terminator__S_059Thesis__PEEK { $_[0]->_AUTOLEXpeek('terminator__S_059Thesis', $retree) }
sub terminator__S_059Thesis {
no warnings 'recursion';
my $self = shift;


local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;

my $C = $self->cursor_xact("RULE terminator__S_059Thesis");
my $xact = $C->xact;
my $S = $C->{'_pos'};
$C->{sym} = "\)";
$self->_MATCHIFYr($S, "terminator__S_059Thesis", do {
if (my ($C) = ($C->_EXACT("\)"))) {
$C->_SUBSUMEr(['O'], sub {
my $C = shift;
$C->O(%terminator)
})
} else { () }

});
}
;
## token terminator:sym<]>
sub terminator__S_060Ket__PEEK { $_[0]->_AUTOLEXpeek('terminator__S_060Ket', $retree) }
sub terminator__S_060Ket {
no warnings 'recursion';
my $self = shift;


local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;

my $C = $self->cursor_xact("RULE terminator__S_060Ket");
my $xact = $C->xact;
my $S = $C->{'_pos'};
$C->{sym} = "\]";
$self->_MATCHIFYr($S, "terminator__S_060Ket", do {
if (my ($C) = ($C->_EXACT("\]"))) {
$C->_SUBSUMEr(['O'], sub {
my $C = shift;
$C->O(%terminator)
})
} else { () }

});
}
;
## token terminator:sym<}>
sub terminator__S_061Ly__PEEK { $_[0]->_AUTOLEXpeek('terminator__S_061Ly', $retree) }
sub terminator__S_061Ly {
no warnings 'recursion';
my $self = shift;


local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;

my $C = $self->cursor_xact("RULE terminator__S_061Ly");
my $xact = $C->xact;
my $S = $C->{'_pos'};
$C->{sym} = "\}";
$self->_MATCHIFYr($S, "terminator__S_061Ly", do {
if (my ($C) = ($C->_EXACT("\}"))) {
$C->_SUBSUMEr(['O'], sub {
my $C = shift;
$C->O(%terminator)
})
} else { () }

});
}
;
our %open2close = (
"\x{0028}" => "\x{0029}",
"\x{003C}" => "\x{003E}",
"\x{005B}" => "\x{005D}",
"\x{007B}" => "\x{007D}",
"\x{00AB}" => "\x{00BB}",
"\x{0F3A}" => "\x{0F3B}",
"\x{0F3C}" => "\x{0F3D}",
"\x{169B}" => "\x{169C}",
"\x{2018}" => "\x{2019}",
"\x{201A}" => "\x{2019}",
"\x{201B}" => "\x{2019}",
"\x{201C}" => "\x{201D}",
"\x{201E}" => "\x{201D}",
"\x{201F}" => "\x{201D}",
"\x{2039}" => "\x{203A}",
"\x{2045}" => "\x{2046}",
"\x{207D}" => "\x{207E}",
"\x{208D}" => "\x{208E}",
"\x{2208}" => "\x{220B}",
"\x{2209}" => "\x{220C}",
"\x{220A}" => "\x{220D}",
"\x{2215}" => "\x{29F5}",
"\x{223C}" => "\x{223D}",
"\x{2243}" => "\x{22CD}",
"\x{2252}" => "\x{2253}",
"\x{2254}" => "\x{2255}",
"\x{2264}" => "\x{2265}",
"\x{2266}" => "\x{2267}",
"\x{2268}" => "\x{2269}",
"\x{226A}" => "\x{226B}",
"\x{226E}" => "\x{226F}",
"\x{2270}" => "\x{2271}",
"\x{2272}" => "\x{2273}",
"\x{2274}" => "\x{2275}",
"\x{2276}" => "\x{2277}",
"\x{2278}" => "\x{2279}",
"\x{227A}" => "\x{227B}",
"\x{227C}" => "\x{227D}",
"\x{227E}" => "\x{227F}",
"\x{2280}" => "\x{2281}",
"\x{2282}" => "\x{2283}",
"\x{2284}" => "\x{2285}",
"\x{2286}" => "\x{2287}",
"\x{2288}" => "\x{2289}",
"\x{228A}" => "\x{228B}",
"\x{228F}" => "\x{2290}",
"\x{2291}" => "\x{2292}",
"\x{2298}" => "\x{29B8}",
"\x{22A2}" => "\x{22A3}",
"\x{22A6}" => "\x{2ADE}",
"\x{22A8}" => "\x{2AE4}",
"\x{22A9}" => "\x{2AE3}",
"\x{22AB}" => "\x{2AE5}",
"\x{22B0}" => "\x{22B1}",
"\x{22B2}" => "\x{22B3}",
"\x{22B4}" => "\x{22B5}",
"\x{22B6}" => "\x{22B7}",
"\x{22C9}" => "\x{22CA}",
"\x{22CB}" => "\x{22CC}",
"\x{22D0}" => "\x{22D1}",
"\x{22D6}" => "\x{22D7}",
"\x{22D8}" => "\x{22D9}",
"\x{22DA}" => "\x{22DB}",
"\x{22DC}" => "\x{22DD}",
"\x{22DE}" => "\x{22DF}",
"\x{22E0}" => "\x{22E1}",
"\x{22E2}" => "\x{22E3}",
"\x{22E4}" => "\x{22E5}",
"\x{22E6}" => "\x{22E7}",
"\x{22E8}" => "\x{22E9}",
"\x{22EA}" => "\x{22EB}",
"\x{22EC}" => "\x{22ED}",
"\x{22F0}" => "\x{22F1}",
"\x{22F2}" => "\x{22FA}",
"\x{22F3}" => "\x{22FB}",
"\x{22F4}" => "\x{22FC}",
"\x{22F6}" => "\x{22FD}",
"\x{22F7}" => "\x{22FE}",
"\x{2308}" => "\x{2309}",
"\x{230A}" => "\x{230B}",
"\x{2329}" => "\x{232A}",
"\x{23B4}" => "\x{23B5}",
"\x{2768}" => "\x{2769}",
"\x{276A}" => "\x{276B}",
"\x{276C}" => "\x{276D}",
"\x{276E}" => "\x{276F}",
"\x{2770}" => "\x{2771}",
"\x{2772}" => "\x{2773}",
"\x{2774}" => "\x{2775}",
"\x{27C3}" => "\x{27C4}",
"\x{27C5}" => "\x{27C6}",
"\x{27D5}" => "\x{27D6}",
"\x{27DD}" => "\x{27DE}",
"\x{27E2}" => "\x{27E3}",
"\x{27E4}" => "\x{27E5}",
"\x{27E6}" => "\x{27E7}",
"\x{27E8}" => "\x{27E9}",
"\x{27EA}" => "\x{27EB}",
"\x{2983}" => "\x{2984}",
"\x{2985}" => "\x{2986}",
"\x{2987}" => "\x{2988}",
"\x{2989}" => "\x{298A}",
"\x{298B}" => "\x{298C}",
"\x{298D}" => "\x{298E}",
"\x{298F}" => "\x{2990}",
"\x{2991}" => "\x{2992}",
"\x{2993}" => "\x{2994}",
"\x{2995}" => "\x{2996}",
"\x{2997}" => "\x{2998}",
"\x{29C0}" => "\x{29C1}",
"\x{29C4}" => "\x{29C5}",
"\x{29CF}" => "\x{29D0}",
"\x{29D1}" => "\x{29D2}",
"\x{29D4}" => "\x{29D5}",
"\x{29D8}" => "\x{29D9}",
"\x{29DA}" => "\x{29DB}",
"\x{29F8}" => "\x{29F9}",
"\x{29FC}" => "\x{29FD}",
"\x{2A2B}" => "\x{2A2C}",
"\x{2A2D}" => "\x{2A2E}",
"\x{2A34}" => "\x{2A35}",
"\x{2A3C}" => "\x{2A3D}",
"\x{2A64}" => "\x{2A65}",
"\x{2A79}" => "\x{2A7A}",
"\x{2A7D}" => "\x{2A7E}",
"\x{2A7F}" => "\x{2A80}",
"\x{2A81}" => "\x{2A82}",
"\x{2A83}" => "\x{2A84}",
"\x{2A8B}" => "\x{2A8C}",
"\x{2A91}" => "\x{2A92}",
"\x{2A93}" => "\x{2A94}",
"\x{2A95}" => "\x{2A96}",
"\x{2A97}" => "\x{2A98}",
"\x{2A99}" => "\x{2A9A}",
"\x{2A9B}" => "\x{2A9C}",
"\x{2AA1}" => "\x{2AA2}",
"\x{2AA6}" => "\x{2AA7}",
"\x{2AA8}" => "\x{2AA9}",
"\x{2AAA}" => "\x{2AAB}",
"\x{2AAC}" => "\x{2AAD}",
"\x{2AAF}" => "\x{2AB0}",
"\x{2AB3}" => "\x{2AB4}",
"\x{2ABB}" => "\x{2ABC}",
"\x{2ABD}" => "\x{2ABE}",
"\x{2ABF}" => "\x{2AC0}",
"\x{2AC1}" => "\x{2AC2}",
"\x{2AC3}" => "\x{2AC4}",
"\x{2AC5}" => "\x{2AC6}",
"\x{2ACD}" => "\x{2ACE}",
"\x{2ACF}" => "\x{2AD0}",
"\x{2AD1}" => "\x{2AD2}",
"\x{2AD3}" => "\x{2AD4}",
"\x{2AD5}" => "\x{2AD6}",
"\x{2AEC}" => "\x{2AED}",
"\x{2AF7}" => "\x{2AF8}",
"\x{2AF9}" => "\x{2AFA}",
"\x{2E02}" => "\x{2E03}",
"\x{2E04}" => "\x{2E05}",
"\x{2E09}" => "\x{2E0A}",
"\x{2E0C}" => "\x{2E0D}",
"\x{2E1C}" => "\x{2E1D}",
"\x{2E20}" => "\x{2E21}",
"\x{3008}" => "\x{3009}",
"\x{300A}" => "\x{300B}",
"\x{300C}" => "\x{300D}",
"\x{300E}" => "\x{300F}",
"\x{3010}" => "\x{3011}",
"\x{3014}" => "\x{3015}",
"\x{3016}" => "\x{3017}",
"\x{3018}" => "\x{3019}",
"\x{301A}" => "\x{301B}",
"\x{301D}" => "\x{301E}",
"\x{FD3E}" => "\x{FD3F}",
"\x{FE17}" => "\x{FE18}",
"\x{FE35}" => "\x{FE36}",
"\x{FE37}" => "\x{FE38}",
"\x{FE39}" => "\x{FE3A}",
"\x{FE3B}" => "\x{FE3C}",
"\x{FE3D}" => "\x{FE3E}",
"\x{FE3F}" => "\x{FE40}",
"\x{FE41}" => "\x{FE42}",
"\x{FE43}" => "\x{FE44}",
"\x{FE47}" => "\x{FE48}",
"\x{FE59}" => "\x{FE5A}",
"\x{FE5B}" => "\x{FE5C}",
"\x{FE5D}" => "\x{FE5E}",
"\x{FF08}" => "\x{FF09}",
"\x{FF1C}" => "\x{FF1E}",
"\x{FF3B}" => "\x{FF3D}",
"\x{FF5B}" => "\x{FF5D}",
"\x{FF5F}" => "\x{FF60}",
"\x{FF62}" => "\x{FF63}",
);
our %close2open = reverse %open2close;
## token opener {
sub opener__PEEK { $_[0]->_AUTOLEXpeek('opener', $retree) }
sub opener {
no warnings 'recursion';
my $self = shift;


local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;

my $C = $self->cursor_xact("RULE opener");
my $xact = $C->xact;
my $S = $C->{'_pos'};
$self->_MATCHIFYr($S, "opener", $C->_PATTERN(qr/\G[\x{0028}\x{003C}\x{005B}\x{007B}\x{00AB}\x{0F3A}\x{0F3C}\x{169B}\x{2018}\x{201A}\x{201B}\x{201C}\x{201E}\x{201F}\x{2039}\x{2045}\x{207D}\x{208D}\x{2208}\x{2209}\x{220A}\x{2215}\x{223C}\x{2243}\x{2252}\x{2254}\x{2264}\x{2266}\x{2268}\x{226A}\x{226E}\x{2270}\x{2272}\x{2274}\x{2276}\x{2278}\x{227A}\x{227C}\x{227E}\x{2280}\x{2282}\x{2284}\x{2286}\x{2288}\x{228A}\x{228F}\x{2291}\x{2298}\x{22A2}\x{22A6}\x{22A8}\x{22A9}\x{22AB}\x{22B0}\x{22B2}\x{22B4}\x{22B6}\x{22C9}\x{22CB}\x{22D0}\x{22D6}\x{22D8}\x{22DA}\x{22DC}\x{22DE}\x{22E0}\x{22E2}\x{22E4}\x{22E6}\x{22E8}\x{22EA}\x{22EC}\x{22F0}\x{22F2}\x{22F3}\x{22F4}\x{22F6}\x{22F7}\x{2308}\x{230A}\x{2329}\x{23B4}\x{2768}\x{276A}\x{276C}\x{276E}\x{2770}\x{2772}\x{2774}\x{27C3}\x{27C5}\x{27D5}\x{27DD}\x{27E2}\x{27E4}\x{27E6}\x{27E8}\x{27EA}\x{2983}\x{2985}\x{2987}\x{2989}\x{298B}\x{298D}\x{298F}\x{2991}\x{2993}\x{2995}\x{2997}\x{29C0}\x{29C4}\x{29CF}\x{29D1}\x{29D4}\x{29D8}\x{29DA}\x{29F8}\x{29FC}\x{2A2B}\x{2A2D}\x{2A34}\x{2A3C}\x{2A64}\x{2A79}\x{2A7D}\x{2A7F}\x{2A81}\x{2A83}\x{2A8B}\x{2A91}\x{2A93}\x{2A95}\x{2A97}\x{2A99}\x{2A9B}\x{2AA1}\x{2AA6}\x{2AA8}\x{2AAA}\x{2AAC}\x{2AAF}\x{2AB3}\x{2ABB}\x{2ABD}\x{2ABF}\x{2AC1}\x{2AC3}\x{2AC5}\x{2ACD}\x{2ACF}\x{2AD1}\x{2AD3}\x{2AD5}\x{2AEC}\x{2AF7}\x{2AF9}\x{2E02}\x{2E04}\x{2E09}\x{2E0C}\x{2E1C}\x{2E20}\x{3008}\x{300A}\x{300C}\x{300E}\x{3010}\x{3014}\x{3016}\x{3018}\x{301A}\x{301D}\x{FD3E}\x{FE17}\x{FE35}\x{FE37}\x{FE39}\x{FE3B}\x{FE3D}\x{FE3F}\x{FE41}\x{FE43}\x{FE47}\x{FE59}\x{FE5B}\x{FE5D}\x{FF08}\x{FF1C}\x{FF3B}\x{FF5B}\x{FF5F}\x{FF62}]/));
}
;
{ package STD::P6;
use Moose ':all' => { -prefix => "moose_" };
use Encode;
moose_extends('STD');
our $ALLROLES = { 'STD::P6', 1 };
our $REGEXES = {
ALL => [ qw/POST PRE arglist args blast block blockoid capterm capture circumfix coloncircumfix colonpair comp_unit curlycheck declarator default_value deflongname desigilname dotty dottyop dottyopish dumbsmart eat_terminator fakesignature fatarrow infix infix_circumfix_meta_operator infix_postfix_meta_operator infix_prefix_meta_operator infixish infixstopper label lambda macro_def method_def methodop modifier_expr module_name multi_declarator multisig named_param nullterm nulltermish number old_rx_mods old_tr_mods package_declarator package_def param_sep param_var parameter pblock post_constraint postcircumfix postfix postfix_prefix_meta_operator postop prefix prefix_circumfix_meta_operator prefix_postfix_meta_operator privop quasiquibble quote quote_mod regex_block regex_declarator regex_def routine_declarator routine_def scope_declarator scoped semiarglist semilist sibble signature sigterm special_variable statement statement_control statement_mod_cond statement_mod_loop statement_prefix statementlist strtonum sublongname subshortname term terminator termish trait trait_mod tribble type_constraint type_declarator typename unitstart value variable variable_declarator version vnum xblock/ ],
circumfix => [ qw/circumfix__S_191sigil__PEEK circumfix__S_192Paren_Thesis__PEEK circumfix__S_193Bra_Ket__PEEK circumfix__S_214Cur_Ly__PEEK/ ],
dotty => [ qw/dotty__S_194DotStar__PEEK dotty__S_195Dot__PEEK/ ],
infix => [ qw/infix__S_190lambda__PEEK infix__S_216Dot__PEEK infix__S_222StarStar__PEEK infix__S_237Star__PEEK infix__S_238Slash__PEEK infix__S_239div__PEEK infix__S_240Percent__PEEK infix__S_241PercentPercent__PEEK infix__S_242mod__PEEK infix__S_243PlusAmp__PEEK infix__S_244LtLt__PEEK infix__S_245GtGt__PEEK infix__S_246TildeAmp__PEEK infix__S_247QuestionAmp__PEEK infix__S_248TildeLt__PEEK infix__S_249TildeGt__PEEK infix__S_250PlusLt__PEEK infix__S_251PlusGt__PEEK infix__S_252Plus__PEEK infix__S_253Minus__PEEK infix__S_254PlusVert__PEEK infix__S_255PlusCaret__PEEK infix__S_256TildeVert__PEEK infix__S_257TildeCaret__PEEK infix__S_258QuestionVert__PEEK infix__S_259QuestionCaret__PEEK infix__S_260x__PEEK infix__S_261xx__PEEK infix__S_262Tilde__PEEK infix__S_263Amp__PEEK infix__S_264Vert__PEEK infix__S_265Caret__PEEK infix__S_270LtEqualGt__PEEK infix__S_271cmp__PEEK infix__S_272leg__PEEK infix__S_273but__PEEK infix__S_274does__PEEK infix__S_275DotDot__PEEK infix__S_276CaretDotDot__PEEK infix__S_277DotDotCaret__PEEK infix__S_278CaretDotDotCaret__PEEK infix__S_279EqualEqual__PEEK infix__S_280BangEqual__PEEK infix__S_281Lt__PEEK infix__S_282LtEqual__PEEK infix__S_283Gt__PEEK infix__S_284GtEqual__PEEK infix__S_285TildeTilde__PEEK infix__S_286BangTilde__PEEK infix__S_287EqualTilde__PEEK infix__S_288eq__PEEK infix__S_289ne__PEEK infix__S_290lt__PEEK infix__S_291le__PEEK infix__S_292gt__PEEK infix__S_293ge__PEEK infix__S_294EqualColonEqual__PEEK infix__S_295EqualEqualEqual__PEEK infix__S_296eqv__PEEK infix__S_297before__PEEK infix__S_298after__PEEK infix__S_299AmpAmp__PEEK infix__S_300VertVert__PEEK infix__S_301CaretCaret__PEEK infix__S_302SlashSlash__PEEK infix__S_303min__PEEK infix__S_304max__PEEK infix__S_305QuestionQuestion_BangBang__PEEK infix__S_306BangBang__PEEK infix__S_307Question__PEEK infix__S_308ff__PEEK infix__S_309Caretff__PEEK infix__S_310ffCaret__PEEK infix__S_311CaretffCaret__PEEK infix__S_312fff__PEEK infix__S_313Caretfff__PEEK infix__S_314fffCaret__PEEK infix__S_315CaretfffCaret__PEEK infix__S_316Equal__PEEK infix__S_317ColonEqual__PEEK infix__S_318ColonColonEqual__PEEK infix__S_319DotEqual__PEEK infix__S_320EqualGt__PEEK infix__S_323Comma__PEEK infix__S_324Colon__PEEK infix__S_325X__PEEK infix__S_326Z__PEEK infix__S_327minmax__PEEK infix__S_328DotDotDot__PEEK infix__S_334and__PEEK infix__S_335andthen__PEEK infix__S_336or__PEEK infix__S_337orelse__PEEK infix__S_338xor__PEEK infix__S_339LtEqualEqual__PEEK infix__S_340EqualEqualGt__PEEK infix__S_341LtLtEqualEqual__PEEK infix__S_342EqualEqualGtGt__PEEK/ ],
infix_circumfix_meta_operator => [ qw/infix_circumfix_meta_operator__S_204Fre_Nch__PEEK infix_circumfix_meta_operator__S_205LtLt_GtGt__PEEK/ ],
infix_postfix_meta_operator => [ qw/infix_postfix_meta_operator__S_206Equal__PEEK/ ],
infix_prefix_meta_operator => [ qw/infix_prefix_meta_operator__S_199Bang__PEEK infix_prefix_meta_operator__S_200R__PEEK infix_prefix_meta_operator__S_201S__PEEK infix_prefix_meta_operator__S_202X__PEEK infix_prefix_meta_operator__S_203Z__PEEK/ ],
module_name => [ qw/module_name__S_039normal__PEEK/ ],
multi_declarator => [ qw/multi_declarator__S_058multi__PEEK multi_declarator__S_059proto__PEEK multi_declarator__S_060only__PEEK multi_declarator__S_061null__PEEK/ ],
package_declarator => [ qw/package_declarator__S_048class__PEEK package_declarator__S_049grammar__PEEK package_declarator__S_050module__PEEK package_declarator__S_051package__PEEK package_declarator__S_052role__PEEK package_declarator__S_053knowhow__PEEK package_declarator__S_054slang__PEEK package_declarator__S_055require__PEEK package_declarator__S_056trusts__PEEK package_declarator__S_057also__PEEK/ ],
postcircumfix => [ qw/postcircumfix__S_207Paren_Thesis__PEEK postcircumfix__S_208Bra_Ket__PEEK postcircumfix__S_209Cur_Ly__PEEK postcircumfix__S_210Lt_Gt__PEEK postcircumfix__S_211LtLt_GtGt__PEEK postcircumfix__S_212Fre_Nch__PEEK/ ],
postfix => [ qw/postfix__S_215i__PEEK postfix__S_217MinusGt__PEEK postfix__S_218PlusPlus__PEEK postfix__S_219MinusMinus__PEEK/ ],
postfix_prefix_meta_operator => [ qw/postfix_prefix_meta_operator__S_198Nch__PEEK/ ],
prefix => [ qw/prefix__S_220PlusPlus__PEEK prefix__S_221MinusMinus__PEEK prefix__S_223Bang__PEEK prefix__S_224Plus__PEEK prefix__S_225Minus__PEEK prefix__S_226TildeTilde__PEEK prefix__S_227Tilde__PEEK prefix__S_228QuestionQuestion__PEEK prefix__S_229Question__PEEK prefix__S_230TildeCaret__PEEK prefix__S_231PlusCaret__PEEK prefix__S_232QuestionCaret__PEEK prefix__S_233CaretCaret__PEEK prefix__S_234Caret__PEEK prefix__S_235VertVert__PEEK prefix__S_236Vert__PEEK prefix__S_266sleep__PEEK prefix__S_267abs__PEEK prefix__S_268let__PEEK prefix__S_269temp__PEEK prefix__S_321so__PEEK prefix__S_322not__PEEK/ ],
prefix_circumfix_meta_operator => [ qw/prefix_circumfix_meta_operator__S_196reduce__PEEK/ ],
prefix_postfix_meta_operator => [ qw/prefix_postfix_meta_operator__S_197Fre__PEEK/ ],
quote => [ qw/quote__S_141SlashSlash__PEEK quote__S_142Slash_Slash__PEEK quote__S_143qq__PEEK quote__S_144q__PEEK quote__S_145Q__PEEK quote__S_157rx__PEEK quote__S_158m__PEEK quote__S_159mm__PEEK quote__S_160s__PEEK quote__S_161ss__PEEK quote__S_162tr__PEEK quote__S_163y__PEEK quote__S_164quasi__PEEK/ ],
quote_mod => [ qw/quote_mod__S_146w__PEEK quote_mod__S_147ww__PEEK quote_mod__S_148p__PEEK quote_mod__S_149x__PEEK quote_mod__S_150to__PEEK quote_mod__S_151s__PEEK quote_mod__S_152a__PEEK quote_mod__S_153h__PEEK quote_mod__S_154f__PEEK quote_mod__S_155c__PEEK quote_mod__S_156b__PEEK/ ],
regex_declarator => [ qw/regex_declarator__S_066regex__PEEK regex_declarator__S_067token__PEEK regex_declarator__S_068rule__PEEK/ ],
routine_declarator => [ qw/routine_declarator__S_062sub__PEEK routine_declarator__S_063method__PEEK routine_declarator__S_064submethod__PEEK routine_declarator__S_065macro__PEEK/ ],
scope_declarator => [ qw/scope_declarator__S_041my__PEEK scope_declarator__S_042our__PEEK scope_declarator__S_043anon__PEEK scope_declarator__S_044state__PEEK scope_declarator__S_045has__PEEK scope_declarator__S_046augment__PEEK scope_declarator__S_047supersede__PEEK/ ],
special_variable => [ qw/special_variable__S_091Dollar_a2___PEEK special_variable__S_092DollarBang__PEEK special_variable__S_093DollarBangCur_Ly__PEEK special_variable__S_094DollarSlash__PEEK special_variable__S_095DollarTilde__PEEK special_variable__S_096DollarGrave__PEEK special_variable__S_097DollarAt__PEEK special_variable__S_098DollarSharp__PEEK special_variable__S_099DollarDollar__PEEK special_variable__S_100DollarPercent__PEEK special_variable__S_101DollarCaretX__PEEK special_variable__S_102DollarCaret__PEEK special_variable__S_103DollarAmp__PEEK special_variable__S_104DollarStar__PEEK special_variable__S_105DollarThesis__PEEK special_variable__S_106DollarMinus__PEEK special_variable__S_107DollarEqual__PEEK special_variable__S_108AtPlus__PEEK special_variable__S_109PercentPlus__PEEK special_variable__S_110DollarPlusBra_Ket__PEEK special_variable__S_111AtPlusBra_Ket__PEEK special_variable__S_112AtPlusCur_Ly__PEEK special_variable__S_113AtMinus__PEEK special_variable__S_114PercentMinus__PEEK special_variable__S_115DollarMinusBra_Ket__PEEK special_variable__S_116AtMinusBra_Ket__PEEK special_variable__S_117PercentMinusCur_Ly__PEEK special_variable__S_118DollarPlus__PEEK special_variable__S_119DollarCurCaret_Ly__PEEK special_variable__S_120ColonColonCur_Ly__PEEK special_variable__S_121DollarCur_Ly__PEEK special_variable__S_122DollarBra__PEEK special_variable__S_123DollarKet__PEEK special_variable__S_124DollarBack__PEEK special_variable__S_125DollarVert__PEEK special_variable__S_126DollarColon__PEEK special_variable__S_127DollarSemi__PEEK special_variable__S_128DollarSingle__PEEK special_variable__S_129DollarDouble__PEEK special_variable__S_130DollarComma__PEEK special_variable__S_131DollarLt__PEEK special_variable__S_132DollarGt__PEEK special_variable__S_133DollarDot__PEEK special_variable__S_134DollarQuestion__PEEK/ ],
statement_control => [ qw/statement_control__S_000need__PEEK statement_control__S_001import__PEEK statement_control__S_002use__PEEK statement_control__S_003no__PEEK statement_control__S_004if__PEEK statement_control__S_005unless__PEEK statement_control__S_006while__PEEK statement_control__S_007until__PEEK statement_control__S_008repeat__PEEK statement_control__S_009loop__PEEK statement_control__S_010for__PEEK statement_control__S_011foreach__PEEK statement_control__S_012given__PEEK statement_control__S_013when__PEEK statement_control__S_014default__PEEK statement_control__S_029CATCH__PEEK statement_control__S_030CONTROL__PEEK statement_control__S_031TEMP__PEEK/ ],
statement_mod_cond => [ qw/statement_mod_cond__S_032if__PEEK statement_mod_cond__S_033unless__PEEK statement_mod_cond__S_034when__PEEK/ ],
statement_mod_loop => [ qw/statement_mod_loop__S_035while__PEEK statement_mod_loop__S_036until__PEEK statement_mod_loop__S_037for__PEEK statement_mod_loop__S_038given__PEEK/ ],
statement_prefix => [ qw/statement_prefix__S_015BEGIN__PEEK statement_prefix__S_016CHECK__PEEK statement_prefix__S_017INIT__PEEK statement_prefix__S_018START__PEEK statement_prefix__S_019ENTER__PEEK statement_prefix__S_020FIRST__PEEK statement_prefix__S_021END__PEEK statement_prefix__S_022LEAVE__PEEK statement_prefix__S_023KEEP__PEEK statement_prefix__S_024UNDO__PEEK statement_prefix__S_025NEXT__PEEK statement_prefix__S_026LAST__PEEK statement_prefix__S_027PRE__PEEK statement_prefix__S_028POST__PEEK statement_prefix__S_168sink__PEEK statement_prefix__S_169try__PEEK statement_prefix__S_170quietly__PEEK statement_prefix__S_171gather__PEEK statement_prefix__S_172contend__PEEK statement_prefix__S_173async__PEEK statement_prefix__S_174maybe__PEEK statement_prefix__S_175lazy__PEEK statement_prefix__S_176do__PEEK statement_prefix__S_177lift__PEEK/ ],
strtonum => [ qw/strtonum__S_138rational__PEEK strtonum__S_139complex__PEEK strtonum__S_140number__PEEK/ ],
term => [ qw/term__S_076fatarrow__PEEK term__S_077variable__PEEK term__S_078package_declarator__PEEK term__S_079scope_declarator__PEEK term__S_080multi_declarator__PEEK term__S_081routine_declarator__PEEK term__S_082regex_declarator__PEEK term__S_083type_declarator__PEEK term__S_084circumfix__PEEK term__S_085dotty__PEEK term__S_086value__PEEK term__S_087capterm__PEEK term__S_088sigterm__PEEK term__S_089statement_prefix__PEEK term__S_090colonpair__PEEK term__S_178new__PEEK term__S_179ColonColonQuestionIDENT__PEEK term__S_180Object__PEEK term__S_181undef__PEEK term__S_182proceed__PEEK term__S_183time__PEEK term__S_184now__PEEK term__S_185self__PEEK term__S_186defer__PEEK term__S_187rand__PEEK term__S_188Star__PEEK term__S_189StarStar__PEEK term__S_213lambda__PEEK term__S_329DotDotDot__PEEK term__S_330QuestionQuestionQuestion__PEEK term__S_331BangBangBang__PEEK term__S_332identifier__PEEK term__S_333name__PEEK/ ],
terminator => [ qw/terminator__S_343Semi__PEEK terminator__S_344if__PEEK terminator__S_345unless__PEEK terminator__S_346while__PEEK terminator__S_347until__PEEK terminator__S_348for__PEEK terminator__S_349given__PEEK terminator__S_350when__PEEK terminator__S_351MinusMinusGt__PEEK terminator__S_352BangBang__PEEK/ ],
trait_mod => [ qw/trait_mod__S_069is__PEEK trait_mod__S_070hides__PEEK trait_mod__S_071does__PEEK trait_mod__S_072will__PEEK trait_mod__S_073of__PEEK trait_mod__S_074as__PEEK trait_mod__S_075handles__PEEK/ ],
type_declarator => [ qw/type_declarator__S_165subset__PEEK type_declarator__S_166enum__PEEK type_declarator__S_167constant__PEEK/ ],
value => [ qw/value__S_135quote__PEEK value__S_136number__PEEK value__S_137version__PEEK/ ],
version => [ qw/version__S_040v__PEEK/ ],
};


no warnings 'qw', 'recursion';
my $retree;

$DB::deep = $DB::deep = 1000; # suppress used-once warning

use YAML::XS;

$SIG{__WARN__} = sub { die @_,"   statement started at line ", 'Cursor'->lineof($::LASTSTATE), "
" } if $::DEBUG;

$retree = YAML::XS::Load(Encode::encode_utf8(<<'RETREE_END'));
---
POST: !!perl/hash:RE_ast
  dba: postfix
  dic: STD::P6
  re: !!perl/hash:RE_sequence
    zyg:
    - !!perl/hash:RE_assertion
      assert: '!'
      re: !!perl/hash:RE_method
        name: stdstopper
        rest: ''
    - !!perl/hash:RE_assertion
      assert: '!'
      re: !!perl/hash:RE_block
        nobind: 1
    - !!perl/hash:RE_quantified_atom
      atom: !!perl/hash:RE_bracket
        re: &1 !!perl/hash:RE_any
          altname: POST_0
          dba: POST
          dic: STD::P6
          zyg:
          - !!perl/hash:RE_method
            alt: POST_0 0
            name: unsp
            rest: ''
          - !!perl/hash:RE_string
            alt: POST_0 1
            i: 0
            text: \
      quant:
      - '?'
    - !!perl/hash:RE_quantified_atom
      atom: !!perl/hash:RE_bracket
        re: !!perl/hash:RE_sequence
          zyg:
          - !!perl/hash:RE_quantified_atom
            atom: !!perl/hash:RE_bracket
              re: !!perl/hash:RE_sequence
                zyg:
                - !!perl/hash:RE_string
                  i: 0
                  text: .
                - !!perl/hash:RE_quantified_atom
                  atom: !!perl/hash:RE_method
                    name: unsp
                    rest: ''
                  quant:
                  - '?'
            quant:
            - '?'
          - !!perl/hash:RE_method
            name: postfix_prefix_meta_operator
            rest: ''
          - !!perl/hash:RE_quantified_atom
            atom: !!perl/hash:RE_method
              name: unsp
              rest: ''
            quant:
            - '?'
      quant:
      - '*'
    - !!perl/hash:RE_bracket
      re: &2 !!perl/hash:RE_any
        altname: POST_1
        dba: postfix
        dic: STD::P6
        zyg:
        - !!perl/hash:RE_sequence
          alt: POST_1 0
          zyg:
          - !!perl/hash:RE_method
            name: dotty
            rest: ''
          - !!perl/hash:RE_block {}
        - !!perl/hash:RE_sequence
          alt: POST_1 1
          zyg:
          - !!perl/hash:RE_method
            name: privop
            rest: ''
          - !!perl/hash:RE_block {}
        - !!perl/hash:RE_sequence
          alt: POST_1 2
          zyg:
          - !!perl/hash:RE_method
            name: postop
            rest: ''
          - !!perl/hash:RE_block {}
    - !!perl/hash:RE_block {}
POST_0: *1
POST_1: *2
PRE: !!perl/hash:RE_ast
  dba: prefix or meta-prefix
  dic: STD::P6
  re: !!perl/hash:RE_sequence
    zyg:
    - !!perl/hash:RE_bracket
      re: &3 !!perl/hash:RE_any
        altname: PRE_0
        dba: prefix or meta-prefix
        dic: STD::P6
        zyg:
        - !!perl/hash:RE_sequence
          alt: PRE_0 0
          zyg:
          - !!perl/hash:RE_method
            name: prefix
            rest: ''
          - !!perl/hash:RE_block {}
        - !!perl/hash:RE_sequence
          alt: PRE_0 1
          zyg:
          - !!perl/hash:RE_method
            name: prefix_circumfix_meta_operator
            rest: ''
          - !!perl/hash:RE_block {}
    - !!perl/hash:RE_quantified_atom
      atom: !!perl/hash:RE_method
        name: prefix_postfix_meta_operator
        rest: ''
      quant:
      - '*'
    - !!perl/hash:RE_method
      name: ws
      rest: ''
PRE_0: *3
arglist: !!perl/hash:RE_ast
  dba: argument list
  dic: STD::P6
  re: !!perl/hash:RE_sequence
    zyg:
    - !!perl/hash:RE_method
      name: ws
      rest: ''
    - !!perl/hash:RE_bracket
      re: &4 !!perl/hash:RE_any
        altname: arglist_0
        dba: argument list
        dic: STD::P6
        zyg:
        - !!perl/hash:RE_assertion
          alt: arglist_0 0
          assert: '?'
          re: !!perl/hash:RE_method
            name: stdstopper
            rest: ''
        - !!perl/hash:RE_sequence
          alt: arglist_0 1
          zyg:
          - !!perl/hash:RE_method
            name: EXPR
            rest: 1
          - !!perl/hash:RE_block {}
arglist_0: *4
args: !!perl/hash:RE_ast
  dba: 'extra arglist after (...):'
  dic: STD::P6
  re: !!perl/hash:RE_sequence
    zyg:
    - !!perl/hash:RE_bracket
      re: &5 !!perl/hash:RE_any
        altname: args_0
        dba: argument list
        dic: STD::P6
        zyg:
        - !!perl/hash:RE_bracket
          alt: args_0 0
          re: !!perl/hash:RE_sequence
            zyg:
            - !!perl/hash:RE_string
              i: 0
              text: (
            - !!perl/hash:RE_block {}
            - !!perl/hash:RE_method
              name: semiarglist
              rest: ''
            - !!perl/hash:RE_bracket
              re: !!perl/hash:RE_first
                zyg:
                - !!perl/hash:RE_string
                  i: 0
                  text: )
                - !!perl/hash:RE_method
                  name: FAILGOAL
                  rest: 1
        - !!perl/hash:RE_sequence
          alt: args_0 1
          zyg:
          - !!perl/hash:RE_method
            name: unsp
            rest: ''
          - !!perl/hash:RE_bracket
            re: !!perl/hash:RE_sequence
              zyg:
              - !!perl/hash:RE_string
                i: 0
                text: (
              - !!perl/hash:RE_block {}
              - !!perl/hash:RE_method
                name: semiarglist
                rest: ''
              - !!perl/hash:RE_bracket
                re: !!perl/hash:RE_first
                  zyg:
                  - !!perl/hash:RE_string
                    i: 0
                    text: )
                  - !!perl/hash:RE_method
                    name: FAILGOAL
                    rest: 1
        - !!perl/hash:RE_sequence
          alt: args_0 2
          zyg:
          - !!perl/hash:RE_block {}
          - !!perl/hash:RE_quantified_atom
            atom: !!perl/hash:RE_bracket
              re: !!perl/hash:RE_sequence
                zyg:
                - !!perl/hash:RE_assertion
                  assert: '?'
                  re: !!perl/hash:RE_method_re
                    name: before
                    nobind: 1
                    re: !!perl/hash:RE_meta
                      min: 1
                      text: \s
                - !!perl/hash:RE_assertion
                  assert: '!'
                  re: !!perl/hash:RE_block
                    nobind: 1
                - !!perl/hash:RE_method
                  name: ws
                  rest: ''
                - !!perl/hash:RE_assertion
                  assert: '!'
                  re: !!perl/hash:RE_method
                    name: infixstopper
                    rest: ''
                - !!perl/hash:RE_method
                  name: arglist
                  rest: ''
            quant:
            - '?'
    - !!perl/hash:RE_block {}
    - !!perl/hash:RE_bracket
      re: !!perl/hash:RE_first
        zyg:
        - !!perl/hash:RE_assertion
          assert: '?'
          re: !!perl/hash:RE_block
            nobind: 1
        - !!perl/hash:RE_sequence
          zyg:
          - !!perl/hash:RE_string
            i: 0
            text: ':'
          - !!perl/hash:RE_assertion
            assert: '?'
            re: !!perl/hash:RE_method_re
              name: before
              nobind: 1
              re: !!perl/hash:RE_meta
                min: 1
                text: \s
          - !!perl/hash:RE_bindnamed
            atom: !!perl/hash:RE_method
              name: arglist
              rest: ''
        - !!perl/hash:RE_block {}
args_0: *5
blast: !!perl/hash:RE_ast
  dba: blast
  dic: STD::P6
  re: !!perl/hash:RE_sequence
    zyg:
    - !!perl/hash:RE_assertion
      assert: '?'
      re: !!perl/hash:RE_method_re
        name: before
        nobind: 1
        re: !!perl/hash:RE_meta
          min: 1
          text: \s
    - !!perl/hash:RE_method
      name: ws
      rest: ''
    - !!perl/hash:RE_bracket
      re: &6 !!perl/hash:RE_any
        altname: blast_0
        dba: blast
        dic: STD::P6
        zyg:
        - !!perl/hash:RE_method
          alt: blast_0 0
          name: block
          rest: ''
        - !!perl/hash:RE_method
          alt: blast_0 1
          name: statement
          rest: ''
blast_0: *6
block: !!perl/hash:RE_ast
  dba: scoped block
  dic: STD::P6
  re: !!perl/hash:RE_sequence
    zyg:
    - !!perl/hash:RE_bracket
      re: !!perl/hash:RE_first
        zyg:
        - !!perl/hash:RE_assertion
          assert: '?'
          re: !!perl/hash:RE_method_re
            name: before
            nobind: 1
            re: !!perl/hash:RE_string
              i: 0
              text: '{'
        - !!perl/hash:RE_method
          name: panic
          rest: 1
    - !!perl/hash:RE_method
      name: newlex
      rest: ''
    - !!perl/hash:RE_method
      name: blockoid
      rest: ''
    - !!perl/hash:RE_method
      name: checkyada
      rest: ''
blockoid: !!perl/hash:RE_ast
  dba: blockoid
  dic: STD::P6
  re: !!perl/hash:RE_sequence
    zyg:
    - !!perl/hash:RE_method
      name: finishlex
      rest: ''
    - !!perl/hash:RE_bracket
      re: &7 !!perl/hash:RE_any
        altname: blockoid_0
        dba: block
        dic: STD::P6
        zyg:
        - !!perl/hash:RE_sequence
          alt: blockoid_0 0
          zyg:
          - !!perl/hash:RE_string
            i: 0
            text: '{YOU_ARE_HERE}'
          - !!perl/hash:RE_method
            name: you_are_here
            rest: ''
        - !!perl/hash:RE_sequence
          alt: blockoid_0 1
          zyg:
          - !!perl/hash:RE_bracket
            re: !!perl/hash:RE_sequence
              zyg:
              - !!perl/hash:RE_string
                i: 0
                text: '{'
              - !!perl/hash:RE_block {}
              - !!perl/hash:RE_method
                name: statementlist
                rest: ''
              - !!perl/hash:RE_bracket
                re: !!perl/hash:RE_first
                  zyg:
                  - !!perl/hash:RE_string
                    i: 0
                    text: '}'
                  - !!perl/hash:RE_method
                    name: FAILGOAL
                    rest: 1
          - !!perl/hash:RE_meta
            text: '::'
          - !!perl/hash:RE_method
            name: curlycheck
            rest: ''
        - !!perl/hash:RE_sequence
          alt: blockoid_0 2
          zyg:
          - !!perl/hash:RE_assertion
            assert: '?'
            re: !!perl/hash:RE_method
              name: terminator
              rest: ''
          - !!perl/hash:RE_method
            name: panic
            rest: 1
        - !!perl/hash:RE_sequence
          alt: blockoid_0 3
          zyg:
          - !!perl/hash:RE_assertion
            assert: '?'
            re: !!perl/hash:RE_noop
              nobind: 1
          - !!perl/hash:RE_method
            name: panic
            rest: 1
blockoid_0: *7
capterm: !!perl/hash:RE_ast
  dba: capterm
  dic: STD::P6
  re: !!perl/hash:RE_sequence
    zyg:
    - !!perl/hash:RE_string
      i: 0
      text: \
    - !!perl/hash:RE_bracket
      re: &8 !!perl/hash:RE_any
        altname: capterm_0
        dba: capterm
        dic: STD::P6
        zyg:
        - !!perl/hash:RE_sequence
          alt: capterm_0 0
          zyg:
          - !!perl/hash:RE_string
            i: 0
            text: (
          - !!perl/hash:RE_quantified_atom
            atom: !!perl/hash:RE_method
              name: capture
              rest: ''
            quant:
            - '?'
          - !!perl/hash:RE_string
            i: 0
            text: )
        - !!perl/hash:RE_sequence
          alt: capterm_0 1
          zyg:
          - !!perl/hash:RE_assertion
            assert: '?'
            re: !!perl/hash:RE_method_re
              name: before
              nobind: 1
              re: !!perl/hash:RE_meta
                min: 1
                text: \S
          - !!perl/hash:RE_method
            name: termish
            rest: ''
        - !!perl/hash:RE_sequence
          alt: capterm_0 2
          zyg:
          - !!perl/hash:RE_block {}
          - !!perl/hash:RE_method
            name: panic
            rest: 1
capterm_0: *8
capture: !!perl/hash:RE_ast
  dba: capture
  dic: STD::P6
  re: !!perl/hash:RE_sequence
    zyg:
    - !!perl/hash:RE_method
      name: ws
      rest: ''
    - !!perl/hash:RE_method
      name: EXPR
      rest: ''
    - !!perl/hash:RE_method
      name: ws
      rest: ''
circumfix__S_191sigil: !!perl/hash:RE_ast
  dba: contextualizer
  dic: STD::P6
  re: !!perl/hash:RE_sequence
    zyg:
    - !!perl/hash:RE_method
      name: sigil
      rest: ''
    - !!perl/hash:RE_bracket
      re: !!perl/hash:RE_sequence
        zyg:
        - !!perl/hash:RE_string
          i: 0
          text: (
        - !!perl/hash:RE_block {}
        - !!perl/hash:RE_method
          name: semilist
          rest: ''
        - !!perl/hash:RE_bracket
          re: !!perl/hash:RE_first
            zyg:
            - !!perl/hash:RE_string
              i: 0
              text: )
            - !!perl/hash:RE_method
              name: FAILGOAL
              rest: 1
    - !!perl/hash:RE_block {}
    - !!perl/hash:RE_method
      name: O
      rest: 1
circumfix__S_192Paren_Thesis: !!perl/hash:RE_ast
  dba: parenthesized expression
  dic: STD::P6
  re: !!perl/hash:RE_sequence
    zyg:
    - !!perl/hash:RE_bracket
      re: !!perl/hash:RE_sequence
        zyg:
        - !!perl/hash:RE_string
          i: 0
          text: (
        - !!perl/hash:RE_block {}
        - !!perl/hash:RE_method
          name: semilist
          rest: ''
        - !!perl/hash:RE_bracket
          re: !!perl/hash:RE_first
            zyg:
            - !!perl/hash:RE_string
              i: 0
              text: )
            - !!perl/hash:RE_method
              name: FAILGOAL
              rest: 1
    - !!perl/hash:RE_method
      name: O
      rest: 1
circumfix__S_193Bra_Ket: !!perl/hash:RE_ast
  dba: array composer
  dic: STD::P6
  re: !!perl/hash:RE_sequence
    zyg:
    - !!perl/hash:RE_bracket
      re: !!perl/hash:RE_sequence
        zyg:
        - !!perl/hash:RE_string
          i: 0
          text: '['
        - !!perl/hash:RE_block {}
        - !!perl/hash:RE_method
          name: semilist
          rest: ''
        - !!perl/hash:RE_bracket
          re: !!perl/hash:RE_first
            zyg:
            - !!perl/hash:RE_string
              i: 0
              text: ']'
            - !!perl/hash:RE_method
              name: FAILGOAL
              rest: 1
    - !!perl/hash:RE_method
      name: O
      rest: 1
    - !!perl/hash:RE_block {}
circumfix__S_214Cur_Ly: !!perl/hash:RE_ast
  dba: circumfix
  dic: STD::P6
  re: !!perl/hash:RE_sequence
    zyg:
    - !!perl/hash:RE_assertion
      assert: '?'
      re: !!perl/hash:RE_method_re
        name: before
        nobind: 1
        re: !!perl/hash:RE_string
          i: 0
          text: '{'
    - !!perl/hash:RE_method
      name: pblock
      rest: ''
    - !!perl/hash:RE_block {}
    - !!perl/hash:RE_method
      name: O
      rest: 1
coloncircumfix: !!perl/hash:RE_ast
  dba: coloncircumfix
  dic: STD::P6
  re: !!perl/hash:RE_bracket
    re: &9 !!perl/hash:RE_any
      altname: coloncircumfix_0
      dba: coloncircumfix
      dic: STD::P6
      zyg:
      - !!perl/hash:RE_sequence
        alt: coloncircumfix_0 0
        zyg:
        - !!perl/hash:RE_string
          i: 0
          text: <>
        - !!perl/hash:RE_method
          name: worry
          rest: 1
      - !!perl/hash:RE_method
        alt: coloncircumfix_0 1
        name: circumfix
        rest: ''
coloncircumfix_0: *9
colonpair: !!perl/hash:RE_ast
  dba: colon pair
  dic: STD::P6
  re: !!perl/hash:RE_sequence
    zyg:
    - !!perl/hash:RE_string
      i: 0
      text: ':'
    - !!perl/hash:RE_bracket
      re: &10 !!perl/hash:RE_any
        altname: colonpair_0
        dba: signature
        dic: STD::P6
        zyg:
        - !!perl/hash:RE_sequence
          alt: colonpair_0 0
          zyg:
          - !!perl/hash:RE_string
            i: 0
            text: '!'
          - !!perl/hash:RE_meta
            text: '::'
          - !!perl/hash:RE_bracket
            re: !!perl/hash:RE_first
              zyg:
              - !!perl/hash:RE_method
                name: identifier
                rest: ''
              - !!perl/hash:RE_method
                name: panic
                rest: 1
          - !!perl/hash:RE_quantified_atom
            atom: !!perl/hash:RE_bracket
              re: !!perl/hash:RE_sequence
                zyg:
                - !!perl/hash:RE_assertion
                  assert: '?'
                  re: !!perl/hash:RE_method_re
                    name: before
                    nobind: 1
                    re: !!perl/hash:RE_cclass
                      i: 0
                      text: '[ \[ \( \< \{ ]'
                - !!perl/hash:RE_method
                  name: panic
                  rest: 1
            quant:
            - '?'
          - !!perl/hash:RE_block {}
        - !!perl/hash:RE_sequence
          alt: colonpair_0 1
          zyg:
          - !!perl/hash:RE_bindnamed
            atom: !!perl/hash:RE_bracket
              re: !!perl/hash:RE_quantified_atom
                atom: !!perl/hash:RE_meta
                  min: 1
                  text: \d
                quant:
                - +
          - !!perl/hash:RE_method
            name: identifier
            rest: ''
          - !!perl/hash:RE_quantified_atom
            atom: !!perl/hash:RE_bracket
              re: !!perl/hash:RE_sequence
                zyg:
                - !!perl/hash:RE_assertion
                  assert: '?'
                  re: !!perl/hash:RE_method_re
                    name: before
                    nobind: 1
                    re: !!perl/hash:RE_cclass
                      i: 0
                      text: '[ \[ \( \< \{ ]'
                - !!perl/hash:RE_method
                  name: sorry
                  rest: 1
                - !!perl/hash:RE_method
                  name: circumfix
                  rest: ''
            quant:
            - '?'
        - !!perl/hash:RE_sequence
          alt: colonpair_0 2
          zyg:
          - !!perl/hash:RE_method
            name: identifier
            rest: ''
          - !!perl/hash:RE_block {}
          - !!perl/hash:RE_bracket
            re: !!perl/hash:RE_first
              zyg:
              - !!perl/hash:RE_sequence
                zyg:
                - !!perl/hash:RE_quantified_atom
                  atom: !!perl/hash:RE_method
                    name: unsp
                    rest: ''
                  quant:
                  - '?'
                - !!perl/hash:RE_method
                  name: coloncircumfix
                  rest: 1
                - !!perl/hash:RE_block {}
              - !!perl/hash:RE_block {}
        - !!perl/hash:RE_bracket
          alt: colonpair_0 3
          re: !!perl/hash:RE_sequence
            zyg:
            - !!perl/hash:RE_string
              i: 0
              text: (
            - !!perl/hash:RE_block {}
            - !!perl/hash:RE_method
              name: fakesignature
              rest: ''
            - !!perl/hash:RE_bracket
              re: !!perl/hash:RE_first
                zyg:
                - !!perl/hash:RE_string
                  i: 0
                  text: )
                - !!perl/hash:RE_method
                  name: FAILGOAL
                  rest: 1
        - !!perl/hash:RE_sequence
          alt: colonpair_0 4
          zyg:
          - !!perl/hash:RE_method
            name: coloncircumfix
            rest: 1
          - !!perl/hash:RE_block {}
        - !!perl/hash:RE_sequence
          alt: colonpair_0 5
          zyg:
          - !!perl/hash:RE_bindnamed
            atom: !!perl/hash:RE_paren
              re: !!perl/hash:RE_sequence
                zyg:
                - !!perl/hash:RE_method
                  name: sigil
                  rest: ''
                - !!perl/hash:RE_block {}
                - !!perl/hash:RE_bracket
                  re: &11 !!perl/hash:RE_any
                    altname: colonpair_1
                    dba: signature
                    dic: STD::P6
                    zyg:
                    - !!perl/hash:RE_sequence
                      alt: colonpair_1 0
                      zyg:
                      - !!perl/hash:RE_quantified_atom
                        atom: !!perl/hash:RE_method
                          name: twigil
                          rest: ''
                        quant:
                        - '?'
                      - !!perl/hash:RE_method
                        name: desigilname
                        rest: ''
                    - !!perl/hash:RE_sequence
                      alt: colonpair_1 1
                      zyg:
                      - !!perl/hash:RE_string
                        i: 0
                        text: <
                      - !!perl/hash:RE_method
                        name: desigilname
                        rest: ''
                      - !!perl/hash:RE_string
                        i: 0
                        text: '>'
          - !!perl/hash:RE_block {}
    - !!perl/hash:RE_block {}
colonpair_0: *10
colonpair_1: *11
comp_unit: !!perl/hash:RE_ast
  dba: comp_unit
  dic: STD::P6
  re: !!perl/hash:RE_sequence
    zyg:
    - !!perl/hash:RE_method
      name: ws
      rest: ''
    - !!perl/hash:RE_block {}
    - !!perl/hash:RE_method
      name: unitstart
      rest: ''
    - !!perl/hash:RE_method
      name: ws
      rest: ''
    - !!perl/hash:RE_method
      name: statementlist
      rest: ''
    - !!perl/hash:RE_method
      name: ws
      rest: ''
    - !!perl/hash:RE_bracket
      re: !!perl/hash:RE_first
        zyg:
        - !!perl/hash:RE_assertion
          assert: '?'
          re: !!perl/hash:RE_method
            name: unitstopper
            rest: ''
        - !!perl/hash:RE_sequence
          zyg:
          - !!perl/hash:RE_method
            name: panic
            rest: 1
          - !!perl/hash:RE_method
            name: ws
            rest: ''
    - !!perl/hash:RE_block {}
curlycheck: !!perl/hash:RE_ast
  dba: curlycheck
  dic: STD::P6
  re: !!perl/hash:RE_bracket
    re: !!perl/hash:RE_first
      zyg:
      - !!perl/hash:RE_sequence
        zyg:
        - !!perl/hash:RE_assertion
          assert: '?'
          re: !!perl/hash:RE_method_re
            name: before
            nobind: 1
            re: !!perl/hash:RE_sequence
              zyg:
              - !!perl/hash:RE_quantified_atom
                atom: !!perl/hash:RE_meta
                  min: 1
                  text: \h
                quant:
                - '*'
              - !!perl/hash:RE_meta
                text: $$
        - !!perl/hash:RE_block {}
      - !!perl/hash:RE_assertion
        assert: '?'
        re: !!perl/hash:RE_method_re
          name: before
          nobind: 1
          re: !!perl/hash:RE_sequence
            zyg:
            - !!perl/hash:RE_quantified_atom
              atom: !!perl/hash:RE_meta
                min: 1
                text: \h
              quant:
              - '*'
            - !!perl/hash:RE_cclass
              i: 0
              text: '[\\,:]'
      - !!perl/hash:RE_sequence
        zyg:
        - !!perl/hash:RE_method
          name: unv
          rest: ''
        - !!perl/hash:RE_meta
          text: $$
        - !!perl/hash:RE_block {}
      - !!perl/hash:RE_sequence
        zyg:
        - !!perl/hash:RE_quantified_atom
          atom: !!perl/hash:RE_method
            name: unsp
            rest: ''
          quant:
          - '?'
        - !!perl/hash:RE_block {}
declarator: !!perl/hash:RE_ast
  dba: declarator
  dic: STD::P6
  re: !!perl/hash:RE_bracket
    re: &12 !!perl/hash:RE_any
      altname: declarator_0
      dba: declarator
      dic: STD::P6
      zyg:
      - !!perl/hash:RE_sequence
        alt: declarator_0 0
        zyg:
        - !!perl/hash:RE_method
          name: variable_declarator
          rest: ''
        - !!perl/hash:RE_quantified_atom
          atom: !!perl/hash:RE_bracket
            re: !!perl/hash:RE_assertion
              assert: '?'
              re: !!perl/hash:RE_method_re
                name: before
                nobind: 1
                re: !!perl/hash:RE_sequence
                  zyg:
                  - !!perl/hash:RE_method
                    name: ws
                    rest: ''
                  - !!perl/hash:RE_string
                    i: 0
                    text: ','
                  - !!perl/hash:RE_method
                    name: ws
                    rest: ''
                  - !!perl/hash:RE_block {}
          quant:
          - '?'
      - !!perl/hash:RE_sequence
        alt: declarator_0 1
        zyg:
        - !!perl/hash:RE_bracket
          re: !!perl/hash:RE_sequence
            zyg:
            - !!perl/hash:RE_string
              i: 0
              text: (
            - !!perl/hash:RE_block {}
            - !!perl/hash:RE_method
              name: signature
              rest: ''
            - !!perl/hash:RE_bracket
              re: !!perl/hash:RE_first
                zyg:
                - !!perl/hash:RE_string
                  i: 0
                  text: )
                - !!perl/hash:RE_method
                  name: FAILGOAL
                  rest: 1
        - !!perl/hash:RE_quantified_atom
          atom: !!perl/hash:RE_method
            name: trait
            rest: ''
          quant:
          - '*'
      - !!perl/hash:RE_method
        alt: declarator_0 2
        name: routine_declarator
        rest: ''
      - !!perl/hash:RE_method
        alt: declarator_0 3
        name: regex_declarator
        rest: ''
      - !!perl/hash:RE_method
        alt: declarator_0 4
        name: type_declarator
        rest: ''
declarator_0: *12
default_value: !!perl/hash:RE_ast
  dba: default_value
  dic: STD::P6
  re: !!perl/hash:RE_sequence
    zyg:
    - !!perl/hash:RE_method
      name: ws
      rest: ''
    - !!perl/hash:RE_string
      i: 0
      text: =
    - !!perl/hash:RE_method
      name: ws
      rest: ''
    - !!perl/hash:RE_method
      name: EXPR
      rest: 1
    - !!perl/hash:RE_method
      name: ws
      rest: ''
deflongname: !!perl/hash:RE_ast
  dba: new name to be defined
  dic: STD::P6
  re: !!perl/hash:RE_sequence
    zyg:
    - !!perl/hash:RE_method
      name: name
      rest: ''
    - !!perl/hash:RE_bracket
      re: &13 !!perl/hash:RE_any
        altname: deflongname_0
        dba: new name to be defined
        dic: STD::P6
        zyg:
        - !!perl/hash:RE_sequence
          alt: deflongname_0 0
          zyg:
          - !!perl/hash:RE_quantified_atom
            atom: !!perl/hash:RE_method
              name: colonpair
              rest: ''
            quant:
            - +
          - !!perl/hash:RE_block {}
        - !!perl/hash:RE_block
          alt: deflongname_0 1
deflongname_0: *13
desigilname: !!perl/hash:RE_ast
  dba: desigilname
  dic: STD::P6
  re: !!perl/hash:RE_bracket
    re: &14 !!perl/hash:RE_any
      altname: desigilname_0
      dba: desigilname
      dic: STD::P6
      zyg:
      - !!perl/hash:RE_sequence
        alt: desigilname_0 0
        zyg:
        - !!perl/hash:RE_assertion
          assert: '?'
          re: !!perl/hash:RE_method_re
            name: before
            nobind: 1
            re: !!perl/hash:RE_string
              i: 0
              text: $
        - !!perl/hash:RE_quantified_atom
          atom: !!perl/hash:RE_bracket
            re: !!perl/hash:RE_sequence
              zyg:
              - !!perl/hash:RE_assertion
                assert: '?'
                re: !!perl/hash:RE_block
                  nobind: 1
              - !!perl/hash:RE_method
                name: panic
                rest: 1
          quant:
          - '?'
        - !!perl/hash:RE_method
          name: variable
          rest: ''
        - !!perl/hash:RE_block {}
      - !!perl/hash:RE_sequence
        alt: desigilname_0 1
        zyg:
        - !!perl/hash:RE_assertion
          assert: '?'
          re: !!perl/hash:RE_method_re
            name: before
            nobind: 1
            re: !!perl/hash:RE_sequence
              zyg:
              - !!perl/hash:RE_cclass
                i: 0
                text: '[\@\%\&]'
              - !!perl/hash:RE_quantified_atom
                atom: !!perl/hash:RE_method
                  name: sigil
                  rest: ''
                quant:
                - '*'
              - !!perl/hash:RE_meta
                min: 1
                text: \w
        - !!perl/hash:RE_method
          name: panic
          rest: 1
      - !!perl/hash:RE_method
        alt: desigilname_0 2
        name: longname
        rest: ''
desigilname_0: *14
dotty__S_194DotStar: !!perl/hash:RE_ast
  dba: dotty
  dic: STD::P6
  re: !!perl/hash:RE_sequence
    zyg:
    - !!perl/hash:RE_bindpos
      atom: !!perl/hash:RE_paren
        re: !!perl/hash:RE_sequence
          zyg:
          - !!perl/hash:RE_string
            i: 0
            text: .
          - !!perl/hash:RE_bracket
            re: &15 !!perl/hash:RE_any
              altname: dotty__S_194DotStar_0
              dba: dotty
              dic: STD::P6
              zyg:
              - !!perl/hash:RE_cclass
                alt: dotty__S_194DotStar_0 0
                i: 0
                text: '[+*?=]'
              - !!perl/hash:RE_sequence
                alt: dotty__S_194DotStar_0 1
                zyg:
                - !!perl/hash:RE_string
                  i: 0
                  text: ^
                - !!perl/hash:RE_quantified_atom
                  atom: !!perl/hash:RE_string
                    i: 0
                    text: '!'
                  quant:
                  - '?'
    - !!perl/hash:RE_meta
      text: '::'
    - !!perl/hash:RE_method
      name: unspacey
      rest: ''
    - !!perl/hash:RE_method
      name: dottyop
      rest: ''
    - !!perl/hash:RE_block {}
    - !!perl/hash:RE_method
      name: O
      rest: 1
dotty__S_194DotStar_0: *15
dotty__S_195Dot: !!perl/hash:RE_ast
  dba: dotty
  dic: STD::P6
  re: !!perl/hash:RE_sequence
    zyg:
    - !!perl/hash:RE_method
      endsym: unspacey
      i: 0
      name: sym
      rest: ''
      sym: .
    - !!perl/hash:RE_method
      name: unspacey
      rest: ''
    - !!perl/hash:RE_method
      name: dottyop
      rest: ''
    - !!perl/hash:RE_method
      name: O
      rest: 1
dottyop: !!perl/hash:RE_ast
  dba: dotty method or postfix
  dic: STD::P6
  re: !!perl/hash:RE_bracket
    re: &16 !!perl/hash:RE_any
      altname: dottyop_0
      dba: dotty method or postfix
      dic: STD::P6
      zyg:
      - !!perl/hash:RE_method
        alt: dottyop_0 0
        name: methodop
        rest: ''
      - !!perl/hash:RE_method
        alt: dottyop_0 1
        name: colonpair
        rest: ''
      - !!perl/hash:RE_sequence
        alt: dottyop_0 2
        zyg:
        - !!perl/hash:RE_assertion
          assert: '!'
          re: !!perl/hash:RE_method
            name: alpha
            rest: ''
        - !!perl/hash:RE_method
          name: postop
          rest: ''
        - !!perl/hash:RE_block {}
dottyop_0: *16
dottyopish: !!perl/hash:RE_ast
  dba: dottyopish
  dic: STD::P6
  re: !!perl/hash:RE_bindnamed
    atom: !!perl/hash:RE_method
      name: dottyop
      rest: ''
dumbsmart: !!perl/hash:RE_ast
  dba: dumbsmart
  dic: STD::P6
  re: !!perl/hash:RE_quantified_atom
    atom: !!perl/hash:RE_bracket
      re: !!perl/hash:RE_sequence
        zyg:
        - !!perl/hash:RE_quantified_atom
          atom: !!perl/hash:RE_meta
            min: 1
            text: \h
          quant:
          - '*'
        - !!perl/hash:RE_bindpos
          atom: !!perl/hash:RE_paren
            re: &17 !!perl/hash:RE_any
              altname: dumbsmart_0
              dba: dumbsmart
              dic: STD::P6
              zyg:
              - !!perl/hash:RE_string
                alt: dumbsmart_0 0
                i: 0
                text: True
              - !!perl/hash:RE_string
                alt: dumbsmart_0 1
                i: 0
                text: False
              - !!perl/hash:RE_string
                alt: dumbsmart_0 2
                i: 0
                text: Bool::True
              - !!perl/hash:RE_string
                alt: dumbsmart_0 3
                i: 0
                text: Bool::False
        - !!perl/hash:RE_assertion
          assert: '?'
          re: !!perl/hash:RE_method_re
            name: before
            nobind: 1
            re: !!perl/hash:RE_meta
              min: 1
              text: \s
        - !!perl/hash:RE_block {}
    quant:
    - '?'
dumbsmart_0: *17
eat_terminator: !!perl/hash:RE_ast
  dba: eat_terminator
  dic: STD::P6
  re: !!perl/hash:RE_bracket
    re: !!perl/hash:RE_first
      zyg:
      - !!perl/hash:RE_string
        i: 0
        text: ;
      - !!perl/hash:RE_sequence
        zyg:
        - !!perl/hash:RE_assertion
          assert: '?'
          re: !!perl/hash:RE_block
            nobind: 1
        - !!perl/hash:RE_method
          name: ws
          rest: ''
      - !!perl/hash:RE_assertion
        assert: '?'
        re: !!perl/hash:RE_method_re
          name: before
          nobind: 1
          re: &18 !!perl/hash:RE_any
            altname: eat_terminator_0
            dba: eat_terminator
            dic: STD::P6
            zyg:
            - !!perl/hash:RE_string
              alt: eat_terminator_0 0
              i: 0
              text: )
            - !!perl/hash:RE_string
              alt: eat_terminator_0 1
              i: 0
              text: ']'
            - !!perl/hash:RE_string
              alt: eat_terminator_0 2
              i: 0
              text: '}'
      - !!perl/hash:RE_meta
        text: $
      - !!perl/hash:RE_assertion
        assert: '?'
        re: !!perl/hash:RE_method
          name: stopper
          rest: ''
      - !!perl/hash:RE_sequence
        zyg:
        - !!perl/hash:RE_assertion
          assert: '?'
          re: !!perl/hash:RE_method_re
            name: before
            nobind: 1
            re: !!perl/hash:RE_method_re
              name: suppose
              nobind: 1
              re: !!perl/hash:RE_method
                name: statement_control
                rest: ''
        - !!perl/hash:RE_method
          name: backup_ws
          rest: ''
        - !!perl/hash:RE_block {}
        - !!perl/hash:RE_method
          name: panic
          rest: 1
      - !!perl/hash:RE_method
        name: panic
        rest: 1
eat_terminator_0: *18
fakesignature: !!perl/hash:RE_ast
  dba: fakesignature
  dic: STD::P6
  re: !!perl/hash:RE_sequence
    zyg:
    - !!perl/hash:RE_method
      name: newlex
      rest: ''
    - !!perl/hash:RE_method
      name: signature
      rest: ''
fatarrow: !!perl/hash:RE_ast
  dba: fatarrow
  dic: STD::P6
  re: !!perl/hash:RE_sequence
    zyg:
    - !!perl/hash:RE_bindnamed
      atom: !!perl/hash:RE_method
        name: identifier
        rest: ''
    - !!perl/hash:RE_quantified_atom
      atom: !!perl/hash:RE_meta
        min: 1
        text: \h
      quant:
      - '*'
    - !!perl/hash:RE_string
      i: 0
      text: =>
    - !!perl/hash:RE_method
      name: ws
      rest: ''
    - !!perl/hash:RE_bindnamed
      atom: !!perl/hash:RE_method
        name: EXPR
        rest: 1
infix__S_190lambda: !!perl/hash:RE_ast
  dba: infix
  dic: STD::P6
  re: !!perl/hash:RE_sequence
    zyg:
    - !!perl/hash:RE_assertion
      assert: '?'
      re: !!perl/hash:RE_method_re
        name: before
        nobind: 1
        re: &19 !!perl/hash:RE_any
          altname: infix__S_190lambda_0
          dba: infix
          dic: STD::P6
          zyg:
          - !!perl/hash:RE_string
            alt: infix__S_190lambda_0 0
            i: 0
            text: '{'
          - !!perl/hash:RE_string
            alt: infix__S_190lambda_0 1
            i: 0
            text: ->
    - !!perl/hash:RE_assertion
      assert: '!'
      re: !!perl/hash:RE_block
        nobind: 1
    - !!perl/hash:RE_block {}
    - !!perl/hash:RE_method
      name: O
      rest: 1
infix__S_190lambda_0: *19
infix__S_216Dot: !!perl/hash:RE_ast
  dba: infix
  dic: STD::P6
  re: !!perl/hash:RE_sequence
    zyg:
    - !!perl/hash:RE_string
      i: 0
      text: .
    - !!perl/hash:RE_cclass
      i: 0
      text: '[\]\)\},:\s\$"'']'
    - !!perl/hash:RE_method
      name: obs
      rest: 1
infix__S_222StarStar: !!perl/hash:RE_ast
  dba: infix
  dic: STD::P6
  re: !!perl/hash:RE_sequence
    zyg:
    - !!perl/hash:RE_method
      i: 0
      name: sym
      rest: ''
      sym: '**'
    - !!perl/hash:RE_method
      name: O
      rest: 1
infix__S_237Star: !!perl/hash:RE_ast
  dba: infix
  dic: STD::P6
  re: !!perl/hash:RE_sequence
    zyg:
    - !!perl/hash:RE_method
      i: 0
      name: sym
      rest: ''
      sym: '*'
    - !!perl/hash:RE_method
      name: O
      rest: 1
infix__S_238Slash: !!perl/hash:RE_ast
  dba: infix
  dic: STD::P6
  re: !!perl/hash:RE_sequence
    zyg:
    - !!perl/hash:RE_method
      i: 0
      name: sym
      rest: ''
      sym: /
    - !!perl/hash:RE_method
      name: O
      rest: 1
infix__S_239div: !!perl/hash:RE_ast
  dba: infix
  dic: STD::P6
  re: !!perl/hash:RE_sequence
    zyg:
    - !!perl/hash:RE_method
      i: 0
      name: sym
      rest: ''
      sym: div
    - !!perl/hash:RE_method
      name: O
      rest: 1
infix__S_240Percent: !!perl/hash:RE_ast
  dba: infix
  dic: STD::P6
  re: !!perl/hash:RE_sequence
    zyg:
    - !!perl/hash:RE_method
      i: 0
      name: sym
      rest: ''
      sym: '%'
    - !!perl/hash:RE_method
      name: O
      rest: 1
infix__S_241PercentPercent: !!perl/hash:RE_ast
  dba: infix
  dic: STD::P6
  re: !!perl/hash:RE_sequence
    zyg:
    - !!perl/hash:RE_method
      i: 0
      name: sym
      rest: ''
      sym: '%%'
    - !!perl/hash:RE_method
      name: O
      rest: 1
infix__S_242mod: !!perl/hash:RE_ast
  dba: infix
  dic: STD::P6
  re: !!perl/hash:RE_sequence
    zyg:
    - !!perl/hash:RE_method
      i: 0
      name: sym
      rest: ''
      sym: mod
    - !!perl/hash:RE_method
      name: O
      rest: 1
infix__S_243PlusAmp: !!perl/hash:RE_ast
  dba: infix
  dic: STD::P6
  re: !!perl/hash:RE_sequence
    zyg:
    - !!perl/hash:RE_method
      i: 0
      name: sym
      rest: ''
      sym: +&
    - !!perl/hash:RE_method
      name: O
      rest: 1
infix__S_244LtLt: !!perl/hash:RE_ast
  dba: infix
  dic: STD::P6
  re: !!perl/hash:RE_sequence
    zyg:
    - !!perl/hash:RE_method
      i: 0
      name: sym
      rest: ''
      sym: <<
    - !!perl/hash:RE_assertion
      assert: '!'
      re: !!perl/hash:RE_block
        nobind: 1
    - !!perl/hash:RE_assertion
      assert: '?'
      re: !!perl/hash:RE_method_re
        name: before
        nobind: 1
        re: !!perl/hash:RE_meta
          min: 1
          text: \s
    - !!perl/hash:RE_method
      name: sorryobs
      rest: 1
    - !!perl/hash:RE_method
      name: O
      rest: 1
infix__S_245GtGt: !!perl/hash:RE_ast
  dba: infix
  dic: STD::P6
  re: !!perl/hash:RE_sequence
    zyg:
    - !!perl/hash:RE_method
      i: 0
      name: sym
      rest: ''
      sym: '>>'
    - !!perl/hash:RE_assertion
      assert: '!'
      re: !!perl/hash:RE_block
        nobind: 1
    - !!perl/hash:RE_assertion
      assert: '?'
      re: !!perl/hash:RE_method_re
        name: before
        nobind: 1
        re: !!perl/hash:RE_meta
          min: 1
          text: \s
    - !!perl/hash:RE_method
      name: sorryobs
      rest: 1
    - !!perl/hash:RE_method
      name: O
      rest: 1
infix__S_246TildeAmp: !!perl/hash:RE_ast
  dba: infix
  dic: STD::P6
  re: !!perl/hash:RE_sequence
    zyg:
    - !!perl/hash:RE_method
      i: 0
      name: sym
      rest: ''
      sym: ~&
    - !!perl/hash:RE_method
      name: O
      rest: 1
infix__S_247QuestionAmp: !!perl/hash:RE_ast
  dba: infix
  dic: STD::P6
  re: !!perl/hash:RE_sequence
    zyg:
    - !!perl/hash:RE_method
      i: 0
      name: sym
      rest: ''
      sym: ?&
    - !!perl/hash:RE_method
      name: O
      rest: 1
infix__S_248TildeLt: !!perl/hash:RE_ast
  dba: infix
  dic: STD::P6
  re: !!perl/hash:RE_sequence
    zyg:
    - !!perl/hash:RE_method
      i: 0
      name: sym
      rest: ''
      sym: ~<
    - !!perl/hash:RE_bracket
      re: !!perl/hash:RE_first
        zyg:
        - !!perl/hash:RE_assertion
          assert: '!'
          re: !!perl/hash:RE_block
            nobind: 1
        - !!perl/hash:RE_assertion
          assert: '?'
          re: !!perl/hash:RE_method_re
            name: before
            nobind: 1
            re: !!perl/hash:RE_string
              i: 0
              text: <<
        - !!perl/hash:RE_assertion
          assert: '!'
          re: !!perl/hash:RE_method_re
            name: before
            nobind: 1
            re: !!perl/hash:RE_string
              i: 0
              text: <
    - !!perl/hash:RE_method
      name: O
      rest: 1
infix__S_249TildeGt: !!perl/hash:RE_ast
  dba: infix
  dic: STD::P6
  re: !!perl/hash:RE_sequence
    zyg:
    - !!perl/hash:RE_method
      i: 0
      name: sym
      rest: ''
      sym: ~>
    - !!perl/hash:RE_bracket
      re: !!perl/hash:RE_first
        zyg:
        - !!perl/hash:RE_assertion
          assert: '!'
          re: !!perl/hash:RE_block
            nobind: 1
        - !!perl/hash:RE_assertion
          assert: '?'
          re: !!perl/hash:RE_method_re
            name: before
            nobind: 1
            re: !!perl/hash:RE_string
              i: 0
              text: '>>'
        - !!perl/hash:RE_assertion
          assert: '!'
          re: !!perl/hash:RE_method_re
            name: before
            nobind: 1
            re: !!perl/hash:RE_string
              i: 0
              text: '>'
    - !!perl/hash:RE_method
      name: O
      rest: 1
infix__S_250PlusLt: !!perl/hash:RE_ast
  dba: infix
  dic: STD::P6
  re: !!perl/hash:RE_sequence
    zyg:
    - !!perl/hash:RE_method
      i: 0
      name: sym
      rest: ''
      sym: +<
    - !!perl/hash:RE_bracket
      re: !!perl/hash:RE_first
        zyg:
        - !!perl/hash:RE_assertion
          assert: '!'
          re: !!perl/hash:RE_block
            nobind: 1
        - !!perl/hash:RE_assertion
          assert: '?'
          re: !!perl/hash:RE_method_re
            name: before
            nobind: 1
            re: !!perl/hash:RE_string
              i: 0
              text: <<
        - !!perl/hash:RE_assertion
          assert: '!'
          re: !!perl/hash:RE_method_re
            name: before
            nobind: 1
            re: !!perl/hash:RE_string
              i: 0
              text: <
    - !!perl/hash:RE_method
      name: O
      rest: 1
infix__S_251PlusGt: !!perl/hash:RE_ast
  dba: infix
  dic: STD::P6
  re: !!perl/hash:RE_sequence
    zyg:
    - !!perl/hash:RE_method
      i: 0
      name: sym
      rest: ''
      sym: +>
    - !!perl/hash:RE_bracket
      re: !!perl/hash:RE_first
        zyg:
        - !!perl/hash:RE_assertion
          assert: '!'
          re: !!perl/hash:RE_block
            nobind: 1
        - !!perl/hash:RE_assertion
          assert: '?'
          re: !!perl/hash:RE_method_re
            name: before
            nobind: 1
            re: !!perl/hash:RE_string
              i: 0
              text: '>>'
        - !!perl/hash:RE_assertion
          assert: '!'
          re: !!perl/hash:RE_method_re
            name: before
            nobind: 1
            re: !!perl/hash:RE_string
              i: 0
              text: '>'
    - !!perl/hash:RE_method
      name: O
      rest: 1
infix__S_252Plus: !!perl/hash:RE_ast
  dba: infix
  dic: STD::P6
  re: !!perl/hash:RE_sequence
    zyg:
    - !!perl/hash:RE_method
      i: 0
      name: sym
      rest: ''
      sym: +
    - !!perl/hash:RE_assertion
      assert: '!'
      re: !!perl/hash:RE_method_re
        name: before
        nobind: 1
        re: !!perl/hash:RE_string
          i: 0
          text: +
    - !!perl/hash:RE_method
      name: O
      rest: 1
infix__S_253Minus: !!perl/hash:RE_ast
  dba: infix
  dic: STD::P6
  re: !!perl/hash:RE_sequence
    zyg:
    - !!perl/hash:RE_method
      i: 0
      name: sym
      rest: ''
      sym: '-'
    - !!perl/hash:RE_assertion
      assert: '!'
      re: !!perl/hash:RE_method_re
        name: before
        nobind: 1
        re: !!perl/hash:RE_string
          i: 0
          text: '-'
    - !!perl/hash:RE_method
      name: O
      rest: 1
infix__S_254PlusVert: !!perl/hash:RE_ast
  dba: infix
  dic: STD::P6
  re: !!perl/hash:RE_sequence
    zyg:
    - !!perl/hash:RE_method
      i: 0
      name: sym
      rest: ''
      sym: +|
    - !!perl/hash:RE_method
      name: O
      rest: 1
infix__S_255PlusCaret: !!perl/hash:RE_ast
  dba: infix
  dic: STD::P6
  re: !!perl/hash:RE_sequence
    zyg:
    - !!perl/hash:RE_method
      i: 0
      name: sym
      rest: ''
      sym: +^
    - !!perl/hash:RE_method
      name: O
      rest: 1
infix__S_256TildeVert: !!perl/hash:RE_ast
  dba: infix
  dic: STD::P6
  re: !!perl/hash:RE_sequence
    zyg:
    - !!perl/hash:RE_method
      i: 0
      name: sym
      rest: ''
      sym: ~|
    - !!perl/hash:RE_method
      name: O
      rest: 1
infix__S_257TildeCaret: !!perl/hash:RE_ast
  dba: infix
  dic: STD::P6
  re: !!perl/hash:RE_sequence
    zyg:
    - !!perl/hash:RE_method
      i: 0
      name: sym
      rest: ''
      sym: ~^
    - !!perl/hash:RE_method
      name: O
      rest: 1
infix__S_258QuestionVert: !!perl/hash:RE_ast
  dba: infix
  dic: STD::P6
  re: !!perl/hash:RE_sequence
    zyg:
    - !!perl/hash:RE_method
      i: 0
      name: sym
      rest: ''
      sym: ?|
    - !!perl/hash:RE_method
      name: O
      rest: 1
infix__S_259QuestionCaret: !!perl/hash:RE_ast
  dba: infix
  dic: STD::P6
  re: !!perl/hash:RE_sequence
    zyg:
    - !!perl/hash:RE_method
      i: 0
      name: sym
      rest: ''
      sym: ?^
    - !!perl/hash:RE_method
      name: O
      rest: 1
infix__S_260x: !!perl/hash:RE_ast
  dba: infix
  dic: STD::P6
  re: !!perl/hash:RE_sequence
    zyg:
    - !!perl/hash:RE_method
      i: 0
      name: sym
      rest: ''
      sym: x
    - !!perl/hash:RE_method
      name: O
      rest: 1
infix__S_261xx: !!perl/hash:RE_ast
  dba: infix
  dic: STD::P6
  re: !!perl/hash:RE_sequence
    zyg:
    - !!perl/hash:RE_method
      i: 0
      name: sym
      rest: ''
      sym: xx
    - !!perl/hash:RE_method
      name: O
      rest: 1
infix__S_262Tilde: !!perl/hash:RE_ast
  dba: infix
  dic: STD::P6
  re: !!perl/hash:RE_sequence
    zyg:
    - !!perl/hash:RE_method
      i: 0
      name: sym
      rest: ''
      sym: '~'
    - !!perl/hash:RE_method
      name: O
      rest: 1
infix__S_263Amp: !!perl/hash:RE_ast
  dba: infix
  dic: STD::P6
  re: !!perl/hash:RE_sequence
    zyg:
    - !!perl/hash:RE_method
      i: 0
      name: sym
      rest: ''
      sym: '&'
    - !!perl/hash:RE_method
      name: O
      rest: 1
infix__S_264Vert: !!perl/hash:RE_ast
  dba: infix
  dic: STD::P6
  re: !!perl/hash:RE_sequence
    zyg:
    - !!perl/hash:RE_method
      i: 0
      name: sym
      rest: ''
      sym: '|'
    - !!perl/hash:RE_method
      name: O
      rest: 1
infix__S_265Caret: !!perl/hash:RE_ast
  dba: infix
  dic: STD::P6
  re: !!perl/hash:RE_sequence
    zyg:
    - !!perl/hash:RE_method
      i: 0
      name: sym
      rest: ''
      sym: ^
    - !!perl/hash:RE_method
      name: O
      rest: 1
infix__S_270LtEqualGt: !!perl/hash:RE_ast
  dba: infix
  dic: STD::P6
  re: !!perl/hash:RE_sequence
    zyg:
    - !!perl/hash:RE_method
      i: 0
      name: sym
      rest: ''
      sym: <=>
    - !!perl/hash:RE_method
      name: O
      rest: 1
infix__S_271cmp: !!perl/hash:RE_ast
  dba: infix
  dic: STD::P6
  re: !!perl/hash:RE_sequence
    zyg:
    - !!perl/hash:RE_method
      i: 0
      name: sym
      rest: ''
      sym: cmp
    - !!perl/hash:RE_method
      name: O
      rest: 1
infix__S_272leg: !!perl/hash:RE_ast
  dba: infix
  dic: STD::P6
  re: !!perl/hash:RE_sequence
    zyg:
    - !!perl/hash:RE_method
      i: 0
      name: sym
      rest: ''
      sym: leg
    - !!perl/hash:RE_method
      name: O
      rest: 1
infix__S_273but: !!perl/hash:RE_ast
  dba: infix
  dic: STD::P6
  re: !!perl/hash:RE_sequence
    zyg:
    - !!perl/hash:RE_method
      i: 0
      name: sym
      rest: ''
      sym: but
    - !!perl/hash:RE_method
      name: O
      rest: 1
infix__S_274does: !!perl/hash:RE_ast
  dba: infix
  dic: STD::P6
  re: !!perl/hash:RE_sequence
    zyg:
    - !!perl/hash:RE_method
      i: 0
      name: sym
      rest: ''
      sym: does
    - !!perl/hash:RE_method
      name: O
      rest: 1
infix__S_275DotDot: !!perl/hash:RE_ast
  dba: infix
  dic: STD::P6
  re: !!perl/hash:RE_sequence
    zyg:
    - !!perl/hash:RE_method
      i: 0
      name: sym
      rest: ''
      sym: ..
    - !!perl/hash:RE_quantified_atom
      atom: !!perl/hash:RE_bracket
        re: !!perl/hash:RE_sequence
          zyg:
          - !!perl/hash:RE_assertion
            assert: '!'
            re: !!perl/hash:RE_block
              nobind: 1
          - !!perl/hash:RE_assertion
            assert: '?'
            re: !!perl/hash:RE_method_re
              name: before
              nobind: 1
              re: &20 !!perl/hash:RE_any
                altname: infix__S_275DotDot_0
                dba: infix
                dic: STD::P6
                zyg:
                - !!perl/hash:RE_string
                  alt: infix__S_275DotDot_0 0
                  i: 0
                  text: )
                - !!perl/hash:RE_string
                  alt: infix__S_275DotDot_0 1
                  i: 0
                  text: ']'
          - !!perl/hash:RE_method
            name: panic
            rest: 1
      quant:
      - '?'
    - !!perl/hash:RE_method
      name: O
      rest: 1
infix__S_275DotDot_0: *20
infix__S_276CaretDotDot: !!perl/hash:RE_ast
  dba: infix
  dic: STD::P6
  re: !!perl/hash:RE_sequence
    zyg:
    - !!perl/hash:RE_method
      i: 0
      name: sym
      rest: ''
      sym: ^..
    - !!perl/hash:RE_method
      name: O
      rest: 1
infix__S_277DotDotCaret: !!perl/hash:RE_ast
  dba: infix
  dic: STD::P6
  re: !!perl/hash:RE_sequence
    zyg:
    - !!perl/hash:RE_method
      i: 0
      name: sym
      rest: ''
      sym: ..^
    - !!perl/hash:RE_method
      name: O
      rest: 1
infix__S_278CaretDotDotCaret: !!perl/hash:RE_ast
  dba: infix
  dic: STD::P6
  re: !!perl/hash:RE_sequence
    zyg:
    - !!perl/hash:RE_method
      i: 0
      name: sym
      rest: ''
      sym: ^..^
    - !!perl/hash:RE_method
      name: O
      rest: 1
infix__S_279EqualEqual: !!perl/hash:RE_ast
  dba: infix
  dic: STD::P6
  re: !!perl/hash:RE_sequence
    zyg:
    - !!perl/hash:RE_method
      i: 0
      name: sym
      rest: ''
      sym: ==
    - !!perl/hash:RE_assertion
      assert: '!'
      re: !!perl/hash:RE_method_re
        name: before
        nobind: 1
        re: !!perl/hash:RE_string
          i: 0
          text: =
    - !!perl/hash:RE_method
      name: O
      rest: 1
infix__S_280BangEqual: !!perl/hash:RE_ast
  dba: infix
  dic: STD::P6
  re: !!perl/hash:RE_sequence
    zyg:
    - !!perl/hash:RE_method
      i: 0
      name: sym
      rest: ''
      sym: '!='
    - !!perl/hash:RE_assertion
      assert: '?'
      re: !!perl/hash:RE_method_re
        name: before
        nobind: 1
        re: !!perl/hash:RE_meta
          min: 1
          text: \s
    - !!perl/hash:RE_method
      name: O
      rest: 1
infix__S_281Lt: !!perl/hash:RE_ast
  dba: infix
  dic: STD::P6
  re: !!perl/hash:RE_sequence
    zyg:
    - !!perl/hash:RE_method
      i: 0
      name: sym
      rest: ''
      sym: <
    - !!perl/hash:RE_assertion
      assert: '!'
      re: !!perl/hash:RE_method_re
        name: before
        nobind: 1
        re: !!perl/hash:RE_string
          i: 0
          text: <
    - !!perl/hash:RE_method
      name: O
      rest: 1
infix__S_282LtEqual: !!perl/hash:RE_ast
  dba: infix
  dic: STD::P6
  re: !!perl/hash:RE_sequence
    zyg:
    - !!perl/hash:RE_method
      i: 0
      name: sym
      rest: ''
      sym: <=
    - !!perl/hash:RE_method
      name: O
      rest: 1
infix__S_283Gt: !!perl/hash:RE_ast
  dba: infix
  dic: STD::P6
  re: !!perl/hash:RE_sequence
    zyg:
    - !!perl/hash:RE_method
      i: 0
      name: sym
      rest: ''
      sym: '>'
    - !!perl/hash:RE_assertion
      assert: '!'
      re: !!perl/hash:RE_method_re
        name: before
        nobind: 1
        re: !!perl/hash:RE_string
          i: 0
          text: '>'
    - !!perl/hash:RE_method
      name: O
      rest: 1
infix__S_284GtEqual: !!perl/hash:RE_ast
  dba: infix
  dic: STD::P6
  re: !!perl/hash:RE_sequence
    zyg:
    - !!perl/hash:RE_method
      i: 0
      name: sym
      rest: ''
      sym: '>='
    - !!perl/hash:RE_method
      name: O
      rest: 1
infix__S_285TildeTilde: !!perl/hash:RE_ast
  dba: infix
  dic: STD::P6
  re: !!perl/hash:RE_sequence
    zyg:
    - !!perl/hash:RE_method
      i: 0
      name: sym
      rest: ''
      sym: ~~
    - !!perl/hash:RE_method
      name: O
      rest: 1
    - !!perl/hash:RE_assertion
      assert: '?'
      re: !!perl/hash:RE_method
        name: dumbsmart
        rest: ''
infix__S_286BangTilde: !!perl/hash:RE_ast
  dba: infix
  dic: STD::P6
  re: !!perl/hash:RE_sequence
    zyg:
    - !!perl/hash:RE_method
      i: 0
      name: sym
      rest: ''
      sym: '!~'
    - !!perl/hash:RE_meta
      min: 1
      text: \s
    - !!perl/hash:RE_method
      name: obs
      rest: 1
    - !!perl/hash:RE_method
      name: O
      rest: 1
infix__S_287EqualTilde: !!perl/hash:RE_ast
  dba: infix
  dic: STD::P6
  re: !!perl/hash:RE_sequence
    zyg:
    - !!perl/hash:RE_method
      i: 0
      name: sym
      rest: ''
      sym: =~
    - !!perl/hash:RE_method
      name: obs
      rest: 1
    - !!perl/hash:RE_method
      name: O
      rest: 1
infix__S_288eq: !!perl/hash:RE_ast
  dba: infix
  dic: STD::P6
  re: !!perl/hash:RE_sequence
    zyg:
    - !!perl/hash:RE_method
      i: 0
      name: sym
      rest: ''
      sym: eq
    - !!perl/hash:RE_method
      name: O
      rest: 1
infix__S_289ne: !!perl/hash:RE_ast
  dba: infix
  dic: STD::P6
  re: !!perl/hash:RE_sequence
    zyg:
    - !!perl/hash:RE_method
      i: 0
      name: sym
      rest: ''
      sym: ne
    - !!perl/hash:RE_method
      name: O
      rest: 1
infix__S_290lt: !!perl/hash:RE_ast
  dba: infix
  dic: STD::P6
  re: !!perl/hash:RE_sequence
    zyg:
    - !!perl/hash:RE_method
      i: 0
      name: sym
      rest: ''
      sym: lt
    - !!perl/hash:RE_method
      name: O
      rest: 1
infix__S_291le: !!perl/hash:RE_ast
  dba: infix
  dic: STD::P6
  re: !!perl/hash:RE_sequence
    zyg:
    - !!perl/hash:RE_method
      i: 0
      name: sym
      rest: ''
      sym: le
    - !!perl/hash:RE_method
      name: O
      rest: 1
infix__S_292gt: !!perl/hash:RE_ast
  dba: infix
  dic: STD::P6
  re: !!perl/hash:RE_sequence
    zyg:
    - !!perl/hash:RE_method
      i: 0
      name: sym
      rest: ''
      sym: gt
    - !!perl/hash:RE_method
      name: O
      rest: 1
infix__S_293ge: !!perl/hash:RE_ast
  dba: infix
  dic: STD::P6
  re: !!perl/hash:RE_sequence
    zyg:
    - !!perl/hash:RE_method
      i: 0
      name: sym
      rest: ''
      sym: ge
    - !!perl/hash:RE_method
      name: O
      rest: 1
infix__S_294EqualColonEqual: !!perl/hash:RE_ast
  dba: infix
  dic: STD::P6
  re: !!perl/hash:RE_sequence
    zyg:
    - !!perl/hash:RE_method
      i: 0
      name: sym
      rest: ''
      sym: =:=
    - !!perl/hash:RE_method
      name: O
      rest: 1
infix__S_295EqualEqualEqual: !!perl/hash:RE_ast
  dba: infix
  dic: STD::P6
  re: !!perl/hash:RE_sequence
    zyg:
    - !!perl/hash:RE_method
      i: 0
      name: sym
      rest: ''
      sym: ===
    - !!perl/hash:RE_method
      name: O
      rest: 1
infix__S_296eqv: !!perl/hash:RE_ast
  dba: infix
  dic: STD::P6
  re: !!perl/hash:RE_sequence
    zyg:
    - !!perl/hash:RE_method
      i: 0
      name: sym
      rest: ''
      sym: eqv
    - !!perl/hash:RE_method
      name: O
      rest: 1
infix__S_297before: !!perl/hash:RE_ast
  dba: infix
  dic: STD::P6
  re: !!perl/hash:RE_sequence
    zyg:
    - !!perl/hash:RE_method
      i: 0
      name: sym
      rest: ''
      sym: before
    - !!perl/hash:RE_method
      name: O
      rest: 1
infix__S_298after: !!perl/hash:RE_ast
  dba: infix
  dic: STD::P6
  re: !!perl/hash:RE_sequence
    zyg:
    - !!perl/hash:RE_method
      i: 0
      name: sym
      rest: ''
      sym: after
    - !!perl/hash:RE_method
      name: O
      rest: 1
infix__S_299AmpAmp: !!perl/hash:RE_ast
  dba: infix
  dic: STD::P6
  re: !!perl/hash:RE_sequence
    zyg:
    - !!perl/hash:RE_method
      i: 0
      name: sym
      rest: ''
      sym: '&&'
    - !!perl/hash:RE_method
      name: O
      rest: 1
infix__S_300VertVert: !!perl/hash:RE_ast
  dba: infix
  dic: STD::P6
  re: !!perl/hash:RE_sequence
    zyg:
    - !!perl/hash:RE_method
      i: 0
      name: sym
      rest: ''
      sym: '||'
    - !!perl/hash:RE_method
      name: O
      rest: 1
infix__S_301CaretCaret: !!perl/hash:RE_ast
  dba: infix
  dic: STD::P6
  re: !!perl/hash:RE_sequence
    zyg:
    - !!perl/hash:RE_method
      i: 0
      name: sym
      rest: ''
      sym: ^^
    - !!perl/hash:RE_method
      name: O
      rest: 1
infix__S_302SlashSlash: !!perl/hash:RE_ast
  dba: infix
  dic: STD::P6
  re: !!perl/hash:RE_sequence
    zyg:
    - !!perl/hash:RE_method
      i: 0
      name: sym
      rest: ''
      sym: //
    - !!perl/hash:RE_method
      name: O
      rest: 1
infix__S_303min: !!perl/hash:RE_ast
  dba: infix
  dic: STD::P6
  re: !!perl/hash:RE_sequence
    zyg:
    - !!perl/hash:RE_method
      i: 0
      name: sym
      rest: ''
      sym: min
    - !!perl/hash:RE_method
      name: O
      rest: 1
infix__S_304max: !!perl/hash:RE_ast
  dba: infix
  dic: STD::P6
  re: !!perl/hash:RE_sequence
    zyg:
    - !!perl/hash:RE_method
      i: 0
      name: sym
      rest: ''
      sym: max
    - !!perl/hash:RE_method
      name: O
      rest: 1
infix__S_305QuestionQuestion_BangBang: !!perl/hash:RE_ast
  dba: infix
  dic: STD::P6
  re: !!perl/hash:RE_sequence
    zyg:
    - !!perl/hash:RE_string
      i: 0
      text: ??
    - !!perl/hash:RE_method
      name: ws
      rest: ''
    - !!perl/hash:RE_method
      name: EXPR
      rest: 1
    - !!perl/hash:RE_bracket
      re: !!perl/hash:RE_first
        zyg:
        - !!perl/hash:RE_string
          i: 0
          text: '!!'
        - !!perl/hash:RE_sequence
          zyg:
          - !!perl/hash:RE_assertion
            assert: '?'
            re: !!perl/hash:RE_method_re
              name: before
              nobind: 1
              re: !!perl/hash:RE_sequence
                zyg:
                - !!perl/hash:RE_string
                  i: 0
                  text: '::'
                - !!perl/hash:RE_cclass
                  i: 0
                  text: -[=]
          - !!perl/hash:RE_method
            name: panic
            rest: 1
        - !!perl/hash:RE_sequence
          zyg:
          - !!perl/hash:RE_method
            name: infixish
            rest: ''
          - !!perl/hash:RE_block {}
        - !!perl/hash:RE_sequence
          zyg:
          - !!perl/hash:RE_assertion
            assert: '?'
            re: !!perl/hash:RE_method_re
              name: before
              nobind: 1
              re: !!perl/hash:RE_sequence
                zyg:
                - !!perl/hash:RE_quantified_atom
                  atom: !!perl/hash:RE_meta
                    min: 1
                    text: \N
                  quant:
                  - '*'
                - !!perl/hash:RE_quantified_atom
                  atom: !!perl/hash:RE_bracket
                    re: !!perl/hash:RE_sequence
                      zyg:
                      - !!perl/hash:RE_meta
                        min: 1
                        text: \n
                      - !!perl/hash:RE_quantified_atom
                        atom: !!perl/hash:RE_meta
                          min: 1
                          text: \N
                        quant:
                        - '*'
                  quant:
                  - '?'
          - !!perl/hash:RE_string
            i: 0
            text: '!!'
          - !!perl/hash:RE_method
            name: sorry
            rest: 1
          - !!perl/hash:RE_method
            name: panic
            rest: 1
        - !!perl/hash:RE_sequence
          zyg:
          - !!perl/hash:RE_method
            name: sorry
            rest: 1
          - !!perl/hash:RE_method
            name: panic
            rest: 1
    - !!perl/hash:RE_method
      name: O
      rest: 1
infix__S_306BangBang: !!perl/hash:RE_ast
  dba: infix
  dic: STD::P6
  re: !!perl/hash:RE_sequence
    zyg:
    - !!perl/hash:RE_method
      i: 0
      name: sym
      rest: ''
      sym: '!!'
    - !!perl/hash:RE_meta
      text: '::'
    - !!perl/hash:RE_bracket
      re: !!perl/hash:RE_first
        zyg:
        - !!perl/hash:RE_sequence
          zyg:
          - !!perl/hash:RE_method_re
            name: suppose
            nobind: 1
            re: !!perl/hash:RE_method
              name: infixish
              rest: ''
          - !!perl/hash:RE_method
            name: panic
            rest: 1
        - !!perl/hash:RE_method
          name: panic
          rest: 1
infix__S_307Question: !!perl/hash:RE_ast
  dba: infix
  dic: STD::P6
  re: !!perl/hash:RE_sequence
    zyg:
    - !!perl/hash:RE_method
      i: 0
      name: sym
      rest: ''
      sym: '?'
    - !!perl/hash:RE_block {}
    - !!perl/hash:RE_assertion
      assert: '!'
      re: !!perl/hash:RE_method_re
        name: before
        nobind: 1
        re: !!perl/hash:RE_string
          i: 0
          text: '?'
    - !!perl/hash:RE_assertion
      assert: '?'
      re: !!perl/hash:RE_method_re
        name: before
        nobind: 1
        re: !!perl/hash:RE_sequence
          zyg:
          - !!perl/hash:RE_quantified_atom
            atom: !!perl/hash:RE_cclass
              i: 0
              text: -[;]
            quant:
            - '*'
          - !!perl/hash:RE_string
            i: 0
            text: ':'
    - !!perl/hash:RE_method
      name: obs
      rest: 1
    - !!perl/hash:RE_method
      name: O
      rest: 1
infix__S_308ff: !!perl/hash:RE_ast
  dba: infix
  dic: STD::P6
  re: !!perl/hash:RE_sequence
    zyg:
    - !!perl/hash:RE_method
      i: 0
      name: sym
      rest: ''
      sym: ff
    - !!perl/hash:RE_method
      name: O
      rest: 1
infix__S_309Caretff: !!perl/hash:RE_ast
  dba: infix
  dic: STD::P6
  re: !!perl/hash:RE_sequence
    zyg:
    - !!perl/hash:RE_method
      i: 0
      name: sym
      rest: ''
      sym: ^ff
    - !!perl/hash:RE_method
      name: O
      rest: 1
infix__S_310ffCaret: !!perl/hash:RE_ast
  dba: infix
  dic: STD::P6
  re: !!perl/hash:RE_sequence
    zyg:
    - !!perl/hash:RE_method
      i: 0
      name: sym
      rest: ''
      sym: ff^
    - !!perl/hash:RE_method
      name: O
      rest: 1
infix__S_311CaretffCaret: !!perl/hash:RE_ast
  dba: infix
  dic: STD::P6
  re: !!perl/hash:RE_sequence
    zyg:
    - !!perl/hash:RE_method
      i: 0
      name: sym
      rest: ''
      sym: ^ff^
    - !!perl/hash:RE_method
      name: O
      rest: 1
infix__S_312fff: !!perl/hash:RE_ast
  dba: infix
  dic: STD::P6
  re: !!perl/hash:RE_sequence
    zyg:
    - !!perl/hash:RE_method
      i: 0
      name: sym
      rest: ''
      sym: fff
    - !!perl/hash:RE_method
      name: O
      rest: 1
infix__S_313Caretfff: !!perl/hash:RE_ast
  dba: infix
  dic: STD::P6
  re: !!perl/hash:RE_sequence
    zyg:
    - !!perl/hash:RE_method
      i: 0
      name: sym
      rest: ''
      sym: ^fff
    - !!perl/hash:RE_method
      name: O
      rest: 1
infix__S_314fffCaret: !!perl/hash:RE_ast
  dba: infix
  dic: STD::P6
  re: !!perl/hash:RE_sequence
    zyg:
    - !!perl/hash:RE_method
      i: 0
      name: sym
      rest: ''
      sym: fff^
    - !!perl/hash:RE_method
      name: O
      rest: 1
infix__S_315CaretfffCaret: !!perl/hash:RE_ast
  dba: infix
  dic: STD::P6
  re: !!perl/hash:RE_sequence
    zyg:
    - !!perl/hash:RE_method
      i: 0
      name: sym
      rest: ''
      sym: ^fff^
    - !!perl/hash:RE_method
      name: O
      rest: 1
infix__S_316Equal: !!perl/hash:RE_ast
  dba: infix
  dic: STD::P6
  re: !!perl/hash:RE_sequence
    zyg:
    - !!perl/hash:RE_method
      i: 0
      name: sym
      rest: ''
      sym: =
    - !!perl/hash:RE_bracket
      re: !!perl/hash:RE_first
        zyg:
        - !!perl/hash:RE_sequence
          zyg:
          - !!perl/hash:RE_assertion
            assert: '?'
            re: !!perl/hash:RE_block
              nobind: 1
          - !!perl/hash:RE_method
            name: O
            rest: 1
        - !!perl/hash:RE_method
          name: O
          rest: 1
infix__S_317ColonEqual: !!perl/hash:RE_ast
  dba: infix
  dic: STD::P6
  re: !!perl/hash:RE_sequence
    zyg:
    - !!perl/hash:RE_method
      i: 0
      name: sym
      rest: ''
      sym: :=
    - !!perl/hash:RE_method
      name: O
      rest: 1
infix__S_318ColonColonEqual: !!perl/hash:RE_ast
  dba: infix
  dic: STD::P6
  re: !!perl/hash:RE_sequence
    zyg:
    - !!perl/hash:RE_method
      i: 0
      name: sym
      rest: ''
      sym: ::=
    - !!perl/hash:RE_method
      name: O
      rest: 1
infix__S_319DotEqual: !!perl/hash:RE_ast
  dba: infix
  dic: STD::P6
  re: !!perl/hash:RE_sequence
    zyg:
    - !!perl/hash:RE_method
      i: 0
      name: sym
      rest: ''
      sym: .=
    - !!perl/hash:RE_method
      name: O
      rest: 1
infix__S_320EqualGt: !!perl/hash:RE_ast
  dba: infix
  dic: STD::P6
  re: !!perl/hash:RE_sequence
    zyg:
    - !!perl/hash:RE_method
      i: 0
      name: sym
      rest: ''
      sym: =>
    - !!perl/hash:RE_method
      name: O
      rest: 1
infix__S_323Comma: !!perl/hash:RE_ast
  dba: infix
  dic: STD::P6
  re: !!perl/hash:RE_sequence
    zyg:
    - !!perl/hash:RE_method
      i: 0
      name: sym
      rest: ''
      sym: ','
    - !!perl/hash:RE_method
      name: O
      rest: 1
    - !!perl/hash:RE_quantified_atom
      atom: !!perl/hash:RE_bracket
        re: !!perl/hash:RE_sequence
          zyg:
          - !!perl/hash:RE_assertion
            assert: '?'
            re: !!perl/hash:RE_method_re
              name: before
              nobind: 1
              re: !!perl/hash:RE_sequence
                zyg:
                - !!perl/hash:RE_quantified_atom
                  atom: !!perl/hash:RE_meta
                    min: 1
                    text: \h
                  quant:
                  - '*'
                - !!perl/hash:RE_string
                  i: 0
                  text: '...'
          - !!perl/hash:RE_method
            name: worry
            rest: 1
      quant:
      - '?'
infix__S_324Colon: !!perl/hash:RE_ast
  dba: infix
  dic: STD::P6
  re: !!perl/hash:RE_sequence
    zyg:
    - !!perl/hash:RE_string
      i: 0
      text: ':'
    - !!perl/hash:RE_assertion
      assert: '?'
      re: !!perl/hash:RE_method_re
        name: before
        nobind: 1
        re: &21 !!perl/hash:RE_any
          altname: infix__S_324Colon_0
          dba: infix
          dic: STD::P6
          zyg:
          - !!perl/hash:RE_meta
            alt: infix__S_324Colon_0 0
            min: 1
            text: \s
          - !!perl/hash:RE_method
            alt: infix__S_324Colon_0 1
            name: terminator
            rest: ''
    - !!perl/hash:RE_block {}
    - !!perl/hash:RE_method
      name: O
      rest: 1
infix__S_324Colon_0: *21
infix__S_325X: !!perl/hash:RE_ast
  dba: infix
  dic: STD::P6
  re: !!perl/hash:RE_sequence
    zyg:
    - !!perl/hash:RE_method
      i: 0
      name: sym
      rest: ''
      sym: X
    - !!perl/hash:RE_method
      name: O
      rest: 1
infix__S_326Z: !!perl/hash:RE_ast
  dba: infix
  dic: STD::P6
  re: !!perl/hash:RE_sequence
    zyg:
    - !!perl/hash:RE_method
      i: 0
      name: sym
      rest: ''
      sym: Z
    - !!perl/hash:RE_method
      name: O
      rest: 1
infix__S_327minmax: !!perl/hash:RE_ast
  dba: infix
  dic: STD::P6
  re: !!perl/hash:RE_sequence
    zyg:
    - !!perl/hash:RE_method
      i: 0
      name: sym
      rest: ''
      sym: minmax
    - !!perl/hash:RE_method
      name: O
      rest: 1
infix__S_328DotDotDot: !!perl/hash:RE_ast
  dba: infix
  dic: STD::P6
  re: !!perl/hash:RE_sequence
    zyg:
    - !!perl/hash:RE_method
      i: 0
      name: sym
      rest: ''
      sym: '...'
    - !!perl/hash:RE_method
      name: O
      rest: 1
infix__S_334and: !!perl/hash:RE_ast
  dba: infix
  dic: STD::P6
  re: !!perl/hash:RE_sequence
    zyg:
    - !!perl/hash:RE_method
      i: 0
      name: sym
      rest: ''
      sym: and
    - !!perl/hash:RE_method
      name: O
      rest: 1
infix__S_335andthen: !!perl/hash:RE_ast
  dba: infix
  dic: STD::P6
  re: !!perl/hash:RE_sequence
    zyg:
    - !!perl/hash:RE_method
      i: 0
      name: sym
      rest: ''
      sym: andthen
    - !!perl/hash:RE_method
      name: O
      rest: 1
infix__S_336or: !!perl/hash:RE_ast
  dba: infix
  dic: STD::P6
  re: !!perl/hash:RE_sequence
    zyg:
    - !!perl/hash:RE_method
      i: 0
      name: sym
      rest: ''
      sym: or
    - !!perl/hash:RE_method
      name: O
      rest: 1
infix__S_337orelse: !!perl/hash:RE_ast
  dba: infix
  dic: STD::P6
  re: !!perl/hash:RE_sequence
    zyg:
    - !!perl/hash:RE_method
      i: 0
      name: sym
      rest: ''
      sym: orelse
    - !!perl/hash:RE_method
      name: O
      rest: 1
infix__S_338xor: !!perl/hash:RE_ast
  dba: infix
  dic: STD::P6
  re: !!perl/hash:RE_sequence
    zyg:
    - !!perl/hash:RE_method
      i: 0
      name: sym
      rest: ''
      sym: xor
    - !!perl/hash:RE_method
      name: O
      rest: 1
infix__S_339LtEqualEqual: !!perl/hash:RE_ast
  dba: infix
  dic: STD::P6
  re: !!perl/hash:RE_sequence
    zyg:
    - !!perl/hash:RE_method
      i: 0
      name: sym
      rest: ''
      sym: <==
    - !!perl/hash:RE_method
      name: O
      rest: 1
infix__S_340EqualEqualGt: !!perl/hash:RE_ast
  dba: infix
  dic: STD::P6
  re: !!perl/hash:RE_sequence
    zyg:
    - !!perl/hash:RE_method
      i: 0
      name: sym
      rest: ''
      sym: ==>
    - !!perl/hash:RE_method
      name: O
      rest: 1
infix__S_341LtLtEqualEqual: !!perl/hash:RE_ast
  dba: infix
  dic: STD::P6
  re: !!perl/hash:RE_sequence
    zyg:
    - !!perl/hash:RE_method
      i: 0
      name: sym
      rest: ''
      sym: <<==
    - !!perl/hash:RE_method
      name: O
      rest: 1
infix__S_342EqualEqualGtGt: !!perl/hash:RE_ast
  dba: infix
  dic: STD::P6
  re: !!perl/hash:RE_sequence
    zyg:
    - !!perl/hash:RE_method
      i: 0
      name: sym
      rest: ''
      sym: ==>>
    - !!perl/hash:RE_method
      name: O
      rest: 1
infix_circumfix_meta_operator__S_204Fre_Nch: !!perl/hash:RE_ast
  dba: infix_circumfix_meta_operator
  dic: STD::P6
  re: !!perl/hash:RE_sequence
    zyg:
    - !!perl/hash:RE_bracket
      re: &22 !!perl/hash:RE_any
        altname: infix_circumfix_meta_operator__S_204Fre_Nch_0
        dba: infix_circumfix_meta_operator
        dic: STD::P6
        zyg:
        - !!perl/hash:RE_string
          alt: infix_circumfix_meta_operator__S_204Fre_Nch_0 0
          i: 0
          text: «
        - !!perl/hash:RE_string
          alt: infix_circumfix_meta_operator__S_204Fre_Nch_0 1
          i: 0
          text: »
    - !!perl/hash:RE_block {}
    - !!perl/hash:RE_method
      name: infixish
      rest: 1
    - !!perl/hash:RE_bracket
      re: !!perl/hash:RE_first
        zyg:
        - &23 !!perl/hash:RE_any
          altname: infix_circumfix_meta_operator__S_204Fre_Nch_1
          dba: infix_circumfix_meta_operator
          dic: STD::P6
          zyg:
          - !!perl/hash:RE_string
            alt: infix_circumfix_meta_operator__S_204Fre_Nch_1 0
            i: 0
            text: «
          - !!perl/hash:RE_string
            alt: infix_circumfix_meta_operator__S_204Fre_Nch_1 1
            i: 0
            text: »
        - !!perl/hash:RE_method
          name: panic
          rest: 1
    - !!perl/hash:RE_method
      name: can_meta
      rest: 1
    - !!perl/hash:RE_assertion
      assert: '?'
      re: !!perl/hash:RE_block
        nobind: 1
infix_circumfix_meta_operator__S_204Fre_Nch_0: *22
infix_circumfix_meta_operator__S_204Fre_Nch_1: *23
infix_circumfix_meta_operator__S_205LtLt_GtGt: !!perl/hash:RE_ast
  dba: infix_circumfix_meta_operator
  dic: STD::P6
  re: !!perl/hash:RE_sequence
    zyg:
    - !!perl/hash:RE_bracket
      re: &24 !!perl/hash:RE_any
        altname: infix_circumfix_meta_operator__S_205LtLt_GtGt_0
        dba: infix_circumfix_meta_operator
        dic: STD::P6
        zyg:
        - !!perl/hash:RE_string
          alt: infix_circumfix_meta_operator__S_205LtLt_GtGt_0 0
          i: 0
          text: <<
        - !!perl/hash:RE_string
          alt: infix_circumfix_meta_operator__S_205LtLt_GtGt_0 1
          i: 0
          text: '>>'
    - !!perl/hash:RE_block {}
    - !!perl/hash:RE_method
      name: infixish
      rest: 1
    - !!perl/hash:RE_bracket
      re: !!perl/hash:RE_first
        zyg:
        - &25 !!perl/hash:RE_any
          altname: infix_circumfix_meta_operator__S_205LtLt_GtGt_1
          dba: infix_circumfix_meta_operator
          dic: STD::P6
          zyg:
          - !!perl/hash:RE_string
            alt: infix_circumfix_meta_operator__S_205LtLt_GtGt_1 0
            i: 0
            text: <<
          - !!perl/hash:RE_string
            alt: infix_circumfix_meta_operator__S_205LtLt_GtGt_1 1
            i: 0
            text: '>>'
        - !!perl/hash:RE_method
          name: panic
          rest: 1
    - !!perl/hash:RE_method
      name: can_meta
      rest: 1
    - !!perl/hash:RE_assertion
      assert: '?'
      re: !!perl/hash:RE_block
        nobind: 1
infix_circumfix_meta_operator__S_205LtLt_GtGt_0: *24
infix_circumfix_meta_operator__S_205LtLt_GtGt_1: *25
infix_postfix_meta_operator__S_206Equal: !!perl/hash:RE_ast
  dba: infix_postfix_meta_operator
  dic: STD::P6
  re: !!perl/hash:RE_sequence
    zyg:
    - !!perl/hash:RE_string
      i: 0
      text: =
    - !!perl/hash:RE_method
      name: can_meta
      rest: 1
    - !!perl/hash:RE_bracket
      re: !!perl/hash:RE_first
        zyg:
        - !!perl/hash:RE_assertion
          assert: '!'
          re: !!perl/hash:RE_block
            nobind: 1
        - !!perl/hash:RE_method
          name: sorry
          rest: 1
    - !!perl/hash:RE_block {}
    - !!perl/hash:RE_method
      name: O
      rest: 1
infix_prefix_meta_operator__S_199Bang: !!perl/hash:RE_ast
  dba: infix_prefix_meta_operator
  dic: STD::P6
  re: !!perl/hash:RE_sequence
    zyg:
    - !!perl/hash:RE_method
      i: 0
      name: sym
      rest: ''
      sym: '!'
    - !!perl/hash:RE_assertion
      assert: '!'
      re: !!perl/hash:RE_method_re
        name: before
        nobind: 1
        re: !!perl/hash:RE_string
          i: 0
          text: '!'
    - !!perl/hash:RE_block {}
    - !!perl/hash:RE_bracket
      re: !!perl/hash:RE_first
        zyg:
        - !!perl/hash:RE_method
          name: infixish
          rest: 1
        - !!perl/hash:RE_method
          name: panic
          rest: 1
    - !!perl/hash:RE_bracket
      re: !!perl/hash:RE_first
        zyg:
        - !!perl/hash:RE_sequence
          zyg:
          - !!perl/hash:RE_assertion
            assert: '?'
            re: !!perl/hash:RE_block
              nobind: 1
          - !!perl/hash:RE_method
            name: O
            rest: 1
        - !!perl/hash:RE_sequence
          zyg:
          - !!perl/hash:RE_method
            name: can_meta
            rest: 1
          - !!perl/hash:RE_assertion
            assert: '?'
            re: !!perl/hash:RE_block
              nobind: 1
          - !!perl/hash:RE_assertion
            assert: '?'
            re: !!perl/hash:RE_block
              nobind: 1
        - !!perl/hash:RE_method
          name: panic
          rest: 1
infix_prefix_meta_operator__S_200R: !!perl/hash:RE_ast
  dba: infix_prefix_meta_operator
  dic: STD::P6
  re: !!perl/hash:RE_sequence
    zyg:
    - !!perl/hash:RE_method
      i: 0
      name: sym
      rest: ''
      sym: R
    - !!perl/hash:RE_block {}
    - !!perl/hash:RE_method
      name: infixish
      rest: 1
    - !!perl/hash:RE_method
      name: can_meta
      rest: 1
    - !!perl/hash:RE_assertion
      assert: '?'
      re: !!perl/hash:RE_block
        nobind: 1
infix_prefix_meta_operator__S_201S: !!perl/hash:RE_ast
  dba: infix_prefix_meta_operator
  dic: STD::P6
  re: !!perl/hash:RE_sequence
    zyg:
    - !!perl/hash:RE_method
      i: 0
      name: sym
      rest: ''
      sym: S
    - !!perl/hash:RE_block {}
    - !!perl/hash:RE_method
      name: infixish
      rest: 1
    - !!perl/hash:RE_method
      name: can_meta
      rest: 1
    - !!perl/hash:RE_assertion
      assert: '?'
      re: !!perl/hash:RE_block
        nobind: 1
infix_prefix_meta_operator__S_202X: !!perl/hash:RE_ast
  dba: infix_prefix_meta_operator
  dic: STD::P6
  re: !!perl/hash:RE_sequence
    zyg:
    - !!perl/hash:RE_method
      i: 0
      name: sym
      rest: ''
      sym: X
    - !!perl/hash:RE_assertion
      assert: '?'
      re: !!perl/hash:RE_method_re
        name: before
        nobind: 1
        re: !!perl/hash:RE_meta
          min: 1
          text: \S
    - !!perl/hash:RE_block {}
    - !!perl/hash:RE_quantified_atom
      atom: !!perl/hash:RE_bracket
        re: !!perl/hash:RE_sequence
          zyg:
          - !!perl/hash:RE_method
            name: infixish
            rest: 1
          - !!perl/hash:RE_method
            name: can_meta
            rest: 1
          - !!perl/hash:RE_assertion
            assert: '?'
            re: !!perl/hash:RE_block
              nobind: 1
      quant:
      - '?'
    - !!perl/hash:RE_method
      name: O
      rest: 1
infix_prefix_meta_operator__S_203Z: !!perl/hash:RE_ast
  dba: infix_prefix_meta_operator
  dic: STD::P6
  re: !!perl/hash:RE_sequence
    zyg:
    - !!perl/hash:RE_method
      i: 0
      name: sym
      rest: ''
      sym: Z
    - !!perl/hash:RE_assertion
      assert: '?'
      re: !!perl/hash:RE_method_re
        name: before
        nobind: 1
        re: !!perl/hash:RE_meta
          min: 1
          text: \S
    - !!perl/hash:RE_block {}
    - !!perl/hash:RE_quantified_atom
      atom: !!perl/hash:RE_bracket
        re: !!perl/hash:RE_sequence
          zyg:
          - !!perl/hash:RE_method
            name: infixish
            rest: 1
          - !!perl/hash:RE_method
            name: can_meta
            rest: 1
          - !!perl/hash:RE_assertion
            assert: '?'
            re: !!perl/hash:RE_block
              nobind: 1
      quant:
      - '?'
    - !!perl/hash:RE_method
      name: O
      rest: 1
infixish: !!perl/hash:RE_ast
  dba: infix or meta-infix
  dic: STD::P6
  re: !!perl/hash:RE_sequence
    zyg:
    - !!perl/hash:RE_assertion
      assert: '!'
      re: !!perl/hash:RE_method
        name: stdstopper
        rest: ''
    - !!perl/hash:RE_assertion
      assert: '!'
      re: !!perl/hash:RE_method
        name: infixstopper
        rest: ''
    - !!perl/hash:RE_bracket
      re: &26 !!perl/hash:RE_any
        altname: infixish_0
        dba: infix or meta-infix
        dic: STD::P6
        zyg:
        - !!perl/hash:RE_sequence
          alt: infixish_0 0
          zyg:
          - !!perl/hash:RE_method
            name: colonpair
            rest: ''
          - !!perl/hash:RE_block {}
        - !!perl/hash:RE_sequence
          alt: infixish_0 1
          zyg:
          - !!perl/hash:RE_bracket
            re: &27 !!perl/hash:RE_any
              altname: infixish_1
              dba: bracketed infix
              dic: STD::P6
              zyg:
              - !!perl/hash:RE_sequence
                alt: infixish_1 0
                zyg:
                - !!perl/hash:RE_bracket
                  re: !!perl/hash:RE_sequence
                    zyg:
                    - !!perl/hash:RE_string
                      i: 0
                      text: '['
                    - !!perl/hash:RE_block {}
                    - !!perl/hash:RE_bindnamed
                      atom: !!perl/hash:RE_method
                        name: infixish
                        rest: 1
                    - !!perl/hash:RE_bracket
                      re: !!perl/hash:RE_first
                        zyg:
                        - !!perl/hash:RE_string
                          i: 0
                          text: ']'
                        - !!perl/hash:RE_method
                          name: FAILGOAL
                          rest: 1
                - !!perl/hash:RE_block {}
              - !!perl/hash:RE_sequence
                alt: infixish_1 1
                zyg:
                - !!perl/hash:RE_bindnamed
                  atom: !!perl/hash:RE_method
                    name: infix_circumfix_meta_operator
                    rest: ''
                - !!perl/hash:RE_block {}
              - !!perl/hash:RE_sequence
                alt: infixish_1 2
                zyg:
                - !!perl/hash:RE_bindnamed
                  atom: !!perl/hash:RE_method
                    name: infix_prefix_meta_operator
                    rest: ''
                - !!perl/hash:RE_block {}
              - !!perl/hash:RE_sequence
                alt: infixish_1 3
                zyg:
                - !!perl/hash:RE_method
                  name: infix
                  rest: ''
                - !!perl/hash:RE_block {}
              - !!perl/hash:RE_sequence
                alt: infixish_1 4
                zyg:
                - !!perl/hash:RE_block {}
                - !!perl/hash:RE_assertion
                  assert: '?'
                  re: !!perl/hash:RE_method
                    name: dotty
                    rest: ''
                - !!perl/hash:RE_method
                  name: panic
                  rest: 1
              - !!perl/hash:RE_sequence
                alt: infixish_1 5
                zyg:
                - !!perl/hash:RE_block {}
                - !!perl/hash:RE_assertion
                  assert: '?'
                  re: !!perl/hash:RE_method
                    name: postfix
                    rest: ''
                - !!perl/hash:RE_method
                  name: panic
                  rest: 1
          - !!perl/hash:RE_quantified_atom
            atom: !!perl/hash:RE_bracket
              re: !!perl/hash:RE_sequence
                zyg:
                - !!perl/hash:RE_assertion
                  assert: '?'
                  re: !!perl/hash:RE_method_re
                    name: before
                    nobind: 1
                    re: !!perl/hash:RE_string
                      i: 0
                      text: =
                - !!perl/hash:RE_assertion
                  assert: '?'
                  re: !!perl/hash:RE_block
                    nobind: 1
                - !!perl/hash:RE_method
                  name: infix_postfix_meta_operator
                  rest: 1
                - !!perl/hash:RE_block {}
            quant:
            - '?'
infixish_0: *26
infixish_1: *27
infixstopper: !!perl/hash:RE_ast
  dba: infix stopper
  dic: STD::P6
  re: !!perl/hash:RE_bracket
    re: &28 !!perl/hash:RE_any
      altname: infixstopper_0
      dba: infix stopper
      dic: STD::P6
      zyg:
      - !!perl/hash:RE_assertion
        alt: infixstopper_0 0
        assert: '?'
        re: !!perl/hash:RE_method_re
          name: before
          nobind: 1
          re: !!perl/hash:RE_method
            name: stopper
            rest: ''
      - !!perl/hash:RE_sequence
        alt: infixstopper_0 1
        zyg:
        - !!perl/hash:RE_assertion
          assert: '?'
          re: !!perl/hash:RE_method_re
            name: before
            nobind: 1
            re: !!perl/hash:RE_string
              i: 0
              text: '!!'
        - !!perl/hash:RE_assertion
          assert: '?'
          re: !!perl/hash:RE_block
            nobind: 1
      - !!perl/hash:RE_sequence
        alt: infixstopper_0 2
        zyg:
        - !!perl/hash:RE_assertion
          assert: '?'
          re: !!perl/hash:RE_method_re
            name: before
            nobind: 1
            re: &29 !!perl/hash:RE_any
              altname: infixstopper_1
              dba: infix stopper
              dic: STD::P6
              zyg:
              - !!perl/hash:RE_string
                alt: infixstopper_1 0
                i: 0
                text: '{'
              - !!perl/hash:RE_method
                alt: infixstopper_1 1
                name: lambda
                rest: ''
        - !!perl/hash:RE_assertion
          assert: '?'
          re: !!perl/hash:RE_block
            nobind: 1
      - !!perl/hash:RE_assertion
        alt: infixstopper_0 3
        assert: '?'
        re: !!perl/hash:RE_block
          nobind: 1
infixstopper_0: *28
infixstopper_1: *29
label: !!perl/hash:RE_ast
  dba: label
  dic: STD::P6
  re: !!perl/hash:RE_sequence
    zyg:
    - !!perl/hash:RE_method
      name: identifier
      rest: ''
    - !!perl/hash:RE_string
      i: 0
      text: ':'
    - !!perl/hash:RE_assertion
      assert: '?'
      re: !!perl/hash:RE_method_re
        name: before
        nobind: 1
        re: !!perl/hash:RE_meta
          min: 1
          text: \s
    - !!perl/hash:RE_method
      name: ws
      rest: ''
    - !!perl/hash:RE_quantified_atom
      atom: !!perl/hash:RE_bracket
        re: !!perl/hash:RE_sequence
          zyg:
          - !!perl/hash:RE_assertion
            assert: '?'
            re: !!perl/hash:RE_block
              nobind: 1
          - !!perl/hash:RE_method
            name: sorry
            rest: 1
      quant:
      - '?'
    - !!perl/hash:RE_block {}
lambda: !!perl/hash:RE_ast
  dba: lambda
  dic: STD::P6
  re: &30 !!perl/hash:RE_any
    altname: lambda_0
    dba: lambda
    dic: STD::P6
    zyg:
    - !!perl/hash:RE_string
      alt: lambda_0 0
      i: 0
      text: ->
    - !!perl/hash:RE_string
      alt: lambda_0 1
      i: 0
      text: <->
lambda_0: *30
macro_def: !!perl/hash:RE_ast
  dba: macro_def
  dic: STD::P6
  re: !!perl/hash:RE_first
    zyg:
    - !!perl/hash:RE_sequence
      zyg:
      - !!perl/hash:RE_method
        name: ws
        rest: ''
      - !!perl/hash:RE_bracket
        re: !!perl/hash:RE_sequence
          zyg:
          - !!perl/hash:RE_quantified_atom
            atom: !!perl/hash:RE_bracket
              re: &31 !!perl/hash:RE_any
                altname: macro_def_0
                dba: macro_def
                dic: STD::P6
                zyg:
                - !!perl/hash:RE_sequence
                  alt: macro_def_0 0
                  zyg:
                  - !!perl/hash:RE_method
                    name: ws
                    rest: ''
                  - !!perl/hash:RE_string
                    i: 0
                    text: '&'
                  - !!perl/hash:RE_quantified_atom
                    atom: !!perl/hash:RE_method
                      name: deflongname
                      rest: ''
                    quant:
                    - '?'
                  - !!perl/hash:RE_method
                    name: ws
                    rest: ''
                - !!perl/hash:RE_sequence
                  alt: macro_def_0 1
                  zyg:
                  - !!perl/hash:RE_method
                    name: ws
                    rest: ''
                  - !!perl/hash:RE_method
                    name: deflongname
                    rest: ''
                  - !!perl/hash:RE_method
                    name: ws
                    rest: ''
            quant:
            - '?'
          - !!perl/hash:RE_method
            name: ws
            rest: ''
          - !!perl/hash:RE_method
            name: newlex
            rest: 1
          - !!perl/hash:RE_method
            name: ws
            rest: ''
          - !!perl/hash:RE_quantified_atom
            atom: !!perl/hash:RE_bracket
              re: &32 !!perl/hash:RE_any
                altname: macro_def_1
                dba: macro_def
                dic: STD::P6
                zyg:
                - !!perl/hash:RE_sequence
                  alt: macro_def_1 0
                  zyg:
                  - !!perl/hash:RE_method
                    name: ws
                    rest: ''
                  - !!perl/hash:RE_method
                    name: multisig
                    rest: ''
                  - !!perl/hash:RE_method
                    name: ws
                    rest: ''
                - !!perl/hash:RE_sequence
                  alt: macro_def_1 1
                  zyg:
                  - !!perl/hash:RE_method
                    name: ws
                    rest: ''
                  - !!perl/hash:RE_method
                    name: trait
                    rest: ''
                  - !!perl/hash:RE_method
                    name: ws
                    rest: ''
            quant:
            - '*'
          - !!perl/hash:RE_method
            name: ws
            rest: ''
          - !!perl/hash:RE_quantified_atom
            atom: !!perl/hash:RE_bracket
              re: !!perl/hash:RE_sequence
                zyg:
                - !!perl/hash:RE_method
                  name: ws
                  rest: ''
                - !!perl/hash:RE_assertion
                  assert: '!'
                  re: !!perl/hash:RE_method_re
                    name: before
                    nobind: 1
                    re: !!perl/hash:RE_sequence
                      zyg:
                      - !!perl/hash:RE_method
                        name: ws
                        rest: ''
                      - !!perl/hash:RE_string
                        i: 0
                        text: '{'
                - !!perl/hash:RE_method
                  name: panic
                  rest: 1
                - !!perl/hash:RE_method
                  name: ws
                  rest: ''
            quant:
            - '?'
          - !!perl/hash:RE_method
            name: ws
            rest: ''
          - !!perl/hash:RE_block {}
          - !!perl/hash:RE_method
            name: blockoid
            rest: ''
          - !!perl/hash:RE_method
            name: checkyada
            rest: ''
          - !!perl/hash:RE_method
            name: getsig
            rest: ''
          - !!perl/hash:RE_method
            name: getdecl
            rest: ''
      - !!perl/hash:RE_method
        name: ws
        rest: ''
    - !!perl/hash:RE_sequence
      zyg:
      - !!perl/hash:RE_method
        name: ws
        rest: ''
      - !!perl/hash:RE_method
        name: panic
        rest: 1
      - !!perl/hash:RE_method
        name: ws
        rest: ''
macro_def_0: *31
macro_def_1: *32
method_def: !!perl/hash:RE_ast
  dba: method_def
  dic: STD::P6
  re: !!perl/hash:RE_first
    zyg:
    - !!perl/hash:RE_sequence
      zyg:
      - !!perl/hash:RE_method
        name: ws
        rest: ''
      - !!perl/hash:RE_method
        name: newlex
        rest: 1
      - !!perl/hash:RE_method
        name: ws
        rest: ''
      - !!perl/hash:RE_bracket
        re: !!perl/hash:RE_sequence
          zyg:
          - !!perl/hash:RE_bracket
            re: &33 !!perl/hash:RE_any
              altname: method_def_0
              dba: subscript signature
              dic: STD::P6
              zyg:
              - !!perl/hash:RE_sequence
                alt: method_def_0 0
                zyg:
                - !!perl/hash:RE_bindnamed
                  atom: !!perl/hash:RE_bracket
                    re: !!perl/hash:RE_quantified_atom
                      atom: !!perl/hash:RE_cclass
                        i: 0
                        text: '[ ! ^ ]'
                      quant:
                      - '?'
                - !!perl/hash:RE_method
                  name: longname
                  rest: ''
                - !!perl/hash:RE_method
                  name: ws
                  rest: ''
                - !!perl/hash:RE_quantified_atom
                  atom: !!perl/hash:RE_bracket
                    re: &34 !!perl/hash:RE_any
                      altname: method_def_1
                      dba: method_def
                      dic: STD::P6
                      zyg:
                      - !!perl/hash:RE_sequence
                        alt: method_def_1 0
                        zyg:
                        - !!perl/hash:RE_method
                          name: ws
                          rest: ''
                        - !!perl/hash:RE_method
                          name: multisig
                          rest: ''
                        - !!perl/hash:RE_method
                          name: ws
                          rest: ''
                      - !!perl/hash:RE_sequence
                        alt: method_def_1 1
                        zyg:
                        - !!perl/hash:RE_method
                          name: ws
                          rest: ''
                        - !!perl/hash:RE_method
                          name: trait
                          rest: ''
                        - !!perl/hash:RE_method
                          name: ws
                          rest: ''
                  quant:
                  - '*'
                - !!perl/hash:RE_method
                  name: ws
                  rest: ''
              - !!perl/hash:RE_sequence
                alt: method_def_0 1
                zyg:
                - !!perl/hash:RE_method
                  name: multisig
                  rest: ''
                - !!perl/hash:RE_method
                  name: ws
                  rest: ''
                - !!perl/hash:RE_quantified_atom
                  atom: !!perl/hash:RE_method
                    name: trait
                    rest: ''
                  quant:
                  - '*'
                - !!perl/hash:RE_method
                  name: ws
                  rest: ''
              - !!perl/hash:RE_sequence
                alt: method_def_0 2
                zyg:
                - !!perl/hash:RE_method
                  name: sigil
                  rest: ''
                - !!perl/hash:RE_method
                  name: ws
                  rest: ''
                - !!perl/hash:RE_string
                  i: 0
                  text: .
                - !!perl/hash:RE_method
                  name: ws
                  rest: ''
                - !!perl/hash:RE_bracket
                  re: &35 !!perl/hash:RE_any
                    altname: method_def_2
                    dba: subscript signature
                    dic: STD::P6
                    zyg:
                    - !!perl/hash:RE_sequence
                      alt: method_def_2 0
                      zyg:
                      - !!perl/hash:RE_bracket
                        re: !!perl/hash:RE_sequence
                          zyg:
                          - !!perl/hash:RE_string
                            i: 0
                            text: (
                          - !!perl/hash:RE_block {}
                          - !!perl/hash:RE_method
                            name: signature
                            rest: ''
                          - !!perl/hash:RE_bracket
                            re: !!perl/hash:RE_first
                              zyg:
                              - !!perl/hash:RE_string
                                i: 0
                                text: )
                              - !!perl/hash:RE_method
                                name: FAILGOAL
                                rest: 1
                      - !!perl/hash:RE_method
                        name: ws
                        rest: ''
                    - !!perl/hash:RE_sequence
                      alt: method_def_2 1
                      zyg:
                      - !!perl/hash:RE_bracket
                        re: !!perl/hash:RE_sequence
                          zyg:
                          - !!perl/hash:RE_string
                            i: 0
                            text: '['
                          - !!perl/hash:RE_block {}
                          - !!perl/hash:RE_method
                            name: signature
                            rest: ''
                          - !!perl/hash:RE_bracket
                            re: !!perl/hash:RE_first
                              zyg:
                              - !!perl/hash:RE_string
                                i: 0
                                text: ']'
                              - !!perl/hash:RE_method
                                name: FAILGOAL
                                rest: 1
                      - !!perl/hash:RE_method
                        name: ws
                        rest: ''
                    - !!perl/hash:RE_sequence
                      alt: method_def_2 2
                      zyg:
                      - !!perl/hash:RE_bracket
                        re: !!perl/hash:RE_sequence
                          zyg:
                          - !!perl/hash:RE_string
                            i: 0
                            text: '{'
                          - !!perl/hash:RE_block {}
                          - !!perl/hash:RE_method
                            name: signature
                            rest: ''
                          - !!perl/hash:RE_bracket
                            re: !!perl/hash:RE_first
                              zyg:
                              - !!perl/hash:RE_string
                                i: 0
                                text: '}'
                              - !!perl/hash:RE_method
                                name: FAILGOAL
                                rest: 1
                      - !!perl/hash:RE_method
                        name: ws
                        rest: ''
                    - !!perl/hash:RE_sequence
                      alt: method_def_2 3
                      zyg:
                      - !!perl/hash:RE_assertion
                        assert: '?'
                        re: !!perl/hash:RE_method_re
                          name: before
                          nobind: 1
                          re: !!perl/hash:RE_sequence
                            zyg:
                            - !!perl/hash:RE_method
                              name: ws
                              rest: ''
                            - !!perl/hash:RE_string
                              i: 0
                              text: <
                      - !!perl/hash:RE_method
                        name: postcircumfix
                        rest: ''
                      - !!perl/hash:RE_method
                        name: ws
                        rest: ''
                - !!perl/hash:RE_quantified_atom
                  atom: !!perl/hash:RE_method
                    name: trait
                    rest: ''
                  quant:
                  - '*'
                - !!perl/hash:RE_method
                  name: ws
                  rest: ''
              - !!perl/hash:RE_assertion
                alt: method_def_0 3
                assert: '?'
                re: !!perl/hash:RE_noop
                  nobind: 1
          - !!perl/hash:RE_block {}
          - !!perl/hash:RE_method
            name: blockoid
            rest: ''
          - !!perl/hash:RE_method
            name: checkyada
            rest: ''
          - !!perl/hash:RE_method
            name: getsig
            rest: ''
          - !!perl/hash:RE_method
            name: getdecl
            rest: ''
      - !!perl/hash:RE_method
        name: ws
        rest: ''
    - !!perl/hash:RE_sequence
      zyg:
      - !!perl/hash:RE_method
        name: ws
        rest: ''
      - !!perl/hash:RE_method
        name: panic
        rest: 1
      - !!perl/hash:RE_method
        name: ws
        rest: ''
method_def_0: *33
method_def_1: *34
method_def_2: *35
methodop: !!perl/hash:RE_ast
  dba: method arguments
  dic: STD::P6
  re: !!perl/hash:RE_sequence
    zyg:
    - !!perl/hash:RE_bracket
      re: &36 !!perl/hash:RE_any
        altname: methodop_0
        dba: methodop
        dic: STD::P6
        zyg:
        - !!perl/hash:RE_method
          alt: methodop_0 0
          name: longname
          rest: ''
        - !!perl/hash:RE_sequence
          alt: methodop_0 1
          zyg:
          - !!perl/hash:RE_assertion
            assert: '?'
            re: !!perl/hash:RE_method_re
              name: before
              nobind: 1
              re: &37 !!perl/hash:RE_any
                altname: methodop_1
                dba: methodop
                dic: STD::P6
                zyg:
                - !!perl/hash:RE_string
                  alt: methodop_1 0
                  i: 0
                  text: $
                - !!perl/hash:RE_string
                  alt: methodop_1 1
                  i: 0
                  text: '@'
                - !!perl/hash:RE_string
                  alt: methodop_1 2
                  i: 0
                  text: '&'
          - !!perl/hash:RE_method
            name: variable
            rest: ''
          - !!perl/hash:RE_block {}
        - !!perl/hash:RE_sequence
          alt: methodop_0 2
          zyg:
          - !!perl/hash:RE_assertion
            assert: '?'
            re: !!perl/hash:RE_method_re
              name: before
              nobind: 1
              re: !!perl/hash:RE_cclass
                i: 0
                text: '[ '' " ]'
          - !!perl/hash:RE_bracket
            re: !!perl/hash:RE_first
              zyg:
              - !!perl/hash:RE_assertion
                assert: '!'
                re: !!perl/hash:RE_block
                  nobind: 1
              - !!perl/hash:RE_assertion
                assert: '!'
                re: !!perl/hash:RE_method_re
                  name: before
                  nobind: 1
                  re: !!perl/hash:RE_sequence
                    zyg:
                    - !!perl/hash:RE_string
                      i: 0
                      text: '"'
                    - !!perl/hash:RE_quantified_atom
                      atom: !!perl/hash:RE_cclass
                        i: 0
                        text: -["]
                      quant:
                      - '*'
                    - !!perl/hash:RE_meta
                      min: 1
                      text: \s
          - !!perl/hash:RE_method
            name: quote
            rest: ''
          - !!perl/hash:RE_bracket
            re: !!perl/hash:RE_first
              zyg:
              - !!perl/hash:RE_assertion
                assert: '?'
                re: !!perl/hash:RE_method_re
                  name: before
                  nobind: 1
                  re: &38 !!perl/hash:RE_any
                    altname: methodop_2
                    dba: methodop
                    dic: STD::P6
                    zyg:
                    - !!perl/hash:RE_string
                      alt: methodop_2 0
                      i: 0
                      text: (
                    - !!perl/hash:RE_string
                      alt: methodop_2 1
                      i: 0
                      text: .(
                    - !!perl/hash:RE_string
                      alt: methodop_2 2
                      i: 0
                      text: \
              - !!perl/hash:RE_method
                name: obs
                rest: 1
          - !!perl/hash:RE_block {}
    - !!perl/hash:RE_quantified_atom
      atom: !!perl/hash:RE_method
        name: unsp
        rest: ''
      quant:
      - '?'
    - !!perl/hash:RE_quantified_atom
      atom: !!perl/hash:RE_bracket
        re: &39 !!perl/hash:RE_any
          altname: methodop_3
          dba: method arguments
          dic: STD::P6
          zyg:
          - !!perl/hash:RE_sequence
            alt: methodop_3 0
            zyg:
            - !!perl/hash:RE_string
              i: 0
              text: ':'
            - !!perl/hash:RE_assertion
              assert: '?'
              re: !!perl/hash:RE_method_re
                name: before
                nobind: 1
                re: &40 !!perl/hash:RE_any
                  altname: methodop_4
                  dba: method arguments
                  dic: STD::P6
                  zyg:
                  - !!perl/hash:RE_meta
                    alt: methodop_4 0
                    min: 1
                    text: \s
                  - !!perl/hash:RE_string
                    alt: methodop_4 1
                    i: 0
                    text: '{'
            - !!perl/hash:RE_assertion
              assert: '!'
              re: !!perl/hash:RE_block
                nobind: 1
            - !!perl/hash:RE_method
              name: arglist
              rest: ''
          - !!perl/hash:RE_sequence
            alt: methodop_3 1
            zyg:
            - !!perl/hash:RE_assertion
              assert: '?'
              re: !!perl/hash:RE_cclass
                i: 0
                nobind: 1
                text: '[\\(]'
            - !!perl/hash:RE_method
              name: args
              rest: ''
          - !!perl/hash:RE_block
            alt: methodop_3 2
      quant:
      - '?'
methodop_0: *36
methodop_1: *37
methodop_2: *38
methodop_3: *39
methodop_4: *40
modifier_expr: !!perl/hash:RE_ast
  dba: modifier_expr
  dic: STD::P6
  re: !!perl/hash:RE_sequence
    zyg:
    - !!perl/hash:RE_method
      name: ws
      rest: ''
    - !!perl/hash:RE_method
      name: EXPR
      rest: ''
    - !!perl/hash:RE_method
      name: ws
      rest: ''
module_name__S_039normal: !!perl/hash:RE_ast
  dba: module_name
  dic: STD::P6
  re: !!perl/hash:RE_sequence
    zyg:
    - !!perl/hash:RE_method
      name: longname
      rest: ''
    - !!perl/hash:RE_quantified_atom
      atom: !!perl/hash:RE_bracket
        re: !!perl/hash:RE_sequence
          zyg:
          - !!perl/hash:RE_assertion
            assert: '?'
            re: !!perl/hash:RE_method_re
              name: before
              nobind: 1
              re: !!perl/hash:RE_string
                i: 0
                text: '['
          - !!perl/hash:RE_bracket
            re: !!perl/hash:RE_sequence
              zyg:
              - !!perl/hash:RE_string
                i: 0
                text: '['
              - !!perl/hash:RE_block {}
              - !!perl/hash:RE_method
                name: arglist
                rest: ''
              - !!perl/hash:RE_bracket
                re: !!perl/hash:RE_first
                  zyg:
                  - !!perl/hash:RE_string
                    i: 0
                    text: ']'
                  - !!perl/hash:RE_method
                    name: FAILGOAL
                    rest: 1
      quant:
      - '?'
multi_declarator__S_058multi: !!perl/hash:RE_ast
  dba: multi_declarator
  dic: STD::P6
  re: !!perl/hash:RE_sequence
    zyg:
    - !!perl/hash:RE_method
      endsym: spacey
      i: 0
      name: sym
      rest: ''
      sym: multi
    - !!perl/hash:RE_method
      name: spacey
      rest: ''
    - !!perl/hash:RE_method
      name: ws
      rest: ''
    - !!perl/hash:RE_bracket
      re: !!perl/hash:RE_first
        zyg:
        - !!perl/hash:RE_method
          name: declarator
          rest: ''
        - !!perl/hash:RE_method
          name: routine_def
          rest: 1
        - !!perl/hash:RE_method
          name: panic
          rest: 1
multi_declarator__S_059proto: !!perl/hash:RE_ast
  dba: multi_declarator
  dic: STD::P6
  re: !!perl/hash:RE_sequence
    zyg:
    - !!perl/hash:RE_method
      endsym: spacey
      i: 0
      name: sym
      rest: ''
      sym: proto
    - !!perl/hash:RE_method
      name: spacey
      rest: ''
    - !!perl/hash:RE_method
      name: ws
      rest: ''
    - !!perl/hash:RE_bracket
      re: !!perl/hash:RE_first
        zyg:
        - !!perl/hash:RE_method
          name: declarator
          rest: ''
        - !!perl/hash:RE_method
          name: routine_def
          rest: 1
        - !!perl/hash:RE_method
          name: panic
          rest: 1
multi_declarator__S_060only: !!perl/hash:RE_ast
  dba: multi_declarator
  dic: STD::P6
  re: !!perl/hash:RE_sequence
    zyg:
    - !!perl/hash:RE_method
      endsym: spacey
      i: 0
      name: sym
      rest: ''
      sym: only
    - !!perl/hash:RE_method
      name: spacey
      rest: ''
    - !!perl/hash:RE_method
      name: ws
      rest: ''
    - !!perl/hash:RE_bracket
      re: !!perl/hash:RE_first
        zyg:
        - !!perl/hash:RE_method
          name: declarator
          rest: ''
        - !!perl/hash:RE_method
          name: routine_def
          rest: 1
        - !!perl/hash:RE_method
          name: panic
          rest: 1
multi_declarator__S_061null: !!perl/hash:RE_ast
  dba: multi_declarator
  dic: STD::P6
  re: !!perl/hash:RE_method
    name: declarator
    rest: ''
multisig: !!perl/hash:RE_ast
  dba: signature
  dic: STD::P6
  re: !!perl/hash:RE_sequence
    zyg:
    - !!perl/hash:RE_method
      name: ws
      rest: ''
    - !!perl/hash:RE_quantified_atom
      atom: !!perl/hash:RE_bracket
        re: !!perl/hash:RE_sequence
          zyg:
          - !!perl/hash:RE_method
            name: ws
            rest: ''
          - !!perl/hash:RE_quantified_atom
            atom: !!perl/hash:RE_string
              i: 0
              text: ':'
            quant:
            - '?'
          - !!perl/hash:RE_bracket
            re: !!perl/hash:RE_sequence
              zyg:
              - !!perl/hash:RE_string
                i: 0
                text: (
              - !!perl/hash:RE_block {}
              - !!perl/hash:RE_method
                name: signature
                rest: 1
              - !!perl/hash:RE_bracket
                re: !!perl/hash:RE_first
                  zyg:
                  - !!perl/hash:RE_string
                    i: 0
                    text: )
                  - !!perl/hash:RE_method
                    name: FAILGOAL
                    rest: 1
          - !!perl/hash:RE_method
            name: ws
            rest: ''
      quant:
      - '**'
      - ':'
      - !!perl/hash:RE_string
        a: 0
        dba: signature
        dic: STD::P6
        i: 0
        i_needed: 1
        r: 1
        s: 1
        text: '|'
    - !!perl/hash:RE_method
      name: ws
      rest: ''
named_param: !!perl/hash:RE_ast
  dba: named_param
  dic: STD::P6
  re: !!perl/hash:RE_sequence
    zyg:
    - !!perl/hash:RE_string
      i: 0
      text: ':'
    - !!perl/hash:RE_bracket
      re: &41 !!perl/hash:RE_any
        altname: named_param_0
        dba: named_param
        dic: STD::P6
        zyg:
        - !!perl/hash:RE_sequence
          alt: named_param_0 0
          zyg:
          - !!perl/hash:RE_bindnamed
            atom: !!perl/hash:RE_method
              name: identifier
              rest: ''
          - !!perl/hash:RE_string
            i: 0
            text: (
          - !!perl/hash:RE_method
            name: ws
            rest: ''
          - !!perl/hash:RE_bracket
            re: &42 !!perl/hash:RE_any
              altname: named_param_1
              dba: named_param
              dic: STD::P6
              zyg:
              - !!perl/hash:RE_method
                alt: named_param_1 0
                name: named_param
                rest: ''
              - !!perl/hash:RE_sequence
                alt: named_param_1 1
                zyg:
                - !!perl/hash:RE_method
                  name: param_var
                  rest: ''
                - !!perl/hash:RE_method
                  name: ws
                  rest: ''
          - !!perl/hash:RE_bracket
            re: !!perl/hash:RE_first
              zyg:
              - !!perl/hash:RE_string
                i: 0
                text: )
              - !!perl/hash:RE_method
                name: panic
                rest: 1
        - !!perl/hash:RE_method
          alt: named_param_0 1
          name: param_var
          rest: 1
named_param_0: *41
named_param_1: *42
nullterm: !!perl/hash:RE_ast
  dba: nullterm
  dic: STD::P6
  re: !!perl/hash:RE_assertion
    assert: '?'
    re: !!perl/hash:RE_noop
      nobind: 1
nulltermish: !!perl/hash:RE_ast
  dba: null term
  dic: STD::P6
  re: !!perl/hash:RE_bracket
    re: &43 !!perl/hash:RE_any
      altname: nulltermish_0
      dba: null term
      dic: STD::P6
      zyg:
      - !!perl/hash:RE_assertion
        alt: nulltermish_0 0
        assert: '?'
        re: !!perl/hash:RE_method
          name: stdstopper
          rest: ''
      - !!perl/hash:RE_sequence
        alt: nulltermish_0 1
        zyg:
        - !!perl/hash:RE_bindnamed
          atom: !!perl/hash:RE_method
            name: termish
            rest: ''
        - !!perl/hash:RE_block {}
      - !!perl/hash:RE_assertion
        alt: nulltermish_0 2
        assert: '?'
        re: !!perl/hash:RE_noop
          nobind: 1
nulltermish_0: *43
number: !!perl/hash:RE_ast
  dba: number
  dic: STD::P6
  re: !!perl/hash:RE_bracket
    re: &44 !!perl/hash:RE_any
      altname: number_0
      dba: number
      dic: STD::P6
      zyg:
      - !!perl/hash:RE_sequence
        alt: number_0 0
        zyg:
        - !!perl/hash:RE_string
          i: 0
          text: 'NaN'
        - !!perl/hash:RE_meta
          text: »
      - !!perl/hash:RE_method
        alt: number_0 1
        name: integer
        rest: ''
      - !!perl/hash:RE_method
        alt: number_0 2
        name: dec_number
        rest: ''
      - !!perl/hash:RE_method
        alt: number_0 3
        name: rad_number
        rest: ''
      - !!perl/hash:RE_sequence
        alt: number_0 4
        zyg:
        - !!perl/hash:RE_string
          i: 0
          text: 'Inf'
        - !!perl/hash:RE_meta
          text: »
number_0: *44
old_rx_mods: !!perl/hash:RE_ast
  dba: old_rx_mods
  dic: STD::P6
  re: !!perl/hash:RE_sequence
    zyg:
    - !!perl/hash:RE_assertion
      assert: '!'
      re: !!perl/hash:RE_method_re
        name: after
        nobind: 1
        re: !!perl/hash:RE_meta
          min: 1
          text: \s
    - !!perl/hash:RE_bindpos
      atom: !!perl/hash:RE_paren
        re: !!perl/hash:RE_quantified_atom
          atom: !!perl/hash:RE_qw
            min: 1
            text: < i g s m x c e >
          quant:
          - +
    - !!perl/hash:RE_block {}
old_tr_mods: !!perl/hash:RE_ast
  dba: old_tr_mods
  dic: STD::P6
  re: !!perl/hash:RE_sequence
    zyg:
    - !!perl/hash:RE_bindpos
      atom: !!perl/hash:RE_paren
        re: !!perl/hash:RE_quantified_atom
          atom: !!perl/hash:RE_qw
            min: 1
            text: < c d s ] >
          quant:
          - +
    - !!perl/hash:RE_block {}
package_declarator__S_048class: !!perl/hash:RE_ast
  dba: package_declarator
  dic: STD::P6
  re: !!perl/hash:RE_sequence
    zyg:
    - !!perl/hash:RE_method
      endsym: spacey
      i: 0
      name: sym
      rest: ''
      sym: class
    - !!perl/hash:RE_method
      name: spacey
      rest: ''
    - !!perl/hash:RE_method
      name: package_def
      rest: ''
package_declarator__S_049grammar: !!perl/hash:RE_ast
  dba: package_declarator
  dic: STD::P6
  re: !!perl/hash:RE_sequence
    zyg:
    - !!perl/hash:RE_method
      endsym: spacey
      i: 0
      name: sym
      rest: ''
      sym: grammar
    - !!perl/hash:RE_method
      name: spacey
      rest: ''
    - !!perl/hash:RE_method
      name: package_def
      rest: ''
package_declarator__S_050module: !!perl/hash:RE_ast
  dba: package_declarator
  dic: STD::P6
  re: !!perl/hash:RE_sequence
    zyg:
    - !!perl/hash:RE_method
      endsym: spacey
      i: 0
      name: sym
      rest: ''
      sym: module
    - !!perl/hash:RE_method
      name: spacey
      rest: ''
    - !!perl/hash:RE_method
      name: package_def
      rest: ''
package_declarator__S_051package: !!perl/hash:RE_ast
  dba: package_declarator
  dic: STD::P6
  re: !!perl/hash:RE_sequence
    zyg:
    - !!perl/hash:RE_method
      endsym: spacey
      i: 0
      name: sym
      rest: ''
      sym: package
    - !!perl/hash:RE_method
      name: spacey
      rest: ''
    - !!perl/hash:RE_method
      name: package_def
      rest: ''
package_declarator__S_052role: !!perl/hash:RE_ast
  dba: package_declarator
  dic: STD::P6
  re: !!perl/hash:RE_sequence
    zyg:
    - !!perl/hash:RE_method
      endsym: spacey
      i: 0
      name: sym
      rest: ''
      sym: role
    - !!perl/hash:RE_method
      name: spacey
      rest: ''
    - !!perl/hash:RE_method
      name: package_def
      rest: ''
package_declarator__S_053knowhow: !!perl/hash:RE_ast
  dba: package_declarator
  dic: STD::P6
  re: !!perl/hash:RE_sequence
    zyg:
    - !!perl/hash:RE_method
      endsym: spacey
      i: 0
      name: sym
      rest: ''
      sym: knowhow
    - !!perl/hash:RE_method
      name: spacey
      rest: ''
    - !!perl/hash:RE_method
      name: package_def
      rest: ''
package_declarator__S_054slang: !!perl/hash:RE_ast
  dba: package_declarator
  dic: STD::P6
  re: !!perl/hash:RE_sequence
    zyg:
    - !!perl/hash:RE_method
      endsym: spacey
      i: 0
      name: sym
      rest: ''
      sym: slang
    - !!perl/hash:RE_method
      name: spacey
      rest: ''
    - !!perl/hash:RE_method
      name: package_def
      rest: ''
package_declarator__S_055require: !!perl/hash:RE_ast
  dba: package_declarator
  dic: STD::P6
  re: !!perl/hash:RE_sequence
    zyg:
    - !!perl/hash:RE_method
      endsym: spacey
      i: 0
      name: sym
      rest: ''
      sym: require
    - !!perl/hash:RE_method
      name: spacey
      rest: ''
    - !!perl/hash:RE_method
      name: ws
      rest: ''
    - !!perl/hash:RE_bracket
      re: !!perl/hash:RE_first
        zyg:
        - !!perl/hash:RE_sequence
          zyg:
          - !!perl/hash:RE_method
            name: module_name
            rest: ''
          - !!perl/hash:RE_quantified_atom
            atom: !!perl/hash:RE_method
              name: EXPR
              rest: ''
            quant:
            - '?'
        - !!perl/hash:RE_method
          name: EXPR
          rest: ''
package_declarator__S_056trusts: !!perl/hash:RE_ast
  dba: package_declarator
  dic: STD::P6
  re: !!perl/hash:RE_sequence
    zyg:
    - !!perl/hash:RE_method
      endsym: spacey
      i: 0
      name: sym
      rest: ''
      sym: trusts
    - !!perl/hash:RE_method
      name: spacey
      rest: ''
    - !!perl/hash:RE_method
      name: ws
      rest: ''
    - !!perl/hash:RE_method
      name: module_name
      rest: ''
package_declarator__S_057also: !!perl/hash:RE_ast
  dba: package_declarator
  dic: STD::P6
  re: !!perl/hash:RE_sequence
    zyg:
    - !!perl/hash:RE_method
      endsym: spacey
      i: 0
      name: sym
      rest: ''
      sym: also
    - !!perl/hash:RE_method
      name: spacey
      rest: ''
    - !!perl/hash:RE_method
      name: ws
      rest: ''
    - !!perl/hash:RE_quantified_atom
      atom: !!perl/hash:RE_method
        name: trait
        rest: ''
      quant:
      - +
    - !!perl/hash:RE_method
      name: ws
      rest: ''
package_def: !!perl/hash:RE_ast
  dba: package_def
  dic: STD::P6
  re: !!perl/hash:RE_first
    zyg:
    - !!perl/hash:RE_sequence
      zyg:
      - !!perl/hash:RE_method
        name: ws
        rest: ''
      - !!perl/hash:RE_block {}
      - !!perl/hash:RE_bracket
        re: !!perl/hash:RE_sequence
          zyg:
          - !!perl/hash:RE_quantified_atom
            atom: !!perl/hash:RE_bracket
              re: !!perl/hash:RE_sequence
                zyg:
                - !!perl/hash:RE_method
                  name: ws
                  rest: ''
                - !!perl/hash:RE_method
                  name: longname
                  rest: ''
                - !!perl/hash:RE_method
                  name: ws
                  rest: ''
                - !!perl/hash:RE_block {}
            quant:
            - '?'
          - !!perl/hash:RE_method
            name: ws
            rest: ''
          - !!perl/hash:RE_method
            name: newlex
            rest: ''
          - !!perl/hash:RE_method
            name: ws
            rest: ''
          - !!perl/hash:RE_quantified_atom
            atom: !!perl/hash:RE_bracket
              re: !!perl/hash:RE_sequence
                zyg:
                - !!perl/hash:RE_method
                  name: ws
                  rest: ''
                - !!perl/hash:RE_assertion
                  assert: '?'
                  re: !!perl/hash:RE_block
                    nobind: 1
                - !!perl/hash:RE_bracket
                  re: !!perl/hash:RE_sequence
                    zyg:
                    - !!perl/hash:RE_string
                      i: 0
                      text: '['
                    - !!perl/hash:RE_block {}
                    - !!perl/hash:RE_method
                      name: signature
                      rest: ''
                    - !!perl/hash:RE_bracket
                      re: !!perl/hash:RE_first
                        zyg:
                        - !!perl/hash:RE_string
                          i: 0
                          text: ']'
                        - !!perl/hash:RE_method
                          name: FAILGOAL
                          rest: 1
                - !!perl/hash:RE_method
                  name: ws
                  rest: ''
                - !!perl/hash:RE_block {}
            quant:
            - '?'
          - !!perl/hash:RE_method
            name: ws
            rest: ''
          - !!perl/hash:RE_quantified_atom
            atom: !!perl/hash:RE_method
              name: trait
              rest: ''
            quant:
            - '*'
          - !!perl/hash:RE_method
            name: ws
            rest: ''
          - !!perl/hash:RE_method
            name: getdecl
            rest: ''
          - !!perl/hash:RE_method
            name: ws
            rest: ''
          - !!perl/hash:RE_bracket
            re: !!perl/hash:RE_first
              zyg:
              - !!perl/hash:RE_sequence
                zyg:
                - !!perl/hash:RE_assertion
                  assert: '?'
                  re: !!perl/hash:RE_method_re
                    name: before
                    nobind: 1
                    re: !!perl/hash:RE_sequence
                      zyg:
                      - !!perl/hash:RE_method
                        name: ws
                        rest: ''
                      - !!perl/hash:RE_string
                        i: 0
                        text: '{'
                - !!perl/hash:RE_bracket
                  re: !!perl/hash:RE_sequence
                    zyg:
                    - !!perl/hash:RE_block {}
                    - !!perl/hash:RE_block {}
                    - !!perl/hash:RE_method
                      name: blockoid
                      rest: ''
                    - !!perl/hash:RE_method
                      name: ws
                      rest: ''
                    - !!perl/hash:RE_method
                      name: checkyada
                      rest: ''
                    - !!perl/hash:RE_method
                      name: ws
                      rest: ''
              - !!perl/hash:RE_sequence
                zyg:
                - !!perl/hash:RE_assertion
                  assert: '?'
                  re: !!perl/hash:RE_method_re
                    name: before
                    nobind: 1
                    re: !!perl/hash:RE_sequence
                      zyg:
                      - !!perl/hash:RE_method
                        name: ws
                        rest: ''
                      - !!perl/hash:RE_string
                        i: 0
                        text: ;
                - !!perl/hash:RE_bracket
                  re: !!perl/hash:RE_first
                    zyg:
                    - !!perl/hash:RE_sequence
                      zyg:
                      - !!perl/hash:RE_assertion
                        assert: '?'
                        re: !!perl/hash:RE_block
                          nobind: 1
                      - !!perl/hash:RE_block {}
                      - !!perl/hash:RE_block {}
                      - !!perl/hash:RE_method
                        name: statementlist
                        rest: ''
                      - !!perl/hash:RE_method
                        name: ws
                        rest: ''
                    - !!perl/hash:RE_sequence
                      zyg:
                      - !!perl/hash:RE_method
                        name: panic
                        rest: 1
                      - !!perl/hash:RE_method
                        name: ws
                        rest: ''
              - !!perl/hash:RE_sequence
                zyg:
                - !!perl/hash:RE_method
                  name: panic
                  rest: 1
                - !!perl/hash:RE_method
                  name: ws
                  rest: ''
    - !!perl/hash:RE_sequence
      zyg:
      - !!perl/hash:RE_method
        name: ws
        rest: ''
      - !!perl/hash:RE_method
        name: panic
        rest: 1
      - !!perl/hash:RE_method
        name: ws
        rest: ''
param_sep: !!perl/hash:RE_ast
  dba: param_sep
  dic: STD::P6
  re: !!perl/hash:RE_sequence
    zyg:
    - !!perl/hash:RE_method
      name: ws
      rest: ''
    - !!perl/hash:RE_bracket
      re: &45 !!perl/hash:RE_any
        altname: param_sep_0
        dba: param_sep
        dic: STD::P6
        zyg:
        - !!perl/hash:RE_string
          alt: param_sep_0 0
          i: 0
          text: ','
        - !!perl/hash:RE_string
          alt: param_sep_0 1
          i: 0
          text: ':'
        - !!perl/hash:RE_string
          alt: param_sep_0 2
          i: 0
          text: ;
        - !!perl/hash:RE_string
          alt: param_sep_0 3
          i: 0
          text: ;;
    - !!perl/hash:RE_method
      name: ws
      rest: ''
param_sep_0: *45
param_var: !!perl/hash:RE_ast
  dba: formal parameter
  dic: STD::P6
  re: !!perl/hash:RE_bracket
    re: &46 !!perl/hash:RE_any
      altname: param_var_0
      dba: formal parameter
      dic: STD::P6
      zyg:
      - !!perl/hash:RE_bracket
        alt: param_var_0 0
        re: !!perl/hash:RE_sequence
          zyg:
          - !!perl/hash:RE_string
            i: 0
            text: '['
          - !!perl/hash:RE_block {}
          - !!perl/hash:RE_method
            name: signature
            rest: ''
          - !!perl/hash:RE_bracket
            re: !!perl/hash:RE_first
              zyg:
              - !!perl/hash:RE_string
                i: 0
                text: ']'
              - !!perl/hash:RE_method
                name: FAILGOAL
                rest: 1
      - !!perl/hash:RE_bracket
        alt: param_var_0 1
        re: !!perl/hash:RE_sequence
          zyg:
          - !!perl/hash:RE_string
            i: 0
            text: (
          - !!perl/hash:RE_block {}
          - !!perl/hash:RE_method
            name: signature
            rest: ''
          - !!perl/hash:RE_bracket
            re: !!perl/hash:RE_first
              zyg:
              - !!perl/hash:RE_string
                i: 0
                text: )
              - !!perl/hash:RE_method
                name: FAILGOAL
                rest: 1
      - !!perl/hash:RE_sequence
        alt: param_var_0 2
        zyg:
        - !!perl/hash:RE_method
          name: sigil
          rest: ''
        - !!perl/hash:RE_quantified_atom
          atom: !!perl/hash:RE_method
            name: twigil
            rest: ''
          quant:
          - '?'
        - !!perl/hash:RE_quantified_atom
          atom: !!perl/hash:RE_bracket
            re: !!perl/hash:RE_first
              zyg:
              - !!perl/hash:RE_sequence
                zyg:
                - !!perl/hash:RE_assertion
                  assert: '?'
                  re: !!perl/hash:RE_block
                    nobind: 1
                - !!perl/hash:RE_assertion
                  assert: '?'
                  re: !!perl/hash:RE_method
                    name: ident
                    rest: ''
                - !!perl/hash:RE_block {}
                - !!perl/hash:RE_bindnamed
                  atom: !!perl/hash:RE_method
                    name: sublongname
                    rest: ''
              - !!perl/hash:RE_sequence
                zyg:
                - !!perl/hash:RE_assertion
                  assert: '?'
                  re: !!perl/hash:RE_block
                    nobind: 1
                - !!perl/hash:RE_quantified_atom
                  atom: !!perl/hash:RE_bindnamed
                    atom: !!perl/hash:RE_method
                      name: identifier
                      rest: ''
                  quant:
                  - '?'
                - !!perl/hash:RE_assertion
                  assert: '?'
                  re: !!perl/hash:RE_method_re
                    name: before
                    nobind: 1
                    re: !!perl/hash:RE_cclass
                      i: 0
                      text: '[ \< \( \[ \{ ]'
                - !!perl/hash:RE_method
                  name: postcircumfix
                  rest: ''
              - !!perl/hash:RE_bindnamed
                atom: !!perl/hash:RE_method
                  name: identifier
                  rest: ''
              - !!perl/hash:RE_sequence
                zyg:
                - !!perl/hash:RE_bindnamed
                  atom: !!perl/hash:RE_method
                    name: decint
                    rest: ''
                - !!perl/hash:RE_method
                  name: panic
                  rest: 1
              - !!perl/hash:RE_bindnamed
                atom: !!perl/hash:RE_bracket
                  re: !!perl/hash:RE_cclass
                    i: 0
                    text: '[/!]'
          quant:
          - '?'
        - !!perl/hash:RE_block {}
param_var_0: *46
parameter: !!perl/hash:RE_ast
  dba: parameter
  dic: STD::P6
  re: !!perl/hash:RE_sequence
    zyg:
    - !!perl/hash:RE_bracket
      re: &47 !!perl/hash:RE_any
        altname: parameter_0
        dba: parameter
        dic: STD::P6
        zyg:
        - !!perl/hash:RE_sequence
          alt: parameter_0 0
          zyg:
          - !!perl/hash:RE_quantified_atom
            atom: !!perl/hash:RE_method
              name: type_constraint
              rest: ''
            quant:
            - +
          - !!perl/hash:RE_block {}
          - !!perl/hash:RE_bracket
            re: &48 !!perl/hash:RE_any
              altname: parameter_1
              dba: parameter
              dic: STD::P6
              zyg:
              - !!perl/hash:RE_sequence
                alt: parameter_1 0
                zyg:
                - !!perl/hash:RE_string
                  i: 0
                  text: '**'
                - !!perl/hash:RE_method
                  name: param_var
                  rest: ''
                - !!perl/hash:RE_block {}
              - !!perl/hash:RE_sequence
                alt: parameter_1 1
                zyg:
                - !!perl/hash:RE_string
                  i: 0
                  text: '*'
                - !!perl/hash:RE_method
                  name: param_var
                  rest: ''
                - !!perl/hash:RE_block {}
              - !!perl/hash:RE_sequence
                alt: parameter_1 2
                zyg:
                - !!perl/hash:RE_string
                  i: 0
                  text: '|'
                - !!perl/hash:RE_method
                  name: param_var
                  rest: ''
                - !!perl/hash:RE_block {}
              - !!perl/hash:RE_sequence
                alt: parameter_1 3
                zyg:
                - !!perl/hash:RE_string
                  i: 0
                  text: \
                - !!perl/hash:RE_method
                  name: param_var
                  rest: ''
                - !!perl/hash:RE_block {}
              - !!perl/hash:RE_sequence
                alt: parameter_1 4
                zyg:
                - !!perl/hash:RE_bracket
                  re: &49 !!perl/hash:RE_any
                    altname: parameter_2
                    dba: parameter
                    dic: STD::P6
                    zyg:
                    - !!perl/hash:RE_sequence
                      alt: parameter_2 0
                      zyg:
                      - !!perl/hash:RE_method
                        name: param_var
                        rest: ''
                      - !!perl/hash:RE_block {}
                    - !!perl/hash:RE_sequence
                      alt: parameter_2 1
                      zyg:
                      - !!perl/hash:RE_method
                        name: named_param
                        rest: ''
                      - !!perl/hash:RE_block {}
                - !!perl/hash:RE_bracket
                  re: &50 !!perl/hash:RE_any
                    altname: parameter_3
                    dba: parameter
                    dic: STD::P6
                    zyg:
                    - !!perl/hash:RE_sequence
                      alt: parameter_3 0
                      zyg:
                      - !!perl/hash:RE_string
                        i: 0
                        text: '?'
                      - !!perl/hash:RE_block {}
                    - !!perl/hash:RE_sequence
                      alt: parameter_3 1
                      zyg:
                      - !!perl/hash:RE_string
                        i: 0
                        text: '!'
                      - !!perl/hash:RE_block {}
                    - !!perl/hash:RE_assertion
                      alt: parameter_3 2
                      assert: '?'
                      re: !!perl/hash:RE_noop
                        nobind: 1
              - !!perl/hash:RE_sequence
                alt: parameter_1 5
                zyg:
                - !!perl/hash:RE_assertion
                  assert: '?'
                  re: !!perl/hash:RE_noop
                    nobind: 1
                - !!perl/hash:RE_block {}
        - !!perl/hash:RE_sequence
          alt: parameter_0 1
          zyg:
          - !!perl/hash:RE_string
            i: 0
            text: '**'
          - !!perl/hash:RE_method
            name: param_var
            rest: ''
          - !!perl/hash:RE_block {}
        - !!perl/hash:RE_sequence
          alt: parameter_0 2
          zyg:
          - !!perl/hash:RE_string
            i: 0
            text: '*'
          - !!perl/hash:RE_method
            name: param_var
            rest: ''
          - !!perl/hash:RE_block {}
        - !!perl/hash:RE_sequence
          alt: parameter_0 3
          zyg:
          - !!perl/hash:RE_string
            i: 0
            text: '|'
          - !!perl/hash:RE_method
            name: param_var
            rest: ''
          - !!perl/hash:RE_block {}
        - !!perl/hash:RE_sequence
          alt: parameter_0 4
          zyg:
          - !!perl/hash:RE_string
            i: 0
            text: \
          - !!perl/hash:RE_method
            name: param_var
            rest: ''
          - !!perl/hash:RE_block {}
        - !!perl/hash:RE_sequence
          alt: parameter_0 5
          zyg:
          - !!perl/hash:RE_bracket
            re: &51 !!perl/hash:RE_any
              altname: parameter_4
              dba: parameter
              dic: STD::P6
              zyg:
              - !!perl/hash:RE_sequence
                alt: parameter_4 0
                zyg:
                - !!perl/hash:RE_method
                  name: param_var
                  rest: ''
                - !!perl/hash:RE_block {}
              - !!perl/hash:RE_sequence
                alt: parameter_4 1
                zyg:
                - !!perl/hash:RE_method
                  name: named_param
                  rest: ''
                - !!perl/hash:RE_block {}
          - !!perl/hash:RE_bracket
            re: &52 !!perl/hash:RE_any
              altname: parameter_5
              dba: parameter
              dic: STD::P6
              zyg:
              - !!perl/hash:RE_sequence
                alt: parameter_5 0
                zyg:
                - !!perl/hash:RE_string
                  i: 0
                  text: '?'
                - !!perl/hash:RE_block {}
              - !!perl/hash:RE_sequence
                alt: parameter_5 1
                zyg:
                - !!perl/hash:RE_string
                  i: 0
                  text: '!'
                - !!perl/hash:RE_block {}
              - !!perl/hash:RE_assertion
                alt: parameter_5 2
                assert: '?'
                re: !!perl/hash:RE_noop
                  nobind: 1
        - !!perl/hash:RE_sequence
          alt: parameter_0 6
          zyg:
          - !!perl/hash:RE_block {}
          - !!perl/hash:RE_method
            name: longname
            rest: ''
          - !!perl/hash:RE_method
            name: panic
            rest: 1
    - !!perl/hash:RE_quantified_atom
      atom: !!perl/hash:RE_method
        name: trait
        rest: ''
      quant:
      - '*'
    - !!perl/hash:RE_quantified_atom
      atom: !!perl/hash:RE_method
        name: post_constraint
        rest: ''
      quant:
      - '*'
    - !!perl/hash:RE_method
      name: getdecl
      rest: ''
    - !!perl/hash:RE_quantified_atom
      atom: !!perl/hash:RE_bracket
        re: !!perl/hash:RE_sequence
          zyg:
          - !!perl/hash:RE_method
            name: default_value
            rest: ''
          - !!perl/hash:RE_block {}
          - !!perl/hash:RE_quantified_atom
            atom: !!perl/hash:RE_bracket
              re: !!perl/hash:RE_sequence
                zyg:
                - !!perl/hash:RE_assertion
                  assert: '?'
                  re: !!perl/hash:RE_method_re
                    name: before
                    nobind: 1
                    re: !!perl/hash:RE_string
                      i: 0
                      text: ':'
                - !!perl/hash:RE_method
                  name: sorry
                  rest: 1
            quant:
            - '?'
          - !!perl/hash:RE_quantified_atom
            atom: !!perl/hash:RE_bracket
              re: !!perl/hash:RE_sequence
                zyg:
                - !!perl/hash:RE_assertion
                  assert: '!'
                  re: !!perl/hash:RE_method_re
                    name: before
                    nobind: 1
                    re: !!perl/hash:RE_cclass
                      i: 0
                      text: '[,;)\]\{\-]'
                - !!perl/hash:RE_method
                  name: sorry
                  rest: 1
            quant:
            - '?'
      quant:
      - '?'
    - !!perl/hash:RE_quantified_atom
      atom: !!perl/hash:RE_bracket
        re: !!perl/hash:RE_sequence
          zyg:
          - !!perl/hash:RE_assertion
            assert: '?'
            re: !!perl/hash:RE_method_re
              name: before
              nobind: 1
              re: !!perl/hash:RE_string
                i: 0
                text: ':'
          - !!perl/hash:RE_assertion
            assert: '?'
            re: !!perl/hash:RE_block
              nobind: 1
          - !!perl/hash:RE_method
            name: sorry
            rest: 1
      quant:
      - '?'
    - !!perl/hash:RE_block {}
    - !!perl/hash:RE_block {}
parameter_0: *47
parameter_1: *48
parameter_2: *49
parameter_3: *50
parameter_4: *51
parameter_5: *52
pblock: !!perl/hash:RE_ast
  dba: parameterized block
  dic: STD::P6
  re: !!perl/hash:RE_sequence
    zyg:
    - !!perl/hash:RE_bracket
      re: !!perl/hash:RE_first
        zyg:
        - !!perl/hash:RE_assertion
          assert: '?'
          re: !!perl/hash:RE_method_re
            name: before
            nobind: 1
            re: &53 !!perl/hash:RE_any
              altname: pblock_0
              dba: parameterized block
              dic: STD::P6
              zyg:
              - !!perl/hash:RE_method
                alt: pblock_0 0
                name: lambda
                rest: ''
              - !!perl/hash:RE_string
                alt: pblock_0 1
                i: 0
                text: '{'
        - !!perl/hash:RE_block {}
    - !!perl/hash:RE_bracket
      re: &54 !!perl/hash:RE_any
        altname: pblock_1
        dba: parameterized block
        dic: STD::P6
        zyg:
        - !!perl/hash:RE_sequence
          alt: pblock_1 0
          zyg:
          - !!perl/hash:RE_method
            name: lambda
            rest: ''
          - !!perl/hash:RE_method
            name: newlex
            rest: 1
          - !!perl/hash:RE_method
            name: signature
            rest: 1
          - !!perl/hash:RE_method
            name: blockoid
            rest: ''
          - !!perl/hash:RE_method
            name: getsig
            rest: ''
        - !!perl/hash:RE_sequence
          alt: pblock_1 1
          zyg:
          - !!perl/hash:RE_assertion
            assert: '?'
            re: !!perl/hash:RE_method_re
              name: before
              nobind: 1
              re: !!perl/hash:RE_string
                i: 0
                text: '{'
          - !!perl/hash:RE_method
            name: newlex
            rest: 1
          - !!perl/hash:RE_method
            name: blockoid
            rest: ''
          - !!perl/hash:RE_method
            name: getsig
            rest: ''
pblock_0: *53
pblock_1: *54
post_constraint: !!perl/hash:RE_ast
  dba: constraint
  dic: STD::P6
  re: !!perl/hash:RE_sequence
    zyg:
    - !!perl/hash:RE_method
      name: ws
      rest: ''
    - !!perl/hash:RE_bracket
      re: &55 !!perl/hash:RE_any
        altname: post_constraint_0
        dba: constraint
        dic: STD::P6
        zyg:
        - !!perl/hash:RE_sequence
          alt: post_constraint_0 0
          zyg:
          - !!perl/hash:RE_bracket
            re: !!perl/hash:RE_sequence
              zyg:
              - !!perl/hash:RE_string
                i: 0
                text: '['
              - !!perl/hash:RE_block {}
              - !!perl/hash:RE_method
                name: signature
                rest: ''
              - !!perl/hash:RE_bracket
                re: !!perl/hash:RE_first
                  zyg:
                  - !!perl/hash:RE_string
                    i: 0
                    text: ']'
                  - !!perl/hash:RE_method
                    name: FAILGOAL
                    rest: 1
          - !!perl/hash:RE_method
            name: ws
            rest: ''
        - !!perl/hash:RE_sequence
          alt: post_constraint_0 1
          zyg:
          - !!perl/hash:RE_bracket
            re: !!perl/hash:RE_sequence
              zyg:
              - !!perl/hash:RE_string
                i: 0
                text: (
              - !!perl/hash:RE_block {}
              - !!perl/hash:RE_method
                name: signature
                rest: ''
              - !!perl/hash:RE_bracket
                re: !!perl/hash:RE_first
                  zyg:
                  - !!perl/hash:RE_string
                    i: 0
                    text: )
                  - !!perl/hash:RE_method
                    name: FAILGOAL
                    rest: 1
          - !!perl/hash:RE_method
            name: ws
            rest: ''
        - !!perl/hash:RE_sequence
          alt: post_constraint_0 2
          zyg:
          - !!perl/hash:RE_string
            i: 0
            text: w
          - !!perl/hash:RE_string
            i: 0
            text: h
          - !!perl/hash:RE_string
            i: 0
            text: e
          - !!perl/hash:RE_string
            i: 0
            text: r
          - !!perl/hash:RE_string
            i: 0
            text: e
          - !!perl/hash:RE_method
            name: ws
            rest: ''
          - !!perl/hash:RE_method
            name: EXPR
            rest: 1
          - !!perl/hash:RE_method
            name: ws
            rest: ''
post_constraint_0: *55
postcircumfix__S_207Paren_Thesis: !!perl/hash:RE_ast
  dba: argument list
  dic: STD::P6
  re: !!perl/hash:RE_sequence
    zyg:
    - !!perl/hash:RE_bracket
      re: !!perl/hash:RE_sequence
        zyg:
        - !!perl/hash:RE_string
          i: 0
          text: (
        - !!perl/hash:RE_block {}
        - !!perl/hash:RE_method
          name: semiarglist
          rest: ''
        - !!perl/hash:RE_bracket
          re: !!perl/hash:RE_first
            zyg:
            - !!perl/hash:RE_string
              i: 0
              text: )
            - !!perl/hash:RE_method
              name: FAILGOAL
              rest: 1
    - !!perl/hash:RE_method
      name: O
      rest: 1
postcircumfix__S_208Bra_Ket: !!perl/hash:RE_ast
  dba: subscript
  dic: STD::P6
  re: !!perl/hash:RE_sequence
    zyg:
    - !!perl/hash:RE_bracket
      re: !!perl/hash:RE_sequence
        zyg:
        - !!perl/hash:RE_string
          i: 0
          text: '['
        - !!perl/hash:RE_block {}
        - !!perl/hash:RE_method
          name: semilist
          rest: ''
        - !!perl/hash:RE_bracket
          re: !!perl/hash:RE_first
            zyg:
            - !!perl/hash:RE_string
              i: 0
              text: ']'
            - !!perl/hash:RE_method
              name: FAILGOAL
              rest: 1
    - !!perl/hash:RE_method
      name: O
      rest: 1
    - !!perl/hash:RE_block {}
postcircumfix__S_209Cur_Ly: !!perl/hash:RE_ast
  dba: subscript
  dic: STD::P6
  re: !!perl/hash:RE_sequence
    zyg:
    - !!perl/hash:RE_bracket
      re: !!perl/hash:RE_sequence
        zyg:
        - !!perl/hash:RE_string
          i: 0
          text: '{'
        - !!perl/hash:RE_block {}
        - !!perl/hash:RE_method
          name: semilist
          rest: ''
        - !!perl/hash:RE_bracket
          re: !!perl/hash:RE_first
            zyg:
            - !!perl/hash:RE_string
              i: 0
              text: '}'
            - !!perl/hash:RE_method
              name: FAILGOAL
              rest: 1
    - !!perl/hash:RE_method
      name: O
      rest: 1
    - !!perl/hash:RE_method
      name: curlycheck
      rest: ''
postcircumfix__S_210Lt_Gt: !!perl/hash:RE_ast
  dba: postcircumfix
  dic: STD::P6
  re: !!perl/hash:RE_sequence
    zyg:
    - !!perl/hash:RE_string
      i: 0
      text: <
    - !!perl/hash:RE_block {}
    - !!perl/hash:RE_bracket
      re: !!perl/hash:RE_first
        zyg:
        - !!perl/hash:RE_sequence
          zyg:
          - !!perl/hash:RE_method
            name: nibble
            rest: 1
          - !!perl/hash:RE_string
            i: 0
            text: '>'
        - !!perl/hash:RE_sequence
          zyg:
          - !!perl/hash:RE_assertion
            assert: '?'
            re: !!perl/hash:RE_method_re
              name: before
              nobind: 1
              re: !!perl/hash:RE_sequence
                zyg:
                - !!perl/hash:RE_quantified_atom
                  atom: !!perl/hash:RE_meta
                    min: 1
                    text: \h
                  quant:
                  - '*'
                - !!perl/hash:RE_bracket
                  re: &56 !!perl/hash:RE_any
                    altname: postcircumfix__S_210Lt_Gt_0
                    dba: postcircumfix
                    dic: STD::P6
                    zyg:
                    - !!perl/hash:RE_meta
                      alt: postcircumfix__S_210Lt_Gt_0 0
                      min: 1
                      text: \d
                    - !!perl/hash:RE_method
                      alt: postcircumfix__S_210Lt_Gt_0 1
                      name: sigil
                      rest: ''
                    - !!perl/hash:RE_string
                      alt: postcircumfix__S_210Lt_Gt_0 2
                      i: 0
                      text: ':'
          - !!perl/hash:RE_block {}
        - !!perl/hash:RE_block {}
    - !!perl/hash:RE_method
      name: O
      rest: 1
postcircumfix__S_210Lt_Gt_0: *56
postcircumfix__S_211LtLt_GtGt: !!perl/hash:RE_ast
  dba: postcircumfix
  dic: STD::P6
  re: !!perl/hash:RE_sequence
    zyg:
    - !!perl/hash:RE_string
      i: 0
      text: <<
    - !!perl/hash:RE_method
      name: nibble
      rest: 1
    - !!perl/hash:RE_bracket
      re: !!perl/hash:RE_first
        zyg:
        - !!perl/hash:RE_string
          i: 0
          text: '>>'
        - !!perl/hash:RE_method
          name: panic
          rest: 1
    - !!perl/hash:RE_method
      name: O
      rest: 1
postcircumfix__S_212Fre_Nch: !!perl/hash:RE_ast
  dba: postcircumfix
  dic: STD::P6
  re: !!perl/hash:RE_sequence
    zyg:
    - !!perl/hash:RE_string
      i: 0
      text: «
    - !!perl/hash:RE_method
      name: nibble
      rest: 1
    - !!perl/hash:RE_bracket
      re: !!perl/hash:RE_first
        zyg:
        - !!perl/hash:RE_string
          i: 0
          text: »
        - !!perl/hash:RE_method
          name: panic
          rest: 1
    - !!perl/hash:RE_method
      name: O
      rest: 1
postfix__S_215i: !!perl/hash:RE_ast
  dba: postfix
  dic: STD::P6
  re: !!perl/hash:RE_sequence
    zyg:
    - !!perl/hash:RE_method
      i: 0
      name: sym
      rest: ''
      sym: i
    - !!perl/hash:RE_meta
      text: »
    - !!perl/hash:RE_method
      name: O
      rest: 1
postfix__S_217MinusGt: !!perl/hash:RE_ast
  dba: postfix
  dic: STD::P6
  re: !!perl/hash:RE_sequence
    zyg:
    - !!perl/hash:RE_string
      i: 0
      text: ->
    - !!perl/hash:RE_bracket
      re: &57 !!perl/hash:RE_any
        altname: postfix__S_217MinusGt_0
        dba: postfix
        dic: STD::P6
        zyg:
        - !!perl/hash:RE_sequence
          alt: postfix__S_217MinusGt_0 0
          zyg:
          - !!perl/hash:RE_bindnamed
            atom: !!perl/hash:RE_cclass
              i: 0
              text: '[ \[ \{ \( ]'
          - !!perl/hash:RE_method
            name: obs
            rest: 1
        - !!perl/hash:RE_method
          alt: postfix__S_217MinusGt_0 1
          name: obs
          rest: 1
postfix__S_217MinusGt_0: *57
postfix__S_218PlusPlus: !!perl/hash:RE_ast
  dba: postfix
  dic: STD::P6
  re: !!perl/hash:RE_sequence
    zyg:
    - !!perl/hash:RE_method
      i: 0
      name: sym
      rest: ''
      sym: ++
    - !!perl/hash:RE_method
      name: O
      rest: 1
postfix__S_219MinusMinus: !!perl/hash:RE_ast
  dba: postfix
  dic: STD::P6
  re: !!perl/hash:RE_sequence
    zyg:
    - !!perl/hash:RE_method
      i: 0
      name: sym
      rest: ''
      sym: --
    - !!perl/hash:RE_method
      name: O
      rest: 1
postfix_prefix_meta_operator__S_198Nch: !!perl/hash:RE_ast
  dba: postfix_prefix_meta_operator
  dic: STD::P6
  re: !!perl/hash:RE_sequence
    zyg:
    - !!perl/hash:RE_bracket
      re: &58 !!perl/hash:RE_any
        altname: postfix_prefix_meta_operator__S_198Nch_0
        dba: postfix_prefix_meta_operator
        dic: STD::P6
        zyg:
        - !!perl/hash:RE_method
          alt: postfix_prefix_meta_operator__S_198Nch_0 0
          i: 0
          name: sym
          rest: ''
          sym: »
        - !!perl/hash:RE_string
          alt: postfix_prefix_meta_operator__S_198Nch_0 1
          i: 0
          text: '>>'
    - !!perl/hash:RE_bracket
      re: !!perl/hash:RE_first
        zyg:
        - !!perl/hash:RE_assertion
          assert: '!'
          re: !!perl/hash:RE_block
            nobind: 1
        - !!perl/hash:RE_assertion
          assert: '!'
          re: !!perl/hash:RE_method_re
            name: before
            nobind: 1
            re: !!perl/hash:RE_string
              i: 0
              text: (
postfix_prefix_meta_operator__S_198Nch_0: *58
postop: !!perl/hash:RE_ast
  dba: postop
  dic: STD::P6
  re: &59 !!perl/hash:RE_any
    altname: postop_0
    dba: postop
    dic: STD::P6
    zyg:
    - !!perl/hash:RE_sequence
      alt: postop_0 0
      zyg:
      - !!perl/hash:RE_method
        name: postfix
        rest: ''
      - !!perl/hash:RE_block {}
    - !!perl/hash:RE_sequence
      alt: postop_0 1
      zyg:
      - !!perl/hash:RE_method
        name: postcircumfix
        rest: ''
      - !!perl/hash:RE_block {}
postop_0: *59
prefix__S_220PlusPlus: !!perl/hash:RE_ast
  dba: prefix
  dic: STD::P6
  re: !!perl/hash:RE_sequence
    zyg:
    - !!perl/hash:RE_method
      i: 0
      name: sym
      rest: ''
      sym: ++
    - !!perl/hash:RE_method
      name: O
      rest: 1
prefix__S_221MinusMinus: !!perl/hash:RE_ast
  dba: prefix
  dic: STD::P6
  re: !!perl/hash:RE_sequence
    zyg:
    - !!perl/hash:RE_method
      i: 0
      name: sym
      rest: ''
      sym: --
    - !!perl/hash:RE_method
      name: O
      rest: 1
prefix__S_223Bang: !!perl/hash:RE_ast
  dba: prefix
  dic: STD::P6
  re: !!perl/hash:RE_sequence
    zyg:
    - !!perl/hash:RE_method
      i: 0
      name: sym
      rest: ''
      sym: '!'
    - !!perl/hash:RE_method
      name: O
      rest: 1
prefix__S_224Plus: !!perl/hash:RE_ast
  dba: prefix
  dic: STD::P6
  re: !!perl/hash:RE_sequence
    zyg:
    - !!perl/hash:RE_method
      i: 0
      name: sym
      rest: ''
      sym: +
    - !!perl/hash:RE_method
      name: O
      rest: 1
prefix__S_225Minus: !!perl/hash:RE_ast
  dba: prefix
  dic: STD::P6
  re: !!perl/hash:RE_sequence
    zyg:
    - !!perl/hash:RE_method
      i: 0
      name: sym
      rest: ''
      sym: '-'
    - !!perl/hash:RE_method
      name: O
      rest: 1
prefix__S_226TildeTilde: !!perl/hash:RE_ast
  dba: prefix
  dic: STD::P6
  re: !!perl/hash:RE_sequence
    zyg:
    - !!perl/hash:RE_method
      i: 0
      name: sym
      rest: ''
      sym: ~~
    - !!perl/hash:RE_method
      name: dupprefix
      rest: 1
    - !!perl/hash:RE_method
      name: O
      rest: 1
prefix__S_227Tilde: !!perl/hash:RE_ast
  dba: prefix
  dic: STD::P6
  re: !!perl/hash:RE_sequence
    zyg:
    - !!perl/hash:RE_method
      i: 0
      name: sym
      rest: ''
      sym: '~'
    - !!perl/hash:RE_method
      name: O
      rest: 1
prefix__S_228QuestionQuestion: !!perl/hash:RE_ast
  dba: prefix
  dic: STD::P6
  re: !!perl/hash:RE_sequence
    zyg:
    - !!perl/hash:RE_method
      i: 0
      name: sym
      rest: ''
      sym: ??
    - !!perl/hash:RE_method
      name: dupprefix
      rest: 1
    - !!perl/hash:RE_method
      name: O
      rest: 1
prefix__S_229Question: !!perl/hash:RE_ast
  dba: prefix
  dic: STD::P6
  re: !!perl/hash:RE_sequence
    zyg:
    - !!perl/hash:RE_method
      i: 0
      name: sym
      rest: ''
      sym: '?'
    - !!perl/hash:RE_method
      name: O
      rest: 1
prefix__S_230TildeCaret: !!perl/hash:RE_ast
  dba: prefix
  dic: STD::P6
  re: !!perl/hash:RE_sequence
    zyg:
    - !!perl/hash:RE_method
      i: 0
      name: sym
      rest: ''
      sym: ~^
    - !!perl/hash:RE_method
      name: O
      rest: 1
prefix__S_231PlusCaret: !!perl/hash:RE_ast
  dba: prefix
  dic: STD::P6
  re: !!perl/hash:RE_sequence
    zyg:
    - !!perl/hash:RE_method
      i: 0
      name: sym
      rest: ''
      sym: +^
    - !!perl/hash:RE_method
      name: O
      rest: 1
prefix__S_232QuestionCaret: !!perl/hash:RE_ast
  dba: prefix
  dic: STD::P6
  re: !!perl/hash:RE_sequence
    zyg:
    - !!perl/hash:RE_method
      i: 0
      name: sym
      rest: ''
      sym: ?^
    - !!perl/hash:RE_method
      name: O
      rest: 1
prefix__S_233CaretCaret: !!perl/hash:RE_ast
  dba: prefix
  dic: STD::P6
  re: !!perl/hash:RE_sequence
    zyg:
    - !!perl/hash:RE_method
      i: 0
      name: sym
      rest: ''
      sym: ^^
    - !!perl/hash:RE_method
      name: dupprefix
      rest: 1
    - !!perl/hash:RE_method
      name: O
      rest: 1
prefix__S_234Caret: !!perl/hash:RE_ast
  dba: prefix
  dic: STD::P6
  re: !!perl/hash:RE_sequence
    zyg:
    - !!perl/hash:RE_method
      i: 0
      name: sym
      rest: ''
      sym: ^
    - !!perl/hash:RE_method
      name: O
      rest: 1
prefix__S_235VertVert: !!perl/hash:RE_ast
  dba: prefix
  dic: STD::P6
  re: !!perl/hash:RE_sequence
    zyg:
    - !!perl/hash:RE_method
      i: 0
      name: sym
      rest: ''
      sym: '||'
    - !!perl/hash:RE_method
      name: O
      rest: 1
prefix__S_236Vert: !!perl/hash:RE_ast
  dba: prefix
  dic: STD::P6
  re: !!perl/hash:RE_sequence
    zyg:
    - !!perl/hash:RE_method
      i: 0
      name: sym
      rest: ''
      sym: '|'
    - !!perl/hash:RE_method
      name: O
      rest: 1
prefix__S_266sleep: !!perl/hash:RE_ast
  dba: prefix
  dic: STD::P6
  re: !!perl/hash:RE_sequence
    zyg:
    - !!perl/hash:RE_method
      i: 0
      name: sym
      rest: ''
      sym: sleep
    - !!perl/hash:RE_meta
      text: »
    - !!perl/hash:RE_assertion
      assert: '?'
      re: !!perl/hash:RE_method_re
        name: before
        nobind: 1
        re: !!perl/hash:RE_quantified_atom
          atom: !!perl/hash:RE_meta
            min: 1
            text: \s
          quant:
          - '*'
    - !!perl/hash:RE_method
      name: O
      rest: 1
prefix__S_267abs: !!perl/hash:RE_ast
  dba: prefix
  dic: STD::P6
  re: !!perl/hash:RE_sequence
    zyg:
    - !!perl/hash:RE_method
      i: 0
      name: sym
      rest: ''
      sym: abs
    - !!perl/hash:RE_meta
      text: »
    - !!perl/hash:RE_assertion
      assert: '?'
      re: !!perl/hash:RE_method_re
        name: before
        nobind: 1
        re: !!perl/hash:RE_quantified_atom
          atom: !!perl/hash:RE_meta
            min: 1
            text: \s
          quant:
          - '*'
    - !!perl/hash:RE_method
      name: O
      rest: 1
prefix__S_268let: !!perl/hash:RE_ast
  dba: prefix
  dic: STD::P6
  re: !!perl/hash:RE_sequence
    zyg:
    - !!perl/hash:RE_method
      i: 0
      name: sym
      rest: ''
      sym: let
    - !!perl/hash:RE_meta
      text: »
    - !!perl/hash:RE_assertion
      assert: '?'
      re: !!perl/hash:RE_method_re
        name: before
        nobind: 1
        re: !!perl/hash:RE_quantified_atom
          atom: !!perl/hash:RE_meta
            min: 1
            text: \s
          quant:
          - '*'
    - !!perl/hash:RE_method
      name: O
      rest: 1
prefix__S_269temp: !!perl/hash:RE_ast
  dba: prefix
  dic: STD::P6
  re: !!perl/hash:RE_sequence
    zyg:
    - !!perl/hash:RE_method
      i: 0
      name: sym
      rest: ''
      sym: temp
    - !!perl/hash:RE_meta
      text: »
    - !!perl/hash:RE_assertion
      assert: '?'
      re: !!perl/hash:RE_method_re
        name: before
        nobind: 1
        re: !!perl/hash:RE_quantified_atom
          atom: !!perl/hash:RE_meta
            min: 1
            text: \s
          quant:
          - '*'
    - !!perl/hash:RE_method
      name: O
      rest: 1
prefix__S_321so: !!perl/hash:RE_ast
  dba: prefix
  dic: STD::P6
  re: !!perl/hash:RE_sequence
    zyg:
    - !!perl/hash:RE_method
      i: 0
      name: sym
      rest: ''
      sym: so
    - !!perl/hash:RE_meta
      text: »
    - !!perl/hash:RE_method
      name: O
      rest: 1
prefix__S_322not: !!perl/hash:RE_ast
  dba: prefix
  dic: STD::P6
  re: !!perl/hash:RE_sequence
    zyg:
    - !!perl/hash:RE_method
      i: 0
      name: sym
      rest: ''
      sym: not
    - !!perl/hash:RE_meta
      text: »
    - !!perl/hash:RE_method
      name: O
      rest: 1
prefix_circumfix_meta_operator__S_196reduce: !!perl/hash:RE_ast
  dba: prefix_circumfix_meta_operator
  dic: STD::P6
  re: !!perl/hash:RE_sequence
    zyg:
    - !!perl/hash:RE_assertion
      assert: '?'
      re: !!perl/hash:RE_method_re
        name: before
        nobind: 1
        re: !!perl/hash:RE_sequence
          zyg:
          - !!perl/hash:RE_string
            i: 0
            text: '['
          - !!perl/hash:RE_quantified_atom
            atom: !!perl/hash:RE_meta
              min: 1
              text: \S
            quant:
            - +
          - !!perl/hash:RE_string
            i: 0
            text: ']'
    - !!perl/hash:RE_bindnamed
      atom: !!perl/hash:RE_paren
        re: !!perl/hash:RE_sequence
          zyg:
          - !!perl/hash:RE_string
            i: 0
            text: '['
          - !!perl/hash:RE_bracket
            re: !!perl/hash:RE_first
              zyg:
              - !!perl/hash:RE_sequence
                zyg:
                - !!perl/hash:RE_bindnamed
                  atom: !!perl/hash:RE_method
                    name: infixish
                    rest: 1
                - !!perl/hash:RE_assertion
                  assert: '?'
                  re: !!perl/hash:RE_method_re
                    name: before
                    nobind: 1
                    re: !!perl/hash:RE_string
                      i: 0
                      text: ']'
              - !!perl/hash:RE_sequence
                zyg:
                - !!perl/hash:RE_meta
                  min: 1
                  text: \\
                - !!perl/hash:RE_bindnamed
                  atom: !!perl/hash:RE_method
                    name: infixish
                    rest: 1
                - !!perl/hash:RE_assertion
                  assert: '?'
                  re: !!perl/hash:RE_method_re
                    name: before
                    nobind: 1
                    re: !!perl/hash:RE_string
                      i: 0
                      text: ']'
              - !!perl/hash:RE_assertion
                assert: '!'
                re: !!perl/hash:RE_noop
                  nobind: 1
          - !!perl/hash:RE_string
            i: 0
            text: ']'
          - !!perl/hash:RE_bracket
            re: &60 !!perl/hash:RE_any
              altname: prefix_circumfix_meta_operator__S_196reduce_0
              dba: prefix_circumfix_meta_operator
              dic: STD::P6
              zyg:
              - !!perl/hash:RE_string
                alt: prefix_circumfix_meta_operator__S_196reduce_0 0
                i: 0
                text: «
              - !!perl/hash:RE_assertion
                alt: prefix_circumfix_meta_operator__S_196reduce_0 1
                assert: '?'
                re: !!perl/hash:RE_noop
                  nobind: 1
    - !!perl/hash:RE_block {}
    - !!perl/hash:RE_method
      name: can_meta
      rest: 1
    - !!perl/hash:RE_bracket
      re: !!perl/hash:RE_first
        zyg:
        - !!perl/hash:RE_assertion
          assert: '!'
          re: !!perl/hash:RE_block
            nobind: 1
        - !!perl/hash:RE_assertion
          assert: '?'
          re: !!perl/hash:RE_block
            nobind: 1
        - !!perl/hash:RE_method
          name: sorry
          rest: 1
    - !!perl/hash:RE_method
      name: O
      rest: 1
    - !!perl/hash:RE_block {}
    - !!perl/hash:RE_bracket
      re: !!perl/hash:RE_first
        zyg:
        - !!perl/hash:RE_assertion
          assert: '?'
          re: !!perl/hash:RE_method_re
            name: before
            nobind: 1
            re: !!perl/hash:RE_string
              i: 0
              text: (
        - !!perl/hash:RE_assertion
          assert: '?'
          re: !!perl/hash:RE_method_re
            name: before
            nobind: 1
            re: !!perl/hash:RE_sequence
              zyg:
              - !!perl/hash:RE_quantified_atom
                atom: !!perl/hash:RE_meta
                  min: 1
                  text: \s
                quant:
                - +
              - !!perl/hash:RE_quantified_atom
                atom: !!perl/hash:RE_bracket
                  re: !!perl/hash:RE_sequence
                    zyg:
                    - !!perl/hash:RE_assertion
                      assert: '?'
                      re: !!perl/hash:RE_method
                        name: stdstopper
                        rest: ''
                    - !!perl/hash:RE_block {}
                quant:
                - '?'
        - !!perl/hash:RE_block {}
prefix_circumfix_meta_operator__S_196reduce_0: *60
prefix_postfix_meta_operator__S_197Fre: !!perl/hash:RE_ast
  dba: prefix_postfix_meta_operator
  dic: STD::P6
  re: &61 !!perl/hash:RE_any
    altname: prefix_postfix_meta_operator__S_197Fre_0
    dba: prefix_postfix_meta_operator
    dic: STD::P6
    zyg:
    - !!perl/hash:RE_method
      alt: prefix_postfix_meta_operator__S_197Fre_0 0
      i: 0
      name: sym
      rest: ''
      sym: «
    - !!perl/hash:RE_string
      alt: prefix_postfix_meta_operator__S_197Fre_0 1
      i: 0
      text: <<
prefix_postfix_meta_operator__S_197Fre_0: *61
privop: !!perl/hash:RE_ast
  dba: privop
  dic: STD::P6
  re: !!perl/hash:RE_sequence
    zyg:
    - !!perl/hash:RE_string
      i: 0
      text: '!'
    - !!perl/hash:RE_method
      name: methodop
      rest: ''
    - !!perl/hash:RE_method
      name: O
      rest: 1
quasiquibble: !!perl/hash:RE_ast
  dba: quasiquibble
  dic: STD::P6
  re: !!perl/hash:RE_sequence
    zyg:
    - !!perl/hash:RE_method
      name: babble
      rest: 1
    - !!perl/hash:RE_block {}
    - !!perl/hash:RE_bracket
      re: !!perl/hash:RE_first
        zyg:
        - !!perl/hash:RE_sequence
          zyg:
          - !!perl/hash:RE_assertion
            assert: '?'
            re: !!perl/hash:RE_block
              nobind: 1
          - !!perl/hash:RE_bracket
            re: !!perl/hash:RE_sequence
              zyg:
              - !!perl/hash:RE_decl {}
              - !!perl/hash:RE_method
                name: block
                rest: ''
        - !!perl/hash:RE_bracket
          re: !!perl/hash:RE_sequence
            zyg:
            - !!perl/hash:RE_decl {}
            - !!perl/hash:RE_method
              name: starter
              rest: ''
            - !!perl/hash:RE_method
              name: statementlist
              rest: ''
            - !!perl/hash:RE_bracket
              re: !!perl/hash:RE_first
                zyg:
                - !!perl/hash:RE_method
                  name: stopper
                  rest: ''
                - !!perl/hash:RE_method
                  name: panic
                  rest: 1
quote__S_141SlashSlash: !!perl/hash:RE_ast
  dba: quote
  dic: STD::P6
  re: !!perl/hash:RE_sequence
    zyg:
    - !!perl/hash:RE_string
      i: 0
      text: /
    - !!perl/hash:RE_quantified_atom
      atom: !!perl/hash:RE_meta
        min: 1
        text: \s
      quant:
      - '*'
    - !!perl/hash:RE_string
      i: 0
      text: /
    - !!perl/hash:RE_method
      name: sorry
      rest: 1
quote__S_142Slash_Slash: !!perl/hash:RE_ast
  dba: quote
  dic: STD::P6
  re: !!perl/hash:RE_sequence
    zyg:
    - !!perl/hash:RE_string
      i: 0
      text: /
    - !!perl/hash:RE_method
      name: nibble
      rest: 1
    - !!perl/hash:RE_bracket
      re: !!perl/hash:RE_first
        zyg:
        - !!perl/hash:RE_string
          i: 0
          text: /
        - !!perl/hash:RE_method
          name: panic
          rest: 1
    - !!perl/hash:RE_quantified_atom
      atom: !!perl/hash:RE_method
        name: old_rx_mods
        rest: ''
      quant:
      - '?'
quote__S_143qq: !!perl/hash:RE_ast
  dba: quote
  dic: STD::P6
  re: !!perl/hash:RE_sequence
    zyg:
    - !!perl/hash:RE_string
      i: 0
      text: qq
    - !!perl/hash:RE_bracket
      re: &62 !!perl/hash:RE_any
        altname: quote__S_143qq_0
        dba: quote
        dic: STD::P6
        zyg:
        - !!perl/hash:RE_sequence
          alt: quote__S_143qq_0 0
          zyg:
          - !!perl/hash:RE_method
            name: quote_mod
            rest: ''
          - !!perl/hash:RE_meta
            text: »
          - !!perl/hash:RE_assertion
            assert: '!'
            re: !!perl/hash:RE_method_re
              name: before
              nobind: 1
              re: !!perl/hash:RE_string
                i: 0
                text: (
          - !!perl/hash:RE_block {}
          - !!perl/hash:RE_method
            name: ws
            rest: ''
          - !!perl/hash:RE_method
            name: quibble
            rest: 1
        - !!perl/hash:RE_sequence
          alt: quote__S_143qq_0 1
          zyg:
          - !!perl/hash:RE_meta
            text: »
          - !!perl/hash:RE_assertion
            assert: '!'
            re: !!perl/hash:RE_method_re
              name: before
              nobind: 1
              re: !!perl/hash:RE_string
                i: 0
                text: (
          - !!perl/hash:RE_method
            name: ws
            rest: ''
          - !!perl/hash:RE_method
            name: quibble
            rest: 1
quote__S_143qq_0: *62
quote__S_144q: !!perl/hash:RE_ast
  dba: quote
  dic: STD::P6
  re: !!perl/hash:RE_sequence
    zyg:
    - !!perl/hash:RE_string
      i: 0
      text: q
    - !!perl/hash:RE_bracket
      re: &63 !!perl/hash:RE_any
        altname: quote__S_144q_0
        dba: quote
        dic: STD::P6
        zyg:
        - !!perl/hash:RE_sequence
          alt: quote__S_144q_0 0
          zyg:
          - !!perl/hash:RE_method
            name: quote_mod
            rest: ''
          - !!perl/hash:RE_meta
            text: »
          - !!perl/hash:RE_assertion
            assert: '!'
            re: !!perl/hash:RE_method_re
              name: before
              nobind: 1
              re: !!perl/hash:RE_string
                i: 0
                text: (
          - !!perl/hash:RE_block {}
          - !!perl/hash:RE_method
            name: quibble
            rest: 1
        - !!perl/hash:RE_sequence
          alt: quote__S_144q_0 1
          zyg:
          - !!perl/hash:RE_meta
            text: »
          - !!perl/hash:RE_assertion
            assert: '!'
            re: !!perl/hash:RE_method_re
              name: before
              nobind: 1
              re: !!perl/hash:RE_string
                i: 0
                text: (
          - !!perl/hash:RE_method
            name: ws
            rest: ''
          - !!perl/hash:RE_method
            name: quibble
            rest: 1
quote__S_144q_0: *63
quote__S_145Q: !!perl/hash:RE_ast
  dba: quote
  dic: STD::P6
  re: !!perl/hash:RE_sequence
    zyg:
    - !!perl/hash:RE_string
      i: 0
      text: Q
    - !!perl/hash:RE_bracket
      re: &64 !!perl/hash:RE_any
        altname: quote__S_145Q_0
        dba: quote
        dic: STD::P6
        zyg:
        - !!perl/hash:RE_sequence
          alt: quote__S_145Q_0 0
          zyg:
          - !!perl/hash:RE_method
            name: quote_mod
            rest: ''
          - !!perl/hash:RE_meta
            text: »
          - !!perl/hash:RE_assertion
            assert: '!'
            re: !!perl/hash:RE_method_re
              name: before
              nobind: 1
              re: !!perl/hash:RE_string
                i: 0
                text: (
          - !!perl/hash:RE_block {}
          - !!perl/hash:RE_method
            name: quibble
            rest: 1
        - !!perl/hash:RE_sequence
          alt: quote__S_145Q_0 1
          zyg:
          - !!perl/hash:RE_meta
            text: »
          - !!perl/hash:RE_assertion
            assert: '!'
            re: !!perl/hash:RE_method_re
              name: before
              nobind: 1
              re: !!perl/hash:RE_string
                i: 0
                text: (
          - !!perl/hash:RE_method
            name: ws
            rest: ''
          - !!perl/hash:RE_method
            name: quibble
            rest: 1
quote__S_145Q_0: *64
quote__S_157rx: !!perl/hash:RE_ast
  dba: quote
  dic: STD::P6
  re: !!perl/hash:RE_sequence
    zyg:
    - !!perl/hash:RE_method
      i: 0
      name: sym
      rest: ''
      sym: rx
    - !!perl/hash:RE_meta
      text: »
    - !!perl/hash:RE_assertion
      assert: '!'
      re: !!perl/hash:RE_method_re
        name: before
        nobind: 1
        re: !!perl/hash:RE_string
          i: 0
          text: (
    - !!perl/hash:RE_method
      name: quibble
      rest: 1
    - !!perl/hash:RE_assertion
      assert: '!'
      re: !!perl/hash:RE_method
        name: old_rx_mods
        rest: ''
quote__S_158m: !!perl/hash:RE_ast
  dba: quote
  dic: STD::P6
  re: !!perl/hash:RE_sequence
    zyg:
    - !!perl/hash:RE_method
      i: 0
      name: sym
      rest: ''
      sym: m
    - !!perl/hash:RE_meta
      text: »
    - !!perl/hash:RE_assertion
      assert: '!'
      re: !!perl/hash:RE_method_re
        name: before
        nobind: 1
        re: !!perl/hash:RE_string
          i: 0
          text: (
    - !!perl/hash:RE_method
      name: quibble
      rest: 1
    - !!perl/hash:RE_assertion
      assert: '!'
      re: !!perl/hash:RE_method
        name: old_rx_mods
        rest: ''
quote__S_159mm: !!perl/hash:RE_ast
  dba: quote
  dic: STD::P6
  re: !!perl/hash:RE_sequence
    zyg:
    - !!perl/hash:RE_method
      i: 0
      name: sym
      rest: ''
      sym: mm
    - !!perl/hash:RE_meta
      text: »
    - !!perl/hash:RE_assertion
      assert: '!'
      re: !!perl/hash:RE_method_re
        name: before
        nobind: 1
        re: !!perl/hash:RE_string
          i: 0
          text: (
    - !!perl/hash:RE_method
      name: quibble
      rest: 1
    - !!perl/hash:RE_assertion
      assert: '!'
      re: !!perl/hash:RE_method
        name: old_rx_mods
        rest: ''
quote__S_160s: !!perl/hash:RE_ast
  dba: quote
  dic: STD::P6
  re: !!perl/hash:RE_sequence
    zyg:
    - !!perl/hash:RE_method
      i: 0
      name: sym
      rest: ''
      sym: s
    - !!perl/hash:RE_meta
      text: »
    - !!perl/hash:RE_assertion
      assert: '!'
      re: !!perl/hash:RE_method_re
        name: before
        nobind: 1
        re: !!perl/hash:RE_string
          i: 0
          text: (
    - !!perl/hash:RE_bindnamed
      atom: !!perl/hash:RE_method
        name: sibble
        rest: 1
    - !!perl/hash:RE_assertion
      assert: '!'
      re: !!perl/hash:RE_method
        name: old_rx_mods
        rest: ''
quote__S_161ss: !!perl/hash:RE_ast
  dba: quote
  dic: STD::P6
  re: !!perl/hash:RE_sequence
    zyg:
    - !!perl/hash:RE_method
      i: 0
      name: sym
      rest: ''
      sym: ss
    - !!perl/hash:RE_meta
      text: »
    - !!perl/hash:RE_assertion
      assert: '!'
      re: !!perl/hash:RE_method_re
        name: before
        nobind: 1
        re: !!perl/hash:RE_string
          i: 0
          text: (
    - !!perl/hash:RE_bindnamed
      atom: !!perl/hash:RE_method
        name: sibble
        rest: 1
    - !!perl/hash:RE_assertion
      assert: '!'
      re: !!perl/hash:RE_method
        name: old_rx_mods
        rest: ''
quote__S_162tr: !!perl/hash:RE_ast
  dba: quote
  dic: STD::P6
  re: !!perl/hash:RE_sequence
    zyg:
    - !!perl/hash:RE_method
      i: 0
      name: sym
      rest: ''
      sym: tr
    - !!perl/hash:RE_meta
      text: »
    - !!perl/hash:RE_assertion
      assert: '!'
      re: !!perl/hash:RE_method_re
        name: before
        nobind: 1
        re: !!perl/hash:RE_string
          i: 0
          text: (
    - !!perl/hash:RE_bindnamed
      atom: !!perl/hash:RE_method
        name: tribble
        rest: 1
    - !!perl/hash:RE_assertion
      assert: '!'
      re: !!perl/hash:RE_method
        name: old_tr_mods
        rest: ''
quote__S_163y: !!perl/hash:RE_ast
  dba: quote
  dic: STD::P6
  re: !!perl/hash:RE_sequence
    zyg:
    - !!perl/hash:RE_method
      i: 0
      name: sym
      rest: ''
      sym: y
    - !!perl/hash:RE_meta
      text: »
    - !!perl/hash:RE_assertion
      assert: '!'
      re: !!perl/hash:RE_block
        nobind: 1
    - !!perl/hash:RE_assertion
      assert: '!'
      re: !!perl/hash:RE_method_re
        name: before
        nobind: 1
        re: !!perl/hash:RE_string
          i: 0
          text: (
    - !!perl/hash:RE_assertion
      assert: '?'
      re: !!perl/hash:RE_method_re
        name: before
        nobind: 1
        re: !!perl/hash:RE_sequence
          zyg:
          - !!perl/hash:RE_quantified_atom
            atom: !!perl/hash:RE_meta
              min: 1
              text: \h
            quant:
            - '*'
          - !!perl/hash:RE_meta
            min: 1
            text: \W
    - !!perl/hash:RE_method
      name: obs
      rest: 1
quote__S_164quasi: !!perl/hash:RE_ast
  dba: quote
  dic: STD::P6
  re: !!perl/hash:RE_sequence
    zyg:
    - !!perl/hash:RE_method
      i: 0
      name: sym
      rest: ''
      sym: quasi
    - !!perl/hash:RE_meta
      text: »
    - !!perl/hash:RE_assertion
      assert: '!'
      re: !!perl/hash:RE_method_re
        name: before
        nobind: 1
        re: !!perl/hash:RE_string
          i: 0
          text: (
    - !!perl/hash:RE_method
      name: quasiquibble
      rest: 1
quote_mod__S_146w: !!perl/hash:RE_ast
  dba: quote_mod
  dic: STD::P6
  re: !!perl/hash:RE_method
    i: 0
    name: sym
    rest: ''
    sym: w
quote_mod__S_147ww: !!perl/hash:RE_ast
  dba: quote_mod
  dic: STD::P6
  re: !!perl/hash:RE_method
    i: 0
    name: sym
    rest: ''
    sym: ww
quote_mod__S_148p: !!perl/hash:RE_ast
  dba: quote_mod
  dic: STD::P6
  re: !!perl/hash:RE_method
    i: 0
    name: sym
    rest: ''
    sym: p
quote_mod__S_149x: !!perl/hash:RE_ast
  dba: quote_mod
  dic: STD::P6
  re: !!perl/hash:RE_method
    i: 0
    name: sym
    rest: ''
    sym: x
quote_mod__S_150to: !!perl/hash:RE_ast
  dba: quote_mod
  dic: STD::P6
  re: !!perl/hash:RE_method
    i: 0
    name: sym
    rest: ''
    sym: to
quote_mod__S_151s: !!perl/hash:RE_ast
  dba: quote_mod
  dic: STD::P6
  re: !!perl/hash:RE_method
    i: 0
    name: sym
    rest: ''
    sym: s
quote_mod__S_152a: !!perl/hash:RE_ast
  dba: quote_mod
  dic: STD::P6
  re: !!perl/hash:RE_method
    i: 0
    name: sym
    rest: ''
    sym: a
quote_mod__S_153h: !!perl/hash:RE_ast
  dba: quote_mod
  dic: STD::P6
  re: !!perl/hash:RE_method
    i: 0
    name: sym
    rest: ''
    sym: h
quote_mod__S_154f: !!perl/hash:RE_ast
  dba: quote_mod
  dic: STD::P6
  re: !!perl/hash:RE_method
    i: 0
    name: sym
    rest: ''
    sym: f
quote_mod__S_155c: !!perl/hash:RE_ast
  dba: quote_mod
  dic: STD::P6
  re: !!perl/hash:RE_method
    i: 0
    name: sym
    rest: ''
    sym: c
quote_mod__S_156b: !!perl/hash:RE_ast
  dba: quote_mod
  dic: STD::P6
  re: !!perl/hash:RE_method
    i: 0
    name: sym
    rest: ''
    sym: b
regex_block: !!perl/hash:RE_ast
  dba: regex_block
  dic: STD::P6
  re: !!perl/hash:RE_sequence
    zyg:
    - !!perl/hash:RE_quantified_atom
      atom: !!perl/hash:RE_bracket
        re: !!perl/hash:RE_sequence
          zyg:
          - !!perl/hash:RE_method
            name: quotepair
            rest: ''
          - !!perl/hash:RE_method
            name: ws
            rest: ''
          - !!perl/hash:RE_block {}
      quant:
      - '*'
    - !!perl/hash:RE_bracket
      re: &65 !!perl/hash:RE_any
        altname: regex_block_0
        dba: regex_block
        dic: STD::P6
        zyg:
        - !!perl/hash:RE_sequence
          alt: regex_block_0 0
          zyg:
          - !!perl/hash:RE_string
            i: 0
            text: '{*}'
          - !!perl/hash:RE_assertion
            assert: '?'
            re: !!perl/hash:RE_block
              nobind: 1
          - !!perl/hash:RE_block {}
        - !!perl/hash:RE_bracket
          alt: regex_block_0 1
          re: !!perl/hash:RE_sequence
            zyg:
            - !!perl/hash:RE_string
              i: 0
              text: '{'
            - !!perl/hash:RE_method
              name: nibble
              rest: 1
            - !!perl/hash:RE_bracket
              re: !!perl/hash:RE_first
                zyg:
                - !!perl/hash:RE_string
                  i: 0
                  text: '}'
                - !!perl/hash:RE_method
                  name: panic
                  rest: 1
    - !!perl/hash:RE_method
      name: curlycheck
      rest: ''
regex_block_0: *65
regex_declarator__S_066regex: !!perl/hash:RE_ast
  dba: regex_declarator
  dic: STD::P6
  re: !!perl/hash:RE_sequence
    zyg:
    - !!perl/hash:RE_method
      endsym: spacey
      i: 0
      name: sym
      rest: ''
      sym: regex
    - !!perl/hash:RE_method
      name: spacey
      rest: ''
    - !!perl/hash:RE_method
      name: regex_def
      rest: 1
regex_declarator__S_067token: !!perl/hash:RE_ast
  dba: regex_declarator
  dic: STD::P6
  re: !!perl/hash:RE_sequence
    zyg:
    - !!perl/hash:RE_method
      endsym: spacey
      i: 0
      name: sym
      rest: ''
      sym: token
    - !!perl/hash:RE_method
      name: spacey
      rest: ''
    - !!perl/hash:RE_method
      name: regex_def
      rest: 1
regex_declarator__S_068rule: !!perl/hash:RE_ast
  dba: regex_declarator
  dic: STD::P6
  re: !!perl/hash:RE_sequence
    zyg:
    - !!perl/hash:RE_method
      endsym: spacey
      i: 0
      name: sym
      rest: ''
      sym: rule
    - !!perl/hash:RE_method
      name: spacey
      rest: ''
    - !!perl/hash:RE_method
      name: regex_def
      rest: 1
regex_def: !!perl/hash:RE_ast
  dba: regex_def
  dic: STD::P6
  re: !!perl/hash:RE_first
    zyg:
    - !!perl/hash:RE_sequence
      zyg:
      - !!perl/hash:RE_method
        name: ws
        rest: ''
      - !!perl/hash:RE_block {}
      - !!perl/hash:RE_bracket
        re: !!perl/hash:RE_sequence
          zyg:
          - !!perl/hash:RE_quantified_atom
            atom: !!perl/hash:RE_bracket
              re: &66 !!perl/hash:RE_any
                altname: regex_def_0
                dba: regex_def
                dic: STD::P6
                zyg:
                - !!perl/hash:RE_sequence
                  alt: regex_def_0 0
                  zyg:
                  - !!perl/hash:RE_method
                    name: ws
                    rest: ''
                  - !!perl/hash:RE_string
                    i: 0
                    text: '&'
                  - !!perl/hash:RE_quantified_atom
                    atom: !!perl/hash:RE_method
                      name: deflongname
                      rest: ''
                    quant:
                    - '?'
                  - !!perl/hash:RE_method
                    name: ws
                    rest: ''
                - !!perl/hash:RE_sequence
                  alt: regex_def_0 1
                  zyg:
                  - !!perl/hash:RE_method
                    name: ws
                    rest: ''
                  - !!perl/hash:RE_method
                    name: deflongname
                    rest: ''
                  - !!perl/hash:RE_method
                    name: ws
                    rest: ''
            quant:
            - '?'
          - !!perl/hash:RE_method
            name: ws
            rest: ''
          - !!perl/hash:RE_method
            name: newlex
            rest: 1
          - !!perl/hash:RE_method
            name: ws
            rest: ''
          - !!perl/hash:RE_quantified_atom
            atom: !!perl/hash:RE_bracket
              re: &67 !!perl/hash:RE_any
                altname: regex_def_1
                dba: regex_def
                dic: STD::P6
                zyg:
                - !!perl/hash:RE_sequence
                  alt: regex_def_1 0
                  zyg:
                  - !!perl/hash:RE_method
                    name: ws
                    rest: ''
                  - !!perl/hash:RE_bracket
                    re: !!perl/hash:RE_sequence
                      zyg:
                      - !!perl/hash:RE_quantified_atom
                        atom: !!perl/hash:RE_string
                          i: 0
                          text: ':'
                        quant:
                        - '?'
                      - !!perl/hash:RE_string
                        i: 0
                        text: (
                      - !!perl/hash:RE_method
                        name: ws
                        rest: ''
                      - !!perl/hash:RE_method
                        name: signature
                        rest: 1
                      - !!perl/hash:RE_method
                        name: ws
                        rest: ''
                      - !!perl/hash:RE_string
                        i: 0
                        text: )
                  - !!perl/hash:RE_method
                    name: ws
                    rest: ''
                - !!perl/hash:RE_sequence
                  alt: regex_def_1 1
                  zyg:
                  - !!perl/hash:RE_method
                    name: ws
                    rest: ''
                  - !!perl/hash:RE_method
                    name: trait
                    rest: ''
                  - !!perl/hash:RE_method
                    name: ws
                    rest: ''
            quant:
            - '*'
          - !!perl/hash:RE_method
            name: ws
            rest: ''
          - !!perl/hash:RE_quantified_atom
            atom: !!perl/hash:RE_bracket
              re: !!perl/hash:RE_sequence
                zyg:
                - !!perl/hash:RE_method
                  name: ws
                  rest: ''
                - !!perl/hash:RE_assertion
                  assert: '!'
                  re: !!perl/hash:RE_method_re
                    name: before
                    nobind: 1
                    re: !!perl/hash:RE_sequence
                      zyg:
                      - !!perl/hash:RE_method
                        name: ws
                        rest: ''
                      - !!perl/hash:RE_string
                        i: 0
                        text: '{'
                - !!perl/hash:RE_method
                  name: panic
                  rest: 1
                - !!perl/hash:RE_method
                  name: ws
                  rest: ''
            quant:
            - '?'
          - !!perl/hash:RE_method
            name: ws
            rest: ''
          - !!perl/hash:RE_block {}
          - !!perl/hash:RE_method
            name: finishlex
            rest: ''
          - !!perl/hash:RE_method
            name: ws
            rest: ''
          - !!perl/hash:RE_method
            name: regex_block
            rest: ''
          - !!perl/hash:RE_method
            name: getsig
            rest: ''
          - !!perl/hash:RE_method
            name: getdecl
            rest: ''
      - !!perl/hash:RE_method
        name: ws
        rest: ''
    - !!perl/hash:RE_sequence
      zyg:
      - !!perl/hash:RE_method
        name: ws
        rest: ''
      - !!perl/hash:RE_method
        name: panic
        rest: 1
      - !!perl/hash:RE_method
        name: ws
        rest: ''
regex_def_0: *66
regex_def_1: *67
routine_declarator__S_062sub: !!perl/hash:RE_ast
  dba: routine_declarator
  dic: STD::P6
  re: !!perl/hash:RE_sequence
    zyg:
    - !!perl/hash:RE_method
      endsym: nofun
      i: 0
      name: sym
      rest: ''
      sym: sub
    - !!perl/hash:RE_method
      name: nofun
      rest: ''
    - !!perl/hash:RE_method
      name: routine_def
      rest: 1
routine_declarator__S_063method: !!perl/hash:RE_ast
  dba: routine_declarator
  dic: STD::P6
  re: !!perl/hash:RE_sequence
    zyg:
    - !!perl/hash:RE_method
      endsym: nofun
      i: 0
      name: sym
      rest: ''
      sym: method
    - !!perl/hash:RE_method
      name: nofun
      rest: ''
    - !!perl/hash:RE_method
      name: method_def
      rest: ''
routine_declarator__S_064submethod: !!perl/hash:RE_ast
  dba: routine_declarator
  dic: STD::P6
  re: !!perl/hash:RE_sequence
    zyg:
    - !!perl/hash:RE_method
      endsym: nofun
      i: 0
      name: sym
      rest: ''
      sym: submethod
    - !!perl/hash:RE_method
      name: nofun
      rest: ''
    - !!perl/hash:RE_method
      name: method_def
      rest: ''
routine_declarator__S_065macro: !!perl/hash:RE_ast
  dba: routine_declarator
  dic: STD::P6
  re: !!perl/hash:RE_sequence
    zyg:
    - !!perl/hash:RE_method
      endsym: nofun
      i: 0
      name: sym
      rest: ''
      sym: macro
    - !!perl/hash:RE_method
      name: nofun
      rest: ''
    - !!perl/hash:RE_method
      name: macro_def
      rest: ''
routine_def: !!perl/hash:RE_ast
  dba: routine_def
  dic: STD::P6
  re: !!perl/hash:RE_first
    zyg:
    - !!perl/hash:RE_sequence
      zyg:
      - !!perl/hash:RE_method
        name: ws
        rest: ''
      - !!perl/hash:RE_bracket
        re: !!perl/hash:RE_sequence
          zyg:
          - !!perl/hash:RE_quantified_atom
            atom: !!perl/hash:RE_bracket
              re: &68 !!perl/hash:RE_any
                altname: routine_def_0
                dba: routine_def
                dic: STD::P6
                zyg:
                - !!perl/hash:RE_sequence
                  alt: routine_def_0 0
                  zyg:
                  - !!perl/hash:RE_method
                    name: ws
                    rest: ''
                  - !!perl/hash:RE_bindnamed
                    atom: !!perl/hash:RE_bracket
                      re: !!perl/hash:RE_sequence
                        zyg:
                        - !!perl/hash:RE_string
                          i: 0
                          text: '&'
                        - !!perl/hash:RE_quantified_atom
                          atom: !!perl/hash:RE_string
                            i: 0
                            text: '*'
                          quant:
                          - '?'
                  - !!perl/hash:RE_method
                    name: ws
                    rest: ''
                  - !!perl/hash:RE_quantified_atom
                    atom: !!perl/hash:RE_method
                      name: deflongname
                      rest: ''
                    quant:
                    - '?'
                  - !!perl/hash:RE_method
                    name: ws
                    rest: ''
                - !!perl/hash:RE_sequence
                  alt: routine_def_0 1
                  zyg:
                  - !!perl/hash:RE_method
                    name: ws
                    rest: ''
                  - !!perl/hash:RE_method
                    name: deflongname
                    rest: ''
                  - !!perl/hash:RE_method
                    name: ws
                    rest: ''
            quant:
            - '?'
          - !!perl/hash:RE_method
            name: ws
            rest: ''
          - !!perl/hash:RE_method
            name: newlex
            rest: 1
          - !!perl/hash:RE_method
            name: ws
            rest: ''
          - !!perl/hash:RE_quantified_atom
            atom: !!perl/hash:RE_bracket
              re: &69 !!perl/hash:RE_any
                altname: routine_def_1
                dba: routine_def
                dic: STD::P6
                zyg:
                - !!perl/hash:RE_sequence
                  alt: routine_def_1 0
                  zyg:
                  - !!perl/hash:RE_method
                    name: ws
                    rest: ''
                  - !!perl/hash:RE_method
                    name: multisig
                    rest: ''
                  - !!perl/hash:RE_method
                    name: ws
                    rest: ''
                - !!perl/hash:RE_sequence
                  alt: routine_def_1 1
                  zyg:
                  - !!perl/hash:RE_method
                    name: ws
                    rest: ''
                  - !!perl/hash:RE_method
                    name: trait
                    rest: ''
                  - !!perl/hash:RE_method
                    name: ws
                    rest: ''
            quant:
            - '*'
          - !!perl/hash:RE_method
            name: ws
            rest: ''
          - !!perl/hash:RE_quantified_atom
            atom: !!perl/hash:RE_bracket
              re: !!perl/hash:RE_sequence
                zyg:
                - !!perl/hash:RE_method
                  name: ws
                  rest: ''
                - !!perl/hash:RE_assertion
                  assert: '!'
                  re: !!perl/hash:RE_method_re
                    name: before
                    nobind: 1
                    re: !!perl/hash:RE_sequence
                      zyg:
                      - !!perl/hash:RE_method
                        name: ws
                        rest: ''
                      - !!perl/hash:RE_string
                        i: 0
                        text: '{'
                - !!perl/hash:RE_method
                  name: panic
                  rest: 1
                - !!perl/hash:RE_method
                  name: ws
                  rest: ''
            quant:
            - '?'
          - !!perl/hash:RE_method
            name: ws
            rest: ''
          - !!perl/hash:RE_assertion
            assert: '!'
            re: !!perl/hash:RE_block
              nobind: 1
          - !!perl/hash:RE_method
            name: blockoid
            rest: ''
          - !!perl/hash:RE_method
            name: checkyada
            rest: ''
          - !!perl/hash:RE_method
            name: getsig
            rest: ''
          - !!perl/hash:RE_method
            name: getdecl
            rest: ''
      - !!perl/hash:RE_method
        name: ws
        rest: ''
    - !!perl/hash:RE_sequence
      zyg:
      - !!perl/hash:RE_method
        name: ws
        rest: ''
      - !!perl/hash:RE_method
        name: panic
        rest: 1
      - !!perl/hash:RE_method
        name: ws
        rest: ''
routine_def_0: *68
routine_def_1: *69
scope_declarator__S_041my: !!perl/hash:RE_ast
  dba: scope_declarator
  dic: STD::P6
  re: !!perl/hash:RE_sequence
    zyg:
    - !!perl/hash:RE_method
      endsym: nofun
      i: 0
      name: sym
      rest: ''
      sym: my
    - !!perl/hash:RE_method
      name: nofun
      rest: ''
    - !!perl/hash:RE_method
      name: scoped
      rest: 1
scope_declarator__S_042our: !!perl/hash:RE_ast
  dba: scope_declarator
  dic: STD::P6
  re: !!perl/hash:RE_sequence
    zyg:
    - !!perl/hash:RE_method
      endsym: nofun
      i: 0
      name: sym
      rest: ''
      sym: our
    - !!perl/hash:RE_method
      name: nofun
      rest: ''
    - !!perl/hash:RE_method
      name: scoped
      rest: 1
scope_declarator__S_043anon: !!perl/hash:RE_ast
  dba: scope_declarator
  dic: STD::P6
  re: !!perl/hash:RE_sequence
    zyg:
    - !!perl/hash:RE_method
      endsym: nofun
      i: 0
      name: sym
      rest: ''
      sym: anon
    - !!perl/hash:RE_method
      name: nofun
      rest: ''
    - !!perl/hash:RE_method
      name: scoped
      rest: 1
scope_declarator__S_044state: !!perl/hash:RE_ast
  dba: scope_declarator
  dic: STD::P6
  re: !!perl/hash:RE_sequence
    zyg:
    - !!perl/hash:RE_method
      endsym: nofun
      i: 0
      name: sym
      rest: ''
      sym: state
    - !!perl/hash:RE_method
      name: nofun
      rest: ''
    - !!perl/hash:RE_method
      name: scoped
      rest: 1
scope_declarator__S_045has: !!perl/hash:RE_ast
  dba: scope_declarator
  dic: STD::P6
  re: !!perl/hash:RE_sequence
    zyg:
    - !!perl/hash:RE_method
      endsym: nofun
      i: 0
      name: sym
      rest: ''
      sym: has
    - !!perl/hash:RE_method
      name: nofun
      rest: ''
    - !!perl/hash:RE_method
      name: scoped
      rest: 1
scope_declarator__S_046augment: !!perl/hash:RE_ast
  dba: scope_declarator
  dic: STD::P6
  re: !!perl/hash:RE_sequence
    zyg:
    - !!perl/hash:RE_method
      endsym: nofun
      i: 0
      name: sym
      rest: ''
      sym: augment
    - !!perl/hash:RE_method
      name: nofun
      rest: ''
    - !!perl/hash:RE_method
      name: scoped
      rest: 1
scope_declarator__S_047supersede: !!perl/hash:RE_ast
  dba: scope_declarator
  dic: STD::P6
  re: !!perl/hash:RE_sequence
    zyg:
    - !!perl/hash:RE_method
      endsym: nofun
      i: 0
      name: sym
      rest: ''
      sym: supersede
    - !!perl/hash:RE_method
      name: nofun
      rest: ''
    - !!perl/hash:RE_method
      name: scoped
      rest: 1
scoped: !!perl/hash:RE_ast
  dba: scoped declarator
  dic: STD::P6
  re: !!perl/hash:RE_first
    zyg:
    - !!perl/hash:RE_sequence
      zyg:
      - !!perl/hash:RE_method
        name: ws
        rest: ''
      - !!perl/hash:RE_bracket
        re: &70 !!perl/hash:RE_any
          altname: scoped_0
          dba: scoped declarator
          dic: STD::P6
          zyg:
          - !!perl/hash:RE_sequence
            alt: scoped_0 0
            zyg:
            - !!perl/hash:RE_method
              name: declarator
              rest: ''
            - !!perl/hash:RE_method
              name: ws
              rest: ''
          - !!perl/hash:RE_sequence
            alt: scoped_0 1
            zyg:
            - !!perl/hash:RE_method
              name: regex_declarator
              rest: ''
            - !!perl/hash:RE_method
              name: ws
              rest: ''
          - !!perl/hash:RE_sequence
            alt: scoped_0 2
            zyg:
            - !!perl/hash:RE_method
              name: package_declarator
              rest: ''
            - !!perl/hash:RE_method
              name: ws
              rest: ''
          - !!perl/hash:RE_sequence
            alt: scoped_0 3
            zyg:
            - !!perl/hash:RE_quantified_atom
              atom: !!perl/hash:RE_bracket
                re: !!perl/hash:RE_sequence
                  zyg:
                  - !!perl/hash:RE_method
                    name: typename
                    rest: ''
                  - !!perl/hash:RE_method
                    name: ws
                    rest: ''
              quant:
              - +
            - !!perl/hash:RE_method
              name: ws
              rest: ''
            - !!perl/hash:RE_block {}
            - !!perl/hash:RE_method
              name: multi_declarator
              rest: ''
            - !!perl/hash:RE_method
              name: ws
              rest: ''
          - !!perl/hash:RE_sequence
            alt: scoped_0 4
            zyg:
            - !!perl/hash:RE_method
              name: multi_declarator
              rest: ''
            - !!perl/hash:RE_method
              name: ws
              rest: ''
    - !!perl/hash:RE_sequence
      zyg:
      - !!perl/hash:RE_method
        name: ws
        rest: ''
      - !!perl/hash:RE_assertion
        assert: '?'
        re: !!perl/hash:RE_method_re
          name: before
          nobind: 1
          re: !!perl/hash:RE_sequence
            zyg:
            - !!perl/hash:RE_method
              name: ws
              rest: ''
            - !!perl/hash:RE_cclass
              i: 0
              text: '[A..Z]'
      - !!perl/hash:RE_method
        name: longname
        rest: ''
      - !!perl/hash:RE_block {}
      - !!perl/hash:RE_method
        name: ws
        rest: ''
      - !!perl/hash:RE_assertion
        assert: '!'
        re: !!perl/hash:RE_noop
          nobind: 1
    - !!perl/hash:RE_sequence
      zyg:
      - !!perl/hash:RE_method
        name: ws
        rest: ''
      - !!perl/hash:RE_method
        name: panic
        rest: 1
      - !!perl/hash:RE_method
        name: ws
        rest: ''
scoped_0: *70
semiarglist: !!perl/hash:RE_ast
  dba: semiarglist
  dic: STD::P6
  re: !!perl/hash:RE_sequence
    zyg:
    - !!perl/hash:RE_quantified_atom
      atom: !!perl/hash:RE_method
        name: arglist
        rest: ''
      quant:
      - '**'
      - ':'
      - !!perl/hash:RE_string
        a: 0
        dba: semiarglist
        dic: STD::P6
        i: 0
        i_needed: 1
        r: 1
        s: 0
        text: ;
    - !!perl/hash:RE_method
      name: ws
      rest: ''
semilist: !!perl/hash:RE_ast
  dba: semicolon list
  dic: STD::P6
  re: !!perl/hash:RE_sequence
    zyg:
    - !!perl/hash:RE_method
      name: ws
      rest: ''
    - !!perl/hash:RE_bracket
      re: &71 !!perl/hash:RE_any
        altname: semilist_0
        dba: semicolon list
        dic: STD::P6
        zyg:
        - !!perl/hash:RE_assertion
          alt: semilist_0 0
          assert: '?'
          re: !!perl/hash:RE_method_re
            name: before
            nobind: 1
            re: !!perl/hash:RE_sequence
              zyg:
              - !!perl/hash:RE_method
                name: ws
                rest: ''
              - !!perl/hash:RE_cclass
                i: 0
                text: '[\)\]\}]'
        - !!perl/hash:RE_sequence
          alt: semilist_0 1
          zyg:
          - !!perl/hash:RE_quantified_atom
            atom: !!perl/hash:RE_bracket
              re: !!perl/hash:RE_sequence
                zyg:
                - !!perl/hash:RE_method
                  name: statement
                  rest: ''
                - !!perl/hash:RE_method
                  name: eat_terminator
                  rest: ''
                - !!perl/hash:RE_method
                  name: ws
                  rest: ''
            quant:
            - '*'
          - !!perl/hash:RE_method
            name: ws
            rest: ''
semilist_0: *71
sibble: !!perl/hash:RE_ast
  dba: sibble
  dic: STD::P6
  re: !!perl/hash:RE_sequence
    zyg:
    - !!perl/hash:RE_method
      name: babble
      rest: 1
    - !!perl/hash:RE_block {}
    - !!perl/hash:RE_var
      var: $start
    - !!perl/hash:RE_bindnamed
      atom: !!perl/hash:RE_method
        name: nibble
        rest: 1
    - !!perl/hash:RE_bracket
      re: !!perl/hash:RE_first
        zyg:
        - !!perl/hash:RE_var
          var: $stop
        - !!perl/hash:RE_method
          name: panic
          rest: 1
    - !!perl/hash:RE_bracket
      re: !!perl/hash:RE_first
        zyg:
        - !!perl/hash:RE_sequence
          zyg:
          - !!perl/hash:RE_assertion
            assert: '?'
            re: !!perl/hash:RE_block
              nobind: 1
          - !!perl/hash:RE_method
            name: ws
            rest: ''
          - !!perl/hash:RE_bracket
            re: !!perl/hash:RE_first
              zyg:
              - !!perl/hash:RE_method
                name: infixish
                rest: ''
              - !!perl/hash:RE_method
                name: panic
                rest: 1
          - !!perl/hash:RE_bracket
            re: !!perl/hash:RE_first
              zyg:
              - !!perl/hash:RE_assertion
                assert: '?'
                re: !!perl/hash:RE_block
                  nobind: 1
              - !!perl/hash:RE_method
                name: panic
                rest: 1
          - !!perl/hash:RE_method
            name: ws
            rest: ''
          - !!perl/hash:RE_bindnamed
            atom: !!perl/hash:RE_method
              name: EXPR
              rest: 1
        - !!perl/hash:RE_sequence
          zyg:
          - !!perl/hash:RE_block {}
          - !!perl/hash:RE_bindnamed
            atom: !!perl/hash:RE_method
              name: nibble
              rest: 1
          - !!perl/hash:RE_var
            var: $stop
        - !!perl/hash:RE_method
          name: panic
          rest: 1
signature: !!perl/hash:RE_ast
  dba: signature
  dic: STD::P6
  re: !!perl/hash:RE_sequence
    zyg:
    - !!perl/hash:RE_method
      name: ws
      rest: ''
    - !!perl/hash:RE_bracket
      re: &72 !!perl/hash:RE_any
        altname: signature_0
        dba: signature
        dic: STD::P6
        zyg:
        - !!perl/hash:RE_sequence
          alt: signature_0 0
          zyg:
          - !!perl/hash:RE_string
            i: 0
            text: \|
          - !!perl/hash:RE_bracket
            re: !!perl/hash:RE_first
              zyg:
              - !!perl/hash:RE_method
                name: param_var
                rest: ''
              - !!perl/hash:RE_method
                name: panic
                rest: 1
          - !!perl/hash:RE_method
            name: ws
            rest: ''
          - !!perl/hash:RE_bracket
            re: !!perl/hash:RE_first
              zyg:
              - !!perl/hash:RE_assertion
                assert: '?'
                re: !!perl/hash:RE_method_re
                  name: before
                  nobind: 1
                  re: &73 !!perl/hash:RE_any
                    altname: signature_1
                    dba: signature
                    dic: STD::P6
                    zyg:
                    - !!perl/hash:RE_string
                      alt: signature_1 0
                      i: 0
                      text: -->
                    - !!perl/hash:RE_string
                      alt: signature_1 1
                      i: 0
                      text: )
                    - !!perl/hash:RE_string
                      alt: signature_1 2
                      i: 0
                      text: ']'
              - !!perl/hash:RE_method
                name: panic
                rest: 1
        - !!perl/hash:RE_quantified_atom
          alt: signature_0 1
          atom: !!perl/hash:RE_bracket
            re: &74 !!perl/hash:RE_any
              altname: signature_2
              dba: signature
              dic: STD::P6
              zyg:
              - !!perl/hash:RE_assertion
                alt: signature_2 0
                assert: '?'
                re: !!perl/hash:RE_method_re
                  name: before
                  nobind: 1
                  re: &75 !!perl/hash:RE_any
                    altname: signature_3
                    dba: signature
                    dic: STD::P6
                    zyg:
                    - !!perl/hash:RE_string
                      alt: signature_3 0
                      i: 0
                      text: -->
                    - !!perl/hash:RE_string
                      alt: signature_3 1
                      i: 0
                      text: )
                    - !!perl/hash:RE_string
                      alt: signature_3 2
                      i: 0
                      text: ']'
                    - !!perl/hash:RE_string
                      alt: signature_3 3
                      i: 0
                      text: '{'
                    - !!perl/hash:RE_sequence
                      alt: signature_3 4
                      zyg:
                      - !!perl/hash:RE_string
                        i: 0
                        text: ':'
                      - !!perl/hash:RE_meta
                        min: 1
                        text: \s
                    - !!perl/hash:RE_string
                      alt: signature_3 5
                      i: 0
                      text: ;;
              - !!perl/hash:RE_bracket
                alt: signature_2 1
                re: !!perl/hash:RE_first
                  zyg:
                  - !!perl/hash:RE_method
                    name: parameter
                    rest: ''
                  - !!perl/hash:RE_method
                    name: panic
                    rest: 1
          quant:
          - '**'
          - ':'
          - !!perl/hash:RE_method
            a: 0
            dba: signature
            dic: STD::P6
            i: 0
            name: param_sep
            need_match: 0
            r: 1
            rest: ~
            s: 0
    - !!perl/hash:RE_method
      name: ws
      rest: ''
    - !!perl/hash:RE_block {}
    - !!perl/hash:RE_quantified_atom
      atom: !!perl/hash:RE_bracket
        re: !!perl/hash:RE_sequence
          zyg:
          - !!perl/hash:RE_string
            i: 0
            text: -->
          - !!perl/hash:RE_method
            name: ws
            rest: ''
          - !!perl/hash:RE_bracket
            re: !!perl/hash:RE_first
              zyg:
              - !!perl/hash:RE_method
                name: type_constraint
                rest: ''
              - !!perl/hash:RE_sequence
                zyg:
                - !!perl/hash:RE_method
                  name: longname
                  rest: ''
                - !!perl/hash:RE_method
                  name: panic
                  rest: 1
              - !!perl/hash:RE_method
                name: panic
                rest: 1
          - !!perl/hash:RE_method
            name: ws
            rest: ''
      quant:
      - '?'
    - !!perl/hash:RE_block {}
signature_0: *72
signature_1: *73
signature_2: *74
signature_3: *75
sigterm: !!perl/hash:RE_ast
  dba: signature
  dic: STD::P6
  re: !!perl/hash:RE_bracket
    re: !!perl/hash:RE_sequence
      zyg:
      - !!perl/hash:RE_string
        i: 0
        text: :(
      - !!perl/hash:RE_block {}
      - !!perl/hash:RE_method
        name: fakesignature
        rest: ''
      - !!perl/hash:RE_bracket
        re: !!perl/hash:RE_first
          zyg:
          - !!perl/hash:RE_string
            i: 0
            text: )
          - !!perl/hash:RE_method
            name: FAILGOAL
            rest: 1
special_variable__S_091Dollar_a2_: !!perl/hash:RE_ast
  dba: special_variable
  dic: STD::P6
  re: !!perl/hash:RE_method
    i: 0
    name: sym
    rest: ''
    sym: $¢
special_variable__S_092DollarBang: !!perl/hash:RE_ast
  dba: special_variable
  dic: STD::P6
  re: !!perl/hash:RE_sequence
    zyg:
    - !!perl/hash:RE_method
      i: 0
      name: sym
      rest: ''
      sym: $!
    - !!perl/hash:RE_assertion
      assert: '!'
      re: !!perl/hash:RE_method_re
        name: before
        nobind: 1
        re: !!perl/hash:RE_meta
          min: 1
          text: \w
special_variable__S_093DollarBangCur_Ly: !!perl/hash:RE_ast
  dba: special_variable
  dic: STD::P6
  re: !!perl/hash:RE_sequence
    zyg:
    - !!perl/hash:RE_string
      i: 0
      text: $!
    - !!perl/hash:RE_bracket
      re: !!perl/hash:RE_sequence
        zyg:
        - !!perl/hash:RE_string
          i: 0
          text: '{'
        - !!perl/hash:RE_block {}
        - !!perl/hash:RE_bracket
          re: &76 !!perl/hash:RE_any
            altname: special_variable__S_093DollarBangCur_Ly_0
            dba: special_variable
            dic: STD::P6
            zyg:
            - !!perl/hash:RE_method
              alt: special_variable__S_093DollarBangCur_Ly_0 0
              name: identifier
              rest: ''
            - !!perl/hash:RE_method
              alt: special_variable__S_093DollarBangCur_Ly_0 1
              name: statementlist
              rest: ''
        - !!perl/hash:RE_bracket
          re: !!perl/hash:RE_first
            zyg:
            - !!perl/hash:RE_string
              i: 0
              text: '}'
            - !!perl/hash:RE_method
              name: FAILGOAL
              rest: 1
    - !!perl/hash:RE_block {}
special_variable__S_093DollarBangCur_Ly_0: *76
special_variable__S_094DollarSlash: !!perl/hash:RE_ast
  dba: special_variable
  dic: STD::P6
  re: !!perl/hash:RE_sequence
    zyg:
    - !!perl/hash:RE_method
      i: 0
      name: sym
      rest: ''
      sym: $/
    - !!perl/hash:RE_quantified_atom
      atom: !!perl/hash:RE_bracket
        re: !!perl/hash:RE_sequence
          zyg:
          - !!perl/hash:RE_assertion
            assert: '?'
            re: !!perl/hash:RE_method_re
              name: before
              nobind: 1
              re: !!perl/hash:RE_sequence
                zyg:
                - !!perl/hash:RE_quantified_atom
                  atom: !!perl/hash:RE_meta
                    min: 1
                    text: \h
                  quant:
                  - '*'
                - !!perl/hash:RE_string
                  i: 0
                  text: =
                - !!perl/hash:RE_assertion
                  assert: '!'
                  re: !!perl/hash:RE_cclass
                    i: 0
                    nobind: 1
                    text: '[=]'
          - !!perl/hash:RE_method
            name: obs
            rest: 1
      quant:
      - '?'
special_variable__S_095DollarTilde: !!perl/hash:RE_ast
  dba: special_variable
  dic: STD::P6
  re: !!perl/hash:RE_sequence
    zyg:
    - !!perl/hash:RE_method
      i: 0
      name: sym
      rest: ''
      sym: $~
    - !!perl/hash:RE_meta
      text: '::'
    - !!perl/hash:RE_assertion
      assert: '?'
      re: !!perl/hash:RE_method_re
        name: before
        nobind: 1
        re: &77 !!perl/hash:RE_any
          altname: special_variable__S_095DollarTilde_0
          dba: special_variable
          dic: STD::P6
          zyg:
          - !!perl/hash:RE_meta
            alt: special_variable__S_095DollarTilde_0 0
            min: 1
            text: \s
          - !!perl/hash:RE_string
            alt: special_variable__S_095DollarTilde_0 1
            i: 0
            text: ','
          - !!perl/hash:RE_string
            alt: special_variable__S_095DollarTilde_0 2
            i: 0
            text: =
          - !!perl/hash:RE_method
            alt: special_variable__S_095DollarTilde_0 3
            name: terminator
            rest: ''
    - !!perl/hash:RE_method
      name: obs
      rest: 1
special_variable__S_095DollarTilde_0: *77
special_variable__S_096DollarGrave: !!perl/hash:RE_ast
  dba: special_variable
  dic: STD::P6
  re: !!perl/hash:RE_sequence
    zyg:
    - !!perl/hash:RE_method
      i: 0
      name: sym
      rest: ''
      sym: $`
    - !!perl/hash:RE_meta
      text: '::'
    - !!perl/hash:RE_assertion
      assert: '?'
      re: !!perl/hash:RE_method_re
        name: before
        nobind: 1
        re: &78 !!perl/hash:RE_any
          altname: special_variable__S_096DollarGrave_0
          dba: special_variable
          dic: STD::P6
          zyg:
          - !!perl/hash:RE_meta
            alt: special_variable__S_096DollarGrave_0 0
            min: 1
            text: \s
          - !!perl/hash:RE_string
            alt: special_variable__S_096DollarGrave_0 1
            i: 0
            text: ','
          - !!perl/hash:RE_method
            alt: special_variable__S_096DollarGrave_0 2
            name: terminator
            rest: ''
    - !!perl/hash:RE_method
      name: obs
      rest: 1
special_variable__S_096DollarGrave_0: *78
special_variable__S_097DollarAt: !!perl/hash:RE_ast
  dba: special_variable
  dic: STD::P6
  re: !!perl/hash:RE_sequence
    zyg:
    - !!perl/hash:RE_method
      i: 0
      name: sym
      rest: ''
      sym: $@
    - !!perl/hash:RE_assertion
      assert: '?'
      re: !!perl/hash:RE_method_re
        name: before
        nobind: 1
        re: !!perl/hash:RE_meta
          min: 1
          text: \W
    - !!perl/hash:RE_meta
      text: '::'
    - !!perl/hash:RE_method
      name: obs
      rest: 1
special_variable__S_098DollarSharp: !!perl/hash:RE_ast
  dba: special_variable
  dic: STD::P6
  re: !!perl/hash:RE_sequence
    zyg:
    - !!perl/hash:RE_method
      i: 0
      name: sym
      rest: ''
      sym: $#
    - !!perl/hash:RE_meta
      text: '::'
    - !!perl/hash:RE_bracket
      re: !!perl/hash:RE_first
        zyg:
        - !!perl/hash:RE_sequence
          zyg:
          - !!perl/hash:RE_bindpos
            atom: !!perl/hash:RE_paren
              re: !!perl/hash:RE_quantified_atom
                atom: !!perl/hash:RE_meta
                  min: 1
                  text: \w
                quant:
                - +
          - !!perl/hash:RE_method
            name: obs
            rest: 1
        - !!perl/hash:RE_method
          name: obs
          rest: 1
special_variable__S_099DollarDollar: !!perl/hash:RE_ast
  dba: special_variable
  dic: STD::P6
  re: !!perl/hash:RE_sequence
    zyg:
    - !!perl/hash:RE_method
      i: 0
      name: sym
      rest: ''
      sym: $$
    - !!perl/hash:RE_assertion
      assert: '!'
      re: !!perl/hash:RE_method
        name: alpha
        rest: ''
    - !!perl/hash:RE_meta
      text: '::'
    - !!perl/hash:RE_assertion
      assert: '?'
      re: !!perl/hash:RE_method_re
        name: before
        nobind: 1
        re: &79 !!perl/hash:RE_any
          altname: special_variable__S_099DollarDollar_0
          dba: special_variable
          dic: STD::P6
          zyg:
          - !!perl/hash:RE_meta
            alt: special_variable__S_099DollarDollar_0 0
            min: 1
            text: \s
          - !!perl/hash:RE_string
            alt: special_variable__S_099DollarDollar_0 1
            i: 0
            text: ','
          - !!perl/hash:RE_method
            alt: special_variable__S_099DollarDollar_0 2
            name: terminator
            rest: ''
    - !!perl/hash:RE_method
      name: obs
      rest: 1
special_variable__S_099DollarDollar_0: *79
special_variable__S_100DollarPercent: !!perl/hash:RE_ast
  dba: special_variable
  dic: STD::P6
  re: !!perl/hash:RE_sequence
    zyg:
    - !!perl/hash:RE_method
      i: 0
      name: sym
      rest: ''
      sym: $%
    - !!perl/hash:RE_assertion
      assert: '!'
      re: !!perl/hash:RE_method_re
        name: before
        nobind: 1
        re: !!perl/hash:RE_meta
          min: 1
          text: \w
    - !!perl/hash:RE_assertion
      assert: '!'
      re: !!perl/hash:RE_method
        name: sigil
        rest: ''
    - !!perl/hash:RE_meta
      text: '::'
    - !!perl/hash:RE_method
      name: obs
      rest: 1
special_variable__S_101DollarCaretX: !!perl/hash:RE_ast
  dba: special_variable
  dic: STD::P6
  re: !!perl/hash:RE_sequence
    zyg:
    - !!perl/hash:RE_method
      name: sigil
      rest: ''
    - !!perl/hash:RE_string
      i: 0
      text: ^
    - !!perl/hash:RE_bindnamed
      atom: !!perl/hash:RE_bracket
        re: !!perl/hash:RE_cclass
          i: 0
          text: '[A..Z]'
    - !!perl/hash:RE_meta
      min: 1
      text: \W
    - !!perl/hash:RE_method
      name: obscaret
      rest: 1
special_variable__S_102DollarCaret: !!perl/hash:RE_ast
  dba: special_variable
  dic: STD::P6
  re: !!perl/hash:RE_sequence
    zyg:
    - !!perl/hash:RE_method
      i: 0
      name: sym
      rest: ''
      sym: $^
    - !!perl/hash:RE_meta
      text: '::'
    - !!perl/hash:RE_assertion
      assert: '?'
      re: !!perl/hash:RE_method_re
        name: before
        nobind: 1
        re: &80 !!perl/hash:RE_any
          altname: special_variable__S_102DollarCaret_0
          dba: special_variable
          dic: STD::P6
          zyg:
          - !!perl/hash:RE_meta
            alt: special_variable__S_102DollarCaret_0 0
            min: 1
            text: \s
          - !!perl/hash:RE_string
            alt: special_variable__S_102DollarCaret_0 1
            i: 0
            text: ','
          - !!perl/hash:RE_string
            alt: special_variable__S_102DollarCaret_0 2
            i: 0
            text: =
          - !!perl/hash:RE_method
            alt: special_variable__S_102DollarCaret_0 3
            name: terminator
            rest: ''
    - !!perl/hash:RE_method
      name: obs
      rest: 1
special_variable__S_102DollarCaret_0: *80
special_variable__S_103DollarAmp: !!perl/hash:RE_ast
  dba: special_variable
  dic: STD::P6
  re: !!perl/hash:RE_sequence
    zyg:
    - !!perl/hash:RE_method
      i: 0
      name: sym
      rest: ''
      sym: $&
    - !!perl/hash:RE_meta
      text: '::'
    - !!perl/hash:RE_assertion
      assert: '?'
      re: !!perl/hash:RE_method_re
        name: before
        nobind: 1
        re: &81 !!perl/hash:RE_any
          altname: special_variable__S_103DollarAmp_0
          dba: special_variable
          dic: STD::P6
          zyg:
          - !!perl/hash:RE_meta
            alt: special_variable__S_103DollarAmp_0 0
            min: 1
            text: \s
          - !!perl/hash:RE_string
            alt: special_variable__S_103DollarAmp_0 1
            i: 0
            text: ','
          - !!perl/hash:RE_method
            alt: special_variable__S_103DollarAmp_0 2
            name: terminator
            rest: ''
    - !!perl/hash:RE_method
      name: obs
      rest: 1
special_variable__S_103DollarAmp_0: *81
special_variable__S_104DollarStar: !!perl/hash:RE_ast
  dba: special_variable
  dic: STD::P6
  re: !!perl/hash:RE_sequence
    zyg:
    - !!perl/hash:RE_method
      i: 0
      name: sym
      rest: ''
      sym: $*
    - !!perl/hash:RE_meta
      text: '::'
    - !!perl/hash:RE_assertion
      assert: '?'
      re: !!perl/hash:RE_method_re
        name: before
        nobind: 1
        re: &82 !!perl/hash:RE_any
          altname: special_variable__S_104DollarStar_0
          dba: special_variable
          dic: STD::P6
          zyg:
          - !!perl/hash:RE_meta
            alt: special_variable__S_104DollarStar_0 0
            min: 1
            text: \s
          - !!perl/hash:RE_string
            alt: special_variable__S_104DollarStar_0 1
            i: 0
            text: ','
          - !!perl/hash:RE_string
            alt: special_variable__S_104DollarStar_0 2
            i: 0
            text: =
          - !!perl/hash:RE_method
            alt: special_variable__S_104DollarStar_0 3
            name: terminator
            rest: ''
    - !!perl/hash:RE_method
      name: obs
      rest: 1
special_variable__S_104DollarStar_0: *82
special_variable__S_105DollarThesis: !!perl/hash:RE_ast
  dba: special_variable
  dic: STD::P6
  re: !!perl/hash:RE_sequence
    zyg:
    - !!perl/hash:RE_method
      i: 0
      name: sym
      rest: ''
      sym: $)
    - !!perl/hash:RE_assertion
      assert: '?'
      re: !!perl/hash:RE_block
        nobind: 1
    - !!perl/hash:RE_assertion
      assert: '?'
      re: !!perl/hash:RE_method_re
        name: before
        nobind: 1
        re: &83 !!perl/hash:RE_any
          altname: special_variable__S_105DollarThesis_0
          dba: special_variable
          dic: STD::P6
          zyg:
          - !!perl/hash:RE_meta
            alt: special_variable__S_105DollarThesis_0 0
            min: 1
            text: \s
          - !!perl/hash:RE_string
            alt: special_variable__S_105DollarThesis_0 1
            i: 0
            text: ','
          - !!perl/hash:RE_method
            alt: special_variable__S_105DollarThesis_0 2
            name: terminator
            rest: ''
    - !!perl/hash:RE_method
      name: obs
      rest: 1
special_variable__S_105DollarThesis_0: *83
special_variable__S_106DollarMinus: !!perl/hash:RE_ast
  dba: special_variable
  dic: STD::P6
  re: !!perl/hash:RE_sequence
    zyg:
    - !!perl/hash:RE_method
      i: 0
      name: sym
      rest: ''
      sym: $-
    - !!perl/hash:RE_meta
      text: '::'
    - !!perl/hash:RE_assertion
      assert: '?'
      re: !!perl/hash:RE_method_re
        name: before
        nobind: 1
        re: &84 !!perl/hash:RE_any
          altname: special_variable__S_106DollarMinus_0
          dba: special_variable
          dic: STD::P6
          zyg:
          - !!perl/hash:RE_meta
            alt: special_variable__S_106DollarMinus_0 0
            min: 1
            text: \s
          - !!perl/hash:RE_string
            alt: special_variable__S_106DollarMinus_0 1
            i: 0
            text: ','
          - !!perl/hash:RE_string
            alt: special_variable__S_106DollarMinus_0 2
            i: 0
            text: =
          - !!perl/hash:RE_method
            alt: special_variable__S_106DollarMinus_0 3
            name: terminator
            rest: ''
    - !!perl/hash:RE_method
      name: obs
      rest: 1
special_variable__S_106DollarMinus_0: *84
special_variable__S_107DollarEqual: !!perl/hash:RE_ast
  dba: special_variable
  dic: STD::P6
  re: !!perl/hash:RE_sequence
    zyg:
    - !!perl/hash:RE_method
      i: 0
      name: sym
      rest: ''
      sym: $=
    - !!perl/hash:RE_meta
      text: '::'
    - !!perl/hash:RE_assertion
      assert: '?'
      re: !!perl/hash:RE_method_re
        name: before
        nobind: 1
        re: &85 !!perl/hash:RE_any
          altname: special_variable__S_107DollarEqual_0
          dba: special_variable
          dic: STD::P6
          zyg:
          - !!perl/hash:RE_meta
            alt: special_variable__S_107DollarEqual_0 0
            min: 1
            text: \s
          - !!perl/hash:RE_string
            alt: special_variable__S_107DollarEqual_0 1
            i: 0
            text: ','
          - !!perl/hash:RE_string
            alt: special_variable__S_107DollarEqual_0 2
            i: 0
            text: =
          - !!perl/hash:RE_method
            alt: special_variable__S_107DollarEqual_0 3
            name: terminator
            rest: ''
    - !!perl/hash:RE_method
      name: obs
      rest: 1
special_variable__S_107DollarEqual_0: *85
special_variable__S_108AtPlus: !!perl/hash:RE_ast
  dba: special_variable
  dic: STD::P6
  re: !!perl/hash:RE_sequence
    zyg:
    - !!perl/hash:RE_method
      i: 0
      name: sym
      rest: ''
      sym: '@+'
    - !!perl/hash:RE_meta
      text: '::'
    - !!perl/hash:RE_assertion
      assert: '?'
      re: !!perl/hash:RE_method_re
        name: before
        nobind: 1
        re: &86 !!perl/hash:RE_any
          altname: special_variable__S_108AtPlus_0
          dba: special_variable
          dic: STD::P6
          zyg:
          - !!perl/hash:RE_meta
            alt: special_variable__S_108AtPlus_0 0
            min: 1
            text: \s
          - !!perl/hash:RE_string
            alt: special_variable__S_108AtPlus_0 1
            i: 0
            text: ','
          - !!perl/hash:RE_method
            alt: special_variable__S_108AtPlus_0 2
            name: terminator
            rest: ''
    - !!perl/hash:RE_method
      name: obs
      rest: 1
special_variable__S_108AtPlus_0: *86
special_variable__S_109PercentPlus: !!perl/hash:RE_ast
  dba: special_variable
  dic: STD::P6
  re: !!perl/hash:RE_sequence
    zyg:
    - !!perl/hash:RE_method
      i: 0
      name: sym
      rest: ''
      sym: '%+'
    - !!perl/hash:RE_meta
      text: '::'
    - !!perl/hash:RE_assertion
      assert: '?'
      re: !!perl/hash:RE_method_re
        name: before
        nobind: 1
        re: &87 !!perl/hash:RE_any
          altname: special_variable__S_109PercentPlus_0
          dba: special_variable
          dic: STD::P6
          zyg:
          - !!perl/hash:RE_meta
            alt: special_variable__S_109PercentPlus_0 0
            min: 1
            text: \s
          - !!perl/hash:RE_string
            alt: special_variable__S_109PercentPlus_0 1
            i: 0
            text: ','
          - !!perl/hash:RE_method
            alt: special_variable__S_109PercentPlus_0 2
            name: terminator
            rest: ''
    - !!perl/hash:RE_method
      name: obs
      rest: 1
special_variable__S_109PercentPlus_0: *87
special_variable__S_110DollarPlusBra_Ket: !!perl/hash:RE_ast
  dba: special_variable
  dic: STD::P6
  re: !!perl/hash:RE_sequence
    zyg:
    - !!perl/hash:RE_string
      i: 0
      text: $+[
    - !!perl/hash:RE_method
      name: obs
      rest: 1
special_variable__S_111AtPlusBra_Ket: !!perl/hash:RE_ast
  dba: special_variable
  dic: STD::P6
  re: !!perl/hash:RE_sequence
    zyg:
    - !!perl/hash:RE_string
      i: 0
      text: '@+['
    - !!perl/hash:RE_method
      name: obs
      rest: 1
special_variable__S_112AtPlusCur_Ly: !!perl/hash:RE_ast
  dba: special_variable
  dic: STD::P6
  re: !!perl/hash:RE_sequence
    zyg:
    - !!perl/hash:RE_string
      i: 0
      text: '@+{'
    - !!perl/hash:RE_method
      name: obs
      rest: 1
special_variable__S_113AtMinus: !!perl/hash:RE_ast
  dba: special_variable
  dic: STD::P6
  re: !!perl/hash:RE_sequence
    zyg:
    - !!perl/hash:RE_method
      i: 0
      name: sym
      rest: ''
      sym: '@-'
    - !!perl/hash:RE_meta
      text: '::'
    - !!perl/hash:RE_assertion
      assert: '?'
      re: !!perl/hash:RE_method_re
        name: before
        nobind: 1
        re: &88 !!perl/hash:RE_any
          altname: special_variable__S_113AtMinus_0
          dba: special_variable
          dic: STD::P6
          zyg:
          - !!perl/hash:RE_meta
            alt: special_variable__S_113AtMinus_0 0
            min: 1
            text: \s
          - !!perl/hash:RE_string
            alt: special_variable__S_113AtMinus_0 1
            i: 0
            text: ','
          - !!perl/hash:RE_method
            alt: special_variable__S_113AtMinus_0 2
            name: terminator
            rest: ''
    - !!perl/hash:RE_method
      name: obs
      rest: 1
special_variable__S_113AtMinus_0: *88
special_variable__S_114PercentMinus: !!perl/hash:RE_ast
  dba: special_variable
  dic: STD::P6
  re: !!perl/hash:RE_sequence
    zyg:
    - !!perl/hash:RE_method
      i: 0
      name: sym
      rest: ''
      sym: '%-'
    - !!perl/hash:RE_meta
      text: '::'
    - !!perl/hash:RE_assertion
      assert: '?'
      re: !!perl/hash:RE_method_re
        name: before
        nobind: 1
        re: &89 !!perl/hash:RE_any
          altname: special_variable__S_114PercentMinus_0
          dba: special_variable
          dic: STD::P6
          zyg:
          - !!perl/hash:RE_meta
            alt: special_variable__S_114PercentMinus_0 0
            min: 1
            text: \s
          - !!perl/hash:RE_string
            alt: special_variable__S_114PercentMinus_0 1
            i: 0
            text: ','
          - !!perl/hash:RE_method
            alt: special_variable__S_114PercentMinus_0 2
            name: terminator
            rest: ''
    - !!perl/hash:RE_method
      name: obs
      rest: 1
special_variable__S_114PercentMinus_0: *89
special_variable__S_115DollarMinusBra_Ket: !!perl/hash:RE_ast
  dba: special_variable
  dic: STD::P6
  re: !!perl/hash:RE_sequence
    zyg:
    - !!perl/hash:RE_string
      i: 0
      text: $-[
    - !!perl/hash:RE_method
      name: obs
      rest: 1
special_variable__S_116AtMinusBra_Ket: !!perl/hash:RE_ast
  dba: special_variable
  dic: STD::P6
  re: !!perl/hash:RE_sequence
    zyg:
    - !!perl/hash:RE_string
      i: 0
      text: '@-['
    - !!perl/hash:RE_method
      name: obs
      rest: 1
special_variable__S_117PercentMinusCur_Ly: !!perl/hash:RE_ast
  dba: special_variable
  dic: STD::P6
  re: !!perl/hash:RE_sequence
    zyg:
    - !!perl/hash:RE_string
      i: 0
      text: '@-{'
    - !!perl/hash:RE_method
      name: obs
      rest: 1
special_variable__S_118DollarPlus: !!perl/hash:RE_ast
  dba: special_variable
  dic: STD::P6
  re: !!perl/hash:RE_sequence
    zyg:
    - !!perl/hash:RE_method
      i: 0
      name: sym
      rest: ''
      sym: $+
    - !!perl/hash:RE_meta
      text: '::'
    - !!perl/hash:RE_assertion
      assert: '?'
      re: !!perl/hash:RE_method_re
        name: before
        nobind: 1
        re: &90 !!perl/hash:RE_any
          altname: special_variable__S_118DollarPlus_0
          dba: special_variable
          dic: STD::P6
          zyg:
          - !!perl/hash:RE_meta
            alt: special_variable__S_118DollarPlus_0 0
            min: 1
            text: \s
          - !!perl/hash:RE_string
            alt: special_variable__S_118DollarPlus_0 1
            i: 0
            text: ','
          - !!perl/hash:RE_method
            alt: special_variable__S_118DollarPlus_0 2
            name: terminator
            rest: ''
    - !!perl/hash:RE_method
      name: obs
      rest: 1
special_variable__S_118DollarPlus_0: *90
special_variable__S_119DollarCurCaret_Ly: !!perl/hash:RE_ast
  dba: special_variable
  dic: STD::P6
  re: !!perl/hash:RE_sequence
    zyg:
    - !!perl/hash:RE_method
      name: sigil
      rest: ''
    - !!perl/hash:RE_string
      i: 0
      text: '{^'
    - !!perl/hash:RE_meta
      text: '::'
    - !!perl/hash:RE_bindnamed
      atom: !!perl/hash:RE_bracket
        re: !!perl/hash:RE_meta
          text: .*?
    - !!perl/hash:RE_string
      i: 0
      text: '}'
    - !!perl/hash:RE_method
      name: obscaret
      rest: 1
special_variable__S_120ColonColonCur_Ly: !!perl/hash:RE_ast
  dba: special_variable
  dic: STD::P6
  re: !!perl/hash:RE_sequence
    zyg:
    - !!perl/hash:RE_string
      i: 0
      text: '::'
    - !!perl/hash:RE_assertion
      assert: '?'
      re: !!perl/hash:RE_method_re
        name: before
        nobind: 1
        re: !!perl/hash:RE_string
          i: 0
          text: '{'
special_variable__S_121DollarCur_Ly: !!perl/hash:RE_ast
  dba: special_variable
  dic: STD::P6
  re: !!perl/hash:RE_sequence
    zyg:
    - !!perl/hash:RE_method
      name: sigil
      rest: ''
    - !!perl/hash:RE_string
      i: 0
      text: '{'
    - !!perl/hash:RE_block {}
    - !!perl/hash:RE_bindnamed
      atom: !!perl/hash:RE_bracket
        re: !!perl/hash:RE_meta
          text: .*?
    - !!perl/hash:RE_string
      i: 0
      text: '}'
    - !!perl/hash:RE_block {}
special_variable__S_122DollarBra: !!perl/hash:RE_ast
  dba: special_variable
  dic: STD::P6
  re: !!perl/hash:RE_sequence
    zyg:
    - !!perl/hash:RE_method
      i: 0
      name: sym
      rest: ''
      sym: $[
    - !!perl/hash:RE_meta
      text: '::'
    - !!perl/hash:RE_assertion
      assert: '?'
      re: !!perl/hash:RE_method_re
        name: before
        nobind: 1
        re: &91 !!perl/hash:RE_any
          altname: special_variable__S_122DollarBra_0
          dba: special_variable
          dic: STD::P6
          zyg:
          - !!perl/hash:RE_meta
            alt: special_variable__S_122DollarBra_0 0
            min: 1
            text: \s
          - !!perl/hash:RE_string
            alt: special_variable__S_122DollarBra_0 1
            i: 0
            text: ','
          - !!perl/hash:RE_string
            alt: special_variable__S_122DollarBra_0 2
            i: 0
            text: =
          - !!perl/hash:RE_method
            alt: special_variable__S_122DollarBra_0 3
            name: terminator
            rest: ''
    - !!perl/hash:RE_method
      name: obs
      rest: 1
special_variable__S_122DollarBra_0: *91
special_variable__S_123DollarKet: !!perl/hash:RE_ast
  dba: special_variable
  dic: STD::P6
  re: !!perl/hash:RE_sequence
    zyg:
    - !!perl/hash:RE_method
      i: 0
      name: sym
      rest: ''
      sym: $]
    - !!perl/hash:RE_meta
      text: '::'
    - !!perl/hash:RE_assertion
      assert: '?'
      re: !!perl/hash:RE_method_re
        name: before
        nobind: 1
        re: &92 !!perl/hash:RE_any
          altname: special_variable__S_123DollarKet_0
          dba: special_variable
          dic: STD::P6
          zyg:
          - !!perl/hash:RE_meta
            alt: special_variable__S_123DollarKet_0 0
            min: 1
            text: \s
          - !!perl/hash:RE_string
            alt: special_variable__S_123DollarKet_0 1
            i: 0
            text: ','
          - !!perl/hash:RE_method
            alt: special_variable__S_123DollarKet_0 2
            name: terminator
            rest: ''
    - !!perl/hash:RE_method
      name: obs
      rest: 1
special_variable__S_123DollarKet_0: *92
special_variable__S_124DollarBack: !!perl/hash:RE_ast
  dba: special_variable
  dic: STD::P6
  re: !!perl/hash:RE_sequence
    zyg:
    - !!perl/hash:RE_method
      i: 0
      name: sym
      rest: ''
      sym: $\
    - !!perl/hash:RE_meta
      text: '::'
    - !!perl/hash:RE_assertion
      assert: '?'
      re: !!perl/hash:RE_method_re
        name: before
        nobind: 1
        re: &93 !!perl/hash:RE_any
          altname: special_variable__S_124DollarBack_0
          dba: special_variable
          dic: STD::P6
          zyg:
          - !!perl/hash:RE_meta
            alt: special_variable__S_124DollarBack_0 0
            min: 1
            text: \s
          - !!perl/hash:RE_string
            alt: special_variable__S_124DollarBack_0 1
            i: 0
            text: ','
          - !!perl/hash:RE_string
            alt: special_variable__S_124DollarBack_0 2
            i: 0
            text: =
          - !!perl/hash:RE_method
            alt: special_variable__S_124DollarBack_0 3
            name: terminator
            rest: ''
    - !!perl/hash:RE_method
      name: obs
      rest: 1
special_variable__S_124DollarBack_0: *93
special_variable__S_125DollarVert: !!perl/hash:RE_ast
  dba: special_variable
  dic: STD::P6
  re: !!perl/hash:RE_sequence
    zyg:
    - !!perl/hash:RE_method
      i: 0
      name: sym
      rest: ''
      sym: $|
    - !!perl/hash:RE_meta
      text: '::'
    - !!perl/hash:RE_assertion
      assert: '?'
      re: !!perl/hash:RE_method_re
        name: before
        nobind: 1
        re: &94 !!perl/hash:RE_any
          altname: special_variable__S_125DollarVert_0
          dba: special_variable
          dic: STD::P6
          zyg:
          - !!perl/hash:RE_meta
            alt: special_variable__S_125DollarVert_0 0
            min: 1
            text: \s
          - !!perl/hash:RE_string
            alt: special_variable__S_125DollarVert_0 1
            i: 0
            text: ','
          - !!perl/hash:RE_string
            alt: special_variable__S_125DollarVert_0 2
            i: 0
            text: =
          - !!perl/hash:RE_method
            alt: special_variable__S_125DollarVert_0 3
            name: terminator
            rest: ''
    - !!perl/hash:RE_method
      name: obs
      rest: 1
special_variable__S_125DollarVert_0: *94
special_variable__S_126DollarColon: !!perl/hash:RE_ast
  dba: special_variable
  dic: STD::P6
  re: !!perl/hash:RE_sequence
    zyg:
    - !!perl/hash:RE_method
      i: 0
      name: sym
      rest: ''
      sym: '$:'
    - !!perl/hash:RE_assertion
      assert: '?'
      re: !!perl/hash:RE_method_re
        name: before
        nobind: 1
        re: !!perl/hash:RE_cclass
          i: 0
          text: '[\x20\t\n\],=)}]'
    - !!perl/hash:RE_method
      name: obs
      rest: 1
special_variable__S_127DollarSemi: !!perl/hash:RE_ast
  dba: special_variable
  dic: STD::P6
  re: !!perl/hash:RE_sequence
    zyg:
    - !!perl/hash:RE_method
      i: 0
      name: sym
      rest: ''
      sym: $;
    - !!perl/hash:RE_meta
      text: '::'
    - !!perl/hash:RE_assertion
      assert: '?'
      re: !!perl/hash:RE_method_re
        name: before
        nobind: 1
        re: &95 !!perl/hash:RE_any
          altname: special_variable__S_127DollarSemi_0
          dba: special_variable
          dic: STD::P6
          zyg:
          - !!perl/hash:RE_meta
            alt: special_variable__S_127DollarSemi_0 0
            min: 1
            text: \s
          - !!perl/hash:RE_string
            alt: special_variable__S_127DollarSemi_0 1
            i: 0
            text: ','
          - !!perl/hash:RE_string
            alt: special_variable__S_127DollarSemi_0 2
            i: 0
            text: =
          - !!perl/hash:RE_method
            alt: special_variable__S_127DollarSemi_0 3
            name: terminator
            rest: ''
    - !!perl/hash:RE_method
      name: obs
      rest: 1
special_variable__S_127DollarSemi_0: *95
special_variable__S_128DollarSingle: !!perl/hash:RE_ast
  dba: special_variable
  dic: STD::P6
  re: !!perl/hash:RE_sequence
    zyg:
    - !!perl/hash:RE_method
      i: 0
      name: sym
      rest: ''
      sym: $'
    - !!perl/hash:RE_meta
      text: '::'
    - !!perl/hash:RE_assertion
      assert: '?'
      re: !!perl/hash:RE_method_re
        name: before
        nobind: 1
        re: &96 !!perl/hash:RE_any
          altname: special_variable__S_128DollarSingle_0
          dba: special_variable
          dic: STD::P6
          zyg:
          - !!perl/hash:RE_meta
            alt: special_variable__S_128DollarSingle_0 0
            min: 1
            text: \s
          - !!perl/hash:RE_string
            alt: special_variable__S_128DollarSingle_0 1
            i: 0
            text: ','
          - !!perl/hash:RE_method
            alt: special_variable__S_128DollarSingle_0 2
            name: terminator
            rest: ''
    - !!perl/hash:RE_method
      name: obs
      rest: 1
special_variable__S_128DollarSingle_0: *96
special_variable__S_129DollarDouble: !!perl/hash:RE_ast
  dba: special_variable
  dic: STD::P6
  re: !!perl/hash:RE_sequence
    zyg:
    - !!perl/hash:RE_method
      i: 0
      name: sym
      rest: ''
      sym: $"
    - !!perl/hash:RE_assertion
      assert: '!'
      re: !!perl/hash:RE_block
        nobind: 1
    - !!perl/hash:RE_meta
      text: '::'
    - !!perl/hash:RE_assertion
      assert: '?'
      re: !!perl/hash:RE_method_re
        name: before
        nobind: 1
        re: &97 !!perl/hash:RE_any
          altname: special_variable__S_129DollarDouble_0
          dba: special_variable
          dic: STD::P6
          zyg:
          - !!perl/hash:RE_meta
            alt: special_variable__S_129DollarDouble_0 0
            min: 1
            text: \s
          - !!perl/hash:RE_string
            alt: special_variable__S_129DollarDouble_0 1
            i: 0
            text: ','
          - !!perl/hash:RE_string
            alt: special_variable__S_129DollarDouble_0 2
            i: 0
            text: =
          - !!perl/hash:RE_method
            alt: special_variable__S_129DollarDouble_0 3
            name: terminator
            rest: ''
    - !!perl/hash:RE_method
      name: obs
      rest: 1
special_variable__S_129DollarDouble_0: *97
special_variable__S_130DollarComma: !!perl/hash:RE_ast
  dba: special_variable
  dic: STD::P6
  re: !!perl/hash:RE_sequence
    zyg:
    - !!perl/hash:RE_method
      i: 0
      name: sym
      rest: ''
      sym: $,
    - !!perl/hash:RE_meta
      text: '::'
    - !!perl/hash:RE_assertion
      assert: '?'
      re: !!perl/hash:RE_method_re
        name: before
        nobind: 1
        re: &98 !!perl/hash:RE_any
          altname: special_variable__S_130DollarComma_0
          dba: special_variable
          dic: STD::P6
          zyg:
          - !!perl/hash:RE_meta
            alt: special_variable__S_130DollarComma_0 0
            min: 1
            text: \s
          - !!perl/hash:RE_string
            alt: special_variable__S_130DollarComma_0 1
            i: 0
            text: ','
          - !!perl/hash:RE_method
            alt: special_variable__S_130DollarComma_0 2
            name: terminator
            rest: ''
    - !!perl/hash:RE_method
      name: obs
      rest: 1
special_variable__S_130DollarComma_0: *98
special_variable__S_131DollarLt: !!perl/hash:RE_ast
  dba: special_variable
  dic: STD::P6
  re: !!perl/hash:RE_sequence
    zyg:
    - !!perl/hash:RE_method
      i: 0
      name: sym
      rest: ''
      sym: $<
    - !!perl/hash:RE_assertion
      assert: '?'
      re: !!perl/hash:RE_method_re
        name: before
        nobind: 1
        re: !!perl/hash:RE_sequence
          zyg:
          - !!perl/hash:RE_quantified_atom
            atom: !!perl/hash:RE_meta
              min: 1
              text: \h
            quant:
            - '*'
          - !!perl/hash:RE_cclass
            i: 0
            text: '[ = , ; ? : ! ) \] } ]'
          - !!perl/hash:RE_assertion
            assert: '!'
            re: !!perl/hash:RE_method_re
              name: before
              nobind: 1
              re: !!perl/hash:RE_sequence
                zyg:
                - !!perl/hash:RE_quantified_atom
                  atom: !!perl/hash:RE_meta
                    min: 1
                    text: \S
                  quant:
                  - '*'
                - !!perl/hash:RE_string
                  i: 0
                  text: '>'
    - !!perl/hash:RE_method
      name: obs
      rest: 1
special_variable__S_132DollarGt: !!perl/hash:RE_ast
  dba: special_variable
  dic: STD::P6
  re: !!perl/hash:RE_sequence
    zyg:
    - !!perl/hash:RE_method
      i: 0
      name: sym
      rest: ''
      sym: $>
    - !!perl/hash:RE_meta
      text: '::'
    - !!perl/hash:RE_assertion
      assert: '?'
      re: !!perl/hash:RE_method_re
        name: before
        nobind: 1
        re: &99 !!perl/hash:RE_any
          altname: special_variable__S_132DollarGt_0
          dba: special_variable
          dic: STD::P6
          zyg:
          - !!perl/hash:RE_meta
            alt: special_variable__S_132DollarGt_0 0
            min: 1
            text: \s
          - !!perl/hash:RE_string
            alt: special_variable__S_132DollarGt_0 1
            i: 0
            text: ','
          - !!perl/hash:RE_method
            alt: special_variable__S_132DollarGt_0 2
            name: terminator
            rest: ''
    - !!perl/hash:RE_method
      name: obs
      rest: 1
special_variable__S_132DollarGt_0: *99
special_variable__S_133DollarDot: !!perl/hash:RE_ast
  dba: special_variable
  dic: STD::P6
  re: !!perl/hash:RE_sequence
    zyg:
    - !!perl/hash:RE_method
      i: 0
      name: sym
      rest: ''
      sym: $.
    - !!perl/hash:RE_meta
      text: '::'
    - !!perl/hash:RE_assertion
      assert: '?'
      re: !!perl/hash:RE_method_re
        name: before
        nobind: 1
        re: &100 !!perl/hash:RE_any
          altname: special_variable__S_133DollarDot_0
          dba: special_variable
          dic: STD::P6
          zyg:
          - !!perl/hash:RE_meta
            alt: special_variable__S_133DollarDot_0 0
            min: 1
            text: \s
          - !!perl/hash:RE_string
            alt: special_variable__S_133DollarDot_0 1
            i: 0
            text: ','
          - !!perl/hash:RE_method
            alt: special_variable__S_133DollarDot_0 2
            name: terminator
            rest: ''
    - !!perl/hash:RE_method
      name: obs
      rest: 1
special_variable__S_133DollarDot_0: *100
special_variable__S_134DollarQuestion: !!perl/hash:RE_ast
  dba: special_variable
  dic: STD::P6
  re: !!perl/hash:RE_sequence
    zyg:
    - !!perl/hash:RE_method
      i: 0
      name: sym
      rest: ''
      sym: $?
    - !!perl/hash:RE_meta
      text: '::'
    - !!perl/hash:RE_assertion
      assert: '?'
      re: !!perl/hash:RE_method_re
        name: before
        nobind: 1
        re: &101 !!perl/hash:RE_any
          altname: special_variable__S_134DollarQuestion_0
          dba: special_variable
          dic: STD::P6
          zyg:
          - !!perl/hash:RE_meta
            alt: special_variable__S_134DollarQuestion_0 0
            min: 1
            text: \s
          - !!perl/hash:RE_string
            alt: special_variable__S_134DollarQuestion_0 1
            i: 0
            text: ','
          - !!perl/hash:RE_method
            alt: special_variable__S_134DollarQuestion_0 2
            name: terminator
            rest: ''
    - !!perl/hash:RE_method
      name: obs
      rest: 1
special_variable__S_134DollarQuestion_0: *101
statement: !!perl/hash:RE_ast
  dba: statement
  dic: STD::P6
  re: !!perl/hash:RE_sequence
    zyg:
    - !!perl/hash:RE_assertion
      assert: '!'
      re: !!perl/hash:RE_method_re
        name: before
        nobind: 1
        re: !!perl/hash:RE_cclass
          i: 0
          text: '[\)\]\}]'
    - !!perl/hash:RE_assertion
      assert: '!'
      re: !!perl/hash:RE_method
        name: stopper
        rest: ''
    - !!perl/hash:RE_assertion
      assert: '!'
      re: !!perl/hash:RE_assertion
        assert: '!'
        nobind: 1
        re: !!perl/hash:RE_block
          nobind: 1
    - !!perl/hash:RE_bracket
      re: &102 !!perl/hash:RE_any
        altname: statement_0
        dba: statement end
        dic: STD::P6
        zyg:
        - !!perl/hash:RE_sequence
          alt: statement_0 0
          zyg:
          - !!perl/hash:RE_method
            name: label
            rest: ''
          - !!perl/hash:RE_method
            name: statement
            rest: ''
        - !!perl/hash:RE_method
          alt: statement_0 1
          name: statement_control
          rest: ''
        - !!perl/hash:RE_sequence
          alt: statement_0 2
          zyg:
          - !!perl/hash:RE_method
            name: EXPR
            rest: ''
          - !!perl/hash:RE_bracket
            re: !!perl/hash:RE_first
              zyg:
              - !!perl/hash:RE_assertion
                assert: '?'
                re: !!perl/hash:RE_block
                  nobind: 1
              - !!perl/hash:RE_sequence
                zyg:
                - !!perl/hash:RE_method
                  name: ws
                  rest: ''
                - !!perl/hash:RE_quantified_atom
                  atom: !!perl/hash:RE_bracket
                    re: &103 !!perl/hash:RE_any
                      altname: statement_1
                      dba: statement modifier loop
                      dic: STD::P6
                      zyg:
                      - !!perl/hash:RE_sequence
                        alt: statement_1 0
                        zyg:
                        - !!perl/hash:RE_method
                          name: statement_mod_loop
                          rest: ''
                        - !!perl/hash:RE_block {}
                      - !!perl/hash:RE_sequence
                        alt: statement_1 1
                        zyg:
                        - !!perl/hash:RE_method
                          name: statement_mod_cond
                          rest: ''
                        - !!perl/hash:RE_bracket
                          re: !!perl/hash:RE_first
                            zyg:
                            - !!perl/hash:RE_assertion
                              assert: '?'
                              re: !!perl/hash:RE_block
                                nobind: 1
                            - !!perl/hash:RE_sequence
                              zyg:
                              - !!perl/hash:RE_method
                                name: ws
                                rest: ''
                              - !!perl/hash:RE_quantified_atom
                                atom: !!perl/hash:RE_method
                                  name: statement_mod_loop
                                  rest: ''
                                quant:
                                - '?'
                  quant:
                  - '?'
        - !!perl/hash:RE_assertion
          alt: statement_0 3
          assert: '?'
          re: !!perl/hash:RE_method_re
            name: before
            nobind: 1
            re: !!perl/hash:RE_string
              i: 0
              text: ;
        - !!perl/hash:RE_assertion
          alt: statement_0 4
          assert: '?'
          re: !!perl/hash:RE_method_re
            name: before
            nobind: 1
            re: !!perl/hash:RE_method
              name: stopper
              rest: ''
        - !!perl/hash:RE_sequence
          alt: statement_0 5
          zyg:
          - !!perl/hash:RE_block {}
          - !!perl/hash:RE_method
            name: panic
            rest: 1
    - !!perl/hash:RE_quantified_atom
      atom: !!perl/hash:RE_bracket
        re: !!perl/hash:RE_sequence
          zyg:
          - !!perl/hash:RE_assertion
            assert: '?'
            re: !!perl/hash:RE_block
              nobind: 1
          - !!perl/hash:RE_quantified_atom
            atom: !!perl/hash:RE_meta
              min: 1
              text: \h
            quant:
            - '*'
          - !!perl/hash:RE_assertion
            assert: '!'
            re: !!perl/hash:RE_method_re
              name: before
              nobind: 1
              re: &104 !!perl/hash:RE_any
                altname: statement_2
                dba: statement
                dic: STD::P6
                zyg:
                - !!perl/hash:RE_string
                  alt: statement_2 0
                  i: 0
                  text: ;
                - !!perl/hash:RE_string
                  alt: statement_2 1
                  i: 0
                  text: )
                - !!perl/hash:RE_string
                  alt: statement_2 2
                  i: 0
                  text: ']'
                - !!perl/hash:RE_string
                  alt: statement_2 3
                  i: 0
                  text: '}'
          - !!perl/hash:RE_assertion
            assert: '!'
            re: !!perl/hash:RE_method
              name: infixstopper
              rest: ''
          - !!perl/hash:RE_block {}
          - !!perl/hash:RE_method
            name: panic
            rest: 1
      quant:
      - '?'
statement_0: *102
statement_1: *103
statement_2: *104
statement_control__S_000need: !!perl/hash:RE_ast
  dba: statement_control
  dic: STD::P6
  re: !!perl/hash:RE_sequence
    zyg:
    - !!perl/hash:RE_method
      endsym: spacey
      i: 0
      name: sym
      rest: ''
      sym: need
    - !!perl/hash:RE_method
      name: spacey
      rest: ''
    - !!perl/hash:RE_method
      name: ws
      rest: ''
    - !!perl/hash:RE_quantified_atom
      atom: !!perl/hash:RE_bracket
        re: &105 !!perl/hash:RE_any
          altname: statement_control__S_000need_0
          dba: statement_control
          dic: STD::P6
          zyg:
          - !!perl/hash:RE_sequence
            alt: statement_control__S_000need_0 0
            zyg:
            - !!perl/hash:RE_method
              name: version
              rest: ''
            - !!perl/hash:RE_method
              name: ws
              rest: ''
          - !!perl/hash:RE_sequence
            alt: statement_control__S_000need_0 1
            zyg:
            - !!perl/hash:RE_method
              name: module_name
              rest: ''
            - !!perl/hash:RE_method
              name: ws
              rest: ''
            - !!perl/hash:RE_block {}
      quant:
      - '**'
      - ':'
      - !!perl/hash:RE_string
        a: 0
        dba: statement_control
        dic: STD::P6
        i: 0
        i_needed: 1
        r: 1
        s: 1
        text: ','
    - !!perl/hash:RE_method
      name: ws
      rest: ''
statement_control__S_000need_0: *105
statement_control__S_001import: !!perl/hash:RE_ast
  dba: statement_control
  dic: STD::P6
  re: !!perl/hash:RE_sequence
    zyg:
    - !!perl/hash:RE_method
      endsym: spacey
      i: 0
      name: sym
      rest: ''
      sym: import
    - !!perl/hash:RE_method
      name: spacey
      rest: ''
    - !!perl/hash:RE_method
      name: ws
      rest: ''
    - !!perl/hash:RE_method
      name: term
      rest: ''
    - !!perl/hash:RE_bracket
      re: !!perl/hash:RE_first
        zyg:
        - !!perl/hash:RE_sequence
          zyg:
          - !!perl/hash:RE_method
            name: spacey
            rest: ''
          - !!perl/hash:RE_method
            name: arglist
            rest: ''
          - !!perl/hash:RE_block {}
        - !!perl/hash:RE_block {}
    - !!perl/hash:RE_method
      name: ws
      rest: ''
statement_control__S_002use: !!perl/hash:RE_ast
  dba: statement_control
  dic: STD::P6
  re: !!perl/hash:RE_sequence
    zyg:
    - !!perl/hash:RE_method
      endsym: spacey
      i: 0
      name: sym
      rest: ''
      sym: use
    - !!perl/hash:RE_method
      name: spacey
      rest: ''
    - !!perl/hash:RE_method
      name: ws
      rest: ''
    - !!perl/hash:RE_bracket
      re: &106 !!perl/hash:RE_any
        altname: statement_control__S_002use_0
        dba: statement_control
        dic: STD::P6
        zyg:
        - !!perl/hash:RE_method
          alt: statement_control__S_002use_0 0
          name: version
          rest: ''
        - !!perl/hash:RE_sequence
          alt: statement_control__S_002use_0 1
          zyg:
          - !!perl/hash:RE_method
            name: module_name
            rest: ''
          - !!perl/hash:RE_block {}
          - !!perl/hash:RE_bracket
            re: !!perl/hash:RE_first
              zyg:
              - !!perl/hash:RE_sequence
                zyg:
                - !!perl/hash:RE_method
                  name: spacey
                  rest: ''
                - !!perl/hash:RE_method
                  name: arglist
                  rest: ''
                - !!perl/hash:RE_block {}
              - !!perl/hash:RE_block {}
    - !!perl/hash:RE_method
      name: ws
      rest: ''
    - !!perl/hash:RE_method
      name: explain_mystery
      rest: ''
statement_control__S_002use_0: *106
statement_control__S_003no: !!perl/hash:RE_ast
  dba: statement_control
  dic: STD::P6
  re: !!perl/hash:RE_sequence
    zyg:
    - !!perl/hash:RE_method
      endsym: spacey
      i: 0
      name: sym
      rest: ''
      sym: no
    - !!perl/hash:RE_method
      name: spacey
      rest: ''
    - !!perl/hash:RE_method
      name: ws
      rest: ''
    - !!perl/hash:RE_method
      name: module_name
      rest: ''
    - !!perl/hash:RE_quantified_atom
      atom: !!perl/hash:RE_bracket
        re: !!perl/hash:RE_sequence
          zyg:
          - !!perl/hash:RE_method
            name: spacey
            rest: ''
          - !!perl/hash:RE_method
            name: arglist
            rest: ''
      quant:
      - '?'
    - !!perl/hash:RE_method
      name: ws
      rest: ''
    - !!perl/hash:RE_method
      name: explain_mystery
      rest: ''
statement_control__S_004if: !!perl/hash:RE_ast
  dba: statement_control
  dic: STD::P6
  re: !!perl/hash:RE_sequence
    zyg:
    - !!perl/hash:RE_method
      endsym: spacey
      i: 0
      name: sym
      rest: ''
      sym: if
    - !!perl/hash:RE_method
      name: spacey
      rest: ''
    - !!perl/hash:RE_method
      name: ws
      rest: ''
    - !!perl/hash:RE_method
      name: xblock
      rest: ''
    - !!perl/hash:RE_method
      name: ws
      rest: ''
    - !!perl/hash:RE_quantified_atom
      atom: !!perl/hash:RE_bracket
        re: !!perl/hash:RE_sequence
          zyg:
          - !!perl/hash:RE_method
            name: ws
            rest: ''
          - !!perl/hash:RE_bracket
            re: &107 !!perl/hash:RE_any
              altname: statement_control__S_004if_0
              dba: statement_control
              dic: STD::P6
              zyg:
              - !!perl/hash:RE_sequence
                alt: statement_control__S_004if_0 0
                zyg:
                - !!perl/hash:RE_string
                  i: 0
                  text: else
                - !!perl/hash:RE_quantified_atom
                  atom: !!perl/hash:RE_meta
                    min: 1
                    text: \h
                  quant:
                  - '*'
                - !!perl/hash:RE_string
                  i: 0
                  text: if
                - !!perl/hash:RE_method
                  name: ws
                  rest: ''
                - !!perl/hash:RE_method
                  name: sorry
                  rest: 1
                - !!perl/hash:RE_method
                  name: ws
                  rest: ''
              - !!perl/hash:RE_sequence
                alt: statement_control__S_004if_0 1
                zyg:
                - !!perl/hash:RE_string
                  i: 0
                  text: elsif
                - !!perl/hash:RE_assertion
                  assert: '?'
                  re: !!perl/hash:RE_method
                    name: spacey
                    rest: ''
                - !!perl/hash:RE_method
                  name: ws
                  rest: ''
                - !!perl/hash:RE_bindnamed
                  atom: !!perl/hash:RE_method
                    name: xblock
                    rest: ''
                - !!perl/hash:RE_method
                  name: ws
                  rest: ''
      quant:
      - '*'
    - !!perl/hash:RE_method
      name: ws
      rest: ''
    - !!perl/hash:RE_quantified_atom
      atom: !!perl/hash:RE_bracket
        re: !!perl/hash:RE_sequence
          zyg:
          - !!perl/hash:RE_method
            name: ws
            rest: ''
          - !!perl/hash:RE_string
            i: 0
            text: else
          - !!perl/hash:RE_assertion
            assert: '?'
            re: !!perl/hash:RE_method
              name: spacey
              rest: ''
          - !!perl/hash:RE_method
            name: ws
            rest: ''
          - !!perl/hash:RE_bindnamed
            atom: !!perl/hash:RE_method
              name: pblock
              rest: ''
          - !!perl/hash:RE_method
            name: ws
            rest: ''
      quant:
      - '?'
    - !!perl/hash:RE_method
      name: ws
      rest: ''
statement_control__S_004if_0: *107
statement_control__S_005unless: !!perl/hash:RE_ast
  dba: statement_control
  dic: STD::P6
  re: !!perl/hash:RE_sequence
    zyg:
    - !!perl/hash:RE_method
      endsym: spacey
      i: 0
      name: sym
      rest: ''
      sym: unless
    - !!perl/hash:RE_method
      name: spacey
      rest: ''
    - !!perl/hash:RE_method
      name: ws
      rest: ''
    - !!perl/hash:RE_method
      name: xblock
      rest: ''
    - !!perl/hash:RE_method
      name: ws
      rest: ''
    - !!perl/hash:RE_bracket
      re: !!perl/hash:RE_first
        zyg:
        - !!perl/hash:RE_assertion
          assert: '!'
          re: !!perl/hash:RE_method_re
            name: before
            nobind: 1
            re: !!perl/hash:RE_sequence
              zyg:
              - !!perl/hash:RE_method
                name: ws
                rest: ''
              - !!perl/hash:RE_string
                i: 0
                text: else
        - !!perl/hash:RE_sequence
          zyg:
          - !!perl/hash:RE_method
            name: panic
            rest: 1
          - !!perl/hash:RE_method
            name: ws
            rest: ''
statement_control__S_006while: !!perl/hash:RE_ast
  dba: statement_control
  dic: STD::P6
  re: !!perl/hash:RE_sequence
    zyg:
    - !!perl/hash:RE_method
      endsym: spacey
      i: 0
      name: sym
      rest: ''
      sym: while
    - !!perl/hash:RE_method
      name: spacey
      rest: ''
    - !!perl/hash:RE_method
      name: ws
      rest: ''
    - !!perl/hash:RE_quantified_atom
      atom: !!perl/hash:RE_bracket
        re: !!perl/hash:RE_sequence
          zyg:
          - !!perl/hash:RE_method
            name: ws
            rest: ''
          - !!perl/hash:RE_assertion
            assert: '?'
            re: !!perl/hash:RE_method_re
              name: before
              nobind: 1
              re: !!perl/hash:RE_sequence
                zyg:
                - !!perl/hash:RE_method
                  name: ws
                  rest: ''
                - !!perl/hash:RE_string
                  i: 0
                  text: (
                - !!perl/hash:RE_method
                  name: ws
                  rest: ''
                - !!perl/hash:RE_quantified_atom
                  atom: !!perl/hash:RE_bracket
                    re: !!perl/hash:RE_sequence
                      zyg:
                      - !!perl/hash:RE_quantified_atom
                        atom: !!perl/hash:RE_string
                          i: 0
                          text: my
                        quant:
                        - '?'
                      - !!perl/hash:RE_method
                        name: ws
                        rest: ''
                      - !!perl/hash:RE_string
                        i: 0
                        text: $
                      - !!perl/hash:RE_quantified_atom
                        atom: !!perl/hash:RE_meta
                          min: 1
                          text: \w
                        quant:
                        - +
                      - !!perl/hash:RE_method
                        name: ws
                        rest: ''
                      - !!perl/hash:RE_string
                        i: 0
                        text: =
                  quant:
                  - '?'
                - !!perl/hash:RE_method
                  name: ws
                  rest: ''
                - !!perl/hash:RE_string
                  i: 0
                  text: <
                - !!perl/hash:RE_method
                  name: ws
                  rest: ''
                - !!perl/hash:RE_quantified_atom
                  atom: !!perl/hash:RE_string
                    i: 0
                    text: $
                  quant:
                  - '?'
                - !!perl/hash:RE_quantified_atom
                  atom: !!perl/hash:RE_meta
                    min: 1
                    text: \w
                  quant:
                  - +
                - !!perl/hash:RE_method
                  name: ws
                  rest: ''
                - !!perl/hash:RE_string
                  i: 0
                  text: '>'
                - !!perl/hash:RE_method
                  name: ws
                  rest: ''
                - !!perl/hash:RE_string
                  i: 0
                  text: )
          - !!perl/hash:RE_method
            name: panic
            rest: 1
          - !!perl/hash:RE_method
            name: ws
            rest: ''
      quant:
      - '?'
    - !!perl/hash:RE_method
      name: ws
      rest: ''
    - !!perl/hash:RE_method
      name: xblock
      rest: ''
    - !!perl/hash:RE_method
      name: ws
      rest: ''
statement_control__S_007until: !!perl/hash:RE_ast
  dba: statement_control
  dic: STD::P6
  re: !!perl/hash:RE_sequence
    zyg:
    - !!perl/hash:RE_method
      endsym: spacey
      i: 0
      name: sym
      rest: ''
      sym: until
    - !!perl/hash:RE_method
      name: spacey
      rest: ''
    - !!perl/hash:RE_method
      name: ws
      rest: ''
    - !!perl/hash:RE_method
      name: xblock
      rest: ''
    - !!perl/hash:RE_method
      name: ws
      rest: ''
statement_control__S_008repeat: !!perl/hash:RE_ast
  dba: statement_control
  dic: STD::P6
  re: !!perl/hash:RE_sequence
    zyg:
    - !!perl/hash:RE_method
      endsym: spacey
      i: 0
      name: sym
      rest: ''
      sym: repeat
    - !!perl/hash:RE_method
      name: spacey
      rest: ''
    - !!perl/hash:RE_method
      name: ws
      rest: ''
    - !!perl/hash:RE_bracket
      re: &108 !!perl/hash:RE_any
        altname: statement_control__S_008repeat_0
        dba: statement_control
        dic: STD::P6
        zyg:
        - !!perl/hash:RE_sequence
          alt: statement_control__S_008repeat_0 0
          zyg:
          - !!perl/hash:RE_bindnamed
            atom: !!perl/hash:RE_bracket
              re: &109 !!perl/hash:RE_any
                altname: statement_control__S_008repeat_1
                dba: statement_control
                dic: STD::P6
                zyg:
                - !!perl/hash:RE_string
                  alt: statement_control__S_008repeat_1 0
                  i: 0
                  text: while
                - !!perl/hash:RE_string
                  alt: statement_control__S_008repeat_1 1
                  i: 0
                  text: until
          - !!perl/hash:RE_method
            name: spacey
            rest: ''
          - !!perl/hash:RE_method
            name: ws
            rest: ''
          - !!perl/hash:RE_method
            name: xblock
            rest: ''
          - !!perl/hash:RE_method
            name: ws
            rest: ''
        - !!perl/hash:RE_sequence
          alt: statement_control__S_008repeat_0 1
          zyg:
          - !!perl/hash:RE_method
            name: pblock
            rest: ''
          - !!perl/hash:RE_method
            name: ws
            rest: ''
          - !!perl/hash:RE_bindnamed
            atom: !!perl/hash:RE_bracket
              re: &110 !!perl/hash:RE_any
                altname: statement_control__S_008repeat_2
                dba: statement_control
                dic: STD::P6
                zyg:
                - !!perl/hash:RE_string
                  alt: statement_control__S_008repeat_2 0
                  i: 0
                  text: while
                - !!perl/hash:RE_string
                  alt: statement_control__S_008repeat_2 1
                  i: 0
                  text: until
          - !!perl/hash:RE_bracket
            re: !!perl/hash:RE_first
              zyg:
              - !!perl/hash:RE_method
                name: spacey
                rest: ''
              - !!perl/hash:RE_method
                name: panic
                rest: 1
          - !!perl/hash:RE_method
            name: ws
            rest: ''
          - !!perl/hash:RE_method
            name: EXPR
            rest: ''
          - !!perl/hash:RE_method
            name: ws
            rest: ''
statement_control__S_008repeat_0: *108
statement_control__S_008repeat_1: *109
statement_control__S_008repeat_2: *110
statement_control__S_009loop: !!perl/hash:RE_ast
  dba: statement_control
  dic: STD::P6
  re: !!perl/hash:RE_sequence
    zyg:
    - !!perl/hash:RE_method
      endsym: spacey
      i: 0
      name: sym
      rest: ''
      sym: loop
    - !!perl/hash:RE_method
      name: spacey
      rest: ''
    - !!perl/hash:RE_method
      name: ws
      rest: ''
    - !!perl/hash:RE_bindnamed
      atom: !!perl/hash:RE_quantified_atom
        atom: !!perl/hash:RE_paren
          re: !!perl/hash:RE_sequence
            zyg:
            - !!perl/hash:RE_string
              i: 0
              text: (
            - !!perl/hash:RE_bracket
              re: !!perl/hash:RE_first
                zyg:
                - !!perl/hash:RE_sequence
                  zyg:
                  - !!perl/hash:RE_method
                    name: ws
                    rest: ''
                  - !!perl/hash:RE_quantified_atom
                    atom: !!perl/hash:RE_bindnamed
                      atom: !!perl/hash:RE_method
                        name: EXPR
                        rest: ''
                    quant:
                    - '?'
                  - !!perl/hash:RE_method
                    name: ws
                    rest: ''
                  - !!perl/hash:RE_string
                    i: 0
                    text: ;
                  - !!perl/hash:RE_method
                    name: ws
                    rest: ''
                  - !!perl/hash:RE_quantified_atom
                    atom: !!perl/hash:RE_bindnamed
                      atom: !!perl/hash:RE_method
                        name: EXPR
                        rest: ''
                    quant:
                    - '?'
                  - !!perl/hash:RE_method
                    name: ws
                    rest: ''
                  - !!perl/hash:RE_string
                    i: 0
                    text: ;
                  - !!perl/hash:RE_method
                    name: ws
                    rest: ''
                  - !!perl/hash:RE_quantified_atom
                    atom: !!perl/hash:RE_bindnamed
                      atom: !!perl/hash:RE_method
                        name: EXPR
                        rest: ''
                    quant:
                    - '?'
                  - !!perl/hash:RE_method
                    name: ws
                    rest: ''
                  - !!perl/hash:RE_string
                    i: 0
                    text: )
                - !!perl/hash:RE_method
                  name: panic
                  rest: 1
            - !!perl/hash:RE_quantified_atom
              atom: !!perl/hash:RE_bracket
                re: !!perl/hash:RE_sequence
                  zyg:
                  - !!perl/hash:RE_assertion
                    assert: '?'
                    re: !!perl/hash:RE_method_re
                      name: before
                      nobind: 1
                      re: !!perl/hash:RE_string
                        i: 0
                        text: '{'
                  - !!perl/hash:RE_method
                    name: sorry
                    rest: 1
              quant:
              - '?'
        quant:
        - '?'
    - !!perl/hash:RE_method
      name: ws
      rest: ''
    - !!perl/hash:RE_method
      name: block
      rest: ''
statement_control__S_010for: !!perl/hash:RE_ast
  dba: statement_control
  dic: STD::P6
  re: !!perl/hash:RE_sequence
    zyg:
    - !!perl/hash:RE_method
      endsym: spacey
      i: 0
      name: sym
      rest: ''
      sym: for
    - !!perl/hash:RE_method
      name: spacey
      rest: ''
    - !!perl/hash:RE_method
      name: ws
      rest: ''
    - !!perl/hash:RE_quantified_atom
      atom: !!perl/hash:RE_bracket
        re: !!perl/hash:RE_sequence
          zyg:
          - !!perl/hash:RE_method
            name: ws
            rest: ''
          - !!perl/hash:RE_assertion
            assert: '?'
            re: !!perl/hash:RE_method_re
              name: before
              nobind: 1
              re: !!perl/hash:RE_sequence
                zyg:
                - !!perl/hash:RE_method
                  name: ws
                  rest: ''
                - !!perl/hash:RE_quantified_atom
                  atom: !!perl/hash:RE_string
                    i: 0
                    text: my
                  quant:
                  - '?'
                - !!perl/hash:RE_method
                  name: ws
                  rest: ''
                - !!perl/hash:RE_string
                  i: 0
                  text: $
                - !!perl/hash:RE_quantified_atom
                  atom: !!perl/hash:RE_meta
                    min: 1
                    text: \w
                  quant:
                  - +
                - !!perl/hash:RE_method
                  name: ws
                  rest: ''
                - !!perl/hash:RE_string
                  i: 0
                  text: (
                - !!perl/hash:RE_method
                  name: ws
                  rest: ''
          - !!perl/hash:RE_method
            name: panic
            rest: 1
          - !!perl/hash:RE_method
            name: ws
            rest: ''
      quant:
      - '?'
    - !!perl/hash:RE_method
      name: ws
      rest: ''
    - !!perl/hash:RE_quantified_atom
      atom: !!perl/hash:RE_bracket
        re: !!perl/hash:RE_sequence
          zyg:
          - !!perl/hash:RE_method
            name: ws
            rest: ''
          - !!perl/hash:RE_assertion
            assert: '?'
            re: !!perl/hash:RE_method_re
              name: before
              nobind: 1
              re: !!perl/hash:RE_sequence
                zyg:
                - !!perl/hash:RE_method
                  name: ws
                  rest: ''
                - !!perl/hash:RE_string
                  i: 0
                  text: (
                - !!perl/hash:RE_method
                  name: ws
                  rest: ''
                - !!perl/hash:RE_quantified_atom
                  atom: !!perl/hash:RE_method
                    name: EXPR
                    rest: ''
                  quant:
                  - '?'
                - !!perl/hash:RE_method
                  name: ws
                  rest: ''
                - !!perl/hash:RE_string
                  i: 0
                  text: ;
                - !!perl/hash:RE_method
                  name: ws
                  rest: ''
                - !!perl/hash:RE_quantified_atom
                  atom: !!perl/hash:RE_method
                    name: EXPR
                    rest: ''
                  quant:
                  - '?'
                - !!perl/hash:RE_method
                  name: ws
                  rest: ''
                - !!perl/hash:RE_string
                  i: 0
                  text: ;
                - !!perl/hash:RE_method
                  name: ws
                  rest: ''
                - !!perl/hash:RE_quantified_atom
                  atom: !!perl/hash:RE_method
                    name: EXPR
                    rest: ''
                  quant:
                  - '?'
                - !!perl/hash:RE_method
                  name: ws
                  rest: ''
                - !!perl/hash:RE_string
                  i: 0
                  text: )
                - !!perl/hash:RE_method
                  name: ws
                  rest: ''
          - !!perl/hash:RE_method
            name: obs
            rest: 1
          - !!perl/hash:RE_method
            name: ws
            rest: ''
      quant:
      - '?'
    - !!perl/hash:RE_method
      name: ws
      rest: ''
    - !!perl/hash:RE_method
      name: xblock
      rest: ''
    - !!perl/hash:RE_method
      name: ws
      rest: ''
statement_control__S_011foreach: !!perl/hash:RE_ast
  dba: statement_control
  dic: STD::P6
  re: !!perl/hash:RE_sequence
    zyg:
    - !!perl/hash:RE_method
      endsym: spacey
      i: 0
      name: sym
      rest: ''
      sym: foreach
    - !!perl/hash:RE_method
      name: spacey
      rest: ''
    - !!perl/hash:RE_method
      name: obs
      rest: 1
statement_control__S_012given: !!perl/hash:RE_ast
  dba: statement_control
  dic: STD::P6
  re: !!perl/hash:RE_sequence
    zyg:
    - !!perl/hash:RE_method
      endsym: spacey
      i: 0
      name: sym
      rest: ''
      sym: given
    - !!perl/hash:RE_method
      name: spacey
      rest: ''
    - !!perl/hash:RE_method
      name: ws
      rest: ''
    - !!perl/hash:RE_method
      name: xblock
      rest: ''
    - !!perl/hash:RE_method
      name: ws
      rest: ''
statement_control__S_013when: !!perl/hash:RE_ast
  dba: statement_control
  dic: STD::P6
  re: !!perl/hash:RE_sequence
    zyg:
    - !!perl/hash:RE_method
      endsym: spacey
      i: 0
      name: sym
      rest: ''
      sym: when
    - !!perl/hash:RE_method
      name: spacey
      rest: ''
    - !!perl/hash:RE_method
      name: ws
      rest: ''
    - !!perl/hash:RE_assertion
      assert: '?'
      re: !!perl/hash:RE_method
        name: dumbsmart
        rest: ''
    - !!perl/hash:RE_method
      name: xblock
      rest: ''
    - !!perl/hash:RE_method
      name: ws
      rest: ''
statement_control__S_014default: !!perl/hash:RE_ast
  dba: statement_control
  dic: STD::P6
  re: !!perl/hash:RE_sequence
    zyg:
    - !!perl/hash:RE_method
      endsym: spacey
      i: 0
      name: sym
      rest: ''
      sym: default
    - !!perl/hash:RE_method
      name: spacey
      rest: ''
    - !!perl/hash:RE_method
      name: ws
      rest: ''
    - !!perl/hash:RE_method
      name: block
      rest: ''
    - !!perl/hash:RE_method
      name: ws
      rest: ''
statement_control__S_029CATCH: !!perl/hash:RE_ast
  dba: statement_control
  dic: STD::P6
  re: !!perl/hash:RE_sequence
    zyg:
    - !!perl/hash:RE_method
      endsym: spacey
      i: 0
      name: sym
      rest: ''
      sym: CATCH
    - !!perl/hash:RE_method
      name: spacey
      rest: ''
    - !!perl/hash:RE_method
      name: ws
      rest: ''
    - !!perl/hash:RE_method
      name: block
      rest: ''
    - !!perl/hash:RE_method
      name: ws
      rest: ''
statement_control__S_030CONTROL: !!perl/hash:RE_ast
  dba: statement_control
  dic: STD::P6
  re: !!perl/hash:RE_sequence
    zyg:
    - !!perl/hash:RE_method
      endsym: spacey
      i: 0
      name: sym
      rest: ''
      sym: CONTROL
    - !!perl/hash:RE_method
      name: spacey
      rest: ''
    - !!perl/hash:RE_method
      name: ws
      rest: ''
    - !!perl/hash:RE_method
      name: block
      rest: ''
    - !!perl/hash:RE_method
      name: ws
      rest: ''
statement_control__S_031TEMP: !!perl/hash:RE_ast
  dba: statement_control
  dic: STD::P6
  re: !!perl/hash:RE_sequence
    zyg:
    - !!perl/hash:RE_method
      endsym: spacey
      i: 0
      name: sym
      rest: ''
      sym: TEMP
    - !!perl/hash:RE_method
      name: spacey
      rest: ''
    - !!perl/hash:RE_method
      name: ws
      rest: ''
    - !!perl/hash:RE_method
      name: block
      rest: ''
    - !!perl/hash:RE_method
      name: ws
      rest: ''
statement_mod_cond__S_032if: !!perl/hash:RE_ast
  dba: statement_mod_cond
  dic: STD::P6
  re: !!perl/hash:RE_sequence
    zyg:
    - !!perl/hash:RE_method
      endsym: nofun
      i: 0
      name: sym
      rest: ''
      sym: if
    - !!perl/hash:RE_method
      name: nofun
      rest: ''
    - !!perl/hash:RE_method
      name: ws
      rest: ''
    - !!perl/hash:RE_method
      name: modifier_expr
      rest: ''
    - !!perl/hash:RE_method
      name: ws
      rest: ''
statement_mod_cond__S_033unless: !!perl/hash:RE_ast
  dba: statement_mod_cond
  dic: STD::P6
  re: !!perl/hash:RE_sequence
    zyg:
    - !!perl/hash:RE_method
      endsym: nofun
      i: 0
      name: sym
      rest: ''
      sym: unless
    - !!perl/hash:RE_method
      name: nofun
      rest: ''
    - !!perl/hash:RE_method
      name: ws
      rest: ''
    - !!perl/hash:RE_method
      name: modifier_expr
      rest: ''
    - !!perl/hash:RE_method
      name: ws
      rest: ''
statement_mod_cond__S_034when: !!perl/hash:RE_ast
  dba: statement_mod_cond
  dic: STD::P6
  re: !!perl/hash:RE_sequence
    zyg:
    - !!perl/hash:RE_method
      endsym: nofun
      i: 0
      name: sym
      rest: ''
      sym: when
    - !!perl/hash:RE_method
      name: nofun
      rest: ''
    - !!perl/hash:RE_method
      name: ws
      rest: ''
    - !!perl/hash:RE_assertion
      assert: '?'
      re: !!perl/hash:RE_method
        name: dumbsmart
        rest: ''
    - !!perl/hash:RE_method
      name: modifier_expr
      rest: ''
    - !!perl/hash:RE_method
      name: ws
      rest: ''
statement_mod_loop__S_035while: !!perl/hash:RE_ast
  dba: statement_mod_loop
  dic: STD::P6
  re: !!perl/hash:RE_sequence
    zyg:
    - !!perl/hash:RE_method
      endsym: nofun
      i: 0
      name: sym
      rest: ''
      sym: while
    - !!perl/hash:RE_method
      name: nofun
      rest: ''
    - !!perl/hash:RE_method
      name: ws
      rest: ''
    - !!perl/hash:RE_method
      name: modifier_expr
      rest: ''
    - !!perl/hash:RE_method
      name: ws
      rest: ''
statement_mod_loop__S_036until: !!perl/hash:RE_ast
  dba: statement_mod_loop
  dic: STD::P6
  re: !!perl/hash:RE_sequence
    zyg:
    - !!perl/hash:RE_method
      endsym: nofun
      i: 0
      name: sym
      rest: ''
      sym: until
    - !!perl/hash:RE_method
      name: nofun
      rest: ''
    - !!perl/hash:RE_method
      name: ws
      rest: ''
    - !!perl/hash:RE_method
      name: modifier_expr
      rest: ''
    - !!perl/hash:RE_method
      name: ws
      rest: ''
statement_mod_loop__S_037for: !!perl/hash:RE_ast
  dba: statement_mod_loop
  dic: STD::P6
  re: !!perl/hash:RE_sequence
    zyg:
    - !!perl/hash:RE_method
      endsym: nofun
      i: 0
      name: sym
      rest: ''
      sym: for
    - !!perl/hash:RE_method
      name: nofun
      rest: ''
    - !!perl/hash:RE_method
      name: ws
      rest: ''
    - !!perl/hash:RE_method
      name: modifier_expr
      rest: ''
    - !!perl/hash:RE_method
      name: ws
      rest: ''
statement_mod_loop__S_038given: !!perl/hash:RE_ast
  dba: statement_mod_loop
  dic: STD::P6
  re: !!perl/hash:RE_sequence
    zyg:
    - !!perl/hash:RE_method
      endsym: nofun
      i: 0
      name: sym
      rest: ''
      sym: given
    - !!perl/hash:RE_method
      name: nofun
      rest: ''
    - !!perl/hash:RE_method
      name: ws
      rest: ''
    - !!perl/hash:RE_method
      name: modifier_expr
      rest: ''
    - !!perl/hash:RE_method
      name: ws
      rest: ''
statement_prefix__S_015BEGIN: !!perl/hash:RE_ast
  dba: statement_prefix
  dic: STD::P6
  re: !!perl/hash:RE_sequence
    zyg:
    - !!perl/hash:RE_method
      i: 0
      name: sym
      rest: ''
      sym: BEGIN
    - !!perl/hash:RE_method
      name: blast
      rest: ''
    - !!perl/hash:RE_method
      name: explain_mystery
      rest: ''
statement_prefix__S_016CHECK: !!perl/hash:RE_ast
  dba: statement_prefix
  dic: STD::P6
  re: !!perl/hash:RE_sequence
    zyg:
    - !!perl/hash:RE_method
      i: 0
      name: sym
      rest: ''
      sym: CHECK
    - !!perl/hash:RE_method
      name: blast
      rest: ''
statement_prefix__S_017INIT: !!perl/hash:RE_ast
  dba: statement_prefix
  dic: STD::P6
  re: !!perl/hash:RE_sequence
    zyg:
    - !!perl/hash:RE_method
      i: 0
      name: sym
      rest: ''
      sym: INIT
    - !!perl/hash:RE_method
      name: blast
      rest: ''
statement_prefix__S_018START: !!perl/hash:RE_ast
  dba: statement_prefix
  dic: STD::P6
  re: !!perl/hash:RE_sequence
    zyg:
    - !!perl/hash:RE_method
      i: 0
      name: sym
      rest: ''
      sym: START
    - !!perl/hash:RE_method
      name: blast
      rest: ''
statement_prefix__S_019ENTER: !!perl/hash:RE_ast
  dba: statement_prefix
  dic: STD::P6
  re: !!perl/hash:RE_sequence
    zyg:
    - !!perl/hash:RE_method
      i: 0
      name: sym
      rest: ''
      sym: ENTER
    - !!perl/hash:RE_method
      name: blast
      rest: ''
statement_prefix__S_020FIRST: !!perl/hash:RE_ast
  dba: statement_prefix
  dic: STD::P6
  re: !!perl/hash:RE_sequence
    zyg:
    - !!perl/hash:RE_method
      i: 0
      name: sym
      rest: ''
      sym: FIRST
    - !!perl/hash:RE_method
      name: blast
      rest: ''
statement_prefix__S_021END: !!perl/hash:RE_ast
  dba: statement_prefix
  dic: STD::P6
  re: !!perl/hash:RE_sequence
    zyg:
    - !!perl/hash:RE_method
      i: 0
      name: sym
      rest: ''
      sym: END
    - !!perl/hash:RE_method
      name: blast
      rest: ''
statement_prefix__S_022LEAVE: !!perl/hash:RE_ast
  dba: statement_prefix
  dic: STD::P6
  re: !!perl/hash:RE_sequence
    zyg:
    - !!perl/hash:RE_method
      i: 0
      name: sym
      rest: ''
      sym: LEAVE
    - !!perl/hash:RE_method
      name: blast
      rest: ''
statement_prefix__S_023KEEP: !!perl/hash:RE_ast
  dba: statement_prefix
  dic: STD::P6
  re: !!perl/hash:RE_sequence
    zyg:
    - !!perl/hash:RE_method
      i: 0
      name: sym
      rest: ''
      sym: KEEP
    - !!perl/hash:RE_method
      name: blast
      rest: ''
statement_prefix__S_024UNDO: !!perl/hash:RE_ast
  dba: statement_prefix
  dic: STD::P6
  re: !!perl/hash:RE_sequence
    zyg:
    - !!perl/hash:RE_method
      i: 0
      name: sym
      rest: ''
      sym: UNDO
    - !!perl/hash:RE_method
      name: blast
      rest: ''
statement_prefix__S_025NEXT: !!perl/hash:RE_ast
  dba: statement_prefix
  dic: STD::P6
  re: !!perl/hash:RE_sequence
    zyg:
    - !!perl/hash:RE_method
      i: 0
      name: sym
      rest: ''
      sym: NEXT
    - !!perl/hash:RE_method
      name: blast
      rest: ''
statement_prefix__S_026LAST: !!perl/hash:RE_ast
  dba: statement_prefix
  dic: STD::P6
  re: !!perl/hash:RE_sequence
    zyg:
    - !!perl/hash:RE_method
      i: 0
      name: sym
      rest: ''
      sym: LAST
    - !!perl/hash:RE_method
      name: blast
      rest: ''
statement_prefix__S_027PRE: !!perl/hash:RE_ast
  dba: statement_prefix
  dic: STD::P6
  re: !!perl/hash:RE_sequence
    zyg:
    - !!perl/hash:RE_method
      i: 0
      name: sym
      rest: ''
      sym: PRE
    - !!perl/hash:RE_method
      name: blast
      rest: ''
statement_prefix__S_028POST: !!perl/hash:RE_ast
  dba: statement_prefix
  dic: STD::P6
  re: !!perl/hash:RE_sequence
    zyg:
    - !!perl/hash:RE_method
      i: 0
      name: sym
      rest: ''
      sym: POST
    - !!perl/hash:RE_method
      name: blast
      rest: ''
statement_prefix__S_168sink: !!perl/hash:RE_ast
  dba: statement_prefix
  dic: STD::P6
  re: !!perl/hash:RE_sequence
    zyg:
    - !!perl/hash:RE_method
      i: 0
      name: sym
      rest: ''
      sym: sink
    - !!perl/hash:RE_method
      name: blast
      rest: ''
statement_prefix__S_169try: !!perl/hash:RE_ast
  dba: statement_prefix
  dic: STD::P6
  re: !!perl/hash:RE_sequence
    zyg:
    - !!perl/hash:RE_method
      i: 0
      name: sym
      rest: ''
      sym: try
    - !!perl/hash:RE_method
      name: blast
      rest: ''
statement_prefix__S_170quietly: !!perl/hash:RE_ast
  dba: statement_prefix
  dic: STD::P6
  re: !!perl/hash:RE_sequence
    zyg:
    - !!perl/hash:RE_method
      i: 0
      name: sym
      rest: ''
      sym: quietly
    - !!perl/hash:RE_method
      name: blast
      rest: ''
statement_prefix__S_171gather: !!perl/hash:RE_ast
  dba: statement_prefix
  dic: STD::P6
  re: !!perl/hash:RE_sequence
    zyg:
    - !!perl/hash:RE_method
      i: 0
      name: sym
      rest: ''
      sym: gather
    - !!perl/hash:RE_method
      name: blast
      rest: ''
statement_prefix__S_172contend: !!perl/hash:RE_ast
  dba: statement_prefix
  dic: STD::P6
  re: !!perl/hash:RE_sequence
    zyg:
    - !!perl/hash:RE_method
      i: 0
      name: sym
      rest: ''
      sym: contend
    - !!perl/hash:RE_method
      name: blast
      rest: ''
statement_prefix__S_173async: !!perl/hash:RE_ast
  dba: statement_prefix
  dic: STD::P6
  re: !!perl/hash:RE_sequence
    zyg:
    - !!perl/hash:RE_method
      i: 0
      name: sym
      rest: ''
      sym: async
    - !!perl/hash:RE_method
      name: blast
      rest: ''
statement_prefix__S_174maybe: !!perl/hash:RE_ast
  dba: statement_prefix
  dic: STD::P6
  re: !!perl/hash:RE_sequence
    zyg:
    - !!perl/hash:RE_method
      i: 0
      name: sym
      rest: ''
      sym: maybe
    - !!perl/hash:RE_method
      name: blast
      rest: ''
statement_prefix__S_175lazy: !!perl/hash:RE_ast
  dba: statement_prefix
  dic: STD::P6
  re: !!perl/hash:RE_sequence
    zyg:
    - !!perl/hash:RE_method
      i: 0
      name: sym
      rest: ''
      sym: lazy
    - !!perl/hash:RE_method
      name: blast
      rest: ''
statement_prefix__S_176do: !!perl/hash:RE_ast
  dba: statement_prefix
  dic: STD::P6
  re: !!perl/hash:RE_sequence
    zyg:
    - !!perl/hash:RE_method
      i: 0
      name: sym
      rest: ''
      sym: do
    - !!perl/hash:RE_method
      name: blast
      rest: ''
statement_prefix__S_177lift: !!perl/hash:RE_ast
  dba: statement_prefix
  dic: STD::P6
  re: !!perl/hash:RE_sequence
    zyg:
    - !!perl/hash:RE_method
      i: 0
      name: sym
      rest: ''
      sym: lift
    - !!perl/hash:RE_method
      name: blast
      rest: ''
statementlist: !!perl/hash:RE_ast
  dba: statement list
  dic: STD::P6
  re: !!perl/hash:RE_sequence
    zyg:
    - !!perl/hash:RE_method
      name: ws
      rest: ''
    - !!perl/hash:RE_bracket
      re: &111 !!perl/hash:RE_any
        altname: statementlist_0
        dba: statement list
        dic: STD::P6
        zyg:
        - !!perl/hash:RE_sequence
          alt: statementlist_0 0
          zyg:
          - !!perl/hash:RE_meta
            text: $
          - !!perl/hash:RE_method
            name: ws
            rest: ''
        - !!perl/hash:RE_assertion
          alt: statementlist_0 1
          assert: '?'
          re: !!perl/hash:RE_method_re
            name: before
            nobind: 1
            re: !!perl/hash:RE_sequence
              zyg:
              - !!perl/hash:RE_method
                name: ws
                rest: ''
              - !!perl/hash:RE_cclass
                i: 0
                text: '[\)\]\}]'
        - !!perl/hash:RE_sequence
          alt: statementlist_0 2
          zyg:
          - !!perl/hash:RE_quantified_atom
            atom: !!perl/hash:RE_bracket
              re: !!perl/hash:RE_sequence
                zyg:
                - !!perl/hash:RE_method
                  name: statement
                  rest: ''
                - !!perl/hash:RE_method
                  name: eat_terminator
                  rest: ''
                - !!perl/hash:RE_method
                  name: ws
                  rest: ''
            quant:
            - '*'
          - !!perl/hash:RE_method
            name: ws
            rest: ''
          - !!perl/hash:RE_block {}
statementlist_0: *111
strtonum__S_138rational: !!perl/hash:RE_ast
  dba: strtonum
  dic: STD::P6
  re: !!perl/hash:RE_sequence
    zyg:
    - !!perl/hash:RE_quantified_atom
      atom: !!perl/hash:RE_cclass
        i: 0
        text: '[+\-]'
      quant:
      - '?'
    - !!perl/hash:RE_bindnamed
      atom: !!perl/hash:RE_method
        name: integer
        rest: ''
    - !!perl/hash:RE_string
      i: 0
      text: /
    - !!perl/hash:RE_bindnamed
      atom: !!perl/hash:RE_method
        name: integer
        rest: ''
strtonum__S_139complex: !!perl/hash:RE_ast
  dba: strtonum
  dic: STD::P6
  re: !!perl/hash:RE_sequence
    zyg:
    - !!perl/hash:RE_quantified_atom
      atom: !!perl/hash:RE_bracket
        re: !!perl/hash:RE_sequence
          zyg:
          - !!perl/hash:RE_quantified_atom
            atom: !!perl/hash:RE_cclass
              i: 0
              text: '[+\-]'
            quant:
            - '?'
          - !!perl/hash:RE_bindnamed
            atom: !!perl/hash:RE_method
              name: number
              rest: ''
      quant:
      - '?'
    - !!perl/hash:RE_cclass
      i: 0
      text: '[+\-]'
    - !!perl/hash:RE_bindnamed
      atom: !!perl/hash:RE_method
        name: number
        rest: ''
    - !!perl/hash:RE_quantified_atom
      atom: !!perl/hash:RE_string
        i: 0
        text: \
      quant:
      - '?'
    - !!perl/hash:RE_string
      i: 0
      text: i
strtonum__S_140number: !!perl/hash:RE_ast
  dba: strtonum
  dic: STD::P6
  re: !!perl/hash:RE_sequence
    zyg:
    - !!perl/hash:RE_quantified_atom
      atom: !!perl/hash:RE_cclass
        i: 0
        text: '[+\-]'
      quant:
      - '?'
    - !!perl/hash:RE_method
      name: number
      rest: ''
sublongname: !!perl/hash:RE_ast
  dba: sublongname
  dic: STD::P6
  re: !!perl/hash:RE_sequence
    zyg:
    - !!perl/hash:RE_method
      name: subshortname
      rest: ''
    - !!perl/hash:RE_quantified_atom
      atom: !!perl/hash:RE_method
        name: sigterm
        rest: ''
      quant:
      - '?'
subshortname: !!perl/hash:RE_ast
  dba: subshortname
  dic: STD::P6
  re: !!perl/hash:RE_bracket
    re: &112 !!perl/hash:RE_any
      altname: subshortname_0
      dba: subshortname
      dic: STD::P6
      zyg:
      - !!perl/hash:RE_sequence
        alt: subshortname_0 0
        zyg:
        - !!perl/hash:RE_method
          name: category
          rest: ''
        - !!perl/hash:RE_quantified_atom
          atom: !!perl/hash:RE_method
            name: colonpair
            rest: ''
          quant:
          - +
      - !!perl/hash:RE_method
        alt: subshortname_0 1
        name: desigilname
        rest: ''
subshortname_0: *112
term__S_076fatarrow: !!perl/hash:RE_ast
  dba: term
  dic: STD::P6
  re: !!perl/hash:RE_method
    name: fatarrow
    rest: ''
term__S_077variable: !!perl/hash:RE_ast
  dba: term
  dic: STD::P6
  re: !!perl/hash:RE_sequence
    zyg:
    - !!perl/hash:RE_method
      name: variable
      rest: ''
    - !!perl/hash:RE_block {}
term__S_078package_declarator: !!perl/hash:RE_ast
  dba: term
  dic: STD::P6
  re: !!perl/hash:RE_method
    name: package_declarator
    rest: ''
term__S_079scope_declarator: !!perl/hash:RE_ast
  dba: term
  dic: STD::P6
  re: !!perl/hash:RE_method
    name: scope_declarator
    rest: ''
term__S_080multi_declarator: !!perl/hash:RE_ast
  dba: term
  dic: STD::P6
  re: !!perl/hash:RE_sequence
    zyg:
    - !!perl/hash:RE_assertion
      assert: '?'
      re: !!perl/hash:RE_method_re
        name: before
        nobind: 1
        re: &113 !!perl/hash:RE_any
          altname: term__S_080multi_declarator_0
          dba: term
          dic: STD::P6
          zyg:
          - !!perl/hash:RE_string
            alt: term__S_080multi_declarator_0 0
            i: 0
            text: multi
          - !!perl/hash:RE_string
            alt: term__S_080multi_declarator_0 1
            i: 0
            text: proto
          - !!perl/hash:RE_string
            alt: term__S_080multi_declarator_0 2
            i: 0
            text: only
    - !!perl/hash:RE_method
      name: multi_declarator
      rest: ''
term__S_080multi_declarator_0: *113
term__S_081routine_declarator: !!perl/hash:RE_ast
  dba: term
  dic: STD::P6
  re: !!perl/hash:RE_method
    name: routine_declarator
    rest: ''
term__S_082regex_declarator: !!perl/hash:RE_ast
  dba: term
  dic: STD::P6
  re: !!perl/hash:RE_method
    name: regex_declarator
    rest: ''
term__S_083type_declarator: !!perl/hash:RE_ast
  dba: term
  dic: STD::P6
  re: !!perl/hash:RE_method
    name: type_declarator
    rest: ''
term__S_084circumfix: !!perl/hash:RE_ast
  dba: term
  dic: STD::P6
  re: !!perl/hash:RE_method
    name: circumfix
    rest: ''
term__S_085dotty: !!perl/hash:RE_ast
  dba: term
  dic: STD::P6
  re: !!perl/hash:RE_method
    name: dotty
    rest: ''
term__S_086value: !!perl/hash:RE_ast
  dba: term
  dic: STD::P6
  re: !!perl/hash:RE_method
    name: value
    rest: ''
term__S_087capterm: !!perl/hash:RE_ast
  dba: term
  dic: STD::P6
  re: !!perl/hash:RE_method
    name: capterm
    rest: ''
term__S_088sigterm: !!perl/hash:RE_ast
  dba: term
  dic: STD::P6
  re: !!perl/hash:RE_method
    name: sigterm
    rest: ''
term__S_089statement_prefix: !!perl/hash:RE_ast
  dba: term
  dic: STD::P6
  re: !!perl/hash:RE_method
    name: statement_prefix
    rest: ''
term__S_090colonpair: !!perl/hash:RE_ast
  dba: term
  dic: STD::P6
  re: !!perl/hash:RE_quantified_atom
    atom: !!perl/hash:RE_bracket
      re: !!perl/hash:RE_sequence
        zyg:
        - !!perl/hash:RE_method
          name: colonpair
          rest: ''
        - !!perl/hash:RE_method
          name: ws
          rest: ''
    quant:
    - +
term__S_178new: !!perl/hash:RE_ast
  dba: term
  dic: STD::P6
  re: !!perl/hash:RE_sequence
    zyg:
    - !!perl/hash:RE_string
      i: 0
      text: new
    - !!perl/hash:RE_quantified_atom
      atom: !!perl/hash:RE_meta
        min: 1
        text: \h
      quant:
      - +
    - !!perl/hash:RE_method
      name: longname
      rest: ''
    - !!perl/hash:RE_quantified_atom
      atom: !!perl/hash:RE_meta
        min: 1
        text: \h
      quant:
      - '*'
    - !!perl/hash:RE_assertion
      assert: '!'
      re: !!perl/hash:RE_method_re
        name: before
        nobind: 1
        re: !!perl/hash:RE_string
          i: 0
          text: ':'
    - !!perl/hash:RE_method
      name: obs
      rest: 1
term__S_179ColonColonQuestionIDENT: !!perl/hash:RE_ast
  dba: term
  dic: STD::P6
  re: !!perl/hash:RE_sequence
    zyg:
    - !!perl/hash:RE_bindnamed
      atom: !!perl/hash:RE_bracket
        re: !!perl/hash:RE_sequence
          zyg:
          - !!perl/hash:RE_string
            i: 0
            text: ::?
          - !!perl/hash:RE_method
            name: identifier
            rest: ''
    - !!perl/hash:RE_meta
      text: »
    - !!perl/hash:RE_method
      name: O
      rest: 1
term__S_180Object: !!perl/hash:RE_ast
  dba: term
  dic: STD::P6
  re: !!perl/hash:RE_sequence
    zyg:
    - !!perl/hash:RE_method
      i: 0
      name: sym
      rest: ''
      sym: Object
    - !!perl/hash:RE_meta
      text: »
    - !!perl/hash:RE_block {}
    - !!perl/hash:RE_method
      name: obs
      rest: 1
term__S_181undef: !!perl/hash:RE_ast
  dba: term
  dic: STD::P6
  re: !!perl/hash:RE_sequence
    zyg:
    - !!perl/hash:RE_method
      i: 0
      name: sym
      rest: ''
      sym: undef
    - !!perl/hash:RE_meta
      text: »
    - !!perl/hash:RE_block {}
    - !!perl/hash:RE_quantified_atom
      atom: !!perl/hash:RE_bracket
        re: !!perl/hash:RE_sequence
          zyg:
          - !!perl/hash:RE_assertion
            assert: '?'
            re: !!perl/hash:RE_method_re
              name: before
              nobind: 1
              re: !!perl/hash:RE_sequence
                zyg:
                - !!perl/hash:RE_quantified_atom
                  atom: !!perl/hash:RE_meta
                    min: 1
                    text: \h
                  quant:
                  - '*'
                - !!perl/hash:RE_string
                  i: 0
                  text: $/
          - !!perl/hash:RE_method
            name: obs
            rest: 1
      quant:
      - '?'
    - !!perl/hash:RE_quantified_atom
      atom: !!perl/hash:RE_bracket
        re: !!perl/hash:RE_sequence
          zyg:
          - !!perl/hash:RE_assertion
            assert: '?'
            re: !!perl/hash:RE_method_re
              name: before
              nobind: 1
              re: !!perl/hash:RE_bracket
                re: !!perl/hash:RE_first
                  zyg:
                  - !!perl/hash:RE_string
                    i: 0
                    text: (
                  - !!perl/hash:RE_sequence
                    zyg:
                    - !!perl/hash:RE_quantified_atom
                      atom: !!perl/hash:RE_meta
                        min: 1
                        text: \h
                      quant:
                      - '*'
                    - !!perl/hash:RE_method
                      name: sigil
                      rest: ''
                    - !!perl/hash:RE_quantified_atom
                      atom: !!perl/hash:RE_method
                        name: twigil
                        rest: ''
                      quant:
                      - '?'
                    - !!perl/hash:RE_meta
                      min: 1
                      text: \w
          - !!perl/hash:RE_method
            name: obs
            rest: 1
      quant:
      - '?'
    - !!perl/hash:RE_method
      name: obs
      rest: 1
term__S_182proceed: !!perl/hash:RE_ast
  dba: term
  dic: STD::P6
  re: !!perl/hash:RE_sequence
    zyg:
    - !!perl/hash:RE_method
      i: 0
      name: sym
      rest: ''
      sym: proceed
    - !!perl/hash:RE_meta
      text: »
    - !!perl/hash:RE_method
      name: O
      rest: 1
term__S_183time: !!perl/hash:RE_ast
  dba: term
  dic: STD::P6
  re: !!perl/hash:RE_sequence
    zyg:
    - !!perl/hash:RE_method
      i: 0
      name: sym
      rest: ''
      sym: time
    - !!perl/hash:RE_meta
      text: »
    - !!perl/hash:RE_method
      name: O
      rest: 1
term__S_184now: !!perl/hash:RE_ast
  dba: term
  dic: STD::P6
  re: !!perl/hash:RE_sequence
    zyg:
    - !!perl/hash:RE_method
      i: 0
      name: sym
      rest: ''
      sym: now
    - !!perl/hash:RE_meta
      text: »
    - !!perl/hash:RE_method
      name: O
      rest: 1
term__S_185self: !!perl/hash:RE_ast
  dba: term
  dic: STD::P6
  re: !!perl/hash:RE_sequence
    zyg:
    - !!perl/hash:RE_method
      i: 0
      name: sym
      rest: ''
      sym: self
    - !!perl/hash:RE_meta
      text: »
    - !!perl/hash:RE_method
      name: O
      rest: 1
term__S_186defer: !!perl/hash:RE_ast
  dba: term
  dic: STD::P6
  re: !!perl/hash:RE_sequence
    zyg:
    - !!perl/hash:RE_method
      i: 0
      name: sym
      rest: ''
      sym: defer
    - !!perl/hash:RE_meta
      text: »
    - !!perl/hash:RE_method
      name: O
      rest: 1
term__S_187rand: !!perl/hash:RE_ast
  dba: term
  dic: STD::P6
  re: !!perl/hash:RE_sequence
    zyg:
    - !!perl/hash:RE_method
      i: 0
      name: sym
      rest: ''
      sym: rand
    - !!perl/hash:RE_meta
      text: »
    - !!perl/hash:RE_quantified_atom
      atom: !!perl/hash:RE_bracket
        re: !!perl/hash:RE_sequence
          zyg:
          - !!perl/hash:RE_assertion
            assert: '?'
            re: !!perl/hash:RE_method_re
              name: before
              nobind: 1
              re: !!perl/hash:RE_sequence
                zyg:
                - !!perl/hash:RE_quantified_atom
                  atom: !!perl/hash:RE_string
                    i: 0
                    text: (
                  quant:
                  - '?'
                - !!perl/hash:RE_quantified_atom
                  atom: !!perl/hash:RE_meta
                    min: 1
                    text: \h
                  quant:
                  - '*'
                - !!perl/hash:RE_bracket
                  re: &114 !!perl/hash:RE_any
                    altname: term__S_187rand_0
                    dba: term
                    dic: STD::P6
                    zyg:
                    - !!perl/hash:RE_meta
                      alt: term__S_187rand_0 0
                      min: 1
                      text: \d
                    - !!perl/hash:RE_string
                      alt: term__S_187rand_0 1
                      i: 0
                      text: $
          - !!perl/hash:RE_method
            name: obs
            rest: 1
      quant:
      - '?'
    - !!perl/hash:RE_quantified_atom
      atom: !!perl/hash:RE_bracket
        re: !!perl/hash:RE_sequence
          zyg:
          - !!perl/hash:RE_assertion
            assert: '?'
            re: !!perl/hash:RE_method_re
              name: before
              nobind: 1
              re: !!perl/hash:RE_string
                i: 0
                text: ()
          - !!perl/hash:RE_method
            name: obs
            rest: 1
      quant:
      - '?'
    - !!perl/hash:RE_method
      name: O
      rest: 1
term__S_187rand_0: *114
term__S_188Star: !!perl/hash:RE_ast
  dba: term
  dic: STD::P6
  re: !!perl/hash:RE_sequence
    zyg:
    - !!perl/hash:RE_method
      i: 0
      name: sym
      rest: ''
      sym: '*'
    - !!perl/hash:RE_method
      name: O
      rest: 1
term__S_189StarStar: !!perl/hash:RE_ast
  dba: term
  dic: STD::P6
  re: !!perl/hash:RE_sequence
    zyg:
    - !!perl/hash:RE_method
      i: 0
      name: sym
      rest: ''
      sym: '**'
    - !!perl/hash:RE_method
      name: O
      rest: 1
term__S_213lambda: !!perl/hash:RE_ast
  dba: term
  dic: STD::P6
  re: !!perl/hash:RE_sequence
    zyg:
    - !!perl/hash:RE_assertion
      assert: '?'
      re: !!perl/hash:RE_method_re
        name: before
        nobind: 1
        re: !!perl/hash:RE_method
          name: lambda
          rest: ''
    - !!perl/hash:RE_method
      name: pblock
      rest: ''
    - !!perl/hash:RE_block {}
    - !!perl/hash:RE_method
      name: O
      rest: 1
term__S_329DotDotDot: !!perl/hash:RE_ast
  dba: term
  dic: STD::P6
  re: !!perl/hash:RE_sequence
    zyg:
    - !!perl/hash:RE_method
      i: 0
      name: sym
      rest: ''
      sym: '...'
    - !!perl/hash:RE_quantified_atom
      atom: !!perl/hash:RE_method
        name: args
        rest: ''
      quant:
      - '?'
    - !!perl/hash:RE_method
      name: O
      rest: 1
term__S_330QuestionQuestionQuestion: !!perl/hash:RE_ast
  dba: term
  dic: STD::P6
  re: !!perl/hash:RE_sequence
    zyg:
    - !!perl/hash:RE_method
      i: 0
      name: sym
      rest: ''
      sym: ???
    - !!perl/hash:RE_quantified_atom
      atom: !!perl/hash:RE_method
        name: args
        rest: ''
      quant:
      - '?'
    - !!perl/hash:RE_method
      name: O
      rest: 1
term__S_331BangBangBang: !!perl/hash:RE_ast
  dba: term
  dic: STD::P6
  re: !!perl/hash:RE_sequence
    zyg:
    - !!perl/hash:RE_method
      i: 0
      name: sym
      rest: ''
      sym: '!!!'
    - !!perl/hash:RE_quantified_atom
      atom: !!perl/hash:RE_method
        name: args
        rest: ''
      quant:
      - '?'
    - !!perl/hash:RE_method
      name: O
      rest: 1
term__S_332identifier: !!perl/hash:RE_ast
  dba: term
  dic: STD::P6
  re: !!perl/hash:RE_sequence
    zyg:
    - !!perl/hash:RE_method
      name: identifier
      rest: ''
    - !!perl/hash:RE_assertion
      assert: '?'
      re: !!perl/hash:RE_method_re
        name: before
        nobind: 1
        re: !!perl/hash:RE_quantified_atom
          atom: !!perl/hash:RE_bracket
            re: &115 !!perl/hash:RE_any
              altname: term__S_332identifier_0
              dba: term
              dic: STD::P6
              zyg:
              - !!perl/hash:RE_method
                alt: term__S_332identifier_0 0
                name: unsp
                rest: ''
              - !!perl/hash:RE_string
                alt: term__S_332identifier_0 1
                i: 0
                text: (
          quant:
          - '?'
    - !!perl/hash:RE_assertion
      assert: '!'
      re: !!perl/hash:RE_cclass
        i: 0
        nobind: 1
        text: '[:]'
    - !!perl/hash:RE_block {}
    - !!perl/hash:RE_method
      name: args
      rest: 1
    - !!perl/hash:RE_block {}
    - !!perl/hash:RE_block {}
    - !!perl/hash:RE_method
      name: O
      rest: 1
term__S_332identifier_0: *115
term__S_333name: !!perl/hash:RE_ast
  dba: term
  dic: STD::P6
  re: !!perl/hash:RE_sequence
    zyg:
    - !!perl/hash:RE_method
      name: longname
      rest: ''
    - !!perl/hash:RE_block {}
    - !!perl/hash:RE_bracket
      re: !!perl/hash:RE_first
        zyg:
        - !!perl/hash:RE_sequence
          zyg:
          - !!perl/hash:RE_assertion
            assert: '?'
            re: !!perl/hash:RE_block
              nobind: 1
          - !!perl/hash:RE_block {}
          - !!perl/hash:RE_quantified_atom
            atom: !!perl/hash:RE_method
              name: unsp
              rest: ''
            quant:
            - '?'
          - !!perl/hash:RE_quantified_atom
            atom: !!perl/hash:RE_bracket
              re: !!perl/hash:RE_sequence
                zyg:
                - !!perl/hash:RE_assertion
                  assert: '?'
                  re: !!perl/hash:RE_method_re
                    name: before
                    nobind: 1
                    re: !!perl/hash:RE_string
                      i: 0
                      text: '['
                - !!perl/hash:RE_method
                  name: postcircumfix
                  rest: ''
            quant:
            - '?'
          - !!perl/hash:RE_quantified_atom
            atom: !!perl/hash:RE_bracket
              re: !!perl/hash:RE_sequence
                zyg:
                - !!perl/hash:RE_assertion
                  assert: '?'
                  re: !!perl/hash:RE_method_re
                    name: after
                    nobind: 1
                    re: !!perl/hash:RE_string
                      i: 0
                      text: '::'
                - !!perl/hash:RE_assertion
                  assert: '?'
                  re: !!perl/hash:RE_method_re
                    name: before
                    nobind: 1
                    re: !!perl/hash:RE_bracket
                      re: &116 !!perl/hash:RE_any
                        altname: term__S_333name_0
                        dba: namespace variable lookup
                        dic: STD::P6
                        zyg:
                        - !!perl/hash:RE_string
                          alt: term__S_333name_0 0
                          i: 0
                          text: «
                        - !!perl/hash:RE_string
                          alt: term__S_333name_0 1
                          i: 0
                          text: <
                        - !!perl/hash:RE_string
                          alt: term__S_333name_0 2
                          i: 0
                          text: '{'
                        - !!perl/hash:RE_string
                          alt: term__S_333name_0 3
                          i: 0
                          text: <<
                - !!perl/hash:RE_method
                  name: postcircumfix
                  rest: ''
                - !!perl/hash:RE_block {}
            quant:
            - '?'
        - !!perl/hash:RE_sequence
          zyg:
          - !!perl/hash:RE_method
            name: args
            rest: ''
          - !!perl/hash:RE_block {}
          - !!perl/hash:RE_block {}
    - !!perl/hash:RE_method
      name: O
      rest: 1
term__S_333name_0: *116
terminator__S_343Semi: !!perl/hash:RE_ast
  dba: terminator
  dic: STD::P6
  re: !!perl/hash:RE_sequence
    zyg:
    - !!perl/hash:RE_string
      i: 0
      text: ;
    - !!perl/hash:RE_method
      name: O
      rest: 1
terminator__S_344if: !!perl/hash:RE_ast
  dba: terminator
  dic: STD::P6
  re: !!perl/hash:RE_sequence
    zyg:
    - !!perl/hash:RE_string
      i: 0
      text: if
    - !!perl/hash:RE_meta
      text: »
    - !!perl/hash:RE_method
      name: nofun
      rest: ''
    - !!perl/hash:RE_method
      name: O
      rest: 1
terminator__S_345unless: !!perl/hash:RE_ast
  dba: terminator
  dic: STD::P6
  re: !!perl/hash:RE_sequence
    zyg:
    - !!perl/hash:RE_string
      i: 0
      text: unless
    - !!perl/hash:RE_meta
      text: »
    - !!perl/hash:RE_method
      name: nofun
      rest: ''
    - !!perl/hash:RE_method
      name: O
      rest: 1
terminator__S_346while: !!perl/hash:RE_ast
  dba: terminator
  dic: STD::P6
  re: !!perl/hash:RE_sequence
    zyg:
    - !!perl/hash:RE_string
      i: 0
      text: while
    - !!perl/hash:RE_meta
      text: »
    - !!perl/hash:RE_method
      name: nofun
      rest: ''
    - !!perl/hash:RE_method
      name: O
      rest: 1
terminator__S_347until: !!perl/hash:RE_ast
  dba: terminator
  dic: STD::P6
  re: !!perl/hash:RE_sequence
    zyg:
    - !!perl/hash:RE_string
      i: 0
      text: until
    - !!perl/hash:RE_meta
      text: »
    - !!perl/hash:RE_method
      name: nofun
      rest: ''
    - !!perl/hash:RE_method
      name: O
      rest: 1
terminator__S_348for: !!perl/hash:RE_ast
  dba: terminator
  dic: STD::P6
  re: !!perl/hash:RE_sequence
    zyg:
    - !!perl/hash:RE_string
      i: 0
      text: for
    - !!perl/hash:RE_meta
      text: »
    - !!perl/hash:RE_method
      name: nofun
      rest: ''
    - !!perl/hash:RE_method
      name: O
      rest: 1
terminator__S_349given: !!perl/hash:RE_ast
  dba: terminator
  dic: STD::P6
  re: !!perl/hash:RE_sequence
    zyg:
    - !!perl/hash:RE_string
      i: 0
      text: given
    - !!perl/hash:RE_meta
      text: »
    - !!perl/hash:RE_method
      name: nofun
      rest: ''
    - !!perl/hash:RE_method
      name: O
      rest: 1
terminator__S_350when: !!perl/hash:RE_ast
  dba: terminator
  dic: STD::P6
  re: !!perl/hash:RE_sequence
    zyg:
    - !!perl/hash:RE_string
      i: 0
      text: when
    - !!perl/hash:RE_meta
      text: »
    - !!perl/hash:RE_method
      name: nofun
      rest: ''
    - !!perl/hash:RE_method
      name: O
      rest: 1
terminator__S_351MinusMinusGt: !!perl/hash:RE_ast
  dba: terminator
  dic: STD::P6
  re: !!perl/hash:RE_sequence
    zyg:
    - !!perl/hash:RE_string
      i: 0
      text: -->
    - !!perl/hash:RE_method
      name: O
      rest: 1
terminator__S_352BangBang: !!perl/hash:RE_ast
  dba: terminator
  dic: STD::P6
  re: !!perl/hash:RE_sequence
    zyg:
    - !!perl/hash:RE_string
      i: 0
      text: '!!'
    - !!perl/hash:RE_assertion
      assert: '?'
      re: !!perl/hash:RE_block
        nobind: 1
    - !!perl/hash:RE_method
      name: O
      rest: 1
termish: !!perl/hash:RE_ast
  dba: postfix
  dic: STD::P6
  re: !!perl/hash:RE_sequence
    zyg:
    - !!perl/hash:RE_bracket
      re: &117 !!perl/hash:RE_any
        altname: termish_0
        dba: prefix or term
        dic: STD::P6
        zyg:
        - !!perl/hash:RE_sequence
          alt: termish_0 0
          zyg:
          - !!perl/hash:RE_method
            name: PRE
            rest: ''
          - !!perl/hash:RE_quantified_atom
            atom: !!perl/hash:RE_bracket
              re: !!perl/hash:RE_sequence
                zyg:
                - !!perl/hash:RE_assertion
                  assert: '!'
                  re: !!perl/hash:RE_block
                    nobind: 1
                - !!perl/hash:RE_method
                  name: PRE
                  rest: ''
            quant:
            - '*'
          - !!perl/hash:RE_bracket
            re: !!perl/hash:RE_first
              zyg:
              - !!perl/hash:RE_assertion
                assert: '?'
                re: !!perl/hash:RE_block
                  nobind: 1
              - !!perl/hash:RE_method
                name: term
                rest: ''
              - !!perl/hash:RE_method
                name: panic
                rest: 1
        - !!perl/hash:RE_method
          alt: termish_0 1
          name: term
          rest: ''
    - !!perl/hash:RE_bracket
      re: !!perl/hash:RE_first
        zyg:
        - !!perl/hash:RE_sequence
          zyg:
          - !!perl/hash:RE_assertion
            assert: '?'
            re: !!perl/hash:RE_block
              nobind: 1
          - !!perl/hash:RE_bracket
            re: !!perl/hash:RE_first
              zyg:
              - !!perl/hash:RE_sequence
                zyg:
                - !!perl/hash:RE_assertion
                  assert: '?'
                  re: !!perl/hash:RE_block
                    nobind: 1
                - !!perl/hash:RE_bracket
                  re: !!perl/hash:RE_first
                    zyg:
                    - !!perl/hash:RE_sequence
                      zyg:
                      - !!perl/hash:RE_quantified_atom
                        atom: !!perl/hash:RE_bracket
                          re: !!perl/hash:RE_sequence
                            zyg:
                            - !!perl/hash:RE_assertion
                              assert: '!'
                              re: !!perl/hash:RE_method_re
                                name: before
                                nobind: 1
                                re: !!perl/hash:RE_string
                                  i: 0
                                  text: \
                            - !!perl/hash:RE_method
                              name: POST
                              rest: ''
                        quant:
                        - +
                      - !!perl/hash:RE_assertion
                        assert: '?'
                        re: !!perl/hash:RE_method_re
                          name: after
                          nobind: 1
                          re: !!perl/hash:RE_cclass
                            i: 0
                            text: '[ \] } > ) ]'
                    - !!perl/hash:RE_block {}
              - !!perl/hash:RE_sequence
                zyg:
                - !!perl/hash:RE_quantified_atom
                  atom: !!perl/hash:RE_bracket
                    re: !!perl/hash:RE_sequence
                      zyg:
                      - !!perl/hash:RE_assertion
                        assert: '!'
                        re: !!perl/hash:RE_method_re
                          name: before
                          nobind: 1
                          re: !!perl/hash:RE_string
                            i: 0
                            text: \
                      - !!perl/hash:RE_method
                        name: POST
                        rest: ''
                  quant:
                  - +
                - !!perl/hash:RE_assertion
                  assert: '?'
                  re: !!perl/hash:RE_method_re
                    name: after
                    nobind: 1
                    re: !!perl/hash:RE_cclass
                      i: 0
                      text: '[ \] } > ) ]'
              - !!perl/hash:RE_block {}
        - !!perl/hash:RE_sequence
          zyg:
          - !!perl/hash:RE_assertion
            assert: '!'
            re: !!perl/hash:RE_block
              nobind: 1
          - !!perl/hash:RE_quantified_atom
            atom: !!perl/hash:RE_method
              name: POST
              rest: ''
            quant:
            - '*'
    - !!perl/hash:RE_block {}
termish_0: *117
trait: !!perl/hash:RE_ast
  dba: trait
  dic: STD::P6
  re: !!perl/hash:RE_sequence
    zyg:
    - !!perl/hash:RE_method
      name: ws
      rest: ''
    - !!perl/hash:RE_bracket
      re: &118 !!perl/hash:RE_any
        altname: trait_0
        dba: trait
        dic: STD::P6
        zyg:
        - !!perl/hash:RE_sequence
          alt: trait_0 0
          zyg:
          - !!perl/hash:RE_method
            name: trait_mod
            rest: ''
          - !!perl/hash:RE_method
            name: ws
            rest: ''
        - !!perl/hash:RE_sequence
          alt: trait_0 1
          zyg:
          - !!perl/hash:RE_method
            name: colonpair
            rest: ''
          - !!perl/hash:RE_method
            name: ws
            rest: ''
trait_0: *118
trait_mod__S_069is: !!perl/hash:RE_ast
  dba: trait_mod
  dic: STD::P6
  re: !!perl/hash:RE_sequence
    zyg:
    - !!perl/hash:RE_method
      endsym: spacey
      i: 0
      name: sym
      rest: ''
      sym: is
    - !!perl/hash:RE_method
      name: spacey
      rest: ''
    - !!perl/hash:RE_method
      name: ws
      rest: ''
    - !!perl/hash:RE_method
      name: longname
      rest: ''
    - !!perl/hash:RE_quantified_atom
      atom: !!perl/hash:RE_method
        name: circumfix
        rest: ''
      quant:
      - '?'
    - !!perl/hash:RE_method
      name: ws
      rest: ''
    - !!perl/hash:RE_block {}
trait_mod__S_070hides: !!perl/hash:RE_ast
  dba: trait_mod
  dic: STD::P6
  re: !!perl/hash:RE_sequence
    zyg:
    - !!perl/hash:RE_method
      endsym: spacey
      i: 0
      name: sym
      rest: ''
      sym: hides
    - !!perl/hash:RE_method
      name: spacey
      rest: ''
    - !!perl/hash:RE_method
      name: ws
      rest: ''
    - !!perl/hash:RE_method
      name: module_name
      rest: ''
    - !!perl/hash:RE_method
      name: ws
      rest: ''
trait_mod__S_071does: !!perl/hash:RE_ast
  dba: trait_mod
  dic: STD::P6
  re: !!perl/hash:RE_sequence
    zyg:
    - !!perl/hash:RE_method
      endsym: spacey
      i: 0
      name: sym
      rest: ''
      sym: does
    - !!perl/hash:RE_method
      name: spacey
      rest: ''
    - !!perl/hash:RE_method
      name: ws
      rest: ''
    - !!perl/hash:RE_method
      name: module_name
      rest: ''
    - !!perl/hash:RE_method
      name: ws
      rest: ''
trait_mod__S_072will: !!perl/hash:RE_ast
  dba: trait_mod
  dic: STD::P6
  re: !!perl/hash:RE_sequence
    zyg:
    - !!perl/hash:RE_method
      endsym: spacey
      i: 0
      name: sym
      rest: ''
      sym: will
    - !!perl/hash:RE_method
      name: spacey
      rest: ''
    - !!perl/hash:RE_method
      name: ws
      rest: ''
    - !!perl/hash:RE_method
      name: identifier
      rest: ''
    - !!perl/hash:RE_method
      name: ws
      rest: ''
    - !!perl/hash:RE_method
      name: pblock
      rest: ''
    - !!perl/hash:RE_method
      name: ws
      rest: ''
trait_mod__S_073of: !!perl/hash:RE_ast
  dba: trait_mod
  dic: STD::P6
  re: !!perl/hash:RE_sequence
    zyg:
    - !!perl/hash:RE_bracket
      re: &119 !!perl/hash:RE_any
        altname: trait_mod__S_073of_0
        dba: trait_mod
        dic: STD::P6
        zyg:
        - !!perl/hash:RE_string
          alt: trait_mod__S_073of_0 0
          i: 0
          text: of
        - !!perl/hash:RE_string
          alt: trait_mod__S_073of_0 1
          i: 0
          text: returns
    - !!perl/hash:RE_method
      name: ws
      rest: ''
    - !!perl/hash:RE_method
      name: typename
      rest: ''
    - !!perl/hash:RE_method
      name: ws
      rest: ''
    - !!perl/hash:RE_quantified_atom
      atom: !!perl/hash:RE_bracket
        re: !!perl/hash:RE_sequence
          zyg:
          - !!perl/hash:RE_method
            name: ws
            rest: ''
          - !!perl/hash:RE_assertion
            assert: '?'
            re: !!perl/hash:RE_block
              nobind: 1
          - !!perl/hash:RE_method
            name: sorry
            rest: 1
          - !!perl/hash:RE_method
            name: ws
            rest: ''
      quant:
      - '?'
    - !!perl/hash:RE_method
      name: ws
      rest: ''
    - !!perl/hash:RE_block {}
trait_mod__S_073of_0: *119
trait_mod__S_074as: !!perl/hash:RE_ast
  dba: trait_mod
  dic: STD::P6
  re: !!perl/hash:RE_sequence
    zyg:
    - !!perl/hash:RE_method
      endsym: spacey
      i: 0
      name: sym
      rest: ''
      sym: as
    - !!perl/hash:RE_method
      name: spacey
      rest: ''
    - !!perl/hash:RE_method
      name: ws
      rest: ''
    - !!perl/hash:RE_method
      name: typename
      rest: ''
    - !!perl/hash:RE_method
      name: ws
      rest: ''
trait_mod__S_075handles: !!perl/hash:RE_ast
  dba: trait_mod
  dic: STD::P6
  re: !!perl/hash:RE_sequence
    zyg:
    - !!perl/hash:RE_method
      endsym: spacey
      i: 0
      name: sym
      rest: ''
      sym: handles
    - !!perl/hash:RE_method
      name: spacey
      rest: ''
    - !!perl/hash:RE_method
      name: ws
      rest: ''
    - !!perl/hash:RE_method
      name: term
      rest: ''
    - !!perl/hash:RE_method
      name: ws
      rest: ''
tribble: !!perl/hash:RE_ast
  dba: tribble
  dic: STD::P6
  re: !!perl/hash:RE_sequence
    zyg:
    - !!perl/hash:RE_method
      name: babble
      rest: 1
    - !!perl/hash:RE_block {}
    - !!perl/hash:RE_var
      var: $start
    - !!perl/hash:RE_bindnamed
      atom: !!perl/hash:RE_method
        name: nibble
        rest: 1
    - !!perl/hash:RE_bracket
      re: !!perl/hash:RE_first
        zyg:
        - !!perl/hash:RE_var
          var: $stop
        - !!perl/hash:RE_method
          name: panic
          rest: 1
    - !!perl/hash:RE_block {}
    - !!perl/hash:RE_bracket
      re: !!perl/hash:RE_first
        zyg:
        - !!perl/hash:RE_sequence
          zyg:
          - !!perl/hash:RE_assertion
            assert: '?'
            re: !!perl/hash:RE_block
              nobind: 1
          - !!perl/hash:RE_method
            name: ws
            rest: ''
          - !!perl/hash:RE_method
            name: quibble
            rest: 1
        - !!perl/hash:RE_sequence
          zyg:
          - !!perl/hash:RE_block {}
          - !!perl/hash:RE_bindnamed
            atom: !!perl/hash:RE_method
              name: nibble
              rest: 1
          - !!perl/hash:RE_var
            var: $stop
        - !!perl/hash:RE_method
          name: panic
          rest: 1
type_constraint: !!perl/hash:RE_ast
  dba: type_constraint
  dic: STD::P6
  re: !!perl/hash:RE_sequence
    zyg:
    - !!perl/hash:RE_bracket
      re: &120 !!perl/hash:RE_any
        altname: type_constraint_0
        dba: type_constraint
        dic: STD::P6
        zyg:
        - !!perl/hash:RE_method
          alt: type_constraint_0 0
          name: value
          rest: ''
        - !!perl/hash:RE_sequence
          alt: type_constraint_0 1
          zyg:
          - !!perl/hash:RE_method
            name: typename
            rest: ''
          - !!perl/hash:RE_quantified_atom
            atom: !!perl/hash:RE_bracket
              re: !!perl/hash:RE_sequence
                zyg:
                - !!perl/hash:RE_assertion
                  assert: '?'
                  re: !!perl/hash:RE_block
                    nobind: 1
                - !!perl/hash:RE_method
                  name: sorry
                  rest: 1
            quant:
            - '?'
          - !!perl/hash:RE_block {}
        - !!perl/hash:RE_sequence
          alt: type_constraint_0 2
          zyg:
          - !!perl/hash:RE_string
            i: 0
            text: w
          - !!perl/hash:RE_string
            i: 0
            text: h
          - !!perl/hash:RE_string
            i: 0
            text: e
          - !!perl/hash:RE_string
            i: 0
            text: r
          - !!perl/hash:RE_string
            i: 0
            text: e
          - !!perl/hash:RE_method
            name: ws
            rest: ''
          - !!perl/hash:RE_method
            name: EXPR
            rest: 1
    - !!perl/hash:RE_method
      name: ws
      rest: ''
type_constraint_0: *120
type_declarator__S_165subset: !!perl/hash:RE_ast
  dba: type_declarator
  dic: STD::P6
  re: !!perl/hash:RE_first
    zyg:
    - !!perl/hash:RE_sequence
      zyg:
      - !!perl/hash:RE_method
        endsym: spacey
        i: 0
        name: sym
        rest: ''
        sym: subset
      - !!perl/hash:RE_method
        name: spacey
        rest: ''
      - !!perl/hash:RE_method
        name: ws
        rest: ''
      - !!perl/hash:RE_bracket
        re: !!perl/hash:RE_sequence
          zyg:
          - !!perl/hash:RE_quantified_atom
            atom: !!perl/hash:RE_bracket
              re: !!perl/hash:RE_sequence
                zyg:
                - !!perl/hash:RE_method
                  name: ws
                  rest: ''
                - !!perl/hash:RE_method
                  name: longname
                  rest: ''
                - !!perl/hash:RE_method
                  name: ws
                  rest: ''
                - !!perl/hash:RE_block {}
            quant:
            - '?'
          - !!perl/hash:RE_method
            name: ws
            rest: ''
          - !!perl/hash:RE_quantified_atom
            atom: !!perl/hash:RE_method
              name: trait
              rest: ''
            quant:
            - '*'
          - !!perl/hash:RE_method
            name: ws
            rest: ''
          - !!perl/hash:RE_quantified_atom
            atom: !!perl/hash:RE_bracket
              re: !!perl/hash:RE_sequence
                zyg:
                - !!perl/hash:RE_string
                  i: 0
                  text: w
                - !!perl/hash:RE_string
                  i: 0
                  text: h
                - !!perl/hash:RE_string
                  i: 0
                  text: e
                - !!perl/hash:RE_string
                  i: 0
                  text: r
                - !!perl/hash:RE_string
                  i: 0
                  text: e
                - !!perl/hash:RE_method
                  name: ws
                  rest: ''
                - !!perl/hash:RE_method
                  name: EXPR
                  rest: 1
                - !!perl/hash:RE_method
                  name: ws
                  rest: ''
            quant:
            - '?'
          - !!perl/hash:RE_method
            name: ws
            rest: ''
    - !!perl/hash:RE_sequence
      zyg:
      - !!perl/hash:RE_method
        name: ws
        rest: ''
      - !!perl/hash:RE_method
        name: panic
        rest: 1
      - !!perl/hash:RE_method
        name: ws
        rest: ''
type_declarator__S_166enum: !!perl/hash:RE_ast
  dba: type_declarator
  dic: STD::P6
  re: !!perl/hash:RE_sequence
    zyg:
    - !!perl/hash:RE_method
      endsym: spacey
      i: 0
      name: sym
      rest: ''
      sym: enum
    - !!perl/hash:RE_method
      name: spacey
      rest: ''
    - !!perl/hash:RE_method
      name: ws
      rest: ''
    - !!perl/hash:RE_bracket
      re: &121 !!perl/hash:RE_any
        altname: type_declarator__S_166enum_0
        dba: type_declarator
        dic: STD::P6
        zyg:
        - !!perl/hash:RE_sequence
          alt: type_declarator__S_166enum_0 0
          zyg:
          - !!perl/hash:RE_bindnamed
            atom: !!perl/hash:RE_method
              name: longname
              rest: ''
          - !!perl/hash:RE_block {}
        - !!perl/hash:RE_sequence
          alt: type_declarator__S_166enum_0 1
          zyg:
          - !!perl/hash:RE_bindnamed
            atom: !!perl/hash:RE_method
              name: variable
              rest: ''
          - !!perl/hash:RE_block {}
        - !!perl/hash:RE_assertion
          alt: type_declarator__S_166enum_0 2
          assert: '?'
          re: !!perl/hash:RE_noop
            nobind: 1
    - !!perl/hash:RE_block {}
    - !!perl/hash:RE_method
      name: ws
      rest: ''
    - !!perl/hash:RE_quantified_atom
      atom: !!perl/hash:RE_method
        name: trait
        rest: ''
      quant:
      - '*'
    - !!perl/hash:RE_assertion
      assert: '?'
      re: !!perl/hash:RE_method_re
        name: before
        nobind: 1
        re: !!perl/hash:RE_cclass
          i: 0
          text: '[ < ( « ]'
    - !!perl/hash:RE_method
      name: term
      rest: ''
    - !!perl/hash:RE_method
      name: ws
      rest: ''
    - !!perl/hash:RE_block {}
type_declarator__S_166enum_0: *121
type_declarator__S_167constant: !!perl/hash:RE_ast
  dba: type_declarator
  dic: STD::P6
  re: !!perl/hash:RE_sequence
    zyg:
    - !!perl/hash:RE_method
      endsym: spacey
      i: 0
      name: sym
      rest: ''
      sym: constant
    - !!perl/hash:RE_method
      name: spacey
      rest: ''
    - !!perl/hash:RE_method
      name: ws
      rest: ''
    - !!perl/hash:RE_bracket
      re: &122 !!perl/hash:RE_any
        altname: type_declarator__S_167constant_0
        dba: type_declarator
        dic: STD::P6
        zyg:
        - !!perl/hash:RE_sequence
          alt: type_declarator__S_167constant_0 0
          zyg:
          - !!perl/hash:RE_method
            name: identifier
            rest: ''
          - !!perl/hash:RE_block {}
        - !!perl/hash:RE_sequence
          alt: type_declarator__S_167constant_0 1
          zyg:
          - !!perl/hash:RE_method
            name: variable
            rest: ''
          - !!perl/hash:RE_block {}
        - !!perl/hash:RE_assertion
          alt: type_declarator__S_167constant_0 2
          assert: '?'
          re: !!perl/hash:RE_noop
            nobind: 1
    - !!perl/hash:RE_block {}
    - !!perl/hash:RE_method
      name: ws
      rest: ''
    - !!perl/hash:RE_quantified_atom
      atom: !!perl/hash:RE_method
        name: trait
        rest: ''
      quant:
      - '*'
    - !!perl/hash:RE_bracket
      re: !!perl/hash:RE_first
        zyg:
        - !!perl/hash:RE_assertion
          assert: '?'
          re: !!perl/hash:RE_method_re
            name: before
            nobind: 1
            re: !!perl/hash:RE_string
              i: 0
              text: =
        - !!perl/hash:RE_sequence
          zyg:
          - !!perl/hash:RE_assertion
            assert: '?'
            re: !!perl/hash:RE_method_re
              name: before
              nobind: 1
              re: !!perl/hash:RE_sequence
                zyg:
                - !!perl/hash:RE_quantified_atom
                  atom: !!perl/hash:RE_cclass
                    i: 0
                    text: -[\n=]
                  quant:
                  - '*'
                - !!perl/hash:RE_string
                  i: 0
                  text: =
          - !!perl/hash:RE_method
            name: panic
            rest: 1
        - !!perl/hash:RE_method
          name: sorry
          rest: 1
    - !!perl/hash:RE_method
      name: getdecl
      rest: ''
type_declarator__S_167constant_0: *122
typename: !!perl/hash:RE_ast
  dba: typename
  dic: STD::P6
  re: !!perl/hash:RE_sequence
    zyg:
    - !!perl/hash:RE_bracket
      re: &123 !!perl/hash:RE_any
        altname: typename_0
        dba: typename
        dic: STD::P6
        zyg:
        - !!perl/hash:RE_sequence
          alt: typename_0 0
          zyg:
          - !!perl/hash:RE_string
            i: 0
            text: ::?
          - !!perl/hash:RE_method
            name: identifier
            rest: ''
        - !!perl/hash:RE_sequence
          alt: typename_0 1
          zyg:
          - !!perl/hash:RE_method
            name: longname
            rest: ''
          - !!perl/hash:RE_assertion
            assert: '?'
            re: !!perl/hash:RE_block
              nobind: 1
    - !!perl/hash:RE_quantified_atom
      atom: !!perl/hash:RE_method
        name: unsp
        rest: ''
      quant:
      - '?'
    - !!perl/hash:RE_quantified_atom
      atom: !!perl/hash:RE_bracket
        re: !!perl/hash:RE_sequence
          zyg:
          - !!perl/hash:RE_assertion
            assert: '?'
            re: !!perl/hash:RE_method_re
              name: before
              nobind: 1
              re: !!perl/hash:RE_string
                i: 0
                text: '['
          - !!perl/hash:RE_bindnamed
            atom: !!perl/hash:RE_method
              name: postcircumfix
              rest: ''
      quant:
      - '?'
    - !!perl/hash:RE_quantified_atom
      atom: !!perl/hash:RE_method
        name: unsp
        rest: ''
      quant:
      - '?'
    - !!perl/hash:RE_quantified_atom
      atom: !!perl/hash:RE_bracket
        re: !!perl/hash:RE_sequence
          zyg:
          - !!perl/hash:RE_assertion
            assert: '?'
            re: !!perl/hash:RE_method_re
              name: before
              nobind: 1
              re: !!perl/hash:RE_string
                i: 0
                text: '{'
          - !!perl/hash:RE_bindnamed
            atom: !!perl/hash:RE_method
              name: postcircumfix
              rest: ''
      quant:
      - '?'
    - !!perl/hash:RE_quantified_atom
      atom: !!perl/hash:RE_bracket
        re: !!perl/hash:RE_sequence
          zyg:
          - !!perl/hash:RE_method
            name: ws
            rest: ''
          - !!perl/hash:RE_string
            i: 0
            text: of
          - !!perl/hash:RE_method
            name: ws
            rest: ''
          - !!perl/hash:RE_method
            name: typename
            rest: ''
      quant:
      - '?'
typename_0: *123
unitstart: !!perl/hash:RE_ast
  dba: unitstart
  dic: STD::P6
  re: !!perl/hash:RE_assertion
    assert: '?'
    re: !!perl/hash:RE_noop
      nobind: 1
value__S_135quote: !!perl/hash:RE_ast
  dba: value
  dic: STD::P6
  re: !!perl/hash:RE_method
    name: quote
    rest: ''
value__S_136number: !!perl/hash:RE_ast
  dba: value
  dic: STD::P6
  re: !!perl/hash:RE_method
    name: number
    rest: ''
value__S_137version: !!perl/hash:RE_ast
  dba: value
  dic: STD::P6
  re: !!perl/hash:RE_method
    name: version
    rest: ''
variable: !!perl/hash:RE_ast
  dba: variable
  dic: STD::P6
  re: !!perl/hash:RE_sequence
    zyg:
    - !!perl/hash:RE_assertion
      assert: '?'
      re: !!perl/hash:RE_method_re
        name: before
        nobind: 1
        re: !!perl/hash:RE_sequence
          zyg:
          - !!perl/hash:RE_method
            name: sigil
            rest: ''
          - !!perl/hash:RE_block {}
    - !!perl/hash:RE_block {}
    - !!perl/hash:RE_bracket
      re: !!perl/hash:RE_first
        zyg:
        - !!perl/hash:RE_sequence
          zyg:
          - !!perl/hash:RE_method
            name: sigil
            rest: ''
          - !!perl/hash:RE_quantified_atom
            atom: !!perl/hash:RE_method
              name: twigil
              rest: ''
            quant:
            - '?'
          - !!perl/hash:RE_assertion
            assert: '?'
            re: !!perl/hash:RE_method_re
              name: before
              nobind: 1
              re: !!perl/hash:RE_sequence
                zyg:
                - !!perl/hash:RE_string
                  i: 0
                  text: '::'
                - !!perl/hash:RE_bracket
                  re: &124 !!perl/hash:RE_any
                    altname: variable_0
                    dba: variable
                    dic: STD::P6
                    zyg:
                    - !!perl/hash:RE_string
                      alt: variable_0 0
                      i: 0
                      text: '{'
                    - !!perl/hash:RE_string
                      alt: variable_0 1
                      i: 0
                      text: <
                    - !!perl/hash:RE_string
                      alt: variable_0 2
                      i: 0
                      text: (
          - !!perl/hash:RE_method
            name: longname
            rest: ''
        - !!perl/hash:RE_sequence
          zyg:
          - !!perl/hash:RE_string
            i: 0
            text: '&'
          - !!perl/hash:RE_bracket
            re: &125 !!perl/hash:RE_any
              altname: variable_1
              dba: infix noun
              dic: STD::P6
              zyg:
              - !!perl/hash:RE_sequence
                alt: variable_1 0
                zyg:
                - !!perl/hash:RE_quantified_atom
                  atom: !!perl/hash:RE_method
                    name: twigil
                    rest: ''
                  quant:
                  - '?'
                - !!perl/hash:RE_method
                  name: sublongname
                  rest: ''
                - !!perl/hash:RE_block {}
              - !!perl/hash:RE_bracket
                alt: variable_1 1
                re: !!perl/hash:RE_sequence
                  zyg:
                  - !!perl/hash:RE_string
                    i: 0
                    text: '['
                  - !!perl/hash:RE_block {}
                  - !!perl/hash:RE_method
                    name: infixish
                    rest: 1
                  - !!perl/hash:RE_bracket
                    re: !!perl/hash:RE_first
                      zyg:
                      - !!perl/hash:RE_string
                        i: 0
                        text: ']'
                      - !!perl/hash:RE_method
                        name: FAILGOAL
                        rest: 1
        - !!perl/hash:RE_sequence
          zyg:
          - !!perl/hash:RE_string
            i: 0
            text: '$::'
          - !!perl/hash:RE_quantified_atom
            atom: !!perl/hash:RE_method
              name: name
              rest: ''
            quant:
            - '?'
        - !!perl/hash:RE_sequence
          zyg:
          - !!perl/hash:RE_string
            i: 0
            text: '$:'
          - !!perl/hash:RE_method
            name: name
            rest: ''
        - !!perl/hash:RE_bracket
          re: &126 !!perl/hash:RE_any
            altname: variable_2
            dba: variable
            dic: STD::P6
            zyg:
            - !!perl/hash:RE_sequence
              alt: variable_2 0
              zyg:
              - !!perl/hash:RE_method
                name: sigil
                rest: ''
              - !!perl/hash:RE_quantified_atom
                atom: !!perl/hash:RE_method
                  name: twigil
                  rest: ''
                quant:
                - '?'
              - !!perl/hash:RE_method
                name: desigilname
                rest: ''
              - !!perl/hash:RE_block {}
            - !!perl/hash:RE_method
              alt: variable_2 1
              name: special_variable
              rest: ''
            - !!perl/hash:RE_sequence
              alt: variable_2 2
              zyg:
              - !!perl/hash:RE_method
                name: sigil
                rest: ''
              - !!perl/hash:RE_bindnamed
                atom: !!perl/hash:RE_method
                  name: decint
                  rest: ''
              - !!perl/hash:RE_quantified_atom
                atom: !!perl/hash:RE_bracket
                  re: !!perl/hash:RE_sequence
                    zyg:
                    - !!perl/hash:RE_assertion
                      assert: '?'
                      re: !!perl/hash:RE_block
                        nobind: 1
                    - !!perl/hash:RE_method
                      name: panic
                      rest: 1
                quant:
                - '?'
            - !!perl/hash:RE_sequence
              alt: variable_2 3
              zyg:
              - !!perl/hash:RE_method
                name: sigil
                rest: ''
              - !!perl/hash:RE_assertion
                assert: '?'
                re: !!perl/hash:RE_method_re
                  name: before
                  nobind: 1
                  re: !!perl/hash:RE_string
                    i: 0
                    text: <
              - !!perl/hash:RE_method
                name: postcircumfix
                rest: ''
              - !!perl/hash:RE_quantified_atom
                atom: !!perl/hash:RE_bracket
                  re: !!perl/hash:RE_sequence
                    zyg:
                    - !!perl/hash:RE_assertion
                      assert: '?'
                      re: !!perl/hash:RE_block
                        nobind: 1
                    - !!perl/hash:RE_method
                      name: panic
                      rest: 1
                quant:
                - '?'
            - !!perl/hash:RE_sequence
              alt: variable_2 4
              zyg:
              - !!perl/hash:RE_method
                name: sigil
                rest: ''
              - !!perl/hash:RE_assertion
                assert: '?'
                re: !!perl/hash:RE_method_re
                  name: before
                  nobind: 1
                  re: !!perl/hash:RE_string
                    i: 0
                    text: (
              - !!perl/hash:RE_method
                name: postcircumfix
                rest: ''
              - !!perl/hash:RE_quantified_atom
                atom: !!perl/hash:RE_bracket
                  re: !!perl/hash:RE_sequence
                    zyg:
                    - !!perl/hash:RE_assertion
                      assert: '?'
                      re: !!perl/hash:RE_block
                        nobind: 1
                    - !!perl/hash:RE_method
                      name: panic
                      rest: 1
                quant:
                - '?'
            - !!perl/hash:RE_sequence
              alt: variable_2 5
              zyg:
              - !!perl/hash:RE_method
                name: sigil
                rest: ''
              - !!perl/hash:RE_assertion
                assert: '?'
                re: !!perl/hash:RE_block
                  nobind: 1
            - !!perl/hash:RE_sequence
              alt: variable_2 6
              zyg:
              - !!perl/hash:RE_assertion
                assert: '?'
                re: !!perl/hash:RE_noop
                  nobind: 1
              - !!perl/hash:RE_block {}
    - !!perl/hash:RE_block {}
    - !!perl/hash:RE_quantified_atom
      atom: !!perl/hash:RE_bracket
        re: !!perl/hash:RE_sequence
          zyg:
          - !!perl/hash:RE_assertion
            assert: '?'
            re: !!perl/hash:RE_block
              nobind: 1
          - !!perl/hash:RE_bracket
            re: &127 !!perl/hash:RE_any
              altname: variable_3
              dba: variable
              dic: STD::P6
              zyg:
              - !!perl/hash:RE_method
                alt: variable_3 0
                name: unsp
                rest: ''
              - !!perl/hash:RE_string
                alt: variable_3 1
                i: 0
                text: \
              - !!perl/hash:RE_assertion
                alt: variable_3 2
                assert: '?'
                re: !!perl/hash:RE_noop
                  nobind: 1
          - !!perl/hash:RE_assertion
            assert: '?'
            re: !!perl/hash:RE_method_re
              name: before
              nobind: 1
              re: !!perl/hash:RE_string
                i: 0
                text: (
          - !!perl/hash:RE_method
            name: postcircumfix
            rest: ''
      quant:
      - '?'
variable_0: *124
variable_1: *125
variable_2: *126
variable_3: *127
variable_declarator: !!perl/hash:RE_ast
  dba: variable_declarator
  dic: STD::P6
  re: !!perl/hash:RE_sequence
    zyg:
    - !!perl/hash:RE_method
      name: variable
      rest: ''
    - !!perl/hash:RE_block {}
    - !!perl/hash:RE_quantified_atom
      atom: !!perl/hash:RE_bracket
        re: !!perl/hash:RE_sequence
          zyg:
          - !!perl/hash:RE_quantified_atom
            atom: !!perl/hash:RE_method
              name: unsp
              rest: ''
            quant:
            - '?'
          - !!perl/hash:RE_bindnamed
            atom: !!perl/hash:RE_quantified_atom
              atom: !!perl/hash:RE_bracket
                re: &128 !!perl/hash:RE_any
                  altname: variable_declarator_0
                  dba: shape definition
                  dic: STD::P6
                  zyg:
                  - !!perl/hash:RE_sequence
                    alt: variable_declarator_0 0
                    zyg:
                    - !!perl/hash:RE_bracket
                      re: !!perl/hash:RE_sequence
                        zyg:
                        - !!perl/hash:RE_string
                          i: 0
                          text: (
                        - !!perl/hash:RE_block {}
                        - !!perl/hash:RE_method
                          name: signature
                          rest: ''
                        - !!perl/hash:RE_bracket
                          re: !!perl/hash:RE_first
                            zyg:
                            - !!perl/hash:RE_string
                              i: 0
                              text: )
                            - !!perl/hash:RE_method
                              name: FAILGOAL
                              rest: 1
                    - !!perl/hash:RE_block {}
                  - !!perl/hash:RE_bracket
                    alt: variable_declarator_0 1
                    re: !!perl/hash:RE_sequence
                      zyg:
                      - !!perl/hash:RE_string
                        i: 0
                        text: '['
                      - !!perl/hash:RE_block {}
                      - !!perl/hash:RE_method
                        name: semilist
                        rest: ''
                      - !!perl/hash:RE_bracket
                        re: !!perl/hash:RE_first
                          zyg:
                          - !!perl/hash:RE_string
                            i: 0
                            text: ']'
                          - !!perl/hash:RE_method
                            name: FAILGOAL
                            rest: 1
                  - !!perl/hash:RE_sequence
                    alt: variable_declarator_0 2
                    zyg:
                    - !!perl/hash:RE_bracket
                      re: !!perl/hash:RE_sequence
                        zyg:
                        - !!perl/hash:RE_string
                          i: 0
                          text: '{'
                        - !!perl/hash:RE_block {}
                        - !!perl/hash:RE_method
                          name: semilist
                          rest: ''
                        - !!perl/hash:RE_bracket
                          re: !!perl/hash:RE_first
                            zyg:
                            - !!perl/hash:RE_string
                              i: 0
                              text: '}'
                            - !!perl/hash:RE_method
                              name: FAILGOAL
                              rest: 1
                    - !!perl/hash:RE_method
                      name: curlycheck
                      rest: ''
                  - !!perl/hash:RE_sequence
                    alt: variable_declarator_0 3
                    zyg:
                    - !!perl/hash:RE_assertion
                      assert: '?'
                      re: !!perl/hash:RE_method_re
                        name: before
                        nobind: 1
                        re: !!perl/hash:RE_string
                          i: 0
                          text: <
                    - !!perl/hash:RE_method
                      name: postcircumfix
                      rest: ''
              quant:
              - '*'
      quant:
      - '?'
    - !!perl/hash:RE_method
      name: ws
      rest: ''
    - !!perl/hash:RE_quantified_atom
      atom: !!perl/hash:RE_method
        name: trait
        rest: ''
      quant:
      - '*'
    - !!perl/hash:RE_quantified_atom
      atom: !!perl/hash:RE_method
        name: post_constraint
        rest: ''
      quant:
      - '*'
    - !!perl/hash:RE_method
      name: getdecl
      rest: ''
variable_declarator_0: *128
version__S_040v: !!perl/hash:RE_ast
  dba: version
  dic: STD::P6
  re: !!perl/hash:RE_sequence
    zyg:
    - !!perl/hash:RE_string
      i: 0
      text: v
    - !!perl/hash:RE_assertion
      assert: '?'
      re: !!perl/hash:RE_method_re
        name: before
        nobind: 1
        re: !!perl/hash:RE_quantified_atom
          atom: !!perl/hash:RE_meta
            min: 1
            text: \d
          quant:
          - +
    - !!perl/hash:RE_meta
      text: '::'
    - !!perl/hash:RE_quantified_atom
      atom: !!perl/hash:RE_method
        name: vnum
        rest: ''
      quant:
      - '**'
      - ':'
      - !!perl/hash:RE_string
        a: 0
        dba: version
        dic: STD::P6
        i: 0
        i_needed: 1
        r: 1
        s: 0
        text: .
    - !!perl/hash:RE_quantified_atom
      atom: !!perl/hash:RE_string
        i: 0
        text: +
      quant:
      - '?'
vnum: !!perl/hash:RE_ast
  dba: vnum
  dic: STD::P6
  re: &129 !!perl/hash:RE_any
    altname: vnum_0
    dba: vnum
    dic: STD::P6
    zyg:
    - !!perl/hash:RE_quantified_atom
      alt: vnum_0 0
      atom: !!perl/hash:RE_meta
        min: 1
        text: \d
      quant:
      - +
    - !!perl/hash:RE_string
      alt: vnum_0 1
      i: 0
      text: '*'
vnum_0: *129
xblock: !!perl/hash:RE_ast
  dba: xblock
  dic: STD::P6
  re: !!perl/hash:RE_sequence
    zyg:
    - !!perl/hash:RE_method
      name: EXPR
      rest: ''
    - !!perl/hash:RE_block {}
    - !!perl/hash:RE_method
      name: ws
      rest: ''
    - !!perl/hash:RE_method
      name: pblock
      rest: ''
RETREE_END
## rule comp_unit {
sub comp_unit__PEEK { $_[0]->_AUTOLEXpeek('comp_unit', $retree) }
sub comp_unit {
no warnings 'recursion';
my $self = shift;

local $::begin_compunit = 1;local $::endargs = -1;local %::LANG;local $::PKGDECL = "";local $::IN_DECL = '';local $::DECLARAND;local $::OFTYPE;local $::NEWPKG;local $::NEWLEX;local $::QSIGIL = '';local $::IN_META = '';local $::QUASIMODO;local $::SCOPE = "";local $::LEFTSIGIL;local $::PRECLIM;local %::MYSTERY = ();local $::INVOCANT_OK;local $::INVOCANT_IS;local $::CURLEX;local $::MULTINESS = '';local $::SIGNUM = 0;local $::MONKEY_TYPING = 0;local %::WORRIES;local @::WORRIES;local $::FATALS = 0;local $::IN_SUPPOSE = 0;local $::CURPKG;
local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;

my $C = $self->cursor_xact("RULE comp_unit");
my $xact = $C->xact;
my $S = $C->{'_pos'};
$self->_MATCHIFYr($S, "comp_unit", do {
my $C = $C;
if (($C) = ($C->ws)
and ($C) = (scalar(do {
{
$::LANG{'MAIN'}    = 'STD::P6' ;
$::LANG{'Q'}       = 'STD::Q' ;
$::LANG{'Quasi'}   = 'STD::Quasi' ;
$::LANG{'Regex'}   = 'STD::Regex' ;
$::LANG{'P5'}      = 'STD::P5' ;
$::LANG{'P5Regex'} = 'STD::P5::Regex' ;
@::WORRIES = ();
$self->load_setting($::SETTINGNAME);
my $oid = $::SETTING->id;
my $id = 'MY:file<' . $::FILE->{'name'} . '>';
$::CURLEX = Stash->new(
'OUTER::' => [$oid],
'!file' => $::FILE, '!line' => 0,
'!id' => [$id],
);
$ALL->{$id} = $::CURLEX;
$::UNIT = $::CURLEX;
$ALL->{'UNIT'} = $::UNIT;
$self->finishlex;
}}, $C))
and ($C) = ($C->unitstart)
and ($C) = ($C->ws)
and ($C) = ($C->_SUBSUMEr(['statementlist'], sub {
my $C = shift;
$C->statementlist
}))
and ($C) = ($C->ws)
and ($C) = ($C->_BRACKETr(sub {
my $C=shift;
do {    my $C = $C->cursor_xact('ALT ||');
my $xact = $C->xact;
my @gather;
do {
push @gather, do {
if (my ($C) = ($C->before(sub {
my $C=shift;
if (my ($C) = ($C->unitstopper)) { ($C) } else { () }
}))) { ($C) } else { () }

}
}
or $xact->[-2] or
do {
push @gather, do {
my $C = $C;
if (($C) = ($C->panic("Confused"))
and ($C) = ($C->ws)) {
$C
} else { () }

}
};
@gather;
}
}))) {
scalar(do {
{
$C->explain_mystery();
$C->{'LEX'} = $::CURLEX;
if (@::WORRIES) {
print STDERR "Potential difficulties:\n  " . join( "\n  ", @::WORRIES) . "\n"};
die "Check failed\n" if $::FATALS;
}}, $C)
} else { () }

});
}
;
## token pblock () {
sub pblock__PEEK { $_[0]->_AUTOLEXpeek('pblock', $retree) }
sub pblock {
no warnings 'recursion';
my $self = shift;

local $::CURLEX = $::CURLEX;
local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;

my $C = $self->cursor_xact("RULE pblock");
my $xact = $C->xact;
my $S = $C->{'_pos'};
$self->_MATCHIFYr($S, "pblock", do {
my $C = $C;
if (($C) = ($C->_BRACKETr(sub {
my $C=shift;
do {    my $C = $C->cursor_xact('ALT ||');
my $xact = $C->xact;
my @gather;
do {
push @gather, do {
if (my ($C) = ($C->before(sub {
my $C=shift;
if (my ($C) = ($C->before(sub {
my $C=shift;
if (my ($C) = (do {
do {
my ($tag, $try);
my @try;
my $relex;

my $fate;
my $x;
if ($fate = $C->{'_fate'} and $fate->[1] eq 'pblock_0') {
$C->deb("Fate passed to pblock_0: ", ::fatestr($fate)) if $::DEBUG & DEBUG::fates;
($C->{'_fate'}, $tag, $try) = @$fate;
@try = ($try);
$x = 'ALT pblock_0';    # some outer ltm is controlling us
}
else {
$x = 'ALTLTM pblock_0'; # we are top level ltm
}
my $C = $C->cursor_xact($x);
my $xact = $C->{_xact};

my @gather = ();
for (;;) {
unless (@try) {
$relex //= $C->cursor_fate('STD::P6', 'pblock_0', $retree);
@try = $relex->($C) or last;
}
$try = shift(@try) // next;

if (ref $try) {
($C->{'_fate'}, $tag, $try) = @$try;   # next candidate fate
}

$C->deb("pblock_0 trying $tag $try") if $::DEBUG & DEBUG::try_processing;
push @gather, ((
sub {
my $C=shift;
if (my ($C) = ($C->lambda)) { ($C) } else { () }
},
sub {
my $C=shift;
$C->_EXACT("\{")
}
)[$try])->($C);
last if @gather;
last if $xact->[-2];  # committed?
}
@gather;
};

})) { ($C) } else { () }
}))) { ($C) } else { () }
}))) { ($C) } else { () }

}
}
or $xact->[-2] or
do {
push @gather, scalar(do {
{
if ($::BORG and $::BORG->{'block'}) {
if ($::BORG->{'name'}) {
my $m = "Function '" . $::BORG->{'name'} . "' needs parens to avoid gobbling block" . $::BORG->{'culprit'}->locmess;
$::BORG->{'block'}->panic($m . "\nMissing block (apparently gobbled by '" . $::BORG->{'name'} . "')");
}
else {
my $m = "Expression needs parens to avoid gobbling block" . $::BORG->{'culprit'}->locmess;
$::BORG->{'block'}->panic($m . "\nMissing block (apparently gobbled by expression)");
}}
elsif (%::MYSTERY) {
$C->panic("Missing block (apparently gobbled by undeclared routine?)")}
else {
$C->panic("Missing block")}}}, $C)
};
@gather;
}
}))
and ($C) = ($C->_BRACKETr(sub {
my $C=shift;
do {
my ($tag, $try);
my @try;
my $relex;

my $fate;
my $x;
if ($fate = $C->{'_fate'} and $fate->[1] eq 'pblock_1') {
$C->deb("Fate passed to pblock_1: ", ::fatestr($fate)) if $::DEBUG & DEBUG::fates;
($C->{'_fate'}, $tag, $try) = @$fate;
@try = ($try);
$x = 'ALT pblock_1';    # some outer ltm is controlling us
}
else {
$x = 'ALTLTM pblock_1'; # we are top level ltm
}
my $C = $C->cursor_xact($x);
my $xact = $C->{_xact};

my @gather = ();
for (;;) {
unless (@try) {
$relex //= $C->cursor_fate('STD::P6', 'pblock_1', $retree);
@try = $relex->($C) or last;
}
$try = shift(@try) // next;

if (ref $try) {
($C->{'_fate'}, $tag, $try) = @$try;   # next candidate fate
}

$C->deb("pblock_1 trying $tag $try") if $::DEBUG & DEBUG::try_processing;
push @gather, ((
sub {
my $C=shift;
if (($C) = ($C->_SUBSUMEr(['lambda'], sub {
my $C = shift;
$C->lambda
}))
and ($C) = ($C->newlex(1))
and ($C) = ($C->_SUBSUMEr(['signature'], sub {
my $C = shift;
$C->signature(1)
}))
and ($C) = ($C->_SUBSUMEr(['blockoid'], sub {
my $C = shift;
$C->blockoid
}))
and ($C) = ($C->getsig)) {
$C
} else { () }
},
sub {
my $C=shift;
if (($C) = ($C->before(sub {
my $C=shift;
if (my ($C) = ($C->before(sub {
my $C=shift;
$C->_EXACT("\{")
}))) { ($C) } else { () }
}))
and ($C) = ($C->newlex(1))
and ($C) = ($C->_SUBSUMEr(['blockoid'], sub {
my $C = shift;
$C->blockoid
}))
and ($C) = ($C->getsig)) {
$C
} else { () }
}
)[$try])->($C);
last if @gather;
last if $xact->[-2];  # committed?
}
@gather;
};
}))) {
$C
} else { () }

});
}
;
## token unitstart { <?> }
sub unitstart__PEEK { $_[0]->_AUTOLEXpeek('unitstart', $retree) }
sub unitstart {
no warnings 'recursion';
my $self = shift;


local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;

my $C = $self->cursor_xact("RULE unitstart");
my $xact = $C->xact;
my $S = $C->{'_pos'};
$self->_MATCHIFYr($S, "unitstart", $C->before(sub {
my $C=shift;
$C
}));
}
;
## token lambda { '->' | '<->' }
sub lambda__PEEK { $_[0]->_AUTOLEXpeek('lambda', $retree) }
sub lambda {
no warnings 'recursion';
my $self = shift;


local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;

my $C = $self->cursor_xact("RULE lambda");
my $xact = $C->xact;
my $S = $C->{'_pos'};
$self->_MATCHIFYr($S, "lambda", do {
do {
my ($tag, $try);
my @try;
my $relex;

my $fate;
my $x;
if ($fate = $C->{'_fate'} and $fate->[1] eq 'lambda_0') {
$C->deb("Fate passed to lambda_0: ", ::fatestr($fate)) if $::DEBUG & DEBUG::fates;
($C->{'_fate'}, $tag, $try) = @$fate;
@try = ($try);
$x = 'ALT lambda_0';    # some outer ltm is controlling us
}
else {
$x = 'ALTLTM lambda_0'; # we are top level ltm
}
my $C = $C->cursor_xact($x);
my $xact = $C->{_xact};

my @gather = ();
for (;;) {
unless (@try) {
$relex //= $C->cursor_fate('STD::P6', 'lambda_0', $retree);
@try = $relex->($C) or last;
}
$try = shift(@try) // next;

if (ref $try) {
($C->{'_fate'}, $tag, $try) = @$try;   # next candidate fate
}

$C->deb("lambda_0 trying $tag $try") if $::DEBUG & DEBUG::try_processing;
push @gather, ((
sub {
my $C=shift;
$C->_EXACT("\-\>")
},
sub {
my $C=shift;
$C->_EXACT("\<\-\>")
}
)[$try])->($C);
last if @gather;
last if $xact->[-2];  # committed?
}
@gather;
};

});
}
;
## token xblock {
sub xblock__PEEK { $_[0]->_AUTOLEXpeek('xblock', $retree) }
sub xblock {
no warnings 'recursion';
my $self = shift;

local $::GOAL = '{';local $::BORG = {
};
local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;

my $C = $self->cursor_xact("RULE xblock");
my $xact = $C->xact;
my $S = $C->{'_pos'};
$self->_MATCHIFYr($S, "xblock", do {
my $C = $C;
if (($C) = ($C->_SUBSUMEr(['EXPR'], sub {
my $C = shift;
$C->EXPR
}))
and ($C) = (scalar(do {
my $M = $C;
$::BORG->{'culprit'} //= $M->{'EXPR'}->cursor($self->{'_pos'}) }, $C))
and ($C) = ($C->ws)) {
$C->_SUBSUMEr(['pblock'], sub {
my $C = shift;
$C->pblock
})
} else { () }

});
}
;
## token block () {
sub block__PEEK { $_[0]->_AUTOLEXpeek('block', $retree) }
sub block {
no warnings 'recursion';
my $self = shift;

local $::CURLEX = $::CURLEX;
local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;

my $C = $self->cursor_xact("RULE block");
my $xact = $C->xact;
my $S = $C->{'_pos'};
$self->_MATCHIFYr($S, "block", do {
my $C = $C;
if (($C) = ($C->_BRACKETr(sub {
my $C=shift;
do {    my $C = $C->cursor_xact('ALT ||');
my $xact = $C->xact;
my @gather;
do {
push @gather, do {
if (my ($C) = ($C->before(sub {
my $C=shift;
if (my ($C) = ($C->before(sub {
my $C=shift;
$C->_EXACT("\{")
}))) { ($C) } else { () }
}))) { ($C) } else { () }

}
}
or $xact->[-2] or
do {
push @gather, do {
if (my ($C) = ($C->panic("Missing block"))) { ($C) } else { () }

}
};
@gather;
}
}))
and ($C) = ($C->newlex)
and ($C) = ($C->_SUBSUMEr(['blockoid'], sub {
my $C = shift;
$C->blockoid
}))
and ($C) = ($C->checkyada)) {
$C
} else { () }

});
}
;
## token blockoid {
sub blockoid__PEEK { $_[0]->_AUTOLEXpeek('blockoid', $retree) }
sub blockoid {
no warnings 'recursion';
my $self = shift;

local %::LANG = %::LANG;local $::SIGNUM;
local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;

my $C = $self->cursor_xact("RULE blockoid");
my $xact = $C->xact;
my $S = $C->{'_pos'};
$self->_MATCHIFYr($S, "blockoid", do {
my $C = $C;
if (($C) = ($C->finishlex)
and ($C) = ($C->_BRACKETr(sub {
my $C=shift;
do {
my ($tag, $try);
my @try;
my $relex;

my $fate;
my $x;
if ($fate = $C->{'_fate'} and $fate->[1] eq 'blockoid_0') {
$C->deb("Fate passed to blockoid_0: ", ::fatestr($fate)) if $::DEBUG & DEBUG::fates;
($C->{'_fate'}, $tag, $try) = @$fate;
@try = ($try);
$x = 'ALT blockoid_0';    # some outer ltm is controlling us
}
else {
$x = 'ALTLTM blockoid_0'; # we are top level ltm
}
my $C = $C->cursor_xact($x);
my $xact = $C->{_xact};

my @gather = ();
for (;;) {
unless (@try) {
$relex //= $C->cursor_fate('STD::P6', 'blockoid_0', $retree);
@try = $relex->($C) or last;
}
$try = shift(@try) // next;

if (ref $try) {
($C->{'_fate'}, $tag, $try) = @$try;   # next candidate fate
}

$C->deb("blockoid_0 trying $tag $try") if $::DEBUG & DEBUG::try_processing;
push @gather, ((
sub {
my $C=shift;
if (($C) = ($C->_EXACT("\{YOU_ARE_HERE\}"))
and ($C) = ($C->you_are_here)) {
$C
} else { () }
},
sub {
my $C=shift;
if (($C) = ($C->_BRACKETr(sub {
my $C=shift;
local $::GOAL = "\}";
my $goalpos = $C;
if (($C) = ($C->_EXACT("\{"))
and ($C) = (scalar(do {
}, $C))
and ($C) = ($C->_SUBSUMEr(['statementlist'], sub {
my $C = shift;
$C->statementlist
}))
and ($C) = ($C->_BRACKETr(sub {
my $C=shift;
do {    my $C = $C->cursor_xact('ALT ||');
my $xact = $C->xact;
my @gather;
do {
push @gather, $C->_EXACT("\}")
}
or $xact->[-2] or
do {
push @gather, do {
if (my ($C) = ($C->FAILGOAL($::GOAL, 'block', $goalpos))) { ($C) } else { () }

}
};
@gather;
}
}))) {
$C
} else { () }
}))
and ($C) = ($C->_COMMITLTM())
and ($C) = ($C->curlycheck)) {
$C
} else { () }
},
sub {
my $C=shift;
if (($C) = ($C->before(sub {
my $C=shift;
if (my ($C) = ($C->terminator)) { ($C) } else { () }
}))
and ($C) = ($C->panic('Missing block'))) {
$C
} else { () }
},
sub {
my $C=shift;
if (($C) = ($C->before(sub {
my $C=shift;
$C
}))
and ($C) = ($C->panic("Malformed block"))) {
$C
} else { () }
}
)[$try])->($C);
last if @gather;
last if $xact->[-2];  # committed?
}
@gather;
};
}))) {
$C
} else { () }

});
}
;
## token curlycheck {
sub curlycheck__PEEK { $_[0]->_AUTOLEXpeek('curlycheck', $retree) }
sub curlycheck {
no warnings 'recursion';
my $self = shift;


local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;

my $C = $self->cursor_xact("RULE curlycheck");
my $xact = $C->xact;
my $S = $C->{'_pos'};
$self->_MATCHIFYr($S, "curlycheck", $C->_BRACKETr(sub {
my $C=shift;
do {    my $C = $C->cursor_xact('ALT ||');
my $xact = $C->xact;
my @gather;
do {
push @gather, do {
if (my ($C) = ($C->before(sub {
my $C=shift;
if (my ($C) = ($C->before(sub {
my $C=shift;
$C->_PATTERN(qr/\G[\x20\t\r]*+(?m:$)/)
}))) { ($C) } else { () }
}))) {
scalar(do {
$::MEMOS[$C->{'_pos'}]->{'endstmt'} = 2}, $C)
} else { () }

}
}
or $xact->[-2] or
do {
push @gather, do {
if (my ($C) = ($C->before(sub {
my $C=shift;
if (my ($C) = ($C->before(sub {
my $C=shift;
$C->_PATTERN(qr/\G[\x20\t\r]*+[\\,:]/)
}))) { ($C) } else { () }
}))) { ($C) } else { () }

}
}
or $xact->[-2] or
do {
push @gather, do {
my $C = $C;
if (($C) = ($C->unv)
and ($C) = ($C->_PATTERN(qr/\G(?m:$)/))) {
scalar(do {
$::MEMOS[$C->{'_pos'}]->{'endstmt'} = 2}, $C)
} else { () }

}
}
or $xact->[-2] or
do {
push @gather, do {
if (my ($C) = ($C->_OPTr(sub {
my $C=shift;
if (my ($C) = ($C->unsp)) { ($C) } else { () }
}))) {
scalar(do {
$::MEMOS[$C->{'_pos'}]->{'endargs'} = 1}, $C)
} else { () }

}
};
@gather;
}
}));
}
;
## token regex_block {
sub regex_block__PEEK { $_[0]->_AUTOLEXpeek('regex_block', $retree) }
sub regex_block {
no warnings 'recursion';
my $self = shift;

local %::LANG = %::LANG;local %::RX = %::RX;my $lang = $::LANG{'Regex'};local $::GOAL = '}';
local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;

my $C = $self->cursor_xact("RULE regex_block");
my $xact = $C->xact;
my $S = $C->{'_pos'};
$C->{'quotepair'} = [];
$self->_MATCHIFYr($S, "regex_block", do {
my $C = $C;
if (($C) = ($C->_STARr(sub {
my $C=shift;
if (my ($C) = ($C->_BRACKETr(sub {
my $C=shift;
if (($C) = ($C->_SUBSUMEr(['quotepair'], sub {
my $C = shift;
$C->quotepair
}))
and ($C) = ($C->ws)) {
scalar(do {
my $M = $C;
my $kv = $M->{'quotepair'}->[-1];
$lang = ($lang->tweak($kv->{'k'}, $kv->{'v'})
or $lang->panic("Unrecognized adverb :" . $kv->{'k'} . '(' . $kv->{'v'} . ')'));
}, $C)
} else { () }
}))) { ($C) } else { () }
}))
and ($C) = ($C->_BRACKETr(sub {
my $C=shift;
do {
my ($tag, $try);
my @try;
my $relex;

my $fate;
my $x;
if ($fate = $C->{'_fate'} and $fate->[1] eq 'regex_block_0') {
$C->deb("Fate passed to regex_block_0: ", ::fatestr($fate)) if $::DEBUG & DEBUG::fates;
($C->{'_fate'}, $tag, $try) = @$fate;
@try = ($try);
$x = 'ALT regex_block_0';    # some outer ltm is controlling us
}
else {
$x = 'ALTLTM regex_block_0'; # we are top level ltm
}
my $C = $C->cursor_xact($x);
my $xact = $C->{_xact};

my @gather = ();
for (;;) {
unless (@try) {
$relex //= $C->cursor_fate('STD::P6', 'regex_block_0', $retree);
@try = $relex->($C) or last;
}
$try = shift(@try) // next;

if (ref $try) {
($C->{'_fate'}, $tag, $try) = @$try;   # next candidate fate
}

$C->deb("regex_block_0 trying $tag $try") if $::DEBUG & DEBUG::try_processing;
push @gather, ((
sub {
my $C=shift;
if (($C) = ($C->_EXACT("\{\*\}"))
and ($C) = ($C->before(sub {
my $C=shift;
(($C) x !!do {
$::MULTINESS eq 'proto' })
}))) {
scalar(do {
$C->{'onlystar'} = 1 }, $C)
} else { () }
},
sub {
my $C=shift;
if (my ($C) = ($C->_BRACKETr(sub {
my $C=shift;
if (($C) = ($C->_EXACT("\{"))
and ($C) = ($C->_SUBSUMEr(['nibble'], sub {
my $C = shift;
$C->nibble( $C->cursor_fresh($lang)->unbalanced('}') )
}))
and ($C) = ($C->_BRACKETr(sub {
my $C=shift;
do {    my $C = $C->cursor_xact('ALT ||');
my $xact = $C->xact;
my @gather;
do {
push @gather, $C->_EXACT("\}")
}
or $xact->[-2] or
do {
push @gather, do {
if (my ($C) = ($C->panic("Unable to parse regex; couldn't find right brace"))) { ($C) } else { () }

}
};
@gather;
}
}))) {
$C
} else { () }
}))) { ($C) } else { () }
}
)[$try])->($C);
last if @gather;
last if $xact->[-2];  # committed?
}
@gather;
};
}))
and ($C) = ($C->curlycheck)) {
$C
} else { () }

});
}
;
## rule statementlist {
sub statementlist__PEEK { $_[0]->_AUTOLEXpeek('statementlist', $retree) }
sub statementlist {
no warnings 'recursion';
my $self = shift;

local $::INVOCANT_OK = 0;local $::MONKEY_TYPING = $::MONKEY_TYPING;
local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;

my $C = $self->cursor_xact("RULE statementlist");
my $xact = $C->xact;
my $S = $C->{'_pos'};
$C->{'eat_terminator'} = [];
$C->{'statement'} = [];
$self->_MATCHIFYr($S, "statementlist", do {
my $C = $C;
if (($C) = ($C->ws)
and ($C) = ($C->_BRACKETr(sub {
my $C=shift;
do {
my ($tag, $try);
my @try;
my $relex;

my $fate;
my $x;
if ($fate = $C->{'_fate'} and $fate->[1] eq 'statementlist_0') {
$C->deb("Fate passed to statementlist_0: ", ::fatestr($fate)) if $::DEBUG & DEBUG::fates;
($C->{'_fate'}, $tag, $try) = @$fate;
@try = ($try);
$x = 'ALT statementlist_0';    # some outer ltm is controlling us
}
else {
$x = 'ALTLTM statementlist_0'; # we are top level ltm
}
my $C = $C->cursor_xact($x);
my $xact = $C->{_xact};

my @gather = ();
for (;;) {
unless (@try) {
$relex //= $C->cursor_fate('STD::P6', 'statementlist_0', $retree);
@try = $relex->($C) or last;
}
$try = shift(@try) // next;

if (ref $try) {
($C->{'_fate'}, $tag, $try) = @$try;   # next candidate fate
}

$C->deb("statementlist_0 trying $tag $try") if $::DEBUG & DEBUG::try_processing;
push @gather, ((
sub {
my $C=shift;
if (($C) = ($C->_PATTERN(qr/\G\z/))
and ($C) = ($C->ws)) {
$C
} else { () }
},
sub {
my $C=shift;
if (my ($C) = ($C->before(sub {
my $C=shift;
if (my ($C) = ($C->before(sub {
my $C=shift;
if (my ($C) = ($C->ws)) {
$C->_PATTERN(qr/\G[\)\]\}]/)
} else { () }
}))) { ($C) } else { () }
}))) { ($C) } else { () }
},
sub {
my $C=shift;
if (($C) = ($C->_STARr(sub {
my $C=shift;
if (my ($C) = ($C->_BRACKETr(sub {
my $C=shift;
if (($C) = ($C->_SUBSUMEr(['statement'], sub {
my $C = shift;
$C->statement
}))
and ($C) = ($C->_SUBSUMEr(['eat_terminator'], sub {
my $C = shift;
$C->eat_terminator
}))
and ($C) = ($C->ws)) {
$C
} else { () }
}))) { ($C) } else { () }
}))
and ($C) = ($C->ws)) {
scalar(do {
my $M = $C;
$self->mark_sinks($M->{'statement'}) }, $C)
} else { () }
}
)[$try])->($C);
last if @gather;
last if $xact->[-2];  # committed?
}
@gather;
};
}))) {
$C
} else { () }

});
}
;
## rule semilist {
sub semilist__PEEK { $_[0]->_AUTOLEXpeek('semilist', $retree) }
sub semilist {
no warnings 'recursion';
my $self = shift;

local $::INVOCANT_OK = 0;
local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;

my $C = $self->cursor_xact("RULE semilist");
my $xact = $C->xact;
my $S = $C->{'_pos'};
$C->{'eat_terminator'} = [];
$C->{'statement'} = [];
$self->_MATCHIFYr($S, "semilist", do {
my $C = $C;
if (($C) = ($C->ws)
and ($C) = ($C->_BRACKETr(sub {
my $C=shift;
do {
my ($tag, $try);
my @try;
my $relex;

my $fate;
my $x;
if ($fate = $C->{'_fate'} and $fate->[1] eq 'semilist_0') {
$C->deb("Fate passed to semilist_0: ", ::fatestr($fate)) if $::DEBUG & DEBUG::fates;
($C->{'_fate'}, $tag, $try) = @$fate;
@try = ($try);
$x = 'ALT semilist_0';    # some outer ltm is controlling us
}
else {
$x = 'ALTLTM semilist_0'; # we are top level ltm
}
my $C = $C->cursor_xact($x);
my $xact = $C->{_xact};

my @gather = ();
for (;;) {
unless (@try) {
$relex //= $C->cursor_fate('STD::P6', 'semilist_0', $retree);
@try = $relex->($C) or last;
}
$try = shift(@try) // next;

if (ref $try) {
($C->{'_fate'}, $tag, $try) = @$try;   # next candidate fate
}

$C->deb("semilist_0 trying $tag $try") if $::DEBUG & DEBUG::try_processing;
push @gather, ((
sub {
my $C=shift;
if (my ($C) = ($C->before(sub {
my $C=shift;
if (my ($C) = ($C->before(sub {
my $C=shift;
if (my ($C) = ($C->ws)) {
$C->_PATTERN(qr/\G[\)\]\}]/)
} else { () }
}))) { ($C) } else { () }
}))) { ($C) } else { () }
},
sub {
my $C=shift;
if (($C) = ($C->_STARr(sub {
my $C=shift;
if (my ($C) = ($C->_BRACKETr(sub {
my $C=shift;
if (($C) = ($C->_SUBSUMEr(['statement'], sub {
my $C = shift;
$C->statement
}))
and ($C) = ($C->_SUBSUMEr(['eat_terminator'], sub {
my $C = shift;
$C->eat_terminator
}))
and ($C) = ($C->ws)) {
$C
} else { () }
}))) { ($C) } else { () }
}))
and ($C) = ($C->ws)) {
$C
} else { () }
}
)[$try])->($C);
last if @gather;
last if $xact->[-2];  # committed?
}
@gather;
};
}))) {
$C
} else { () }

});
}
;
## token label {
sub label__PEEK { $_[0]->_AUTOLEXpeek('label', $retree) }
sub label {
no warnings 'recursion';
my $self = shift;

my $label;
local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;

my $C = $self->cursor_xact("RULE label");
my $xact = $C->xact;
my $S = $C->{'_pos'};
$self->_MATCHIFYr($S, "label", do {
my $C = $C;
if (($C) = ($C->_SUBSUMEr(['identifier'], sub {
my $C = shift;
$C->identifier
}))
and ($C) = ($C->_EXACT("\:"))
and ($C) = ($C->before(sub {
my $C=shift;
if (my ($C) = ($C->before(sub {
my $C=shift;
$C->_PATTERN(qr/\G\s/)
}))) { ($C) } else { () }
}))
and ($C) = ($C->ws)
and ($C) = ($C->_OPTr(sub {
my $C=shift;
if (my ($C) = ($C->_BRACKETr(sub {
my $C=shift;
if (($C) = ($C->before(sub {
my $C=shift;
(($C) x !!do {
my $M = $C;
$C->is_name($label = $M->{'identifier'}->Str) })
}))
and ($C) = ($C->sorry("Illegal redeclaration of '$label'"))) {
$C
} else { () }
}))) { ($C) } else { () }
}))) {
scalar(do {
{
$C->add_constant($label,$self->label_id)}}, $C)
} else { () }

});
}
;
## token statement {
sub statement__PEEK { $_[0]->_AUTOLEXpeek('statement', $retree) }
sub statement {
no warnings 'recursion';
my $self = shift;

local $::endargs = -1;local $::QSIGIL = 0;
local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;

my $C = $self->cursor_xact("RULE statement");
my $xact = $C->xact;
my $S = $C->{'_pos'};
$C->{'statement_mod_cond'} = [];
$C->{'statement_mod_loop'} = [];
$self->_MATCHIFYr($S, "statement", do {
my $C = $C;
if (($C) = ($C->_NOTBEFORE(sub {
my $C=shift;
if (my ($C) = ($C->before(sub {
my $C=shift;
$C->_PATTERN(qr/\G[\)\]\}]/)
}))) { ($C) } else { () }
}))
and ($C) = ($C->_NOTBEFORE(sub {
my $C=shift;
if (my ($C) = ($C->stopper)) { ($C) } else { () }
}))
and ($C) = ($C->_NOTBEFORE(sub {
my $C=shift;
if (my ($C) = ($C->_NOTBEFORE(sub {
my $C=shift;
(($C) x !!do {
$::LASTSTATE = $C->{'_pos'};
$C = $::LANG{'MAIN'}->bless($C);
})
}))) { ($C) } else { () }
}))
and ($C) = ($C->_BRACKETr(sub {
my $C=shift;
do {
my ($tag, $try);
my @try;
my $relex;

my $fate;
my $x;
if ($fate = $C->{'_fate'} and $fate->[1] eq 'statement_0') {
$C->deb("Fate passed to statement_0: ", ::fatestr($fate)) if $::DEBUG & DEBUG::fates;
($C->{'_fate'}, $tag, $try) = @$fate;
@try = ($try);
$x = 'ALT statement_0';    # some outer ltm is controlling us
}
else {
$x = 'ALTLTM statement_0'; # we are top level ltm
}
my $C = $C->cursor_xact($x);
my $xact = $C->{_xact};

my @gather = ();
for (;;) {
unless (@try) {
$relex //= $C->cursor_fate('STD::P6', 'statement_0', $retree);
@try = $relex->($C) or last;
}
$try = shift(@try) // next;

if (ref $try) {
($C->{'_fate'}, $tag, $try) = @$try;   # next candidate fate
}

$C->deb("statement_0 trying $tag $try") if $::DEBUG & DEBUG::try_processing;
push @gather, ((
sub {
my $C=shift;
if (my ($C) = ($C->_SUBSUMEr(['label'], sub {
my $C = shift;
$C->label
}))) {
$C->_SUBSUMEr(['statement'], sub {
my $C = shift;
$C->statement
})
} else { () }
},
sub {
my $C=shift;
$C->_SUBSUMEr(['statement_control'], sub {
my $C = shift;
$C->statement_control
})
},
sub {
my $C=shift;
if (($C) = ($C->_SUBSUMEr(['EXPR'], sub {
my $C = shift;
$C->EXPR
}))
and ($C) = ($C->_BRACKETr(sub {
my $C=shift;
do {    my $C = $C->cursor_xact('ALT ||');
my $xact = $C->xact;
my @gather;
do {
push @gather, do {
if (my ($C) = ($C->before(sub {
my $C=shift;
(($C) x !!do {
($::MEMOS[$C->{'_pos'}]->{'endstmt'} // 0) == 2 })
}))) { ($C) } else { () }

}
}
or $xact->[-2] or
do {
push @gather, do {
if (my ($C) = ($C->ws)) {
$C->_OPTr(sub {
my $C=shift;
if (my ($C) = ($C->_BRACKETr(sub {
my $C=shift;
do {
my ($tag, $try);
my @try;
my $relex;

my $fate;
my $x;
if ($fate = $C->{'_fate'} and $fate->[1] eq 'statement_1') {
$C->deb("Fate passed to statement_1: ", ::fatestr($fate)) if $::DEBUG & DEBUG::fates;
($C->{'_fate'}, $tag, $try) = @$fate;
@try = ($try);
$x = 'ALT statement_1';    # some outer ltm is controlling us
}
else {
$x = 'ALTLTM statement_1'; # we are top level ltm
}
my $C = $C->cursor_xact($x);
my $xact = $C->{_xact};

my @gather = ();
for (;;) {
unless (@try) {
$relex //= $C->cursor_fate('STD::P6', 'statement_1', $retree);
@try = $relex->($C) or last;
}
$try = shift(@try) // next;

if (ref $try) {
($C->{'_fate'}, $tag, $try) = @$try;   # next candidate fate
}

$C->deb("statement_1 trying $tag $try") if $::DEBUG & DEBUG::try_processing;
push @gather, ((
sub {
my $C=shift;
if (my ($C) = ($C->_SUBSUMEr(['statement_mod_loop'], sub {
my $C = shift;
$C->statement_mod_loop
}))) {
scalar(do {
my $M = $C;
{
my $sp = $M->{'EXPR'}->{'statement_prefix'};
if ($sp and $sp->{'sym'} eq 'do') {
my $s = $M->{'statement_mod_loop'}->[0]->{'sym'};
$C->obs("do...$s" ,"repeat...$s");
};
}}, $C)
} else { () }
},
sub {
my $C=shift;
if (($C) = ($C->_SUBSUMEr(['statement_mod_cond'], sub {
my $C = shift;
$C->statement_mod_cond
}))
and ($C) = ($C->_BRACKETr(sub {
my $C=shift;
do {    my $C = $C->cursor_xact('ALT ||');
my $xact = $C->xact;
my @gather;
do {
push @gather, do {
if (my ($C) = ($C->before(sub {
my $C=shift;
(($C) x !!do {
($::MEMOS[$C->{'_pos'}]->{'endstmt'} // 0) == 2 })
}))) { ($C) } else { () }

}
}
or $xact->[-2] or
do {
push @gather, do {
if (my ($C) = ($C->ws)) {
$C->_OPTr(sub {
my $C=shift;
$C->_SUBSUMEr(['statement_mod_loop'], sub {
my $C = shift;
$C->statement_mod_loop
})
})
} else { () }

}
};
@gather;
}
}))) {
$C
} else { () }
}
)[$try])->($C);
last if @gather;
last if $xact->[-2];  # committed?
}
@gather;
};
}))) { ($C) } else { () }
})
} else { () }

}
};
@gather;
}
}))) {
$C
} else { () }
},
sub {
my $C=shift;
if (my ($C) = ($C->before(sub {
my $C=shift;
if (my ($C) = ($C->before(sub {
my $C=shift;
$C->_EXACT("\;")
}))) { ($C) } else { () }
}))) { ($C) } else { () }
},
sub {
my $C=shift;
if (my ($C) = ($C->before(sub {
my $C=shift;
if (my ($C) = ($C->before(sub {
my $C=shift;
$C->_SUBSUMEr(['stopper'], sub {
my $C = shift;
$C->stopper
})
}))) { ($C) } else { () }
}))) { ($C) } else { () }
},
sub {
my $C=shift;
if (($C) = (scalar(do {
}, $C))
and ($C) = ($C->panic("Bogus statement"))) {
$C
} else { () }
}
)[$try])->($C);
last if @gather;
last if $xact->[-2];  # committed?
}
@gather;
};
}))) {
$C->_OPTr(sub {
my $C=shift;
if (my ($C) = ($C->_BRACKETr(sub {
my $C=shift;
if (($C) = ($C->before(sub {
my $C=shift;
(($C) x !!do {
($::MEMOS[$::MEMOS[$C->{'_pos'}]->{'ws'}//$C->{'_pos'}]->{'endargs'}//0) == 1 })
}))
and ($C) = ($C->_PATTERN(qr/\G[\x20\t\r]*+/))
and ($C) = ($C->_NOTBEFORE(sub {
my $C=shift;
if (my ($C) = ($C->before(sub {
my $C=shift;
if (my ($C) = (do {
do {
my ($tag, $try);
my @try;
my $relex;

my $fate;
my $x;
if ($fate = $C->{'_fate'} and $fate->[1] eq 'statement_2') {
$C->deb("Fate passed to statement_2: ", ::fatestr($fate)) if $::DEBUG & DEBUG::fates;
($C->{'_fate'}, $tag, $try) = @$fate;
@try = ($try);
$x = 'ALT statement_2';    # some outer ltm is controlling us
}
else {
$x = 'ALTLTM statement_2'; # we are top level ltm
}
my $C = $C->cursor_xact($x);
my $xact = $C->{_xact};

my @gather = ();
for (;;) {
unless (@try) {
$relex //= $C->cursor_fate('STD::P6', 'statement_2', $retree);
@try = $relex->($C) or last;
}
$try = shift(@try) // next;

if (ref $try) {
($C->{'_fate'}, $tag, $try) = @$try;   # next candidate fate
}

$C->deb("statement_2 trying $tag $try") if $::DEBUG & DEBUG::try_processing;
push @gather, ((
sub {
my $C=shift;
$C->_EXACT("\;")
},
sub {
my $C=shift;
$C->_EXACT("\)")
},
sub {
my $C=shift;
$C->_EXACT("\]")
},
sub {
my $C=shift;
$C->_EXACT("\}")
}
)[$try])->($C);
last if @gather;
last if $xact->[-2];  # committed?
}
@gather;
};

})) { ($C) } else { () }
}))) { ($C) } else { () }
}))
and ($C) = ($C->_NOTBEFORE(sub {
my $C=shift;
if (my ($C) = ($C->infixstopper)) { ($C) } else { () }
}))
and ($C) = (scalar(do {
$::HIGHWATER = $C->{'_pos'} = $::MEMOS[$C->{'_pos'}]->{'ws'}//$C->{'_pos'}}, $C))
and ($C) = ($C->panic("Strange text after block (missing comma, semicolon, comment marker?)"))) {
$C
} else { () }
}))) { ($C) } else { () }
})
} else { () }

});
}
;
## token eat_terminator {
sub eat_terminator__PEEK { $_[0]->_AUTOLEXpeek('eat_terminator', $retree) }
sub eat_terminator {
no warnings 'recursion';
my $self = shift;


local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;

my $C = $self->cursor_xact("RULE eat_terminator");
my $xact = $C->xact;
my $S = $C->{'_pos'};
$self->_MATCHIFYr($S, "eat_terminator", $C->_BRACKETr(sub {
my $C=shift;
do {    my $C = $C->cursor_xact('ALT ||');
my $xact = $C->xact;
my @gather;
do {
push @gather, $C->_EXACT("\;")
}
or $xact->[-2] or
do {
push @gather, do {
my $C = $C;
if (($C) = ($C->before(sub {
my $C=shift;
(($C) x !!do {
($::MEMOS[$C->{'_pos'}]->{'endstmt'}//0) >= 2 })
}))
and ($C) = ($C->ws)) {
$C
} else { () }

}
}
or $xact->[-2] or
do {
push @gather, do {
if (my ($C) = ($C->before(sub {
my $C=shift;
if (my ($C) = ($C->before(sub {
my $C=shift;
if (my ($C) = (do {
do {
my ($tag, $try);
my @try;
my $relex;

my $fate;
my $x;
if ($fate = $C->{'_fate'} and $fate->[1] eq 'eat_terminator_0') {
$C->deb("Fate passed to eat_terminator_0: ", ::fatestr($fate)) if $::DEBUG & DEBUG::fates;
($C->{'_fate'}, $tag, $try) = @$fate;
@try = ($try);
$x = 'ALT eat_terminator_0';    # some outer ltm is controlling us
}
else {
$x = 'ALTLTM eat_terminator_0'; # we are top level ltm
}
my $C = $C->cursor_xact($x);
my $xact = $C->{_xact};

my @gather = ();
for (;;) {
unless (@try) {
$relex //= $C->cursor_fate('STD::P6', 'eat_terminator_0', $retree);
@try = $relex->($C) or last;
}
$try = shift(@try) // next;

if (ref $try) {
($C->{'_fate'}, $tag, $try) = @$try;   # next candidate fate
}

$C->deb("eat_terminator_0 trying $tag $try") if $::DEBUG & DEBUG::try_processing;
push @gather, ((
sub {
my $C=shift;
$C->_EXACT("\)")
},
sub {
my $C=shift;
$C->_EXACT("\]")
},
sub {
my $C=shift;
$C->_EXACT("\}")
}
)[$try])->($C);
last if @gather;
last if $xact->[-2];  # committed?
}
@gather;
};

})) { ($C) } else { () }
}))) { ($C) } else { () }
}))) { ($C) } else { () }

}
}
or $xact->[-2] or
do {
push @gather, $C->_PATTERN(qr/\G\z/)
}
or $xact->[-2] or
do {
push @gather, do {
if (my ($C) = ($C->before(sub {
my $C=shift;
if (my ($C) = ($C->stopper)) { ($C) } else { () }
}))) { ($C) } else { () }

}
}
or $xact->[-2] or
do {
push @gather, do {
my $C = $C;
if (($C) = ($C->before(sub {
my $C=shift;
if (my ($C) = ($C->before(sub {
my $C=shift;
if (my ($C) = ($C->suppose(sub {
my $C=shift;
$C->_SUBSUMEr(['statement_control'], sub {
my $C = shift;
$C->statement_control
})
}))) { ($C) } else { () }
}))) { ($C) } else { () }
}))
and ($C) = ($C->backup_ws)
and ($C) = (scalar(do {
$::HIGHWATER = -1}, $C))
and ($C) = ($C->panic("Missing semicolon"))) {
$C
} else { () }

}
}
or $xact->[-2] or
do {
push @gather, do {
if (my ($C) = ($C->panic("Confused"))) { ($C) } else { () }

}
};
@gather;
}
}));
}
;
## method backup_ws ()
sub backup_ws {
no warnings 'recursion';
my $self = shift;
if ($::MEMOS[$self->{'_pos'}]->{'ws'}) {
return $self->cursor($::MEMOS[$self->{'_pos'}]->{'ws'})};
return $self;
};
## token statement_control:need {
sub statement_control__S_000need__PEEK { $_[0]->_AUTOLEXpeek('statement_control__S_000need', $retree) }
sub statement_control__S_000need {
no warnings 'recursion';
my $self = shift;

;
my $longname;
local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;

my $C = $self->cursor_xact("RULE statement_control__S_000need");
my $xact = $C->xact;
my $S = $C->{'_pos'};
$C->{'module_name'} = [];
$C->{'version'} = [];
$C->{sym} = "need";
$self->_MATCHIFYr($S, "statement_control__S_000need", do {
my $C = $C;
if (($C) = ($C->_EXACT("need"))
and ($C) = ($C->spacey)
and ($C) = ($C->ws)
and ($C) = ($C->_REPSEPr( sub {
my $C=shift;
$C->_EXACT("\,")
}, sub {
my $C=shift;
if (my ($C) = ($C->_BRACKETr(sub {
my $C=shift;
do {
my ($tag, $try);
my @try;
my $relex;

my $fate;
my $x;
if ($fate = $C->{'_fate'} and $fate->[1] eq 'statement_control__S_000need_0') {
$C->deb("Fate passed to statement_control__S_000need_0: ", ::fatestr($fate)) if $::DEBUG & DEBUG::fates;
($C->{'_fate'}, $tag, $try) = @$fate;
@try = ($try);
$x = 'ALT statement_control__S_000need_0';    # some outer ltm is controlling us
}
else {
$x = 'ALTLTM statement_control__S_000need_0'; # we are top level ltm
}
my $C = $C->cursor_xact($x);
my $xact = $C->{_xact};

my @gather = ();
for (;;) {
unless (@try) {
$relex //= $C->cursor_fate('STD::P6', 'statement_control__S_000need_0', $retree);
@try = $relex->($C) or last;
}
$try = shift(@try) // next;

if (ref $try) {
($C->{'_fate'}, $tag, $try) = @$try;   # next candidate fate
}

$C->deb("statement_control__S_000need_0 trying $tag $try") if $::DEBUG & DEBUG::try_processing;
push @gather, ((
sub {
my $C=shift;
if (($C) = ($C->_SUBSUMEr(['version'], sub {
my $C = shift;
$C->version
}))
and ($C) = ($C->ws)) {
$C
} else { () }
},
sub {
my $C=shift;
if (($C) = ($C->_SUBSUMEr(['module_name'], sub {
my $C = shift;
$C->module_name
}))
and ($C) = ($C->ws)) {
scalar(do {
my $M = $C;
{
local $::IN_DECL = 'use';
local $::SCOPE = 'use';
$longname = $M->{'module_name'}->[-1]->{'longname'};
$C->do_need($longname->{'name'});
}}, $C)
} else { () }
}
)[$try])->($C);
last if @gather;
last if $xact->[-2];  # committed?
}
@gather;
};
}))) { ($C) } else { () }
}))
and ($C) = ($C->ws)) {
$C
} else { () }

});
}
;
## token statement_control:import {
sub statement_control__S_001import__PEEK { $_[0]->_AUTOLEXpeek('statement_control__S_001import', $retree) }
sub statement_control__S_001import {
no warnings 'recursion';
my $self = shift;

;
local $::IN_DECL = 'use';local $::SCOPE = 'use';
local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;

my $C = $self->cursor_xact("RULE statement_control__S_001import");
my $xact = $C->xact;
my $S = $C->{'_pos'};
$C->{sym} = "import";
$self->_MATCHIFYr($S, "statement_control__S_001import", do {
my $C = $C;
if (($C) = ($C->_EXACT("import"))
and ($C) = ($C->spacey)
and ($C) = ($C->ws)
and ($C) = ($C->_SUBSUMEr(['term'], sub {
my $C = shift;
$C->term
}))
and ($C) = ($C->_BRACKETr(sub {
my $C=shift;
do {    my $C = $C->cursor_xact('ALT ||');
my $xact = $C->xact;
my @gather;
do {
push @gather, do {
my $C = $C;
if (($C) = ($C->spacey)
and ($C) = ($C->_SUBSUMEr(['arglist'], sub {
my $C = shift;
$C->arglist
}))) {
scalar(do {
my $M = $C;
{
local %::MYSTERY;
$C->do_import($M->{'term'}, $M->{'arglist'});
$C->explain_mystery();
}}, $C)
} else { () }

}
}
or $xact->[-2] or
do {
push @gather, scalar(do {
my $M = $C;
{
$C->do_import($M->{'term'}, '')}}, $C)
};
@gather;
}
}))
and ($C) = ($C->ws)) {
$C
} else { () }

});
}
;
## token statement_control:use {
sub statement_control__S_002use__PEEK { $_[0]->_AUTOLEXpeek('statement_control__S_002use', $retree) }
sub statement_control__S_002use {
no warnings 'recursion';
my $self = shift;

;
my $longname;local $::IN_DECL = 'use';local $::SCOPE = 'use';local %::MYSTERY;
local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;

my $C = $self->cursor_xact("RULE statement_control__S_002use");
my $xact = $C->xact;
my $S = $C->{'_pos'};
$C->{sym} = "use";
$self->_MATCHIFYr($S, "statement_control__S_002use", do {
my $C = $C;
if (($C) = ($C->_EXACT("use"))
and ($C) = ($C->spacey)
and ($C) = ($C->ws)
and ($C) = ($C->_BRACKETr(sub {
my $C=shift;
do {
my ($tag, $try);
my @try;
my $relex;

my $fate;
my $x;
if ($fate = $C->{'_fate'} and $fate->[1] eq 'statement_control__S_002use_0') {
$C->deb("Fate passed to statement_control__S_002use_0: ", ::fatestr($fate)) if $::DEBUG & DEBUG::fates;
($C->{'_fate'}, $tag, $try) = @$fate;
@try = ($try);
$x = 'ALT statement_control__S_002use_0';    # some outer ltm is controlling us
}
else {
$x = 'ALTLTM statement_control__S_002use_0'; # we are top level ltm
}
my $C = $C->cursor_xact($x);
my $xact = $C->{_xact};

my @gather = ();
for (;;) {
unless (@try) {
$relex //= $C->cursor_fate('STD::P6', 'statement_control__S_002use_0', $retree);
@try = $relex->($C) or last;
}
$try = shift(@try) // next;

if (ref $try) {
($C->{'_fate'}, $tag, $try) = @$try;   # next candidate fate
}

$C->deb("statement_control__S_002use_0 trying $tag $try") if $::DEBUG & DEBUG::try_processing;
push @gather, ((
sub {
my $C=shift;
$C->_SUBSUMEr(['version'], sub {
my $C = shift;
$C->version
})
},
sub {
my $C=shift;
if (($C) = ($C->_SUBSUMEr(['module_name'], sub {
my $C = shift;
$C->module_name
}))
and ($C) = (scalar(do {
my $M = $C;
{
$longname = $M->{'module_name'}->{'longname'};
if ($longname->Str eq 'MONKEY_TYPING') {
$::MONKEY_TYPING = 1};
}}, $C))
and ($C) = ($C->_BRACKETr(sub {
my $C=shift;
do {    my $C = $C->cursor_xact('ALT ||');
my $xact = $C->xact;
my @gather;
do {
push @gather, do {
my $C = $C;
if (($C) = ($C->spacey)
and ($C) = ($C->_SUBSUMEr(['arglist'], sub {
my $C = shift;
$C->arglist
}))) {
scalar(do {
my $M = $C;
{
$C->do_use($longname->{'name'}, $M->{'arglist'})}}, $C)
} else { () }

}
}
or $xact->[-2] or
do {
push @gather, scalar(do {
{
$C->do_use($longname->{'name'}, '')}}, $C)
};
@gather;
}
}))) {
$C
} else { () }
}
)[$try])->($C);
last if @gather;
last if $xact->[-2];  # committed?
}
@gather;
};
}))
and ($C) = ($C->ws)
and ($C) = ($C->explain_mystery)) {
$C
} else { () }

});
}
;
## token statement_control:no {
sub statement_control__S_003no__PEEK { $_[0]->_AUTOLEXpeek('statement_control__S_003no', $retree) }
sub statement_control__S_003no {
no warnings 'recursion';
my $self = shift;

;
local %::MYSTERY;
local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;

my $C = $self->cursor_xact("RULE statement_control__S_003no");
my $xact = $C->xact;
my $S = $C->{'_pos'};
$C->{'arglist'} = [];
$C->{sym} = "no";
$self->_MATCHIFYr($S, "statement_control__S_003no", do {
my $C = $C;
if (($C) = ($C->_EXACT("no"))
and ($C) = ($C->spacey)
and ($C) = ($C->ws)
and ($C) = ($C->_SUBSUMEr(['module_name'], sub {
my $C = shift;
$C->module_name
}))
and ($C) = ($C->_OPTr(sub {
my $C=shift;
if (my ($C) = ($C->_BRACKETr(sub {
my $C=shift;
if (my ($C) = ($C->spacey)) {
$C->_SUBSUMEr(['arglist'], sub {
my $C = shift;
$C->arglist
})
} else { () }
}))) { ($C) } else { () }
}))
and ($C) = ($C->ws)
and ($C) = ($C->explain_mystery)) {
$C
} else { () }

});
}
;
## token statement_control:if {
sub statement_control__S_004if__PEEK { $_[0]->_AUTOLEXpeek('statement_control__S_004if', $retree) }
sub statement_control__S_004if {
no warnings 'recursion';
my $self = shift;

;

local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;

my $C = $self->cursor_xact("RULE statement_control__S_004if");
my $xact = $C->xact;
my $S = $C->{'_pos'};
$C->{'else'} = [];
$C->{'elsif'} = [];
$C->{sym} = "if";
$self->_MATCHIFYr($S, "statement_control__S_004if", do {
my $C = $C;
if (($C) = ($C->_EXACT("if"))
and ($C) = ($C->spacey)
and ($C) = ($C->ws)
and ($C) = ($C->_SUBSUMEr(['xblock'], sub {
my $C = shift;
$C->xblock
}))
and ($C) = ($C->ws)
and ($C) = ($C->_STARr(sub {
my $C=shift;
if (my ($C) = ($C->_BRACKETr(sub {
my $C=shift;
if (($C) = ($C->ws)
and ($C) = ($C->_BRACKETr(sub {
my $C=shift;
do {
my ($tag, $try);
my @try;
my $relex;

my $fate;
my $x;
if ($fate = $C->{'_fate'} and $fate->[1] eq 'statement_control__S_004if_0') {
$C->deb("Fate passed to statement_control__S_004if_0: ", ::fatestr($fate)) if $::DEBUG & DEBUG::fates;
($C->{'_fate'}, $tag, $try) = @$fate;
@try = ($try);
$x = 'ALT statement_control__S_004if_0';    # some outer ltm is controlling us
}
else {
$x = 'ALTLTM statement_control__S_004if_0'; # we are top level ltm
}
my $C = $C->cursor_xact($x);
my $xact = $C->{_xact};

my @gather = ();
for (;;) {
unless (@try) {
$relex //= $C->cursor_fate('STD::P6', 'statement_control__S_004if_0', $retree);
@try = $relex->($C) or last;
}
$try = shift(@try) // next;

if (ref $try) {
($C->{'_fate'}, $tag, $try) = @$try;   # next candidate fate
}

$C->deb("statement_control__S_004if_0 trying $tag $try") if $::DEBUG & DEBUG::try_processing;
push @gather, ((
sub {
my $C=shift;
if (($C) = ($C->_PATTERN(qr/\Gelse[\x20\t\r]*+if/))
and ($C) = ($C->ws)
and ($C) = ($C->sorry("Please use 'elsif'"))
and ($C) = ($C->ws)) {
$C
} else { () }
},
sub {
my $C=shift;
if (($C) = ($C->_EXACT("elsif"))
and ($C) = ($C->before(sub {
my $C=shift;
if (my ($C) = ($C->spacey)) { ($C) } else { () }
}))
and ($C) = ($C->ws)
and ($C) = ($C->_SUBSUMEr(['elsif'], sub {
my $C = shift;
$C->xblock
}))
and ($C) = ($C->ws)) {
$C
} else { () }
}
)[$try])->($C);
last if @gather;
last if $xact->[-2];  # committed?
}
@gather;
};
}))) {
$C
} else { () }
}))) { ($C) } else { () }
}))
and ($C) = ($C->ws)
and ($C) = ($C->_OPTr(sub {
my $C=shift;
if (my ($C) = ($C->_BRACKETr(sub {
my $C=shift;
if (($C) = ($C->ws)
and ($C) = ($C->_EXACT("else"))
and ($C) = ($C->before(sub {
my $C=shift;
if (my ($C) = ($C->spacey)) { ($C) } else { () }
}))
and ($C) = ($C->ws)
and ($C) = ($C->_SUBSUMEr(['else'], sub {
my $C = shift;
$C->pblock
}))
and ($C) = ($C->ws)) {
$C
} else { () }
}))) { ($C) } else { () }
}))
and ($C) = ($C->ws)) {
$C
} else { () }

});
}
;
## token statement_control:unless {
sub statement_control__S_005unless__PEEK { $_[0]->_AUTOLEXpeek('statement_control__S_005unless', $retree) }
sub statement_control__S_005unless {
no warnings 'recursion';
my $self = shift;

;

local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;

my $C = $self->cursor_xact("RULE statement_control__S_005unless");
my $xact = $C->xact;
my $S = $C->{'_pos'};
$C->{sym} = "unless";
$self->_MATCHIFYr($S, "statement_control__S_005unless", do {
my $C = $C;
if (($C) = ($C->_EXACT("unless"))
and ($C) = ($C->spacey)
and ($C) = ($C->ws)
and ($C) = ($C->_SUBSUMEr(['xblock'], sub {
my $C = shift;
$C->xblock
}))
and ($C) = ($C->ws)
and ($C) = ($C->_BRACKETr(sub {
my $C=shift;
do {    my $C = $C->cursor_xact('ALT ||');
my $xact = $C->xact;
my @gather;
do {
push @gather, do {
if (my ($C) = ($C->_NOTBEFORE(sub {
my $C=shift;
if (my ($C) = ($C->before(sub {
my $C=shift;
if (my ($C) = ($C->ws)) {
$C->_EXACT("else")
} else { () }
}))) { ($C) } else { () }
}))) { ($C) } else { () }

}
}
or $xact->[-2] or
do {
push @gather, do {
my $C = $C;
if (($C) = ($C->panic("\"unless\" does not take \"else\" in Perl 6; please rewrite using \"if\""))
and ($C) = ($C->ws)) {
$C
} else { () }

}
};
@gather;
}
}))) {
$C
} else { () }

});
}
;
## token statement_control:while {
sub statement_control__S_006while__PEEK { $_[0]->_AUTOLEXpeek('statement_control__S_006while', $retree) }
sub statement_control__S_006while {
no warnings 'recursion';
my $self = shift;

;

local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;

my $C = $self->cursor_xact("RULE statement_control__S_006while");
my $xact = $C->xact;
my $S = $C->{'_pos'};
$C->{sym} = "while";
$self->_MATCHIFYr($S, "statement_control__S_006while", do {
my $C = $C;
if (($C) = ($C->_EXACT("while"))
and ($C) = ($C->spacey)
and ($C) = ($C->ws)
and ($C) = ($C->_OPTr(sub {
my $C=shift;
if (my ($C) = ($C->_BRACKETr(sub {
my $C=shift;
if (($C) = ($C->ws)
and ($C) = ($C->before(sub {
my $C=shift;
if (my ($C) = ($C->before(sub {
my $C=shift;
do {
my $C = $C;
if (($C) = ($C->ws)
and ($C) = ($C->_EXACT("\("))
and ($C) = ($C->ws)
and ($C) = ($C->_OPTr(sub {
my $C=shift;
if (my ($C) = ($C->_BRACKETr(sub {
my $C=shift;
if (($C) = ($C->_PATTERN(qr/\G(?:my)?+/))
and ($C) = ($C->ws)
and ($C) = ($C->_PATTERN(qr/\G\$\w++/))
and ($C) = ($C->ws)) {
$C->_EXACT("\=")
} else { () }
}))) { ($C) } else { () }
}))
and ($C) = ($C->ws)
and ($C) = ($C->_EXACT("\<"))
and ($C) = ($C->ws)
and ($C) = ($C->_PATTERN(qr/\G\$?+\w++/))
and ($C) = ($C->ws)
and ($C) = ($C->_EXACT("\>"))
and ($C) = ($C->ws)) {
$C->_EXACT("\)")
} else { () }
};
}))) { ($C) } else { () }
}))
and ($C) = ($C->panic("This appears to be Perl 5 code"))
and ($C) = ($C->ws)) {
$C
} else { () }
}))) { ($C) } else { () }
}))
and ($C) = ($C->ws)
and ($C) = ($C->_SUBSUMEr(['xblock'], sub {
my $C = shift;
$C->xblock
}))
and ($C) = ($C->ws)) {
$C
} else { () }

});
}
;
## token statement_control:until {
sub statement_control__S_007until__PEEK { $_[0]->_AUTOLEXpeek('statement_control__S_007until', $retree) }
sub statement_control__S_007until {
no warnings 'recursion';
my $self = shift;

;

local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;

my $C = $self->cursor_xact("RULE statement_control__S_007until");
my $xact = $C->xact;
my $S = $C->{'_pos'};
$C->{sym} = "until";
$self->_MATCHIFYr($S, "statement_control__S_007until", do {
my $C = $C;
if (($C) = ($C->_EXACT("until"))
and ($C) = ($C->spacey)
and ($C) = ($C->ws)
and ($C) = ($C->_SUBSUMEr(['xblock'], sub {
my $C = shift;
$C->xblock
}))
and ($C) = ($C->ws)) {
$C
} else { () }

});
}
;
## token statement_control:repeat {
sub statement_control__S_008repeat__PEEK { $_[0]->_AUTOLEXpeek('statement_control__S_008repeat', $retree) }
sub statement_control__S_008repeat {
no warnings 'recursion';
my $self = shift;

;

local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;

my $C = $self->cursor_xact("RULE statement_control__S_008repeat");
my $xact = $C->xact;
my $S = $C->{'_pos'};
$C->{sym} = "repeat";
$self->_MATCHIFYr($S, "statement_control__S_008repeat", do {
my $C = $C;
if (($C) = ($C->_EXACT("repeat"))
and ($C) = ($C->spacey)
and ($C) = ($C->ws)
and ($C) = ($C->_BRACKETr(sub {
my $C=shift;
do {
my ($tag, $try);
my @try;
my $relex;

my $fate;
my $x;
if ($fate = $C->{'_fate'} and $fate->[1] eq 'statement_control__S_008repeat_0') {
$C->deb("Fate passed to statement_control__S_008repeat_0: ", ::fatestr($fate)) if $::DEBUG & DEBUG::fates;
($C->{'_fate'}, $tag, $try) = @$fate;
@try = ($try);
$x = 'ALT statement_control__S_008repeat_0';    # some outer ltm is controlling us
}
else {
$x = 'ALTLTM statement_control__S_008repeat_0'; # we are top level ltm
}
my $C = $C->cursor_xact($x);
my $xact = $C->{_xact};

my @gather = ();
for (;;) {
unless (@try) {
$relex //= $C->cursor_fate('STD::P6', 'statement_control__S_008repeat_0', $retree);
@try = $relex->($C) or last;
}
$try = shift(@try) // next;

if (ref $try) {
($C->{'_fate'}, $tag, $try) = @$try;   # next candidate fate
}

$C->deb("statement_control__S_008repeat_0 trying $tag $try") if $::DEBUG & DEBUG::try_processing;
push @gather, ((
sub {
my $C=shift;
if (($C) = ($C->_SUBSUMEr(['wu'], sub {
my $C = shift;
$C->_BRACKETr(sub {
my $C=shift;
do {
my ($tag, $try);
my @try;
my $relex;

my $fate;
my $x;
if ($fate = $C->{'_fate'} and $fate->[1] eq 'statement_control__S_008repeat_1') {
$C->deb("Fate passed to statement_control__S_008repeat_1: ", ::fatestr($fate)) if $::DEBUG & DEBUG::fates;
($C->{'_fate'}, $tag, $try) = @$fate;
@try = ($try);
$x = 'ALT statement_control__S_008repeat_1';    # some outer ltm is controlling us
}
else {
$x = 'ALTLTM statement_control__S_008repeat_1'; # we are top level ltm
}
my $C = $C->cursor_xact($x);
my $xact = $C->{_xact};

my @gather = ();
for (;;) {
unless (@try) {
$relex //= $C->cursor_fate('STD::P6', 'statement_control__S_008repeat_1', $retree);
@try = $relex->($C) or last;
}
$try = shift(@try) // next;

if (ref $try) {
($C->{'_fate'}, $tag, $try) = @$try;   # next candidate fate
}

$C->deb("statement_control__S_008repeat_1 trying $tag $try") if $::DEBUG & DEBUG::try_processing;
push @gather, ((
sub {
my $C=shift;
$C->_EXACT("while")
},
sub {
my $C=shift;
$C->_EXACT("until")
}
)[$try])->($C);
last if @gather;
last if $xact->[-2];  # committed?
}
@gather;
};
})
}))
and ($C) = ($C->spacey)
and ($C) = ($C->ws)
and ($C) = ($C->_SUBSUMEr(['xblock'], sub {
my $C = shift;
$C->xblock
}))
and ($C) = ($C->ws)) {
$C
} else { () }
},
sub {
my $C=shift;
if (($C) = ($C->_SUBSUMEr(['pblock'], sub {
my $C = shift;
$C->pblock
}))
and ($C) = ($C->ws)
and ($C) = ($C->_SUBSUMEr(['wu'], sub {
my $C = shift;
$C->_BRACKETr(sub {
my $C=shift;
do {
my ($tag, $try);
my @try;
my $relex;

my $fate;
my $x;
if ($fate = $C->{'_fate'} and $fate->[1] eq 'statement_control__S_008repeat_2') {
$C->deb("Fate passed to statement_control__S_008repeat_2: ", ::fatestr($fate)) if $::DEBUG & DEBUG::fates;
($C->{'_fate'}, $tag, $try) = @$fate;
@try = ($try);
$x = 'ALT statement_control__S_008repeat_2';    # some outer ltm is controlling us
}
else {
$x = 'ALTLTM statement_control__S_008repeat_2'; # we are top level ltm
}
my $C = $C->cursor_xact($x);
my $xact = $C->{_xact};

my @gather = ();
for (;;) {
unless (@try) {
$relex //= $C->cursor_fate('STD::P6', 'statement_control__S_008repeat_2', $retree);
@try = $relex->($C) or last;
}
$try = shift(@try) // next;

if (ref $try) {
($C->{'_fate'}, $tag, $try) = @$try;   # next candidate fate
}

$C->deb("statement_control__S_008repeat_2 trying $tag $try") if $::DEBUG & DEBUG::try_processing;
push @gather, ((
sub {
my $C=shift;
$C->_EXACT("while")
},
sub {
my $C=shift;
$C->_EXACT("until")
}
)[$try])->($C);
last if @gather;
last if $xact->[-2];  # committed?
}
@gather;
};
})
}))
and ($C) = ($C->_BRACKETr(sub {
my $C=shift;
do {    my $C = $C->cursor_xact('ALT ||');
my $xact = $C->xact;
my @gather;
do {
push @gather, do {
if (my ($C) = ($C->spacey)) { ($C) } else { () }

}
}
or $xact->[-2] or
do {
push @gather, do {
if (my ($C) = ($C->panic("Whitespace required after keyword"))) { ($C) } else { () }

}
};
@gather;
}
}))
and ($C) = ($C->ws)
and ($C) = ($C->_SUBSUMEr(['EXPR'], sub {
my $C = shift;
$C->EXPR
}))
and ($C) = ($C->ws)) {
$C
} else { () }
}
)[$try])->($C);
last if @gather;
last if $xact->[-2];  # committed?
}
@gather;
};
}))) {
$C
} else { () }

});
}
;
## token statement_control:loop {
sub statement_control__S_009loop__PEEK { $_[0]->_AUTOLEXpeek('statement_control__S_009loop', $retree) }
sub statement_control__S_009loop {
no warnings 'recursion';
my $self = shift;

;

local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;

my $C = $self->cursor_xact("RULE statement_control__S_009loop");
my $xact = $C->xact;
my $S = $C->{'_pos'};
$C->{sym} = "loop";
$self->_MATCHIFYr($S, "statement_control__S_009loop", do {
my $C = $C;
if (($C) = ($C->_EXACT("loop"))
and ($C) = ($C->spacey)
and ($C) = ($C->ws)
and ($C) = ($C->_OPTr(sub {
my $C=shift;
$C->_SUBSUMEr(['eee'], sub {
my $C = shift;
$C->_PAREN( sub {
my $C=shift;
do {
my $C = $C;
if (($C) = ($C->_EXACT("\("))
and ($C) = ($C->_BRACKETr(sub {
my $C=shift;
do {    my $C = $C->cursor_xact('ALT ||');
my $xact = $C->xact;
my @gather;
do {
push @gather, do {
my $C = $C;
if (($C) = ($C->ws)
and ($C) = ($C->_OPTr(sub {
my $C=shift;
$C->_SUBSUMEr(['e1'], sub {
my $C = shift;
$C->EXPR
})
}))
and ($C) = ($C->ws)
and ($C) = ($C->_EXACT("\;"))
and ($C) = ($C->ws)
and ($C) = ($C->_OPTr(sub {
my $C=shift;
$C->_SUBSUMEr(['e2'], sub {
my $C = shift;
$C->EXPR
})
}))
and ($C) = ($C->ws)
and ($C) = ($C->_EXACT("\;"))
and ($C) = ($C->ws)
and ($C) = ($C->_OPTr(sub {
my $C=shift;
$C->_SUBSUMEr(['e3'], sub {
my $C = shift;
$C->EXPR
})
}))
and ($C) = ($C->ws)) {
$C->_EXACT("\)")
} else { () }

}
}
or $xact->[-2] or
do {
push @gather, do {
if (my ($C) = ($C->panic("Malformed loop spec"))) { ($C) } else { () }

}
};
@gather;
}
}))) {
$C->_OPTr(sub {
my $C=shift;
if (my ($C) = ($C->_BRACKETr(sub {
my $C=shift;
if (($C) = ($C->before(sub {
my $C=shift;
if (my ($C) = ($C->before(sub {
my $C=shift;
$C->_EXACT("\{")
}))) { ($C) } else { () }
}))
and ($C) = ($C->sorry("Whitespace required before block"))) {
$C
} else { () }
}))) { ($C) } else { () }
})
} else { () }
};

})
})
}))
and ($C) = ($C->ws)) {
$C->_SUBSUMEr(['block'], sub {
my $C = shift;
$C->block
})
} else { () }

});
}
;
## token statement_control:for {
sub statement_control__S_010for__PEEK { $_[0]->_AUTOLEXpeek('statement_control__S_010for', $retree) }
sub statement_control__S_010for {
no warnings 'recursion';
my $self = shift;

;

local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;

my $C = $self->cursor_xact("RULE statement_control__S_010for");
my $xact = $C->xact;
my $S = $C->{'_pos'};
$C->{sym} = "for";
$self->_MATCHIFYr($S, "statement_control__S_010for", do {
my $C = $C;
if (($C) = ($C->_EXACT("for"))
and ($C) = ($C->spacey)
and ($C) = ($C->ws)
and ($C) = ($C->_OPTr(sub {
my $C=shift;
if (my ($C) = ($C->_BRACKETr(sub {
my $C=shift;
if (($C) = ($C->ws)
and ($C) = ($C->before(sub {
my $C=shift;
if (my ($C) = ($C->before(sub {
my $C=shift;
do {
my $C = $C;
if (($C) = ($C->ws)
and ($C) = ($C->_PATTERN(qr/\G(?:my)?+/))
and ($C) = ($C->ws)
and ($C) = ($C->_PATTERN(qr/\G\$\w++/))
and ($C) = ($C->ws)
and ($C) = ($C->_EXACT("\("))
and ($C) = ($C->ws)) {
$C
} else { () }
};
}))) { ($C) } else { () }
}))
and ($C) = ($C->panic("This appears to be Perl 5 code"))
and ($C) = ($C->ws)) {
$C
} else { () }
}))) { ($C) } else { () }
}))
and ($C) = ($C->ws)
and ($C) = ($C->_OPTr(sub {
my $C=shift;
if (my ($C) = ($C->_BRACKETr(sub {
my $C=shift;
if (($C) = ($C->ws)
and ($C) = ($C->before(sub {
my $C=shift;
if (my ($C) = ($C->before(sub {
my $C=shift;
do {
my $C = $C;
if (($C) = ($C->ws)
and ($C) = ($C->_EXACT("\("))
and ($C) = ($C->ws)
and ($C) = ($C->_OPTr(sub {
my $C=shift;
if (my ($C) = ($C->EXPR)) { ($C) } else { () }
}))
and ($C) = ($C->ws)
and ($C) = ($C->_EXACT("\;"))
and ($C) = ($C->ws)
and ($C) = ($C->_OPTr(sub {
my $C=shift;
if (my ($C) = ($C->EXPR)) { ($C) } else { () }
}))
and ($C) = ($C->ws)
and ($C) = ($C->_EXACT("\;"))
and ($C) = ($C->ws)
and ($C) = ($C->_OPTr(sub {
my $C=shift;
if (my ($C) = ($C->EXPR)) { ($C) } else { () }
}))
and ($C) = ($C->ws)
and ($C) = ($C->_EXACT("\)"))
and ($C) = ($C->ws)) {
$C
} else { () }
};
}))) { ($C) } else { () }
}))
and ($C) = ($C->obs('C-style "for (;;)" loop', '"loop (;;)"'))
and ($C) = ($C->ws)) {
$C
} else { () }
}))) { ($C) } else { () }
}))
and ($C) = ($C->ws)
and ($C) = ($C->_SUBSUMEr(['xblock'], sub {
my $C = shift;
$C->xblock
}))
and ($C) = ($C->ws)) {
$C
} else { () }

});
}
;
## token statement_control:foreach {
sub statement_control__S_011foreach__PEEK { $_[0]->_AUTOLEXpeek('statement_control__S_011foreach', $retree) }
sub statement_control__S_011foreach {
no warnings 'recursion';
my $self = shift;

;

local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;

my $C = $self->cursor_xact("RULE statement_control__S_011foreach");
my $xact = $C->xact;
my $S = $C->{'_pos'};
$C->{sym} = "foreach";
$self->_MATCHIFYr($S, "statement_control__S_011foreach", do {
my $C = $C;
if (($C) = ($C->_EXACT("foreach"))
and ($C) = ($C->spacey)
and ($C) = ($C->obs("'foreach'", "'for'"))) {
$C
} else { () }

});
}
;
## token statement_control:given {
sub statement_control__S_012given__PEEK { $_[0]->_AUTOLEXpeek('statement_control__S_012given', $retree) }
sub statement_control__S_012given {
no warnings 'recursion';
my $self = shift;

;

local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;

my $C = $self->cursor_xact("RULE statement_control__S_012given");
my $xact = $C->xact;
my $S = $C->{'_pos'};
$C->{sym} = "given";
$self->_MATCHIFYr($S, "statement_control__S_012given", do {
my $C = $C;
if (($C) = ($C->_EXACT("given"))
and ($C) = ($C->spacey)
and ($C) = ($C->ws)
and ($C) = ($C->_SUBSUMEr(['xblock'], sub {
my $C = shift;
$C->xblock
}))
and ($C) = ($C->ws)) {
$C
} else { () }

});
}
;
## token statement_control:when {
sub statement_control__S_013when__PEEK { $_[0]->_AUTOLEXpeek('statement_control__S_013when', $retree) }
sub statement_control__S_013when {
no warnings 'recursion';
my $self = shift;

;

local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;

my $C = $self->cursor_xact("RULE statement_control__S_013when");
my $xact = $C->xact;
my $S = $C->{'_pos'};
$C->{sym} = "when";
$self->_MATCHIFYr($S, "statement_control__S_013when", do {
my $C = $C;
if (($C) = ($C->_EXACT("when"))
and ($C) = ($C->spacey)
and ($C) = ($C->ws)
and ($C) = ($C->before(sub {
my $C=shift;
if (my ($C) = ($C->dumbsmart)) { ($C) } else { () }
}))
and ($C) = ($C->_SUBSUMEr(['xblock'], sub {
my $C = shift;
$C->xblock
}))
and ($C) = ($C->ws)) {
$C
} else { () }

});
}
;
## rule statement_control:default {<sym> <block> }
sub statement_control__S_014default__PEEK { $_[0]->_AUTOLEXpeek('statement_control__S_014default', $retree) }
sub statement_control__S_014default {
no warnings 'recursion';
my $self = shift;

;

local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;

my $C = $self->cursor_xact("RULE statement_control__S_014default");
my $xact = $C->xact;
my $S = $C->{'_pos'};
$C->{sym} = "default";
$self->_MATCHIFYr($S, "statement_control__S_014default", do {
my $C = $C;
if (($C) = ($C->_EXACT("default"))
and ($C) = ($C->spacey)
and ($C) = ($C->ws)
and ($C) = ($C->_SUBSUMEr(['block'], sub {
my $C = shift;
$C->block
}))
and ($C) = ($C->ws)) {
$C
} else { () }

});
}
;
## token statement_prefix:BEGIN   { :my %*MYSTERY; <sym> <blast> <.explain_mystery> }
sub statement_prefix__S_015BEGIN__PEEK { $_[0]->_AUTOLEXpeek('statement_prefix__S_015BEGIN', $retree) }
sub statement_prefix__S_015BEGIN {
no warnings 'recursion';
my $self = shift;

local %::MYSTERY;
local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;

my $C = $self->cursor_xact("RULE statement_prefix__S_015BEGIN");
my $xact = $C->xact;
my $S = $C->{'_pos'};
$C->{sym} = "BEGIN";
$self->_MATCHIFYr($S, "statement_prefix__S_015BEGIN", do {
my $C = $C;
if (($C) = ($C->_EXACT("BEGIN"))
and ($C) = ($C->_SUBSUMEr(['blast'], sub {
my $C = shift;
$C->blast
}))
and ($C) = ($C->explain_mystery)) {
$C
} else { () }

});
}
;
## token statement_prefix:CHECK   { <sym> <blast> }
sub statement_prefix__S_016CHECK__PEEK { $_[0]->_AUTOLEXpeek('statement_prefix__S_016CHECK', $retree) }
sub statement_prefix__S_016CHECK {
no warnings 'recursion';
my $self = shift;


local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;

my $C = $self->cursor_xact("RULE statement_prefix__S_016CHECK");
my $xact = $C->xact;
my $S = $C->{'_pos'};
$C->{sym} = "CHECK";
$self->_MATCHIFYr($S, "statement_prefix__S_016CHECK", do {
if (my ($C) = ($C->_EXACT("CHECK"))) {
$C->_SUBSUMEr(['blast'], sub {
my $C = shift;
$C->blast
})
} else { () }

});
}
;
## token statement_prefix:INIT    { <sym> <blast> }
sub statement_prefix__S_017INIT__PEEK { $_[0]->_AUTOLEXpeek('statement_prefix__S_017INIT', $retree) }
sub statement_prefix__S_017INIT {
no warnings 'recursion';
my $self = shift;


local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;

my $C = $self->cursor_xact("RULE statement_prefix__S_017INIT");
my $xact = $C->xact;
my $S = $C->{'_pos'};
$C->{sym} = "INIT";
$self->_MATCHIFYr($S, "statement_prefix__S_017INIT", do {
if (my ($C) = ($C->_EXACT("INIT"))) {
$C->_SUBSUMEr(['blast'], sub {
my $C = shift;
$C->blast
})
} else { () }

});
}
;
## token statement_prefix:START   { <sym> <blast> }
sub statement_prefix__S_018START__PEEK { $_[0]->_AUTOLEXpeek('statement_prefix__S_018START', $retree) }
sub statement_prefix__S_018START {
no warnings 'recursion';
my $self = shift;


local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;

my $C = $self->cursor_xact("RULE statement_prefix__S_018START");
my $xact = $C->xact;
my $S = $C->{'_pos'};
$C->{sym} = "START";
$self->_MATCHIFYr($S, "statement_prefix__S_018START", do {
if (my ($C) = ($C->_EXACT("START"))) {
$C->_SUBSUMEr(['blast'], sub {
my $C = shift;
$C->blast
})
} else { () }

});
}
;
## token statement_prefix:ENTER   { <sym> <blast> }
sub statement_prefix__S_019ENTER__PEEK { $_[0]->_AUTOLEXpeek('statement_prefix__S_019ENTER', $retree) }
sub statement_prefix__S_019ENTER {
no warnings 'recursion';
my $self = shift;


local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;

my $C = $self->cursor_xact("RULE statement_prefix__S_019ENTER");
my $xact = $C->xact;
my $S = $C->{'_pos'};
$C->{sym} = "ENTER";
$self->_MATCHIFYr($S, "statement_prefix__S_019ENTER", do {
if (my ($C) = ($C->_EXACT("ENTER"))) {
$C->_SUBSUMEr(['blast'], sub {
my $C = shift;
$C->blast
})
} else { () }

});
}
;
## token statement_prefix:FIRST   { <sym> <blast> }
sub statement_prefix__S_020FIRST__PEEK { $_[0]->_AUTOLEXpeek('statement_prefix__S_020FIRST', $retree) }
sub statement_prefix__S_020FIRST {
no warnings 'recursion';
my $self = shift;


local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;

my $C = $self->cursor_xact("RULE statement_prefix__S_020FIRST");
my $xact = $C->xact;
my $S = $C->{'_pos'};
$C->{sym} = "FIRST";
$self->_MATCHIFYr($S, "statement_prefix__S_020FIRST", do {
if (my ($C) = ($C->_EXACT("FIRST"))) {
$C->_SUBSUMEr(['blast'], sub {
my $C = shift;
$C->blast
})
} else { () }

});
}
;
## token statement_prefix:END     { <sym> <blast> }
sub statement_prefix__S_021END__PEEK { $_[0]->_AUTOLEXpeek('statement_prefix__S_021END', $retree) }
sub statement_prefix__S_021END {
no warnings 'recursion';
my $self = shift;


local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;

my $C = $self->cursor_xact("RULE statement_prefix__S_021END");
my $xact = $C->xact;
my $S = $C->{'_pos'};
$C->{sym} = "END";
$self->_MATCHIFYr($S, "statement_prefix__S_021END", do {
if (my ($C) = ($C->_EXACT("END"))) {
$C->_SUBSUMEr(['blast'], sub {
my $C = shift;
$C->blast
})
} else { () }

});
}
;
## token statement_prefix:LEAVE   { <sym> <blast> }
sub statement_prefix__S_022LEAVE__PEEK { $_[0]->_AUTOLEXpeek('statement_prefix__S_022LEAVE', $retree) }
sub statement_prefix__S_022LEAVE {
no warnings 'recursion';
my $self = shift;


local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;

my $C = $self->cursor_xact("RULE statement_prefix__S_022LEAVE");
my $xact = $C->xact;
my $S = $C->{'_pos'};
$C->{sym} = "LEAVE";
$self->_MATCHIFYr($S, "statement_prefix__S_022LEAVE", do {
if (my ($C) = ($C->_EXACT("LEAVE"))) {
$C->_SUBSUMEr(['blast'], sub {
my $C = shift;
$C->blast
})
} else { () }

});
}
;
## token statement_prefix:KEEP    { <sym> <blast> }
sub statement_prefix__S_023KEEP__PEEK { $_[0]->_AUTOLEXpeek('statement_prefix__S_023KEEP', $retree) }
sub statement_prefix__S_023KEEP {
no warnings 'recursion';
my $self = shift;


local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;

my $C = $self->cursor_xact("RULE statement_prefix__S_023KEEP");
my $xact = $C->xact;
my $S = $C->{'_pos'};
$C->{sym} = "KEEP";
$self->_MATCHIFYr($S, "statement_prefix__S_023KEEP", do {
if (my ($C) = ($C->_EXACT("KEEP"))) {
$C->_SUBSUMEr(['blast'], sub {
my $C = shift;
$C->blast
})
} else { () }

});
}
;
## token statement_prefix:UNDO    { <sym> <blast> }
sub statement_prefix__S_024UNDO__PEEK { $_[0]->_AUTOLEXpeek('statement_prefix__S_024UNDO', $retree) }
sub statement_prefix__S_024UNDO {
no warnings 'recursion';
my $self = shift;


local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;

my $C = $self->cursor_xact("RULE statement_prefix__S_024UNDO");
my $xact = $C->xact;
my $S = $C->{'_pos'};
$C->{sym} = "UNDO";
$self->_MATCHIFYr($S, "statement_prefix__S_024UNDO", do {
if (my ($C) = ($C->_EXACT("UNDO"))) {
$C->_SUBSUMEr(['blast'], sub {
my $C = shift;
$C->blast
})
} else { () }

});
}
;
## token statement_prefix:NEXT    { <sym> <blast> }
sub statement_prefix__S_025NEXT__PEEK { $_[0]->_AUTOLEXpeek('statement_prefix__S_025NEXT', $retree) }
sub statement_prefix__S_025NEXT {
no warnings 'recursion';
my $self = shift;


local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;

my $C = $self->cursor_xact("RULE statement_prefix__S_025NEXT");
my $xact = $C->xact;
my $S = $C->{'_pos'};
$C->{sym} = "NEXT";
$self->_MATCHIFYr($S, "statement_prefix__S_025NEXT", do {
if (my ($C) = ($C->_EXACT("NEXT"))) {
$C->_SUBSUMEr(['blast'], sub {
my $C = shift;
$C->blast
})
} else { () }

});
}
;
## token statement_prefix:LAST    { <sym> <blast> }
sub statement_prefix__S_026LAST__PEEK { $_[0]->_AUTOLEXpeek('statement_prefix__S_026LAST', $retree) }
sub statement_prefix__S_026LAST {
no warnings 'recursion';
my $self = shift;


local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;

my $C = $self->cursor_xact("RULE statement_prefix__S_026LAST");
my $xact = $C->xact;
my $S = $C->{'_pos'};
$C->{sym} = "LAST";
$self->_MATCHIFYr($S, "statement_prefix__S_026LAST", do {
if (my ($C) = ($C->_EXACT("LAST"))) {
$C->_SUBSUMEr(['blast'], sub {
my $C = shift;
$C->blast
})
} else { () }

});
}
;
## token statement_prefix:PRE     { <sym> <blast> }
sub statement_prefix__S_027PRE__PEEK { $_[0]->_AUTOLEXpeek('statement_prefix__S_027PRE', $retree) }
sub statement_prefix__S_027PRE {
no warnings 'recursion';
my $self = shift;


local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;

my $C = $self->cursor_xact("RULE statement_prefix__S_027PRE");
my $xact = $C->xact;
my $S = $C->{'_pos'};
$C->{sym} = "PRE";
$self->_MATCHIFYr($S, "statement_prefix__S_027PRE", do {
if (my ($C) = ($C->_EXACT("PRE"))) {
$C->_SUBSUMEr(['blast'], sub {
my $C = shift;
$C->blast
})
} else { () }

});
}
;
## token statement_prefix:POST    { <sym> <blast> }
sub statement_prefix__S_028POST__PEEK { $_[0]->_AUTOLEXpeek('statement_prefix__S_028POST', $retree) }
sub statement_prefix__S_028POST {
no warnings 'recursion';
my $self = shift;


local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;

my $C = $self->cursor_xact("RULE statement_prefix__S_028POST");
my $xact = $C->xact;
my $S = $C->{'_pos'};
$C->{sym} = "POST";
$self->_MATCHIFYr($S, "statement_prefix__S_028POST", do {
if (my ($C) = ($C->_EXACT("POST"))) {
$C->_SUBSUMEr(['blast'], sub {
my $C = shift;
$C->blast
})
} else { () }

});
}
;
## rule statement_control:CATCH   {<sym> <block> }
sub statement_control__S_029CATCH__PEEK { $_[0]->_AUTOLEXpeek('statement_control__S_029CATCH', $retree) }
sub statement_control__S_029CATCH {
no warnings 'recursion';
my $self = shift;

;

local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;

my $C = $self->cursor_xact("RULE statement_control__S_029CATCH");
my $xact = $C->xact;
my $S = $C->{'_pos'};
$C->{sym} = "CATCH";
$self->_MATCHIFYr($S, "statement_control__S_029CATCH", do {
my $C = $C;
if (($C) = ($C->_EXACT("CATCH"))
and ($C) = ($C->spacey)
and ($C) = ($C->ws)
and ($C) = ($C->_SUBSUMEr(['block'], sub {
my $C = shift;
$C->block
}))
and ($C) = ($C->ws)) {
$C
} else { () }

});
}
;
## rule statement_control:CONTROL {<sym> <block> }
sub statement_control__S_030CONTROL__PEEK { $_[0]->_AUTOLEXpeek('statement_control__S_030CONTROL', $retree) }
sub statement_control__S_030CONTROL {
no warnings 'recursion';
my $self = shift;

;

local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;

my $C = $self->cursor_xact("RULE statement_control__S_030CONTROL");
my $xact = $C->xact;
my $S = $C->{'_pos'};
$C->{sym} = "CONTROL";
$self->_MATCHIFYr($S, "statement_control__S_030CONTROL", do {
my $C = $C;
if (($C) = ($C->_EXACT("CONTROL"))
and ($C) = ($C->spacey)
and ($C) = ($C->ws)
and ($C) = ($C->_SUBSUMEr(['block'], sub {
my $C = shift;
$C->block
}))
and ($C) = ($C->ws)) {
$C
} else { () }

});
}
;
## rule statement_control:TEMP    {<sym> <block> }
sub statement_control__S_031TEMP__PEEK { $_[0]->_AUTOLEXpeek('statement_control__S_031TEMP', $retree) }
sub statement_control__S_031TEMP {
no warnings 'recursion';
my $self = shift;

;

local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;

my $C = $self->cursor_xact("RULE statement_control__S_031TEMP");
my $xact = $C->xact;
my $S = $C->{'_pos'};
$C->{sym} = "TEMP";
$self->_MATCHIFYr($S, "statement_control__S_031TEMP", do {
my $C = $C;
if (($C) = ($C->_EXACT("TEMP"))
and ($C) = ($C->spacey)
and ($C) = ($C->ws)
and ($C) = ($C->_SUBSUMEr(['block'], sub {
my $C = shift;
$C->block
}))
and ($C) = ($C->ws)) {
$C
} else { () }

});
}
;
## rule modifier_expr { <EXPR> }
sub modifier_expr__PEEK { $_[0]->_AUTOLEXpeek('modifier_expr', $retree) }
sub modifier_expr {
no warnings 'recursion';
my $self = shift;


local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;

my $C = $self->cursor_xact("RULE modifier_expr");
my $xact = $C->xact;
my $S = $C->{'_pos'};
$self->_MATCHIFYr($S, "modifier_expr", do {
my $C = $C;
if (($C) = ($C->ws)
and ($C) = ($C->_SUBSUMEr(['EXPR'], sub {
my $C = shift;
$C->EXPR
}))
and ($C) = ($C->ws)) {
$C
} else { () }

});
}
;
## rule statement_mod_cond:if     {<sym> <modifier_expr> }
sub statement_mod_cond__S_032if__PEEK { $_[0]->_AUTOLEXpeek('statement_mod_cond__S_032if', $retree) }
sub statement_mod_cond__S_032if {
no warnings 'recursion';
my $self = shift;

;

local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;

my $C = $self->cursor_xact("RULE statement_mod_cond__S_032if");
my $xact = $C->xact;
my $S = $C->{'_pos'};
$C->{sym} = "if";
$self->_MATCHIFYr($S, "statement_mod_cond__S_032if", do {
my $C = $C;
if (($C) = ($C->_EXACT("if"))
and ($C) = ($C->nofun)
and ($C) = ($C->ws)
and ($C) = ($C->_SUBSUMEr(['modifier_expr'], sub {
my $C = shift;
$C->modifier_expr
}))
and ($C) = ($C->ws)) {
$C
} else { () }

});
}
;
## rule statement_mod_cond:unless {<sym> <modifier_expr> }
sub statement_mod_cond__S_033unless__PEEK { $_[0]->_AUTOLEXpeek('statement_mod_cond__S_033unless', $retree) }
sub statement_mod_cond__S_033unless {
no warnings 'recursion';
my $self = shift;

;

local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;

my $C = $self->cursor_xact("RULE statement_mod_cond__S_033unless");
my $xact = $C->xact;
my $S = $C->{'_pos'};
$C->{sym} = "unless";
$self->_MATCHIFYr($S, "statement_mod_cond__S_033unless", do {
my $C = $C;
if (($C) = ($C->_EXACT("unless"))
and ($C) = ($C->nofun)
and ($C) = ($C->ws)
and ($C) = ($C->_SUBSUMEr(['modifier_expr'], sub {
my $C = shift;
$C->modifier_expr
}))
and ($C) = ($C->ws)) {
$C
} else { () }

});
}
;
## rule statement_mod_cond:when   {<sym> <?dumbsmart> <modifier_expr> }
sub statement_mod_cond__S_034when__PEEK { $_[0]->_AUTOLEXpeek('statement_mod_cond__S_034when', $retree) }
sub statement_mod_cond__S_034when {
no warnings 'recursion';
my $self = shift;

;

local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;

my $C = $self->cursor_xact("RULE statement_mod_cond__S_034when");
my $xact = $C->xact;
my $S = $C->{'_pos'};
$C->{sym} = "when";
$self->_MATCHIFYr($S, "statement_mod_cond__S_034when", do {
my $C = $C;
if (($C) = ($C->_EXACT("when"))
and ($C) = ($C->nofun)
and ($C) = ($C->ws)
and ($C) = ($C->before(sub {
my $C=shift;
if (my ($C) = ($C->dumbsmart)) { ($C) } else { () }
}))
and ($C) = ($C->_SUBSUMEr(['modifier_expr'], sub {
my $C = shift;
$C->modifier_expr
}))
and ($C) = ($C->ws)) {
$C
} else { () }

});
}
;
## rule statement_mod_loop:while {<sym> <modifier_expr> }
sub statement_mod_loop__S_035while__PEEK { $_[0]->_AUTOLEXpeek('statement_mod_loop__S_035while', $retree) }
sub statement_mod_loop__S_035while {
no warnings 'recursion';
my $self = shift;

;

local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;

my $C = $self->cursor_xact("RULE statement_mod_loop__S_035while");
my $xact = $C->xact;
my $S = $C->{'_pos'};
$C->{sym} = "while";
$self->_MATCHIFYr($S, "statement_mod_loop__S_035while", do {
my $C = $C;
if (($C) = ($C->_EXACT("while"))
and ($C) = ($C->nofun)
and ($C) = ($C->ws)
and ($C) = ($C->_SUBSUMEr(['modifier_expr'], sub {
my $C = shift;
$C->modifier_expr
}))
and ($C) = ($C->ws)) {
$C
} else { () }

});
}
;
## rule statement_mod_loop:until {<sym> <modifier_expr> }
sub statement_mod_loop__S_036until__PEEK { $_[0]->_AUTOLEXpeek('statement_mod_loop__S_036until', $retree) }
sub statement_mod_loop__S_036until {
no warnings 'recursion';
my $self = shift;

;

local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;

my $C = $self->cursor_xact("RULE statement_mod_loop__S_036until");
my $xact = $C->xact;
my $S = $C->{'_pos'};
$C->{sym} = "until";
$self->_MATCHIFYr($S, "statement_mod_loop__S_036until", do {
my $C = $C;
if (($C) = ($C->_EXACT("until"))
and ($C) = ($C->nofun)
and ($C) = ($C->ws)
and ($C) = ($C->_SUBSUMEr(['modifier_expr'], sub {
my $C = shift;
$C->modifier_expr
}))
and ($C) = ($C->ws)) {
$C
} else { () }

});
}
;
## rule statement_mod_loop:for   {<sym> <modifier_expr> }
sub statement_mod_loop__S_037for__PEEK { $_[0]->_AUTOLEXpeek('statement_mod_loop__S_037for', $retree) }
sub statement_mod_loop__S_037for {
no warnings 'recursion';
my $self = shift;

;

local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;

my $C = $self->cursor_xact("RULE statement_mod_loop__S_037for");
my $xact = $C->xact;
my $S = $C->{'_pos'};
$C->{sym} = "for";
$self->_MATCHIFYr($S, "statement_mod_loop__S_037for", do {
my $C = $C;
if (($C) = ($C->_EXACT("for"))
and ($C) = ($C->nofun)
and ($C) = ($C->ws)
and ($C) = ($C->_SUBSUMEr(['modifier_expr'], sub {
my $C = shift;
$C->modifier_expr
}))
and ($C) = ($C->ws)) {
$C
} else { () }

});
}
;
## rule statement_mod_loop:given {<sym> <modifier_expr> }
sub statement_mod_loop__S_038given__PEEK { $_[0]->_AUTOLEXpeek('statement_mod_loop__S_038given', $retree) }
sub statement_mod_loop__S_038given {
no warnings 'recursion';
my $self = shift;

;

local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;

my $C = $self->cursor_xact("RULE statement_mod_loop__S_038given");
my $xact = $C->xact;
my $S = $C->{'_pos'};
$C->{sym} = "given";
$self->_MATCHIFYr($S, "statement_mod_loop__S_038given", do {
my $C = $C;
if (($C) = ($C->_EXACT("given"))
and ($C) = ($C->nofun)
and ($C) = ($C->ws)
and ($C) = ($C->_SUBSUMEr(['modifier_expr'], sub {
my $C = shift;
$C->modifier_expr
}))
and ($C) = ($C->ws)) {
$C
} else { () }

});
}
;
## token module_name:normal {
sub module_name__S_039normal__PEEK { $_[0]->_AUTOLEXpeek('module_name__S_039normal', $retree) }
sub module_name__S_039normal {
no warnings 'recursion';
my $self = shift;


local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;

my $C = $self->cursor_xact("RULE module_name__S_039normal");
my $xact = $C->xact;
my $S = $C->{'_pos'};
$C->{'arglist'} = [];
$C->{sym} = "normal";
$self->_MATCHIFYr($S, "module_name__S_039normal", do {
if (my ($C) = ($C->_SUBSUMEr(['longname'], sub {
my $C = shift;
$C->longname
}))) {
$C->_OPTr(sub {
my $C=shift;
if (my ($C) = ($C->_BRACKETr(sub {
my $C=shift;
if (($C) = ($C->before(sub {
my $C=shift;
if (my ($C) = ($C->before(sub {
my $C=shift;
$C->_EXACT("\[")
}))) { ($C) } else { () }
}))
and ($C) = ($C->_BRACKETr(sub {
my $C=shift;
local $::GOAL = "\]";
my $goalpos = $C;
if (($C) = ($C->_EXACT("\["))
and ($C) = (scalar(do {
}, $C))
and ($C) = ($C->_SUBSUMEr(['arglist'], sub {
my $C = shift;
$C->arglist
}))
and ($C) = ($C->_BRACKETr(sub {
my $C=shift;
do {    my $C = $C->cursor_xact('ALT ||');
my $xact = $C->xact;
my @gather;
do {
push @gather, $C->_EXACT("\]")
}
or $xact->[-2] or
do {
push @gather, do {
if (my ($C) = ($C->FAILGOAL($::GOAL, 'generic role', $goalpos))) { ($C) } else { () }

}
};
@gather;
}
}))) {
$C
} else { () }
}))) {
$C
} else { () }
}))) { ($C) } else { () }
})
} else { () }

});
}
;
## token vnum {
sub vnum__PEEK { $_[0]->_AUTOLEXpeek('vnum', $retree) }
sub vnum {
no warnings 'recursion';
my $self = shift;


local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;

my $C = $self->cursor_xact("RULE vnum");
my $xact = $C->xact;
my $S = $C->{'_pos'};
$self->_MATCHIFYr($S, "vnum", do {
do {
my ($tag, $try);
my @try;
my $relex;

my $fate;
my $x;
if ($fate = $C->{'_fate'} and $fate->[1] eq 'vnum_0') {
$C->deb("Fate passed to vnum_0: ", ::fatestr($fate)) if $::DEBUG & DEBUG::fates;
($C->{'_fate'}, $tag, $try) = @$fate;
@try = ($try);
$x = 'ALT vnum_0';    # some outer ltm is controlling us
}
else {
$x = 'ALTLTM vnum_0'; # we are top level ltm
}
my $C = $C->cursor_xact($x);
my $xact = $C->{_xact};

my @gather = ();
for (;;) {
unless (@try) {
$relex //= $C->cursor_fate('STD::P6', 'vnum_0', $retree);
@try = $relex->($C) or last;
}
$try = shift(@try) // next;

if (ref $try) {
($C->{'_fate'}, $tag, $try) = @$try;   # next candidate fate
}

$C->deb("vnum_0 trying $tag $try") if $::DEBUG & DEBUG::try_processing;
push @gather, ((
sub {
my $C=shift;
$C->_PATTERN(qr/\G\d++/)
},
sub {
my $C=shift;
$C->_EXACT("\*")
}
)[$try])->($C);
last if @gather;
last if $xact->[-2];  # committed?
}
@gather;
};

});
}
;
## token version:sym<v> {
sub version__S_040v__PEEK { $_[0]->_AUTOLEXpeek('version__S_040v', $retree) }
sub version__S_040v {
no warnings 'recursion';
my $self = shift;


local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;

my $C = $self->cursor_xact("RULE version__S_040v");
my $xact = $C->xact;
my $S = $C->{'_pos'};
$C->{'vnum'} = [];
$C->{sym} = "v";
$self->_MATCHIFYr($S, "version__S_040v", do {
my $C = $C;
if (($C) = ($C->_EXACT("v"))
and ($C) = ($C->before(sub {
my $C=shift;
if (my ($C) = ($C->before(sub {
my $C=shift;
$C->_PATTERN(qr/\G\d++/)
}))) { ($C) } else { () }
}))
and ($C) = ($C->_COMMITLTM())
and ($C) = ($C->_REPSEPr( sub {
my $C=shift;
$C->_EXACT("\.")
}, sub {
my $C=shift;
$C->_SUBSUMEr(['vnum'], sub {
my $C = shift;
$C->vnum
})
}))) {
$C->_PATTERN(qr/\G\+?+/)
} else { () }

});
}
;
## token variable_declarator {
sub variable_declarator__PEEK { $_[0]->_AUTOLEXpeek('variable_declarator', $retree) }
sub variable_declarator {
no warnings 'recursion';
my $self = shift;

local $::IN_DECL = 'variable';local $::DECLARAND;my $var;
local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;

my $C = $self->cursor_xact("RULE variable_declarator");
my $xact = $C->xact;
my $S = $C->{'_pos'};
$C->{'post_constraint'} = [];
$C->{'postcircumfix'} = [];
$C->{'semilist'} = [];
$C->{'shape'} = [];
$C->{'signature'} = [];
$C->{'trait'} = [];
$self->_MATCHIFYr($S, "variable_declarator", do {
my $C = $C;
if (($C) = ($C->_SUBSUMEr(['variable'], sub {
my $C = shift;
$C->variable
}))
and ($C) = (scalar(do {
my $M = $C;
$var = $M->{'variable'}->Str;
$C->add_variable($var);
$::IN_DECL = '';
}, $C))
and ($C) = ($C->_OPTr(sub {
my $C=shift;
if (my ($C) = ($C->_BRACKETr(sub {
my $C=shift;
if (my ($C) = ($C->_OPTr(sub {
my $C=shift;
if (my ($C) = ($C->unsp)) { ($C) } else { () }
}))) {
$C->_STARr(sub {
my $C=shift;
$C->_SUBSUMEr(['shape'], sub {
my $C = shift;
$C->_BRACKETr(sub {
my $C=shift;
do {
my ($tag, $try);
my @try;
my $relex;

my $fate;
my $x;
if ($fate = $C->{'_fate'} and $fate->[1] eq 'variable_declarator_0') {
$C->deb("Fate passed to variable_declarator_0: ", ::fatestr($fate)) if $::DEBUG & DEBUG::fates;
($C->{'_fate'}, $tag, $try) = @$fate;
@try = ($try);
$x = 'ALT variable_declarator_0';    # some outer ltm is controlling us
}
else {
$x = 'ALTLTM variable_declarator_0'; # we are top level ltm
}
my $C = $C->cursor_xact($x);
my $xact = $C->{_xact};

my @gather = ();
for (;;) {
unless (@try) {
$relex //= $C->cursor_fate('STD::P6', 'variable_declarator_0', $retree);
@try = $relex->($C) or last;
}
$try = shift(@try) // next;

if (ref $try) {
($C->{'_fate'}, $tag, $try) = @$try;   # next candidate fate
}

$C->deb("variable_declarator_0 trying $tag $try") if $::DEBUG & DEBUG::try_processing;
push @gather, ((
sub {
my $C=shift;
if (my ($C) = ($C->_BRACKETr(sub {
my $C=shift;
local $::GOAL = "\)";
my $goalpos = $C;
if (($C) = ($C->_EXACT("\("))
and ($C) = (scalar(do {
}, $C))
and ($C) = ($C->_SUBSUMEr(['signature'], sub {
my $C = shift;
$C->signature
}))
and ($C) = ($C->_BRACKETr(sub {
my $C=shift;
do {    my $C = $C->cursor_xact('ALT ||');
my $xact = $C->xact;
my @gather;
do {
push @gather, $C->_EXACT("\)")
}
or $xact->[-2] or
do {
push @gather, do {
if (my ($C) = ($C->FAILGOAL($::GOAL, 'variable_declarator', $goalpos))) { ($C) } else { () }

}
};
@gather;
}
}))) {
$C
} else { () }
}))) {
scalar(do {
{
given (substr($var,0,1)) {
when ('&') {
$C->sorry("The () shape syntax in routine declarations is reserved (maybe use :() to declare a longname?)")}
;
when ('@') {
$C->sorry("The () shape syntax in array declarations is reserved")}
;
when ('%') {
$C->sorry("The () shape syntax in hash declarations is reserved")}
;
default {
$C->sorry("The () shape syntax in variable declarations is reserved")}
;
}
}}, $C)
} else { () }
},
sub {
my $C=shift;
if (my ($C) = ($C->_BRACKETr(sub {
my $C=shift;
local $::GOAL = "\]";
my $goalpos = $C;
if (($C) = ($C->_EXACT("\["))
and ($C) = (scalar(do {
}, $C))
and ($C) = ($C->_SUBSUMEr(['semilist'], sub {
my $C = shift;
$C->semilist
}))
and ($C) = ($C->_BRACKETr(sub {
my $C=shift;
do {    my $C = $C->cursor_xact('ALT ||');
my $xact = $C->xact;
my @gather;
do {
push @gather, $C->_EXACT("\]")
}
or $xact->[-2] or
do {
push @gather, do {
if (my ($C) = ($C->FAILGOAL($::GOAL, 'shape definition', $goalpos))) { ($C) } else { () }

}
};
@gather;
}
}))) {
$C
} else { () }
}))) { ($C) } else { () }
},
sub {
my $C=shift;
if (($C) = ($C->_BRACKETr(sub {
my $C=shift;
local $::GOAL = "\}";
my $goalpos = $C;
if (($C) = ($C->_EXACT("\{"))
and ($C) = (scalar(do {
}, $C))
and ($C) = ($C->_SUBSUMEr(['semilist'], sub {
my $C = shift;
$C->semilist
}))
and ($C) = ($C->_BRACKETr(sub {
my $C=shift;
do {    my $C = $C->cursor_xact('ALT ||');
my $xact = $C->xact;
my @gather;
do {
push @gather, $C->_EXACT("\}")
}
or $xact->[-2] or
do {
push @gather, do {
if (my ($C) = ($C->FAILGOAL($::GOAL, 'shape definition', $goalpos))) { ($C) } else { () }

}
};
@gather;
}
}))) {
$C
} else { () }
}))
and ($C) = ($C->curlycheck)) {
$C
} else { () }
},
sub {
my $C=shift;
if (my ($C) = ($C->before(sub {
my $C=shift;
if (my ($C) = ($C->before(sub {
my $C=shift;
$C->_EXACT("\<")
}))) { ($C) } else { () }
}))) {
$C->_SUBSUMEr(['postcircumfix'], sub {
my $C = shift;
$C->postcircumfix
})
} else { () }
}
)[$try])->($C);
last if @gather;
last if $xact->[-2];  # committed?
}
@gather;
};
})
})
})
} else { () }
}))) { ($C) } else { () }
}))
and ($C) = ($C->ws)
and ($C) = ($C->_STARr(sub {
my $C=shift;
$C->_SUBSUMEr(['trait'], sub {
my $C = shift;
$C->trait
})
}))
and ($C) = ($C->_STARr(sub {
my $C=shift;
$C->_SUBSUMEr(['post_constraint'], sub {
my $C = shift;
$C->post_constraint
})
}))
and ($C) = ($C->getdecl)) {
$C
} else { () }

});
}
;
## rule scoped ($*SCOPE) {
sub scoped__PEEK { $_[0]->_AUTOLEXpeek('scoped', $retree) }
sub scoped {
no warnings 'recursion';
my $self = shift;

die 'Required argument SCOPE omitted' unless @_;
local $::SCOPE = @_ ? shift() : undef;

local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;

my $C = $self->cursor_xact("RULE scoped");
my $xact = $C->xact;
my $S = $C->{'_pos'};
$C->{'typename'} = [];
$self->_MATCHIFYr($S, "scoped", do {    my $C = $C->cursor_xact('ALT ||');
my $xact = $C->xact;
my @gather;
do {
push @gather, do {
my $C = $C;
if (($C) = ($C->ws)
and ($C) = ($C->_BRACKETr(sub {
my $C=shift;
do {
my ($tag, $try);
my @try;
my $relex;

my $fate;
my $x;
if ($fate = $C->{'_fate'} and $fate->[1] eq 'scoped_0') {
$C->deb("Fate passed to scoped_0: ", ::fatestr($fate)) if $::DEBUG & DEBUG::fates;
($C->{'_fate'}, $tag, $try) = @$fate;
@try = ($try);
$x = 'ALT scoped_0';    # some outer ltm is controlling us
}
else {
$x = 'ALTLTM scoped_0'; # we are top level ltm
}
my $C = $C->cursor_xact($x);
my $xact = $C->{_xact};

my @gather = ();
for (;;) {
unless (@try) {
$relex //= $C->cursor_fate('STD::P6', 'scoped_0', $retree);
@try = $relex->($C) or last;
}
$try = shift(@try) // next;

if (ref $try) {
($C->{'_fate'}, $tag, $try) = @$try;   # next candidate fate
}

$C->deb("scoped_0 trying $tag $try") if $::DEBUG & DEBUG::try_processing;
push @gather, ((
sub {
my $C=shift;
if (($C) = ($C->_SUBSUMEr(['declarator'], sub {
my $C = shift;
$C->declarator
}))
and ($C) = ($C->ws)) {
$C
} else { () }
},
sub {
my $C=shift;
if (($C) = ($C->_SUBSUMEr(['regex_declarator'], sub {
my $C = shift;
$C->regex_declarator
}))
and ($C) = ($C->ws)) {
$C
} else { () }
},
sub {
my $C=shift;
if (($C) = ($C->_SUBSUMEr(['package_declarator'], sub {
my $C = shift;
$C->package_declarator
}))
and ($C) = ($C->ws)) {
$C
} else { () }
},
sub {
my $C=shift;
if (($C) = ($C->_PLUSr(sub {
my $C=shift;
if (my ($C) = ($C->_BRACKETr(sub {
my $C=shift;
if (($C) = ($C->_SUBSUMEr(['typename'], sub {
my $C = shift;
$C->typename
}))
and ($C) = ($C->ws)) {
$C
} else { () }
}))) { ($C) } else { () }
}))
and ($C) = ($C->ws)
and ($C) = (scalar(do {
my $M = $C;
my $t = $M->{'typename'};
@$t > 1 and $C->sorry("Multiple prefix constraints not yet supported");
$::OFTYPE = $t->[0];
}, $C))
and ($C) = ($C->_SUBSUMEr(['multi_declarator'], sub {
my $C = shift;
$C->multi_declarator
}))
and ($C) = ($C->ws)) {
$C
} else { () }
},
sub {
my $C=shift;
if (($C) = ($C->_SUBSUMEr(['multi_declarator'], sub {
my $C = shift;
$C->multi_declarator
}))
and ($C) = ($C->ws)) {
$C
} else { () }
}
)[$try])->($C);
last if @gather;
last if $xact->[-2];  # committed?
}
@gather;
};
}))) {
$C
} else { () }

}
}
or $xact->[-2] or
do {
push @gather, do {
my $C = $C;
if (($C) = ($C->ws)
and ($C) = ($C->before(sub {
my $C=shift;
if (my ($C) = ($C->before(sub {
my $C=shift;
if (my ($C) = ($C->ws)) {
$C->_PATTERN(qr/\G[A-Z]/)
} else { () }
}))) { ($C) } else { () }
}))
and ($C) = ($C->_SUBSUMEr(['longname'], sub {
my $C = shift;
$C->longname
}))
and ($C) = (scalar(do {
my $M = $C;
{
my $t = $M->{'longname'}->Str;
if (not $C->is_known($t)) {
$C->sorry("In $::SCOPE declaration, typename '$t' must be predeclared (or marked as declarative with :: prefix)")};
}}, $C))
and ($C) = ($C->ws)
and ($C) = ($C->_NOTBEFORE(sub {
my $C=shift;
$C
}))) {
$C
} else { () }

}
}
or $xact->[-2] or
do {
push @gather, do {
my $C = $C;
if (($C) = ($C->ws)
and ($C) = ($C->panic("Malformed $::SCOPE"))
and ($C) = ($C->ws)) {
$C
} else { () }

}
};
@gather;
});
}
;
## token scope_declarator:my        { <sym> <scoped('my')> }
sub scope_declarator__S_041my__PEEK { $_[0]->_AUTOLEXpeek('scope_declarator__S_041my', $retree) }
sub scope_declarator__S_041my {
no warnings 'recursion';
my $self = shift;

;

local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;

my $C = $self->cursor_xact("RULE scope_declarator__S_041my");
my $xact = $C->xact;
my $S = $C->{'_pos'};
$C->{sym} = "my";
$self->_MATCHIFYr($S, "scope_declarator__S_041my", do {
my $C = $C;
if (($C) = ($C->_EXACT("my"))
and ($C) = ($C->nofun)) {
$C->_SUBSUMEr(['scoped'], sub {
my $C = shift;
$C->scoped('my')
})
} else { () }

});
}
;
## token scope_declarator:our       { <sym> <scoped('our')> }
sub scope_declarator__S_042our__PEEK { $_[0]->_AUTOLEXpeek('scope_declarator__S_042our', $retree) }
sub scope_declarator__S_042our {
no warnings 'recursion';
my $self = shift;

;

local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;

my $C = $self->cursor_xact("RULE scope_declarator__S_042our");
my $xact = $C->xact;
my $S = $C->{'_pos'};
$C->{sym} = "our";
$self->_MATCHIFYr($S, "scope_declarator__S_042our", do {
my $C = $C;
if (($C) = ($C->_EXACT("our"))
and ($C) = ($C->nofun)) {
$C->_SUBSUMEr(['scoped'], sub {
my $C = shift;
$C->scoped('our')
})
} else { () }

});
}
;
## token scope_declarator:anon      { <sym> <scoped('anon')> }
sub scope_declarator__S_043anon__PEEK { $_[0]->_AUTOLEXpeek('scope_declarator__S_043anon', $retree) }
sub scope_declarator__S_043anon {
no warnings 'recursion';
my $self = shift;

;

local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;

my $C = $self->cursor_xact("RULE scope_declarator__S_043anon");
my $xact = $C->xact;
my $S = $C->{'_pos'};
$C->{sym} = "anon";
$self->_MATCHIFYr($S, "scope_declarator__S_043anon", do {
my $C = $C;
if (($C) = ($C->_EXACT("anon"))
and ($C) = ($C->nofun)) {
$C->_SUBSUMEr(['scoped'], sub {
my $C = shift;
$C->scoped('anon')
})
} else { () }

});
}
;
## token scope_declarator:state     { <sym> <scoped('state')> }
sub scope_declarator__S_044state__PEEK { $_[0]->_AUTOLEXpeek('scope_declarator__S_044state', $retree) }
sub scope_declarator__S_044state {
no warnings 'recursion';
my $self = shift;

;

local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;

my $C = $self->cursor_xact("RULE scope_declarator__S_044state");
my $xact = $C->xact;
my $S = $C->{'_pos'};
$C->{sym} = "state";
$self->_MATCHIFYr($S, "scope_declarator__S_044state", do {
my $C = $C;
if (($C) = ($C->_EXACT("state"))
and ($C) = ($C->nofun)) {
$C->_SUBSUMEr(['scoped'], sub {
my $C = shift;
$C->scoped('state')
})
} else { () }

});
}
;
## token scope_declarator:has       { <sym> <scoped('has')> }
sub scope_declarator__S_045has__PEEK { $_[0]->_AUTOLEXpeek('scope_declarator__S_045has', $retree) }
sub scope_declarator__S_045has {
no warnings 'recursion';
my $self = shift;

;

local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;

my $C = $self->cursor_xact("RULE scope_declarator__S_045has");
my $xact = $C->xact;
my $S = $C->{'_pos'};
$C->{sym} = "has";
$self->_MATCHIFYr($S, "scope_declarator__S_045has", do {
my $C = $C;
if (($C) = ($C->_EXACT("has"))
and ($C) = ($C->nofun)) {
$C->_SUBSUMEr(['scoped'], sub {
my $C = shift;
$C->scoped('has')
})
} else { () }

});
}
;
## token scope_declarator:augment   { <sym> <scoped('augment')> }
sub scope_declarator__S_046augment__PEEK { $_[0]->_AUTOLEXpeek('scope_declarator__S_046augment', $retree) }
sub scope_declarator__S_046augment {
no warnings 'recursion';
my $self = shift;

;

local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;

my $C = $self->cursor_xact("RULE scope_declarator__S_046augment");
my $xact = $C->xact;
my $S = $C->{'_pos'};
$C->{sym} = "augment";
$self->_MATCHIFYr($S, "scope_declarator__S_046augment", do {
my $C = $C;
if (($C) = ($C->_EXACT("augment"))
and ($C) = ($C->nofun)) {
$C->_SUBSUMEr(['scoped'], sub {
my $C = shift;
$C->scoped('augment')
})
} else { () }

});
}
;
## token scope_declarator:supersede { <sym> <scoped('supersede')> }
sub scope_declarator__S_047supersede__PEEK { $_[0]->_AUTOLEXpeek('scope_declarator__S_047supersede', $retree) }
sub scope_declarator__S_047supersede {
no warnings 'recursion';
my $self = shift;

;

local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;

my $C = $self->cursor_xact("RULE scope_declarator__S_047supersede");
my $xact = $C->xact;
my $S = $C->{'_pos'};
$C->{sym} = "supersede";
$self->_MATCHIFYr($S, "scope_declarator__S_047supersede", do {
my $C = $C;
if (($C) = ($C->_EXACT("supersede"))
and ($C) = ($C->nofun)) {
$C->_SUBSUMEr(['scoped'], sub {
my $C = shift;
$C->scoped('supersede')
})
} else { () }

});
}
;
## token package_declarator:class {
sub package_declarator__S_048class__PEEK { $_[0]->_AUTOLEXpeek('package_declarator__S_048class', $retree) }
sub package_declarator__S_048class {
no warnings 'recursion';
my $self = shift;

;
local $::PKGDECL = 'class';
local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;

my $C = $self->cursor_xact("RULE package_declarator__S_048class");
my $xact = $C->xact;
my $S = $C->{'_pos'};
$C->{sym} = "class";
$self->_MATCHIFYr($S, "package_declarator__S_048class", do {
my $C = $C;
if (($C) = ($C->_EXACT("class"))
and ($C) = ($C->spacey)) {
$C->_SUBSUMEr(['package_def'], sub {
my $C = shift;
$C->package_def
})
} else { () }

});
}
;
## token package_declarator:grammar {
sub package_declarator__S_049grammar__PEEK { $_[0]->_AUTOLEXpeek('package_declarator__S_049grammar', $retree) }
sub package_declarator__S_049grammar {
no warnings 'recursion';
my $self = shift;

;
local $::PKGDECL = 'grammar';
local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;

my $C = $self->cursor_xact("RULE package_declarator__S_049grammar");
my $xact = $C->xact;
my $S = $C->{'_pos'};
$C->{sym} = "grammar";
$self->_MATCHIFYr($S, "package_declarator__S_049grammar", do {
my $C = $C;
if (($C) = ($C->_EXACT("grammar"))
and ($C) = ($C->spacey)) {
$C->_SUBSUMEr(['package_def'], sub {
my $C = shift;
$C->package_def
})
} else { () }

});
}
;
## token package_declarator:module {
sub package_declarator__S_050module__PEEK { $_[0]->_AUTOLEXpeek('package_declarator__S_050module', $retree) }
sub package_declarator__S_050module {
no warnings 'recursion';
my $self = shift;

;
local $::PKGDECL = 'module';
local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;

my $C = $self->cursor_xact("RULE package_declarator__S_050module");
my $xact = $C->xact;
my $S = $C->{'_pos'};
$C->{sym} = "module";
$self->_MATCHIFYr($S, "package_declarator__S_050module", do {
my $C = $C;
if (($C) = ($C->_EXACT("module"))
and ($C) = ($C->spacey)) {
$C->_SUBSUMEr(['package_def'], sub {
my $C = shift;
$C->package_def
})
} else { () }

});
}
;
## token package_declarator:package {
sub package_declarator__S_051package__PEEK { $_[0]->_AUTOLEXpeek('package_declarator__S_051package', $retree) }
sub package_declarator__S_051package {
no warnings 'recursion';
my $self = shift;

;
local $::PKGDECL = 'package';
local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;

my $C = $self->cursor_xact("RULE package_declarator__S_051package");
my $xact = $C->xact;
my $S = $C->{'_pos'};
$C->{sym} = "package";
$self->_MATCHIFYr($S, "package_declarator__S_051package", do {
my $C = $C;
if (($C) = ($C->_EXACT("package"))
and ($C) = ($C->spacey)) {
$C->_SUBSUMEr(['package_def'], sub {
my $C = shift;
$C->package_def
})
} else { () }

});
}
;
## token package_declarator:role {
sub package_declarator__S_052role__PEEK { $_[0]->_AUTOLEXpeek('package_declarator__S_052role', $retree) }
sub package_declarator__S_052role {
no warnings 'recursion';
my $self = shift;

;
local $::PKGDECL = 'role';
local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;

my $C = $self->cursor_xact("RULE package_declarator__S_052role");
my $xact = $C->xact;
my $S = $C->{'_pos'};
$C->{sym} = "role";
$self->_MATCHIFYr($S, "package_declarator__S_052role", do {
my $C = $C;
if (($C) = ($C->_EXACT("role"))
and ($C) = ($C->spacey)) {
$C->_SUBSUMEr(['package_def'], sub {
my $C = shift;
$C->package_def
})
} else { () }

});
}
;
## token package_declarator:knowhow {
sub package_declarator__S_053knowhow__PEEK { $_[0]->_AUTOLEXpeek('package_declarator__S_053knowhow', $retree) }
sub package_declarator__S_053knowhow {
no warnings 'recursion';
my $self = shift;

;
local $::PKGDECL = 'knowhow';
local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;

my $C = $self->cursor_xact("RULE package_declarator__S_053knowhow");
my $xact = $C->xact;
my $S = $C->{'_pos'};
$C->{sym} = "knowhow";
$self->_MATCHIFYr($S, "package_declarator__S_053knowhow", do {
my $C = $C;
if (($C) = ($C->_EXACT("knowhow"))
and ($C) = ($C->spacey)) {
$C->_SUBSUMEr(['package_def'], sub {
my $C = shift;
$C->package_def
})
} else { () }

});
}
;
## token package_declarator:slang {
sub package_declarator__S_054slang__PEEK { $_[0]->_AUTOLEXpeek('package_declarator__S_054slang', $retree) }
sub package_declarator__S_054slang {
no warnings 'recursion';
my $self = shift;

;
local $::PKGDECL = 'slang';
local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;

my $C = $self->cursor_xact("RULE package_declarator__S_054slang");
my $xact = $C->xact;
my $S = $C->{'_pos'};
$C->{sym} = "slang";
$self->_MATCHIFYr($S, "package_declarator__S_054slang", do {
my $C = $C;
if (($C) = ($C->_EXACT("slang"))
and ($C) = ($C->spacey)) {
$C->_SUBSUMEr(['package_def'], sub {
my $C = shift;
$C->package_def
})
} else { () }

});
}
;
## token package_declarator:require {   # here because of declarational aspects
sub package_declarator__S_055require__PEEK { $_[0]->_AUTOLEXpeek('package_declarator__S_055require', $retree) }
sub package_declarator__S_055require {
no warnings 'recursion';
my $self = shift;

;

local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;

my $C = $self->cursor_xact("RULE package_declarator__S_055require");
my $xact = $C->xact;
my $S = $C->{'_pos'};
$C->{'EXPR'} = [];
$C->{sym} = "require";
$self->_MATCHIFYr($S, "package_declarator__S_055require", do {
my $C = $C;
if (($C) = ($C->_EXACT("require"))
and ($C) = ($C->spacey)
and ($C) = ($C->ws)
and ($C) = ($C->_BRACKETr(sub {
my $C=shift;
do {    my $C = $C->cursor_xact('ALT ||');
my $xact = $C->xact;
my @gather;
do {
push @gather, do {
if (my ($C) = ($C->_SUBSUMEr(['module_name'], sub {
my $C = shift;
$C->module_name
}))) {
$C->_OPTr(sub {
my $C=shift;
$C->_SUBSUMEr(['EXPR'], sub {
my $C = shift;
$C->EXPR
})
})
} else { () }

}
}
or $xact->[-2] or
do {
push @gather, $C->_SUBSUMEr(['EXPR'], sub {
my $C = shift;
$C->EXPR
})
};
@gather;
}
}))) {
$C
} else { () }

});
}
;
## token package_declarator:trusts {
sub package_declarator__S_056trusts__PEEK { $_[0]->_AUTOLEXpeek('package_declarator__S_056trusts', $retree) }
sub package_declarator__S_056trusts {
no warnings 'recursion';
my $self = shift;

;

local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;

my $C = $self->cursor_xact("RULE package_declarator__S_056trusts");
my $xact = $C->xact;
my $S = $C->{'_pos'};
$C->{sym} = "trusts";
$self->_MATCHIFYr($S, "package_declarator__S_056trusts", do {
my $C = $C;
if (($C) = ($C->_EXACT("trusts"))
and ($C) = ($C->spacey)
and ($C) = ($C->ws)) {
$C->_SUBSUMEr(['module_name'], sub {
my $C = shift;
$C->module_name
})
} else { () }

});
}
;
## token package_declarator:sym<also> {
sub package_declarator__S_057also__PEEK { $_[0]->_AUTOLEXpeek('package_declarator__S_057also', $retree) }
sub package_declarator__S_057also {
no warnings 'recursion';
my $self = shift;

;

local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;

my $C = $self->cursor_xact("RULE package_declarator__S_057also");
my $xact = $C->xact;
my $S = $C->{'_pos'};
$C->{'trait'} = [];
$C->{sym} = "also";
$self->_MATCHIFYr($S, "package_declarator__S_057also", do {
my $C = $C;
if (($C) = ($C->_EXACT("also"))
and ($C) = ($C->spacey)
and ($C) = ($C->ws)
and ($C) = ($C->_PLUSr(sub {
my $C=shift;
$C->_SUBSUMEr(['trait'], sub {
my $C = shift;
$C->trait
})
}))
and ($C) = ($C->ws)) {
$C
} else { () }

});
}
;
## rule package_def {
sub package_def__PEEK { $_[0]->_AUTOLEXpeek('package_def', $retree) }
sub package_def {
no warnings 'recursion';
my $self = shift;

my $longname;local $::IN_DECL = 'package';local $::DECLARAND;local $::NEWPKG;local $::NEWLEX;my $outer = $::CURLEX;local $::CURPKG = $::CURPKG;local $::CURLEX = $::CURLEX;
local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;

my $C = $self->cursor_xact("RULE package_def");
my $xact = $C->xact;
my $S = $C->{'_pos'};
$C->{'longname'} = [];
$C->{'signature'} = [];
$C->{'trait'} = [];
$self->_MATCHIFYr($S, "package_def", do {    my $C = $C->cursor_xact('ALT ||');
my $xact = $C->xact;
my @gather;
do {
push @gather, do {
my $C = $C;
if (($C) = ($C->ws)
and ($C) = (scalar(do {
$::SCOPE ||= 'our'}, $C))
and ($C) = ($C->_BRACKETr(sub {
my $C=shift;
if (($C) = ($C->_OPTr(sub {
my $C=shift;
if (my ($C) = ($C->_BRACKETr(sub {
my $C=shift;
if (($C) = ($C->ws)
and ($C) = ($C->_SUBSUMEr(['longname'], sub {
my $C = shift;
$C->longname
}))
and ($C) = ($C->ws)) {
scalar(do {
my $M = $C;
$longname = $M->{'longname'}->[0];
$C->add_name($longname->{'name'}->Str);
}, $C)
} else { () }
}))) { ($C) } else { () }
}))
and ($C) = ($C->ws)
and ($C) = ($C->newlex)
and ($C) = ($C->ws)
and ($C) = ($C->_OPTr(sub {
my $C=shift;
if (my ($C) = ($C->_BRACKETr(sub {
my $C=shift;
if (($C) = ($C->ws)
and ($C) = ($C->before(sub {
my $C=shift;
(($C) x !!do {
($::PKGDECL//'') eq 'role' })
}))
and ($C) = ($C->_BRACKETr(sub {
my $C=shift;
local $::GOAL = "\]";
my $goalpos = $C;
if (($C) = ($C->_EXACT("\["))
and ($C) = (scalar(do {
}, $C))
and ($C) = ($C->_SUBSUMEr(['signature'], sub {
my $C = shift;
$C->signature
}))
and ($C) = ($C->_BRACKETr(sub {
my $C=shift;
do {    my $C = $C->cursor_xact('ALT ||');
my $xact = $C->xact;
my @gather;
do {
push @gather, $C->_EXACT("\]")
}
or $xact->[-2] or
do {
push @gather, do {
if (my ($C) = ($C->FAILGOAL($::GOAL, 'generic role', $goalpos))) { ($C) } else { () }

}
};
@gather;
}
}))) {
$C
} else { () }
}))
and ($C) = ($C->ws)) {
scalar(do {
$::IN_DECL = ''}, $C)
} else { () }
}))) { ($C) } else { () }
}))
and ($C) = ($C->ws)
and ($C) = ($C->_STARr(sub {
my $C=shift;
$C->_SUBSUMEr(['trait'], sub {
my $C = shift;
$C->trait
})
}))
and ($C) = ($C->ws)
and ($C) = ($C->getdecl)
and ($C) = ($C->ws)
and ($C) = ($C->_BRACKETr(sub {
my $C=shift;
do {    my $C = $C->cursor_xact('ALT ||');
my $xact = $C->xact;
my @gather;
do {
push @gather, do {
my $C = $C;
if (($C) = ($C->before(sub {
my $C=shift;
if (my ($C) = ($C->before(sub {
my $C=shift;
if (my ($C) = ($C->ws)) {
$C->_EXACT("\{")
} else { () }
}))) { ($C) } else { () }
}))
and ($C) = ($C->_BRACKETr(sub {
my $C=shift;
if (($C) = (scalar(do {
{
if ($longname and $::NEWPKG) {
my $shortname = $longname->{'name'}->Str;
if ($::SCOPE eq 'our') {
$::CURPKG = $::NEWPKG // $::CURPKG->{$shortname . '::'};
$self->deb("added our " . $::CURPKG->id) if $::DEBUG & DEBUG::symtab;
}
else {
$::CURPKG = $::NEWPKG // $::CURPKG->{$shortname . '::'};
$self->deb("added my " . $::CURPKG->id) if $::DEBUG & DEBUG::symtab;
};
};
$::begin_compunit = 0;
$::UNIT->{'$?LONGNAME'} ||= $longname ? $longname->{'name'}->Str : '';
}}, $C))
and ($C) = (scalar(do {
$::IN_DECL = ''}, $C))
and ($C) = ($C->_SUBSUMEr(['blockoid'], sub {
my $C = shift;
$C->blockoid
}))
and ($C) = ($C->ws)
and ($C) = ($C->checkyada)
and ($C) = ($C->ws)) {
$C
} else { () }
}))) {
$C
} else { () }

}
}
or $xact->[-2] or
do {
push @gather, do {
my $C = $C;
if (($C) = ($C->before(sub {
my $C=shift;
if (my ($C) = ($C->before(sub {
my $C=shift;
if (my ($C) = ($C->ws)) {
$C->_EXACT("\;")
} else { () }
}))) { ($C) } else { () }
}))
and ($C) = ($C->_BRACKETr(sub {
my $C=shift;
do {    my $C = $C->cursor_xact('ALT ||');
my $xact = $C->xact;
my @gather;
do {
push @gather, do {
my $C = $C;
if (($C) = ($C->before(sub {
my $C=shift;
(($C) x !!do {
$::begin_compunit })
}))
and ($C) = (scalar(do {
{
$longname  or  $C->panic("Compilation unit cannot be anonymous");
$outer == $::UNIT or $C->panic("Semicolon form of " . $::PKGDECL . " definition not allowed in subscope;\n  please use block form");
$::PKGDECL eq 'package' and $C->panic("Semicolon form of package definition indicates a Perl 5 module; unfortunately,\n  STD doesn't know how to parse Perl 5 code yet");
my $shortname = $longname->{'name'}->Str;
$::CURPKG = $::NEWPKG // $::CURPKG->{$shortname . '::'};
$::begin_compunit = 0;
$::CURLEX = $outer;
$::UNIT->{'$?LONGNAME'} = $longname->{'name'}->Str;
}}, $C))
and ($C) = (scalar(do {
$::IN_DECL = ''}, $C))
and ($C) = ($C->_SUBSUMEr(['statementlist'], sub {
my $C = shift;
$C->statementlist
}))
and ($C) = ($C->ws)) {
$C
} else { () }

}
}
or $xact->[-2] or
do {
push @gather, do {
my $C = $C;
if (($C) = ($C->panic("Too late for semicolon form of " . $::PKGDECL . " definition"))
and ($C) = ($C->ws)) {
$C
} else { () }

}
};
@gather;
}
}))) {
$C
} else { () }

}
}
or $xact->[-2] or
do {
push @gather, do {
my $C = $C;
if (($C) = ($C->panic("Unable to parse " . $::PKGDECL . " definition"))
and ($C) = ($C->ws)) {
$C
} else { () }

}
};
@gather;
}
}))) {
$C
} else { () }
}))) {
$C
} else { () }

}
}
or $xact->[-2] or
do {
push @gather, do {
my $C = $C;
if (($C) = ($C->ws)
and ($C) = ($C->panic("Malformed $::PKGDECL"))
and ($C) = ($C->ws)) {
$C
} else { () }

}
};
@gather;
});
}
;
## token declarator {
sub declarator__PEEK { $_[0]->_AUTOLEXpeek('declarator', $retree) }
sub declarator {
no warnings 'recursion';
my $self = shift;


local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;

my $C = $self->cursor_xact("RULE declarator");
my $xact = $C->xact;
my $S = $C->{'_pos'};
$C->{'trait'} = [];
$self->_MATCHIFYr($S, "declarator", $C->_BRACKETr(sub {
my $C=shift;
do {
my ($tag, $try);
my @try;
my $relex;

my $fate;
my $x;
if ($fate = $C->{'_fate'} and $fate->[1] eq 'declarator_0') {
$C->deb("Fate passed to declarator_0: ", ::fatestr($fate)) if $::DEBUG & DEBUG::fates;
($C->{'_fate'}, $tag, $try) = @$fate;
@try = ($try);
$x = 'ALT declarator_0';    # some outer ltm is controlling us
}
else {
$x = 'ALTLTM declarator_0'; # we are top level ltm
}
my $C = $C->cursor_xact($x);
my $xact = $C->{_xact};

my @gather = ();
for (;;) {
unless (@try) {
$relex //= $C->cursor_fate('STD::P6', 'declarator_0', $retree);
@try = $relex->($C) or last;
}
$try = shift(@try) // next;

if (ref $try) {
($C->{'_fate'}, $tag, $try) = @$try;   # next candidate fate
}

$C->deb("declarator_0 trying $tag $try") if $::DEBUG & DEBUG::try_processing;
push @gather, ((
sub {
my $C=shift;
if (my ($C) = ($C->_SUBSUMEr(['variable_declarator'], sub {
my $C = shift;
$C->variable_declarator
}))) {
$C->_OPTr(sub {
my $C=shift;
if (my ($C) = ($C->_BRACKETr(sub {
my $C=shift;
$C->before(sub {
my $C=shift;
if (my ($C) = ($C->before(sub {
my $C=shift;
do {
my $C = $C;
if (($C) = ($C->ws)
and ($C) = ($C->_EXACT("\,"))
and ($C) = ($C->ws)) {
scalar(do {
$::MEMOS[$C->{'_pos'}]->{'declend'} = $::SCOPE}, $C)
} else { () }
};
}))) { ($C) } else { () }
})
}))) { ($C) } else { () }
})
} else { () }
},
sub {
my $C=shift;
if (my ($C) = ($C->_BRACKETr(sub {
my $C=shift;
local $::GOAL = "\)";
my $goalpos = $C;
if (($C) = ($C->_EXACT("\("))
and ($C) = (scalar(do {
}, $C))
and ($C) = ($C->_SUBSUMEr(['signature'], sub {
my $C = shift;
$C->signature
}))
and ($C) = ($C->_BRACKETr(sub {
my $C=shift;
do {    my $C = $C->cursor_xact('ALT ||');
my $xact = $C->xact;
my @gather;
do {
push @gather, $C->_EXACT("\)")
}
or $xact->[-2] or
do {
push @gather, do {
if (my ($C) = ($C->FAILGOAL($::GOAL, 'declarator', $goalpos))) { ($C) } else { () }

}
};
@gather;
}
}))) {
$C
} else { () }
}))) {
$C->_STARr(sub {
my $C=shift;
$C->_SUBSUMEr(['trait'], sub {
my $C = shift;
$C->trait
})
})
} else { () }
},
sub {
my $C=shift;
$C->_SUBSUMEr(['routine_declarator'], sub {
my $C = shift;
$C->routine_declarator
})
},
sub {
my $C=shift;
$C->_SUBSUMEr(['regex_declarator'], sub {
my $C = shift;
$C->regex_declarator
})
},
sub {
my $C=shift;
$C->_SUBSUMEr(['type_declarator'], sub {
my $C = shift;
$C->type_declarator
})
}
)[$try])->($C);
last if @gather;
last if $xact->[-2];  # committed?
}
@gather;
};
}));
}
;
## token multi_declarator:multi {
sub multi_declarator__S_058multi__PEEK { $_[0]->_AUTOLEXpeek('multi_declarator__S_058multi', $retree) }
sub multi_declarator__S_058multi {
no warnings 'recursion';
my $self = shift;

;
local $::MULTINESS = 'multi';
local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;

my $C = $self->cursor_xact("RULE multi_declarator__S_058multi");
my $xact = $C->xact;
my $S = $C->{'_pos'};
$C->{sym} = "multi";
$self->_MATCHIFYr($S, "multi_declarator__S_058multi", do {
my $C = $C;
if (($C) = ($C->_EXACT("multi"))
and ($C) = ($C->spacey)
and ($C) = ($C->ws)
and ($C) = ($C->_BRACKETr(sub {
my $C=shift;
do {    my $C = $C->cursor_xact('ALT ||');
my $xact = $C->xact;
my @gather;
do {
push @gather, $C->_SUBSUMEr(['declarator'], sub {
my $C = shift;
$C->declarator
})
}
or $xact->[-2] or
do {
push @gather, $C->_SUBSUMEr(['routine_def'], sub {
my $C = shift;
$C->routine_def('multi')
})
}
or $xact->[-2] or
do {
push @gather, do {
if (my ($C) = ($C->panic('Malformed multi'))) { ($C) } else { () }

}
};
@gather;
}
}))) {
$C
} else { () }

});
}
;
## token multi_declarator:proto {
sub multi_declarator__S_059proto__PEEK { $_[0]->_AUTOLEXpeek('multi_declarator__S_059proto', $retree) }
sub multi_declarator__S_059proto {
no warnings 'recursion';
my $self = shift;

;
local $::MULTINESS = 'proto';
local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;

my $C = $self->cursor_xact("RULE multi_declarator__S_059proto");
my $xact = $C->xact;
my $S = $C->{'_pos'};
$C->{sym} = "proto";
$self->_MATCHIFYr($S, "multi_declarator__S_059proto", do {
my $C = $C;
if (($C) = ($C->_EXACT("proto"))
and ($C) = ($C->spacey)
and ($C) = ($C->ws)
and ($C) = ($C->_BRACKETr(sub {
my $C=shift;
do {    my $C = $C->cursor_xact('ALT ||');
my $xact = $C->xact;
my @gather;
do {
push @gather, $C->_SUBSUMEr(['declarator'], sub {
my $C = shift;
$C->declarator
})
}
or $xact->[-2] or
do {
push @gather, $C->_SUBSUMEr(['routine_def'], sub {
my $C = shift;
$C->routine_def('proto')
})
}
or $xact->[-2] or
do {
push @gather, do {
if (my ($C) = ($C->panic('Malformed proto'))) { ($C) } else { () }

}
};
@gather;
}
}))) {
$C
} else { () }

});
}
;
## token multi_declarator:only {
sub multi_declarator__S_060only__PEEK { $_[0]->_AUTOLEXpeek('multi_declarator__S_060only', $retree) }
sub multi_declarator__S_060only {
no warnings 'recursion';
my $self = shift;

;
local $::MULTINESS = 'only';
local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;

my $C = $self->cursor_xact("RULE multi_declarator__S_060only");
my $xact = $C->xact;
my $S = $C->{'_pos'};
$C->{sym} = "only";
$self->_MATCHIFYr($S, "multi_declarator__S_060only", do {
my $C = $C;
if (($C) = ($C->_EXACT("only"))
and ($C) = ($C->spacey)
and ($C) = ($C->ws)
and ($C) = ($C->_BRACKETr(sub {
my $C=shift;
do {    my $C = $C->cursor_xact('ALT ||');
my $xact = $C->xact;
my @gather;
do {
push @gather, $C->_SUBSUMEr(['declarator'], sub {
my $C = shift;
$C->declarator
})
}
or $xact->[-2] or
do {
push @gather, $C->_SUBSUMEr(['routine_def'], sub {
my $C = shift;
$C->routine_def('only')
})
}
or $xact->[-2] or
do {
push @gather, do {
if (my ($C) = ($C->panic('Malformed only'))) { ($C) } else { () }

}
};
@gather;
}
}))) {
$C
} else { () }

});
}
;
## token multi_declarator:null {
sub multi_declarator__S_061null__PEEK { $_[0]->_AUTOLEXpeek('multi_declarator__S_061null', $retree) }
sub multi_declarator__S_061null {
no warnings 'recursion';
my $self = shift;

;
local $::MULTINESS = '';
local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;

my $C = $self->cursor_xact("RULE multi_declarator__S_061null");
my $xact = $C->xact;
my $S = $C->{'_pos'};
$C->{sym} = "null";
$self->_MATCHIFYr($S, "multi_declarator__S_061null", $C->_SUBSUMEr(['declarator'], sub {
my $C = shift;
$C->declarator
}));
}
;
## token routine_declarator:sub       { <sym> <routine_def('sub')> }
sub routine_declarator__S_062sub__PEEK { $_[0]->_AUTOLEXpeek('routine_declarator__S_062sub', $retree) }
sub routine_declarator__S_062sub {
no warnings 'recursion';
my $self = shift;

;

local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;

my $C = $self->cursor_xact("RULE routine_declarator__S_062sub");
my $xact = $C->xact;
my $S = $C->{'_pos'};
$C->{sym} = "sub";
$self->_MATCHIFYr($S, "routine_declarator__S_062sub", do {
my $C = $C;
if (($C) = ($C->_EXACT("sub"))
and ($C) = ($C->nofun)) {
$C->_SUBSUMEr(['routine_def'], sub {
my $C = shift;
$C->routine_def('sub')
})
} else { () }

});
}
;
## token routine_declarator:method    { <sym> <method_def> }
sub routine_declarator__S_063method__PEEK { $_[0]->_AUTOLEXpeek('routine_declarator__S_063method', $retree) }
sub routine_declarator__S_063method {
no warnings 'recursion';
my $self = shift;

;

local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;

my $C = $self->cursor_xact("RULE routine_declarator__S_063method");
my $xact = $C->xact;
my $S = $C->{'_pos'};
$C->{sym} = "method";
$self->_MATCHIFYr($S, "routine_declarator__S_063method", do {
my $C = $C;
if (($C) = ($C->_EXACT("method"))
and ($C) = ($C->nofun)) {
$C->_SUBSUMEr(['method_def'], sub {
my $C = shift;
$C->method_def
})
} else { () }

});
}
;
## token routine_declarator:submethod { <sym> <method_def> }
sub routine_declarator__S_064submethod__PEEK { $_[0]->_AUTOLEXpeek('routine_declarator__S_064submethod', $retree) }
sub routine_declarator__S_064submethod {
no warnings 'recursion';
my $self = shift;

;

local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;

my $C = $self->cursor_xact("RULE routine_declarator__S_064submethod");
my $xact = $C->xact;
my $S = $C->{'_pos'};
$C->{sym} = "submethod";
$self->_MATCHIFYr($S, "routine_declarator__S_064submethod", do {
my $C = $C;
if (($C) = ($C->_EXACT("submethod"))
and ($C) = ($C->nofun)) {
$C->_SUBSUMEr(['method_def'], sub {
my $C = shift;
$C->method_def
})
} else { () }

});
}
;
## token routine_declarator:macro     { <sym> <macro_def> }
sub routine_declarator__S_065macro__PEEK { $_[0]->_AUTOLEXpeek('routine_declarator__S_065macro', $retree) }
sub routine_declarator__S_065macro {
no warnings 'recursion';
my $self = shift;

;

local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;

my $C = $self->cursor_xact("RULE routine_declarator__S_065macro");
my $xact = $C->xact;
my $S = $C->{'_pos'};
$C->{sym} = "macro";
$self->_MATCHIFYr($S, "routine_declarator__S_065macro", do {
my $C = $C;
if (($C) = ($C->_EXACT("macro"))
and ($C) = ($C->nofun)) {
$C->_SUBSUMEr(['macro_def'], sub {
my $C = shift;
$C->macro_def
})
} else { () }

});
}
;
## token regex_declarator:regex { <sym>       <regex_def(:!r,:!s)> }
sub regex_declarator__S_066regex__PEEK { $_[0]->_AUTOLEXpeek('regex_declarator__S_066regex', $retree) }
sub regex_declarator__S_066regex {
no warnings 'recursion';
my $self = shift;

;

local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;

my $C = $self->cursor_xact("RULE regex_declarator__S_066regex");
my $xact = $C->xact;
my $S = $C->{'_pos'};
$C->{sym} = "regex";
$self->_MATCHIFYr($S, "regex_declarator__S_066regex", do {
my $C = $C;
if (($C) = ($C->_EXACT("regex"))
and ($C) = ($C->spacey)) {
$C->_SUBSUMEr(['regex_def'], sub {
my $C = shift;
$C->regex_def('r' => 0,'s' => 0)
})
} else { () }

});
}
;
## token regex_declarator:token { <sym>       <regex_def(:r,:!s)> }
sub regex_declarator__S_067token__PEEK { $_[0]->_AUTOLEXpeek('regex_declarator__S_067token', $retree) }
sub regex_declarator__S_067token {
no warnings 'recursion';
my $self = shift;

;

local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;

my $C = $self->cursor_xact("RULE regex_declarator__S_067token");
my $xact = $C->xact;
my $S = $C->{'_pos'};
$C->{sym} = "token";
$self->_MATCHIFYr($S, "regex_declarator__S_067token", do {
my $C = $C;
if (($C) = ($C->_EXACT("token"))
and ($C) = ($C->spacey)) {
$C->_SUBSUMEr(['regex_def'], sub {
my $C = shift;
$C->regex_def('r' => 1,'s' => 0)
})
} else { () }

});
}
;
## token regex_declarator:rule  { <sym>       <regex_def(:r,:s)> }
sub regex_declarator__S_068rule__PEEK { $_[0]->_AUTOLEXpeek('regex_declarator__S_068rule', $retree) }
sub regex_declarator__S_068rule {
no warnings 'recursion';
my $self = shift;

;

local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;

my $C = $self->cursor_xact("RULE regex_declarator__S_068rule");
my $xact = $C->xact;
my $S = $C->{'_pos'};
$C->{sym} = "rule";
$self->_MATCHIFYr($S, "regex_declarator__S_068rule", do {
my $C = $C;
if (($C) = ($C->_EXACT("rule"))
and ($C) = ($C->spacey)) {
$C->_SUBSUMEr(['regex_def'], sub {
my $C = shift;
$C->regex_def('r' => 1,'s' => 1)
})
} else { () }

});
}
;
## rule multisig {
sub multisig__PEEK { $_[0]->_AUTOLEXpeek('multisig', $retree) }
sub multisig {
no warnings 'recursion';
my $self = shift;

my $signum = 0;
local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;

my $C = $self->cursor_xact("RULE multisig");
my $xact = $C->xact;
my $S = $C->{'_pos'};
$C->{'signature'} = [];
$self->_MATCHIFYr($S, "multisig", do {
my $C = $C;
if (($C) = ($C->ws)
and ($C) = ($C->_REPSEPr( sub {
my $C=shift;
$C->_EXACT("\|")
}, sub {
my $C=shift;
if (my ($C) = ($C->_BRACKETr(sub {
my $C=shift;
if (($C) = ($C->ws)
and ($C) = ($C->_PATTERN(qr/\G\:?+/))
and ($C) = ($C->_BRACKETr(sub {
my $C=shift;
local $::GOAL = "\)";
my $goalpos = $C;
if (($C) = ($C->_EXACT("\("))
and ($C) = (scalar(do {
}, $C))
and ($C) = ($C->_SUBSUMEr(['signature'], sub {
my $C = shift;
$C->signature(++$signum)
}))
and ($C) = ($C->_BRACKETr(sub {
my $C=shift;
do {    my $C = $C->cursor_xact('ALT ||');
my $xact = $C->xact;
my @gather;
do {
push @gather, $C->_EXACT("\)")
}
or $xact->[-2] or
do {
push @gather, do {
if (my ($C) = ($C->FAILGOAL($::GOAL, 'signature', $goalpos))) { ($C) } else { () }

}
};
@gather;
}
}))) {
$C
} else { () }
}))
and ($C) = ($C->ws)) {
$C
} else { () }
}))) { ($C) } else { () }
}))
and ($C) = ($C->ws)) {
$C
} else { () }

});
}
;
## method checkyada
sub checkyada {
no warnings 'recursion';
my $self = shift;
eval {
my $statements = $self->{'blockoid'}->{'statementlist'}->{'statement'};
my $startsym = $statements->[0]->{'EXPR'}->{'sym'} // '';
given ($startsym) {
when ('...') {
$::DECLARAND->{'stub'} = 1 }
;
when ('!!!') {
$::DECLARAND->{'stub'} = 1 }
;
when ('???') {
$::DECLARAND->{'stub'} = 1 }
;
when ('*') {
if ($::MULTINESS eq 'proto' and $statements->elems == 1) {
delete $self->{'blockoid'};
$self->{'onlystar'} = 1;
}}
;
}
;
};
return $self;
};
## rule routine_def ($d) {
sub routine_def__PEEK { $_[0]->_AUTOLEXpeek('routine_def', $retree) }
sub routine_def {
no warnings 'recursion';
my $self = shift;

die 'Required argument d omitted' unless @_;
my $d = @_ ? shift() : undef;
local $::CURLEX = $::CURLEX;local $::IN_DECL = $d;local $::DECLARAND;
local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;

my $C = $self->cursor_xact("RULE routine_def");
my $xact = $C->xact;
my $S = $C->{'_pos'};
$C->{'deflongname'} = [];
$C->{'multisig'} = [];
$C->{'sigil'} = [];
$C->{'trait'} = [];
$self->_MATCHIFYr($S, "routine_def", do {    my $C = $C->cursor_xact('ALT ||');
my $xact = $C->xact;
my @gather;
do {
push @gather, do {
my $C = $C;
if (($C) = ($C->ws)
and ($C) = ($C->_BRACKETr(sub {
my $C=shift;
if (($C) = ($C->_OPTr(sub {
my $C=shift;
if (my ($C) = ($C->_BRACKETr(sub {
my $C=shift;
do {
my ($tag, $try);
my @try;
my $relex;

my $fate;
my $x;
if ($fate = $C->{'_fate'} and $fate->[1] eq 'routine_def_0') {
$C->deb("Fate passed to routine_def_0: ", ::fatestr($fate)) if $::DEBUG & DEBUG::fates;
($C->{'_fate'}, $tag, $try) = @$fate;
@try = ($try);
$x = 'ALT routine_def_0';    # some outer ltm is controlling us
}
else {
$x = 'ALTLTM routine_def_0'; # we are top level ltm
}
my $C = $C->cursor_xact($x);
my $xact = $C->{_xact};

my @gather = ();
for (;;) {
unless (@try) {
$relex //= $C->cursor_fate('STD::P6', 'routine_def_0', $retree);
@try = $relex->($C) or last;
}
$try = shift(@try) // next;

if (ref $try) {
($C->{'_fate'}, $tag, $try) = @$try;   # next candidate fate
}

$C->deb("routine_def_0 trying $tag $try") if $::DEBUG & DEBUG::try_processing;
push @gather, ((
sub {
my $C=shift;
if (($C) = ($C->ws)
and ($C) = ($C->_SUBSUMEr(['sigil'], sub {
my $C = shift;
$C->_BRACKETr(sub {
my $C=shift;
$C->_PATTERN(qr/\G\&\*?+/)
})
}))
and ($C) = ($C->ws)
and ($C) = ($C->_OPTr(sub {
my $C=shift;
$C->_SUBSUMEr(['deflongname'], sub {
my $C = shift;
$C->deflongname
})
}))
and ($C) = ($C->ws)) {
$C
} else { () }
},
sub {
my $C=shift;
if (($C) = ($C->ws)
and ($C) = ($C->_SUBSUMEr(['deflongname'], sub {
my $C = shift;
$C->deflongname
}))
and ($C) = ($C->ws)) {
$C
} else { () }
}
)[$try])->($C);
last if @gather;
last if $xact->[-2];  # committed?
}
@gather;
};
}))) { ($C) } else { () }
}))
and ($C) = ($C->ws)
and ($C) = ($C->newlex(1))
and ($C) = ($C->ws)
and ($C) = ($C->_STARr(sub {
my $C=shift;
if (my ($C) = ($C->_BRACKETr(sub {
my $C=shift;
do {
my ($tag, $try);
my @try;
my $relex;

my $fate;
my $x;
if ($fate = $C->{'_fate'} and $fate->[1] eq 'routine_def_1') {
$C->deb("Fate passed to routine_def_1: ", ::fatestr($fate)) if $::DEBUG & DEBUG::fates;
($C->{'_fate'}, $tag, $try) = @$fate;
@try = ($try);
$x = 'ALT routine_def_1';    # some outer ltm is controlling us
}
else {
$x = 'ALTLTM routine_def_1'; # we are top level ltm
}
my $C = $C->cursor_xact($x);
my $xact = $C->{_xact};

my @gather = ();
for (;;) {
unless (@try) {
$relex //= $C->cursor_fate('STD::P6', 'routine_def_1', $retree);
@try = $relex->($C) or last;
}
$try = shift(@try) // next;

if (ref $try) {
($C->{'_fate'}, $tag, $try) = @$try;   # next candidate fate
}

$C->deb("routine_def_1 trying $tag $try") if $::DEBUG & DEBUG::try_processing;
push @gather, ((
sub {
my $C=shift;
if (($C) = ($C->ws)
and ($C) = ($C->_SUBSUMEr(['multisig'], sub {
my $C = shift;
$C->multisig
}))
and ($C) = ($C->ws)) {
$C
} else { () }
},
sub {
my $C=shift;
if (($C) = ($C->ws)
and ($C) = ($C->_SUBSUMEr(['trait'], sub {
my $C = shift;
$C->trait
}))
and ($C) = ($C->ws)) {
$C
} else { () }
}
)[$try])->($C);
last if @gather;
last if $xact->[-2];  # committed?
}
@gather;
};
}))) { ($C) } else { () }
}))
and ($C) = ($C->ws)
and ($C) = ($C->_OPTr(sub {
my $C=shift;
if (my ($C) = ($C->_BRACKETr(sub {
my $C=shift;
if (($C) = ($C->ws)
and ($C) = ($C->_NOTBEFORE(sub {
my $C=shift;
if (my ($C) = ($C->before(sub {
my $C=shift;
if (my ($C) = ($C->ws)) {
$C->_EXACT("\{")
} else { () }
}))) { ($C) } else { () }
}))
and ($C) = ($C->panic("Malformed block"))
and ($C) = ($C->ws)) {
$C
} else { () }
}))) { ($C) } else { () }
}))
and ($C) = ($C->ws)
and ($C) = ($C->_NOTBEFORE(sub {
my $C=shift;
(($C) x !!do {
$::IN_DECL = ''})
}))
and ($C) = ($C->_SUBSUMEr(['blockoid'], sub {
my $C = shift;
$C->blockoid
}))
and ($C) = ($C->checkyada)
and ($C) = ($C->getsig)
and ($C) = ($C->getdecl)) {
$C
} else { () }
}))
and ($C) = ($C->ws)) {
$C
} else { () }

}
}
or $xact->[-2] or
do {
push @gather, do {
my $C = $C;
if (($C) = ($C->ws)
and ($C) = ($C->panic("Malformed routine"))
and ($C) = ($C->ws)) {
$C
} else { () }

}
};
@gather;
});
}
;
## rule method_def () {
sub method_def__PEEK { $_[0]->_AUTOLEXpeek('method_def', $retree) }
sub method_def {
no warnings 'recursion';
my $self = shift;

local $::CURLEX = $::CURLEX;local $::IN_DECL = 'method';local $::DECLARAND;
local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;

my $C = $self->cursor_xact("RULE method_def");
my $xact = $C->xact;
my $S = $C->{'_pos'};
$C->{'multisig'} = [];
$C->{'trait'} = [];
$self->_MATCHIFYr($S, "method_def", do {    my $C = $C->cursor_xact('ALT ||');
my $xact = $C->xact;
my @gather;
do {
push @gather, do {
my $C = $C;
if (($C) = ($C->ws)
and ($C) = ($C->newlex(1))
and ($C) = ($C->ws)
and ($C) = ($C->_BRACKETr(sub {
my $C=shift;
if (($C) = ($C->_BRACKETr(sub {
my $C=shift;
do {
my ($tag, $try);
my @try;
my $relex;

my $fate;
my $x;
if ($fate = $C->{'_fate'} and $fate->[1] eq 'method_def_0') {
$C->deb("Fate passed to method_def_0: ", ::fatestr($fate)) if $::DEBUG & DEBUG::fates;
($C->{'_fate'}, $tag, $try) = @$fate;
@try = ($try);
$x = 'ALT method_def_0';    # some outer ltm is controlling us
}
else {
$x = 'ALTLTM method_def_0'; # we are top level ltm
}
my $C = $C->cursor_xact($x);
my $xact = $C->{_xact};

my @gather = ();
for (;;) {
unless (@try) {
$relex //= $C->cursor_fate('STD::P6', 'method_def_0', $retree);
@try = $relex->($C) or last;
}
$try = shift(@try) // next;

if (ref $try) {
($C->{'_fate'}, $tag, $try) = @$try;   # next candidate fate
}

$C->deb("method_def_0 trying $tag $try") if $::DEBUG & DEBUG::try_processing;
push @gather, ((
sub {
my $C=shift;
if (($C) = ($C->_SUBSUMEr(['type'], sub {
my $C = shift;
$C->_BRACKETr(sub {
my $C=shift;
$C->_PATTERN(qr/\G(?:[!^])?+/)
})
}))
and ($C) = ($C->_SUBSUMEr(['longname'], sub {
my $C = shift;
$C->longname
}))
and ($C) = ($C->ws)
and ($C) = ($C->_STARr(sub {
my $C=shift;
if (my ($C) = ($C->_BRACKETr(sub {
my $C=shift;
do {
my ($tag, $try);
my @try;
my $relex;

my $fate;
my $x;
if ($fate = $C->{'_fate'} and $fate->[1] eq 'method_def_1') {
$C->deb("Fate passed to method_def_1: ", ::fatestr($fate)) if $::DEBUG & DEBUG::fates;
($C->{'_fate'}, $tag, $try) = @$fate;
@try = ($try);
$x = 'ALT method_def_1';    # some outer ltm is controlling us
}
else {
$x = 'ALTLTM method_def_1'; # we are top level ltm
}
my $C = $C->cursor_xact($x);
my $xact = $C->{_xact};

my @gather = ();
for (;;) {
unless (@try) {
$relex //= $C->cursor_fate('STD::P6', 'method_def_1', $retree);
@try = $relex->($C) or last;
}
$try = shift(@try) // next;

if (ref $try) {
($C->{'_fate'}, $tag, $try) = @$try;   # next candidate fate
}

$C->deb("method_def_1 trying $tag $try") if $::DEBUG & DEBUG::try_processing;
push @gather, ((
sub {
my $C=shift;
if (($C) = ($C->ws)
and ($C) = ($C->_SUBSUMEr(['multisig'], sub {
my $C = shift;
$C->multisig
}))
and ($C) = ($C->ws)) {
$C
} else { () }
},
sub {
my $C=shift;
if (($C) = ($C->ws)
and ($C) = ($C->_SUBSUMEr(['trait'], sub {
my $C = shift;
$C->trait
}))
and ($C) = ($C->ws)) {
$C
} else { () }
}
)[$try])->($C);
last if @gather;
last if $xact->[-2];  # committed?
}
@gather;
};
}))) { ($C) } else { () }
}))
and ($C) = ($C->ws)) {
$C
} else { () }
},
sub {
my $C=shift;
if (($C) = ($C->_SUBSUMEr(['multisig'], sub {
my $C = shift;
$C->multisig
}))
and ($C) = ($C->ws)
and ($C) = ($C->_STARr(sub {
my $C=shift;
$C->_SUBSUMEr(['trait'], sub {
my $C = shift;
$C->trait
})
}))
and ($C) = ($C->ws)) {
$C
} else { () }
},
sub {
my $C=shift;
if (($C) = ($C->_SUBSUMEr(['sigil'], sub {
my $C = shift;
$C->sigil
}))
and ($C) = ($C->ws)
and ($C) = ($C->_EXACT("\."))
and ($C) = ($C->ws)
and ($C) = ($C->_BRACKETr(sub {
my $C=shift;
do {
my ($tag, $try);
my @try;
my $relex;

my $fate;
my $x;
if ($fate = $C->{'_fate'} and $fate->[1] eq 'method_def_2') {
$C->deb("Fate passed to method_def_2: ", ::fatestr($fate)) if $::DEBUG & DEBUG::fates;
($C->{'_fate'}, $tag, $try) = @$fate;
@try = ($try);
$x = 'ALT method_def_2';    # some outer ltm is controlling us
}
else {
$x = 'ALTLTM method_def_2'; # we are top level ltm
}
my $C = $C->cursor_xact($x);
my $xact = $C->{_xact};

my @gather = ();
for (;;) {
unless (@try) {
$relex //= $C->cursor_fate('STD::P6', 'method_def_2', $retree);
@try = $relex->($C) or last;
}
$try = shift(@try) // next;

if (ref $try) {
($C->{'_fate'}, $tag, $try) = @$try;   # next candidate fate
}

$C->deb("method_def_2 trying $tag $try") if $::DEBUG & DEBUG::try_processing;
push @gather, ((
sub {
my $C=shift;
if (($C) = ($C->_BRACKETr(sub {
my $C=shift;
local $::GOAL = "\)";
my $goalpos = $C;
if (($C) = ($C->_EXACT("\("))
and ($C) = (scalar(do {
}, $C))
and ($C) = ($C->_SUBSUMEr(['signature'], sub {
my $C = shift;
$C->signature
}))
and ($C) = ($C->_BRACKETr(sub {
my $C=shift;
do {    my $C = $C->cursor_xact('ALT ||');
my $xact = $C->xact;
my @gather;
do {
push @gather, $C->_EXACT("\)")
}
or $xact->[-2] or
do {
push @gather, do {
if (my ($C) = ($C->FAILGOAL($::GOAL, 'subscript signature', $goalpos))) { ($C) } else { () }

}
};
@gather;
}
}))) {
$C
} else { () }
}))
and ($C) = ($C->ws)) {
$C
} else { () }
},
sub {
my $C=shift;
if (($C) = ($C->_BRACKETr(sub {
my $C=shift;
local $::GOAL = "\]";
my $goalpos = $C;
if (($C) = ($C->_EXACT("\["))
and ($C) = (scalar(do {
}, $C))
and ($C) = ($C->_SUBSUMEr(['signature'], sub {
my $C = shift;
$C->signature
}))
and ($C) = ($C->_BRACKETr(sub {
my $C=shift;
do {    my $C = $C->cursor_xact('ALT ||');
my $xact = $C->xact;
my @gather;
do {
push @gather, $C->_EXACT("\]")
}
or $xact->[-2] or
do {
push @gather, do {
if (my ($C) = ($C->FAILGOAL($::GOAL, 'subscript signature', $goalpos))) { ($C) } else { () }

}
};
@gather;
}
}))) {
$C
} else { () }
}))
and ($C) = ($C->ws)) {
$C
} else { () }
},
sub {
my $C=shift;
if (($C) = ($C->_BRACKETr(sub {
my $C=shift;
local $::GOAL = "\}";
my $goalpos = $C;
if (($C) = ($C->_EXACT("\{"))
and ($C) = (scalar(do {
}, $C))
and ($C) = ($C->_SUBSUMEr(['signature'], sub {
my $C = shift;
$C->signature
}))
and ($C) = ($C->_BRACKETr(sub {
my $C=shift;
do {    my $C = $C->cursor_xact('ALT ||');
my $xact = $C->xact;
my @gather;
do {
push @gather, $C->_EXACT("\}")
}
or $xact->[-2] or
do {
push @gather, do {
if (my ($C) = ($C->FAILGOAL($::GOAL, 'subscript signature', $goalpos))) { ($C) } else { () }

}
};
@gather;
}
}))) {
$C
} else { () }
}))
and ($C) = ($C->ws)) {
$C
} else { () }
},
sub {
my $C=shift;
if (($C) = ($C->before(sub {
my $C=shift;
if (my ($C) = ($C->before(sub {
my $C=shift;
if (my ($C) = ($C->ws)) {
$C->_EXACT("\<")
} else { () }
}))) { ($C) } else { () }
}))
and ($C) = ($C->_SUBSUMEr(['postcircumfix'], sub {
my $C = shift;
$C->postcircumfix
}))
and ($C) = ($C->ws)) {
$C
} else { () }
}
)[$try])->($C);
last if @gather;
last if $xact->[-2];  # committed?
}
@gather;
};
}))
and ($C) = ($C->_STARr(sub {
my $C=shift;
$C->_SUBSUMEr(['trait'], sub {
my $C = shift;
$C->trait
})
}))
and ($C) = ($C->ws)) {
$C
} else { () }
},
sub {
my $C=shift;
if (my ($C) = ($C->before(sub {
my $C=shift;
$C
}))) { ($C) } else { () }
}
)[$try])->($C);
last if @gather;
last if $xact->[-2];  # committed?
}
@gather;
};
}))
and ($C) = (scalar(do {
$::IN_DECL = ''}, $C))
and ($C) = ($C->_SUBSUMEr(['blockoid'], sub {
my $C = shift;
$C->blockoid
}))
and ($C) = ($C->checkyada)
and ($C) = ($C->getsig)
and ($C) = ($C->getdecl)) {
$C
} else { () }
}))
and ($C) = ($C->ws)) {
$C
} else { () }

}
}
or $xact->[-2] or
do {
push @gather, do {
my $C = $C;
if (($C) = ($C->ws)
and ($C) = ($C->panic("Malformed method"))
and ($C) = ($C->ws)) {
$C
} else { () }

}
};
@gather;
});
}
;
## rule regex_def (:$r, :$s) {
sub regex_def__PEEK { $_[0]->_AUTOLEXpeek('regex_def', $retree) }
sub regex_def {
no warnings 'recursion';
my $self = shift;

my %args = @_;
my $r = exists $args{r} ? delete $args{r} : undef;
my $s = exists $args{s} ? delete $args{s} : undef;
local $::CURLEX = $::CURLEX;local $::IN_DECL = 'regex';local %::RX = %::RX;local $::DECLARAND;
local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;

my $C = $self->cursor_xact("RULE regex_def");
my $xact = $C->xact;
my $S = $C->{'_pos'};
$C->{'deflongname'} = [];
$C->{'signature'} = [];
$C->{'trait'} = [];
$self->_MATCHIFYr($S, "regex_def", do {    my $C = $C->cursor_xact('ALT ||');
my $xact = $C->xact;
my @gather;
do {
push @gather, do {
my $C = $C;
if (($C) = ($C->ws)
and ($C) = (scalar(do {
$::RX{'s'} = $s;
$::RX{'r'} = $r;
}, $C))
and ($C) = ($C->_BRACKETr(sub {
my $C=shift;
if (($C) = ($C->_OPTr(sub {
my $C=shift;
if (my ($C) = ($C->_BRACKETr(sub {
my $C=shift;
do {
my ($tag, $try);
my @try;
my $relex;

my $fate;
my $x;
if ($fate = $C->{'_fate'} and $fate->[1] eq 'regex_def_0') {
$C->deb("Fate passed to regex_def_0: ", ::fatestr($fate)) if $::DEBUG & DEBUG::fates;
($C->{'_fate'}, $tag, $try) = @$fate;
@try = ($try);
$x = 'ALT regex_def_0';    # some outer ltm is controlling us
}
else {
$x = 'ALTLTM regex_def_0'; # we are top level ltm
}
my $C = $C->cursor_xact($x);
my $xact = $C->{_xact};

my @gather = ();
for (;;) {
unless (@try) {
$relex //= $C->cursor_fate('STD::P6', 'regex_def_0', $retree);
@try = $relex->($C) or last;
}
$try = shift(@try) // next;

if (ref $try) {
($C->{'_fate'}, $tag, $try) = @$try;   # next candidate fate
}

$C->deb("regex_def_0 trying $tag $try") if $::DEBUG & DEBUG::try_processing;
push @gather, ((
sub {
my $C=shift;
if (($C) = ($C->ws)
and ($C) = ($C->_EXACT("\&"))
and ($C) = ($C->_OPTr(sub {
my $C=shift;
$C->_SUBSUMEr(['deflongname'], sub {
my $C = shift;
$C->deflongname
})
}))
and ($C) = ($C->ws)) {
$C
} else { () }
},
sub {
my $C=shift;
if (($C) = ($C->ws)
and ($C) = ($C->_SUBSUMEr(['deflongname'], sub {
my $C = shift;
$C->deflongname
}))
and ($C) = ($C->ws)) {
$C
} else { () }
}
)[$try])->($C);
last if @gather;
last if $xact->[-2];  # committed?
}
@gather;
};
}))) { ($C) } else { () }
}))
and ($C) = ($C->ws)
and ($C) = ($C->newlex(1))
and ($C) = ($C->ws)
and ($C) = ($C->_STARr(sub {
my $C=shift;
if (my ($C) = ($C->_BRACKETr(sub {
my $C=shift;
do {
my ($tag, $try);
my @try;
my $relex;

my $fate;
my $x;
if ($fate = $C->{'_fate'} and $fate->[1] eq 'regex_def_1') {
$C->deb("Fate passed to regex_def_1: ", ::fatestr($fate)) if $::DEBUG & DEBUG::fates;
($C->{'_fate'}, $tag, $try) = @$fate;
@try = ($try);
$x = 'ALT regex_def_1';    # some outer ltm is controlling us
}
else {
$x = 'ALTLTM regex_def_1'; # we are top level ltm
}
my $C = $C->cursor_xact($x);
my $xact = $C->{_xact};

my @gather = ();
for (;;) {
unless (@try) {
$relex //= $C->cursor_fate('STD::P6', 'regex_def_1', $retree);
@try = $relex->($C) or last;
}
$try = shift(@try) // next;

if (ref $try) {
($C->{'_fate'}, $tag, $try) = @$try;   # next candidate fate
}

$C->deb("regex_def_1 trying $tag $try") if $::DEBUG & DEBUG::try_processing;
push @gather, ((
sub {
my $C=shift;
if (($C) = ($C->ws)
and ($C) = ($C->_BRACKETr(sub {
my $C=shift;
if (($C) = ($C->_PATTERN(qr/\G\:?+\(/))
and ($C) = ($C->ws)
and ($C) = ($C->_SUBSUMEr(['signature'], sub {
my $C = shift;
$C->signature(1)
}))
and ($C) = ($C->ws)) {
$C->_EXACT("\)")
} else { () }
}))
and ($C) = ($C->ws)) {
$C
} else { () }
},
sub {
my $C=shift;
if (($C) = ($C->ws)
and ($C) = ($C->_SUBSUMEr(['trait'], sub {
my $C = shift;
$C->trait
}))
and ($C) = ($C->ws)) {
$C
} else { () }
}
)[$try])->($C);
last if @gather;
last if $xact->[-2];  # committed?
}
@gather;
};
}))) { ($C) } else { () }
}))
and ($C) = ($C->ws)
and ($C) = ($C->_OPTr(sub {
my $C=shift;
if (my ($C) = ($C->_BRACKETr(sub {
my $C=shift;
if (($C) = ($C->ws)
and ($C) = ($C->_NOTBEFORE(sub {
my $C=shift;
if (my ($C) = ($C->before(sub {
my $C=shift;
if (my ($C) = ($C->ws)) {
$C->_EXACT("\{")
} else { () }
}))) { ($C) } else { () }
}))
and ($C) = ($C->panic("Malformed block"))
and ($C) = ($C->ws)) {
$C
} else { () }
}))) { ($C) } else { () }
}))
and ($C) = ($C->ws)
and ($C) = (scalar(do {
$::IN_DECL = ''}, $C))
and ($C) = ($C->finishlex)
and ($C) = ($C->ws)
and ($C) = ($C->_SUBSUMEr(['regex_block'], sub {
my $C = shift;
$C->regex_block
}))
and ($C) = ($C->getsig)
and ($C) = ($C->getdecl)) {
$C
} else { () }
}))
and ($C) = ($C->ws)) {
$C
} else { () }

}
}
or $xact->[-2] or
do {
push @gather, do {
my $C = $C;
if (($C) = ($C->ws)
and ($C) = ($C->panic("Malformed regex"))
and ($C) = ($C->ws)) {
$C
} else { () }

}
};
@gather;
});
}
;
## rule macro_def () {
sub macro_def__PEEK { $_[0]->_AUTOLEXpeek('macro_def', $retree) }
sub macro_def {
no warnings 'recursion';
my $self = shift;

local $::CURLEX = $::CURLEX;local $::IN_DECL = 'macro';local $::DECLARAND;
local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;

my $C = $self->cursor_xact("RULE macro_def");
my $xact = $C->xact;
my $S = $C->{'_pos'};
$C->{'deflongname'} = [];
$C->{'multisig'} = [];
$C->{'trait'} = [];
$self->_MATCHIFYr($S, "macro_def", do {    my $C = $C->cursor_xact('ALT ||');
my $xact = $C->xact;
my @gather;
do {
push @gather, do {
my $C = $C;
if (($C) = ($C->ws)
and ($C) = ($C->_BRACKETr(sub {
my $C=shift;
if (($C) = ($C->_OPTr(sub {
my $C=shift;
if (my ($C) = ($C->_BRACKETr(sub {
my $C=shift;
do {
my ($tag, $try);
my @try;
my $relex;

my $fate;
my $x;
if ($fate = $C->{'_fate'} and $fate->[1] eq 'macro_def_0') {
$C->deb("Fate passed to macro_def_0: ", ::fatestr($fate)) if $::DEBUG & DEBUG::fates;
($C->{'_fate'}, $tag, $try) = @$fate;
@try = ($try);
$x = 'ALT macro_def_0';    # some outer ltm is controlling us
}
else {
$x = 'ALTLTM macro_def_0'; # we are top level ltm
}
my $C = $C->cursor_xact($x);
my $xact = $C->{_xact};

my @gather = ();
for (;;) {
unless (@try) {
$relex //= $C->cursor_fate('STD::P6', 'macro_def_0', $retree);
@try = $relex->($C) or last;
}
$try = shift(@try) // next;

if (ref $try) {
($C->{'_fate'}, $tag, $try) = @$try;   # next candidate fate
}

$C->deb("macro_def_0 trying $tag $try") if $::DEBUG & DEBUG::try_processing;
push @gather, ((
sub {
my $C=shift;
if (($C) = ($C->ws)
and ($C) = ($C->_EXACT("\&"))
and ($C) = ($C->_OPTr(sub {
my $C=shift;
$C->_SUBSUMEr(['deflongname'], sub {
my $C = shift;
$C->deflongname
})
}))
and ($C) = ($C->ws)) {
$C
} else { () }
},
sub {
my $C=shift;
if (($C) = ($C->ws)
and ($C) = ($C->_SUBSUMEr(['deflongname'], sub {
my $C = shift;
$C->deflongname
}))
and ($C) = ($C->ws)) {
$C
} else { () }
}
)[$try])->($C);
last if @gather;
last if $xact->[-2];  # committed?
}
@gather;
};
}))) { ($C) } else { () }
}))
and ($C) = ($C->ws)
and ($C) = ($C->newlex(1))
and ($C) = ($C->ws)
and ($C) = ($C->_STARr(sub {
my $C=shift;
if (my ($C) = ($C->_BRACKETr(sub {
my $C=shift;
do {
my ($tag, $try);
my @try;
my $relex;

my $fate;
my $x;
if ($fate = $C->{'_fate'} and $fate->[1] eq 'macro_def_1') {
$C->deb("Fate passed to macro_def_1: ", ::fatestr($fate)) if $::DEBUG & DEBUG::fates;
($C->{'_fate'}, $tag, $try) = @$fate;
@try = ($try);
$x = 'ALT macro_def_1';    # some outer ltm is controlling us
}
else {
$x = 'ALTLTM macro_def_1'; # we are top level ltm
}
my $C = $C->cursor_xact($x);
my $xact = $C->{_xact};

my @gather = ();
for (;;) {
unless (@try) {
$relex //= $C->cursor_fate('STD::P6', 'macro_def_1', $retree);
@try = $relex->($C) or last;
}
$try = shift(@try) // next;

if (ref $try) {
($C->{'_fate'}, $tag, $try) = @$try;   # next candidate fate
}

$C->deb("macro_def_1 trying $tag $try") if $::DEBUG & DEBUG::try_processing;
push @gather, ((
sub {
my $C=shift;
if (($C) = ($C->ws)
and ($C) = ($C->_SUBSUMEr(['multisig'], sub {
my $C = shift;
$C->multisig
}))
and ($C) = ($C->ws)) {
$C
} else { () }
},
sub {
my $C=shift;
if (($C) = ($C->ws)
and ($C) = ($C->_SUBSUMEr(['trait'], sub {
my $C = shift;
$C->trait
}))
and ($C) = ($C->ws)) {
$C
} else { () }
}
)[$try])->($C);
last if @gather;
last if $xact->[-2];  # committed?
}
@gather;
};
}))) { ($C) } else { () }
}))
and ($C) = ($C->ws)
and ($C) = ($C->_OPTr(sub {
my $C=shift;
if (my ($C) = ($C->_BRACKETr(sub {
my $C=shift;
if (($C) = ($C->ws)
and ($C) = ($C->_NOTBEFORE(sub {
my $C=shift;
if (my ($C) = ($C->before(sub {
my $C=shift;
if (my ($C) = ($C->ws)) {
$C->_EXACT("\{")
} else { () }
}))) { ($C) } else { () }
}))
and ($C) = ($C->panic("Malformed block"))
and ($C) = ($C->ws)) {
$C
} else { () }
}))) { ($C) } else { () }
}))
and ($C) = ($C->ws)
and ($C) = (scalar(do {
$::IN_DECL = ''}, $C))
and ($C) = ($C->_SUBSUMEr(['blockoid'], sub {
my $C = shift;
$C->blockoid
}))
and ($C) = ($C->checkyada)
and ($C) = ($C->getsig)
and ($C) = ($C->getdecl)) {
$C
} else { () }
}))
and ($C) = ($C->ws)) {
$C
} else { () }

}
}
or $xact->[-2] or
do {
push @gather, do {
my $C = $C;
if (($C) = ($C->ws)
and ($C) = ($C->panic("Malformed macro"))
and ($C) = ($C->ws)) {
$C
} else { () }

}
};
@gather;
});
}
;
## rule trait {
sub trait__PEEK { $_[0]->_AUTOLEXpeek('trait', $retree) }
sub trait {
no warnings 'recursion';
my $self = shift;

local $::IN_DECL = 0;
local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;

my $C = $self->cursor_xact("RULE trait");
my $xact = $C->xact;
my $S = $C->{'_pos'};
$self->_MATCHIFYr($S, "trait", do {
my $C = $C;
if (($C) = ($C->ws)
and ($C) = ($C->_BRACKETr(sub {
my $C=shift;
do {
my ($tag, $try);
my @try;
my $relex;

my $fate;
my $x;
if ($fate = $C->{'_fate'} and $fate->[1] eq 'trait_0') {
$C->deb("Fate passed to trait_0: ", ::fatestr($fate)) if $::DEBUG & DEBUG::fates;
($C->{'_fate'}, $tag, $try) = @$fate;
@try = ($try);
$x = 'ALT trait_0';    # some outer ltm is controlling us
}
else {
$x = 'ALTLTM trait_0'; # we are top level ltm
}
my $C = $C->cursor_xact($x);
my $xact = $C->{_xact};

my @gather = ();
for (;;) {
unless (@try) {
$relex //= $C->cursor_fate('STD::P6', 'trait_0', $retree);
@try = $relex->($C) or last;
}
$try = shift(@try) // next;

if (ref $try) {
($C->{'_fate'}, $tag, $try) = @$try;   # next candidate fate
}

$C->deb("trait_0 trying $tag $try") if $::DEBUG & DEBUG::try_processing;
push @gather, ((
sub {
my $C=shift;
if (($C) = ($C->_SUBSUMEr(['trait_mod'], sub {
my $C = shift;
$C->trait_mod
}))
and ($C) = ($C->ws)) {
$C
} else { () }
},
sub {
my $C=shift;
if (($C) = ($C->_SUBSUMEr(['colonpair'], sub {
my $C = shift;
$C->colonpair
}))
and ($C) = ($C->ws)) {
$C
} else { () }
}
)[$try])->($C);
last if @gather;
last if $xact->[-2];  # committed?
}
@gather;
};
}))) {
$C
} else { () }

});
}
;
## token trait_mod:is {
sub trait_mod__S_069is__PEEK { $_[0]->_AUTOLEXpeek('trait_mod__S_069is', $retree) }
sub trait_mod__S_069is {
no warnings 'recursion';
my $self = shift;

;

local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;

my $C = $self->cursor_xact("RULE trait_mod__S_069is");
my $xact = $C->xact;
my $S = $C->{'_pos'};
$C->{'circumfix'} = [];
$C->{sym} = "is";
$self->_MATCHIFYr($S, "trait_mod__S_069is", do {
my $C = $C;
if (($C) = ($C->_EXACT("is"))
and ($C) = ($C->spacey)
and ($C) = ($C->ws)
and ($C) = ($C->_SUBSUMEr(['longname'], sub {
my $C = shift;
$C->longname
}))
and ($C) = ($C->_OPTr(sub {
my $C=shift;
$C->_SUBSUMEr(['circumfix'], sub {
my $C = shift;
$C->circumfix
})
}))
and ($C) = ($C->ws)) {
scalar(do {
my $M = $C;
{
if ($::DECLARAND) {
my $traitname = $M->{'longname'}->Str;
$::DECLARAND->{$traitname} = $self->gettrait($traitname, $M->{'circumfix'});
}}}, $C)
} else { () }

});
}
;
## token trait_mod:hides {
sub trait_mod__S_070hides__PEEK { $_[0]->_AUTOLEXpeek('trait_mod__S_070hides', $retree) }
sub trait_mod__S_070hides {
no warnings 'recursion';
my $self = shift;

;

local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;

my $C = $self->cursor_xact("RULE trait_mod__S_070hides");
my $xact = $C->xact;
my $S = $C->{'_pos'};
$C->{sym} = "hides";
$self->_MATCHIFYr($S, "trait_mod__S_070hides", do {
my $C = $C;
if (($C) = ($C->_EXACT("hides"))
and ($C) = ($C->spacey)
and ($C) = ($C->ws)
and ($C) = ($C->_SUBSUMEr(['module_name'], sub {
my $C = shift;
$C->module_name
}))
and ($C) = ($C->ws)) {
$C
} else { () }

});
}
;
## token trait_mod:does {
sub trait_mod__S_071does__PEEK { $_[0]->_AUTOLEXpeek('trait_mod__S_071does', $retree) }
sub trait_mod__S_071does {
no warnings 'recursion';
my $self = shift;

;
local $::PKGDECL = 'role';
local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;

my $C = $self->cursor_xact("RULE trait_mod__S_071does");
my $xact = $C->xact;
my $S = $C->{'_pos'};
$C->{sym} = "does";
$self->_MATCHIFYr($S, "trait_mod__S_071does", do {
my $C = $C;
if (($C) = ($C->_EXACT("does"))
and ($C) = ($C->spacey)
and ($C) = ($C->ws)
and ($C) = ($C->_SUBSUMEr(['module_name'], sub {
my $C = shift;
$C->module_name
}))
and ($C) = ($C->ws)) {
$C
} else { () }

});
}
;
## token trait_mod:will {
sub trait_mod__S_072will__PEEK { $_[0]->_AUTOLEXpeek('trait_mod__S_072will', $retree) }
sub trait_mod__S_072will {
no warnings 'recursion';
my $self = shift;

;

local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;

my $C = $self->cursor_xact("RULE trait_mod__S_072will");
my $xact = $C->xact;
my $S = $C->{'_pos'};
$C->{sym} = "will";
$self->_MATCHIFYr($S, "trait_mod__S_072will", do {
my $C = $C;
if (($C) = ($C->_EXACT("will"))
and ($C) = ($C->spacey)
and ($C) = ($C->ws)
and ($C) = ($C->_SUBSUMEr(['identifier'], sub {
my $C = shift;
$C->identifier
}))
and ($C) = ($C->ws)
and ($C) = ($C->_SUBSUMEr(['pblock'], sub {
my $C = shift;
$C->pblock
}))
and ($C) = ($C->ws)) {
$C
} else { () }

});
}
;
## token trait_mod:of {
sub trait_mod__S_073of__PEEK { $_[0]->_AUTOLEXpeek('trait_mod__S_073of', $retree) }
sub trait_mod__S_073of {
no warnings 'recursion';
my $self = shift;

;

local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;

my $C = $self->cursor_xact("RULE trait_mod__S_073of");
my $xact = $C->xact;
my $S = $C->{'_pos'};
$C->{sym} = "of";
$self->_MATCHIFYr($S, "trait_mod__S_073of", do {
my $C = $C;
if (($C) = ($C->_BRACKETr(sub {
my $C=shift;
do {
my ($tag, $try);
my @try;
my $relex;

my $fate;
my $x;
if ($fate = $C->{'_fate'} and $fate->[1] eq 'trait_mod__S_073of_0') {
$C->deb("Fate passed to trait_mod__S_073of_0: ", ::fatestr($fate)) if $::DEBUG & DEBUG::fates;
($C->{'_fate'}, $tag, $try) = @$fate;
@try = ($try);
$x = 'ALT trait_mod__S_073of_0';    # some outer ltm is controlling us
}
else {
$x = 'ALTLTM trait_mod__S_073of_0'; # we are top level ltm
}
my $C = $C->cursor_xact($x);
my $xact = $C->{_xact};

my @gather = ();
for (;;) {
unless (@try) {
$relex //= $C->cursor_fate('STD::P6', 'trait_mod__S_073of_0', $retree);
@try = $relex->($C) or last;
}
$try = shift(@try) // next;

if (ref $try) {
($C->{'_fate'}, $tag, $try) = @$try;   # next candidate fate
}

$C->deb("trait_mod__S_073of_0 trying $tag $try") if $::DEBUG & DEBUG::try_processing;
push @gather, ((
sub {
my $C=shift;
$C->_EXACT("of")
},
sub {
my $C=shift;
$C->_EXACT("returns")
}
)[$try])->($C);
last if @gather;
last if $xact->[-2];  # committed?
}
@gather;
};
}))
and ($C) = ($C->ws)
and ($C) = ($C->_SUBSUMEr(['typename'], sub {
my $C = shift;
$C->typename
}))
and ($C) = ($C->ws)
and ($C) = ($C->_OPTr(sub {
my $C=shift;
if (my ($C) = ($C->_BRACKETr(sub {
my $C=shift;
if (($C) = ($C->ws)
and ($C) = ($C->before(sub {
my $C=shift;
(($C) x !!do {
$::DECLARAND->{'of'} })
}))
and ($C) = ($C->sorry("Extra 'of' type; already declared as type " . $::DECLARAND->{'of'}->Str))
and ($C) = ($C->ws)) {
$C
} else { () }
}))) { ($C) } else { () }
}))
and ($C) = ($C->ws)) {
scalar(do {
my $M = $C;
$::DECLARAND->{'of'} = $M->{'typename'}}, $C)
} else { () }

});
}
;
## token trait_mod:as      { <sym>:s <typename> }
sub trait_mod__S_074as__PEEK { $_[0]->_AUTOLEXpeek('trait_mod__S_074as', $retree) }
sub trait_mod__S_074as {
no warnings 'recursion';
my $self = shift;

;

local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;

my $C = $self->cursor_xact("RULE trait_mod__S_074as");
my $xact = $C->xact;
my $S = $C->{'_pos'};
$C->{sym} = "as";
$self->_MATCHIFYr($S, "trait_mod__S_074as", do {
my $C = $C;
if (($C) = ($C->_EXACT("as"))
and ($C) = ($C->spacey)
and ($C) = ($C->ws)
and ($C) = ($C->_SUBSUMEr(['typename'], sub {
my $C = shift;
$C->typename
}))
and ($C) = ($C->ws)) {
$C
} else { () }

});
}
;
## token trait_mod:handles { <sym>:s <term> }
sub trait_mod__S_075handles__PEEK { $_[0]->_AUTOLEXpeek('trait_mod__S_075handles', $retree) }
sub trait_mod__S_075handles {
no warnings 'recursion';
my $self = shift;

;

local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;

my $C = $self->cursor_xact("RULE trait_mod__S_075handles");
my $xact = $C->xact;
my $S = $C->{'_pos'};
$C->{sym} = "handles";
$self->_MATCHIFYr($S, "trait_mod__S_075handles", do {
my $C = $C;
if (($C) = ($C->_EXACT("handles"))
and ($C) = ($C->spacey)
and ($C) = ($C->ws)
and ($C) = ($C->_SUBSUMEr(['term'], sub {
my $C = shift;
$C->term
}))
and ($C) = ($C->ws)) {
$C
} else { () }

});
}
;
## token nullterm {
sub nullterm__PEEK { $_[0]->_AUTOLEXpeek('nullterm', $retree) }
sub nullterm {
no warnings 'recursion';
my $self = shift;


local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;

my $C = $self->cursor_xact("RULE nullterm");
my $xact = $C->xact;
my $S = $C->{'_pos'};
$self->_MATCHIFYr($S, "nullterm", $C->before(sub {
my $C=shift;
$C
}));
}
;
## token nulltermish {
sub nulltermish__PEEK { $_[0]->_AUTOLEXpeek('nulltermish', $retree) }
sub nulltermish {
no warnings 'recursion';
my $self = shift;


local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;

my $C = $self->cursor_xact("RULE nulltermish");
my $xact = $C->xact;
my $S = $C->{'_pos'};
$self->_MATCHIFYr($S, "nulltermish", $C->_BRACKETr(sub {
my $C=shift;
do {
my ($tag, $try);
my @try;
my $relex;

my $fate;
my $x;
if ($fate = $C->{'_fate'} and $fate->[1] eq 'nulltermish_0') {
$C->deb("Fate passed to nulltermish_0: ", ::fatestr($fate)) if $::DEBUG & DEBUG::fates;
($C->{'_fate'}, $tag, $try) = @$fate;
@try = ($try);
$x = 'ALT nulltermish_0';    # some outer ltm is controlling us
}
else {
$x = 'ALTLTM nulltermish_0'; # we are top level ltm
}
my $C = $C->cursor_xact($x);
my $xact = $C->{_xact};

my @gather = ();
for (;;) {
unless (@try) {
$relex //= $C->cursor_fate('STD::P6', 'nulltermish_0', $retree);
@try = $relex->($C) or last;
}
$try = shift(@try) // next;

if (ref $try) {
($C->{'_fate'}, $tag, $try) = @$try;   # next candidate fate
}

$C->deb("nulltermish_0 trying $tag $try") if $::DEBUG & DEBUG::try_processing;
push @gather, ((
sub {
my $C=shift;
if (my ($C) = ($C->before(sub {
my $C=shift;
if (my ($C) = ($C->stdstopper)) { ($C) } else { () }
}))) { ($C) } else { () }
},
sub {
my $C=shift;
if (my ($C) = ($C->_SUBSUMEr(['term'], sub {
my $C = shift;
$C->termish
}))) {
scalar(do {
my $M = $C;
$C->{'PRE'}  = delete $M->{'term'}->{'PRE'};
$C->{'POST'} = delete $M->{'term'}->{'POST'};
$C->{'~CAPS'} = $M->{'term'}->{'~CAPS'};
}, $C)
} else { () }
},
sub {
my $C=shift;
if (my ($C) = ($C->before(sub {
my $C=shift;
$C
}))) { ($C) } else { () }
}
)[$try])->($C);
last if @gather;
last if $xact->[-2];  # committed?
}
@gather;
};
}));
}
;
## token termish {
sub termish__PEEK { $_[0]->_AUTOLEXpeek('termish', $retree) }
sub termish {
no warnings 'recursion';
my $self = shift;

local $::SCOPE = "";local $::MULTINESS = "";local $::OFTYPE;local $::VAR;
local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;

my $C = $self->cursor_xact("RULE termish");
my $xact = $C->xact;
my $S = $C->{'_pos'};
$C->{'POST'} = [];
$C->{'PRE'} = [];
$self->_MATCHIFYr($S, "termish", do {
my $C = $C;
if (($C) = ($C->_BRACKETr(sub {
my $C=shift;
do {
my ($tag, $try);
my @try;
my $relex;

my $fate;
my $x;
if ($fate = $C->{'_fate'} and $fate->[1] eq 'termish_0') {
$C->deb("Fate passed to termish_0: ", ::fatestr($fate)) if $::DEBUG & DEBUG::fates;
($C->{'_fate'}, $tag, $try) = @$fate;
@try = ($try);
$x = 'ALT termish_0';    # some outer ltm is controlling us
}
else {
$x = 'ALTLTM termish_0'; # we are top level ltm
}
my $C = $C->cursor_xact($x);
my $xact = $C->{_xact};

my @gather = ();
for (;;) {
unless (@try) {
$relex //= $C->cursor_fate('STD::P6', 'termish_0', $retree);
@try = $relex->($C) or last;
}
$try = shift(@try) // next;

if (ref $try) {
($C->{'_fate'}, $tag, $try) = @$try;   # next candidate fate
}

$C->deb("termish_0 trying $tag $try") if $::DEBUG & DEBUG::try_processing;
push @gather, ((
sub {
my $C=shift;
if (($C) = ($C->_SUBSUMEr(['PRE'], sub {
my $C = shift;
$C->PRE
}))
and ($C) = ($C->_STARr(sub {
my $C=shift;
if (my ($C) = ($C->_BRACKETr(sub {
my $C=shift;
if (my ($C) = ($C->_NOTBEFORE(sub {
my $C=shift;
(($C) x !!do {
my $M = $C;
my $p = $M->{'PRE'};
my @p = @$p;
$p[-1]->{'O'}->{'term'} and $M->{'term'} = pop @$p ;
})
}))) {
$C->_SUBSUMEr(['PRE'], sub {
my $C = shift;
$C->PRE
})
} else { () }
}))) { ($C) } else { () }
}))
and ($C) = ($C->_BRACKETr(sub {
my $C=shift;
do {    my $C = $C->cursor_xact('ALT ||');
my $xact = $C->xact;
my @gather;
do {
push @gather, do {
if (my ($C) = ($C->before(sub {
my $C=shift;
(($C) x !!do {
my $M = $C;
$M->{'term'} })
}))) { ($C) } else { () }

}
}
or $xact->[-2] or
do {
push @gather, $C->_SUBSUMEr(['term'], sub {
my $C = shift;
$C->term
})
}
or $xact->[-2] or
do {
push @gather, do {
if (my ($C) = ($C->panic("Prefix requires an argument"))) { ($C) } else { () }

}
};
@gather;
}
}))) {
$C
} else { () }
},
sub {
my $C=shift;
$C->_SUBSUMEr(['term'], sub {
my $C = shift;
$C->term
})
}
)[$try])->($C);
last if @gather;
last if $xact->[-2];  # committed?
}
@gather;
};
}))
and ($C) = ($C->_BRACKETr(sub {
my $C=shift;
do {    my $C = $C->cursor_xact('ALT ||');
my $xact = $C->xact;
my @gather;
do {
push @gather, do {
my $C = $C;
if (($C) = ($C->before(sub {
my $C=shift;
(($C) x !!do {
$::QSIGIL })
}))
and ($C) = ($C->_BRACKETr(sub {
my $C=shift;
do {    my $C = $C->cursor_xact('ALT ||');
my $xact = $C->xact;
my @gather;
do {
push @gather, do {
my $C = $C;
if (($C) = ($C->before(sub {
my $C=shift;
(($C) x !!do {
$::QSIGIL eq '$' })
}))
and ($C) = ($C->_BRACKETr(sub {
my $C=shift;
do {    my $C = $C->cursor_xact('ALT ||');
my $xact = $C->xact;
my @gather;
do {
push @gather, do {
if (my ($C) = (LazyMap::lazymap(sub {
my $C=shift;
if (my ($C) = ($C->before(sub {
my $C=shift;
if (my ($C) = ($C->after(sub {
my $C=shift;
$C->_PATTERN(qr/\G(?<=[\]}>)])/)
}))) { ($C) } else { () }
}))) { ($C) } else { () }
},
$C->_PLUSg(sub {
my $C=shift;
if (my ($C) = ($C->_BRACKETr(sub {
my $C=shift;
if (my ($C) = ($C->_NOTBEFORE(sub {
my $C=shift;
if (my ($C) = ($C->before(sub {
my $C=shift;
$C->_EXACT("\\")
}))) { ($C) } else { () }
}))) {
$C->_SUBSUMEr(['POST'], sub {
my $C = shift;
$C->POST
})
} else { () }
}))) { ($C) } else { () }
})))) { ($C) } else { () }

}
}
or $xact->[-2] or
do {
push @gather, scalar(do {
my $M = $C;
$M->{'POST'} = [] }, $C)
};
@gather;
}
}))) {
$C
} else { () }

}
}
or $xact->[-2] or
do {
push @gather, do {
if (my ($C) = (LazyMap::lazymap(sub {
my $C=shift;
if (my ($C) = ($C->before(sub {
my $C=shift;
if (my ($C) = ($C->after(sub {
my $C=shift;
$C->_PATTERN(qr/\G(?<=[\]}>)])/)
}))) { ($C) } else { () }
}))) { ($C) } else { () }
},
$C->_PLUSg(sub {
my $C=shift;
if (my ($C) = ($C->_BRACKETr(sub {
my $C=shift;
if (my ($C) = ($C->_NOTBEFORE(sub {
my $C=shift;
if (my ($C) = ($C->before(sub {
my $C=shift;
$C->_EXACT("\\")
}))) { ($C) } else { () }
}))) {
$C->_SUBSUMEr(['POST'], sub {
my $C = shift;
$C->POST
})
} else { () }
}))) { ($C) } else { () }
})))) { ($C) } else { () }

}
}
or $xact->[-2] or
do {
push @gather, scalar(do {
$::VAR = 0}, $C)
};
@gather;
}
}))) {
$C
} else { () }

}
}
or $xact->[-2] or
do {
push @gather, do {
if (my ($C) = ($C->_NOTBEFORE(sub {
my $C=shift;
(($C) x !!do {
$::QSIGIL })
}))) {
$C->_STARr(sub {
my $C=shift;
$C->_SUBSUMEr(['POST'], sub {
my $C = shift;
$C->POST
})
})
} else { () }

}
};
@gather;
}
}))) {
scalar(do {
my $M = $C;
$self->check_variable($::VAR) if $::VAR;
$C->{'~CAPS'} = $M->{'term'}->{'~CAPS'};
}, $C)
} else { () }

});
}
;
## token term:fatarrow           { <fatarrow> }
sub term__S_076fatarrow__PEEK { $_[0]->_AUTOLEXpeek('term__S_076fatarrow', $retree) }
sub term__S_076fatarrow {
no warnings 'recursion';
my $self = shift;


local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;

my $C = $self->cursor_xact("RULE term__S_076fatarrow");
my $xact = $C->xact;
my $S = $C->{'_pos'};
$C->{sym} = "fatarrow";
$self->_MATCHIFYr($S, "term__S_076fatarrow", $C->_SUBSUMEr(['fatarrow'], sub {
my $C = shift;
$C->fatarrow
}));
}
;
## token term:variable           { <variable> { $*VAR = $<variable> } }
sub term__S_077variable__PEEK { $_[0]->_AUTOLEXpeek('term__S_077variable', $retree) }
sub term__S_077variable {
no warnings 'recursion';
my $self = shift;


local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;

my $C = $self->cursor_xact("RULE term__S_077variable");
my $xact = $C->xact;
my $S = $C->{'_pos'};
$C->{sym} = "variable";
$self->_MATCHIFYr($S, "term__S_077variable", do {
if (my ($C) = ($C->_SUBSUMEr(['variable'], sub {
my $C = shift;
$C->variable
}))) {
scalar(do {
my $M = $C;
$::VAR = $M->{'variable'} }, $C)
} else { () }

});
}
;
## token term:package_declarator { <package_declarator> }
sub term__S_078package_declarator__PEEK { $_[0]->_AUTOLEXpeek('term__S_078package_declarator', $retree) }
sub term__S_078package_declarator {
no warnings 'recursion';
my $self = shift;


local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;

my $C = $self->cursor_xact("RULE term__S_078package_declarator");
my $xact = $C->xact;
my $S = $C->{'_pos'};
$C->{sym} = "package_declarator";
$self->_MATCHIFYr($S, "term__S_078package_declarator", $C->_SUBSUMEr(['package_declarator'], sub {
my $C = shift;
$C->package_declarator
}));
}
;
## token term:scope_declarator   { <scope_declarator> }
sub term__S_079scope_declarator__PEEK { $_[0]->_AUTOLEXpeek('term__S_079scope_declarator', $retree) }
sub term__S_079scope_declarator {
no warnings 'recursion';
my $self = shift;


local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;

my $C = $self->cursor_xact("RULE term__S_079scope_declarator");
my $xact = $C->xact;
my $S = $C->{'_pos'};
$C->{sym} = "scope_declarator";
$self->_MATCHIFYr($S, "term__S_079scope_declarator", $C->_SUBSUMEr(['scope_declarator'], sub {
my $C = shift;
$C->scope_declarator
}));
}
;
## token term:multi_declarator   { <?before 'multi'|'proto'|'only'> <multi_declarator> }
sub term__S_080multi_declarator__PEEK { $_[0]->_AUTOLEXpeek('term__S_080multi_declarator', $retree) }
sub term__S_080multi_declarator {
no warnings 'recursion';
my $self = shift;


local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;

my $C = $self->cursor_xact("RULE term__S_080multi_declarator");
my $xact = $C->xact;
my $S = $C->{'_pos'};
$C->{sym} = "multi_declarator";
$self->_MATCHIFYr($S, "term__S_080multi_declarator", do {
if (my ($C) = ($C->before(sub {
my $C=shift;
if (my ($C) = ($C->before(sub {
my $C=shift;
if (my ($C) = (do {
do {
my ($tag, $try);
my @try;
my $relex;

my $fate;
my $x;
if ($fate = $C->{'_fate'} and $fate->[1] eq 'term__S_080multi_declarator_0') {
$C->deb("Fate passed to term__S_080multi_declarator_0: ", ::fatestr($fate)) if $::DEBUG & DEBUG::fates;
($C->{'_fate'}, $tag, $try) = @$fate;
@try = ($try);
$x = 'ALT term__S_080multi_declarator_0';    # some outer ltm is controlling us
}
else {
$x = 'ALTLTM term__S_080multi_declarator_0'; # we are top level ltm
}
my $C = $C->cursor_xact($x);
my $xact = $C->{_xact};

my @gather = ();
for (;;) {
unless (@try) {
$relex //= $C->cursor_fate('STD::P6', 'term__S_080multi_declarator_0', $retree);
@try = $relex->($C) or last;
}
$try = shift(@try) // next;

if (ref $try) {
($C->{'_fate'}, $tag, $try) = @$try;   # next candidate fate
}

$C->deb("term__S_080multi_declarator_0 trying $tag $try") if $::DEBUG & DEBUG::try_processing;
push @gather, ((
sub {
my $C=shift;
$C->_EXACT("multi")
},
sub {
my $C=shift;
$C->_EXACT("proto")
},
sub {
my $C=shift;
$C->_EXACT("only")
}
)[$try])->($C);
last if @gather;
last if $xact->[-2];  # committed?
}
@gather;
};

})) { ($C) } else { () }
}))) { ($C) } else { () }
}))) {
$C->_SUBSUMEr(['multi_declarator'], sub {
my $C = shift;
$C->multi_declarator
})
} else { () }

});
}
;
## token term:routine_declarator { <routine_declarator> }
sub term__S_081routine_declarator__PEEK { $_[0]->_AUTOLEXpeek('term__S_081routine_declarator', $retree) }
sub term__S_081routine_declarator {
no warnings 'recursion';
my $self = shift;


local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;

my $C = $self->cursor_xact("RULE term__S_081routine_declarator");
my $xact = $C->xact;
my $S = $C->{'_pos'};
$C->{sym} = "routine_declarator";
$self->_MATCHIFYr($S, "term__S_081routine_declarator", $C->_SUBSUMEr(['routine_declarator'], sub {
my $C = shift;
$C->routine_declarator
}));
}
;
## token term:regex_declarator   { <regex_declarator> }
sub term__S_082regex_declarator__PEEK { $_[0]->_AUTOLEXpeek('term__S_082regex_declarator', $retree) }
sub term__S_082regex_declarator {
no warnings 'recursion';
my $self = shift;


local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;

my $C = $self->cursor_xact("RULE term__S_082regex_declarator");
my $xact = $C->xact;
my $S = $C->{'_pos'};
$C->{sym} = "regex_declarator";
$self->_MATCHIFYr($S, "term__S_082regex_declarator", $C->_SUBSUMEr(['regex_declarator'], sub {
my $C = shift;
$C->regex_declarator
}));
}
;
## token term:type_declarator    { <type_declarator> }
sub term__S_083type_declarator__PEEK { $_[0]->_AUTOLEXpeek('term__S_083type_declarator', $retree) }
sub term__S_083type_declarator {
no warnings 'recursion';
my $self = shift;


local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;

my $C = $self->cursor_xact("RULE term__S_083type_declarator");
my $xact = $C->xact;
my $S = $C->{'_pos'};
$C->{sym} = "type_declarator";
$self->_MATCHIFYr($S, "term__S_083type_declarator", $C->_SUBSUMEr(['type_declarator'], sub {
my $C = shift;
$C->type_declarator
}));
}
;
## token term:circumfix          { <circumfix> }
sub term__S_084circumfix__PEEK { $_[0]->_AUTOLEXpeek('term__S_084circumfix', $retree) }
sub term__S_084circumfix {
no warnings 'recursion';
my $self = shift;


local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;

my $C = $self->cursor_xact("RULE term__S_084circumfix");
my $xact = $C->xact;
my $S = $C->{'_pos'};
$C->{sym} = "circumfix";
$self->_MATCHIFYr($S, "term__S_084circumfix", $C->_SUBSUMEr(['circumfix'], sub {
my $C = shift;
$C->circumfix
}));
}
;
## token term:dotty              { <dotty> }
sub term__S_085dotty__PEEK { $_[0]->_AUTOLEXpeek('term__S_085dotty', $retree) }
sub term__S_085dotty {
no warnings 'recursion';
my $self = shift;


local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;

my $C = $self->cursor_xact("RULE term__S_085dotty");
my $xact = $C->xact;
my $S = $C->{'_pos'};
$C->{sym} = "dotty";
$self->_MATCHIFYr($S, "term__S_085dotty", $C->_SUBSUMEr(['dotty'], sub {
my $C = shift;
$C->dotty
}));
}
;
## token term:value              { <value> }
sub term__S_086value__PEEK { $_[0]->_AUTOLEXpeek('term__S_086value', $retree) }
sub term__S_086value {
no warnings 'recursion';
my $self = shift;


local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;

my $C = $self->cursor_xact("RULE term__S_086value");
my $xact = $C->xact;
my $S = $C->{'_pos'};
$C->{sym} = "value";
$self->_MATCHIFYr($S, "term__S_086value", $C->_SUBSUMEr(['value'], sub {
my $C = shift;
$C->value
}));
}
;
## token term:capterm            { <capterm> }
sub term__S_087capterm__PEEK { $_[0]->_AUTOLEXpeek('term__S_087capterm', $retree) }
sub term__S_087capterm {
no warnings 'recursion';
my $self = shift;


local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;

my $C = $self->cursor_xact("RULE term__S_087capterm");
my $xact = $C->xact;
my $S = $C->{'_pos'};
$C->{sym} = "capterm";
$self->_MATCHIFYr($S, "term__S_087capterm", $C->_SUBSUMEr(['capterm'], sub {
my $C = shift;
$C->capterm
}));
}
;
## token term:sigterm            { <sigterm> }
sub term__S_088sigterm__PEEK { $_[0]->_AUTOLEXpeek('term__S_088sigterm', $retree) }
sub term__S_088sigterm {
no warnings 'recursion';
my $self = shift;


local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;

my $C = $self->cursor_xact("RULE term__S_088sigterm");
my $xact = $C->xact;
my $S = $C->{'_pos'};
$C->{sym} = "sigterm";
$self->_MATCHIFYr($S, "term__S_088sigterm", $C->_SUBSUMEr(['sigterm'], sub {
my $C = shift;
$C->sigterm
}));
}
;
## token term:statement_prefix   { <statement_prefix> }
sub term__S_089statement_prefix__PEEK { $_[0]->_AUTOLEXpeek('term__S_089statement_prefix', $retree) }
sub term__S_089statement_prefix {
no warnings 'recursion';
my $self = shift;


local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;

my $C = $self->cursor_xact("RULE term__S_089statement_prefix");
my $xact = $C->xact;
my $S = $C->{'_pos'};
$C->{sym} = "statement_prefix";
$self->_MATCHIFYr($S, "term__S_089statement_prefix", $C->_SUBSUMEr(['statement_prefix'], sub {
my $C = shift;
$C->statement_prefix
}));
}
;
## token term:colonpair          { [ <colonpair> <.ws> ]+ }
sub term__S_090colonpair__PEEK { $_[0]->_AUTOLEXpeek('term__S_090colonpair', $retree) }
sub term__S_090colonpair {
no warnings 'recursion';
my $self = shift;


local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;

my $C = $self->cursor_xact("RULE term__S_090colonpair");
my $xact = $C->xact;
my $S = $C->{'_pos'};
$C->{'colonpair'} = [];
$C->{sym} = "colonpair";
$self->_MATCHIFYr($S, "term__S_090colonpair", $C->_PLUSr(sub {
my $C=shift;
if (my ($C) = ($C->_BRACKETr(sub {
my $C=shift;
if (($C) = ($C->_SUBSUMEr(['colonpair'], sub {
my $C = shift;
$C->colonpair
}))
and ($C) = ($C->ws)) {
$C
} else { () }
}))) { ($C) } else { () }
}));
}
;
## token fatarrow {
sub fatarrow__PEEK { $_[0]->_AUTOLEXpeek('fatarrow', $retree) }
sub fatarrow {
no warnings 'recursion';
my $self = shift;


local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;

my $C = $self->cursor_xact("RULE fatarrow");
my $xact = $C->xact;
my $S = $C->{'_pos'};
$self->_MATCHIFYr($S, "fatarrow", do {
my $C = $C;
if (($C) = ($C->_SUBSUMEr(['key'], sub {
my $C = shift;
$C->identifier
}))
and ($C) = ($C->_PATTERN(qr/\G[\x20\t\r]*+\=\>/))
and ($C) = ($C->ws)) {
$C->_SUBSUMEr(['val'], sub {
my $C = shift;
$C->EXPR(\%item_assignment)
})
} else { () }

});
}
;
## token coloncircumfix ($front) {
sub coloncircumfix__PEEK { $_[0]->_AUTOLEXpeek('coloncircumfix', $retree) }
sub coloncircumfix {
no warnings 'recursion';
my $self = shift;

die 'Required argument front omitted' unless @_;
my $front = @_ ? shift() : undef;

local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;

my $C = $self->cursor_xact("RULE coloncircumfix");
my $xact = $C->xact;
my $S = $C->{'_pos'};
$self->_MATCHIFYr($S, "coloncircumfix", $C->_BRACKETr(sub {
my $C=shift;
do {
my ($tag, $try);
my @try;
my $relex;

my $fate;
my $x;
if ($fate = $C->{'_fate'} and $fate->[1] eq 'coloncircumfix_0') {
$C->deb("Fate passed to coloncircumfix_0: ", ::fatestr($fate)) if $::DEBUG & DEBUG::fates;
($C->{'_fate'}, $tag, $try) = @$fate;
@try = ($try);
$x = 'ALT coloncircumfix_0';    # some outer ltm is controlling us
}
else {
$x = 'ALTLTM coloncircumfix_0'; # we are top level ltm
}
my $C = $C->cursor_xact($x);
my $xact = $C->{_xact};

my @gather = ();
for (;;) {
unless (@try) {
$relex //= $C->cursor_fate('STD::P6', 'coloncircumfix_0', $retree);
@try = $relex->($C) or last;
}
$try = shift(@try) // next;

if (ref $try) {
($C->{'_fate'}, $tag, $try) = @$try;   # next candidate fate
}

$C->deb("coloncircumfix_0 trying $tag $try") if $::DEBUG & DEBUG::try_processing;
push @gather, ((
sub {
my $C=shift;
if (($C) = ($C->_EXACT("\<\>"))
and ($C) = ($C->worry("Pair with <> really means a Nil value, not null string; use :$front" . "('') to represent the null string,\n  or :$front" . "() to represent Nil more accurately"))) {
$C
} else { () }
},
sub {
my $C=shift;
$C->_SUBSUMEr(['circumfix'], sub {
my $C = shift;
$C->circumfix
})
}
)[$try])->($C);
last if @gather;
last if $xact->[-2];  # committed?
}
@gather;
};
}));
}
;
## token colonpair {
sub colonpair__PEEK { $_[0]->_AUTOLEXpeek('colonpair', $retree) }
sub colonpair {
no warnings 'recursion';
my $self = shift;

my $key;my $value;
local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;

my $C = $self->cursor_xact("RULE colonpair");
my $xact = $C->xact;
my $S = $C->{'_pos'};
$self->_MATCHIFYr($S, "colonpair", do {
my $C = $C;
if (($C) = ($C->_EXACT("\:"))
and ($C) = ($C->_BRACKETr(sub {
my $C=shift;
do {
my ($tag, $try);
my @try;
my $relex;

my $fate;
my $x;
if ($fate = $C->{'_fate'} and $fate->[1] eq 'colonpair_0') {
$C->deb("Fate passed to colonpair_0: ", ::fatestr($fate)) if $::DEBUG & DEBUG::fates;
($C->{'_fate'}, $tag, $try) = @$fate;
@try = ($try);
$x = 'ALT colonpair_0';    # some outer ltm is controlling us
}
else {
$x = 'ALTLTM colonpair_0'; # we are top level ltm
}
my $C = $C->cursor_xact($x);
my $xact = $C->{_xact};

my @gather = ();
for (;;) {
unless (@try) {
$relex //= $C->cursor_fate('STD::P6', 'colonpair_0', $retree);
@try = $relex->($C) or last;
}
$try = shift(@try) // next;

if (ref $try) {
($C->{'_fate'}, $tag, $try) = @$try;   # next candidate fate
}

$C->deb("colonpair_0 trying $tag $try") if $::DEBUG & DEBUG::try_processing;
push @gather, ((
sub {
my $C=shift;
if (($C) = ($C->_EXACT("\!"))
and ($C) = ($C->_COMMITLTM())
and ($C) = ($C->_BRACKETr(sub {
my $C=shift;
do {    my $C = $C->cursor_xact('ALT ||');
my $xact = $C->xact;
my @gather;
do {
push @gather, $C->_SUBSUMEr(['identifier'], sub {
my $C = shift;
$C->identifier
})
}
or $xact->[-2] or
do {
push @gather, do {
if (my ($C) = ($C->panic("Malformed False pair; expected identifier"))) { ($C) } else { () }

}
};
@gather;
}
}))
and ($C) = ($C->_OPTr(sub {
my $C=shift;
if (my ($C) = ($C->_BRACKETr(sub {
my $C=shift;
if (($C) = ($C->before(sub {
my $C=shift;
if (my ($C) = ($C->before(sub {
my $C=shift;
$C->_PATTERN(qr/\G[\[\(\<\{]/)
}))) { ($C) } else { () }
}))
and ($C) = ($C->panic("Extra argument not allowed; pair already has False argument"))) {
$C
} else { () }
}))) { ($C) } else { () }
}))) {
scalar(do {
my $M = $C;
$key = $M->{'identifier'}->Str;
$value = 0;
}, $C)
} else { () }
},
sub {
my $C=shift;
if (($C) = ($C->_SUBSUMEr(['num'], sub {
my $C = shift;
$C->_BRACKETr(sub {
my $C=shift;
$C->_PATTERN(qr/\G\d++/)
})
}))
and ($C) = ($C->_SUBSUMEr(['identifier'], sub {
my $C = shift;
$C->identifier
}))) {
$C->_OPTr(sub {
my $C=shift;
if (my ($C) = ($C->_BRACKETr(sub {
my $C=shift;
if (($C) = ($C->before(sub {
my $C=shift;
if (my ($C) = ($C->before(sub {
my $C=shift;
$C->_PATTERN(qr/\G[\[\(\<\{]/)
}))) { ($C) } else { () }
}))
and ($C) = (do {
my $M = $C;
$C->sorry("Extra argument not allowed; pair already has argument of " . $M->{'num'}->Str)
})
and ($C) = ($C->circumfix)) {
$C
} else { () }
}))) { ($C) } else { () }
})
} else { () }
},
sub {
my $C=shift;
if (($C) = ($C->_SUBSUMEr(['identifier'], sub {
my $C = shift;
$C->identifier
}))
and ($C) = (scalar(do {
my $M = $C;
$key = $M->{'identifier'}->Str}, $C))
and ($C) = ($C->_BRACKETr(sub {
my $C=shift;
do {    my $C = $C->cursor_xact('ALT ||');
my $xact = $C->xact;
my @gather;
do {
push @gather, do {
my $C = $C;
if (($C) = ($C->_OPTr(sub {
my $C=shift;
if (my ($C) = ($C->unsp)) { ($C) } else { () }
}))
and ($C) = ($C->_SUBSUMEr(['coloncircumfix'], sub {
my $C = shift;
$C->coloncircumfix($key)
}))) {
scalar(do {
my $M = $C;
$value = $M->{'coloncircumfix'}}, $C)
} else { () }

}
}
or $xact->[-2] or
do {
push @gather, scalar(do {
$value = 1}, $C)
};
@gather;
}
}))) {
$C
} else { () }
},
sub {
my $C=shift;
if (my ($C) = ($C->_BRACKETr(sub {
my $C=shift;
local $::GOAL = "\)";
my $goalpos = $C;
if (($C) = ($C->_EXACT("\("))
and ($C) = (scalar(do {
}, $C))
and ($C) = ($C->_SUBSUMEr(['fakesignature'], sub {
my $C = shift;
$C->fakesignature
}))
and ($C) = ($C->_BRACKETr(sub {
my $C=shift;
do {    my $C = $C->cursor_xact('ALT ||');
my $xact = $C->xact;
my @gather;
do {
push @gather, $C->_EXACT("\)")
}
or $xact->[-2] or
do {
push @gather, do {
if (my ($C) = ($C->FAILGOAL($::GOAL, 'signature', $goalpos))) { ($C) } else { () }

}
};
@gather;
}
}))) {
$C
} else { () }
}))) { ($C) } else { () }
},
sub {
my $C=shift;
if (my ($C) = ($C->_SUBSUMEr(['coloncircumfix'], sub {
my $C = shift;
$C->coloncircumfix('')
}))) {
scalar(do {
my $M = $C;
$key = "";
$value = $M->{'coloncircumfix'};
}, $C)
} else { () }
},
sub {
my $C=shift;
if (my ($C) = ($C->_SUBSUMEr(['var'], sub {
my $C = shift;
$C->_PAREN( sub {
my $C=shift;
do {
my $C = $C;
if (($C) = ($C->_SUBSUMEr(['sigil'], sub {
my $C = shift;
$C->sigil
}))
and ($C) = (scalar(do {
}, $C))
and ($C) = ($C->_BRACKETr(sub {
my $C=shift;
do {
my ($tag, $try);
my @try;
my $relex;

my $fate;
my $x;
if ($fate = $C->{'_fate'} and $fate->[1] eq 'colonpair_1') {
$C->deb("Fate passed to colonpair_1: ", ::fatestr($fate)) if $::DEBUG & DEBUG::fates;
($C->{'_fate'}, $tag, $try) = @$fate;
@try = ($try);
$x = 'ALT colonpair_1';    # some outer ltm is controlling us
}
else {
$x = 'ALTLTM colonpair_1'; # we are top level ltm
}
my $C = $C->cursor_xact($x);
my $xact = $C->{_xact};

my @gather = ();
for (;;) {
unless (@try) {
$relex //= $C->cursor_fate('STD::P6', 'colonpair_1', $retree);
@try = $relex->($C) or last;
}
$try = shift(@try) // next;

if (ref $try) {
($C->{'_fate'}, $tag, $try) = @$try;   # next candidate fate
}

$C->deb("colonpair_1 trying $tag $try") if $::DEBUG & DEBUG::try_processing;
push @gather, ((
sub {
my $C=shift;
if (my ($C) = ($C->_OPTr(sub {
my $C=shift;
$C->_SUBSUMEr(['twigil'], sub {
my $C = shift;
$C->twigil
})
}))) {
$C->_SUBSUMEr(['desigilname'], sub {
my $C = shift;
$C->desigilname
})
} else { () }
},
sub {
my $C=shift;
if (($C) = ($C->_EXACT("\<"))
and ($C) = ($C->_SUBSUMEr(['desigilname'], sub {
my $C = shift;
$C->desigilname
}))) {
$C->_EXACT("\>")
} else { () }
}
)[$try])->($C);
last if @gather;
last if $xact->[-2];  # committed?
}
@gather;
};
}))) {
$C
} else { () }
};

})
}))) {
scalar(do {
my $M = $C;
$key = $M->{'var'}->{'desigilname'}->Str;
$value = $M->{'var'};
$C->check_variable($value);
}, $C)
} else { () }
}
)[$try])->($C);
last if @gather;
last if $xact->[-2];  # committed?
}
@gather;
};
}))) {
scalar(do {
my $M = $C;
$M->{'k'} = $key;
$M->{'v'} = $value;
}, $C)
} else { () }

});
}
;
## token special_variable:sym<$¢> { <sym> }
sub special_variable__S_091Dollar_a2___PEEK { $_[0]->_AUTOLEXpeek('special_variable__S_091Dollar_a2_', $retree) }
sub special_variable__S_091Dollar_a2_ {
no warnings 'recursion';
my $self = shift;


local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;

my $C = $self->cursor_xact("RULE special_variable__S_091Dollar_a2_");
my $xact = $C->xact;
my $S = $C->{'_pos'};
$C->{sym} = "\$¢";
$self->_MATCHIFYr($S, "special_variable__S_091Dollar_a2_", $C->_EXACT("\$¢"));
}
;
## token special_variable:sym<$!> { <sym> <!before \w> }
sub special_variable__S_092DollarBang__PEEK { $_[0]->_AUTOLEXpeek('special_variable__S_092DollarBang', $retree) }
sub special_variable__S_092DollarBang {
no warnings 'recursion';
my $self = shift;


local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;

my $C = $self->cursor_xact("RULE special_variable__S_092DollarBang");
my $xact = $C->xact;
my $S = $C->{'_pos'};
$C->{sym} = "\$\!";
$self->_MATCHIFYr($S, "special_variable__S_092DollarBang", do {
my $C = $C;
if (($C) = ($C->_EXACT("\$\!"))
and ($C) = ($C->_NOTBEFORE(sub {
my $C=shift;
if (my ($C) = ($C->before(sub {
my $C=shift;
$C->_PATTERN(qr/\G\w/)
}))) { ($C) } else { () }
}))) {
$C
} else { () }

});
}
;
## token special_variable:sym<$!{ }> {
sub special_variable__S_093DollarBangCur_Ly__PEEK { $_[0]->_AUTOLEXpeek('special_variable__S_093DollarBangCur_Ly', $retree) }
sub special_variable__S_093DollarBangCur_Ly {
no warnings 'recursion';
my $self = shift;


local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;

my $C = $self->cursor_xact("RULE special_variable__S_093DollarBangCur_Ly");
my $xact = $C->xact;
my $S = $C->{'_pos'};
$C->{sym} = "\$\!\{\ \}";
$self->_MATCHIFYr($S, "special_variable__S_093DollarBangCur_Ly", do {
my $C = $C;
if (($C) = ($C->_EXACT("\$\!"))
and ($C) = ($C->_BRACKETr(sub {
my $C=shift;
local $::GOAL = "\}";
my $goalpos = $C;
if (($C) = ($C->_EXACT("\{"))
and ($C) = (scalar(do {
}, $C))
and ($C) = ($C->_BRACKETr(sub {
my $C=shift;
do {
my ($tag, $try);
my @try;
my $relex;

my $fate;
my $x;
if ($fate = $C->{'_fate'} and $fate->[1] eq 'special_variable__S_093DollarBangCur_Ly_0') {
$C->deb("Fate passed to special_variable__S_093DollarBangCur_Ly_0: ", ::fatestr($fate)) if $::DEBUG & DEBUG::fates;
($C->{'_fate'}, $tag, $try) = @$fate;
@try = ($try);
$x = 'ALT special_variable__S_093DollarBangCur_Ly_0';    # some outer ltm is controlling us
}
else {
$x = 'ALTLTM special_variable__S_093DollarBangCur_Ly_0'; # we are top level ltm
}
my $C = $C->cursor_xact($x);
my $xact = $C->{_xact};

my @gather = ();
for (;;) {
unless (@try) {
$relex //= $C->cursor_fate('STD::P6', 'special_variable__S_093DollarBangCur_Ly_0', $retree);
@try = $relex->($C) or last;
}
$try = shift(@try) // next;

if (ref $try) {
($C->{'_fate'}, $tag, $try) = @$try;   # next candidate fate
}

$C->deb("special_variable__S_093DollarBangCur_Ly_0 trying $tag $try") if $::DEBUG & DEBUG::try_processing;
push @gather, ((
sub {
my $C=shift;
$C->_SUBSUMEr(['identifier'], sub {
my $C = shift;
$C->identifier
})
},
sub {
my $C=shift;
$C->_SUBSUMEr(['statementlist'], sub {
my $C = shift;
$C->statementlist
})
}
)[$try])->($C);
last if @gather;
last if $xact->[-2];  # committed?
}
@gather;
};
}))
and ($C) = ($C->_BRACKETr(sub {
my $C=shift;
do {    my $C = $C->cursor_xact('ALT ||');
my $xact = $C->xact;
my @gather;
do {
push @gather, $C->_EXACT("\}")
}
or $xact->[-2] or
do {
push @gather, do {
if (my ($C) = ($C->FAILGOAL($::GOAL, 'special_variable', $goalpos))) { ($C) } else { () }

}
};
@gather;
}
}))) {
$C
} else { () }
}))) {
scalar(do {
{
my $all = substr($::ORIG, $self->{'_pos'}, $C->{'_pos'} - $self->{'_pos'});
my ($inside) = $all =~ m!^...\s*(.*?)\s*.$!;
$C->obs("Perl 5's $all construct", "a smartmatch like \$! ~~ $inside" );
}}, $C)
} else { () }

});
}
;
## token special_variable:sym<$/> {
sub special_variable__S_094DollarSlash__PEEK { $_[0]->_AUTOLEXpeek('special_variable__S_094DollarSlash', $retree) }
sub special_variable__S_094DollarSlash {
no warnings 'recursion';
my $self = shift;


local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;

my $C = $self->cursor_xact("RULE special_variable__S_094DollarSlash");
my $xact = $C->xact;
my $S = $C->{'_pos'};
$C->{sym} = "\$\/";
$self->_MATCHIFYr($S, "special_variable__S_094DollarSlash", do {
if (my ($C) = ($C->_EXACT("\$\/"))) {
$C->_OPTr(sub {
my $C=shift;
if (my ($C) = ($C->_BRACKETr(sub {
my $C=shift;
if (($C) = ($C->before(sub {
my $C=shift;
if (my ($C) = ($C->before(sub {
my $C=shift;
do {
my $C = $C;
if (($C) = ($C->_PATTERN(qr/\G[\x20\t\r]*+\=/))
and ($C) = ($C->_NOTBEFORE(sub {
my $C=shift;
$C->_PATTERN(qr/\G[=]/)
}))) {
$C
} else { () }
};
}))) { ($C) } else { () }
}))
and ($C) = ($C->obs('$/ variable as input record separator',
"the filehandle's :irs attribute"))) {
$C
} else { () }
}))) { ($C) } else { () }
})
} else { () }

});
}
;
## token special_variable:sym<$~> {
sub special_variable__S_095DollarTilde__PEEK { $_[0]->_AUTOLEXpeek('special_variable__S_095DollarTilde', $retree) }
sub special_variable__S_095DollarTilde {
no warnings 'recursion';
my $self = shift;


local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;

my $C = $self->cursor_xact("RULE special_variable__S_095DollarTilde");
my $xact = $C->xact;
my $S = $C->{'_pos'};
$C->{sym} = "\$\~";
$self->_MATCHIFYr($S, "special_variable__S_095DollarTilde", do {
my $C = $C;
if (($C) = ($C->_EXACT("\$\~"))
and ($C) = ($C->_COMMITLTM())
and ($C) = ($C->before(sub {
my $C=shift;
if (my ($C) = ($C->before(sub {
my $C=shift;
if (my ($C) = (do {
do {
my ($tag, $try);
my @try;
my $relex;

my $fate;
my $x;
if ($fate = $C->{'_fate'} and $fate->[1] eq 'special_variable__S_095DollarTilde_0') {
$C->deb("Fate passed to special_variable__S_095DollarTilde_0: ", ::fatestr($fate)) if $::DEBUG & DEBUG::fates;
($C->{'_fate'}, $tag, $try) = @$fate;
@try = ($try);
$x = 'ALT special_variable__S_095DollarTilde_0';    # some outer ltm is controlling us
}
else {
$x = 'ALTLTM special_variable__S_095DollarTilde_0'; # we are top level ltm
}
my $C = $C->cursor_xact($x);
my $xact = $C->{_xact};

my @gather = ();
for (;;) {
unless (@try) {
$relex //= $C->cursor_fate('STD::P6', 'special_variable__S_095DollarTilde_0', $retree);
@try = $relex->($C) or last;
}
$try = shift(@try) // next;

if (ref $try) {
($C->{'_fate'}, $tag, $try) = @$try;   # next candidate fate
}

$C->deb("special_variable__S_095DollarTilde_0 trying $tag $try") if $::DEBUG & DEBUG::try_processing;
push @gather, ((
sub {
my $C=shift;
$C->_PATTERN(qr/\G\s/)
},
sub {
my $C=shift;
$C->_EXACT("\,")
},
sub {
my $C=shift;
$C->_EXACT("\=")
},
sub {
my $C=shift;
$C->_SUBSUMEr(['terminator'], sub {
my $C = shift;
$C->terminator
})
}
)[$try])->($C);
last if @gather;
last if $xact->[-2];  # committed?
}
@gather;
};

})) { ($C) } else { () }
}))) { ($C) } else { () }
}))
and ($C) = ($C->obs('$~ variable', 'Form module'))) {
$C
} else { () }

});
}
;
## token special_variable:sym<$`> {
sub special_variable__S_096DollarGrave__PEEK { $_[0]->_AUTOLEXpeek('special_variable__S_096DollarGrave', $retree) }
sub special_variable__S_096DollarGrave {
no warnings 'recursion';
my $self = shift;


local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;

my $C = $self->cursor_xact("RULE special_variable__S_096DollarGrave");
my $xact = $C->xact;
my $S = $C->{'_pos'};
$C->{sym} = "\$\`";
$self->_MATCHIFYr($S, "special_variable__S_096DollarGrave", do {
my $C = $C;
if (($C) = ($C->_EXACT("\$\`"))
and ($C) = ($C->_COMMITLTM())
and ($C) = ($C->before(sub {
my $C=shift;
if (my ($C) = ($C->before(sub {
my $C=shift;
if (my ($C) = (do {
do {
my ($tag, $try);
my @try;
my $relex;

my $fate;
my $x;
if ($fate = $C->{'_fate'} and $fate->[1] eq 'special_variable__S_096DollarGrave_0') {
$C->deb("Fate passed to special_variable__S_096DollarGrave_0: ", ::fatestr($fate)) if $::DEBUG & DEBUG::fates;
($C->{'_fate'}, $tag, $try) = @$fate;
@try = ($try);
$x = 'ALT special_variable__S_096DollarGrave_0';    # some outer ltm is controlling us
}
else {
$x = 'ALTLTM special_variable__S_096DollarGrave_0'; # we are top level ltm
}
my $C = $C->cursor_xact($x);
my $xact = $C->{_xact};

my @gather = ();
for (;;) {
unless (@try) {
$relex //= $C->cursor_fate('STD::P6', 'special_variable__S_096DollarGrave_0', $retree);
@try = $relex->($C) or last;
}
$try = shift(@try) // next;

if (ref $try) {
($C->{'_fate'}, $tag, $try) = @$try;   # next candidate fate
}

$C->deb("special_variable__S_096DollarGrave_0 trying $tag $try") if $::DEBUG & DEBUG::try_processing;
push @gather, ((
sub {
my $C=shift;
$C->_PATTERN(qr/\G\s/)
},
sub {
my $C=shift;
$C->_EXACT("\,")
},
sub {
my $C=shift;
$C->_SUBSUMEr(['terminator'], sub {
my $C = shift;
$C->terminator
})
}
)[$try])->($C);
last if @gather;
last if $xact->[-2];  # committed?
}
@gather;
};

})) { ($C) } else { () }
}))) { ($C) } else { () }
}))
and ($C) = ($C->obs('$` variable', 'explicit pattern before <('))) {
$C
} else { () }

});
}
;
## token special_variable:sym<$@> {
sub special_variable__S_097DollarAt__PEEK { $_[0]->_AUTOLEXpeek('special_variable__S_097DollarAt', $retree) }
sub special_variable__S_097DollarAt {
no warnings 'recursion';
my $self = shift;


local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;

my $C = $self->cursor_xact("RULE special_variable__S_097DollarAt");
my $xact = $C->xact;
my $S = $C->{'_pos'};
$C->{sym} = "\$\@";
$self->_MATCHIFYr($S, "special_variable__S_097DollarAt", do {
my $C = $C;
if (($C) = ($C->_EXACT("\$\@"))
and ($C) = ($C->before(sub {
my $C=shift;
if (my ($C) = ($C->before(sub {
my $C=shift;
$C->_PATTERN(qr/\G\W/)
}))) { ($C) } else { () }
}))
and ($C) = ($C->_COMMITLTM())
and ($C) = ($C->obs('$@ variable as eval error', '$!'))) {
$C
} else { () }

});
}
;
## token special_variable:sym<$#> {
sub special_variable__S_098DollarSharp__PEEK { $_[0]->_AUTOLEXpeek('special_variable__S_098DollarSharp', $retree) }
sub special_variable__S_098DollarSharp {
no warnings 'recursion';
my $self = shift;


local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;

my $C = $self->cursor_xact("RULE special_variable__S_098DollarSharp");
my $xact = $C->xact;
my $S = $C->{'_pos'};
$C->{sym} = "\$\#";
$self->_MATCHIFYr($S, "special_variable__S_098DollarSharp", do {
my $C = $C;
if (($C) = ($C->_EXACT("\$\#"))
and ($C) = ($C->_COMMITLTM())
and ($C) = ($C->_BRACKETr(sub {
my $C=shift;
do {    my $C = $C->cursor_xact('ALT ||');
my $xact = $C->xact;
my @gather;
do {
push @gather, do {
my $C = $C;
if (($C) = ($C->_SUBSUMEr(['0'], sub {
my $C = shift;
$C->_PAREN( sub {
my $C=shift;
$C->_PATTERN(qr/\G\w++/)

})
}))
and ($C) = (do {
my $M = $C;
$C->obs("\$#" . $M->{0}->Str . " variable", '@' . $M->{0}->Str . '.end')
})) {
$C
} else { () }

}
}
or $xact->[-2] or
do {
push @gather, do {
if (my ($C) = ($C->obs('$# variable', '.fmt'))) { ($C) } else { () }

}
};
@gather;
}
}))) {
$C
} else { () }

});
}
;
## token special_variable:sym<$$> {
sub special_variable__S_099DollarDollar__PEEK { $_[0]->_AUTOLEXpeek('special_variable__S_099DollarDollar', $retree) }
sub special_variable__S_099DollarDollar {
no warnings 'recursion';
my $self = shift;


local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;

my $C = $self->cursor_xact("RULE special_variable__S_099DollarDollar");
my $xact = $C->xact;
my $S = $C->{'_pos'};
$C->{sym} = "\$\$";
$self->_MATCHIFYr($S, "special_variable__S_099DollarDollar", do {
my $C = $C;
if (($C) = ($C->_EXACT("\$\$"))
and ($C) = ($C->_NOTBEFORE(sub {
my $C=shift;
$C->_PATTERN(qr/\G[_[:alpha:]]/)
}))
and ($C) = ($C->_COMMITLTM())
and ($C) = ($C->before(sub {
my $C=shift;
if (my ($C) = ($C->before(sub {
my $C=shift;
if (my ($C) = (do {
do {
my ($tag, $try);
my @try;
my $relex;

my $fate;
my $x;
if ($fate = $C->{'_fate'} and $fate->[1] eq 'special_variable__S_099DollarDollar_0') {
$C->deb("Fate passed to special_variable__S_099DollarDollar_0: ", ::fatestr($fate)) if $::DEBUG & DEBUG::fates;
($C->{'_fate'}, $tag, $try) = @$fate;
@try = ($try);
$x = 'ALT special_variable__S_099DollarDollar_0';    # some outer ltm is controlling us
}
else {
$x = 'ALTLTM special_variable__S_099DollarDollar_0'; # we are top level ltm
}
my $C = $C->cursor_xact($x);
my $xact = $C->{_xact};

my @gather = ();
for (;;) {
unless (@try) {
$relex //= $C->cursor_fate('STD::P6', 'special_variable__S_099DollarDollar_0', $retree);
@try = $relex->($C) or last;
}
$try = shift(@try) // next;

if (ref $try) {
($C->{'_fate'}, $tag, $try) = @$try;   # next candidate fate
}

$C->deb("special_variable__S_099DollarDollar_0 trying $tag $try") if $::DEBUG & DEBUG::try_processing;
push @gather, ((
sub {
my $C=shift;
$C->_PATTERN(qr/\G\s/)
},
sub {
my $C=shift;
$C->_EXACT("\,")
},
sub {
my $C=shift;
$C->_SUBSUMEr(['terminator'], sub {
my $C = shift;
$C->terminator
})
}
)[$try])->($C);
last if @gather;
last if $xact->[-2];  # committed?
}
@gather;
};

})) { ($C) } else { () }
}))) { ($C) } else { () }
}))
and ($C) = ($C->obs('$$ variable', '$*PID'))) {
$C
} else { () }

});
}
;
## token special_variable:sym<$%> {
sub special_variable__S_100DollarPercent__PEEK { $_[0]->_AUTOLEXpeek('special_variable__S_100DollarPercent', $retree) }
sub special_variable__S_100DollarPercent {
no warnings 'recursion';
my $self = shift;


local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;

my $C = $self->cursor_xact("RULE special_variable__S_100DollarPercent");
my $xact = $C->xact;
my $S = $C->{'_pos'};
$C->{sym} = "\$\%";
$self->_MATCHIFYr($S, "special_variable__S_100DollarPercent", do {
my $C = $C;
if (($C) = ($C->_EXACT("\$\%"))
and ($C) = ($C->_NOTBEFORE(sub {
my $C=shift;
if (my ($C) = ($C->before(sub {
my $C=shift;
$C->_PATTERN(qr/\G\w/)
}))) { ($C) } else { () }
}))
and ($C) = ($C->_NOTBEFORE(sub {
my $C=shift;
if (my ($C) = ($C->sigil)) { ($C) } else { () }
}))
and ($C) = ($C->_COMMITLTM())
and ($C) = ($C->obs('$% variable', 'Form module'))) {
$C
} else { () }

});
}
;
## token special_variable:sym<$^X> {
sub special_variable__S_101DollarCaretX__PEEK { $_[0]->_AUTOLEXpeek('special_variable__S_101DollarCaretX', $retree) }
sub special_variable__S_101DollarCaretX {
no warnings 'recursion';
my $self = shift;


local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;

my $C = $self->cursor_xact("RULE special_variable__S_101DollarCaretX");
my $xact = $C->xact;
my $S = $C->{'_pos'};
$C->{sym} = "\$\^X";
$self->_MATCHIFYr($S, "special_variable__S_101DollarCaretX", do {
my $C = $C;
if (($C) = ($C->_SUBSUMEr(['sigil'], sub {
my $C = shift;
$C->sigil
}))
and ($C) = ($C->_EXACT("\^"))
and ($C) = ($C->_SUBSUMEr(['letter'], sub {
my $C = shift;
$C->_BRACKETr(sub {
my $C=shift;
$C->_PATTERN(qr/\G[A-Z]/)
})
}))
and ($C) = ($C->_PATTERN(qr/\G\W/))
and ($C) = (do {
my $M = $C;
$C->obscaret($M->{'sigil'}->Str . '^' . $M->{'letter'}->Str, $M->{'sigil'}->Str, $M->{'letter'}->Str)
})) {
$C
} else { () }

});
}
;
## token special_variable:sym<$^> {
sub special_variable__S_102DollarCaret__PEEK { $_[0]->_AUTOLEXpeek('special_variable__S_102DollarCaret', $retree) }
sub special_variable__S_102DollarCaret {
no warnings 'recursion';
my $self = shift;


local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;

my $C = $self->cursor_xact("RULE special_variable__S_102DollarCaret");
my $xact = $C->xact;
my $S = $C->{'_pos'};
$C->{sym} = "\$\^";
$self->_MATCHIFYr($S, "special_variable__S_102DollarCaret", do {
my $C = $C;
if (($C) = ($C->_EXACT("\$\^"))
and ($C) = ($C->_COMMITLTM())
and ($C) = ($C->before(sub {
my $C=shift;
if (my ($C) = ($C->before(sub {
my $C=shift;
if (my ($C) = (do {
do {
my ($tag, $try);
my @try;
my $relex;

my $fate;
my $x;
if ($fate = $C->{'_fate'} and $fate->[1] eq 'special_variable__S_102DollarCaret_0') {
$C->deb("Fate passed to special_variable__S_102DollarCaret_0: ", ::fatestr($fate)) if $::DEBUG & DEBUG::fates;
($C->{'_fate'}, $tag, $try) = @$fate;
@try = ($try);
$x = 'ALT special_variable__S_102DollarCaret_0';    # some outer ltm is controlling us
}
else {
$x = 'ALTLTM special_variable__S_102DollarCaret_0'; # we are top level ltm
}
my $C = $C->cursor_xact($x);
my $xact = $C->{_xact};

my @gather = ();
for (;;) {
unless (@try) {
$relex //= $C->cursor_fate('STD::P6', 'special_variable__S_102DollarCaret_0', $retree);
@try = $relex->($C) or last;
}
$try = shift(@try) // next;

if (ref $try) {
($C->{'_fate'}, $tag, $try) = @$try;   # next candidate fate
}

$C->deb("special_variable__S_102DollarCaret_0 trying $tag $try") if $::DEBUG & DEBUG::try_processing;
push @gather, ((
sub {
my $C=shift;
$C->_PATTERN(qr/\G\s/)
},
sub {
my $C=shift;
$C->_EXACT("\,")
},
sub {
my $C=shift;
$C->_EXACT("\=")
},
sub {
my $C=shift;
$C->_SUBSUMEr(['terminator'], sub {
my $C = shift;
$C->terminator
})
}
)[$try])->($C);
last if @gather;
last if $xact->[-2];  # committed?
}
@gather;
};

})) { ($C) } else { () }
}))) { ($C) } else { () }
}))
and ($C) = ($C->obs('$^ variable', 'Form module'))) {
$C
} else { () }

});
}
;
## token special_variable:sym<$&> {
sub special_variable__S_103DollarAmp__PEEK { $_[0]->_AUTOLEXpeek('special_variable__S_103DollarAmp', $retree) }
sub special_variable__S_103DollarAmp {
no warnings 'recursion';
my $self = shift;


local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;

my $C = $self->cursor_xact("RULE special_variable__S_103DollarAmp");
my $xact = $C->xact;
my $S = $C->{'_pos'};
$C->{sym} = "\$\&";
$self->_MATCHIFYr($S, "special_variable__S_103DollarAmp", do {
my $C = $C;
if (($C) = ($C->_EXACT("\$\&"))
and ($C) = ($C->_COMMITLTM())
and ($C) = ($C->before(sub {
my $C=shift;
if (my ($C) = ($C->before(sub {
my $C=shift;
if (my ($C) = (do {
do {
my ($tag, $try);
my @try;
my $relex;

my $fate;
my $x;
if ($fate = $C->{'_fate'} and $fate->[1] eq 'special_variable__S_103DollarAmp_0') {
$C->deb("Fate passed to special_variable__S_103DollarAmp_0: ", ::fatestr($fate)) if $::DEBUG & DEBUG::fates;
($C->{'_fate'}, $tag, $try) = @$fate;
@try = ($try);
$x = 'ALT special_variable__S_103DollarAmp_0';    # some outer ltm is controlling us
}
else {
$x = 'ALTLTM special_variable__S_103DollarAmp_0'; # we are top level ltm
}
my $C = $C->cursor_xact($x);
my $xact = $C->{_xact};

my @gather = ();
for (;;) {
unless (@try) {
$relex //= $C->cursor_fate('STD::P6', 'special_variable__S_103DollarAmp_0', $retree);
@try = $relex->($C) or last;
}
$try = shift(@try) // next;

if (ref $try) {
($C->{'_fate'}, $tag, $try) = @$try;   # next candidate fate
}

$C->deb("special_variable__S_103DollarAmp_0 trying $tag $try") if $::DEBUG & DEBUG::try_processing;
push @gather, ((
sub {
my $C=shift;
$C->_PATTERN(qr/\G\s/)
},
sub {
my $C=shift;
$C->_EXACT("\,")
},
sub {
my $C=shift;
$C->_SUBSUMEr(['terminator'], sub {
my $C = shift;
$C->terminator
})
}
)[$try])->($C);
last if @gather;
last if $xact->[-2];  # committed?
}
@gather;
};

})) { ($C) } else { () }
}))) { ($C) } else { () }
}))
and ($C) = ($C->obs('$& variable', '$/ or $()'))) {
$C
} else { () }

});
}
;
## token special_variable:sym<$*> {
sub special_variable__S_104DollarStar__PEEK { $_[0]->_AUTOLEXpeek('special_variable__S_104DollarStar', $retree) }
sub special_variable__S_104DollarStar {
no warnings 'recursion';
my $self = shift;


local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;

my $C = $self->cursor_xact("RULE special_variable__S_104DollarStar");
my $xact = $C->xact;
my $S = $C->{'_pos'};
$C->{sym} = "\$\*";
$self->_MATCHIFYr($S, "special_variable__S_104DollarStar", do {
my $C = $C;
if (($C) = ($C->_EXACT("\$\*"))
and ($C) = ($C->_COMMITLTM())
and ($C) = ($C->before(sub {
my $C=shift;
if (my ($C) = ($C->before(sub {
my $C=shift;
if (my ($C) = (do {
do {
my ($tag, $try);
my @try;
my $relex;

my $fate;
my $x;
if ($fate = $C->{'_fate'} and $fate->[1] eq 'special_variable__S_104DollarStar_0') {
$C->deb("Fate passed to special_variable__S_104DollarStar_0: ", ::fatestr($fate)) if $::DEBUG & DEBUG::fates;
($C->{'_fate'}, $tag, $try) = @$fate;
@try = ($try);
$x = 'ALT special_variable__S_104DollarStar_0';    # some outer ltm is controlling us
}
else {
$x = 'ALTLTM special_variable__S_104DollarStar_0'; # we are top level ltm
}
my $C = $C->cursor_xact($x);
my $xact = $C->{_xact};

my @gather = ();
for (;;) {
unless (@try) {
$relex //= $C->cursor_fate('STD::P6', 'special_variable__S_104DollarStar_0', $retree);
@try = $relex->($C) or last;
}
$try = shift(@try) // next;

if (ref $try) {
($C->{'_fate'}, $tag, $try) = @$try;   # next candidate fate
}

$C->deb("special_variable__S_104DollarStar_0 trying $tag $try") if $::DEBUG & DEBUG::try_processing;
push @gather, ((
sub {
my $C=shift;
$C->_PATTERN(qr/\G\s/)
},
sub {
my $C=shift;
$C->_EXACT("\,")
},
sub {
my $C=shift;
$C->_EXACT("\=")
},
sub {
my $C=shift;
$C->_SUBSUMEr(['terminator'], sub {
my $C = shift;
$C->terminator
})
}
)[$try])->($C);
last if @gather;
last if $xact->[-2];  # committed?
}
@gather;
};

})) { ($C) } else { () }
}))) { ($C) } else { () }
}))
and ($C) = ($C->obs('$* variable', '^^ and $$'))) {
$C
} else { () }

});
}
;
## token special_variable:sym<$)> {
sub special_variable__S_105DollarThesis__PEEK { $_[0]->_AUTOLEXpeek('special_variable__S_105DollarThesis', $retree) }
sub special_variable__S_105DollarThesis {
no warnings 'recursion';
my $self = shift;


local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;

my $C = $self->cursor_xact("RULE special_variable__S_105DollarThesis");
my $xact = $C->xact;
my $S = $C->{'_pos'};
$C->{sym} = "\$\)";
$self->_MATCHIFYr($S, "special_variable__S_105DollarThesis", do {
my $C = $C;
if (($C) = ($C->_EXACT("\$\)"))
and ($C) = ($C->before(sub {
my $C=shift;
(($C) x !!do {
$::GOAL ne ')' })
}))
and ($C) = ($C->before(sub {
my $C=shift;
if (my ($C) = ($C->before(sub {
my $C=shift;
if (my ($C) = (do {
do {
my ($tag, $try);
my @try;
my $relex;

my $fate;
my $x;
if ($fate = $C->{'_fate'} and $fate->[1] eq 'special_variable__S_105DollarThesis_0') {
$C->deb("Fate passed to special_variable__S_105DollarThesis_0: ", ::fatestr($fate)) if $::DEBUG & DEBUG::fates;
($C->{'_fate'}, $tag, $try) = @$fate;
@try = ($try);
$x = 'ALT special_variable__S_105DollarThesis_0';    # some outer ltm is controlling us
}
else {
$x = 'ALTLTM special_variable__S_105DollarThesis_0'; # we are top level ltm
}
my $C = $C->cursor_xact($x);
my $xact = $C->{_xact};

my @gather = ();
for (;;) {
unless (@try) {
$relex //= $C->cursor_fate('STD::P6', 'special_variable__S_105DollarThesis_0', $retree);
@try = $relex->($C) or last;
}
$try = shift(@try) // next;

if (ref $try) {
($C->{'_fate'}, $tag, $try) = @$try;   # next candidate fate
}

$C->deb("special_variable__S_105DollarThesis_0 trying $tag $try") if $::DEBUG & DEBUG::try_processing;
push @gather, ((
sub {
my $C=shift;
$C->_PATTERN(qr/\G\s/)
},
sub {
my $C=shift;
$C->_EXACT("\,")
},
sub {
my $C=shift;
$C->_SUBSUMEr(['terminator'], sub {
my $C = shift;
$C->terminator
})
}
)[$try])->($C);
last if @gather;
last if $xact->[-2];  # committed?
}
@gather;
};

})) { ($C) } else { () }
}))) { ($C) } else { () }
}))
and ($C) = ($C->obs('$) variable', '$*EGID'))) {
$C
} else { () }

});
}
;
## token special_variable:sym<$-> {
sub special_variable__S_106DollarMinus__PEEK { $_[0]->_AUTOLEXpeek('special_variable__S_106DollarMinus', $retree) }
sub special_variable__S_106DollarMinus {
no warnings 'recursion';
my $self = shift;


local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;

my $C = $self->cursor_xact("RULE special_variable__S_106DollarMinus");
my $xact = $C->xact;
my $S = $C->{'_pos'};
$C->{sym} = "\$\-";
$self->_MATCHIFYr($S, "special_variable__S_106DollarMinus", do {
my $C = $C;
if (($C) = ($C->_EXACT("\$\-"))
and ($C) = ($C->_COMMITLTM())
and ($C) = ($C->before(sub {
my $C=shift;
if (my ($C) = ($C->before(sub {
my $C=shift;
if (my ($C) = (do {
do {
my ($tag, $try);
my @try;
my $relex;

my $fate;
my $x;
if ($fate = $C->{'_fate'} and $fate->[1] eq 'special_variable__S_106DollarMinus_0') {
$C->deb("Fate passed to special_variable__S_106DollarMinus_0: ", ::fatestr($fate)) if $::DEBUG & DEBUG::fates;
($C->{'_fate'}, $tag, $try) = @$fate;
@try = ($try);
$x = 'ALT special_variable__S_106DollarMinus_0';    # some outer ltm is controlling us
}
else {
$x = 'ALTLTM special_variable__S_106DollarMinus_0'; # we are top level ltm
}
my $C = $C->cursor_xact($x);
my $xact = $C->{_xact};

my @gather = ();
for (;;) {
unless (@try) {
$relex //= $C->cursor_fate('STD::P6', 'special_variable__S_106DollarMinus_0', $retree);
@try = $relex->($C) or last;
}
$try = shift(@try) // next;

if (ref $try) {
($C->{'_fate'}, $tag, $try) = @$try;   # next candidate fate
}

$C->deb("special_variable__S_106DollarMinus_0 trying $tag $try") if $::DEBUG & DEBUG::try_processing;
push @gather, ((
sub {
my $C=shift;
$C->_PATTERN(qr/\G\s/)
},
sub {
my $C=shift;
$C->_EXACT("\,")
},
sub {
my $C=shift;
$C->_EXACT("\=")
},
sub {
my $C=shift;
$C->_SUBSUMEr(['terminator'], sub {
my $C = shift;
$C->terminator
})
}
)[$try])->($C);
last if @gather;
last if $xact->[-2];  # committed?
}
@gather;
};

})) { ($C) } else { () }
}))) { ($C) } else { () }
}))
and ($C) = ($C->obs('$- variable', 'Form module'))) {
$C
} else { () }

});
}
;
## token special_variable:sym<$=> {
sub special_variable__S_107DollarEqual__PEEK { $_[0]->_AUTOLEXpeek('special_variable__S_107DollarEqual', $retree) }
sub special_variable__S_107DollarEqual {
no warnings 'recursion';
my $self = shift;


local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;

my $C = $self->cursor_xact("RULE special_variable__S_107DollarEqual");
my $xact = $C->xact;
my $S = $C->{'_pos'};
$C->{sym} = "\$\=";
$self->_MATCHIFYr($S, "special_variable__S_107DollarEqual", do {
my $C = $C;
if (($C) = ($C->_EXACT("\$\="))
and ($C) = ($C->_COMMITLTM())
and ($C) = ($C->before(sub {
my $C=shift;
if (my ($C) = ($C->before(sub {
my $C=shift;
if (my ($C) = (do {
do {
my ($tag, $try);
my @try;
my $relex;

my $fate;
my $x;
if ($fate = $C->{'_fate'} and $fate->[1] eq 'special_variable__S_107DollarEqual_0') {
$C->deb("Fate passed to special_variable__S_107DollarEqual_0: ", ::fatestr($fate)) if $::DEBUG & DEBUG::fates;
($C->{'_fate'}, $tag, $try) = @$fate;
@try = ($try);
$x = 'ALT special_variable__S_107DollarEqual_0';    # some outer ltm is controlling us
}
else {
$x = 'ALTLTM special_variable__S_107DollarEqual_0'; # we are top level ltm
}
my $C = $C->cursor_xact($x);
my $xact = $C->{_xact};

my @gather = ();
for (;;) {
unless (@try) {
$relex //= $C->cursor_fate('STD::P6', 'special_variable__S_107DollarEqual_0', $retree);
@try = $relex->($C) or last;
}
$try = shift(@try) // next;

if (ref $try) {
($C->{'_fate'}, $tag, $try) = @$try;   # next candidate fate
}

$C->deb("special_variable__S_107DollarEqual_0 trying $tag $try") if $::DEBUG & DEBUG::try_processing;
push @gather, ((
sub {
my $C=shift;
$C->_PATTERN(qr/\G\s/)
},
sub {
my $C=shift;
$C->_EXACT("\,")
},
sub {
my $C=shift;
$C->_EXACT("\=")
},
sub {
my $C=shift;
$C->_SUBSUMEr(['terminator'], sub {
my $C = shift;
$C->terminator
})
}
)[$try])->($C);
last if @gather;
last if $xact->[-2];  # committed?
}
@gather;
};

})) { ($C) } else { () }
}))) { ($C) } else { () }
}))
and ($C) = ($C->obs('$= variable', 'Form module'))) {
$C
} else { () }

});
}
;
## token special_variable:sym<@+> {
sub special_variable__S_108AtPlus__PEEK { $_[0]->_AUTOLEXpeek('special_variable__S_108AtPlus', $retree) }
sub special_variable__S_108AtPlus {
no warnings 'recursion';
my $self = shift;


local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;

my $C = $self->cursor_xact("RULE special_variable__S_108AtPlus");
my $xact = $C->xact;
my $S = $C->{'_pos'};
$C->{sym} = "\@\+";
$self->_MATCHIFYr($S, "special_variable__S_108AtPlus", do {
my $C = $C;
if (($C) = ($C->_EXACT("\@\+"))
and ($C) = ($C->_COMMITLTM())
and ($C) = ($C->before(sub {
my $C=shift;
if (my ($C) = ($C->before(sub {
my $C=shift;
if (my ($C) = (do {
do {
my ($tag, $try);
my @try;
my $relex;

my $fate;
my $x;
if ($fate = $C->{'_fate'} and $fate->[1] eq 'special_variable__S_108AtPlus_0') {
$C->deb("Fate passed to special_variable__S_108AtPlus_0: ", ::fatestr($fate)) if $::DEBUG & DEBUG::fates;
($C->{'_fate'}, $tag, $try) = @$fate;
@try = ($try);
$x = 'ALT special_variable__S_108AtPlus_0';    # some outer ltm is controlling us
}
else {
$x = 'ALTLTM special_variable__S_108AtPlus_0'; # we are top level ltm
}
my $C = $C->cursor_xact($x);
my $xact = $C->{_xact};

my @gather = ();
for (;;) {
unless (@try) {
$relex //= $C->cursor_fate('STD::P6', 'special_variable__S_108AtPlus_0', $retree);
@try = $relex->($C) or last;
}
$try = shift(@try) // next;

if (ref $try) {
($C->{'_fate'}, $tag, $try) = @$try;   # next candidate fate
}

$C->deb("special_variable__S_108AtPlus_0 trying $tag $try") if $::DEBUG & DEBUG::try_processing;
push @gather, ((
sub {
my $C=shift;
$C->_PATTERN(qr/\G\s/)
},
sub {
my $C=shift;
$C->_EXACT("\,")
},
sub {
my $C=shift;
$C->_SUBSUMEr(['terminator'], sub {
my $C = shift;
$C->terminator
})
}
)[$try])->($C);
last if @gather;
last if $xact->[-2];  # committed?
}
@gather;
};

})) { ($C) } else { () }
}))) { ($C) } else { () }
}))
and ($C) = ($C->obs('@+ variable', '.to method'))) {
$C
} else { () }

});
}
;
## token special_variable:sym<%+> {
sub special_variable__S_109PercentPlus__PEEK { $_[0]->_AUTOLEXpeek('special_variable__S_109PercentPlus', $retree) }
sub special_variable__S_109PercentPlus {
no warnings 'recursion';
my $self = shift;


local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;

my $C = $self->cursor_xact("RULE special_variable__S_109PercentPlus");
my $xact = $C->xact;
my $S = $C->{'_pos'};
$C->{sym} = "\%\+";
$self->_MATCHIFYr($S, "special_variable__S_109PercentPlus", do {
my $C = $C;
if (($C) = ($C->_EXACT("\%\+"))
and ($C) = ($C->_COMMITLTM())
and ($C) = ($C->before(sub {
my $C=shift;
if (my ($C) = ($C->before(sub {
my $C=shift;
if (my ($C) = (do {
do {
my ($tag, $try);
my @try;
my $relex;

my $fate;
my $x;
if ($fate = $C->{'_fate'} and $fate->[1] eq 'special_variable__S_109PercentPlus_0') {
$C->deb("Fate passed to special_variable__S_109PercentPlus_0: ", ::fatestr($fate)) if $::DEBUG & DEBUG::fates;
($C->{'_fate'}, $tag, $try) = @$fate;
@try = ($try);
$x = 'ALT special_variable__S_109PercentPlus_0';    # some outer ltm is controlling us
}
else {
$x = 'ALTLTM special_variable__S_109PercentPlus_0'; # we are top level ltm
}
my $C = $C->cursor_xact($x);
my $xact = $C->{_xact};

my @gather = ();
for (;;) {
unless (@try) {
$relex //= $C->cursor_fate('STD::P6', 'special_variable__S_109PercentPlus_0', $retree);
@try = $relex->($C) or last;
}
$try = shift(@try) // next;

if (ref $try) {
($C->{'_fate'}, $tag, $try) = @$try;   # next candidate fate
}

$C->deb("special_variable__S_109PercentPlus_0 trying $tag $try") if $::DEBUG & DEBUG::try_processing;
push @gather, ((
sub {
my $C=shift;
$C->_PATTERN(qr/\G\s/)
},
sub {
my $C=shift;
$C->_EXACT("\,")
},
sub {
my $C=shift;
$C->_SUBSUMEr(['terminator'], sub {
my $C = shift;
$C->terminator
})
}
)[$try])->($C);
last if @gather;
last if $xact->[-2];  # committed?
}
@gather;
};

})) { ($C) } else { () }
}))) { ($C) } else { () }
}))
and ($C) = ($C->obs('%+ variable', '.to method'))) {
$C
} else { () }

});
}
;
## token special_variable:sym<$+[ ]> {
sub special_variable__S_110DollarPlusBra_Ket__PEEK { $_[0]->_AUTOLEXpeek('special_variable__S_110DollarPlusBra_Ket', $retree) }
sub special_variable__S_110DollarPlusBra_Ket {
no warnings 'recursion';
my $self = shift;


local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;

my $C = $self->cursor_xact("RULE special_variable__S_110DollarPlusBra_Ket");
my $xact = $C->xact;
my $S = $C->{'_pos'};
$C->{sym} = "\$\+\[\ \]";
$self->_MATCHIFYr($S, "special_variable__S_110DollarPlusBra_Ket", do {
my $C = $C;
if (($C) = ($C->_EXACT("\$\+\["))
and ($C) = ($C->obs('@+ variable', '.to method'))) {
$C
} else { () }

});
}
;
## token special_variable:sym<@+[ ]> {
sub special_variable__S_111AtPlusBra_Ket__PEEK { $_[0]->_AUTOLEXpeek('special_variable__S_111AtPlusBra_Ket', $retree) }
sub special_variable__S_111AtPlusBra_Ket {
no warnings 'recursion';
my $self = shift;


local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;

my $C = $self->cursor_xact("RULE special_variable__S_111AtPlusBra_Ket");
my $xact = $C->xact;
my $S = $C->{'_pos'};
$C->{sym} = "\@\+\[\ \]";
$self->_MATCHIFYr($S, "special_variable__S_111AtPlusBra_Ket", do {
my $C = $C;
if (($C) = ($C->_EXACT("\@\+\["))
and ($C) = ($C->obs('@+ variable', '.to method'))) {
$C
} else { () }

});
}
;
## token special_variable:sym<@+{ }> {
sub special_variable__S_112AtPlusCur_Ly__PEEK { $_[0]->_AUTOLEXpeek('special_variable__S_112AtPlusCur_Ly', $retree) }
sub special_variable__S_112AtPlusCur_Ly {
no warnings 'recursion';
my $self = shift;


local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;

my $C = $self->cursor_xact("RULE special_variable__S_112AtPlusCur_Ly");
my $xact = $C->xact;
my $S = $C->{'_pos'};
$C->{sym} = "\@\+\{\ \}";
$self->_MATCHIFYr($S, "special_variable__S_112AtPlusCur_Ly", do {
my $C = $C;
if (($C) = ($C->_EXACT("\@\+\{"))
and ($C) = ($C->obs('%+ variable', '.to method'))) {
$C
} else { () }

});
}
;
## token special_variable:sym<@-> {
sub special_variable__S_113AtMinus__PEEK { $_[0]->_AUTOLEXpeek('special_variable__S_113AtMinus', $retree) }
sub special_variable__S_113AtMinus {
no warnings 'recursion';
my $self = shift;


local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;

my $C = $self->cursor_xact("RULE special_variable__S_113AtMinus");
my $xact = $C->xact;
my $S = $C->{'_pos'};
$C->{sym} = "\@\-";
$self->_MATCHIFYr($S, "special_variable__S_113AtMinus", do {
my $C = $C;
if (($C) = ($C->_EXACT("\@\-"))
and ($C) = ($C->_COMMITLTM())
and ($C) = ($C->before(sub {
my $C=shift;
if (my ($C) = ($C->before(sub {
my $C=shift;
if (my ($C) = (do {
do {
my ($tag, $try);
my @try;
my $relex;

my $fate;
my $x;
if ($fate = $C->{'_fate'} and $fate->[1] eq 'special_variable__S_113AtMinus_0') {
$C->deb("Fate passed to special_variable__S_113AtMinus_0: ", ::fatestr($fate)) if $::DEBUG & DEBUG::fates;
($C->{'_fate'}, $tag, $try) = @$fate;
@try = ($try);
$x = 'ALT special_variable__S_113AtMinus_0';    # some outer ltm is controlling us
}
else {
$x = 'ALTLTM special_variable__S_113AtMinus_0'; # we are top level ltm
}
my $C = $C->cursor_xact($x);
my $xact = $C->{_xact};

my @gather = ();
for (;;) {
unless (@try) {
$relex //= $C->cursor_fate('STD::P6', 'special_variable__S_113AtMinus_0', $retree);
@try = $relex->($C) or last;
}
$try = shift(@try) // next;

if (ref $try) {
($C->{'_fate'}, $tag, $try) = @$try;   # next candidate fate
}

$C->deb("special_variable__S_113AtMinus_0 trying $tag $try") if $::DEBUG & DEBUG::try_processing;
push @gather, ((
sub {
my $C=shift;
$C->_PATTERN(qr/\G\s/)
},
sub {
my $C=shift;
$C->_EXACT("\,")
},
sub {
my $C=shift;
$C->_SUBSUMEr(['terminator'], sub {
my $C = shift;
$C->terminator
})
}
)[$try])->($C);
last if @gather;
last if $xact->[-2];  # committed?
}
@gather;
};

})) { ($C) } else { () }
}))) { ($C) } else { () }
}))
and ($C) = ($C->obs('@- variable', '.from method'))) {
$C
} else { () }

});
}
;
## token special_variable:sym<%-> {
sub special_variable__S_114PercentMinus__PEEK { $_[0]->_AUTOLEXpeek('special_variable__S_114PercentMinus', $retree) }
sub special_variable__S_114PercentMinus {
no warnings 'recursion';
my $self = shift;


local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;

my $C = $self->cursor_xact("RULE special_variable__S_114PercentMinus");
my $xact = $C->xact;
my $S = $C->{'_pos'};
$C->{sym} = "\%\-";
$self->_MATCHIFYr($S, "special_variable__S_114PercentMinus", do {
my $C = $C;
if (($C) = ($C->_EXACT("\%\-"))
and ($C) = ($C->_COMMITLTM())
and ($C) = ($C->before(sub {
my $C=shift;
if (my ($C) = ($C->before(sub {
my $C=shift;
if (my ($C) = (do {
do {
my ($tag, $try);
my @try;
my $relex;

my $fate;
my $x;
if ($fate = $C->{'_fate'} and $fate->[1] eq 'special_variable__S_114PercentMinus_0') {
$C->deb("Fate passed to special_variable__S_114PercentMinus_0: ", ::fatestr($fate)) if $::DEBUG & DEBUG::fates;
($C->{'_fate'}, $tag, $try) = @$fate;
@try = ($try);
$x = 'ALT special_variable__S_114PercentMinus_0';    # some outer ltm is controlling us
}
else {
$x = 'ALTLTM special_variable__S_114PercentMinus_0'; # we are top level ltm
}
my $C = $C->cursor_xact($x);
my $xact = $C->{_xact};

my @gather = ();
for (;;) {
unless (@try) {
$relex //= $C->cursor_fate('STD::P6', 'special_variable__S_114PercentMinus_0', $retree);
@try = $relex->($C) or last;
}
$try = shift(@try) // next;

if (ref $try) {
($C->{'_fate'}, $tag, $try) = @$try;   # next candidate fate
}

$C->deb("special_variable__S_114PercentMinus_0 trying $tag $try") if $::DEBUG & DEBUG::try_processing;
push @gather, ((
sub {
my $C=shift;
$C->_PATTERN(qr/\G\s/)
},
sub {
my $C=shift;
$C->_EXACT("\,")
},
sub {
my $C=shift;
$C->_SUBSUMEr(['terminator'], sub {
my $C = shift;
$C->terminator
})
}
)[$try])->($C);
last if @gather;
last if $xact->[-2];  # committed?
}
@gather;
};

})) { ($C) } else { () }
}))) { ($C) } else { () }
}))
and ($C) = ($C->obs('%- variable', '.from method'))) {
$C
} else { () }

});
}
;
## token special_variable:sym<$-[ ]> {
sub special_variable__S_115DollarMinusBra_Ket__PEEK { $_[0]->_AUTOLEXpeek('special_variable__S_115DollarMinusBra_Ket', $retree) }
sub special_variable__S_115DollarMinusBra_Ket {
no warnings 'recursion';
my $self = shift;


local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;

my $C = $self->cursor_xact("RULE special_variable__S_115DollarMinusBra_Ket");
my $xact = $C->xact;
my $S = $C->{'_pos'};
$C->{sym} = "\$\-\[\ \]";
$self->_MATCHIFYr($S, "special_variable__S_115DollarMinusBra_Ket", do {
my $C = $C;
if (($C) = ($C->_EXACT("\$\-\["))
and ($C) = ($C->obs('@- variable', '.from method'))) {
$C
} else { () }

});
}
;
## token special_variable:sym<@-[ ]> {
sub special_variable__S_116AtMinusBra_Ket__PEEK { $_[0]->_AUTOLEXpeek('special_variable__S_116AtMinusBra_Ket', $retree) }
sub special_variable__S_116AtMinusBra_Ket {
no warnings 'recursion';
my $self = shift;


local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;

my $C = $self->cursor_xact("RULE special_variable__S_116AtMinusBra_Ket");
my $xact = $C->xact;
my $S = $C->{'_pos'};
$C->{sym} = "\@\-\[\ \]";
$self->_MATCHIFYr($S, "special_variable__S_116AtMinusBra_Ket", do {
my $C = $C;
if (($C) = ($C->_EXACT("\@\-\["))
and ($C) = ($C->obs('@- variable', '.from method'))) {
$C
} else { () }

});
}
;
## token special_variable:sym<%-{ }> {
sub special_variable__S_117PercentMinusCur_Ly__PEEK { $_[0]->_AUTOLEXpeek('special_variable__S_117PercentMinusCur_Ly', $retree) }
sub special_variable__S_117PercentMinusCur_Ly {
no warnings 'recursion';
my $self = shift;


local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;

my $C = $self->cursor_xact("RULE special_variable__S_117PercentMinusCur_Ly");
my $xact = $C->xact;
my $S = $C->{'_pos'};
$C->{sym} = "\%\-\{\ \}";
$self->_MATCHIFYr($S, "special_variable__S_117PercentMinusCur_Ly", do {
my $C = $C;
if (($C) = ($C->_EXACT("\@\-\{"))
and ($C) = ($C->obs('%- variable', '.from method'))) {
$C
} else { () }

});
}
;
## token special_variable:sym<$+> {
sub special_variable__S_118DollarPlus__PEEK { $_[0]->_AUTOLEXpeek('special_variable__S_118DollarPlus', $retree) }
sub special_variable__S_118DollarPlus {
no warnings 'recursion';
my $self = shift;


local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;

my $C = $self->cursor_xact("RULE special_variable__S_118DollarPlus");
my $xact = $C->xact;
my $S = $C->{'_pos'};
$C->{sym} = "\$\+";
$self->_MATCHIFYr($S, "special_variable__S_118DollarPlus", do {
my $C = $C;
if (($C) = ($C->_EXACT("\$\+"))
and ($C) = ($C->_COMMITLTM())
and ($C) = ($C->before(sub {
my $C=shift;
if (my ($C) = ($C->before(sub {
my $C=shift;
if (my ($C) = (do {
do {
my ($tag, $try);
my @try;
my $relex;

my $fate;
my $x;
if ($fate = $C->{'_fate'} and $fate->[1] eq 'special_variable__S_118DollarPlus_0') {
$C->deb("Fate passed to special_variable__S_118DollarPlus_0: ", ::fatestr($fate)) if $::DEBUG & DEBUG::fates;
($C->{'_fate'}, $tag, $try) = @$fate;
@try = ($try);
$x = 'ALT special_variable__S_118DollarPlus_0';    # some outer ltm is controlling us
}
else {
$x = 'ALTLTM special_variable__S_118DollarPlus_0'; # we are top level ltm
}
my $C = $C->cursor_xact($x);
my $xact = $C->{_xact};

my @gather = ();
for (;;) {
unless (@try) {
$relex //= $C->cursor_fate('STD::P6', 'special_variable__S_118DollarPlus_0', $retree);
@try = $relex->($C) or last;
}
$try = shift(@try) // next;

if (ref $try) {
($C->{'_fate'}, $tag, $try) = @$try;   # next candidate fate
}

$C->deb("special_variable__S_118DollarPlus_0 trying $tag $try") if $::DEBUG & DEBUG::try_processing;
push @gather, ((
sub {
my $C=shift;
$C->_PATTERN(qr/\G\s/)
},
sub {
my $C=shift;
$C->_EXACT("\,")
},
sub {
my $C=shift;
$C->_SUBSUMEr(['terminator'], sub {
my $C = shift;
$C->terminator
})
}
)[$try])->($C);
last if @gather;
last if $xact->[-2];  # committed?
}
@gather;
};

})) { ($C) } else { () }
}))) { ($C) } else { () }
}))
and ($C) = ($C->obs('$+ variable', 'Form module'))) {
$C
} else { () }

});
}
;
## token special_variable:sym<${^ }> {
sub special_variable__S_119DollarCurCaret_Ly__PEEK { $_[0]->_AUTOLEXpeek('special_variable__S_119DollarCurCaret_Ly', $retree) }
sub special_variable__S_119DollarCurCaret_Ly {
no warnings 'recursion';
my $self = shift;


local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;

my $C = $self->cursor_xact("RULE special_variable__S_119DollarCurCaret_Ly");
my $xact = $C->xact;
my $S = $C->{'_pos'};
$C->{sym} = "\$\{\^\ \}";
$self->_MATCHIFYr($S, "special_variable__S_119DollarCurCaret_Ly", do {
my $C = $C;
if (($C) = ($C->_SUBSUMEr(['sigil'], sub {
my $C = shift;
$C->sigil
}))
and ($C) = ($C->_EXACT("\{\^"))
and ($C) = ($C->_COMMITLTM())
and ($C) = ($C->_SUBSUMEr(['text'], sub {
my $C = shift;
$C->_BRACKET(sub {
my $C=shift;
$C->_SCANf()
})
}))
and ($C) = ($C->_EXACT("\}"))
and ($C) = (do {
my $M = $C;
$C->obscaret($M->{'sigil'}->Str . '{^' . $M->{'text'}->Str . '}', $M->{'sigil'}->Str, $M->{'text'}->Str)
})) {
$C
} else { () }

});
}
;
## method obscaret (Str $var, Str $sigil, Str $name)
sub obscaret {
no warnings 'recursion';
my $self = shift;
die 'Required argument var omitted' unless @_;
my $var = @_ ? shift() : undef;
die 'Required argument sigil omitted' unless @_;
my $sigil = @_ ? shift() : undef;
die 'Required argument name omitted' unless @_;
my $name = @_ ? shift() : undef;
my $repl;
given ($sigil) {
when ('$') {
given ($name) {
when ('MATCH')         {
$repl = '$/' }
;
when ('PREMATCH')      {
$repl = 'an explicit pattern before <(' }
;
when ('POSTMATCH')     {
$repl = 'an explicit pattern after )>' }
;
when ('ENCODING')      {
$repl = '$?ENCODING' }
;
when ('UNICODE')       {
$repl = '$?UNICODE' }
;
when ('TAINT')         {
$repl = '$*TAINT' }
;
when ('OPEN')          {
$repl = 'filehandle introspection' }
;
when ('N')             {
$repl = '$-1' }
;
when ('L')             {
$repl = 'Form module' }
;
when ('A')             {
$repl = 'Form module' }
;
when ('E')             {
$repl = '$!.extended_os_error' }
;
when ('C')             {
$repl = 'COMPILING namespace' }
;
when ('D')             {
$repl = '$*DEBUGGING' }
;
when ('F')             {
$repl = '$*SYSTEM_FD_MAX' }
;
when ('H')             {
$repl = '$?FOO variables' }
;
when ('I')             {
$repl = '$*INPLACE' }
;
when ('O')             {
$repl = '$?OS or $*OS' }
;
when ('P')             {
$repl = 'whatever debugger Perl 6 comes with' }
;
when ('R')             {
$repl = 'an explicit result variable' }
;
when ('S')             {
$repl = 'the context function' }
;
when ('T')             {
$repl = '$*BASETIME' }
;
when ('V')             {
$repl = '$*PERL_VERSION' }
;
when ('W')             {
$repl = '$*WARNING' }
;
when ('X')             {
$repl = '$*EXECUTABLE_NAME' }
;
default               {
$repl = "a global form such as $sigil*$name" }
;
}
}
;
when ('%') {
given ($name) {
when ('H')             {
$repl = '$?FOO variables' }
;
default               {
$repl = "a global form such as $sigil*$name" }
;
}
}
;
default {
$repl = "a global form such as $sigil*$name" }
;
};
return $self->obs("$var variable", $repl);
};
## token special_variable:sym<::{ }> {
sub special_variable__S_120ColonColonCur_Ly__PEEK { $_[0]->_AUTOLEXpeek('special_variable__S_120ColonColonCur_Ly', $retree) }
sub special_variable__S_120ColonColonCur_Ly {
no warnings 'recursion';
my $self = shift;


local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;

my $C = $self->cursor_xact("RULE special_variable__S_120ColonColonCur_Ly");
my $xact = $C->xact;
my $S = $C->{'_pos'};
$C->{sym} = "\:\:\{\ \}";
$self->_MATCHIFYr($S, "special_variable__S_120ColonColonCur_Ly", do {
my $C = $C;
if (($C) = ($C->_EXACT("\:\:"))
and ($C) = ($C->before(sub {
my $C=shift;
if (my ($C) = ($C->before(sub {
my $C=shift;
$C->_EXACT("\{")
}))) { ($C) } else { () }
}))) {
$C
} else { () }

});
}
;
## regex special_variable:sym<${ }> {
sub special_variable__S_121DollarCur_Ly__PEEK { $_[0]->_AUTOLEXpeek('special_variable__S_121DollarCur_Ly', $retree) }
sub special_variable__S_121DollarCur_Ly {
no warnings 'recursion';
my $self = shift;


local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;

my $C = $self->cursor_xact("RULE special_variable__S_121DollarCur_Ly");
my $xact = $C->xact;
my $S = $C->{'_pos'};
$C->{sym} = "\$\{\ \}";
$self->_MATCHIFY($S, "special_variable__S_121DollarCur_Ly", LazyMap::lazymap(sub {
my $C=shift;
if (($C) = ($C->_EXACT("\{"))
and ($C) = (scalar(do {
}, $C))) {
LazyMap::lazymap(sub {
my $C=shift;
if (my ($C) = ($C->_EXACT("\}"))) {
scalar(do {
my $M = $C;
{
my $sigil = $M->{'sigil'}->Str;
my $text = $M->{'text'}->Str;
my $bad = $sigil . '{' . $text . '}';
$text = $text - 1 if $text =~ /^\d+$/;
if ($text !~ /^(\w|\:)+$/) {
return () if $::QSIGIL;
$C->obs($bad, $sigil . '(' . $text . ')');
}
elsif ($::QSIGIL) {
$C->obs($bad, '{' . $sigil . $text . '}')}
else {
$C->obs($bad, $sigil . $text)};
}}, $C)
} else { () }
},
$C->_SUBSUME(['text'], sub {
my $C = shift;
$C->_BRACKET(sub {
my $C=shift;
$C->_SCANf()
})
}))
} else { () }
},
$C->_SUBSUME(['sigil'], sub {
my $C = shift;
$C->sigil
})));
}
;
## token special_variable:sym<$[> {
sub special_variable__S_122DollarBra__PEEK { $_[0]->_AUTOLEXpeek('special_variable__S_122DollarBra', $retree) }
sub special_variable__S_122DollarBra {
no warnings 'recursion';
my $self = shift;


local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;

my $C = $self->cursor_xact("RULE special_variable__S_122DollarBra");
my $xact = $C->xact;
my $S = $C->{'_pos'};
$C->{sym} = "\$\[";
$self->_MATCHIFYr($S, "special_variable__S_122DollarBra", do {
my $C = $C;
if (($C) = ($C->_EXACT("\$\["))
and ($C) = ($C->_COMMITLTM())
and ($C) = ($C->before(sub {
my $C=shift;
if (my ($C) = ($C->before(sub {
my $C=shift;
if (my ($C) = (do {
do {
my ($tag, $try);
my @try;
my $relex;

my $fate;
my $x;
if ($fate = $C->{'_fate'} and $fate->[1] eq 'special_variable__S_122DollarBra_0') {
$C->deb("Fate passed to special_variable__S_122DollarBra_0: ", ::fatestr($fate)) if $::DEBUG & DEBUG::fates;
($C->{'_fate'}, $tag, $try) = @$fate;
@try = ($try);
$x = 'ALT special_variable__S_122DollarBra_0';    # some outer ltm is controlling us
}
else {
$x = 'ALTLTM special_variable__S_122DollarBra_0'; # we are top level ltm
}
my $C = $C->cursor_xact($x);
my $xact = $C->{_xact};

my @gather = ();
for (;;) {
unless (@try) {
$relex //= $C->cursor_fate('STD::P6', 'special_variable__S_122DollarBra_0', $retree);
@try = $relex->($C) or last;
}
$try = shift(@try) // next;

if (ref $try) {
($C->{'_fate'}, $tag, $try) = @$try;   # next candidate fate
}

$C->deb("special_variable__S_122DollarBra_0 trying $tag $try") if $::DEBUG & DEBUG::try_processing;
push @gather, ((
sub {
my $C=shift;
$C->_PATTERN(qr/\G\s/)
},
sub {
my $C=shift;
$C->_EXACT("\,")
},
sub {
my $C=shift;
$C->_EXACT("\=")
},
sub {
my $C=shift;
$C->_SUBSUMEr(['terminator'], sub {
my $C = shift;
$C->terminator
})
}
)[$try])->($C);
last if @gather;
last if $xact->[-2];  # committed?
}
@gather;
};

})) { ($C) } else { () }
}))) { ($C) } else { () }
}))
and ($C) = ($C->obs('$[ variable', 'user-defined array indices'))) {
$C
} else { () }

});
}
;
## token special_variable:sym<$]> {
sub special_variable__S_123DollarKet__PEEK { $_[0]->_AUTOLEXpeek('special_variable__S_123DollarKet', $retree) }
sub special_variable__S_123DollarKet {
no warnings 'recursion';
my $self = shift;


local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;

my $C = $self->cursor_xact("RULE special_variable__S_123DollarKet");
my $xact = $C->xact;
my $S = $C->{'_pos'};
$C->{sym} = "\$\]";
$self->_MATCHIFYr($S, "special_variable__S_123DollarKet", do {
my $C = $C;
if (($C) = ($C->_EXACT("\$\]"))
and ($C) = ($C->_COMMITLTM())
and ($C) = ($C->before(sub {
my $C=shift;
if (my ($C) = ($C->before(sub {
my $C=shift;
if (my ($C) = (do {
do {
my ($tag, $try);
my @try;
my $relex;

my $fate;
my $x;
if ($fate = $C->{'_fate'} and $fate->[1] eq 'special_variable__S_123DollarKet_0') {
$C->deb("Fate passed to special_variable__S_123DollarKet_0: ", ::fatestr($fate)) if $::DEBUG & DEBUG::fates;
($C->{'_fate'}, $tag, $try) = @$fate;
@try = ($try);
$x = 'ALT special_variable__S_123DollarKet_0';    # some outer ltm is controlling us
}
else {
$x = 'ALTLTM special_variable__S_123DollarKet_0'; # we are top level ltm
}
my $C = $C->cursor_xact($x);
my $xact = $C->{_xact};

my @gather = ();
for (;;) {
unless (@try) {
$relex //= $C->cursor_fate('STD::P6', 'special_variable__S_123DollarKet_0', $retree);
@try = $relex->($C) or last;
}
$try = shift(@try) // next;

if (ref $try) {
($C->{'_fate'}, $tag, $try) = @$try;   # next candidate fate
}

$C->deb("special_variable__S_123DollarKet_0 trying $tag $try") if $::DEBUG & DEBUG::try_processing;
push @gather, ((
sub {
my $C=shift;
$C->_PATTERN(qr/\G\s/)
},
sub {
my $C=shift;
$C->_EXACT("\,")
},
sub {
my $C=shift;
$C->_SUBSUMEr(['terminator'], sub {
my $C = shift;
$C->terminator
})
}
)[$try])->($C);
last if @gather;
last if $xact->[-2];  # committed?
}
@gather;
};

})) { ($C) } else { () }
}))) { ($C) } else { () }
}))
and ($C) = ($C->obs('$] variable', '$*PERL_VERSION'))) {
$C
} else { () }

});
}
;
## token special_variable:sym<$\\> {
sub special_variable__S_124DollarBack__PEEK { $_[0]->_AUTOLEXpeek('special_variable__S_124DollarBack', $retree) }
sub special_variable__S_124DollarBack {
no warnings 'recursion';
my $self = shift;


local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;

my $C = $self->cursor_xact("RULE special_variable__S_124DollarBack");
my $xact = $C->xact;
my $S = $C->{'_pos'};
$C->{sym} = "\$\\";
$self->_MATCHIFYr($S, "special_variable__S_124DollarBack", do {
my $C = $C;
if (($C) = ($C->_EXACT("\$\\"))
and ($C) = ($C->_COMMITLTM())
and ($C) = ($C->before(sub {
my $C=shift;
if (my ($C) = ($C->before(sub {
my $C=shift;
if (my ($C) = (do {
do {
my ($tag, $try);
my @try;
my $relex;

my $fate;
my $x;
if ($fate = $C->{'_fate'} and $fate->[1] eq 'special_variable__S_124DollarBack_0') {
$C->deb("Fate passed to special_variable__S_124DollarBack_0: ", ::fatestr($fate)) if $::DEBUG & DEBUG::fates;
($C->{'_fate'}, $tag, $try) = @$fate;
@try = ($try);
$x = 'ALT special_variable__S_124DollarBack_0';    # some outer ltm is controlling us
}
else {
$x = 'ALTLTM special_variable__S_124DollarBack_0'; # we are top level ltm
}
my $C = $C->cursor_xact($x);
my $xact = $C->{_xact};

my @gather = ();
for (;;) {
unless (@try) {
$relex //= $C->cursor_fate('STD::P6', 'special_variable__S_124DollarBack_0', $retree);
@try = $relex->($C) or last;
}
$try = shift(@try) // next;

if (ref $try) {
($C->{'_fate'}, $tag, $try) = @$try;   # next candidate fate
}

$C->deb("special_variable__S_124DollarBack_0 trying $tag $try") if $::DEBUG & DEBUG::try_processing;
push @gather, ((
sub {
my $C=shift;
$C->_PATTERN(qr/\G\s/)
},
sub {
my $C=shift;
$C->_EXACT("\,")
},
sub {
my $C=shift;
$C->_EXACT("\=")
},
sub {
my $C=shift;
$C->_SUBSUMEr(['terminator'], sub {
my $C = shift;
$C->terminator
})
}
)[$try])->($C);
last if @gather;
last if $xact->[-2];  # committed?
}
@gather;
};

})) { ($C) } else { () }
}))) { ($C) } else { () }
}))
and ($C) = ($C->obs('$\\ variable', "the filehandle's :ors attribute"))) {
$C
} else { () }

});
}
;
## token special_variable:sym<$|> {
sub special_variable__S_125DollarVert__PEEK { $_[0]->_AUTOLEXpeek('special_variable__S_125DollarVert', $retree) }
sub special_variable__S_125DollarVert {
no warnings 'recursion';
my $self = shift;


local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;

my $C = $self->cursor_xact("RULE special_variable__S_125DollarVert");
my $xact = $C->xact;
my $S = $C->{'_pos'};
$C->{sym} = "\$\|";
$self->_MATCHIFYr($S, "special_variable__S_125DollarVert", do {
my $C = $C;
if (($C) = ($C->_EXACT("\$\|"))
and ($C) = ($C->_COMMITLTM())
and ($C) = ($C->before(sub {
my $C=shift;
if (my ($C) = ($C->before(sub {
my $C=shift;
if (my ($C) = (do {
do {
my ($tag, $try);
my @try;
my $relex;

my $fate;
my $x;
if ($fate = $C->{'_fate'} and $fate->[1] eq 'special_variable__S_125DollarVert_0') {
$C->deb("Fate passed to special_variable__S_125DollarVert_0: ", ::fatestr($fate)) if $::DEBUG & DEBUG::fates;
($C->{'_fate'}, $tag, $try) = @$fate;
@try = ($try);
$x = 'ALT special_variable__S_125DollarVert_0';    # some outer ltm is controlling us
}
else {
$x = 'ALTLTM special_variable__S_125DollarVert_0'; # we are top level ltm
}
my $C = $C->cursor_xact($x);
my $xact = $C->{_xact};

my @gather = ();
for (;;) {
unless (@try) {
$relex //= $C->cursor_fate('STD::P6', 'special_variable__S_125DollarVert_0', $retree);
@try = $relex->($C) or last;
}
$try = shift(@try) // next;

if (ref $try) {
($C->{'_fate'}, $tag, $try) = @$try;   # next candidate fate
}

$C->deb("special_variable__S_125DollarVert_0 trying $tag $try") if $::DEBUG & DEBUG::try_processing;
push @gather, ((
sub {
my $C=shift;
$C->_PATTERN(qr/\G\s/)
},
sub {
my $C=shift;
$C->_EXACT("\,")
},
sub {
my $C=shift;
$C->_EXACT("\=")
},
sub {
my $C=shift;
$C->_SUBSUMEr(['terminator'], sub {
my $C = shift;
$C->terminator
})
}
)[$try])->($C);
last if @gather;
last if $xact->[-2];  # committed?
}
@gather;
};

})) { ($C) } else { () }
}))) { ($C) } else { () }
}))
and ($C) = ($C->obs('$| variable', ':autoflush on open'))) {
$C
} else { () }

});
}
;
## token special_variable:sym<$:> {
sub special_variable__S_126DollarColon__PEEK { $_[0]->_AUTOLEXpeek('special_variable__S_126DollarColon', $retree) }
sub special_variable__S_126DollarColon {
no warnings 'recursion';
my $self = shift;


local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;

my $C = $self->cursor_xact("RULE special_variable__S_126DollarColon");
my $xact = $C->xact;
my $S = $C->{'_pos'};
$C->{sym} = "\$\:";
$self->_MATCHIFYr($S, "special_variable__S_126DollarColon", do {
my $C = $C;
if (($C) = ($C->_EXACT("\$\:"))
and ($C) = ($C->before(sub {
my $C=shift;
if (my ($C) = ($C->before(sub {
my $C=shift;
$C->_PATTERN(qr/\G[\x20\t\n\],=)}]/)
}))) { ($C) } else { () }
}))
and ($C) = ($C->obs('$: variable', 'Form module'))) {
$C
} else { () }

});
}
;
## token special_variable:sym<$;> {
sub special_variable__S_127DollarSemi__PEEK { $_[0]->_AUTOLEXpeek('special_variable__S_127DollarSemi', $retree) }
sub special_variable__S_127DollarSemi {
no warnings 'recursion';
my $self = shift;


local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;

my $C = $self->cursor_xact("RULE special_variable__S_127DollarSemi");
my $xact = $C->xact;
my $S = $C->{'_pos'};
$C->{sym} = "\$\;";
$self->_MATCHIFYr($S, "special_variable__S_127DollarSemi", do {
my $C = $C;
if (($C) = ($C->_EXACT("\$\;"))
and ($C) = ($C->_COMMITLTM())
and ($C) = ($C->before(sub {
my $C=shift;
if (my ($C) = ($C->before(sub {
my $C=shift;
if (my ($C) = (do {
do {
my ($tag, $try);
my @try;
my $relex;

my $fate;
my $x;
if ($fate = $C->{'_fate'} and $fate->[1] eq 'special_variable__S_127DollarSemi_0') {
$C->deb("Fate passed to special_variable__S_127DollarSemi_0: ", ::fatestr($fate)) if $::DEBUG & DEBUG::fates;
($C->{'_fate'}, $tag, $try) = @$fate;
@try = ($try);
$x = 'ALT special_variable__S_127DollarSemi_0';    # some outer ltm is controlling us
}
else {
$x = 'ALTLTM special_variable__S_127DollarSemi_0'; # we are top level ltm
}
my $C = $C->cursor_xact($x);
my $xact = $C->{_xact};

my @gather = ();
for (;;) {
unless (@try) {
$relex //= $C->cursor_fate('STD::P6', 'special_variable__S_127DollarSemi_0', $retree);
@try = $relex->($C) or last;
}
$try = shift(@try) // next;

if (ref $try) {
($C->{'_fate'}, $tag, $try) = @$try;   # next candidate fate
}

$C->deb("special_variable__S_127DollarSemi_0 trying $tag $try") if $::DEBUG & DEBUG::try_processing;
push @gather, ((
sub {
my $C=shift;
$C->_PATTERN(qr/\G\s/)
},
sub {
my $C=shift;
$C->_EXACT("\,")
},
sub {
my $C=shift;
$C->_EXACT("\=")
},
sub {
my $C=shift;
$C->_SUBSUMEr(['terminator'], sub {
my $C = shift;
$C->terminator
})
}
)[$try])->($C);
last if @gather;
last if $xact->[-2];  # committed?
}
@gather;
};

})) { ($C) } else { () }
}))) { ($C) } else { () }
}))
and ($C) = ($C->obs('$; variable', 'real multidimensional hashes'))) {
$C
} else { () }

});
}
;
## token special_variable:sym<$'> { #'
sub special_variable__S_128DollarSingle__PEEK { $_[0]->_AUTOLEXpeek('special_variable__S_128DollarSingle', $retree) }
sub special_variable__S_128DollarSingle {
no warnings 'recursion';
my $self = shift;


local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;

my $C = $self->cursor_xact("RULE special_variable__S_128DollarSingle");
my $xact = $C->xact;
my $S = $C->{'_pos'};
$C->{sym} = "\$\'";
$self->_MATCHIFYr($S, "special_variable__S_128DollarSingle", do {
my $C = $C;
if (($C) = ($C->_EXACT("\$\'"))
and ($C) = ($C->_COMMITLTM())
and ($C) = ($C->before(sub {
my $C=shift;
if (my ($C) = ($C->before(sub {
my $C=shift;
if (my ($C) = (do {
do {
my ($tag, $try);
my @try;
my $relex;

my $fate;
my $x;
if ($fate = $C->{'_fate'} and $fate->[1] eq 'special_variable__S_128DollarSingle_0') {
$C->deb("Fate passed to special_variable__S_128DollarSingle_0: ", ::fatestr($fate)) if $::DEBUG & DEBUG::fates;
($C->{'_fate'}, $tag, $try) = @$fate;
@try = ($try);
$x = 'ALT special_variable__S_128DollarSingle_0';    # some outer ltm is controlling us
}
else {
$x = 'ALTLTM special_variable__S_128DollarSingle_0'; # we are top level ltm
}
my $C = $C->cursor_xact($x);
my $xact = $C->{_xact};

my @gather = ();
for (;;) {
unless (@try) {
$relex //= $C->cursor_fate('STD::P6', 'special_variable__S_128DollarSingle_0', $retree);
@try = $relex->($C) or last;
}
$try = shift(@try) // next;

if (ref $try) {
($C->{'_fate'}, $tag, $try) = @$try;   # next candidate fate
}

$C->deb("special_variable__S_128DollarSingle_0 trying $tag $try") if $::DEBUG & DEBUG::try_processing;
push @gather, ((
sub {
my $C=shift;
$C->_PATTERN(qr/\G\s/)
},
sub {
my $C=shift;
$C->_EXACT("\,")
},
sub {
my $C=shift;
$C->_SUBSUMEr(['terminator'], sub {
my $C = shift;
$C->terminator
})
}
)[$try])->($C);
last if @gather;
last if $xact->[-2];  # committed?
}
@gather;
};

})) { ($C) } else { () }
}))) { ($C) } else { () }
}))
and ($C) = ($C->obs('$' . "'" . 'variable', "explicit pattern after )\x{3E}"))) {
$C
} else { () }

});
}
;
## token special_variable:sym<$"> {
sub special_variable__S_129DollarDouble__PEEK { $_[0]->_AUTOLEXpeek('special_variable__S_129DollarDouble', $retree) }
sub special_variable__S_129DollarDouble {
no warnings 'recursion';
my $self = shift;


local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;

my $C = $self->cursor_xact("RULE special_variable__S_129DollarDouble");
my $xact = $C->xact;
my $S = $C->{'_pos'};
$C->{sym} = "\$\"";
$self->_MATCHIFYr($S, "special_variable__S_129DollarDouble", do {
my $C = $C;
if (($C) = ($C->_EXACT("\$\""))
and ($C) = ($C->_NOTBEFORE(sub {
my $C=shift;
(($C) x !!do {
$::QSIGIL })
}))
and ($C) = ($C->_COMMITLTM())
and ($C) = ($C->before(sub {
my $C=shift;
if (my ($C) = ($C->before(sub {
my $C=shift;
if (my ($C) = (do {
do {
my ($tag, $try);
my @try;
my $relex;

my $fate;
my $x;
if ($fate = $C->{'_fate'} and $fate->[1] eq 'special_variable__S_129DollarDouble_0') {
$C->deb("Fate passed to special_variable__S_129DollarDouble_0: ", ::fatestr($fate)) if $::DEBUG & DEBUG::fates;
($C->{'_fate'}, $tag, $try) = @$fate;
@try = ($try);
$x = 'ALT special_variable__S_129DollarDouble_0';    # some outer ltm is controlling us
}
else {
$x = 'ALTLTM special_variable__S_129DollarDouble_0'; # we are top level ltm
}
my $C = $C->cursor_xact($x);
my $xact = $C->{_xact};

my @gather = ();
for (;;) {
unless (@try) {
$relex //= $C->cursor_fate('STD::P6', 'special_variable__S_129DollarDouble_0', $retree);
@try = $relex->($C) or last;
}
$try = shift(@try) // next;

if (ref $try) {
($C->{'_fate'}, $tag, $try) = @$try;   # next candidate fate
}

$C->deb("special_variable__S_129DollarDouble_0 trying $tag $try") if $::DEBUG & DEBUG::try_processing;
push @gather, ((
sub {
my $C=shift;
$C->_PATTERN(qr/\G\s/)
},
sub {
my $C=shift;
$C->_EXACT("\,")
},
sub {
my $C=shift;
$C->_EXACT("\=")
},
sub {
my $C=shift;
$C->_SUBSUMEr(['terminator'], sub {
my $C = shift;
$C->terminator
})
}
)[$try])->($C);
last if @gather;
last if $xact->[-2];  # committed?
}
@gather;
};

})) { ($C) } else { () }
}))) { ($C) } else { () }
}))
and ($C) = ($C->obs('$" variable', '.join() method'))) {
$C
} else { () }

});
}
;
## token special_variable:sym<$,> {
sub special_variable__S_130DollarComma__PEEK { $_[0]->_AUTOLEXpeek('special_variable__S_130DollarComma', $retree) }
sub special_variable__S_130DollarComma {
no warnings 'recursion';
my $self = shift;


local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;

my $C = $self->cursor_xact("RULE special_variable__S_130DollarComma");
my $xact = $C->xact;
my $S = $C->{'_pos'};
$C->{sym} = "\$\,";
$self->_MATCHIFYr($S, "special_variable__S_130DollarComma", do {
my $C = $C;
if (($C) = ($C->_EXACT("\$\,"))
and ($C) = ($C->_COMMITLTM())
and ($C) = ($C->before(sub {
my $C=shift;
if (my ($C) = ($C->before(sub {
my $C=shift;
if (my ($C) = (do {
do {
my ($tag, $try);
my @try;
my $relex;

my $fate;
my $x;
if ($fate = $C->{'_fate'} and $fate->[1] eq 'special_variable__S_130DollarComma_0') {
$C->deb("Fate passed to special_variable__S_130DollarComma_0: ", ::fatestr($fate)) if $::DEBUG & DEBUG::fates;
($C->{'_fate'}, $tag, $try) = @$fate;
@try = ($try);
$x = 'ALT special_variable__S_130DollarComma_0';    # some outer ltm is controlling us
}
else {
$x = 'ALTLTM special_variable__S_130DollarComma_0'; # we are top level ltm
}
my $C = $C->cursor_xact($x);
my $xact = $C->{_xact};

my @gather = ();
for (;;) {
unless (@try) {
$relex //= $C->cursor_fate('STD::P6', 'special_variable__S_130DollarComma_0', $retree);
@try = $relex->($C) or last;
}
$try = shift(@try) // next;

if (ref $try) {
($C->{'_fate'}, $tag, $try) = @$try;   # next candidate fate
}

$C->deb("special_variable__S_130DollarComma_0 trying $tag $try") if $::DEBUG & DEBUG::try_processing;
push @gather, ((
sub {
my $C=shift;
$C->_PATTERN(qr/\G\s/)
},
sub {
my $C=shift;
$C->_EXACT("\,")
},
sub {
my $C=shift;
$C->_SUBSUMEr(['terminator'], sub {
my $C = shift;
$C->terminator
})
}
)[$try])->($C);
last if @gather;
last if $xact->[-2];  # committed?
}
@gather;
};

})) { ($C) } else { () }
}))) { ($C) } else { () }
}))
and ($C) = ($C->obs('$, variable', ".join() method"))) {
$C
} else { () }

});
}
;
## token special_variable:sym['$<'] {
sub special_variable__S_131DollarLt__PEEK { $_[0]->_AUTOLEXpeek('special_variable__S_131DollarLt', $retree) }
sub special_variable__S_131DollarLt {
no warnings 'recursion';
my $self = shift;


local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;

my $C = $self->cursor_xact("RULE special_variable__S_131DollarLt");
my $xact = $C->xact;
my $S = $C->{'_pos'};
$C->{sym} = "\$\<";
$self->_MATCHIFYr($S, "special_variable__S_131DollarLt", do {
my $C = $C;
if (($C) = ($C->_EXACT("\$\<"))
and ($C) = ($C->before(sub {
my $C=shift;
if (my ($C) = ($C->before(sub {
my $C=shift;
do {
my $C = $C;
if (($C) = ($C->_PATTERN(qr/\G[\x20\t\r]*+[=,;?:!)\]}]/))
and ($C) = ($C->_NOTBEFORE(sub {
my $C=shift;
if (my ($C) = ($C->before(sub {
my $C=shift;
$C->_PATTERN(qr/\G\S*+\>/)
}))) { ($C) } else { () }
}))) {
$C
} else { () }
};
}))) { ($C) } else { () }
}))
and ($C) = ($C->obs('$< variable', '$*UID'))) {
$C
} else { () }

});
}
;
## token special_variable:sym«\$>» {
sub special_variable__S_132DollarGt__PEEK { $_[0]->_AUTOLEXpeek('special_variable__S_132DollarGt', $retree) }
sub special_variable__S_132DollarGt {
no warnings 'recursion';
my $self = shift;


local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;

my $C = $self->cursor_xact("RULE special_variable__S_132DollarGt");
my $xact = $C->xact;
my $S = $C->{'_pos'};
$C->{sym} = "\$\>";
$self->_MATCHIFYr($S, "special_variable__S_132DollarGt", do {
my $C = $C;
if (($C) = ($C->_EXACT("\$\>"))
and ($C) = ($C->_COMMITLTM())
and ($C) = ($C->before(sub {
my $C=shift;
if (my ($C) = ($C->before(sub {
my $C=shift;
if (my ($C) = (do {
do {
my ($tag, $try);
my @try;
my $relex;

my $fate;
my $x;
if ($fate = $C->{'_fate'} and $fate->[1] eq 'special_variable__S_132DollarGt_0') {
$C->deb("Fate passed to special_variable__S_132DollarGt_0: ", ::fatestr($fate)) if $::DEBUG & DEBUG::fates;
($C->{'_fate'}, $tag, $try) = @$fate;
@try = ($try);
$x = 'ALT special_variable__S_132DollarGt_0';    # some outer ltm is controlling us
}
else {
$x = 'ALTLTM special_variable__S_132DollarGt_0'; # we are top level ltm
}
my $C = $C->cursor_xact($x);
my $xact = $C->{_xact};

my @gather = ();
for (;;) {
unless (@try) {
$relex //= $C->cursor_fate('STD::P6', 'special_variable__S_132DollarGt_0', $retree);
@try = $relex->($C) or last;
}
$try = shift(@try) // next;

if (ref $try) {
($C->{'_fate'}, $tag, $try) = @$try;   # next candidate fate
}

$C->deb("special_variable__S_132DollarGt_0 trying $tag $try") if $::DEBUG & DEBUG::try_processing;
push @gather, ((
sub {
my $C=shift;
$C->_PATTERN(qr/\G\s/)
},
sub {
my $C=shift;
$C->_EXACT("\,")
},
sub {
my $C=shift;
$C->_SUBSUMEr(['terminator'], sub {
my $C = shift;
$C->terminator
})
}
)[$try])->($C);
last if @gather;
last if $xact->[-2];  # committed?
}
@gather;
};

})) { ($C) } else { () }
}))) { ($C) } else { () }
}))
and ($C) = ($C->obs('$> variable', '$*EUID'))) {
$C
} else { () }

});
}
;
## token special_variable:sym<$.> {
sub special_variable__S_133DollarDot__PEEK { $_[0]->_AUTOLEXpeek('special_variable__S_133DollarDot', $retree) }
sub special_variable__S_133DollarDot {
no warnings 'recursion';
my $self = shift;


local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;

my $C = $self->cursor_xact("RULE special_variable__S_133DollarDot");
my $xact = $C->xact;
my $S = $C->{'_pos'};
$C->{sym} = "\$\.";
$self->_MATCHIFYr($S, "special_variable__S_133DollarDot", do {
my $C = $C;
if (($C) = ($C->_EXACT("\$\."))
and ($C) = ($C->_COMMITLTM())
and ($C) = ($C->before(sub {
my $C=shift;
if (my ($C) = ($C->before(sub {
my $C=shift;
if (my ($C) = (do {
do {
my ($tag, $try);
my @try;
my $relex;

my $fate;
my $x;
if ($fate = $C->{'_fate'} and $fate->[1] eq 'special_variable__S_133DollarDot_0') {
$C->deb("Fate passed to special_variable__S_133DollarDot_0: ", ::fatestr($fate)) if $::DEBUG & DEBUG::fates;
($C->{'_fate'}, $tag, $try) = @$fate;
@try = ($try);
$x = 'ALT special_variable__S_133DollarDot_0';    # some outer ltm is controlling us
}
else {
$x = 'ALTLTM special_variable__S_133DollarDot_0'; # we are top level ltm
}
my $C = $C->cursor_xact($x);
my $xact = $C->{_xact};

my @gather = ();
for (;;) {
unless (@try) {
$relex //= $C->cursor_fate('STD::P6', 'special_variable__S_133DollarDot_0', $retree);
@try = $relex->($C) or last;
}
$try = shift(@try) // next;

if (ref $try) {
($C->{'_fate'}, $tag, $try) = @$try;   # next candidate fate
}

$C->deb("special_variable__S_133DollarDot_0 trying $tag $try") if $::DEBUG & DEBUG::try_processing;
push @gather, ((
sub {
my $C=shift;
$C->_PATTERN(qr/\G\s/)
},
sub {
my $C=shift;
$C->_EXACT("\,")
},
sub {
my $C=shift;
$C->_SUBSUMEr(['terminator'], sub {
my $C = shift;
$C->terminator
})
}
)[$try])->($C);
last if @gather;
last if $xact->[-2];  # committed?
}
@gather;
};

})) { ($C) } else { () }
}))) { ($C) } else { () }
}))
and ($C) = ($C->obs('$. variable', "the filehandle's .line method"))) {
$C
} else { () }

});
}
;
## token special_variable:sym<$?> {
sub special_variable__S_134DollarQuestion__PEEK { $_[0]->_AUTOLEXpeek('special_variable__S_134DollarQuestion', $retree) }
sub special_variable__S_134DollarQuestion {
no warnings 'recursion';
my $self = shift;


local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;

my $C = $self->cursor_xact("RULE special_variable__S_134DollarQuestion");
my $xact = $C->xact;
my $S = $C->{'_pos'};
$C->{sym} = "\$\?";
$self->_MATCHIFYr($S, "special_variable__S_134DollarQuestion", do {
my $C = $C;
if (($C) = ($C->_EXACT("\$\?"))
and ($C) = ($C->_COMMITLTM())
and ($C) = ($C->before(sub {
my $C=shift;
if (my ($C) = ($C->before(sub {
my $C=shift;
if (my ($C) = (do {
do {
my ($tag, $try);
my @try;
my $relex;

my $fate;
my $x;
if ($fate = $C->{'_fate'} and $fate->[1] eq 'special_variable__S_134DollarQuestion_0') {
$C->deb("Fate passed to special_variable__S_134DollarQuestion_0: ", ::fatestr($fate)) if $::DEBUG & DEBUG::fates;
($C->{'_fate'}, $tag, $try) = @$fate;
@try = ($try);
$x = 'ALT special_variable__S_134DollarQuestion_0';    # some outer ltm is controlling us
}
else {
$x = 'ALTLTM special_variable__S_134DollarQuestion_0'; # we are top level ltm
}
my $C = $C->cursor_xact($x);
my $xact = $C->{_xact};

my @gather = ();
for (;;) {
unless (@try) {
$relex //= $C->cursor_fate('STD::P6', 'special_variable__S_134DollarQuestion_0', $retree);
@try = $relex->($C) or last;
}
$try = shift(@try) // next;

if (ref $try) {
($C->{'_fate'}, $tag, $try) = @$try;   # next candidate fate
}

$C->deb("special_variable__S_134DollarQuestion_0 trying $tag $try") if $::DEBUG & DEBUG::try_processing;
push @gather, ((
sub {
my $C=shift;
$C->_PATTERN(qr/\G\s/)
},
sub {
my $C=shift;
$C->_EXACT("\,")
},
sub {
my $C=shift;
$C->_SUBSUMEr(['terminator'], sub {
my $C = shift;
$C->terminator
})
}
)[$try])->($C);
last if @gather;
last if $xact->[-2];  # committed?
}
@gather;
};

})) { ($C) } else { () }
}))) { ($C) } else { () }
}))
and ($C) = ($C->obs('$? variable as child error', '$!'))) {
$C
} else { () }

});
}
;
## token desigilname {
sub desigilname__PEEK { $_[0]->_AUTOLEXpeek('desigilname', $retree) }
sub desigilname {
no warnings 'recursion';
my $self = shift;


local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;

my $C = $self->cursor_xact("RULE desigilname");
my $xact = $C->xact;
my $S = $C->{'_pos'};
$self->_MATCHIFYr($S, "desigilname", $C->_BRACKETr(sub {
my $C=shift;
do {
my ($tag, $try);
my @try;
my $relex;

my $fate;
my $x;
if ($fate = $C->{'_fate'} and $fate->[1] eq 'desigilname_0') {
$C->deb("Fate passed to desigilname_0: ", ::fatestr($fate)) if $::DEBUG & DEBUG::fates;
($C->{'_fate'}, $tag, $try) = @$fate;
@try = ($try);
$x = 'ALT desigilname_0';    # some outer ltm is controlling us
}
else {
$x = 'ALTLTM desigilname_0'; # we are top level ltm
}
my $C = $C->cursor_xact($x);
my $xact = $C->{_xact};

my @gather = ();
for (;;) {
unless (@try) {
$relex //= $C->cursor_fate('STD::P6', 'desigilname_0', $retree);
@try = $relex->($C) or last;
}
$try = shift(@try) // next;

if (ref $try) {
($C->{'_fate'}, $tag, $try) = @$try;   # next candidate fate
}

$C->deb("desigilname_0 trying $tag $try") if $::DEBUG & DEBUG::try_processing;
push @gather, ((
sub {
my $C=shift;
if (($C) = ($C->before(sub {
my $C=shift;
if (my ($C) = ($C->before(sub {
my $C=shift;
$C->_EXACT("\$")
}))) { ($C) } else { () }
}))
and ($C) = ($C->_OPTr(sub {
my $C=shift;
if (my ($C) = ($C->_BRACKETr(sub {
my $C=shift;
if (($C) = ($C->before(sub {
my $C=shift;
(($C) x !!do {
$::IN_DECL })
}))
and ($C) = ($C->panic("Can't declare an indirect variable name"))) {
$C
} else { () }
}))) { ($C) } else { () }
}))
and ($C) = ($C->_SUBSUMEr(['variable'], sub {
my $C = shift;
$C->variable
}))) {
scalar(do {
my $M = $C;
$::VAR = $M->{'variable'};
$self->check_variable($::VAR) if substr($::VAR,1,1) ne '$';
}, $C)
} else { () }
},
sub {
my $C=shift;
if (($C) = ($C->before(sub {
my $C=shift;
if (my ($C) = ($C->before(sub {
my $C=shift;
$C->{'sigil'} = [];
do {
my $C = $C;
if (($C) = ($C->_PATTERN(qr/\G[\@\%\&]/))
and ($C) = ($C->_STARr(sub {
my $C=shift;
$C->_SUBSUMEr(['sigil'], sub {
my $C = shift;
$C->sigil
})
}))) {
$C->_PATTERN(qr/\G\w/)
} else { () }
};
}))) { ($C) } else { () }
}))
and ($C) = ($C->panic("Invalid hard reference syntax"))) {
$C
} else { () }
},
sub {
my $C=shift;
$C->_SUBSUMEr(['longname'], sub {
my $C = shift;
$C->longname
})
}
)[$try])->($C);
last if @gather;
last if $xact->[-2];  # committed?
}
@gather;
};
}));
}
;
## token variable {
sub variable__PEEK { $_[0]->_AUTOLEXpeek('variable', $retree) }
sub variable {
no warnings 'recursion';
my $self = shift;

local $::IN_META = '';my $sigil = '';my $twigil = '';my $name;
local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;

my $C = $self->cursor_xact("RULE variable");
my $xact = $C->xact;
my $S = $C->{'_pos'};
$C->{'name'} = [];
$C->{'postcircumfix'} = [];
$C->{'twigil'} = [];
$self->_MATCHIFYr($S, "variable", do {
my $C = $C;
if (($C) = ($C->before(sub {
my $C=shift;
if (my ($C) = ($C->before(sub {
my $C=shift;
if (my ($C) = ($C->_SUBSUMEr(['sigil'], sub {
my $C = shift;
$C->sigil
}))) {
scalar(do {
my $M = $C;
$sigil = $M->{'sigil'}->Str;
$::LEFTSIGIL ||= $sigil;
}, $C)
} else { () }
}))) { ($C) } else { () }
}))
and ($C) = (scalar(do {
}, $C))
and ($C) = ($C->_BRACKETr(sub {
my $C=shift;
do {    my $C = $C->cursor_xact('ALT ||');
my $xact = $C->xact;
my @gather;
do {
push @gather, do {
my $C = $C;
if (($C) = ($C->_SUBSUMEr(['sigil'], sub {
my $C = shift;
$C->sigil
}))
and ($C) = ($C->_OPTr(sub {
my $C=shift;
$C->_SUBSUMEr(['twigil'], sub {
my $C = shift;
$C->twigil
})
}))
and ($C) = ($C->before(sub {
my $C=shift;
if (my ($C) = ($C->before(sub {
my $C=shift;
do {
my $C = $C;
if (($C) = ($C->_EXACT("\:\:"))
and ($C) = ($C->_BRACKETr(sub {
my $C=shift;
do {
my ($tag, $try);
my @try;
my $relex;

my $fate;
my $x;
if ($fate = $C->{'_fate'} and $fate->[1] eq 'variable_0') {
$C->deb("Fate passed to variable_0: ", ::fatestr($fate)) if $::DEBUG & DEBUG::fates;
($C->{'_fate'}, $tag, $try) = @$fate;
@try = ($try);
$x = 'ALT variable_0';    # some outer ltm is controlling us
}
else {
$x = 'ALTLTM variable_0'; # we are top level ltm
}
my $C = $C->cursor_xact($x);
my $xact = $C->{_xact};

my @gather = ();
for (;;) {
unless (@try) {
$relex //= $C->cursor_fate('STD::P6', 'variable_0', $retree);
@try = $relex->($C) or last;
}
$try = shift(@try) // next;

if (ref $try) {
($C->{'_fate'}, $tag, $try) = @$try;   # next candidate fate
}

$C->deb("variable_0 trying $tag $try") if $::DEBUG & DEBUG::try_processing;
push @gather, ((
sub {
my $C=shift;
$C->_EXACT("\{")
},
sub {
my $C=shift;
$C->_EXACT("\<")
},
sub {
my $C=shift;
$C->_EXACT("\(")
}
)[$try])->($C);
last if @gather;
last if $xact->[-2];  # committed?
}
@gather;
};
}))) {
$C
} else { () }
};
}))) { ($C) } else { () }
}))) {
$C->_SUBSUMEr(['longname'], sub {
my $C = shift;
$C->longname
})
} else { () }

}
}
or $xact->[-2] or
do {
push @gather, do {
my $C = $C;
if (($C) = ($C->_EXACT("\&"))
and ($C) = ($C->_BRACKETr(sub {
my $C=shift;
do {
my ($tag, $try);
my @try;
my $relex;

my $fate;
my $x;
if ($fate = $C->{'_fate'} and $fate->[1] eq 'variable_1') {
$C->deb("Fate passed to variable_1: ", ::fatestr($fate)) if $::DEBUG & DEBUG::fates;
($C->{'_fate'}, $tag, $try) = @$fate;
@try = ($try);
$x = 'ALT variable_1';    # some outer ltm is controlling us
}
else {
$x = 'ALTLTM variable_1'; # we are top level ltm
}
my $C = $C->cursor_xact($x);
my $xact = $C->{_xact};

my @gather = ();
for (;;) {
unless (@try) {
$relex //= $C->cursor_fate('STD::P6', 'variable_1', $retree);
@try = $relex->($C) or last;
}
$try = shift(@try) // next;

if (ref $try) {
($C->{'_fate'}, $tag, $try) = @$try;   # next candidate fate
}

$C->deb("variable_1 trying $tag $try") if $::DEBUG & DEBUG::try_processing;
push @gather, ((
sub {
my $C=shift;
if (($C) = ($C->_OPTr(sub {
my $C=shift;
$C->_SUBSUMEr(['twigil'], sub {
my $C = shift;
$C->twigil
})
}))
and ($C) = ($C->_SUBSUMEr(['sublongname'], sub {
my $C = shift;
$C->sublongname
}))) {
scalar(do {
my $M = $C;
$name = $M->{'sublongname'}->Str }, $C)
} else { () }
},
sub {
my $C=shift;
if (my ($C) = ($C->_BRACKETr(sub {
my $C=shift;
local $::GOAL = "\]";
my $goalpos = $C;
if (($C) = ($C->_EXACT("\["))
and ($C) = (scalar(do {
}, $C))
and ($C) = ($C->_SUBSUMEr(['infixish'], sub {
my $C = shift;
$C->infixish('[]')
}))
and ($C) = ($C->_BRACKETr(sub {
my $C=shift;
do {    my $C = $C->cursor_xact('ALT ||');
my $xact = $C->xact;
my @gather;
do {
push @gather, $C->_EXACT("\]")
}
or $xact->[-2] or
do {
push @gather, do {
if (my ($C) = ($C->FAILGOAL($::GOAL, 'infix noun', $goalpos))) { ($C) } else { () }

}
};
@gather;
}
}))) {
$C
} else { () }
}))) { ($C) } else { () }
}
)[$try])->($C);
last if @gather;
last if $xact->[-2];  # committed?
}
@gather;
};
}))) {
$C
} else { () }

}
}
or $xact->[-2] or
do {
push @gather, do {
if (my ($C) = ($C->_EXACT("\$\:\:"))) {
$C->_OPTr(sub {
my $C=shift;
$C->_SUBSUMEr(['name'], sub {
my $C = shift;
$C->name
})
})
} else { () }

}
}
or $xact->[-2] or
do {
push @gather, do {
if (my ($C) = ($C->_EXACT("\$\:"))) {
$C->_SUBSUMEr(['name'], sub {
my $C = shift;
$C->name
})
} else { () }

}
}
or $xact->[-2] or
do {
push @gather, do {
if (my ($C) = ($C->_BRACKETr(sub {
my $C=shift;
do {
my ($tag, $try);
my @try;
my $relex;

my $fate;
my $x;
if ($fate = $C->{'_fate'} and $fate->[1] eq 'variable_2') {
$C->deb("Fate passed to variable_2: ", ::fatestr($fate)) if $::DEBUG & DEBUG::fates;
($C->{'_fate'}, $tag, $try) = @$fate;
@try = ($try);
$x = 'ALT variable_2';    # some outer ltm is controlling us
}
else {
$x = 'ALTLTM variable_2'; # we are top level ltm
}
my $C = $C->cursor_xact($x);
my $xact = $C->{_xact};

my @gather = ();
for (;;) {
unless (@try) {
$relex //= $C->cursor_fate('STD::P6', 'variable_2', $retree);
@try = $relex->($C) or last;
}
$try = shift(@try) // next;

if (ref $try) {
($C->{'_fate'}, $tag, $try) = @$try;   # next candidate fate
}

$C->deb("variable_2 trying $tag $try") if $::DEBUG & DEBUG::try_processing;
push @gather, ((
sub {
my $C=shift;
if (($C) = ($C->_SUBSUMEr(['sigil'], sub {
my $C = shift;
$C->sigil
}))
and ($C) = ($C->_OPTr(sub {
my $C=shift;
$C->_SUBSUMEr(['twigil'], sub {
my $C = shift;
$C->twigil
})
}))
and ($C) = ($C->_SUBSUMEr(['desigilname'], sub {
my $C = shift;
$C->desigilname
}))) {
scalar(do {
my $M = $C;
$name = $M->{'desigilname'}->Str }, $C)
} else { () }
},
sub {
my $C=shift;
$C->_SUBSUMEr(['special_variable'], sub {
my $C = shift;
$C->special_variable
})
},
sub {
my $C=shift;
if (($C) = ($C->_SUBSUMEr(['sigil'], sub {
my $C = shift;
$C->sigil
}))
and ($C) = ($C->_SUBSUMEr(['index'], sub {
my $C = shift;
$C->decint
}))) {
$C->_OPTr(sub {
my $C=shift;
if (my ($C) = ($C->_BRACKETr(sub {
my $C=shift;
if (($C) = ($C->before(sub {
my $C=shift;
(($C) x !!do {
$::IN_DECL })
}))
and ($C) = ($C->panic("Can't declare a numeric variable"))) {
$C
} else { () }
}))) { ($C) } else { () }
})
} else { () }
},
sub {
my $C=shift;
if (($C) = ($C->_SUBSUMEr(['sigil'], sub {
my $C = shift;
$C->sigil
}))
and ($C) = ($C->before(sub {
my $C=shift;
if (my ($C) = ($C->before(sub {
my $C=shift;
$C->_EXACT("\<")
}))) { ($C) } else { () }
}))
and ($C) = ($C->_SUBSUMEr(['postcircumfix'], sub {
my $C = shift;
$C->postcircumfix
}))) {
$C->_OPTr(sub {
my $C=shift;
if (my ($C) = ($C->_BRACKETr(sub {
my $C=shift;
if (($C) = ($C->before(sub {
my $C=shift;
(($C) x !!do {
$::IN_DECL })
}))
and ($C) = ($C->panic("Can't declare a match variable"))) {
$C
} else { () }
}))) { ($C) } else { () }
})
} else { () }
},
sub {
my $C=shift;
if (($C) = ($C->_SUBSUMEr(['sigil'], sub {
my $C = shift;
$C->sigil
}))
and ($C) = ($C->before(sub {
my $C=shift;
if (my ($C) = ($C->before(sub {
my $C=shift;
$C->_EXACT("\(")
}))) { ($C) } else { () }
}))
and ($C) = ($C->_SUBSUMEr(['postcircumfix'], sub {
my $C = shift;
$C->postcircumfix
}))) {
$C->_OPTr(sub {
my $C=shift;
if (my ($C) = ($C->_BRACKETr(sub {
my $C=shift;
if (($C) = ($C->before(sub {
my $C=shift;
(($C) x !!do {
$::IN_DECL })
}))
and ($C) = ($C->panic("Can't declare a contextualizer"))) {
$C
} else { () }
}))) { ($C) } else { () }
})
} else { () }
},
sub {
my $C=shift;
if (($C) = ($C->_SUBSUMEr(['sigil'], sub {
my $C = shift;
$C->sigil
}))
and ($C) = ($C->before(sub {
my $C=shift;
(($C) x !!do {
$::IN_DECL })
}))) {
$C
} else { () }
},
sub {
my $C=shift;
if (my ($C) = ($C->before(sub {
my $C=shift;
$C
}))) {
scalar(do {
{
if ($::QSIGIL) {
return ()}
else {
$C->sorry("Non-declarative sigil is missing its name")}}}, $C)
} else { () }
}
)[$try])->($C);
last if @gather;
last if $xact->[-2];  # committed?
}
@gather;
};
}))) { ($C) } else { () }

}
};
@gather;
}
}))
and ($C) = (scalar(do {
my $M = $C;
my $t = $M->{'twigil'};
$twigil = $t->[0]->Str if @$t;
}, $C))) {
$C->_OPTr(sub {
my $C=shift;
if (my ($C) = ($C->_BRACKETr(sub {
my $C=shift;
if (($C) = ($C->before(sub {
my $C=shift;
(($C) x !!do {
$twigil eq '.' })
}))
and ($C) = ($C->_BRACKETr(sub {
my $C=shift;
do {
my ($tag, $try);
my @try;
my $relex;

my $fate;
my $x;
if ($fate = $C->{'_fate'} and $fate->[1] eq 'variable_3') {
$C->deb("Fate passed to variable_3: ", ::fatestr($fate)) if $::DEBUG & DEBUG::fates;
($C->{'_fate'}, $tag, $try) = @$fate;
@try = ($try);
$x = 'ALT variable_3';    # some outer ltm is controlling us
}
else {
$x = 'ALTLTM variable_3'; # we are top level ltm
}
my $C = $C->cursor_xact($x);
my $xact = $C->{_xact};

my @gather = ();
for (;;) {
unless (@try) {
$relex //= $C->cursor_fate('STD::P6', 'variable_3', $retree);
@try = $relex->($C) or last;
}
$try = shift(@try) // next;

if (ref $try) {
($C->{'_fate'}, $tag, $try) = @$try;   # next candidate fate
}

$C->deb("variable_3 trying $tag $try") if $::DEBUG & DEBUG::try_processing;
push @gather, ((
sub {
my $C=shift;
if (my ($C) = ($C->unsp)) { ($C) } else { () }
},
sub {
my $C=shift;
$C->_EXACT("\\")
},
sub {
my $C=shift;
if (my ($C) = ($C->before(sub {
my $C=shift;
$C
}))) { ($C) } else { () }
}
)[$try])->($C);
last if @gather;
last if $xact->[-2];  # committed?
}
@gather;
};
}))
and ($C) = ($C->before(sub {
my $C=shift;
if (my ($C) = ($C->before(sub {
my $C=shift;
$C->_EXACT("\(")
}))) { ($C) } else { () }
}))) {
$C->_SUBSUMEr(['postcircumfix'], sub {
my $C = shift;
$C->postcircumfix
})
} else { () }
}))) { ($C) } else { () }
})
} else { () }

});
}
;
## token deflongname {
sub deflongname__PEEK { $_[0]->_AUTOLEXpeek('deflongname', $retree) }
sub deflongname {
no warnings 'recursion';
my $self = shift;


local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;

my $C = $self->cursor_xact("RULE deflongname");
my $xact = $C->xact;
my $S = $C->{'_pos'};
$C->{'colonpair'} = [];
$self->_MATCHIFYr($S, "deflongname", do {
my $C = $C;
if (($C) = ($C->_SUBSUMEr(['name'], sub {
my $C = shift;
$C->name
}))
and ($C) = ($C->_BRACKETr(sub {
my $C=shift;
do {
my ($tag, $try);
my @try;
my $relex;

my $fate;
my $x;
if ($fate = $C->{'_fate'} and $fate->[1] eq 'deflongname_0') {
$C->deb("Fate passed to deflongname_0: ", ::fatestr($fate)) if $::DEBUG & DEBUG::fates;
($C->{'_fate'}, $tag, $try) = @$fate;
@try = ($try);
$x = 'ALT deflongname_0';    # some outer ltm is controlling us
}
else {
$x = 'ALTLTM deflongname_0'; # we are top level ltm
}
my $C = $C->cursor_xact($x);
my $xact = $C->{_xact};

my @gather = ();
for (;;) {
unless (@try) {
$relex //= $C->cursor_fate('STD::P6', 'deflongname_0', $retree);
@try = $relex->($C) or last;
}
$try = shift(@try) // next;

if (ref $try) {
($C->{'_fate'}, $tag, $try) = @$try;   # next candidate fate
}

$C->deb("deflongname_0 trying $tag $try") if $::DEBUG & DEBUG::try_processing;
push @gather, ((
sub {
my $C=shift;
if (my ($C) = ($C->_PLUSr(sub {
my $C=shift;
$C->_SUBSUMEr(['colonpair'], sub {
my $C = shift;
$C->colonpair
})
}))) {
scalar(do {
$C->add_categorical(substr($::ORIG, $self->{'_pos'}, $C->{'_pos'} - $self->{'_pos'})) if $::IN_DECL}, $C)
} else { () }
},
sub {
my $C=shift;
scalar(do {
my $M = $C;
$C->add_routine($M->{'name'}->Str) if $::IN_DECL}, $C)
}
)[$try])->($C);
last if @gather;
last if $xact->[-2];  # committed?
}
@gather;
};
}))) {
$C
} else { () }

});
}
;
## token subshortname {
sub subshortname__PEEK { $_[0]->_AUTOLEXpeek('subshortname', $retree) }
sub subshortname {
no warnings 'recursion';
my $self = shift;


local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;

my $C = $self->cursor_xact("RULE subshortname");
my $xact = $C->xact;
my $S = $C->{'_pos'};
$C->{'colonpair'} = [];
$self->_MATCHIFYr($S, "subshortname", $C->_BRACKETr(sub {
my $C=shift;
do {
my ($tag, $try);
my @try;
my $relex;

my $fate;
my $x;
if ($fate = $C->{'_fate'} and $fate->[1] eq 'subshortname_0') {
$C->deb("Fate passed to subshortname_0: ", ::fatestr($fate)) if $::DEBUG & DEBUG::fates;
($C->{'_fate'}, $tag, $try) = @$fate;
@try = ($try);
$x = 'ALT subshortname_0';    # some outer ltm is controlling us
}
else {
$x = 'ALTLTM subshortname_0'; # we are top level ltm
}
my $C = $C->cursor_xact($x);
my $xact = $C->{_xact};

my @gather = ();
for (;;) {
unless (@try) {
$relex //= $C->cursor_fate('STD::P6', 'subshortname_0', $retree);
@try = $relex->($C) or last;
}
$try = shift(@try) // next;

if (ref $try) {
($C->{'_fate'}, $tag, $try) = @$try;   # next candidate fate
}

$C->deb("subshortname_0 trying $tag $try") if $::DEBUG & DEBUG::try_processing;
push @gather, ((
sub {
my $C=shift;
if (my ($C) = ($C->_SUBSUMEr(['category'], sub {
my $C = shift;
$C->category
}))) {
$C->_PLUSr(sub {
my $C=shift;
$C->_SUBSUMEr(['colonpair'], sub {
my $C = shift;
$C->colonpair
})
})
} else { () }
},
sub {
my $C=shift;
$C->_SUBSUMEr(['desigilname'], sub {
my $C = shift;
$C->desigilname
})
}
)[$try])->($C);
last if @gather;
last if $xact->[-2];  # committed?
}
@gather;
};
}));
}
;
## token sublongname {
sub sublongname__PEEK { $_[0]->_AUTOLEXpeek('sublongname', $retree) }
sub sublongname {
no warnings 'recursion';
my $self = shift;


local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;

my $C = $self->cursor_xact("RULE sublongname");
my $xact = $C->xact;
my $S = $C->{'_pos'};
$C->{'sigterm'} = [];
$self->_MATCHIFYr($S, "sublongname", do {
if (my ($C) = ($C->_SUBSUMEr(['subshortname'], sub {
my $C = shift;
$C->subshortname
}))) {
$C->_OPTr(sub {
my $C=shift;
$C->_SUBSUMEr(['sigterm'], sub {
my $C = shift;
$C->sigterm
})
})
} else { () }

});
}
;
## token value:quote   { <quote> }
sub value__S_135quote__PEEK { $_[0]->_AUTOLEXpeek('value__S_135quote', $retree) }
sub value__S_135quote {
no warnings 'recursion';
my $self = shift;


local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;

my $C = $self->cursor_xact("RULE value__S_135quote");
my $xact = $C->xact;
my $S = $C->{'_pos'};
$C->{sym} = "quote";
$self->_MATCHIFYr($S, "value__S_135quote", $C->_SUBSUMEr(['quote'], sub {
my $C = shift;
$C->quote
}));
}
;
## token value:number  { <number> }
sub value__S_136number__PEEK { $_[0]->_AUTOLEXpeek('value__S_136number', $retree) }
sub value__S_136number {
no warnings 'recursion';
my $self = shift;


local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;

my $C = $self->cursor_xact("RULE value__S_136number");
my $xact = $C->xact;
my $S = $C->{'_pos'};
$C->{sym} = "number";
$self->_MATCHIFYr($S, "value__S_136number", $C->_SUBSUMEr(['number'], sub {
my $C = shift;
$C->number
}));
}
;
## token value:version { <version> }
sub value__S_137version__PEEK { $_[0]->_AUTOLEXpeek('value__S_137version', $retree) }
sub value__S_137version {
no warnings 'recursion';
my $self = shift;


local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;

my $C = $self->cursor_xact("RULE value__S_137version");
my $xact = $C->xact;
my $S = $C->{'_pos'};
$C->{sym} = "version";
$self->_MATCHIFYr($S, "value__S_137version", $C->_SUBSUMEr(['version'], sub {
my $C = shift;
$C->version
}));
}
;
## token typename {
sub typename__PEEK { $_[0]->_AUTOLEXpeek('typename', $retree) }
sub typename {
no warnings 'recursion';
my $self = shift;


local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;

my $C = $self->cursor_xact("RULE typename");
my $xact = $C->xact;
my $S = $C->{'_pos'};
$C->{'param'} = [];
$C->{'typename'} = [];
$C->{'whence'} = [];
$self->_MATCHIFYr($S, "typename", do {
my $C = $C;
if (($C) = ($C->_BRACKETr(sub {
my $C=shift;
do {
my ($tag, $try);
my @try;
my $relex;

my $fate;
my $x;
if ($fate = $C->{'_fate'} and $fate->[1] eq 'typename_0') {
$C->deb("Fate passed to typename_0: ", ::fatestr($fate)) if $::DEBUG & DEBUG::fates;
($C->{'_fate'}, $tag, $try) = @$fate;
@try = ($try);
$x = 'ALT typename_0';    # some outer ltm is controlling us
}
else {
$x = 'ALTLTM typename_0'; # we are top level ltm
}
my $C = $C->cursor_xact($x);
my $xact = $C->{_xact};

my @gather = ();
for (;;) {
unless (@try) {
$relex //= $C->cursor_fate('STD::P6', 'typename_0', $retree);
@try = $relex->($C) or last;
}
$try = shift(@try) // next;

if (ref $try) {
($C->{'_fate'}, $tag, $try) = @$try;   # next candidate fate
}

$C->deb("typename_0 trying $tag $try") if $::DEBUG & DEBUG::try_processing;
push @gather, ((
sub {
my $C=shift;
if (my ($C) = ($C->_EXACT("\:\:\?"))) {
$C->_SUBSUMEr(['identifier'], sub {
my $C = shift;
$C->identifier
})
} else { () }
},
sub {
my $C=shift;
if (($C) = ($C->_SUBSUMEr(['longname'], sub {
my $C = shift;
$C->longname
}))
and ($C) = ($C->before(sub {
my $C=shift;
(($C) x !!do {
my $M = $C;
{
my $longname = $M->{'longname'}->Str;
if (substr($longname, 0, 2) eq '::') {
$C->add_my_name(substr($longname, 2))}
else {
$C->is_name($longname)
};
}})
}))) {
$C
} else { () }
}
)[$try])->($C);
last if @gather;
last if $xact->[-2];  # committed?
}
@gather;
};
}))
and ($C) = ($C->_OPTr(sub {
my $C=shift;
if (my ($C) = ($C->unsp)) { ($C) } else { () }
}))
and ($C) = ($C->_OPTr(sub {
my $C=shift;
if (my ($C) = ($C->_BRACKETr(sub {
my $C=shift;
if (my ($C) = ($C->before(sub {
my $C=shift;
if (my ($C) = ($C->before(sub {
my $C=shift;
$C->_EXACT("\[")
}))) { ($C) } else { () }
}))) {
$C->_SUBSUMEr(['param'], sub {
my $C = shift;
$C->postcircumfix
})
} else { () }
}))) { ($C) } else { () }
}))
and ($C) = ($C->_OPTr(sub {
my $C=shift;
if (my ($C) = ($C->unsp)) { ($C) } else { () }
}))
and ($C) = ($C->_OPTr(sub {
my $C=shift;
if (my ($C) = ($C->_BRACKETr(sub {
my $C=shift;
if (my ($C) = ($C->before(sub {
my $C=shift;
if (my ($C) = ($C->before(sub {
my $C=shift;
$C->_EXACT("\{")
}))) { ($C) } else { () }
}))) {
$C->_SUBSUMEr(['whence'], sub {
my $C = shift;
$C->postcircumfix
})
} else { () }
}))) { ($C) } else { () }
}))) {
$C->_OPTr(sub {
my $C=shift;
if (my ($C) = ($C->_BRACKETr(sub {
my $C=shift;
if (($C) = ($C->ws)
and ($C) = ($C->_EXACT("of"))
and ($C) = ($C->ws)) {
$C->_SUBSUMEr(['typename'], sub {
my $C = shift;
$C->typename
})
} else { () }
}))) { ($C) } else { () }
})
} else { () }

});
}
;
## token number {
sub number__PEEK { $_[0]->_AUTOLEXpeek('number', $retree) }
sub number {
no warnings 'recursion';
my $self = shift;


local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;

my $C = $self->cursor_xact("RULE number");
my $xact = $C->xact;
my $S = $C->{'_pos'};
$self->_MATCHIFYr($S, "number", $C->_BRACKETr(sub {
my $C=shift;
do {
my ($tag, $try);
my @try;
my $relex;

my $fate;
my $x;
if ($fate = $C->{'_fate'} and $fate->[1] eq 'number_0') {
$C->deb("Fate passed to number_0: ", ::fatestr($fate)) if $::DEBUG & DEBUG::fates;
($C->{'_fate'}, $tag, $try) = @$fate;
@try = ($try);
$x = 'ALT number_0';    # some outer ltm is controlling us
}
else {
$x = 'ALTLTM number_0'; # we are top level ltm
}
my $C = $C->cursor_xact($x);
my $xact = $C->{_xact};

my @gather = ();
for (;;) {
unless (@try) {
$relex //= $C->cursor_fate('STD::P6', 'number_0', $retree);
@try = $relex->($C) or last;
}
$try = shift(@try) // next;

if (ref $try) {
($C->{'_fate'}, $tag, $try) = @$try;   # next candidate fate
}

$C->deb("number_0 trying $tag $try") if $::DEBUG & DEBUG::try_processing;
push @gather, ((
sub {
my $C=shift;
$C->_PATTERN(qr/\GNaN\b/)
},
sub {
my $C=shift;
$C->_SUBSUMEr(['integer'], sub {
my $C = shift;
$C->integer
})
},
sub {
my $C=shift;
$C->_SUBSUMEr(['dec_number'], sub {
my $C = shift;
$C->dec_number
})
},
sub {
my $C=shift;
$C->_SUBSUMEr(['rad_number'], sub {
my $C = shift;
$C->rad_number
})
},
sub {
my $C=shift;
$C->_PATTERN(qr/\GInf\b/)
}
)[$try])->($C);
last if @gather;
last if $xact->[-2];  # committed?
}
@gather;
};
}));
}
;
## token strtonum:rational { <[+\-]>?<nu=.integer>'/'<de=.integer> }
sub strtonum__S_138rational__PEEK { $_[0]->_AUTOLEXpeek('strtonum__S_138rational', $retree) }
sub strtonum__S_138rational {
no warnings 'recursion';
my $self = shift;


local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;

my $C = $self->cursor_xact("RULE strtonum__S_138rational");
my $xact = $C->xact;
my $S = $C->{'_pos'};
$C->{sym} = "rational";
$self->_MATCHIFYr($S, "strtonum__S_138rational", do {
my $C = $C;
if (($C) = ($C->_PATTERN(qr/\G(?:[+\-])?+/))
and ($C) = ($C->_SUBSUMEr(['nu'], sub {
my $C = shift;
$C->integer
}))
and ($C) = ($C->_EXACT("\/"))) {
$C->_SUBSUMEr(['de'], sub {
my $C = shift;
$C->integer
})
} else { () }

});
}
;
## token strtonum:complex { [<[+\-]>?<re=.number>]? <[+\-]><im=.number>'\\'?'i' }
sub strtonum__S_139complex__PEEK { $_[0]->_AUTOLEXpeek('strtonum__S_139complex', $retree) }
sub strtonum__S_139complex {
no warnings 'recursion';
my $self = shift;


local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;

my $C = $self->cursor_xact("RULE strtonum__S_139complex");
my $xact = $C->xact;
my $S = $C->{'_pos'};
$C->{'re'} = [];
$C->{sym} = "complex";
$self->_MATCHIFYr($S, "strtonum__S_139complex", do {
my $C = $C;
if (($C) = ($C->_OPTr(sub {
my $C=shift;
if (my ($C) = ($C->_BRACKETr(sub {
my $C=shift;
if (my ($C) = ($C->_PATTERN(qr/\G(?:[+\-])?+/))) {
$C->_SUBSUMEr(['re'], sub {
my $C = shift;
$C->number
})
} else { () }
}))) { ($C) } else { () }
}))
and ($C) = ($C->_PATTERN(qr/\G[+\-]/))
and ($C) = ($C->_SUBSUMEr(['im'], sub {
my $C = shift;
$C->number
}))) {
$C->_PATTERN(qr/\G\\?+i/)
} else { () }

});
}
;
## token strtonum:number { <[+\-]>?<number> }
sub strtonum__S_140number__PEEK { $_[0]->_AUTOLEXpeek('strtonum__S_140number', $retree) }
sub strtonum__S_140number {
no warnings 'recursion';
my $self = shift;


local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;

my $C = $self->cursor_xact("RULE strtonum__S_140number");
my $xact = $C->xact;
my $S = $C->{'_pos'};
$C->{sym} = "number";
$self->_MATCHIFYr($S, "strtonum__S_140number", do {
if (my ($C) = ($C->_PATTERN(qr/\G(?:[+\-])?+/))) {
$C->_SUBSUMEr(['number'], sub {
my $C = shift;
$C->number
})
} else { () }

});
}
;
## token sibble ($l, $lang2) {
sub sibble__PEEK { $_[0]->_AUTOLEXpeek('sibble', $retree) }
sub sibble {
no warnings 'recursion';
my $self = shift;

die 'Required argument l omitted' unless @_;
my $l = @_ ? shift() : undef;
die 'Required argument lang2 omitted' unless @_;
my $lang2 = @_ ? shift() : undef;
my ($lang, $start, $stop);
local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;

my $C = $self->cursor_xact("RULE sibble");
my $xact = $C->xact;
my $S = $C->{'_pos'};
$self->_MATCHIFYr($S, "sibble", do {
my $C = $C;
if (($C) = ($C->_SUBSUMEr(['babble'], sub {
my $C = shift;
$C->babble($l)
}))
and ($C) = (scalar(do {
my $M = $C;
my $B = $M->{'babble'}->{'B'};
($lang,$start,$stop) = @$B;
}, $C))
and ($C) = ($C->_EXACT($start))
and ($C) = ($C->_SUBSUMEr(['left'], sub {
my $C = shift;
$C->nibble($lang)
}))
and ($C) = ($C->_BRACKETr(sub {
my $C=shift;
do {    my $C = $C->cursor_xact('ALT ||');
my $xact = $C->xact;
my @gather;
do {
push @gather, do {
if (my ($C) = ($C->_EXACT($stop))) { ($C) } else { () }

}
}
or $xact->[-2] or
do {
push @gather, do {
if (my ($C) = ($C->panic("Couldn't find terminator $stop"))) { ($C) } else { () }

}
};
@gather;
}
}))
and ($C) = ($C->_BRACKETr(sub {
my $C=shift;
do {    my $C = $C->cursor_xact('ALT ||');
my $xact = $C->xact;
my @gather;
do {
push @gather, do {
my $C = $C;
if (($C) = ($C->before(sub {
my $C=shift;
(($C) x !!do {
$start ne $stop })
}))
and ($C) = ($C->ws)
and ($C) = ($C->_BRACKETr(sub {
my $C=shift;
do {    my $C = $C->cursor_xact('ALT ||');
my $xact = $C->xact;
my @gather;
do {
push @gather, $C->_SUBSUMEr(['infixish'], sub {
my $C = shift;
$C->infixish
})
}
or $xact->[-2] or
do {
push @gather, $C->_SUBSUMEr(['panic'], sub {
my $C = shift;
$C->panic("Missing assignment operator")
})
};
@gather;
}
}))
and ($C) = ($C->_BRACKETr(sub {
my $C=shift;
do {    my $C = $C->cursor_xact('ALT ||');
my $xact = $C->xact;
my @gather;
do {
push @gather, do {
if (my ($C) = ($C->before(sub {
my $C=shift;
(($C) x !!do {
my $M = $C;
$M->{'infixish'}->Str eq '=' || $M->{'infixish'}->{'infix_postfix_meta_operator'} })
}))) { ($C) } else { () }

}
}
or $xact->[-2] or
do {
push @gather, do {
if (my ($C) = ($C->panic("Malformed assignment operator"))) { ($C) } else { () }

}
};
@gather;
}
}))
and ($C) = ($C->ws)) {
$C->_SUBSUMEr(['right','EXPR'], sub {
my $C = shift;
$C->EXPR(\%item_assignment)
})
} else { () }

}
}
or $xact->[-2] or
do {
push @gather, do {
my $C = $C;
if (($C) = (scalar(do {
$lang = $lang2->unbalanced($stop)}, $C))
and ($C) = ($C->_SUBSUMEr(['right'], sub {
my $C = shift;
$C->nibble($lang)
}))
and ($C) = ($C->_EXACT($stop))) {
$C
} else { () }

}
}
or $xact->[-2] or
do {
push @gather, do {
if (my ($C) = ($C->panic("Malformed replacement part; couldn't find final $stop"))) { ($C) } else { () }

}
};
@gather;
}
}))) {
$C
} else { () }

});
}
;
## token tribble ($l, $lang2 = $l) {
sub tribble__PEEK { $_[0]->_AUTOLEXpeek('tribble', $retree) }
sub tribble {
no warnings 'recursion';
my $self = shift;

die 'Required argument l omitted' unless @_;
my $l = @_ ? shift() : undef;
my $lang2 = @_ ? shift() : $l;
my ($lang, $start, $stop);local $::CCSTATE = '';
local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;

my $C = $self->cursor_xact("RULE tribble");
my $xact = $C->xact;
my $S = $C->{'_pos'};
$self->_MATCHIFYr($S, "tribble", do {
my $C = $C;
if (($C) = ($C->_SUBSUMEr(['babble'], sub {
my $C = shift;
$C->babble($l)
}))
and ($C) = (scalar(do {
my $M = $C;
my $B = $M->{'babble'}->{'B'};
($lang,$start,$stop) = @$B;
}, $C))
and ($C) = ($C->_EXACT($start))
and ($C) = ($C->_SUBSUMEr(['left'], sub {
my $C = shift;
$C->nibble($lang)
}))
and ($C) = ($C->_BRACKETr(sub {
my $C=shift;
do {    my $C = $C->cursor_xact('ALT ||');
my $xact = $C->xact;
my @gather;
do {
push @gather, do {
if (my ($C) = ($C->_EXACT($stop))) { ($C) } else { () }

}
}
or $xact->[-2] or
do {
push @gather, do {
if (my ($C) = ($C->panic("Couldn't find terminator $stop"))) { ($C) } else { () }

}
};
@gather;
}
}))
and ($C) = (scalar(do {
$::CCSTATE = ''}, $C))
and ($C) = ($C->_BRACKETr(sub {
my $C=shift;
do {    my $C = $C->cursor_xact('ALT ||');
my $xact = $C->xact;
my @gather;
do {
push @gather, do {
my $C = $C;
if (($C) = ($C->before(sub {
my $C=shift;
(($C) x !!do {
$start ne $stop })
}))
and ($C) = ($C->ws)) {
$C->_SUBSUMEr(['quibble'], sub {
my $C = shift;
$C->quibble($lang2)
})
} else { () }

}
}
or $xact->[-2] or
do {
push @gather, do {
my $C = $C;
if (($C) = (scalar(do {
$lang = $lang2->unbalanced($stop)}, $C))
and ($C) = ($C->_SUBSUMEr(['right'], sub {
my $C = shift;
$C->nibble($lang)
}))
and ($C) = ($C->_EXACT($stop))) {
$C
} else { () }

}
}
or $xact->[-2] or
do {
push @gather, do {
if (my ($C) = ($C->panic("Malformed replacement part; couldn't find final $stop"))) { ($C) } else { () }

}
};
@gather;
}
}))) {
$C
} else { () }

});
}
;
## token quasiquibble ($l) {
sub quasiquibble__PEEK { $_[0]->_AUTOLEXpeek('quasiquibble', $retree) }
sub quasiquibble {
no warnings 'recursion';
my $self = shift;

die 'Required argument l omitted' unless @_;
my $l = @_ ? shift() : undef;
local %::LANG = %::LANG;my ($lang, $start, $stop);local $::QUASIMODO = 0;
local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;

my $C = $self->cursor_xact("RULE quasiquibble");
my $xact = $C->xact;
my $S = $C->{'_pos'};
$self->_MATCHIFYr($S, "quasiquibble", do {
my $C = $C;
if (($C) = ($C->_SUBSUMEr(['babble'], sub {
my $C = shift;
$C->babble($l)
}))
and ($C) = (scalar(do {
my $M = $C;
my $B = $M->{'babble'}->{'B'};
($lang,$start,$stop) = @$B;
$::LANG{'MAIN'} = $lang;
}, $C))
and ($C) = ($C->_BRACKETr(sub {
my $C=shift;
do {    my $C = $C->cursor_xact('ALT ||');
my $xact = $C->xact;
my @gather;
do {
push @gather, do {
my $C = $C;
if (($C) = ($C->before(sub {
my $C=shift;
(($C) x !!do {
$start eq '{' })
}))
and ($C) = ($C->_BRACKETr(sub {
my $C=shift;
my $newlang = ($lang);
$C = bless($C, (ref($newlang) || $newlang));
$C->_SUBSUMEr(['block'], sub {
my $C = shift;
$C->block
})
}))) {
$C
} else { () }

}
}
or $xact->[-2] or
do {
push @gather, do {
if (my ($C) = ($C->_BRACKETr(sub {
my $C=shift;
my $newlang = ($lang);
$C = bless($C, (ref($newlang) || $newlang));
do {
my $C = $C;
if (($C) = ($C->_SUBSUMEr(['starter'], sub {
my $C = shift;
$C->starter
}))
and ($C) = ($C->_SUBSUMEr(['statementlist'], sub {
my $C = shift;
$C->statementlist
}))
and ($C) = ($C->_BRACKETr(sub {
my $C=shift;
do {    my $C = $C->cursor_xact('ALT ||');
my $xact = $C->xact;
my @gather;
do {
push @gather, $C->_SUBSUMEr(['stopper'], sub {
my $C = shift;
$C->stopper
})
}
or $xact->[-2] or
do {
push @gather, do {
if (my ($C) = ($C->panic("Couldn't find terminator $stop"))) { ($C) } else { () }

}
};
@gather;
}
}))) {
$C
} else { () }

}
}))) { ($C) } else { () }

}
};
@gather;
}
}))) {
$C
} else { () }

});
}
;
## token quote:sym<//>   {
sub quote__S_141SlashSlash__PEEK { $_[0]->_AUTOLEXpeek('quote__S_141SlashSlash', $retree) }
sub quote__S_141SlashSlash {
no warnings 'recursion';
my $self = shift;


local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;

my $C = $self->cursor_xact("RULE quote__S_141SlashSlash");
my $xact = $C->xact;
my $S = $C->{'_pos'};
$C->{sym} = "\/\/";
$self->_MATCHIFYr($S, "quote__S_141SlashSlash", do {
my $C = $C;
if (($C) = ($C->_PATTERN(qr/\G\/\s*+\//))
and ($C) = ($C->sorry("Null regex not allowed"))) {
$C
} else { () }

});
}
;
## token quote:sym</ />   {
sub quote__S_142Slash_Slash__PEEK { $_[0]->_AUTOLEXpeek('quote__S_142Slash_Slash', $retree) }
sub quote__S_142Slash_Slash {
no warnings 'recursion';
my $self = shift;


local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;

my $C = $self->cursor_xact("RULE quote__S_142Slash_Slash");
my $xact = $C->xact;
my $S = $C->{'_pos'};
$C->{sym} = "\/\ \/";
$self->_MATCHIFYr($S, "quote__S_142Slash_Slash", do {
my $C = $C;
if (($C) = ($C->_EXACT("\/"))
and ($C) = ($C->_SUBSUMEr(['nibble'], sub {
my $C = shift;
$C->nibble( $C->cursor_fresh( $::LANG{'Regex'} )->unbalanced("/") )
}))
and ($C) = ($C->_BRACKETr(sub {
my $C=shift;
do {    my $C = $C->cursor_xact('ALT ||');
my $xact = $C->xact;
my @gather;
do {
push @gather, $C->_EXACT("\/")
}
or $xact->[-2] or
do {
push @gather, do {
if (my ($C) = ($C->panic("Unable to parse regex; couldn't find final '/'"))) { ($C) } else { () }

}
};
@gather;
}
}))) {
$C->_OPTr(sub {
my $C=shift;
if (my ($C) = ($C->old_rx_mods)) { ($C) } else { () }
})
} else { () }

});
}
;
## token quote:qq {
sub quote__S_143qq__PEEK { $_[0]->_AUTOLEXpeek('quote__S_143qq', $retree) }
sub quote__S_143qq {
no warnings 'recursion';
my $self = shift;

my $qm;
local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;

my $C = $self->cursor_xact("RULE quote__S_143qq");
my $xact = $C->xact;
my $S = $C->{'_pos'};
$C->{sym} = "qq";
$self->_MATCHIFYr($S, "quote__S_143qq", do {
my $C = $C;
if (($C) = ($C->_EXACT("qq"))
and ($C) = ($C->_BRACKETr(sub {
my $C=shift;
do {
my ($tag, $try);
my @try;
my $relex;

my $fate;
my $x;
if ($fate = $C->{'_fate'} and $fate->[1] eq 'quote__S_143qq_0') {
$C->deb("Fate passed to quote__S_143qq_0: ", ::fatestr($fate)) if $::DEBUG & DEBUG::fates;
($C->{'_fate'}, $tag, $try) = @$fate;
@try = ($try);
$x = 'ALT quote__S_143qq_0';    # some outer ltm is controlling us
}
else {
$x = 'ALTLTM quote__S_143qq_0'; # we are top level ltm
}
my $C = $C->cursor_xact($x);
my $xact = $C->{_xact};

my @gather = ();
for (;;) {
unless (@try) {
$relex //= $C->cursor_fate('STD::P6', 'quote__S_143qq_0', $retree);
@try = $relex->($C) or last;
}
$try = shift(@try) // next;

if (ref $try) {
($C->{'_fate'}, $tag, $try) = @$try;   # next candidate fate
}

$C->deb("quote__S_143qq_0 trying $tag $try") if $::DEBUG & DEBUG::try_processing;
push @gather, ((
sub {
my $C=shift;
if (($C) = ($C->_SUBSUMEr(['quote_mod'], sub {
my $C = shift;
$C->quote_mod
}))
and ($C) = ($C->_PATTERN(qr/\G\b/))
and ($C) = ($C->_NOTBEFORE(sub {
my $C=shift;
if (my ($C) = ($C->before(sub {
my $C=shift;
$C->_EXACT("\(")
}))) { ($C) } else { () }
}))
and ($C) = (scalar(do {
my $M = $C;
$qm = $M->{'quote_mod'}->Str }, $C))
and ($C) = ($C->ws)) {
$C->_SUBSUMEr(['quibble'], sub {
my $C = shift;
$C->quibble($C->cursor_fresh( $::LANG{'Q'} )->tweak('qq' => 1)->tweak($qm => 1))
})
} else { () }
},
sub {
my $C=shift;
if (($C) = ($C->_PATTERN(qr/\G\b/))
and ($C) = ($C->_NOTBEFORE(sub {
my $C=shift;
if (my ($C) = ($C->before(sub {
my $C=shift;
$C->_EXACT("\(")
}))) { ($C) } else { () }
}))
and ($C) = ($C->ws)) {
$C->_SUBSUMEr(['quibble'], sub {
my $C = shift;
$C->quibble($C->cursor_fresh( $::LANG{'Q'} )->tweak('qq' => 1))
})
} else { () }
}
)[$try])->($C);
last if @gather;
last if $xact->[-2];  # committed?
}
@gather;
};
}))) {
$C
} else { () }

});
}
;
## token quote:q {
sub quote__S_144q__PEEK { $_[0]->_AUTOLEXpeek('quote__S_144q', $retree) }
sub quote__S_144q {
no warnings 'recursion';
my $self = shift;

my $qm;
local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;

my $C = $self->cursor_xact("RULE quote__S_144q");
my $xact = $C->xact;
my $S = $C->{'_pos'};
$C->{sym} = "q";
$self->_MATCHIFYr($S, "quote__S_144q", do {
my $C = $C;
if (($C) = ($C->_EXACT("q"))
and ($C) = ($C->_BRACKETr(sub {
my $C=shift;
do {
my ($tag, $try);
my @try;
my $relex;

my $fate;
my $x;
if ($fate = $C->{'_fate'} and $fate->[1] eq 'quote__S_144q_0') {
$C->deb("Fate passed to quote__S_144q_0: ", ::fatestr($fate)) if $::DEBUG & DEBUG::fates;
($C->{'_fate'}, $tag, $try) = @$fate;
@try = ($try);
$x = 'ALT quote__S_144q_0';    # some outer ltm is controlling us
}
else {
$x = 'ALTLTM quote__S_144q_0'; # we are top level ltm
}
my $C = $C->cursor_xact($x);
my $xact = $C->{_xact};

my @gather = ();
for (;;) {
unless (@try) {
$relex //= $C->cursor_fate('STD::P6', 'quote__S_144q_0', $retree);
@try = $relex->($C) or last;
}
$try = shift(@try) // next;

if (ref $try) {
($C->{'_fate'}, $tag, $try) = @$try;   # next candidate fate
}

$C->deb("quote__S_144q_0 trying $tag $try") if $::DEBUG & DEBUG::try_processing;
push @gather, ((
sub {
my $C=shift;
if (($C) = ($C->_SUBSUMEr(['quote_mod'], sub {
my $C = shift;
$C->quote_mod
}))
and ($C) = ($C->_PATTERN(qr/\G\b/))
and ($C) = ($C->_NOTBEFORE(sub {
my $C=shift;
if (my ($C) = ($C->before(sub {
my $C=shift;
$C->_EXACT("\(")
}))) { ($C) } else { () }
}))
and ($C) = (scalar(do {
my $M = $C;
$qm = $M->{'quote_mod'}->Str }, $C))) {
$C->_SUBSUMEr(['quibble'], sub {
my $C = shift;
$C->quibble($C->cursor_fresh( $::LANG{'Q'} )->tweak('q' => 1)->tweak($qm => 1))
})
} else { () }
},
sub {
my $C=shift;
if (($C) = ($C->_PATTERN(qr/\G\b/))
and ($C) = ($C->_NOTBEFORE(sub {
my $C=shift;
if (my ($C) = ($C->before(sub {
my $C=shift;
$C->_EXACT("\(")
}))) { ($C) } else { () }
}))
and ($C) = ($C->ws)) {
$C->_SUBSUMEr(['quibble'], sub {
my $C = shift;
$C->quibble($C->cursor_fresh( $::LANG{'Q'} )->tweak('q' => 1))
})
} else { () }
}
)[$try])->($C);
last if @gather;
last if $xact->[-2];  # committed?
}
@gather;
};
}))) {
$C
} else { () }

});
}
;
## token quote:Q {
sub quote__S_145Q__PEEK { $_[0]->_AUTOLEXpeek('quote__S_145Q', $retree) }
sub quote__S_145Q {
no warnings 'recursion';
my $self = shift;

my $qm;
local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;

my $C = $self->cursor_xact("RULE quote__S_145Q");
my $xact = $C->xact;
my $S = $C->{'_pos'};
$C->{sym} = "Q";
$self->_MATCHIFYr($S, "quote__S_145Q", do {
my $C = $C;
if (($C) = ($C->_EXACT("Q"))
and ($C) = ($C->_BRACKETr(sub {
my $C=shift;
do {
my ($tag, $try);
my @try;
my $relex;

my $fate;
my $x;
if ($fate = $C->{'_fate'} and $fate->[1] eq 'quote__S_145Q_0') {
$C->deb("Fate passed to quote__S_145Q_0: ", ::fatestr($fate)) if $::DEBUG & DEBUG::fates;
($C->{'_fate'}, $tag, $try) = @$fate;
@try = ($try);
$x = 'ALT quote__S_145Q_0';    # some outer ltm is controlling us
}
else {
$x = 'ALTLTM quote__S_145Q_0'; # we are top level ltm
}
my $C = $C->cursor_xact($x);
my $xact = $C->{_xact};

my @gather = ();
for (;;) {
unless (@try) {
$relex //= $C->cursor_fate('STD::P6', 'quote__S_145Q_0', $retree);
@try = $relex->($C) or last;
}
$try = shift(@try) // next;

if (ref $try) {
($C->{'_fate'}, $tag, $try) = @$try;   # next candidate fate
}

$C->deb("quote__S_145Q_0 trying $tag $try") if $::DEBUG & DEBUG::try_processing;
push @gather, ((
sub {
my $C=shift;
if (($C) = ($C->_SUBSUMEr(['quote_mod'], sub {
my $C = shift;
$C->quote_mod
}))
and ($C) = ($C->_PATTERN(qr/\G\b/))
and ($C) = ($C->_NOTBEFORE(sub {
my $C=shift;
if (my ($C) = ($C->before(sub {
my $C=shift;
$C->_EXACT("\(")
}))) { ($C) } else { () }
}))
and ($C) = (scalar(do {
my $M = $C;
$qm = $M->{'quote_mod'}->Str }, $C))) {
$C->_SUBSUMEr(['quibble'], sub {
my $C = shift;
$C->quibble($C->cursor_fresh( $::LANG{'Q'} )->tweak($qm => 1))
})
} else { () }
},
sub {
my $C=shift;
if (($C) = ($C->_PATTERN(qr/\G\b/))
and ($C) = ($C->_NOTBEFORE(sub {
my $C=shift;
if (my ($C) = ($C->before(sub {
my $C=shift;
$C->_EXACT("\(")
}))) { ($C) } else { () }
}))
and ($C) = ($C->ws)) {
$C->_SUBSUMEr(['quibble'], sub {
my $C = shift;
$C->quibble($C->cursor_fresh( $::LANG{'Q'} ))
})
} else { () }
}
)[$try])->($C);
last if @gather;
last if $xact->[-2];  # committed?
}
@gather;
};
}))) {
$C
} else { () }

});
}
;
## token quote_mod:w  { <sym> }
sub quote_mod__S_146w__PEEK { $_[0]->_AUTOLEXpeek('quote_mod__S_146w', $retree) }
sub quote_mod__S_146w {
no warnings 'recursion';
my $self = shift;


local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;

my $C = $self->cursor_xact("RULE quote_mod__S_146w");
my $xact = $C->xact;
my $S = $C->{'_pos'};
$C->{sym} = "w";
$self->_MATCHIFYr($S, "quote_mod__S_146w", $C->_EXACT("w"));
}
;
## token quote_mod:ww { <sym> }
sub quote_mod__S_147ww__PEEK { $_[0]->_AUTOLEXpeek('quote_mod__S_147ww', $retree) }
sub quote_mod__S_147ww {
no warnings 'recursion';
my $self = shift;


local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;

my $C = $self->cursor_xact("RULE quote_mod__S_147ww");
my $xact = $C->xact;
my $S = $C->{'_pos'};
$C->{sym} = "ww";
$self->_MATCHIFYr($S, "quote_mod__S_147ww", $C->_EXACT("ww"));
}
;
## token quote_mod:p  { <sym> }
sub quote_mod__S_148p__PEEK { $_[0]->_AUTOLEXpeek('quote_mod__S_148p', $retree) }
sub quote_mod__S_148p {
no warnings 'recursion';
my $self = shift;


local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;

my $C = $self->cursor_xact("RULE quote_mod__S_148p");
my $xact = $C->xact;
my $S = $C->{'_pos'};
$C->{sym} = "p";
$self->_MATCHIFYr($S, "quote_mod__S_148p", $C->_EXACT("p"));
}
;
## token quote_mod:x  { <sym> }
sub quote_mod__S_149x__PEEK { $_[0]->_AUTOLEXpeek('quote_mod__S_149x', $retree) }
sub quote_mod__S_149x {
no warnings 'recursion';
my $self = shift;


local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;

my $C = $self->cursor_xact("RULE quote_mod__S_149x");
my $xact = $C->xact;
my $S = $C->{'_pos'};
$C->{sym} = "x";
$self->_MATCHIFYr($S, "quote_mod__S_149x", $C->_EXACT("x"));
}
;
## token quote_mod:to { <sym> }
sub quote_mod__S_150to__PEEK { $_[0]->_AUTOLEXpeek('quote_mod__S_150to', $retree) }
sub quote_mod__S_150to {
no warnings 'recursion';
my $self = shift;


local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;

my $C = $self->cursor_xact("RULE quote_mod__S_150to");
my $xact = $C->xact;
my $S = $C->{'_pos'};
$C->{sym} = "to";
$self->_MATCHIFYr($S, "quote_mod__S_150to", $C->_EXACT("to"));
}
;
## token quote_mod:s  { <sym> }
sub quote_mod__S_151s__PEEK { $_[0]->_AUTOLEXpeek('quote_mod__S_151s', $retree) }
sub quote_mod__S_151s {
no warnings 'recursion';
my $self = shift;


local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;

my $C = $self->cursor_xact("RULE quote_mod__S_151s");
my $xact = $C->xact;
my $S = $C->{'_pos'};
$C->{sym} = "s";
$self->_MATCHIFYr($S, "quote_mod__S_151s", $C->_EXACT("s"));
}
;
## token quote_mod:a  { <sym> }
sub quote_mod__S_152a__PEEK { $_[0]->_AUTOLEXpeek('quote_mod__S_152a', $retree) }
sub quote_mod__S_152a {
no warnings 'recursion';
my $self = shift;


local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;

my $C = $self->cursor_xact("RULE quote_mod__S_152a");
my $xact = $C->xact;
my $S = $C->{'_pos'};
$C->{sym} = "a";
$self->_MATCHIFYr($S, "quote_mod__S_152a", $C->_EXACT("a"));
}
;
## token quote_mod:h  { <sym> }
sub quote_mod__S_153h__PEEK { $_[0]->_AUTOLEXpeek('quote_mod__S_153h', $retree) }
sub quote_mod__S_153h {
no warnings 'recursion';
my $self = shift;


local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;

my $C = $self->cursor_xact("RULE quote_mod__S_153h");
my $xact = $C->xact;
my $S = $C->{'_pos'};
$C->{sym} = "h";
$self->_MATCHIFYr($S, "quote_mod__S_153h", $C->_EXACT("h"));
}
;
## token quote_mod:f  { <sym> }
sub quote_mod__S_154f__PEEK { $_[0]->_AUTOLEXpeek('quote_mod__S_154f', $retree) }
sub quote_mod__S_154f {
no warnings 'recursion';
my $self = shift;


local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;

my $C = $self->cursor_xact("RULE quote_mod__S_154f");
my $xact = $C->xact;
my $S = $C->{'_pos'};
$C->{sym} = "f";
$self->_MATCHIFYr($S, "quote_mod__S_154f", $C->_EXACT("f"));
}
;
## token quote_mod:c  { <sym> }
sub quote_mod__S_155c__PEEK { $_[0]->_AUTOLEXpeek('quote_mod__S_155c', $retree) }
sub quote_mod__S_155c {
no warnings 'recursion';
my $self = shift;


local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;

my $C = $self->cursor_xact("RULE quote_mod__S_155c");
my $xact = $C->xact;
my $S = $C->{'_pos'};
$C->{sym} = "c";
$self->_MATCHIFYr($S, "quote_mod__S_155c", $C->_EXACT("c"));
}
;
## token quote_mod:b  { <sym> }
sub quote_mod__S_156b__PEEK { $_[0]->_AUTOLEXpeek('quote_mod__S_156b', $retree) }
sub quote_mod__S_156b {
no warnings 'recursion';
my $self = shift;


local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;

my $C = $self->cursor_xact("RULE quote_mod__S_156b");
my $xact = $C->xact;
my $S = $C->{'_pos'};
$C->{sym} = "b";
$self->_MATCHIFYr($S, "quote_mod__S_156b", $C->_EXACT("b"));
}
;
## token quote:rx {
sub quote__S_157rx__PEEK { $_[0]->_AUTOLEXpeek('quote__S_157rx', $retree) }
sub quote__S_157rx {
no warnings 'recursion';
my $self = shift;


local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;

my $C = $self->cursor_xact("RULE quote__S_157rx");
my $xact = $C->xact;
my $S = $C->{'_pos'};
$C->{sym} = "rx";
$self->_MATCHIFYr($S, "quote__S_157rx", do {
my $C = $C;
if (($C) = ($C->_PATTERN(qr/\Grx\b/))
and ($C) = ($C->_NOTBEFORE(sub {
my $C=shift;
if (my ($C) = ($C->before(sub {
my $C=shift;
$C->_EXACT("\(")
}))) { ($C) } else { () }
}))
and ($C) = ($C->_SUBSUMEr(['quibble'], sub {
my $C = shift;
$C->quibble( $C->cursor_fresh( $::LANG{'Regex'} ) )
}))
and ($C) = ($C->_NOTBEFORE(sub {
my $C=shift;
if (my ($C) = ($C->old_rx_mods)) { ($C) } else { () }
}))) {
$C
} else { () }

});
}
;
## token quote:m  {
sub quote__S_158m__PEEK { $_[0]->_AUTOLEXpeek('quote__S_158m', $retree) }
sub quote__S_158m {
no warnings 'recursion';
my $self = shift;


local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;

my $C = $self->cursor_xact("RULE quote__S_158m");
my $xact = $C->xact;
my $S = $C->{'_pos'};
$C->{sym} = "m";
$self->_MATCHIFYr($S, "quote__S_158m", do {
my $C = $C;
if (($C) = ($C->_PATTERN(qr/\Gm\b/))
and ($C) = ($C->_NOTBEFORE(sub {
my $C=shift;
if (my ($C) = ($C->before(sub {
my $C=shift;
$C->_EXACT("\(")
}))) { ($C) } else { () }
}))
and ($C) = ($C->_SUBSUMEr(['quibble'], sub {
my $C = shift;
$C->quibble( $C->cursor_fresh( $::LANG{'Regex'} ) )
}))
and ($C) = ($C->_NOTBEFORE(sub {
my $C=shift;
if (my ($C) = ($C->old_rx_mods)) { ($C) } else { () }
}))) {
$C
} else { () }

});
}
;
## token quote:mm {
sub quote__S_159mm__PEEK { $_[0]->_AUTOLEXpeek('quote__S_159mm', $retree) }
sub quote__S_159mm {
no warnings 'recursion';
my $self = shift;


local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;

my $C = $self->cursor_xact("RULE quote__S_159mm");
my $xact = $C->xact;
my $S = $C->{'_pos'};
$C->{sym} = "mm";
$self->_MATCHIFYr($S, "quote__S_159mm", do {
my $C = $C;
if (($C) = ($C->_PATTERN(qr/\Gmm\b/))
and ($C) = ($C->_NOTBEFORE(sub {
my $C=shift;
if (my ($C) = ($C->before(sub {
my $C=shift;
$C->_EXACT("\(")
}))) { ($C) } else { () }
}))
and ($C) = ($C->_SUBSUMEr(['quibble'], sub {
my $C = shift;
$C->quibble( $C->cursor_fresh( $::LANG{'Regex'} )->tweak('s' => 1))
}))
and ($C) = ($C->_NOTBEFORE(sub {
my $C=shift;
if (my ($C) = ($C->old_rx_mods)) { ($C) } else { () }
}))) {
$C
} else { () }

});
}
;
## token quote:s {
sub quote__S_160s__PEEK { $_[0]->_AUTOLEXpeek('quote__S_160s', $retree) }
sub quote__S_160s {
no warnings 'recursion';
my $self = shift;


local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;

my $C = $self->cursor_xact("RULE quote__S_160s");
my $xact = $C->xact;
my $S = $C->{'_pos'};
$C->{sym} = "s";
$self->_MATCHIFYr($S, "quote__S_160s", do {
my $C = $C;
if (($C) = ($C->_PATTERN(qr/\Gs\b/))
and ($C) = ($C->_NOTBEFORE(sub {
my $C=shift;
if (my ($C) = ($C->before(sub {
my $C=shift;
$C->_EXACT("\(")
}))) { ($C) } else { () }
}))
and ($C) = ($C->_SUBSUMEr(['pat'], sub {
my $C = shift;
$C->sibble( $C->cursor_fresh( $::LANG{'Regex'} ), $C->cursor_fresh( $::LANG{'Q'} )->tweak('qq' => 1))
}))
and ($C) = ($C->_NOTBEFORE(sub {
my $C=shift;
if (my ($C) = ($C->old_rx_mods)) { ($C) } else { () }
}))) {
$C
} else { () }

});
}
;
## token quote:ss {
sub quote__S_161ss__PEEK { $_[0]->_AUTOLEXpeek('quote__S_161ss', $retree) }
sub quote__S_161ss {
no warnings 'recursion';
my $self = shift;


local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;

my $C = $self->cursor_xact("RULE quote__S_161ss");
my $xact = $C->xact;
my $S = $C->{'_pos'};
$C->{sym} = "ss";
$self->_MATCHIFYr($S, "quote__S_161ss", do {
my $C = $C;
if (($C) = ($C->_PATTERN(qr/\Gss\b/))
and ($C) = ($C->_NOTBEFORE(sub {
my $C=shift;
if (my ($C) = ($C->before(sub {
my $C=shift;
$C->_EXACT("\(")
}))) { ($C) } else { () }
}))
and ($C) = ($C->_SUBSUMEr(['pat'], sub {
my $C = shift;
$C->sibble( $C->cursor_fresh( $::LANG{'Regex'} )->tweak('s' => 1), $C->cursor_fresh( $::LANG{'Q'} )->tweak('qq' => 1))
}))
and ($C) = ($C->_NOTBEFORE(sub {
my $C=shift;
if (my ($C) = ($C->old_rx_mods)) { ($C) } else { () }
}))) {
$C
} else { () }

});
}
;
## token quote:tr {
sub quote__S_162tr__PEEK { $_[0]->_AUTOLEXpeek('quote__S_162tr', $retree) }
sub quote__S_162tr {
no warnings 'recursion';
my $self = shift;


local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;

my $C = $self->cursor_xact("RULE quote__S_162tr");
my $xact = $C->xact;
my $S = $C->{'_pos'};
$C->{sym} = "tr";
$self->_MATCHIFYr($S, "quote__S_162tr", do {
my $C = $C;
if (($C) = ($C->_PATTERN(qr/\Gtr\b/))
and ($C) = ($C->_NOTBEFORE(sub {
my $C=shift;
if (my ($C) = ($C->before(sub {
my $C=shift;
$C->_EXACT("\(")
}))) { ($C) } else { () }
}))
and ($C) = ($C->_SUBSUMEr(['pat'], sub {
my $C = shift;
$C->tribble( $C->cursor_fresh( $::LANG{'Q'} )->tweak('cc' => 1))
}))
and ($C) = ($C->_NOTBEFORE(sub {
my $C=shift;
if (my ($C) = ($C->old_tr_mods)) { ($C) } else { () }
}))) {
$C
} else { () }

});
}
;
## token quote:y {
sub quote__S_163y__PEEK { $_[0]->_AUTOLEXpeek('quote__S_163y', $retree) }
sub quote__S_163y {
no warnings 'recursion';
my $self = shift;


local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;

my $C = $self->cursor_xact("RULE quote__S_163y");
my $xact = $C->xact;
my $S = $C->{'_pos'};
$C->{sym} = "y";
$self->_MATCHIFYr($S, "quote__S_163y", do {
my $C = $C;
if (($C) = ($C->_PATTERN(qr/\Gy\b/))
and ($C) = ($C->_NOTBEFORE(sub {
my $C=shift;
(($C) x !!do {
$self->is_known('&y') or $self->is_known('y') })
}))
and ($C) = ($C->_NOTBEFORE(sub {
my $C=shift;
if (my ($C) = ($C->before(sub {
my $C=shift;
$C->_EXACT("\(")
}))) { ($C) } else { () }
}))
and ($C) = ($C->before(sub {
my $C=shift;
if (my ($C) = ($C->before(sub {
my $C=shift;
$C->_PATTERN(qr/\G[\x20\t\r]*+\W/)
}))) { ($C) } else { () }
}))
and ($C) = ($C->obs('y///','tr///'))) {
$C
} else { () }

});
}
;
## token old_rx_mods {
sub old_rx_mods__PEEK { $_[0]->_AUTOLEXpeek('old_rx_mods', $retree) }
sub old_rx_mods {
no warnings 'recursion';
my $self = shift;


local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;

my $C = $self->cursor_xact("RULE old_rx_mods");
my $xact = $C->xact;
my $S = $C->{'_pos'};
$self->_MATCHIFYr($S, "old_rx_mods", do {
my $C = $C;
if (($C) = ($C->_NOTBEFORE(sub {
my $C=shift;
if (my ($C) = ($C->after(sub {
my $C=shift;
$C->_PATTERN(qr/\G(?<=\w)/)
}))) { ($C) } else { () }
}))
and ($C) = ($C->_SUBSUMEr(['0'], sub {
my $C = shift;
$C->_PAREN( sub {
my $C=shift;
$C->_PLUSr(sub {
my $C=shift;
if (my ($C) = ($C->_ARRAY( qw< i g s m x c e > ))) { ($C) } else { () }
})

})
}))) {
scalar(do {
my $M = $C;
{
given ($M->{0}->Str) {
$_ =~ /i/ and $C->worryobs('/i',':i');
$_ =~ /g/ and $C->worryobs('/g',':g');
$_ =~ /m/ and $C->worryobs('/m','^^ and $$ anchors');
$_ =~ /s/ and $C->worryobs('/s','. or \N');
$_ =~ /x/ and $C->worryobs('/x','normal default whitespace');
$_ =~ /c/ and $C->worryobs('/c',':c or :p');
$_ =~ /e/ and $C->worryobs('/e','interpolated {...} or s{} = ... form');
$C->obs('suffix regex modifiers','prefix adverbs');
}
}}, $C)
} else { () }

});
}
;
## token old_tr_mods {
sub old_tr_mods__PEEK { $_[0]->_AUTOLEXpeek('old_tr_mods', $retree) }
sub old_tr_mods {
no warnings 'recursion';
my $self = shift;


local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;

my $C = $self->cursor_xact("RULE old_tr_mods");
my $xact = $C->xact;
my $S = $C->{'_pos'};
$self->_MATCHIFYr($S, "old_tr_mods", do {
if (my ($C) = ($C->_SUBSUMEr(['0'], sub {
my $C = shift;
$C->_PAREN( sub {
my $C=shift;
$C->_PLUSr(sub {
my $C=shift;
if (my ($C) = ($C->_ARRAY( qw< c d s ] > ))) { ($C) } else { () }
})

})
}))) {
scalar(do {
my $M = $C;
{
given ($M->{0}->Str) {
$_ =~ /c/ and $C->worryobs('/c',':c');
$_ =~ /d/ and $C->worryobs('/g',':d');
$_ =~ /s/ and $C->worryobs('/s',':s');
$C->obs('suffix transliteration modifiers','prefix adverbs');
}
}}, $C)
} else { () }

});
}
;
## token quote:quasi {
sub quote__S_164quasi__PEEK { $_[0]->_AUTOLEXpeek('quote__S_164quasi', $retree) }
sub quote__S_164quasi {
no warnings 'recursion';
my $self = shift;


local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;

my $C = $self->cursor_xact("RULE quote__S_164quasi");
my $xact = $C->xact;
my $S = $C->{'_pos'};
$C->{sym} = "quasi";
$self->_MATCHIFYr($S, "quote__S_164quasi", do {
my $C = $C;
if (($C) = ($C->_PATTERN(qr/\Gquasi\b/))
and ($C) = ($C->_NOTBEFORE(sub {
my $C=shift;
if (my ($C) = ($C->before(sub {
my $C=shift;
$C->_EXACT("\(")
}))) { ($C) } else { () }
}))) {
$C->_SUBSUMEr(['quasiquibble'], sub {
my $C = shift;
$C->quasiquibble($C->cursor_fresh( $::LANG{'Quasi'} ))
})
} else { () }

});
}
;
## token capterm {
sub capterm__PEEK { $_[0]->_AUTOLEXpeek('capterm', $retree) }
sub capterm {
no warnings 'recursion';
my $self = shift;


local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;

my $C = $self->cursor_xact("RULE capterm");
my $xact = $C->xact;
my $S = $C->{'_pos'};
$C->{'capture'} = [];
$self->_MATCHIFYr($S, "capterm", do {
my $C = $C;
if (($C) = ($C->_EXACT("\\"))
and ($C) = ($C->_BRACKETr(sub {
my $C=shift;
do {
my ($tag, $try);
my @try;
my $relex;

my $fate;
my $x;
if ($fate = $C->{'_fate'} and $fate->[1] eq 'capterm_0') {
$C->deb("Fate passed to capterm_0: ", ::fatestr($fate)) if $::DEBUG & DEBUG::fates;
($C->{'_fate'}, $tag, $try) = @$fate;
@try = ($try);
$x = 'ALT capterm_0';    # some outer ltm is controlling us
}
else {
$x = 'ALTLTM capterm_0'; # we are top level ltm
}
my $C = $C->cursor_xact($x);
my $xact = $C->{_xact};

my @gather = ();
for (;;) {
unless (@try) {
$relex //= $C->cursor_fate('STD::P6', 'capterm_0', $retree);
@try = $relex->($C) or last;
}
$try = shift(@try) // next;

if (ref $try) {
($C->{'_fate'}, $tag, $try) = @$try;   # next candidate fate
}

$C->deb("capterm_0 trying $tag $try") if $::DEBUG & DEBUG::try_processing;
push @gather, ((
sub {
my $C=shift;
if (($C) = ($C->_EXACT("\("))
and ($C) = ($C->_OPTr(sub {
my $C=shift;
$C->_SUBSUMEr(['capture'], sub {
my $C = shift;
$C->capture
})
}))) {
$C->_EXACT("\)")
} else { () }
},
sub {
my $C=shift;
if (my ($C) = ($C->before(sub {
my $C=shift;
if (my ($C) = ($C->before(sub {
my $C=shift;
$C->_PATTERN(qr/\G\S/)
}))) { ($C) } else { () }
}))) {
$C->_SUBSUMEr(['termish'], sub {
my $C = shift;
$C->termish
})
} else { () }
},
sub {
my $C=shift;
if (($C) = (scalar(do {
}, $C))
and ($C) = ($C->panic("You can't backslash that"))) {
$C
} else { () }
}
)[$try])->($C);
last if @gather;
last if $xact->[-2];  # committed?
}
@gather;
};
}))) {
$C
} else { () }

});
}
;
## rule capture {
sub capture__PEEK { $_[0]->_AUTOLEXpeek('capture', $retree) }
sub capture {
no warnings 'recursion';
my $self = shift;

local $::INVOCANT_OK = 1;
local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;

my $C = $self->cursor_xact("RULE capture");
my $xact = $C->xact;
my $S = $C->{'_pos'};
$self->_MATCHIFYr($S, "capture", do {
my $C = $C;
if (($C) = ($C->ws)
and ($C) = ($C->_SUBSUMEr(['EXPR'], sub {
my $C = shift;
$C->EXPR
}))
and ($C) = ($C->ws)) {
$C
} else { () }

});
}
;
## token sigterm {
sub sigterm__PEEK { $_[0]->_AUTOLEXpeek('sigterm', $retree) }
sub sigterm {
no warnings 'recursion';
my $self = shift;


local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;

my $C = $self->cursor_xact("RULE sigterm");
my $xact = $C->xact;
my $S = $C->{'_pos'};
$self->_MATCHIFYr($S, "sigterm", $C->_BRACKETr(sub {
my $C=shift;
local $::GOAL = "\)";
my $goalpos = $C;
if (($C) = ($C->_EXACT("\:\("))
and ($C) = (scalar(do {
}, $C))
and ($C) = ($C->_SUBSUMEr(['fakesignature'], sub {
my $C = shift;
$C->fakesignature
}))
and ($C) = ($C->_BRACKETr(sub {
my $C=shift;
do {    my $C = $C->cursor_xact('ALT ||');
my $xact = $C->xact;
my @gather;
do {
push @gather, $C->_EXACT("\)")
}
or $xact->[-2] or
do {
push @gather, do {
if (my ($C) = ($C->FAILGOAL($::GOAL, 'signature', $goalpos))) { ($C) } else { () }

}
};
@gather;
}
}))) {
$C
} else { () }
}));
}
;
## rule param_sep { [','|':'|';'|';;'] }
sub param_sep__PEEK { $_[0]->_AUTOLEXpeek('param_sep', $retree) }
sub param_sep {
no warnings 'recursion';
my $self = shift;


local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;

my $C = $self->cursor_xact("RULE param_sep");
my $xact = $C->xact;
my $S = $C->{'_pos'};
$self->_MATCHIFYr($S, "param_sep", do {
my $C = $C;
if (($C) = ($C->ws)
and ($C) = ($C->_BRACKETr(sub {
my $C=shift;
do {
my ($tag, $try);
my @try;
my $relex;

my $fate;
my $x;
if ($fate = $C->{'_fate'} and $fate->[1] eq 'param_sep_0') {
$C->deb("Fate passed to param_sep_0: ", ::fatestr($fate)) if $::DEBUG & DEBUG::fates;
($C->{'_fate'}, $tag, $try) = @$fate;
@try = ($try);
$x = 'ALT param_sep_0';    # some outer ltm is controlling us
}
else {
$x = 'ALTLTM param_sep_0'; # we are top level ltm
}
my $C = $C->cursor_xact($x);
my $xact = $C->{_xact};

my @gather = ();
for (;;) {
unless (@try) {
$relex //= $C->cursor_fate('STD::P6', 'param_sep_0', $retree);
@try = $relex->($C) or last;
}
$try = shift(@try) // next;

if (ref $try) {
($C->{'_fate'}, $tag, $try) = @$try;   # next candidate fate
}

$C->deb("param_sep_0 trying $tag $try") if $::DEBUG & DEBUG::try_processing;
push @gather, ((
sub {
my $C=shift;
$C->_EXACT("\,")
},
sub {
my $C=shift;
$C->_EXACT("\:")
},
sub {
my $C=shift;
$C->_EXACT("\;")
},
sub {
my $C=shift;
$C->_EXACT("\;\;")
}
)[$try])->($C);
last if @gather;
last if $xact->[-2];  # committed?
}
@gather;
};
}))
and ($C) = ($C->ws)) {
$C
} else { () }

});
}
;
## token fakesignature() {
sub fakesignature__PEEK { $_[0]->_AUTOLEXpeek('fakesignature', $retree) }
sub fakesignature {
no warnings 'recursion';
my $self = shift;

local $::CURLEX = $::CURLEX;local $::DECLARAND;
local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;

my $C = $self->cursor_xact("RULE fakesignature");
my $xact = $C->xact;
my $S = $C->{'_pos'};
$self->_MATCHIFYr($S, "fakesignature", do {
if (my ($C) = ($C->newlex)) {
$C->_SUBSUMEr(['signature'], sub {
my $C = shift;
$C->signature
})
} else { () }

});
}
;
## token signature ($lexsig = 0) {
sub signature__PEEK { $_[0]->_AUTOLEXpeek('signature', $retree) }
sub signature {
no warnings 'recursion';
my $self = shift;

my $lexsig = @_ ? shift() : 0;
local $::IN_DECL = 'sig';local $::zone = 'posreq';my $startpos = $self->{'_pos'};local $::MULTINESS = 'only';local $::SIGNUM = $lexsig;
local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;

my $C = $self->cursor_xact("RULE signature");
my $xact = $C->xact;
my $S = $C->{'_pos'};
$C->{'longname'} = [];
$C->{'param_sep'} = [];
$C->{'parameter'} = [];
$C->{'type_constraint'} = [];
$self->_MATCHIFYr($S, "signature", do {
my $C = $C;
if (($C) = ($C->ws)
and ($C) = ($C->_BRACKETr(sub {
my $C=shift;
do {
my ($tag, $try);
my @try;
my $relex;

my $fate;
my $x;
if ($fate = $C->{'_fate'} and $fate->[1] eq 'signature_0') {
$C->deb("Fate passed to signature_0: ", ::fatestr($fate)) if $::DEBUG & DEBUG::fates;
($C->{'_fate'}, $tag, $try) = @$fate;
@try = ($try);
$x = 'ALT signature_0';    # some outer ltm is controlling us
}
else {
$x = 'ALTLTM signature_0'; # we are top level ltm
}
my $C = $C->cursor_xact($x);
my $xact = $C->{_xact};

my @gather = ();
for (;;) {
unless (@try) {
$relex //= $C->cursor_fate('STD::P6', 'signature_0', $retree);
@try = $relex->($C) or last;
}
$try = shift(@try) // next;

if (ref $try) {
($C->{'_fate'}, $tag, $try) = @$try;   # next candidate fate
}

$C->deb("signature_0 trying $tag $try") if $::DEBUG & DEBUG::try_processing;
push @gather, ((
sub {
my $C=shift;
if (($C) = ($C->_EXACT("\\\|"))
and ($C) = ($C->_BRACKETr(sub {
my $C=shift;
do {    my $C = $C->cursor_xact('ALT ||');
my $xact = $C->xact;
my @gather;
do {
push @gather, $C->_SUBSUMEr(['param_var'], sub {
my $C = shift;
$C->param_var
})
}
or $xact->[-2] or
do {
push @gather, do {
if (my ($C) = ($C->panic("\\| signature must contain one variable"))) { ($C) } else { () }

}
};
@gather;
}
}))
and ($C) = ($C->ws)
and ($C) = ($C->_BRACKETr(sub {
my $C=shift;
do {    my $C = $C->cursor_xact('ALT ||');
my $xact = $C->xact;
my @gather;
do {
push @gather, do {
if (my ($C) = ($C->before(sub {
my $C=shift;
if (my ($C) = ($C->before(sub {
my $C=shift;
if (my ($C) = (do {
do {
my ($tag, $try);
my @try;
my $relex;

my $fate;
my $x;
if ($fate = $C->{'_fate'} and $fate->[1] eq 'signature_1') {
$C->deb("Fate passed to signature_1: ", ::fatestr($fate)) if $::DEBUG & DEBUG::fates;
($C->{'_fate'}, $tag, $try) = @$fate;
@try = ($try);
$x = 'ALT signature_1';    # some outer ltm is controlling us
}
else {
$x = 'ALTLTM signature_1'; # we are top level ltm
}
my $C = $C->cursor_xact($x);
my $xact = $C->{_xact};

my @gather = ();
for (;;) {
unless (@try) {
$relex //= $C->cursor_fate('STD::P6', 'signature_1', $retree);
@try = $relex->($C) or last;
}
$try = shift(@try) // next;

if (ref $try) {
($C->{'_fate'}, $tag, $try) = @$try;   # next candidate fate
}

$C->deb("signature_1 trying $tag $try") if $::DEBUG & DEBUG::try_processing;
push @gather, ((
sub {
my $C=shift;
$C->_EXACT("\-\-\>")
},
sub {
my $C=shift;
$C->_EXACT("\)")
},
sub {
my $C=shift;
$C->_EXACT("\]")
}
)[$try])->($C);
last if @gather;
last if $xact->[-2];  # committed?
}
@gather;
};

})) { ($C) } else { () }
}))) { ($C) } else { () }
}))) { ($C) } else { () }

}
}
or $xact->[-2] or
do {
push @gather, do {
if (my ($C) = ($C->panic("\\| signature may contain only a variable"))) { ($C) } else { () }

}
};
@gather;
}
}))) {
$C
} else { () }
},
sub {
my $C=shift;
$C->_REPSEPr( sub {
my $C=shift;
$C->_SUBSUMEr(['param_sep'], sub {
my $C = shift;
$C->param_sep
})
}, sub {
my $C=shift;
if (my ($C) = ($C->_BRACKETr(sub {
my $C=shift;
do {
my ($tag, $try);
my @try;
my $relex;

my $fate;
my $x;
if ($fate = $C->{'_fate'} and $fate->[1] eq 'signature_2') {
$C->deb("Fate passed to signature_2: ", ::fatestr($fate)) if $::DEBUG & DEBUG::fates;
($C->{'_fate'}, $tag, $try) = @$fate;
@try = ($try);
$x = 'ALT signature_2';    # some outer ltm is controlling us
}
else {
$x = 'ALTLTM signature_2'; # we are top level ltm
}
my $C = $C->cursor_xact($x);
my $xact = $C->{_xact};

my @gather = ();
for (;;) {
unless (@try) {
$relex //= $C->cursor_fate('STD::P6', 'signature_2', $retree);
@try = $relex->($C) or last;
}
$try = shift(@try) // next;

if (ref $try) {
($C->{'_fate'}, $tag, $try) = @$try;   # next candidate fate
}

$C->deb("signature_2 trying $tag $try") if $::DEBUG & DEBUG::try_processing;
push @gather, ((
sub {
my $C=shift;
if (my ($C) = ($C->before(sub {
my $C=shift;
if (my ($C) = ($C->before(sub {
my $C=shift;
if (my ($C) = (do {
do {
my ($tag, $try);
my @try;
my $relex;

my $fate;
my $x;
if ($fate = $C->{'_fate'} and $fate->[1] eq 'signature_3') {
$C->deb("Fate passed to signature_3: ", ::fatestr($fate)) if $::DEBUG & DEBUG::fates;
($C->{'_fate'}, $tag, $try) = @$fate;
@try = ($try);
$x = 'ALT signature_3';    # some outer ltm is controlling us
}
else {
$x = 'ALTLTM signature_3'; # we are top level ltm
}
my $C = $C->cursor_xact($x);
my $xact = $C->{_xact};

my @gather = ();
for (;;) {
unless (@try) {
$relex //= $C->cursor_fate('STD::P6', 'signature_3', $retree);
@try = $relex->($C) or last;
}
$try = shift(@try) // next;

if (ref $try) {
($C->{'_fate'}, $tag, $try) = @$try;   # next candidate fate
}

$C->deb("signature_3 trying $tag $try") if $::DEBUG & DEBUG::try_processing;
push @gather, ((
sub {
my $C=shift;
$C->_EXACT("\-\-\>")
},
sub {
my $C=shift;
$C->_EXACT("\)")
},
sub {
my $C=shift;
$C->_EXACT("\]")
},
sub {
my $C=shift;
$C->_EXACT("\{")
},
sub {
my $C=shift;
$C->_PATTERN(qr/\G\:\s/)
},
sub {
my $C=shift;
$C->_EXACT("\;\;")
}
)[$try])->($C);
last if @gather;
last if $xact->[-2];  # committed?
}
@gather;
};

})) { ($C) } else { () }
}))) { ($C) } else { () }
}))) { ($C) } else { () }
},
sub {
my $C=shift;
if (my ($C) = ($C->_BRACKETr(sub {
my $C=shift;
do {    my $C = $C->cursor_xact('ALT ||');
my $xact = $C->xact;
my @gather;
do {
push @gather, $C->_SUBSUMEr(['parameter'], sub {
my $C = shift;
$C->parameter
})
}
or $xact->[-2] or
do {
push @gather, do {
if (my ($C) = ($C->panic("Malformed parameter"))) { ($C) } else { () }

}
};
@gather;
}
}))) { ($C) } else { () }
}
)[$try])->($C);
last if @gather;
last if $xact->[-2];  # committed?
}
@gather;
};
}))) { ($C) } else { () }
})
}
)[$try])->($C);
last if @gather;
last if $xact->[-2];  # committed?
}
@gather;
};
}))
and ($C) = ($C->ws)
and ($C) = (scalar(do {
$::IN_DECL = ''}, $C))
and ($C) = ($C->_OPTr(sub {
my $C=shift;
if (my ($C) = ($C->_BRACKETr(sub {
my $C=shift;
if (($C) = ($C->_EXACT("\-\-\>"))
and ($C) = ($C->ws)
and ($C) = ($C->_BRACKETr(sub {
my $C=shift;
do {    my $C = $C->cursor_xact('ALT ||');
my $xact = $C->xact;
my @gather;
do {
push @gather, $C->_SUBSUMEr(['type_constraint'], sub {
my $C = shift;
$C->type_constraint
})
}
or $xact->[-2] or
do {
push @gather, do {
my $C = $C;
if (($C) = ($C->_SUBSUMEr(['longname'], sub {
my $C = shift;
$C->longname
}))
and ($C) = (do {
my $M = $C;
$C->panic("Typename " . $M->{'longname'}->[0]->Str . " must be predeclared")
})) {
$C
} else { () }

}
}
or $xact->[-2] or
do {
push @gather, do {
if (my ($C) = ($C->panic("No type found after -->"))) { ($C) } else { () }

}
};
@gather;
}
}))
and ($C) = ($C->ws)) {
$C
} else { () }
}))) { ($C) } else { () }
}))) {
scalar(do {
{
$::LEFTSIGIL = '@';
if ($lexsig) {
$::CURLEX->{'$?SIGNATURE'} .= '|' if $lexsig > 1;
$::CURLEX->{'$?SIGNATURE'} .= '(' . substr($::ORIG, $startpos, $C->{'_pos'} - $startpos) . ')';
delete $::CURLEX->{'!NEEDSIG'};
};
}}, $C)
} else { () }

});
}
;
## token type_declarator:subset {
sub type_declarator__S_165subset__PEEK { $_[0]->_AUTOLEXpeek('type_declarator__S_165subset', $retree) }
sub type_declarator__S_165subset {
no warnings 'recursion';
my $self = shift;

;
local $::IN_DECL = 'subset';local $::DECLARAND;
local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;

my $C = $self->cursor_xact("RULE type_declarator__S_165subset");
my $xact = $C->xact;
my $S = $C->{'_pos'};
$C->{'EXPR'} = [];
$C->{'longname'} = [];
$C->{'trait'} = [];
$C->{sym} = "subset";
$self->_MATCHIFYr($S, "type_declarator__S_165subset", do {    my $C = $C->cursor_xact('ALT ||');
my $xact = $C->xact;
my @gather;
do {
push @gather, do {
my $C = $C;
if (($C) = ($C->_EXACT("subset"))
and ($C) = ($C->spacey)
and ($C) = ($C->ws)
and ($C) = ($C->_BRACKETr(sub {
my $C=shift;
if (($C) = ($C->_OPTr(sub {
my $C=shift;
if (my ($C) = ($C->_BRACKETr(sub {
my $C=shift;
if (($C) = ($C->ws)
and ($C) = ($C->_SUBSUMEr(['longname'], sub {
my $C = shift;
$C->longname
}))
and ($C) = ($C->ws)) {
scalar(do {
my $M = $C;
$C->add_name($M->{'longname'}->[0]->Str)}, $C)
} else { () }
}))) { ($C) } else { () }
}))
and ($C) = ($C->ws)
and ($C) = ($C->_STARr(sub {
my $C=shift;
$C->_SUBSUMEr(['trait'], sub {
my $C = shift;
$C->trait
})
}))
and ($C) = ($C->ws)
and ($C) = ($C->_OPTr(sub {
my $C=shift;
if (my ($C) = ($C->_BRACKETr(sub {
my $C=shift;
if (($C) = ($C->_EXACT("where"))
and ($C) = ($C->ws)
and ($C) = ($C->_SUBSUMEr(['EXPR'], sub {
my $C = shift;
$C->EXPR(\%item_assignment)
}))
and ($C) = ($C->ws)) {
$C
} else { () }
}))) { ($C) } else { () }
}))
and ($C) = ($C->ws)) {
$C
} else { () }
}))) {
$C
} else { () }

}
}
or $xact->[-2] or
do {
push @gather, do {
my $C = $C;
if (($C) = ($C->ws)
and ($C) = ($C->panic("Malformed subset"))
and ($C) = ($C->ws)) {
$C
} else { () }

}
};
@gather;
});
}
;
## token type_declarator:enum {
sub type_declarator__S_166enum__PEEK { $_[0]->_AUTOLEXpeek('type_declarator__S_166enum', $retree) }
sub type_declarator__S_166enum {
no warnings 'recursion';
my $self = shift;

;
local $::IN_DECL = 'enum';local $::DECLARAND;
local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;

my $C = $self->cursor_xact("RULE type_declarator__S_166enum");
my $xact = $C->xact;
my $S = $C->{'_pos'};
$C->{'trait'} = [];
$C->{sym} = "enum";
$self->_MATCHIFYr($S, "type_declarator__S_166enum", do {
my $C = $C;
if (($C) = ($C->_EXACT("enum"))
and ($C) = ($C->spacey)
and ($C) = ($C->ws)
and ($C) = ($C->_BRACKETr(sub {
my $C=shift;
do {
my ($tag, $try);
my @try;
my $relex;

my $fate;
my $x;
if ($fate = $C->{'_fate'} and $fate->[1] eq 'type_declarator__S_166enum_0') {
$C->deb("Fate passed to type_declarator__S_166enum_0: ", ::fatestr($fate)) if $::DEBUG & DEBUG::fates;
($C->{'_fate'}, $tag, $try) = @$fate;
@try = ($try);
$x = 'ALT type_declarator__S_166enum_0';    # some outer ltm is controlling us
}
else {
$x = 'ALTLTM type_declarator__S_166enum_0'; # we are top level ltm
}
my $C = $C->cursor_xact($x);
my $xact = $C->{_xact};

my @gather = ();
for (;;) {
unless (@try) {
$relex //= $C->cursor_fate('STD::P6', 'type_declarator__S_166enum_0', $retree);
@try = $relex->($C) or last;
}
$try = shift(@try) // next;

if (ref $try) {
($C->{'_fate'}, $tag, $try) = @$try;   # next candidate fate
}

$C->deb("type_declarator__S_166enum_0 trying $tag $try") if $::DEBUG & DEBUG::try_processing;
push @gather, ((
sub {
my $C=shift;
if (my ($C) = ($C->_SUBSUMEr(['name','longname'], sub {
my $C = shift;
$C->longname
}))) {
scalar(do {
my $M = $C;
$C->add_name($M->{'name'}->Str)}, $C)
} else { () }
},
sub {
my $C=shift;
if (my ($C) = ($C->_SUBSUMEr(['name','variable'], sub {
my $C = shift;
$C->variable
}))) {
scalar(do {
my $M = $C;
$C->add_variable($M->{'name'}->Str)}, $C)
} else { () }
},
sub {
my $C=shift;
if (my ($C) = ($C->before(sub {
my $C=shift;
$C
}))) { ($C) } else { () }
}
)[$try])->($C);
last if @gather;
last if $xact->[-2];  # committed?
}
@gather;
};
}))
and ($C) = (scalar(do {
$::IN_DECL = ''}, $C))
and ($C) = ($C->ws)
and ($C) = ($C->_STARr(sub {
my $C=shift;
$C->_SUBSUMEr(['trait'], sub {
my $C = shift;
$C->trait
})
}))
and ($C) = ($C->before(sub {
my $C=shift;
if (my ($C) = ($C->before(sub {
my $C=shift;
$C->_PATTERN(qr/\G[<(«]/)
}))) { ($C) } else { () }
}))
and ($C) = ($C->_SUBSUMEr(['term'], sub {
my $C = shift;
$C->term
}))
and ($C) = ($C->ws)) {
scalar(do {
my $M = $C;
$C->add_enum($M->{'name'}, $M->{'term'}->Str)}, $C)
} else { () }

});
}
;
## token type_declarator:constant {
sub type_declarator__S_167constant__PEEK { $_[0]->_AUTOLEXpeek('type_declarator__S_167constant', $retree) }
sub type_declarator__S_167constant {
no warnings 'recursion';
my $self = shift;

;
local $::IN_DECL = 'constant';local $::DECLARAND;
local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;

my $C = $self->cursor_xact("RULE type_declarator__S_167constant");
my $xact = $C->xact;
my $S = $C->{'_pos'};
$C->{'trait'} = [];
$C->{sym} = "constant";
$self->_MATCHIFYr($S, "type_declarator__S_167constant", do {
my $C = $C;
if (($C) = ($C->_EXACT("constant"))
and ($C) = ($C->spacey)
and ($C) = ($C->ws)
and ($C) = ($C->_BRACKETr(sub {
my $C=shift;
do {
my ($tag, $try);
my @try;
my $relex;

my $fate;
my $x;
if ($fate = $C->{'_fate'} and $fate->[1] eq 'type_declarator__S_167constant_0') {
$C->deb("Fate passed to type_declarator__S_167constant_0: ", ::fatestr($fate)) if $::DEBUG & DEBUG::fates;
($C->{'_fate'}, $tag, $try) = @$fate;
@try = ($try);
$x = 'ALT type_declarator__S_167constant_0';    # some outer ltm is controlling us
}
else {
$x = 'ALTLTM type_declarator__S_167constant_0'; # we are top level ltm
}
my $C = $C->cursor_xact($x);
my $xact = $C->{_xact};

my @gather = ();
for (;;) {
unless (@try) {
$relex //= $C->cursor_fate('STD::P6', 'type_declarator__S_167constant_0', $retree);
@try = $relex->($C) or last;
}
$try = shift(@try) // next;

if (ref $try) {
($C->{'_fate'}, $tag, $try) = @$try;   # next candidate fate
}

$C->deb("type_declarator__S_167constant_0 trying $tag $try") if $::DEBUG & DEBUG::try_processing;
push @gather, ((
sub {
my $C=shift;
if (my ($C) = ($C->_SUBSUMEr(['identifier'], sub {
my $C = shift;
$C->identifier
}))) {
scalar(do {
my $M = $C;
$C->add_name($M->{'identifier'}->Str)}, $C)
} else { () }
},
sub {
my $C=shift;
if (my ($C) = ($C->_SUBSUMEr(['variable'], sub {
my $C = shift;
$C->variable
}))) {
scalar(do {
my $M = $C;
$C->add_variable($M->{'variable'}->Str)}, $C)
} else { () }
},
sub {
my $C=shift;
if (my ($C) = ($C->before(sub {
my $C=shift;
$C
}))) { ($C) } else { () }
}
)[$try])->($C);
last if @gather;
last if $xact->[-2];  # committed?
}
@gather;
};
}))
and ($C) = (scalar(do {
$::IN_DECL = ''}, $C))
and ($C) = ($C->ws)
and ($C) = ($C->_STARr(sub {
my $C=shift;
$C->_SUBSUMEr(['trait'], sub {
my $C = shift;
$C->trait
})
}))
and ($C) = ($C->_BRACKETr(sub {
my $C=shift;
do {    my $C = $C->cursor_xact('ALT ||');
my $xact = $C->xact;
my @gather;
do {
push @gather, do {
if (my ($C) = ($C->before(sub {
my $C=shift;
if (my ($C) = ($C->before(sub {
my $C=shift;
$C->_EXACT("\=")
}))) { ($C) } else { () }
}))) { ($C) } else { () }

}
}
or $xact->[-2] or
do {
push @gather, do {
my $C = $C;
if (($C) = ($C->before(sub {
my $C=shift;
if (my ($C) = ($C->before(sub {
my $C=shift;
$C->_PATTERN(qr/\G(?:[^\n=])*+\=/)
}))) { ($C) } else { () }
}))
and ($C) = ($C->panic("Malformed constant"))) {
$C
} else { () }

}
}
or $xact->[-2] or
do {
push @gather, do {
if (my ($C) = ($C->sorry("Missing initializer on constant declaration"))) { ($C) } else { () }

}
};
@gather;
}
}))
and ($C) = ($C->getdecl)) {
$C
} else { () }

});
}
;
## token type_constraint {
sub type_constraint__PEEK { $_[0]->_AUTOLEXpeek('type_constraint', $retree) }
sub type_constraint {
no warnings 'recursion';
my $self = shift;

local $::IN_DECL = '';
local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;

my $C = $self->cursor_xact("RULE type_constraint");
my $xact = $C->xact;
my $S = $C->{'_pos'};
$self->_MATCHIFYr($S, "type_constraint", do {
my $C = $C;
if (($C) = ($C->_BRACKETr(sub {
my $C=shift;
do {
my ($tag, $try);
my @try;
my $relex;

my $fate;
my $x;
if ($fate = $C->{'_fate'} and $fate->[1] eq 'type_constraint_0') {
$C->deb("Fate passed to type_constraint_0: ", ::fatestr($fate)) if $::DEBUG & DEBUG::fates;
($C->{'_fate'}, $tag, $try) = @$fate;
@try = ($try);
$x = 'ALT type_constraint_0';    # some outer ltm is controlling us
}
else {
$x = 'ALTLTM type_constraint_0'; # we are top level ltm
}
my $C = $C->cursor_xact($x);
my $xact = $C->{_xact};

my @gather = ();
for (;;) {
unless (@try) {
$relex //= $C->cursor_fate('STD::P6', 'type_constraint_0', $retree);
@try = $relex->($C) or last;
}
$try = shift(@try) // next;

if (ref $try) {
($C->{'_fate'}, $tag, $try) = @$try;   # next candidate fate
}

$C->deb("type_constraint_0 trying $tag $try") if $::DEBUG & DEBUG::try_processing;
push @gather, ((
sub {
my $C=shift;
$C->_SUBSUMEr(['value'], sub {
my $C = shift;
$C->value
})
},
sub {
my $C=shift;
if (($C) = ($C->_SUBSUMEr(['typename'], sub {
my $C = shift;
$C->typename
}))
and ($C) = ($C->_OPTr(sub {
my $C=shift;
if (my ($C) = ($C->_BRACKETr(sub {
my $C=shift;
if (($C) = ($C->before(sub {
my $C=shift;
(($C) x !!do {
$::DECLARAND->{'of'} })
}))
and ($C) = ($C->sorry("Extra 'of' type; already declared as type " . $::DECLARAND->{'of'}->Str))) {
$C
} else { () }
}))) { ($C) } else { () }
}))) {
scalar(do {
my $M = $C;
$::DECLARAND->{'of'} = $M->{'typename'}}, $C)
} else { () }
},
sub {
my $C=shift;
if (($C) = ($C->_EXACT("where"))
and ($C) = ($C->ws)) {
$C->_SUBSUMEr(['EXPR'], sub {
my $C = shift;
$C->EXPR(\%item_assignment)
})
} else { () }
}
)[$try])->($C);
last if @gather;
last if $xact->[-2];  # committed?
}
@gather;
};
}))
and ($C) = ($C->ws)) {
$C
} else { () }

});
}
;
## rule post_constraint {
sub post_constraint__PEEK { $_[0]->_AUTOLEXpeek('post_constraint', $retree) }
sub post_constraint {
no warnings 'recursion';
my $self = shift;

local $::IN_DECL = '';
local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;

my $C = $self->cursor_xact("RULE post_constraint");
my $xact = $C->xact;
my $S = $C->{'_pos'};
$self->_MATCHIFYr($S, "post_constraint", do {
my $C = $C;
if (($C) = ($C->ws)
and ($C) = ($C->_BRACKETr(sub {
my $C=shift;
do {
my ($tag, $try);
my @try;
my $relex;

my $fate;
my $x;
if ($fate = $C->{'_fate'} and $fate->[1] eq 'post_constraint_0') {
$C->deb("Fate passed to post_constraint_0: ", ::fatestr($fate)) if $::DEBUG & DEBUG::fates;
($C->{'_fate'}, $tag, $try) = @$fate;
@try = ($try);
$x = 'ALT post_constraint_0';    # some outer ltm is controlling us
}
else {
$x = 'ALTLTM post_constraint_0'; # we are top level ltm
}
my $C = $C->cursor_xact($x);
my $xact = $C->{_xact};

my @gather = ();
for (;;) {
unless (@try) {
$relex //= $C->cursor_fate('STD::P6', 'post_constraint_0', $retree);
@try = $relex->($C) or last;
}
$try = shift(@try) // next;

if (ref $try) {
($C->{'_fate'}, $tag, $try) = @$try;   # next candidate fate
}

$C->deb("post_constraint_0 trying $tag $try") if $::DEBUG & DEBUG::try_processing;
push @gather, ((
sub {
my $C=shift;
if (($C) = ($C->_BRACKETr(sub {
my $C=shift;
local $::GOAL = "\]";
my $goalpos = $C;
if (($C) = ($C->_EXACT("\["))
and ($C) = (scalar(do {
}, $C))
and ($C) = ($C->_SUBSUMEr(['signature'], sub {
my $C = shift;
$C->signature
}))
and ($C) = ($C->_BRACKETr(sub {
my $C=shift;
do {    my $C = $C->cursor_xact('ALT ||');
my $xact = $C->xact;
my @gather;
do {
push @gather, $C->_EXACT("\]")
}
or $xact->[-2] or
do {
push @gather, do {
if (my ($C) = ($C->FAILGOAL($::GOAL, 'constraint', $goalpos))) { ($C) } else { () }

}
};
@gather;
}
}))) {
$C
} else { () }
}))
and ($C) = ($C->ws)) {
$C
} else { () }
},
sub {
my $C=shift;
if (($C) = ($C->_BRACKETr(sub {
my $C=shift;
local $::GOAL = "\)";
my $goalpos = $C;
if (($C) = ($C->_EXACT("\("))
and ($C) = (scalar(do {
}, $C))
and ($C) = ($C->_SUBSUMEr(['signature'], sub {
my $C = shift;
$C->signature
}))
and ($C) = ($C->_BRACKETr(sub {
my $C=shift;
do {    my $C = $C->cursor_xact('ALT ||');
my $xact = $C->xact;
my @gather;
do {
push @gather, $C->_EXACT("\)")
}
or $xact->[-2] or
do {
push @gather, do {
if (my ($C) = ($C->FAILGOAL($::GOAL, 'constraint', $goalpos))) { ($C) } else { () }

}
};
@gather;
}
}))) {
$C
} else { () }
}))
and ($C) = ($C->ws)) {
$C
} else { () }
},
sub {
my $C=shift;
if (($C) = ($C->_EXACT("where"))
and ($C) = ($C->ws)
and ($C) = ($C->_SUBSUMEr(['EXPR'], sub {
my $C = shift;
$C->EXPR(\%item_assignment)
}))
and ($C) = ($C->ws)) {
$C
} else { () }
}
)[$try])->($C);
last if @gather;
last if $xact->[-2];  # committed?
}
@gather;
};
}))) {
$C
} else { () }

});
}
;
## token named_param {
sub named_param__PEEK { $_[0]->_AUTOLEXpeek('named_param', $retree) }
sub named_param {
no warnings 'recursion';
my $self = shift;

local $::GOAL = ')';
local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;

my $C = $self->cursor_xact("RULE named_param");
my $xact = $C->xact;
my $S = $C->{'_pos'};
$self->_MATCHIFYr($S, "named_param", do {
my $C = $C;
if (($C) = ($C->_EXACT("\:"))
and ($C) = ($C->_BRACKETr(sub {
my $C=shift;
do {
my ($tag, $try);
my @try;
my $relex;

my $fate;
my $x;
if ($fate = $C->{'_fate'} and $fate->[1] eq 'named_param_0') {
$C->deb("Fate passed to named_param_0: ", ::fatestr($fate)) if $::DEBUG & DEBUG::fates;
($C->{'_fate'}, $tag, $try) = @$fate;
@try = ($try);
$x = 'ALT named_param_0';    # some outer ltm is controlling us
}
else {
$x = 'ALTLTM named_param_0'; # we are top level ltm
}
my $C = $C->cursor_xact($x);
my $xact = $C->{_xact};

my @gather = ();
for (;;) {
unless (@try) {
$relex //= $C->cursor_fate('STD::P6', 'named_param_0', $retree);
@try = $relex->($C) or last;
}
$try = shift(@try) // next;

if (ref $try) {
($C->{'_fate'}, $tag, $try) = @$try;   # next candidate fate
}

$C->deb("named_param_0 trying $tag $try") if $::DEBUG & DEBUG::try_processing;
push @gather, ((
sub {
my $C=shift;
if (($C) = ($C->_SUBSUMEr(['name'], sub {
my $C = shift;
$C->identifier
}))
and ($C) = ($C->_EXACT("\("))
and ($C) = ($C->ws)
and ($C) = ($C->_BRACKETr(sub {
my $C=shift;
do {
my ($tag, $try);
my @try;
my $relex;

my $fate;
my $x;
if ($fate = $C->{'_fate'} and $fate->[1] eq 'named_param_1') {
$C->deb("Fate passed to named_param_1: ", ::fatestr($fate)) if $::DEBUG & DEBUG::fates;
($C->{'_fate'}, $tag, $try) = @$fate;
@try = ($try);
$x = 'ALT named_param_1';    # some outer ltm is controlling us
}
else {
$x = 'ALTLTM named_param_1'; # we are top level ltm
}
my $C = $C->cursor_xact($x);
my $xact = $C->{_xact};

my @gather = ();
for (;;) {
unless (@try) {
$relex //= $C->cursor_fate('STD::P6', 'named_param_1', $retree);
@try = $relex->($C) or last;
}
$try = shift(@try) // next;

if (ref $try) {
($C->{'_fate'}, $tag, $try) = @$try;   # next candidate fate
}

$C->deb("named_param_1 trying $tag $try") if $::DEBUG & DEBUG::try_processing;
push @gather, ((
sub {
my $C=shift;
$C->_SUBSUMEr(['named_param'], sub {
my $C = shift;
$C->named_param
})
},
sub {
my $C=shift;
if (($C) = ($C->_SUBSUMEr(['param_var'], sub {
my $C = shift;
$C->param_var
}))
and ($C) = ($C->ws)) {
$C
} else { () }
}
)[$try])->($C);
last if @gather;
last if $xact->[-2];  # committed?
}
@gather;
};
}))
and ($C) = ($C->_BRACKETr(sub {
my $C=shift;
do {    my $C = $C->cursor_xact('ALT ||');
my $xact = $C->xact;
my @gather;
do {
push @gather, $C->_EXACT("\)")
}
or $xact->[-2] or
do {
push @gather, do {
if (my ($C) = ($C->panic("Unable to parse named parameter; couldn't find right parenthesis"))) { ($C) } else { () }

}
};
@gather;
}
}))) {
$C
} else { () }
},
sub {
my $C=shift;
$C->_SUBSUMEr(['param_var'], sub {
my $C = shift;
$C->param_var(1)
})
}
)[$try])->($C);
last if @gather;
last if $xact->[-2];  # committed?
}
@gather;
};
}))) {
$C
} else { () }

});
}
;
## token param_var($named = 0) {
sub param_var__PEEK { $_[0]->_AUTOLEXpeek('param_var', $retree) }
sub param_var {
no warnings 'recursion';
my $self = shift;

my $named = @_ ? shift() : 0;

local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;

my $C = $self->cursor_xact("RULE param_var");
my $xact = $C->xact;
my $S = $C->{'_pos'};
$C->{'name'} = [];
$C->{'postcircumfix'} = [];
$C->{'twigil'} = [];
$self->_MATCHIFYr($S, "param_var", $C->_BRACKETr(sub {
my $C=shift;
do {
my ($tag, $try);
my @try;
my $relex;

my $fate;
my $x;
if ($fate = $C->{'_fate'} and $fate->[1] eq 'param_var_0') {
$C->deb("Fate passed to param_var_0: ", ::fatestr($fate)) if $::DEBUG & DEBUG::fates;
($C->{'_fate'}, $tag, $try) = @$fate;
@try = ($try);
$x = 'ALT param_var_0';    # some outer ltm is controlling us
}
else {
$x = 'ALTLTM param_var_0'; # we are top level ltm
}
my $C = $C->cursor_xact($x);
my $xact = $C->{_xact};

my @gather = ();
for (;;) {
unless (@try) {
$relex //= $C->cursor_fate('STD::P6', 'param_var_0', $retree);
@try = $relex->($C) or last;
}
$try = shift(@try) // next;

if (ref $try) {
($C->{'_fate'}, $tag, $try) = @$try;   # next candidate fate
}

$C->deb("param_var_0 trying $tag $try") if $::DEBUG & DEBUG::try_processing;
push @gather, ((
sub {
my $C=shift;
if (my ($C) = ($C->_BRACKETr(sub {
my $C=shift;
local $::GOAL = "\]";
my $goalpos = $C;
if (($C) = ($C->_EXACT("\["))
and ($C) = (scalar(do {
}, $C))
and ($C) = ($C->_SUBSUMEr(['signature'], sub {
my $C = shift;
$C->signature
}))
and ($C) = ($C->_BRACKETr(sub {
my $C=shift;
do {    my $C = $C->cursor_xact('ALT ||');
my $xact = $C->xact;
my @gather;
do {
push @gather, $C->_EXACT("\]")
}
or $xact->[-2] or
do {
push @gather, do {
if (my ($C) = ($C->FAILGOAL($::GOAL, 'formal parameter', $goalpos))) { ($C) } else { () }

}
};
@gather;
}
}))) {
$C
} else { () }
}))) { ($C) } else { () }
},
sub {
my $C=shift;
if (my ($C) = ($C->_BRACKETr(sub {
my $C=shift;
local $::GOAL = "\)";
my $goalpos = $C;
if (($C) = ($C->_EXACT("\("))
and ($C) = (scalar(do {
}, $C))
and ($C) = ($C->_SUBSUMEr(['signature'], sub {
my $C = shift;
$C->signature
}))
and ($C) = ($C->_BRACKETr(sub {
my $C=shift;
do {    my $C = $C->cursor_xact('ALT ||');
my $xact = $C->xact;
my @gather;
do {
push @gather, $C->_EXACT("\)")
}
or $xact->[-2] or
do {
push @gather, do {
if (my ($C) = ($C->FAILGOAL($::GOAL, 'formal parameter', $goalpos))) { ($C) } else { () }

}
};
@gather;
}
}))) {
$C
} else { () }
}))) { ($C) } else { () }
},
sub {
my $C=shift;
if (($C) = ($C->_SUBSUMEr(['sigil'], sub {
my $C = shift;
$C->sigil
}))
and ($C) = ($C->_OPTr(sub {
my $C=shift;
$C->_SUBSUMEr(['twigil'], sub {
my $C = shift;
$C->twigil
})
}))
and ($C) = ($C->_OPTr(sub {
my $C=shift;
if (my ($C) = ($C->_BRACKETr(sub {
my $C=shift;
do {    my $C = $C->cursor_xact('ALT ||');
my $xact = $C->xact;
my @gather;
do {
push @gather, do {
my $C = $C;
if (($C) = ($C->before(sub {
my $C=shift;
(($C) x !!do {
my $M = $C;
$M->{'sigil'}->Str eq '&' })
}))
and ($C) = ($C->before(sub {
my $C=shift;
if (my ($C) = ($C->ident)) { ($C) } else { () }
}))
and ($C) = (scalar(do {
}, $C))) {
$C->_SUBSUMEr(['name'], sub {
my $C = shift;
$C->sublongname
})
} else { () }

}
}
or $xact->[-2] or
do {
push @gather, do {
my $C = $C;
if (($C) = ($C->before(sub {
my $C=shift;
(($C) x !!do {
my $M = $C;
$M->{'sigil'}->Str eq '@' || $M->{'sigil'}->Str eq '%' })
}))
and ($C) = ($C->_OPTr(sub {
my $C=shift;
$C->_SUBSUMEr(['name'], sub {
my $C = shift;
$C->identifier
})
}))
and ($C) = ($C->before(sub {
my $C=shift;
if (my ($C) = ($C->before(sub {
my $C=shift;
$C->_PATTERN(qr/\G[\<\(\[\{]/)
}))) { ($C) } else { () }
}))) {
$C->_SUBSUMEr(['postcircumfix'], sub {
my $C = shift;
$C->postcircumfix
})
} else { () }

}
}
or $xact->[-2] or
do {
push @gather, $C->_SUBSUMEr(['name'], sub {
my $C = shift;
$C->identifier
})
}
or $xact->[-2] or
do {
push @gather, do {
my $C = $C;
if (($C) = ($C->_SUBSUMEr(['name'], sub {
my $C = shift;
$C->decint
}))
and ($C) = ($C->panic("Can't declare a numeric parameter"))) {
$C
} else { () }

}
}
or $xact->[-2] or
do {
push @gather, $C->_SUBSUMEr(['name'], sub {
my $C = shift;
$C->_BRACKETr(sub {
my $C=shift;
$C->_PATTERN(qr/\G[\/!]/)
})
})
};
@gather;
}
}))) { ($C) } else { () }
}))) {
scalar(do {
my $M = $C;
{
my $vname = $M->{'sigil'}->Str;
my $t = $M->{'twigil'};
my $twigil = '';
$twigil = $t->[0]->Str if @$t;
$vname .= $twigil;
my $n = eval {
$M->{'name'}->[0]->Str } // '';
$vname .= $n;
given ($twigil) {
when ('') {
$self->add_my_name($vname) if $n ne '';
$::CURLEX->{$vname}->{'used'} = 1 if $named and $n;
}
;
when ('.') {
}
;
when ('!') {
}
;
when ('*') {
}
;
default {
$self->panic("You may not use the $twigil twigil in a signature")}
;
}
;
}}, $C)
} else { () }
}
)[$try])->($C);
last if @gather;
last if $xact->[-2];  # committed?
}
@gather;
};
}));
}
;
## token parameter {
sub parameter__PEEK { $_[0]->_AUTOLEXpeek('parameter', $retree) }
sub parameter {
no warnings 'recursion';
my $self = shift;

my $kind;my $quant = '';local $::DECLARAND;local $::OFTYPE;
local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;

my $C = $self->cursor_xact("RULE parameter");
my $xact = $C->xact;
my $S = $C->{'_pos'};
$C->{'default_value'} = [];
$C->{'post_constraint'} = [];
$C->{'trait'} = [];
$C->{'type_constraint'} = [];
$self->_MATCHIFYr($S, "parameter", do {
my $C = $C;
if (($C) = ($C->_BRACKETr(sub {
my $C=shift;
do {
my ($tag, $try);
my @try;
my $relex;

my $fate;
my $x;
if ($fate = $C->{'_fate'} and $fate->[1] eq 'parameter_0') {
$C->deb("Fate passed to parameter_0: ", ::fatestr($fate)) if $::DEBUG & DEBUG::fates;
($C->{'_fate'}, $tag, $try) = @$fate;
@try = ($try);
$x = 'ALT parameter_0';    # some outer ltm is controlling us
}
else {
$x = 'ALTLTM parameter_0'; # we are top level ltm
}
my $C = $C->cursor_xact($x);
my $xact = $C->{_xact};

my @gather = ();
for (;;) {
unless (@try) {
$relex //= $C->cursor_fate('STD::P6', 'parameter_0', $retree);
@try = $relex->($C) or last;
}
$try = shift(@try) // next;

if (ref $try) {
($C->{'_fate'}, $tag, $try) = @$try;   # next candidate fate
}

$C->deb("parameter_0 trying $tag $try") if $::DEBUG & DEBUG::try_processing;
push @gather, ((
sub {
my $C=shift;
if (($C) = ($C->_PLUSr(sub {
my $C=shift;
$C->_SUBSUMEr(['type_constraint'], sub {
my $C = shift;
$C->type_constraint
})
}))
and ($C) = (scalar(do {
my $M = $C;
{
my $t = $M->{'type_constraint'};
my @t = grep {
substr($_->Str,0,2) ne '::' }  @$t;
@t > 1 and $C->sorry("Multiple prefix constraints not yet supported")
;
}}, $C))
and ($C) = ($C->_BRACKETr(sub {
my $C=shift;
do {
my ($tag, $try);
my @try;
my $relex;

my $fate;
my $x;
if ($fate = $C->{'_fate'} and $fate->[1] eq 'parameter_1') {
$C->deb("Fate passed to parameter_1: ", ::fatestr($fate)) if $::DEBUG & DEBUG::fates;
($C->{'_fate'}, $tag, $try) = @$fate;
@try = ($try);
$x = 'ALT parameter_1';    # some outer ltm is controlling us
}
else {
$x = 'ALTLTM parameter_1'; # we are top level ltm
}
my $C = $C->cursor_xact($x);
my $xact = $C->{_xact};

my @gather = ();
for (;;) {
unless (@try) {
$relex //= $C->cursor_fate('STD::P6', 'parameter_1', $retree);
@try = $relex->($C) or last;
}
$try = shift(@try) // next;

if (ref $try) {
($C->{'_fate'}, $tag, $try) = @$try;   # next candidate fate
}

$C->deb("parameter_1 trying $tag $try") if $::DEBUG & DEBUG::try_processing;
push @gather, ((
sub {
my $C=shift;
if (($C) = ($C->_EXACT("\*\*"))
and ($C) = ($C->_SUBSUMEr(['param_var'], sub {
my $C = shift;
$C->param_var
}))) {
scalar(do {
$quant = '**';
$kind = '*';
}, $C)
} else { () }
},
sub {
my $C=shift;
if (($C) = ($C->_EXACT("\*"))
and ($C) = ($C->_SUBSUMEr(['param_var'], sub {
my $C = shift;
$C->param_var
}))) {
scalar(do {
$quant = '*';
$kind = '*';
}, $C)
} else { () }
},
sub {
my $C=shift;
if (($C) = ($C->_EXACT("\|"))
and ($C) = ($C->_SUBSUMEr(['param_var'], sub {
my $C = shift;
$C->param_var
}))) {
scalar(do {
$quant = '|';
$kind = '*';
}, $C)
} else { () }
},
sub {
my $C=shift;
if (($C) = ($C->_EXACT("\\"))
and ($C) = ($C->_SUBSUMEr(['param_var'], sub {
my $C = shift;
$C->param_var
}))) {
scalar(do {
$quant = '\\';
$kind = '!';
}, $C)
} else { () }
},
sub {
my $C=shift;
if (($C) = ($C->_BRACKETr(sub {
my $C=shift;
do {
my ($tag, $try);
my @try;
my $relex;

my $fate;
my $x;
if ($fate = $C->{'_fate'} and $fate->[1] eq 'parameter_2') {
$C->deb("Fate passed to parameter_2: ", ::fatestr($fate)) if $::DEBUG & DEBUG::fates;
($C->{'_fate'}, $tag, $try) = @$fate;
@try = ($try);
$x = 'ALT parameter_2';    # some outer ltm is controlling us
}
else {
$x = 'ALTLTM parameter_2'; # we are top level ltm
}
my $C = $C->cursor_xact($x);
my $xact = $C->{_xact};

my @gather = ();
for (;;) {
unless (@try) {
$relex //= $C->cursor_fate('STD::P6', 'parameter_2', $retree);
@try = $relex->($C) or last;
}
$try = shift(@try) // next;

if (ref $try) {
($C->{'_fate'}, $tag, $try) = @$try;   # next candidate fate
}

$C->deb("parameter_2 trying $tag $try") if $::DEBUG & DEBUG::try_processing;
push @gather, ((
sub {
my $C=shift;
if (my ($C) = ($C->_SUBSUMEr(['param_var'], sub {
my $C = shift;
$C->param_var
}))) {
scalar(do {
$quant = '';
$kind = '!';
}, $C)
} else { () }
},
sub {
my $C=shift;
if (my ($C) = ($C->_SUBSUMEr(['named_param'], sub {
my $C = shift;
$C->named_param
}))) {
scalar(do {
$quant = '';
$kind = '*';
}, $C)
} else { () }
}
)[$try])->($C);
last if @gather;
last if $xact->[-2];  # committed?
}
@gather;
};
}))
and ($C) = ($C->_BRACKETr(sub {
my $C=shift;
do {
my ($tag, $try);
my @try;
my $relex;

my $fate;
my $x;
if ($fate = $C->{'_fate'} and $fate->[1] eq 'parameter_3') {
$C->deb("Fate passed to parameter_3: ", ::fatestr($fate)) if $::DEBUG & DEBUG::fates;
($C->{'_fate'}, $tag, $try) = @$fate;
@try = ($try);
$x = 'ALT parameter_3';    # some outer ltm is controlling us
}
else {
$x = 'ALTLTM parameter_3'; # we are top level ltm
}
my $C = $C->cursor_xact($x);
my $xact = $C->{_xact};

my @gather = ();
for (;;) {
unless (@try) {
$relex //= $C->cursor_fate('STD::P6', 'parameter_3', $retree);
@try = $relex->($C) or last;
}
$try = shift(@try) // next;

if (ref $try) {
($C->{'_fate'}, $tag, $try) = @$try;   # next candidate fate
}

$C->deb("parameter_3 trying $tag $try") if $::DEBUG & DEBUG::try_processing;
push @gather, ((
sub {
my $C=shift;
if (my ($C) = ($C->_EXACT("\?"))) {
scalar(do {
$quant = '?';
$kind = '?' ;
}, $C)
} else { () }
},
sub {
my $C=shift;
if (my ($C) = ($C->_EXACT("\!"))) {
scalar(do {
$quant = '!';
$kind //= '!' ;
}, $C)
} else { () }
},
sub {
my $C=shift;
if (my ($C) = ($C->before(sub {
my $C=shift;
$C
}))) { ($C) } else { () }
}
)[$try])->($C);
last if @gather;
last if $xact->[-2];  # committed?
}
@gather;
};
}))) {
$C
} else { () }
},
sub {
my $C=shift;
if (my ($C) = ($C->before(sub {
my $C=shift;
$C
}))) {
scalar(do {
$quant = '';
$kind = '!' ;
}, $C)
} else { () }
}
)[$try])->($C);
last if @gather;
last if $xact->[-2];  # committed?
}
@gather;
};
}))) {
$C
} else { () }
},
sub {
my $C=shift;
if (($C) = ($C->_EXACT("\*\*"))
and ($C) = ($C->_SUBSUMEr(['param_var'], sub {
my $C = shift;
$C->param_var
}))) {
scalar(do {
$quant = '**';
$kind = '*';
}, $C)
} else { () }
},
sub {
my $C=shift;
if (($C) = ($C->_EXACT("\*"))
and ($C) = ($C->_SUBSUMEr(['param_var'], sub {
my $C = shift;
$C->param_var
}))) {
scalar(do {
$quant = '*';
$kind = '*';
}, $C)
} else { () }
},
sub {
my $C=shift;
if (($C) = ($C->_EXACT("\|"))
and ($C) = ($C->_SUBSUMEr(['param_var'], sub {
my $C = shift;
$C->param_var
}))) {
scalar(do {
$quant = '|';
$kind = '*';
}, $C)
} else { () }
},
sub {
my $C=shift;
if (($C) = ($C->_EXACT("\\"))
and ($C) = ($C->_SUBSUMEr(['param_var'], sub {
my $C = shift;
$C->param_var
}))) {
scalar(do {
$quant = '\\';
$kind = '!';
}, $C)
} else { () }
},
sub {
my $C=shift;
if (($C) = ($C->_BRACKETr(sub {
my $C=shift;
do {
my ($tag, $try);
my @try;
my $relex;

my $fate;
my $x;
if ($fate = $C->{'_fate'} and $fate->[1] eq 'parameter_4') {
$C->deb("Fate passed to parameter_4: ", ::fatestr($fate)) if $::DEBUG & DEBUG::fates;
($C->{'_fate'}, $tag, $try) = @$fate;
@try = ($try);
$x = 'ALT parameter_4';    # some outer ltm is controlling us
}
else {
$x = 'ALTLTM parameter_4'; # we are top level ltm
}
my $C = $C->cursor_xact($x);
my $xact = $C->{_xact};

my @gather = ();
for (;;) {
unless (@try) {
$relex //= $C->cursor_fate('STD::P6', 'parameter_4', $retree);
@try = $relex->($C) or last;
}
$try = shift(@try) // next;

if (ref $try) {
($C->{'_fate'}, $tag, $try) = @$try;   # next candidate fate
}

$C->deb("parameter_4 trying $tag $try") if $::DEBUG & DEBUG::try_processing;
push @gather, ((
sub {
my $C=shift;
if (my ($C) = ($C->_SUBSUMEr(['param_var'], sub {
my $C = shift;
$C->param_var
}))) {
scalar(do {
$quant = '';
$kind = '!';
}, $C)
} else { () }
},
sub {
my $C=shift;
if (my ($C) = ($C->_SUBSUMEr(['named_param'], sub {
my $C = shift;
$C->named_param
}))) {
scalar(do {
$quant = '';
$kind = '*';
}, $C)
} else { () }
}
)[$try])->($C);
last if @gather;
last if $xact->[-2];  # committed?
}
@gather;
};
}))
and ($C) = ($C->_BRACKETr(sub {
my $C=shift;
do {
my ($tag, $try);
my @try;
my $relex;

my $fate;
my $x;
if ($fate = $C->{'_fate'} and $fate->[1] eq 'parameter_5') {
$C->deb("Fate passed to parameter_5: ", ::fatestr($fate)) if $::DEBUG & DEBUG::fates;
($C->{'_fate'}, $tag, $try) = @$fate;
@try = ($try);
$x = 'ALT parameter_5';    # some outer ltm is controlling us
}
else {
$x = 'ALTLTM parameter_5'; # we are top level ltm
}
my $C = $C->cursor_xact($x);
my $xact = $C->{_xact};

my @gather = ();
for (;;) {
unless (@try) {
$relex //= $C->cursor_fate('STD::P6', 'parameter_5', $retree);
@try = $relex->($C) or last;
}
$try = shift(@try) // next;

if (ref $try) {
($C->{'_fate'}, $tag, $try) = @$try;   # next candidate fate
}

$C->deb("parameter_5 trying $tag $try") if $::DEBUG & DEBUG::try_processing;
push @gather, ((
sub {
my $C=shift;
if (my ($C) = ($C->_EXACT("\?"))) {
scalar(do {
$quant = '?';
$kind = '?' ;
}, $C)
} else { () }
},
sub {
my $C=shift;
if (my ($C) = ($C->_EXACT("\!"))) {
scalar(do {
$quant = '!';
$kind //= '!' ;
}, $C)
} else { () }
},
sub {
my $C=shift;
if (my ($C) = ($C->before(sub {
my $C=shift;
$C
}))) { ($C) } else { () }
}
)[$try])->($C);
last if @gather;
last if $xact->[-2];  # committed?
}
@gather;
};
}))) {
$C
} else { () }
},
sub {
my $C=shift;
if (($C) = (scalar(do {
}, $C))
and ($C) = ($C->_SUBSUMEr(['longname'], sub {
my $C = shift;
$C->longname
}))
and ($C) = (do {
my $M = $C;
$C->panic("In parameter declaration, typename '" . $M->{'longname'}->Str . "' must be predeclared (or marked as declarative with :: prefix)")
})) {
$C
} else { () }
}
)[$try])->($C);
last if @gather;
last if $xact->[-2];  # committed?
}
@gather;
};
}))
and ($C) = ($C->_STARr(sub {
my $C=shift;
$C->_SUBSUMEr(['trait'], sub {
my $C = shift;
$C->trait
})
}))
and ($C) = ($C->_STARr(sub {
my $C=shift;
$C->_SUBSUMEr(['post_constraint'], sub {
my $C = shift;
$C->post_constraint
})
}))
and ($C) = ($C->getdecl)
and ($C) = ($C->_OPTr(sub {
my $C=shift;
if (my ($C) = ($C->_BRACKETr(sub {
my $C=shift;
if (($C) = ($C->_SUBSUMEr(['default_value'], sub {
my $C = shift;
$C->default_value
}))
and ($C) = (scalar(do {
{
given ($quant) {
when ('!') {
$C->sorry("Can't put a default on a required parameter") }
;
when ('*') {
$C->sorry("Can't put a default on a slurpy parameter") }
;
when ('**') {
$C->sorry("Can't put a default on a slice parameter") }
;
when ('|') {
$C->sorry("Can't put a default on an slurpy capture parameter") }
;
when ('\\') {
$C->sorry("Can't put a default on a capture parameter") }
;
}
;
$kind = '?' if $kind eq '!';
}}, $C))
and ($C) = ($C->_OPTr(sub {
my $C=shift;
if (my ($C) = ($C->_BRACKETr(sub {
my $C=shift;
if (($C) = ($C->before(sub {
my $C=shift;
if (my ($C) = ($C->before(sub {
my $C=shift;
$C->_EXACT("\:")
}))) { ($C) } else { () }
}))
and ($C) = ($C->sorry("Can't put a default on the invocant parameter"))) {
$C
} else { () }
}))) { ($C) } else { () }
}))) {
$C->_OPTr(sub {
my $C=shift;
if (my ($C) = ($C->_BRACKETr(sub {
my $C=shift;
if (($C) = ($C->_NOTBEFORE(sub {
my $C=shift;
if (my ($C) = ($C->before(sub {
my $C=shift;
$C->_PATTERN(qr/\G[,;)\]\{\-]/)
}))) { ($C) } else { () }
}))
and ($C) = ($C->sorry("Default expression must come last"))) {
$C
} else { () }
}))) { ($C) } else { () }
})
} else { () }
}))) { ($C) } else { () }
}))
and ($C) = ($C->_OPTr(sub {
my $C=shift;
if (my ($C) = ($C->_BRACKETr(sub {
my $C=shift;
if (($C) = ($C->before(sub {
my $C=shift;
if (my ($C) = ($C->before(sub {
my $C=shift;
$C->_EXACT("\:")
}))) { ($C) } else { () }
}))
and ($C) = ($C->before(sub {
my $C=shift;
(($C) x !!do {
$kind ne '!' })
}))
and ($C) = ($C->sorry("Invocant is too exotic"))) {
$C
} else { () }
}))) { ($C) } else { () }
}))
and ($C) = (scalar(do {
my $M = $C;
$M->{'quant'} = $quant;
$M->{'kind'} = $kind;
}, $C))) {
scalar(do {
{
given ($kind) {
when ('!') {
given ($::zone) {
when ('posopt') {
$C->sorry("Can't put required parameter after optional parameters")}
;
when ('var') {
$C->sorry("Can't put required parameter after variadic parameters")}
;
}
}
;
when ('?') {
given ($::zone) {
when ('posreq') {
$::zone = 'posopt' }
;
when ('var') {
$C->sorry("Can't put optional positional parameter after variadic parameters")}
;
}
}
;
when ('*') {
$::zone = 'var'}
;
}
}}, $C)
} else { () }

});
}
;
## rule default_value {
sub default_value__PEEK { $_[0]->_AUTOLEXpeek('default_value', $retree) }
sub default_value {
no warnings 'recursion';
my $self = shift;

local $::IN_DECL = '';
local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;

my $C = $self->cursor_xact("RULE default_value");
my $xact = $C->xact;
my $S = $C->{'_pos'};
$self->_MATCHIFYr($S, "default_value", do {
my $C = $C;
if (($C) = ($C->ws)
and ($C) = ($C->_EXACT("\="))
and ($C) = ($C->ws)
and ($C) = ($C->_SUBSUMEr(['EXPR'], sub {
my $C = shift;
$C->EXPR(\%item_assignment)
}))
and ($C) = ($C->ws)) {
$C
} else { () }

});
}
;
## token statement_prefix:sink    { <sym> <blast> }
sub statement_prefix__S_168sink__PEEK { $_[0]->_AUTOLEXpeek('statement_prefix__S_168sink', $retree) }
sub statement_prefix__S_168sink {
no warnings 'recursion';
my $self = shift;


local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;

my $C = $self->cursor_xact("RULE statement_prefix__S_168sink");
my $xact = $C->xact;
my $S = $C->{'_pos'};
$C->{sym} = "sink";
$self->_MATCHIFYr($S, "statement_prefix__S_168sink", do {
if (my ($C) = ($C->_EXACT("sink"))) {
$C->_SUBSUMEr(['blast'], sub {
my $C = shift;
$C->blast
})
} else { () }

});
}
;
## token statement_prefix:try     { <sym> <blast> }
sub statement_prefix__S_169try__PEEK { $_[0]->_AUTOLEXpeek('statement_prefix__S_169try', $retree) }
sub statement_prefix__S_169try {
no warnings 'recursion';
my $self = shift;


local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;

my $C = $self->cursor_xact("RULE statement_prefix__S_169try");
my $xact = $C->xact;
my $S = $C->{'_pos'};
$C->{sym} = "try";
$self->_MATCHIFYr($S, "statement_prefix__S_169try", do {
if (my ($C) = ($C->_EXACT("try"))) {
$C->_SUBSUMEr(['blast'], sub {
my $C = shift;
$C->blast
})
} else { () }

});
}
;
## token statement_prefix:quietly { <sym> <blast> }
sub statement_prefix__S_170quietly__PEEK { $_[0]->_AUTOLEXpeek('statement_prefix__S_170quietly', $retree) }
sub statement_prefix__S_170quietly {
no warnings 'recursion';
my $self = shift;


local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;

my $C = $self->cursor_xact("RULE statement_prefix__S_170quietly");
my $xact = $C->xact;
my $S = $C->{'_pos'};
$C->{sym} = "quietly";
$self->_MATCHIFYr($S, "statement_prefix__S_170quietly", do {
if (my ($C) = ($C->_EXACT("quietly"))) {
$C->_SUBSUMEr(['blast'], sub {
my $C = shift;
$C->blast
})
} else { () }

});
}
;
## token statement_prefix:gather  { <sym> <blast> }
sub statement_prefix__S_171gather__PEEK { $_[0]->_AUTOLEXpeek('statement_prefix__S_171gather', $retree) }
sub statement_prefix__S_171gather {
no warnings 'recursion';
my $self = shift;


local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;

my $C = $self->cursor_xact("RULE statement_prefix__S_171gather");
my $xact = $C->xact;
my $S = $C->{'_pos'};
$C->{sym} = "gather";
$self->_MATCHIFYr($S, "statement_prefix__S_171gather", do {
if (my ($C) = ($C->_EXACT("gather"))) {
$C->_SUBSUMEr(['blast'], sub {
my $C = shift;
$C->blast
})
} else { () }

});
}
;
## token statement_prefix:contend { <sym> <blast> }
sub statement_prefix__S_172contend__PEEK { $_[0]->_AUTOLEXpeek('statement_prefix__S_172contend', $retree) }
sub statement_prefix__S_172contend {
no warnings 'recursion';
my $self = shift;


local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;

my $C = $self->cursor_xact("RULE statement_prefix__S_172contend");
my $xact = $C->xact;
my $S = $C->{'_pos'};
$C->{sym} = "contend";
$self->_MATCHIFYr($S, "statement_prefix__S_172contend", do {
if (my ($C) = ($C->_EXACT("contend"))) {
$C->_SUBSUMEr(['blast'], sub {
my $C = shift;
$C->blast
})
} else { () }

});
}
;
## token statement_prefix:async   { <sym> <blast> }
sub statement_prefix__S_173async__PEEK { $_[0]->_AUTOLEXpeek('statement_prefix__S_173async', $retree) }
sub statement_prefix__S_173async {
no warnings 'recursion';
my $self = shift;


local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;

my $C = $self->cursor_xact("RULE statement_prefix__S_173async");
my $xact = $C->xact;
my $S = $C->{'_pos'};
$C->{sym} = "async";
$self->_MATCHIFYr($S, "statement_prefix__S_173async", do {
if (my ($C) = ($C->_EXACT("async"))) {
$C->_SUBSUMEr(['blast'], sub {
my $C = shift;
$C->blast
})
} else { () }

});
}
;
## token statement_prefix:maybe   { <sym> <blast> }
sub statement_prefix__S_174maybe__PEEK { $_[0]->_AUTOLEXpeek('statement_prefix__S_174maybe', $retree) }
sub statement_prefix__S_174maybe {
no warnings 'recursion';
my $self = shift;


local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;

my $C = $self->cursor_xact("RULE statement_prefix__S_174maybe");
my $xact = $C->xact;
my $S = $C->{'_pos'};
$C->{sym} = "maybe";
$self->_MATCHIFYr($S, "statement_prefix__S_174maybe", do {
if (my ($C) = ($C->_EXACT("maybe"))) {
$C->_SUBSUMEr(['blast'], sub {
my $C = shift;
$C->blast
})
} else { () }

});
}
;
## token statement_prefix:lazy    { <sym> <blast> }
sub statement_prefix__S_175lazy__PEEK { $_[0]->_AUTOLEXpeek('statement_prefix__S_175lazy', $retree) }
sub statement_prefix__S_175lazy {
no warnings 'recursion';
my $self = shift;


local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;

my $C = $self->cursor_xact("RULE statement_prefix__S_175lazy");
my $xact = $C->xact;
my $S = $C->{'_pos'};
$C->{sym} = "lazy";
$self->_MATCHIFYr($S, "statement_prefix__S_175lazy", do {
if (my ($C) = ($C->_EXACT("lazy"))) {
$C->_SUBSUMEr(['blast'], sub {
my $C = shift;
$C->blast
})
} else { () }

});
}
;
## token statement_prefix:do      { <sym> <blast> }
sub statement_prefix__S_176do__PEEK { $_[0]->_AUTOLEXpeek('statement_prefix__S_176do', $retree) }
sub statement_prefix__S_176do {
no warnings 'recursion';
my $self = shift;


local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;

my $C = $self->cursor_xact("RULE statement_prefix__S_176do");
my $xact = $C->xact;
my $S = $C->{'_pos'};
$C->{sym} = "do";
$self->_MATCHIFYr($S, "statement_prefix__S_176do", do {
if (my ($C) = ($C->_EXACT("do"))) {
$C->_SUBSUMEr(['blast'], sub {
my $C = shift;
$C->blast
})
} else { () }

});
}
;
## token statement_prefix:lift    {
sub statement_prefix__S_177lift__PEEK { $_[0]->_AUTOLEXpeek('statement_prefix__S_177lift', $retree) }
sub statement_prefix__S_177lift {
no warnings 'recursion';
my $self = shift;

local $::QUASIMODO = 1;
local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;

my $C = $self->cursor_xact("RULE statement_prefix__S_177lift");
my $xact = $C->xact;
my $S = $C->{'_pos'};
$C->{sym} = "lift";
$self->_MATCHIFYr($S, "statement_prefix__S_177lift", do {
if (my ($C) = ($C->_EXACT("lift"))) {
$C->_SUBSUMEr(['blast'], sub {
my $C = shift;
$C->blast
})
} else { () }

});
}
;
## token blast {
sub blast__PEEK { $_[0]->_AUTOLEXpeek('blast', $retree) }
sub blast {
no warnings 'recursion';
my $self = shift;


local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;

my $C = $self->cursor_xact("RULE blast");
my $xact = $C->xact;
my $S = $C->{'_pos'};
$self->_MATCHIFYr($S, "blast", do {
my $C = $C;
if (($C) = ($C->before(sub {
my $C=shift;
if (my ($C) = ($C->before(sub {
my $C=shift;
$C->_PATTERN(qr/\G\s/)
}))) { ($C) } else { () }
}))
and ($C) = ($C->ws)
and ($C) = ($C->_BRACKETr(sub {
my $C=shift;
do {
my ($tag, $try);
my @try;
my $relex;

my $fate;
my $x;
if ($fate = $C->{'_fate'} and $fate->[1] eq 'blast_0') {
$C->deb("Fate passed to blast_0: ", ::fatestr($fate)) if $::DEBUG & DEBUG::fates;
($C->{'_fate'}, $tag, $try) = @$fate;
@try = ($try);
$x = 'ALT blast_0';    # some outer ltm is controlling us
}
else {
$x = 'ALTLTM blast_0'; # we are top level ltm
}
my $C = $C->cursor_xact($x);
my $xact = $C->{_xact};

my @gather = ();
for (;;) {
unless (@try) {
$relex //= $C->cursor_fate('STD::P6', 'blast_0', $retree);
@try = $relex->($C) or last;
}
$try = shift(@try) // next;

if (ref $try) {
($C->{'_fate'}, $tag, $try) = @$try;   # next candidate fate
}

$C->deb("blast_0 trying $tag $try") if $::DEBUG & DEBUG::try_processing;
push @gather, ((
sub {
my $C=shift;
$C->_SUBSUMEr(['block'], sub {
my $C = shift;
$C->block
})
},
sub {
my $C=shift;
$C->_SUBSUMEr(['statement'], sub {
my $C = shift;
$C->statement
})
}
)[$try])->($C);
last if @gather;
last if $xact->[-2];  # committed?
}
@gather;
};
}))) {
$C
} else { () }

});
}
;
## token term:new {
sub term__S_178new__PEEK { $_[0]->_AUTOLEXpeek('term__S_178new', $retree) }
sub term__S_178new {
no warnings 'recursion';
my $self = shift;


local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;

my $C = $self->cursor_xact("RULE term__S_178new");
my $xact = $C->xact;
my $S = $C->{'_pos'};
$C->{sym} = "new";
$self->_MATCHIFYr($S, "term__S_178new", do {
my $C = $C;
if (($C) = ($C->_PATTERN(qr/\Gnew[\x20\t\r]++/))
and ($C) = ($C->_SUBSUMEr(['longname'], sub {
my $C = shift;
$C->longname
}))
and ($C) = ($C->_PATTERN(qr/\G[\x20\t\r]*+/))
and ($C) = ($C->_NOTBEFORE(sub {
my $C=shift;
if (my ($C) = ($C->before(sub {
my $C=shift;
$C->_EXACT("\:")
}))) { ($C) } else { () }
}))
and ($C) = ($C->obs("C++ constructor syntax", "method call syntax"))) {
$C
} else { () }

});
}
;
## token term:sym<::?IDENT> {
sub term__S_179ColonColonQuestionIDENT__PEEK { $_[0]->_AUTOLEXpeek('term__S_179ColonColonQuestionIDENT', $retree) }
sub term__S_179ColonColonQuestionIDENT {
no warnings 'recursion';
my $self = shift;


local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;

my $C = $self->cursor_xact("RULE term__S_179ColonColonQuestionIDENT");
my $xact = $C->xact;
my $S = $C->{'_pos'};
$C->{sym} = "\:\:\?IDENT";
$self->_MATCHIFYr($S, "term__S_179ColonColonQuestionIDENT", do {
my $C = $C;
if (($C) = ($C->_SUBSUMEr(['sym'], sub {
my $C = shift;
$C->_BRACKETr(sub {
my $C=shift;
if (my ($C) = ($C->_EXACT("\:\:\?"))) {
$C->_SUBSUMEr(['identifier'], sub {
my $C = shift;
$C->identifier
})
} else { () }
})
}))
and ($C) = ($C->_PATTERN(qr/\G\b/))) {
$C->_SUBSUMEr(['O'], sub {
my $C = shift;
$C->O(%term)
})
} else { () }

});
}
;
## token term:sym<Object> {
sub term__S_180Object__PEEK { $_[0]->_AUTOLEXpeek('term__S_180Object', $retree) }
sub term__S_180Object {
no warnings 'recursion';
my $self = shift;


local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;

my $C = $self->cursor_xact("RULE term__S_180Object");
my $xact = $C->xact;
my $S = $C->{'_pos'};
$C->{sym} = "Object";
$self->_MATCHIFYr($S, "term__S_180Object", do {
my $C = $C;
if (($C) = ($C->_PATTERN(qr/\GObject\b/))
and ($C) = (scalar(do {
}, $C))
and ($C) = ($C->obs('Object', 'Mu as the "most universal" object type'))) {
$C
} else { () }

});
}
;
## token term:sym<undef> {
sub term__S_181undef__PEEK { $_[0]->_AUTOLEXpeek('term__S_181undef', $retree) }
sub term__S_181undef {
no warnings 'recursion';
my $self = shift;


local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;

my $C = $self->cursor_xact("RULE term__S_181undef");
my $xact = $C->xact;
my $S = $C->{'_pos'};
$C->{sym} = "undef";
$self->_MATCHIFYr($S, "term__S_181undef", do {
my $C = $C;
if (($C) = ($C->_PATTERN(qr/\Gundef\b/))
and ($C) = (scalar(do {
}, $C))
and ($C) = ($C->_OPTr(sub {
my $C=shift;
if (my ($C) = ($C->_BRACKETr(sub {
my $C=shift;
if (($C) = ($C->before(sub {
my $C=shift;
if (my ($C) = ($C->before(sub {
my $C=shift;
$C->_PATTERN(qr/\G[\x20\t\r]*+\$\//)
}))) { ($C) } else { () }
}))
and ($C) = ($C->obs('$/ variable as input record separator',
"the filehandle's .slurp method"))) {
$C
} else { () }
}))) { ($C) } else { () }
}))
and ($C) = ($C->_OPTr(sub {
my $C=shift;
if (my ($C) = ($C->_BRACKETr(sub {
my $C=shift;
if (($C) = ($C->before(sub {
my $C=shift;
if (my ($C) = ($C->before(sub {
my $C=shift;
$C->{'sigil'} = [];
$C->{'twigil'} = [];
if (my ($C) = ($C->_BRACKETr(sub {
my $C=shift;
do {    my $C = $C->cursor_xact('ALT ||');
my $xact = $C->xact;
my @gather;
do {
push @gather, $C->_EXACT("\(")
}
or $xact->[-2] or
do {
push @gather, do {
my $C = $C;
if (($C) = ($C->_PATTERN(qr/\G[\x20\t\r]*+/))
and ($C) = ($C->_SUBSUMEr(['sigil'], sub {
my $C = shift;
$C->sigil
}))
and ($C) = ($C->_OPTr(sub {
my $C=shift;
$C->_SUBSUMEr(['twigil'], sub {
my $C = shift;
$C->twigil
})
}))) {
$C->_PATTERN(qr/\G\w/)
} else { () }

}
};
@gather;
}
}))) { ($C) } else { () }
}))) { ($C) } else { () }
}))
and ($C) = ($C->obs('undef as a verb', 'undefine function or assignment of Nil'))) {
$C
} else { () }
}))) { ($C) } else { () }
}))
and ($C) = ($C->obs('undef as a value', "something more specific:\n\tMu (the \"most undefined\" type object),\n\tan undefined type object such as Int,\n\tNil as an empty list,\n\t:!defined as a matcher,\n\tAny:U as a type constraint\n\tor fail() as a failure return\n\t   "))) {
$C
} else { () }

});
}
;
## token term:sym<proceed>
sub term__S_182proceed__PEEK { $_[0]->_AUTOLEXpeek('term__S_182proceed', $retree) }
sub term__S_182proceed {
no warnings 'recursion';
my $self = shift;


local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;

my $C = $self->cursor_xact("RULE term__S_182proceed");
my $xact = $C->xact;
my $S = $C->{'_pos'};
$C->{sym} = "proceed";
$self->_MATCHIFYr($S, "term__S_182proceed", do {
if (my ($C) = ($C->_PATTERN(qr/\Gproceed\b/))) {
$C->_SUBSUMEr(['O'], sub {
my $C = shift;
$C->O(%term)
})
} else { () }

});
}
;
## token term:sym<time>
sub term__S_183time__PEEK { $_[0]->_AUTOLEXpeek('term__S_183time', $retree) }
sub term__S_183time {
no warnings 'recursion';
my $self = shift;


local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;

my $C = $self->cursor_xact("RULE term__S_183time");
my $xact = $C->xact;
my $S = $C->{'_pos'};
$C->{sym} = "time";
$self->_MATCHIFYr($S, "term__S_183time", do {
if (my ($C) = ($C->_PATTERN(qr/\Gtime\b/))) {
$C->_SUBSUMEr(['O'], sub {
my $C = shift;
$C->O(%term)
})
} else { () }

});
}
;
## token term:sym<now>
sub term__S_184now__PEEK { $_[0]->_AUTOLEXpeek('term__S_184now', $retree) }
sub term__S_184now {
no warnings 'recursion';
my $self = shift;


local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;

my $C = $self->cursor_xact("RULE term__S_184now");
my $xact = $C->xact;
my $S = $C->{'_pos'};
$C->{sym} = "now";
$self->_MATCHIFYr($S, "term__S_184now", do {
if (my ($C) = ($C->_PATTERN(qr/\Gnow\b/))) {
$C->_SUBSUMEr(['O'], sub {
my $C = shift;
$C->O(%term)
})
} else { () }

});
}
;
## token term:sym<self>
sub term__S_185self__PEEK { $_[0]->_AUTOLEXpeek('term__S_185self', $retree) }
sub term__S_185self {
no warnings 'recursion';
my $self = shift;


local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;

my $C = $self->cursor_xact("RULE term__S_185self");
my $xact = $C->xact;
my $S = $C->{'_pos'};
$C->{sym} = "self";
$self->_MATCHIFYr($S, "term__S_185self", do {
if (my ($C) = ($C->_PATTERN(qr/\Gself\b/))) {
$C->_SUBSUMEr(['O'], sub {
my $C = shift;
$C->O(%term)
})
} else { () }

});
}
;
## token term:sym<defer>
sub term__S_186defer__PEEK { $_[0]->_AUTOLEXpeek('term__S_186defer', $retree) }
sub term__S_186defer {
no warnings 'recursion';
my $self = shift;


local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;

my $C = $self->cursor_xact("RULE term__S_186defer");
my $xact = $C->xact;
my $S = $C->{'_pos'};
$C->{sym} = "defer";
$self->_MATCHIFYr($S, "term__S_186defer", do {
if (my ($C) = ($C->_PATTERN(qr/\Gdefer\b/))) {
$C->_SUBSUMEr(['O'], sub {
my $C = shift;
$C->O(%term)
})
} else { () }

});
}
;
## token term:rand {
sub term__S_187rand__PEEK { $_[0]->_AUTOLEXpeek('term__S_187rand', $retree) }
sub term__S_187rand {
no warnings 'recursion';
my $self = shift;


local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;

my $C = $self->cursor_xact("RULE term__S_187rand");
my $xact = $C->xact;
my $S = $C->{'_pos'};
$C->{sym} = "rand";
$self->_MATCHIFYr($S, "term__S_187rand", do {
my $C = $C;
if (($C) = ($C->_PATTERN(qr/\Grand\b/))
and ($C) = ($C->_OPTr(sub {
my $C=shift;
if (my ($C) = ($C->_BRACKETr(sub {
my $C=shift;
if (($C) = ($C->before(sub {
my $C=shift;
if (my ($C) = ($C->before(sub {
my $C=shift;
do {
my $C = $C;
if (($C) = ($C->_PATTERN(qr/\G\(?+[\x20\t\r]*+/))
and ($C) = ($C->_BRACKETr(sub {
my $C=shift;
do {
my ($tag, $try);
my @try;
my $relex;

my $fate;
my $x;
if ($fate = $C->{'_fate'} and $fate->[1] eq 'term__S_187rand_0') {
$C->deb("Fate passed to term__S_187rand_0: ", ::fatestr($fate)) if $::DEBUG & DEBUG::fates;
($C->{'_fate'}, $tag, $try) = @$fate;
@try = ($try);
$x = 'ALT term__S_187rand_0';    # some outer ltm is controlling us
}
else {
$x = 'ALTLTM term__S_187rand_0'; # we are top level ltm
}
my $C = $C->cursor_xact($x);
my $xact = $C->{_xact};

my @gather = ();
for (;;) {
unless (@try) {
$relex //= $C->cursor_fate('STD::P6', 'term__S_187rand_0', $retree);
@try = $relex->($C) or last;
}
$try = shift(@try) // next;

if (ref $try) {
($C->{'_fate'}, $tag, $try) = @$try;   # next candidate fate
}

$C->deb("term__S_187rand_0 trying $tag $try") if $::DEBUG & DEBUG::try_processing;
push @gather, ((
sub {
my $C=shift;
$C->_PATTERN(qr/\G\d/)
},
sub {
my $C=shift;
$C->_EXACT("\$")
}
)[$try])->($C);
last if @gather;
last if $xact->[-2];  # committed?
}
@gather;
};
}))) {
$C
} else { () }
};
}))) { ($C) } else { () }
}))
and ($C) = ($C->obs('rand(N)', 'N.rand or (1..N).pick'))) {
$C
} else { () }
}))) { ($C) } else { () }
}))
and ($C) = ($C->_OPTr(sub {
my $C=shift;
if (my ($C) = ($C->_BRACKETr(sub {
my $C=shift;
if (($C) = ($C->before(sub {
my $C=shift;
if (my ($C) = ($C->before(sub {
my $C=shift;
$C->_EXACT("\(\)")
}))) { ($C) } else { () }
}))
and ($C) = ($C->obs('rand()', 'rand'))) {
$C
} else { () }
}))) { ($C) } else { () }
}))) {
$C->_SUBSUMEr(['O'], sub {
my $C = shift;
$C->O(%term)
})
} else { () }

});
}
;
## token term:sym<*>
sub term__S_188Star__PEEK { $_[0]->_AUTOLEXpeek('term__S_188Star', $retree) }
sub term__S_188Star {
no warnings 'recursion';
my $self = shift;


local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;

my $C = $self->cursor_xact("RULE term__S_188Star");
my $xact = $C->xact;
my $S = $C->{'_pos'};
$C->{sym} = "\*";
$self->_MATCHIFYr($S, "term__S_188Star", do {
if (my ($C) = ($C->_EXACT("\*"))) {
$C->_SUBSUMEr(['O'], sub {
my $C = shift;
$C->O(%term)
})
} else { () }

});
}
;
## token term:sym<**>
sub term__S_189StarStar__PEEK { $_[0]->_AUTOLEXpeek('term__S_189StarStar', $retree) }
sub term__S_189StarStar {
no warnings 'recursion';
my $self = shift;


local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;

my $C = $self->cursor_xact("RULE term__S_189StarStar");
my $xact = $C->xact;
my $S = $C->{'_pos'};
$C->{sym} = "\*\*";
$self->_MATCHIFYr($S, "term__S_189StarStar", do {
if (my ($C) = ($C->_EXACT("\*\*"))) {
$C->_SUBSUMEr(['O'], sub {
my $C = shift;
$C->O(%term)
})
} else { () }

});
}
;
## token infix:lambda {
sub infix__S_190lambda__PEEK { $_[0]->_AUTOLEXpeek('infix__S_190lambda', $retree) }
sub infix__S_190lambda {
no warnings 'recursion';
my $self = shift;


local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;

my $C = $self->cursor_xact("RULE infix__S_190lambda");
my $xact = $C->xact;
my $S = $C->{'_pos'};
$C->{sym} = "lambda";
$self->_MATCHIFYr($S, "infix__S_190lambda", do {
my $C = $C;
if (($C) = ($C->before(sub {
my $C=shift;
if (my ($C) = ($C->before(sub {
my $C=shift;
if (my ($C) = (do {
do {
my ($tag, $try);
my @try;
my $relex;

my $fate;
my $x;
if ($fate = $C->{'_fate'} and $fate->[1] eq 'infix__S_190lambda_0') {
$C->deb("Fate passed to infix__S_190lambda_0: ", ::fatestr($fate)) if $::DEBUG & DEBUG::fates;
($C->{'_fate'}, $tag, $try) = @$fate;
@try = ($try);
$x = 'ALT infix__S_190lambda_0';    # some outer ltm is controlling us
}
else {
$x = 'ALTLTM infix__S_190lambda_0'; # we are top level ltm
}
my $C = $C->cursor_xact($x);
my $xact = $C->{_xact};

my @gather = ();
for (;;) {
unless (@try) {
$relex //= $C->cursor_fate('STD::P6', 'infix__S_190lambda_0', $retree);
@try = $relex->($C) or last;
}
$try = shift(@try) // next;

if (ref $try) {
($C->{'_fate'}, $tag, $try) = @$try;   # next candidate fate
}

$C->deb("infix__S_190lambda_0 trying $tag $try") if $::DEBUG & DEBUG::try_processing;
push @gather, ((
sub {
my $C=shift;
$C->_EXACT("\{")
},
sub {
my $C=shift;
$C->_EXACT("\-\>")
}
)[$try])->($C);
last if @gather;
last if $xact->[-2];  # committed?
}
@gather;
};

})) { ($C) } else { () }
}))) { ($C) } else { () }
}))
and ($C) = ($C->_NOTBEFORE(sub {
my $C=shift;
(($C) x !!do {
$::IN_META })
}))
and ($C) = (scalar(do {
{
my $needparens = 0;
my $line = $C->lineof($C->{'_pos'});
for ('if', 'unless', 'while', 'until', 'for', 'given', 'when', 'loop', 'sub', 'method') {
$needparens++ if $_ eq 'loop';
my $m = $::MYSTERY{$_};
next unless $m;
if ($line - ($m->{'line'}//-123) < 5) {
if ($m->{'ctx'} eq '(') {
$C->panic("Word '$_' interpreted as '$_" . "()' function call; please use whitespace " .
($needparens ? 'around the parens' : 'instead of parens') . $m->{'token'}->locmess .
"\nUnexpected block in infix position (two terms in a row)")}
else {
$C->panic("Word '$_' interpreted as a listop; please use 'do $_' to introduce the statement control word" . $m->{'token'}->cursor($m->{'token'}->from)->locmess .
"\nUnexpected block in infix position (two terms in a row)")}};
}
;
return () if $::IN_REDUCE;
my $endpos = $C->{'_pos'};
my $startpos = $::MEMOS[$endpos]->{'ws'} // $endpos;
if ($self->lineof($startpos) != $self->lineof($endpos)) {
$C->panic("Unexpected block in infix position (previous line missing its semicolon?)")}
elsif ($::MEMOS[$C->{'_pos'}-1]->{'baremeth'}) {
$C->panic("Unexpected block in infix position (method call needs colon or parens to take arguments)")}
else {
$C->panic("Unexpected block in infix position (two terms in a row, or previous statement missing semicolon?)")};
}}, $C))) {
$C->_SUBSUMEr(['O'], sub {
my $C = shift;
$C->O(%term)
})
} else { () }

});
}
;
## token circumfix:sigil
sub circumfix__S_191sigil__PEEK { $_[0]->_AUTOLEXpeek('circumfix__S_191sigil', $retree) }
sub circumfix__S_191sigil {
no warnings 'recursion';
my $self = shift;


local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;

my $C = $self->cursor_xact("RULE circumfix__S_191sigil");
my $xact = $C->xact;
my $S = $C->{'_pos'};
$C->{sym} = "sigil";
$self->_MATCHIFYr($S, "circumfix__S_191sigil", do {
my $C = $C;
if (($C) = ($C->_SUBSUMEr(['sigil'], sub {
my $C = shift;
$C->sigil
}))
and ($C) = ($C->_BRACKETr(sub {
my $C=shift;
local $::GOAL = "\)";
my $goalpos = $C;
if (($C) = ($C->_EXACT("\("))
and ($C) = (scalar(do {
}, $C))
and ($C) = ($C->_SUBSUMEr(['semilist'], sub {
my $C = shift;
$C->semilist
}))
and ($C) = ($C->_BRACKETr(sub {
my $C=shift;
do {    my $C = $C->cursor_xact('ALT ||');
my $xact = $C->xact;
my @gather;
do {
push @gather, $C->_EXACT("\)")
}
or $xact->[-2] or
do {
push @gather, do {
if (my ($C) = ($C->FAILGOAL($::GOAL, 'contextualizer', $goalpos))) { ($C) } else { () }

}
};
@gather;
}
}))) {
$C
} else { () }
}))
and ($C) = (scalar(do {
my $M = $C;
$::LEFTSIGIL ||= $M->{'sigil'}->Str }, $C))) {
$C->_SUBSUMEr(['O'], sub {
my $C = shift;
$C->O(%term)
})
} else { () }

});
}
;
## token circumfix:sym<( )>
sub circumfix__S_192Paren_Thesis__PEEK { $_[0]->_AUTOLEXpeek('circumfix__S_192Paren_Thesis', $retree) }
sub circumfix__S_192Paren_Thesis {
no warnings 'recursion';
my $self = shift;


local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;

my $C = $self->cursor_xact("RULE circumfix__S_192Paren_Thesis");
my $xact = $C->xact;
my $S = $C->{'_pos'};
$C->{sym} = "\(\ \)";
$self->_MATCHIFYr($S, "circumfix__S_192Paren_Thesis", do {
if (my ($C) = ($C->_BRACKETr(sub {
my $C=shift;
local $::GOAL = "\)";
my $goalpos = $C;
if (($C) = ($C->_EXACT("\("))
and ($C) = (scalar(do {
}, $C))
and ($C) = ($C->_SUBSUMEr(['semilist'], sub {
my $C = shift;
$C->semilist
}))
and ($C) = ($C->_BRACKETr(sub {
my $C=shift;
do {    my $C = $C->cursor_xact('ALT ||');
my $xact = $C->xact;
my @gather;
do {
push @gather, $C->_EXACT("\)")
}
or $xact->[-2] or
do {
push @gather, do {
if (my ($C) = ($C->FAILGOAL($::GOAL, 'parenthesized expression', $goalpos))) { ($C) } else { () }

}
};
@gather;
}
}))) {
$C
} else { () }
}))) {
$C->_SUBSUMEr(['O'], sub {
my $C = shift;
$C->O(%term)
})
} else { () }

});
}
;
## token circumfix:sym<[ ]>
sub circumfix__S_193Bra_Ket__PEEK { $_[0]->_AUTOLEXpeek('circumfix__S_193Bra_Ket', $retree) }
sub circumfix__S_193Bra_Ket {
no warnings 'recursion';
my $self = shift;


local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;

my $C = $self->cursor_xact("RULE circumfix__S_193Bra_Ket");
my $xact = $C->xact;
my $S = $C->{'_pos'};
$C->{sym} = "\[\ \]";
$self->_MATCHIFYr($S, "circumfix__S_193Bra_Ket", do {
my $C = $C;
if (($C) = ($C->_BRACKETr(sub {
my $C=shift;
local $::GOAL = "\]";
my $goalpos = $C;
if (($C) = ($C->_EXACT("\["))
and ($C) = (scalar(do {
}, $C))
and ($C) = ($C->_SUBSUMEr(['semilist'], sub {
my $C = shift;
$C->semilist
}))
and ($C) = ($C->_BRACKETr(sub {
my $C=shift;
do {    my $C = $C->cursor_xact('ALT ||');
my $xact = $C->xact;
my @gather;
do {
push @gather, $C->_EXACT("\]")
}
or $xact->[-2] or
do {
push @gather, do {
if (my ($C) = ($C->FAILGOAL($::GOAL, 'array composer', $goalpos))) { ($C) } else { () }

}
};
@gather;
}
}))) {
$C
} else { () }
}))
and ($C) = ($C->_SUBSUMEr(['O'], sub {
my $C = shift;
$C->O(%term)
}))) {
scalar(do {
$::MEMOS[$C->{'_pos'}]->{'arraycomp'} = 1}, $C)
} else { () }

});
}
;
## token PRE {
sub PRE__PEEK { $_[0]->_AUTOLEXpeek('PRE', $retree) }
sub PRE {
no warnings 'recursion';
my $self = shift;


local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;

my $C = $self->cursor_xact("RULE PRE");
my $xact = $C->xact;
my $S = $C->{'_pos'};
$C->{'prefix_postfix_meta_operator'} = [];
$self->_MATCHIFYr($S, "PRE", do {
my $C = $C;
if (($C) = ($C->_BRACKETr(sub {
my $C=shift;
do {
my ($tag, $try);
my @try;
my $relex;

my $fate;
my $x;
if ($fate = $C->{'_fate'} and $fate->[1] eq 'PRE_0') {
$C->deb("Fate passed to PRE_0: ", ::fatestr($fate)) if $::DEBUG & DEBUG::fates;
($C->{'_fate'}, $tag, $try) = @$fate;
@try = ($try);
$x = 'ALT PRE_0';    # some outer ltm is controlling us
}
else {
$x = 'ALTLTM PRE_0'; # we are top level ltm
}
my $C = $C->cursor_xact($x);
my $xact = $C->{_xact};

my @gather = ();
for (;;) {
unless (@try) {
$relex //= $C->cursor_fate('STD::P6', 'PRE_0', $retree);
@try = $relex->($C) or last;
}
$try = shift(@try) // next;

if (ref $try) {
($C->{'_fate'}, $tag, $try) = @$try;   # next candidate fate
}

$C->deb("PRE_0 trying $tag $try") if $::DEBUG & DEBUG::try_processing;
push @gather, ((
sub {
my $C=shift;
if (my ($C) = ($C->_SUBSUMEr(['prefix'], sub {
my $C = shift;
$C->prefix
}))) {
scalar(do {
my $M = $C;
$M->{'O'} = $M->{'prefix'}->{'O'};
$M->{'sym'} = $M->{'prefix'}->{'sym'} ;
}, $C)
} else { () }
},
sub {
my $C=shift;
if (my ($C) = ($C->_SUBSUMEr(['prefix_circumfix_meta_operator'], sub {
my $C = shift;
$C->prefix_circumfix_meta_operator
}))) {
scalar(do {
my $M = $C;
$M->{'O'} = $M->{'prefix_circumfix_meta_operator'}->{'O'};
$M->{'sym'} = $M->{'prefix_circumfix_meta_operator'}->Str ;
}, $C)
} else { () }
}
)[$try])->($C);
last if @gather;
last if $xact->[-2];  # committed?
}
@gather;
};
}))
and ($C) = ($C->_STARr(sub {
my $C=shift;
$C->_SUBSUMEr(['prefix_postfix_meta_operator'], sub {
my $C = shift;
$C->prefix_postfix_meta_operator
})
}))
and ($C) = ($C->ws)) {
$C
} else { () }

});
}
;
## token infixish ($in_meta = $*IN_META) {
sub infixish__PEEK { $_[0]->_AUTOLEXpeek('infixish', $retree) }
sub infixish {
no warnings 'recursion';
my $self = shift;

my $in_meta = @_ ? shift() : $::IN_META;
my $infix;local $::IN_META = $in_meta;
local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;

my $C = $self->cursor_xact("RULE infixish");
my $xact = $C->xact;
my $S = $C->{'_pos'};
$C->{'infix_postfix_meta_operator'} = [];
$self->_MATCHIFYr($S, "infixish", do {
my $C = $C;
if (($C) = ($C->_NOTBEFORE(sub {
my $C=shift;
if (my ($C) = ($C->stdstopper)) { ($C) } else { () }
}))
and ($C) = ($C->_NOTBEFORE(sub {
my $C=shift;
if (my ($C) = ($C->infixstopper)) { ($C) } else { () }
}))
and ($C) = ($C->_BRACKETr(sub {
my $C=shift;
do {
my ($tag, $try);
my @try;
my $relex;

my $fate;
my $x;
if ($fate = $C->{'_fate'} and $fate->[1] eq 'infixish_0') {
$C->deb("Fate passed to infixish_0: ", ::fatestr($fate)) if $::DEBUG & DEBUG::fates;
($C->{'_fate'}, $tag, $try) = @$fate;
@try = ($try);
$x = 'ALT infixish_0';    # some outer ltm is controlling us
}
else {
$x = 'ALTLTM infixish_0'; # we are top level ltm
}
my $C = $C->cursor_xact($x);
my $xact = $C->{_xact};

my @gather = ();
for (;;) {
unless (@try) {
$relex //= $C->cursor_fate('STD::P6', 'infixish_0', $retree);
@try = $relex->($C) or last;
}
$try = shift(@try) // next;

if (ref $try) {
($C->{'_fate'}, $tag, $try) = @$try;   # next candidate fate
}

$C->deb("infixish_0 trying $tag $try") if $::DEBUG & DEBUG::try_processing;
push @gather, ((
sub {
my $C=shift;
if (my ($C) = ($C->_SUBSUMEr(['colonpair'], sub {
my $C = shift;
$C->colonpair
}))) {
scalar(do {
my $M = $C;
$M->{'fake'} = 1;
$M->{'sym'} = ':';
$M->{'O'}->{'prec'} = $item_assignment{'prec'};
$M->{'O'}->{'assoc'} = 'unary';
$M->{'O'}->{'dba'} = 'adverb';
}, $C)
} else { () }
},
sub {
my $C=shift;
if (my ($C) = ($C->_BRACKETr(sub {
my $C=shift;
do {
my ($tag, $try);
my @try;
my $relex;

my $fate;
my $x;
if ($fate = $C->{'_fate'} and $fate->[1] eq 'infixish_1') {
$C->deb("Fate passed to infixish_1: ", ::fatestr($fate)) if $::DEBUG & DEBUG::fates;
($C->{'_fate'}, $tag, $try) = @$fate;
@try = ($try);
$x = 'ALT infixish_1';    # some outer ltm is controlling us
}
else {
$x = 'ALTLTM infixish_1'; # we are top level ltm
}
my $C = $C->cursor_xact($x);
my $xact = $C->{_xact};

my @gather = ();
for (;;) {
unless (@try) {
$relex //= $C->cursor_fate('STD::P6', 'infixish_1', $retree);
@try = $relex->($C) or last;
}
$try = shift(@try) // next;

if (ref $try) {
($C->{'_fate'}, $tag, $try) = @$try;   # next candidate fate
}

$C->deb("infixish_1 trying $tag $try") if $::DEBUG & DEBUG::try_processing;
push @gather, ((
sub {
my $C=shift;
if (my ($C) = ($C->_BRACKETr(sub {
my $C=shift;
local $::GOAL = "\]";
my $goalpos = $C;
if (($C) = ($C->_EXACT("\["))
and ($C) = (scalar(do {
}, $C))
and ($C) = ($C->_SUBSUMEr(['infix'], sub {
my $C = shift;
$C->infixish('[]')
}))
and ($C) = ($C->_BRACKETr(sub {
my $C=shift;
do {    my $C = $C->cursor_xact('ALT ||');
my $xact = $C->xact;
my @gather;
do {
push @gather, $C->_EXACT("\]")
}
or $xact->[-2] or
do {
push @gather, do {
if (my ($C) = ($C->FAILGOAL($::GOAL, 'bracketed infix', $goalpos))) { ($C) } else { () }

}
};
@gather;
}
}))) {
$C
} else { () }
}))) {
scalar(do {
my $M = $C;
$M->{'O'} = $M->{'infix'}->{'O'};
$M->{'sym'} = $M->{'infix'}->{'sym'};
}, $C)
} else { () }
},
sub {
my $C=shift;
if (my ($C) = ($C->_SUBSUMEr(['infix','infix_circumfix_meta_operator'], sub {
my $C = shift;
$C->infix_circumfix_meta_operator
}))) {
scalar(do {
my $M = $C;
$M->{'O'} = $M->{'infix'}->{'O'};
$M->{'sym'} = $M->{'infix'}->{'sym'};
}, $C)
} else { () }
},
sub {
my $C=shift;
if (my ($C) = ($C->_SUBSUMEr(['infix','infix_prefix_meta_operator'], sub {
my $C = shift;
$C->infix_prefix_meta_operator
}))) {
scalar(do {
my $M = $C;
$M->{'O'} = $M->{'infix'}->{'O'};
$M->{'sym'} = $M->{'infix'}->{'sym'};
}, $C)
} else { () }
},
sub {
my $C=shift;
if (my ($C) = ($C->_SUBSUMEr(['infix'], sub {
my $C = shift;
$C->infix
}))) {
scalar(do {
my $M = $C;
$M->{'O'} = $M->{'infix'}->{'O'};
$M->{'sym'} = $M->{'infix'}->{'sym'};
}, $C)
} else { () }
},
sub {
my $C=shift;
if (($C) = (scalar(do {
}, $C))
and ($C) = ($C->before(sub {
my $C=shift;
if (my ($C) = ($C->dotty)) { ($C) } else { () }
}))
and ($C) = ($C->panic("Method call found where infix expected (omit whitespace?)"))) {
$C
} else { () }
},
sub {
my $C=shift;
if (($C) = (scalar(do {
}, $C))
and ($C) = ($C->before(sub {
my $C=shift;
if (my ($C) = ($C->postfix)) { ($C) } else { () }
}))
and ($C) = ($C->panic("Postfix found where infix expected (omit whitespace?)"))) {
$C
} else { () }
}
)[$try])->($C);
last if @gather;
last if $xact->[-2];  # committed?
}
@gather;
};
}))) {
$C->_OPTr(sub {
my $C=shift;
if (my ($C) = ($C->_BRACKETr(sub {
my $C=shift;
if (($C) = ($C->before(sub {
my $C=shift;
if (my ($C) = ($C->before(sub {
my $C=shift;
$C->_EXACT("\=")
}))) { ($C) } else { () }
}))
and ($C) = ($C->before(sub {
my $C=shift;
(($C) x !!do {
my $M = $C;
$infix = $M->{'infix'}})
}))
and ($C) = ($C->_SUBSUMEr(['infix_postfix_meta_operator'], sub {
my $C = shift;
$C->infix_postfix_meta_operator($infix)
}))) {
scalar(do {
my $M = $C;
$M->{'O'} = $M->{'infix_postfix_meta_operator'}->[0]->{'O'};
$M->{'sym'} = $M->{'infix_postfix_meta_operator'}->[0]->{'sym'};
}, $C)
} else { () }
}))) { ($C) } else { () }
})
} else { () }
}
)[$try])->($C);
last if @gather;
last if $xact->[-2];  # committed?
}
@gather;
};
}))) {
$C
} else { () }

});
}
;
## token dotty:sym<.*> {
sub dotty__S_194DotStar__PEEK { $_[0]->_AUTOLEXpeek('dotty__S_194DotStar', $retree) }
sub dotty__S_194DotStar {
no warnings 'recursion';
my $self = shift;

;

local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;

my $C = $self->cursor_xact("RULE dotty__S_194DotStar");
my $xact = $C->xact;
my $S = $C->{'_pos'};
$C->{sym} = "\.\*";
$self->_MATCHIFYr($S, "dotty__S_194DotStar", do {
my $C = $C;
if (($C) = ($C->_SUBSUMEr(['0'], sub {
my $C = shift;
$C->_PAREN( sub {
my $C=shift;
do {
my $C = $C;
if (($C) = ($C->_EXACT("\."))
and ($C) = ($C->_BRACKETr(sub {
my $C=shift;
do {
my ($tag, $try);
my @try;
my $relex;

my $fate;
my $x;
if ($fate = $C->{'_fate'} and $fate->[1] eq 'dotty__S_194DotStar_0') {
$C->deb("Fate passed to dotty__S_194DotStar_0: ", ::fatestr($fate)) if $::DEBUG & DEBUG::fates;
($C->{'_fate'}, $tag, $try) = @$fate;
@try = ($try);
$x = 'ALT dotty__S_194DotStar_0';    # some outer ltm is controlling us
}
else {
$x = 'ALTLTM dotty__S_194DotStar_0'; # we are top level ltm
}
my $C = $C->cursor_xact($x);
my $xact = $C->{_xact};

my @gather = ();
for (;;) {
unless (@try) {
$relex //= $C->cursor_fate('STD::P6', 'dotty__S_194DotStar_0', $retree);
@try = $relex->($C) or last;
}
$try = shift(@try) // next;

if (ref $try) {
($C->{'_fate'}, $tag, $try) = @$try;   # next candidate fate
}

$C->deb("dotty__S_194DotStar_0 trying $tag $try") if $::DEBUG & DEBUG::try_processing;
push @gather, ((
sub {
my $C=shift;
$C->_PATTERN(qr/\G[+*?=]/)
},
sub {
my $C=shift;
$C->_PATTERN(qr/\G\^\!?+/)
}
)[$try])->($C);
last if @gather;
last if $xact->[-2];  # committed?
}
@gather;
};
}))) {
$C
} else { () }
};

})
}))
and ($C) = ($C->_COMMITLTM())
and ($C) = ($C->unspacey)
and ($C) = ($C->_SUBSUMEr(['dottyop'], sub {
my $C = shift;
$C->dottyop
}))
and ($C) = (scalar(do {
my $M = $C;
$M->{'sym'} = $M->{0}->Str}, $C))) {
$C->_SUBSUMEr(['O'], sub {
my $C = shift;
$C->O(%methodcall)
})
} else { () }

});
}
;
## token dotty:sym<.> {
sub dotty__S_195Dot__PEEK { $_[0]->_AUTOLEXpeek('dotty__S_195Dot', $retree) }
sub dotty__S_195Dot {
no warnings 'recursion';
my $self = shift;

;

local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;

my $C = $self->cursor_xact("RULE dotty__S_195Dot");
my $xact = $C->xact;
my $S = $C->{'_pos'};
$C->{sym} = "\.";
$self->_MATCHIFYr($S, "dotty__S_195Dot", do {
my $C = $C;
if (($C) = ($C->_EXACT("\."))
and ($C) = ($C->unspacey)
and ($C) = ($C->_SUBSUMEr(['dottyop'], sub {
my $C = shift;
$C->dottyop
}))) {
$C->_SUBSUMEr(['O'], sub {
my $C = shift;
$C->O(%methodcall)
})
} else { () }

});
}
;
## token privop {
sub privop__PEEK { $_[0]->_AUTOLEXpeek('privop', $retree) }
sub privop {
no warnings 'recursion';
my $self = shift;


local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;

my $C = $self->cursor_xact("RULE privop");
my $xact = $C->xact;
my $S = $C->{'_pos'};
$self->_MATCHIFYr($S, "privop", do {
my $C = $C;
if (($C) = ($C->_EXACT("\!"))
and ($C) = ($C->_SUBSUMEr(['methodop'], sub {
my $C = shift;
$C->methodop
}))) {
$C->_SUBSUMEr(['O'], sub {
my $C = shift;
$C->O(%methodcall)
})
} else { () }

});
}
;
## token dottyopish {
sub dottyopish__PEEK { $_[0]->_AUTOLEXpeek('dottyopish', $retree) }
sub dottyopish {
no warnings 'recursion';
my $self = shift;


local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;

my $C = $self->cursor_xact("RULE dottyopish");
my $xact = $C->xact;
my $S = $C->{'_pos'};
$self->_MATCHIFYr($S, "dottyopish", $C->_SUBSUMEr(['term'], sub {
my $C = shift;
$C->dottyop
}));
}
;
## token dottyop {
sub dottyop__PEEK { $_[0]->_AUTOLEXpeek('dottyop', $retree) }
sub dottyop {
no warnings 'recursion';
my $self = shift;


local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;

my $C = $self->cursor_xact("RULE dottyop");
my $xact = $C->xact;
my $S = $C->{'_pos'};
$self->_MATCHIFYr($S, "dottyop", $C->_BRACKETr(sub {
my $C=shift;
do {
my ($tag, $try);
my @try;
my $relex;

my $fate;
my $x;
if ($fate = $C->{'_fate'} and $fate->[1] eq 'dottyop_0') {
$C->deb("Fate passed to dottyop_0: ", ::fatestr($fate)) if $::DEBUG & DEBUG::fates;
($C->{'_fate'}, $tag, $try) = @$fate;
@try = ($try);
$x = 'ALT dottyop_0';    # some outer ltm is controlling us
}
else {
$x = 'ALTLTM dottyop_0'; # we are top level ltm
}
my $C = $C->cursor_xact($x);
my $xact = $C->{_xact};

my @gather = ();
for (;;) {
unless (@try) {
$relex //= $C->cursor_fate('STD::P6', 'dottyop_0', $retree);
@try = $relex->($C) or last;
}
$try = shift(@try) // next;

if (ref $try) {
($C->{'_fate'}, $tag, $try) = @$try;   # next candidate fate
}

$C->deb("dottyop_0 trying $tag $try") if $::DEBUG & DEBUG::try_processing;
push @gather, ((
sub {
my $C=shift;
$C->_SUBSUMEr(['methodop'], sub {
my $C = shift;
$C->methodop
})
},
sub {
my $C=shift;
$C->_SUBSUMEr(['colonpair'], sub {
my $C = shift;
$C->colonpair
})
},
sub {
my $C=shift;
if (($C) = ($C->_NOTBEFORE(sub {
my $C=shift;
$C->_PATTERN(qr/\G[_[:alpha:]]/)
}))
and ($C) = ($C->_SUBSUMEr(['postop'], sub {
my $C = shift;
$C->postop
}))) {
scalar(do {
my $M = $C;
$M->{'O'} = $M->{'postop'}->{'O'};
$M->{'sym'} = $M->{'postop'}->{'sym'};
}, $C)
} else { () }
}
)[$try])->($C);
last if @gather;
last if $xact->[-2];  # committed?
}
@gather;
};
}));
}
;
## token POST {
sub POST__PEEK { $_[0]->_AUTOLEXpeek('POST', $retree) }
sub POST {
no warnings 'recursion';
my $self = shift;


local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;

my $C = $self->cursor_xact("RULE POST");
my $xact = $C->xact;
my $S = $C->{'_pos'};
$C->{'postfix_prefix_meta_operator'} = [];
$self->_MATCHIFYr($S, "POST", do {
my $C = $C;
if (($C) = ($C->_NOTBEFORE(sub {
my $C=shift;
if (my ($C) = ($C->stdstopper)) { ($C) } else { () }
}))
and ($C) = ($C->_NOTBEFORE(sub {
my $C=shift;
(($C) x !!do {
$::MEMOS[$C->{'_pos'}]->{'ws'} })
}))
and ($C) = ($C->_OPTr(sub {
my $C=shift;
if (my ($C) = ($C->_BRACKETr(sub {
my $C=shift;
do {
my ($tag, $try);
my @try;
my $relex;

my $fate;
my $x;
if ($fate = $C->{'_fate'} and $fate->[1] eq 'POST_0') {
$C->deb("Fate passed to POST_0: ", ::fatestr($fate)) if $::DEBUG & DEBUG::fates;
($C->{'_fate'}, $tag, $try) = @$fate;
@try = ($try);
$x = 'ALT POST_0';    # some outer ltm is controlling us
}
else {
$x = 'ALTLTM POST_0'; # we are top level ltm
}
my $C = $C->cursor_xact($x);
my $xact = $C->{_xact};

my @gather = ();
for (;;) {
unless (@try) {
$relex //= $C->cursor_fate('STD::P6', 'POST_0', $retree);
@try = $relex->($C) or last;
}
$try = shift(@try) // next;

if (ref $try) {
($C->{'_fate'}, $tag, $try) = @$try;   # next candidate fate
}

$C->deb("POST_0 trying $tag $try") if $::DEBUG & DEBUG::try_processing;
push @gather, ((
sub {
my $C=shift;
if (my ($C) = ($C->unsp)) { ($C) } else { () }
},
sub {
my $C=shift;
$C->_EXACT("\\")
}
)[$try])->($C);
last if @gather;
last if $xact->[-2];  # committed?
}
@gather;
};
}))) { ($C) } else { () }
}))
and ($C) = ($C->_STARr(sub {
my $C=shift;
if (my ($C) = ($C->_BRACKETr(sub {
my $C=shift;
if (($C) = ($C->_OPTr(sub {
my $C=shift;
if (my ($C) = ($C->_BRACKETr(sub {
my $C=shift;
if (my ($C) = ($C->_EXACT("\."))) {
$C->_OPTr(sub {
my $C=shift;
if (my ($C) = ($C->unsp)) { ($C) } else { () }
})
} else { () }
}))) { ($C) } else { () }
}))
and ($C) = ($C->_SUBSUMEr(['postfix_prefix_meta_operator'], sub {
my $C = shift;
$C->postfix_prefix_meta_operator
}))) {
$C->_OPTr(sub {
my $C=shift;
if (my ($C) = ($C->unsp)) { ($C) } else { () }
})
} else { () }
}))) { ($C) } else { () }
}))
and ($C) = ($C->_BRACKETr(sub {
my $C=shift;
do {
my ($tag, $try);
my @try;
my $relex;

my $fate;
my $x;
if ($fate = $C->{'_fate'} and $fate->[1] eq 'POST_1') {
$C->deb("Fate passed to POST_1: ", ::fatestr($fate)) if $::DEBUG & DEBUG::fates;
($C->{'_fate'}, $tag, $try) = @$fate;
@try = ($try);
$x = 'ALT POST_1';    # some outer ltm is controlling us
}
else {
$x = 'ALTLTM POST_1'; # we are top level ltm
}
my $C = $C->cursor_xact($x);
my $xact = $C->{_xact};

my @gather = ();
for (;;) {
unless (@try) {
$relex //= $C->cursor_fate('STD::P6', 'POST_1', $retree);
@try = $relex->($C) or last;
}
$try = shift(@try) // next;

if (ref $try) {
($C->{'_fate'}, $tag, $try) = @$try;   # next candidate fate
}

$C->deb("POST_1 trying $tag $try") if $::DEBUG & DEBUG::try_processing;
push @gather, ((
sub {
my $C=shift;
if (my ($C) = ($C->_SUBSUMEr(['dotty'], sub {
my $C = shift;
$C->dotty
}))) {
scalar(do {
my $M = $C;
$M->{'O'} = $M->{'dotty'}->{'O'};
$M->{'sym'} = $M->{'dotty'}->{'sym'};
$M->{'~CAPS'} = $M->{'dotty'}->{'~CAPS'};
}, $C)
} else { () }
},
sub {
my $C=shift;
if (my ($C) = ($C->_SUBSUMEr(['privop'], sub {
my $C = shift;
$C->privop
}))) {
scalar(do {
my $M = $C;
$M->{'O'} = $M->{'privop'}->{'O'};
$M->{'sym'} = $M->{'privop'}->{'sym'};
$M->{'~CAPS'} = $M->{'privop'}->{'~CAPS'};
}, $C)
} else { () }
},
sub {
my $C=shift;
if (my ($C) = ($C->_SUBSUMEr(['postop'], sub {
my $C = shift;
$C->postop
}))) {
scalar(do {
my $M = $C;
$M->{'O'} = $M->{'postop'}->{'O'};
$M->{'sym'} = $M->{'postop'}->{'sym'};
$M->{'~CAPS'} = $M->{'postop'}->{'~CAPS'};
}, $C)
} else { () }
}
)[$try])->($C);
last if @gather;
last if $xact->[-2];  # committed?
}
@gather;
};
}))) {
scalar(do {
$::LEFTSIGIL = '@'}, $C)
} else { () }

});
}
;
## method can_meta ($op, $meta)
sub can_meta {
no warnings 'recursion';
my $self = shift;
die 'Required argument op omitted' unless @_;
my $op = @_ ? shift() : undef;
die 'Required argument meta omitted' unless @_;
my $meta = @_ ? shift() : undef;
!$op->{'O'}->{'fiddly'} ||
$self->sorry("Can't " . $meta . " " . $op->{'sym'} . " because " . $op->{'O'}->{'dba'} . " operators are too fiddly");
$self;
};
## regex prefix_circumfix_meta_operator:reduce {
sub prefix_circumfix_meta_operator__S_196reduce__PEEK { $_[0]->_AUTOLEXpeek('prefix_circumfix_meta_operator__S_196reduce', $retree) }
sub prefix_circumfix_meta_operator__S_196reduce {
no warnings 'recursion';
my $self = shift;

local $::IN_REDUCE = 1;my $op;
local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;

my $C = $self->cursor_xact("RULE prefix_circumfix_meta_operator__S_196reduce");
my $xact = $C->xact;
my $S = $C->{'_pos'};
$C->{sym} = "reduce";
$self->_MATCHIFY($S, "prefix_circumfix_meta_operator__S_196reduce", LazyMap::lazymap(sub {
my $C=shift;
LazyMap::lazymap(sub {
my $C=shift;
if (my ($C) = (scalar(do {
my $M = $C;
$op = $M->{'s'}->{'op'}}, $C))) {
LazyMap::lazymap(sub {
my $C=shift;
LazyMap::lazymap(sub {
my $C=shift;
LazyMap::lazymap(sub {
my $C=shift;
if (my ($C) = (scalar(do {
my $M = $C;
$M->{'sym'} = $M->{'s'}->Str}, $C))) {
$C->_BRACKET(sub {
my $C=shift;
do {    my $C = $C->cursor_xact('ALT ||');
my $xact = $C->xact;
my @gather;
do {
push @gather, $C->before(sub {
my $C=shift;
$C->_EXACT("\(")
})
}
or $xact->[-2] or
do {
push @gather, $C->before(sub {
my $C=shift;
LazyMap::lazymap(sub {
my $C=shift;
$C->_OPTg(sub {
my $C=shift;
$C->_BRACKET(sub {
my $C=shift;
LazyMap::lazymap(sub {
my $C=shift;
scalar(do {
my $M = $C;
$M->{'O'}->{'term'} = 1 }, $C)
},
$C->before(sub {
my $C=shift;
$C->stdstopper
}))
})
})
},
$C->_PLUSg(sub {
my $C=shift;
$C->_PATTERN(qr/\G\s/)
}))
})
}
or $xact->[-2] or
do {
push @gather, scalar(do {
my $M = $C;
$M->{'O'}->{'term'} = 1 }, $C)
};
@gather;
}
})
} else { () }
},
$C->_SUBSUME(['O'], sub {
my $C = shift;
$C->O($op->Opairs, %list_prefix, assoc => 'unary', uassoc => 'left')
}))
},
$C->_BRACKET(sub {
my $C=shift;
do {    my $C = $C->cursor_xact('ALT ||');
my $xact = $C->xact;
my @gather;
do {
push @gather, $C->_NOTBEFORE(sub {
my $C=shift;
(($C) x !!do {
$op->{'O'}->{'diffy'} })
})
}
or $xact->[-2] or
do {
push @gather, $C->before(sub {
my $C=shift;
(($C) x !!do {
$op->{'O'}->{'assoc'} eq 'chain' })
})
}
or $xact->[-2] or
do {
push @gather, $C->sorry("Can't reduce with " . $op->{'sym'} . " because " . $op->{'O'}->{'dba'} . " operators are diffy and not chaining")
};
@gather;
}
}))
},
$C->can_meta($op, "reduce with"))
} else { () }
},
$C->_SUBSUME(['s'], sub {
my $C = shift;
$C->_PAREN( sub {
my $C=shift;
if (my ($C) = ($C->_EXACT("\["))) {
LazyMap::lazymap(sub {
my $C=shift;
if (my ($C) = ($C->_EXACT("\]"))) {
$C->_BRACKET(sub {
my $C=shift;
do {
my ($tag, $try);
my @try;
my $relex;

my $fate;
my $x;
if ($fate = $C->{'_fate'} and $fate->[1] eq 'prefix_circumfix_meta_operator__S_196reduce_0') {
$C->deb("Fate passed to prefix_circumfix_meta_operator__S_196reduce_0: ", ::fatestr($fate)) if $::DEBUG & DEBUG::fates;
($C->{'_fate'}, $tag, $try) = @$fate;
@try = ($try);
$x = 'ALT prefix_circumfix_meta_operator__S_196reduce_0';    # some outer ltm is controlling us
}
else {
$x = 'ALTLTM prefix_circumfix_meta_operator__S_196reduce_0'; # we are top level ltm
}
my $C = $C->cursor_xact($x);
my $xact = $C->{_xact};

my @gather = ();
for (;;) {
unless (@try) {
$relex //= $C->cursor_fate('STD::P6', 'prefix_circumfix_meta_operator__S_196reduce_0', $retree);
@try = $relex->($C) or last;
}
$try = shift(@try) // next;

if (ref $try) {
($C->{'_fate'}, $tag, $try) = @$try;   # next candidate fate
}

$C->deb("prefix_circumfix_meta_operator__S_196reduce_0 trying $tag $try") if $::DEBUG & DEBUG::try_processing;
push @gather, ((
sub {
my $C=shift;
$C->_EXACT("«")
},
sub {
my $C=shift;
$C->before(sub {
my $C=shift;
$C
})
}
)[$try])->($C);
last if @gather;
last if $xact->[-2];  # committed?
}
@gather;
};
})
} else { () }
},
$C->_BRACKET(sub {
my $C=shift;
do {    my $C = $C->cursor_xact('ALT ||');
my $xact = $C->xact;
my @gather;
do {
push @gather, LazyMap::lazymap(sub {
my $C=shift;
$C->before(sub {
my $C=shift;
$C->_EXACT("\]")
})
},
$C->_SUBSUME(['op'], sub {
my $C = shift;
$C->infixish('red')
}))
}
or $xact->[-2] or
do {
push @gather, do {
if (my ($C) = ($C->_EXACT("\\"))) {
LazyMap::lazymap(sub {
my $C=shift;
$C->before(sub {
my $C=shift;
$C->_EXACT("\]")
})
},
$C->_SUBSUME(['op'], sub {
my $C = shift;
$C->infixish('tri')
}))
} else { () }

}
}
or $xact->[-2] or
do {
push @gather, $C->_NOTBEFORE(sub {
my $C=shift;
$C
})
};
@gather;
}
}))
} else { () }

})
}))
},
$C->before(sub {
my $C=shift;
if (my ($C) = ($C->_EXACT("\["))) {
LazyMap::lazymap(sub {
my $C=shift;
$C->_EXACT("\]")
},
$C->_PLUSg(sub {
my $C=shift;
$C->_PATTERN(qr/\G\S/)
}))
} else { () }
})));
}
;
## token prefix_postfix_meta_operator:sym< « >    { <sym> | '<<' }
sub prefix_postfix_meta_operator__S_197Fre__PEEK { $_[0]->_AUTOLEXpeek('prefix_postfix_meta_operator__S_197Fre', $retree) }
sub prefix_postfix_meta_operator__S_197Fre {
no warnings 'recursion';
my $self = shift;


local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;

my $C = $self->cursor_xact("RULE prefix_postfix_meta_operator__S_197Fre");
my $xact = $C->xact;
my $S = $C->{'_pos'};
$C->{sym} = "«";
$self->_MATCHIFYr($S, "prefix_postfix_meta_operator__S_197Fre", do {
do {
my ($tag, $try);
my @try;
my $relex;

my $fate;
my $x;
if ($fate = $C->{'_fate'} and $fate->[1] eq 'prefix_postfix_meta_operator__S_197Fre_0') {
$C->deb("Fate passed to prefix_postfix_meta_operator__S_197Fre_0: ", ::fatestr($fate)) if $::DEBUG & DEBUG::fates;
($C->{'_fate'}, $tag, $try) = @$fate;
@try = ($try);
$x = 'ALT prefix_postfix_meta_operator__S_197Fre_0';    # some outer ltm is controlling us
}
else {
$x = 'ALTLTM prefix_postfix_meta_operator__S_197Fre_0'; # we are top level ltm
}
my $C = $C->cursor_xact($x);
my $xact = $C->{_xact};

my @gather = ();
for (;;) {
unless (@try) {
$relex //= $C->cursor_fate('STD::P6', 'prefix_postfix_meta_operator__S_197Fre_0', $retree);
@try = $relex->($C) or last;
}
$try = shift(@try) // next;

if (ref $try) {
($C->{'_fate'}, $tag, $try) = @$try;   # next candidate fate
}

$C->deb("prefix_postfix_meta_operator__S_197Fre_0 trying $tag $try") if $::DEBUG & DEBUG::try_processing;
push @gather, ((
sub {
my $C=shift;
$C->_EXACT("«")
},
sub {
my $C=shift;
$C->_EXACT("\<\<")
}
)[$try])->($C);
last if @gather;
last if $xact->[-2];  # committed?
}
@gather;
};

});
}
;
## token postfix_prefix_meta_operator:sym< » >    {
sub postfix_prefix_meta_operator__S_198Nch__PEEK { $_[0]->_AUTOLEXpeek('postfix_prefix_meta_operator__S_198Nch', $retree) }
sub postfix_prefix_meta_operator__S_198Nch {
no warnings 'recursion';
my $self = shift;


local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;

my $C = $self->cursor_xact("RULE postfix_prefix_meta_operator__S_198Nch");
my $xact = $C->xact;
my $S = $C->{'_pos'};
$C->{sym} = "»";
$self->_MATCHIFYr($S, "postfix_prefix_meta_operator__S_198Nch", do {
my $C = $C;
if (($C) = ($C->_BRACKETr(sub {
my $C=shift;
do {
my ($tag, $try);
my @try;
my $relex;

my $fate;
my $x;
if ($fate = $C->{'_fate'} and $fate->[1] eq 'postfix_prefix_meta_operator__S_198Nch_0') {
$C->deb("Fate passed to postfix_prefix_meta_operator__S_198Nch_0: ", ::fatestr($fate)) if $::DEBUG & DEBUG::fates;
($C->{'_fate'}, $tag, $try) = @$fate;
@try = ($try);
$x = 'ALT postfix_prefix_meta_operator__S_198Nch_0';    # some outer ltm is controlling us
}
else {
$x = 'ALTLTM postfix_prefix_meta_operator__S_198Nch_0'; # we are top level ltm
}
my $C = $C->cursor_xact($x);
my $xact = $C->{_xact};

my @gather = ();
for (;;) {
unless (@try) {
$relex //= $C->cursor_fate('STD::P6', 'postfix_prefix_meta_operator__S_198Nch_0', $retree);
@try = $relex->($C) or last;
}
$try = shift(@try) // next;

if (ref $try) {
($C->{'_fate'}, $tag, $try) = @$try;   # next candidate fate
}

$C->deb("postfix_prefix_meta_operator__S_198Nch_0 trying $tag $try") if $::DEBUG & DEBUG::try_processing;
push @gather, ((
sub {
my $C=shift;
$C->_EXACT("»")
},
sub {
my $C=shift;
$C->_EXACT("\>\>")
}
)[$try])->($C);
last if @gather;
last if $xact->[-2];  # committed?
}
@gather;
};
}))
and ($C) = ($C->_BRACKETr(sub {
my $C=shift;
do {    my $C = $C->cursor_xact('ALT ||');
my $xact = $C->xact;
my @gather;
do {
push @gather, do {
if (my ($C) = ($C->_NOTBEFORE(sub {
my $C=shift;
(($C) x !!do {
$::QSIGIL })
}))) { ($C) } else { () }

}
}
or $xact->[-2] or
do {
push @gather, do {
if (my ($C) = ($C->_NOTBEFORE(sub {
my $C=shift;
if (my ($C) = ($C->before(sub {
my $C=shift;
$C->_EXACT("\(")
}))) { ($C) } else { () }
}))) { ($C) } else { () }

}
};
@gather;
}
}))) {
$C
} else { () }

});
}
;
## token infix_prefix_meta_operator:sym<!> {
sub infix_prefix_meta_operator__S_199Bang__PEEK { $_[0]->_AUTOLEXpeek('infix_prefix_meta_operator__S_199Bang', $retree) }
sub infix_prefix_meta_operator__S_199Bang {
no warnings 'recursion';
my $self = shift;


local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;

my $C = $self->cursor_xact("RULE infix_prefix_meta_operator__S_199Bang");
my $xact = $C->xact;
my $S = $C->{'_pos'};
$C->{sym} = "\!";
$self->_MATCHIFYr($S, "infix_prefix_meta_operator__S_199Bang", do {
my $C = $C;
if (($C) = ($C->_EXACT("\!"))
and ($C) = ($C->_NOTBEFORE(sub {
my $C=shift;
if (my ($C) = ($C->before(sub {
my $C=shift;
$C->_EXACT("\!")
}))) { ($C) } else { () }
}))
and ($C) = (scalar(do {
}, $C))
and ($C) = ($C->_BRACKETr(sub {
my $C=shift;
do {    my $C = $C->cursor_xact('ALT ||');
my $xact = $C->xact;
my @gather;
do {
push @gather, $C->_SUBSUMEr(['infixish'], sub {
my $C = shift;
$C->infixish('neg')
})
}
or $xact->[-2] or
do {
push @gather, do {
if (my ($C) = ($C->panic("Negation metaoperator not followed by valid infix"))) { ($C) } else { () }

}
};
@gather;
}
}))
and ($C) = ($C->_BRACKETr(sub {
my $C=shift;
do {    my $C = $C->cursor_xact('ALT ||');
my $xact = $C->xact;
my @gather;
do {
push @gather, do {
if (my ($C) = ($C->before(sub {
my $C=shift;
(($C) x !!do {
my $M = $C;
$M->{'infixish'}->Str eq '=' })
}))) {
$C->_SUBSUMEr(['O'], sub {
my $C = shift;
$C->O(%chaining)
})
} else { () }

}
}
or $xact->[-2] or
do {
push @gather, do {
my $C = $C;
if (($C) = (do {
my $M = $C;
$C->can_meta($M->{'infixish'}, "negate")
})
and ($C) = ($C->before(sub {
my $C=shift;
(($C) x !!do {
my $M = $C;
$M->{'infixish'}->{'O'}->{'iffy'} })
}))
and ($C) = ($C->before(sub {
my $C=shift;
(($C) x !!do {
my $M = $C;
$M->{'O'} = $M->{'infixish'}->{'O'}})
}))) {
$C
} else { () }

}
}
or $xact->[-2] or
do {
push @gather, do {
if (my ($C) = (do {
my $M = $C;
$C->panic("Can't negate " . $M->{'infixish'}->Str . " because " . $M->{'infixish'}->{'O'}->{'dba'} . " operators are not iffy enough")
})) { ($C) } else { () }

}
};
@gather;
}
}))) {
$C
} else { () }

});
}
;
## token infix_prefix_meta_operator:sym<R> {
sub infix_prefix_meta_operator__S_200R__PEEK { $_[0]->_AUTOLEXpeek('infix_prefix_meta_operator__S_200R', $retree) }
sub infix_prefix_meta_operator__S_200R {
no warnings 'recursion';
my $self = shift;


local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;

my $C = $self->cursor_xact("RULE infix_prefix_meta_operator__S_200R");
my $xact = $C->xact;
my $S = $C->{'_pos'};
$C->{sym} = "R";
$self->_MATCHIFYr($S, "infix_prefix_meta_operator__S_200R", do {
my $C = $C;
if (($C) = ($C->_EXACT("R"))
and ($C) = (scalar(do {
}, $C))
and ($C) = ($C->_SUBSUMEr(['infixish'], sub {
my $C = shift;
$C->infixish('R')
}))
and ($C) = (do {
my $M = $C;
$C->can_meta($M->{'infixish'}, "reverse the args of")
})
and ($C) = ($C->before(sub {
my $C=shift;
(($C) x !!do {
my $M = $C;
$M->{'O'} = $M->{'infixish'}->{'O'}})
}))) {
$C
} else { () }

});
}
;
## token infix_prefix_meta_operator:sym<S> {
sub infix_prefix_meta_operator__S_201S__PEEK { $_[0]->_AUTOLEXpeek('infix_prefix_meta_operator__S_201S', $retree) }
sub infix_prefix_meta_operator__S_201S {
no warnings 'recursion';
my $self = shift;


local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;

my $C = $self->cursor_xact("RULE infix_prefix_meta_operator__S_201S");
my $xact = $C->xact;
my $S = $C->{'_pos'};
$C->{sym} = "S";
$self->_MATCHIFYr($S, "infix_prefix_meta_operator__S_201S", do {
my $C = $C;
if (($C) = ($C->_EXACT("S"))
and ($C) = (scalar(do {
}, $C))
and ($C) = ($C->_SUBSUMEr(['infixish'], sub {
my $C = shift;
$C->infixish('S')
}))
and ($C) = (do {
my $M = $C;
$C->can_meta($M->{'infixish'}, "sequence the args of")
})
and ($C) = ($C->before(sub {
my $C=shift;
(($C) x !!do {
my $M = $C;
$M->{'O'} = $M->{'infixish'}->{'O'}})
}))) {
$C
} else { () }

});
}
;
## token infix_prefix_meta_operator:sym<X> {
sub infix_prefix_meta_operator__S_202X__PEEK { $_[0]->_AUTOLEXpeek('infix_prefix_meta_operator__S_202X', $retree) }
sub infix_prefix_meta_operator__S_202X {
no warnings 'recursion';
my $self = shift;


local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;

my $C = $self->cursor_xact("RULE infix_prefix_meta_operator__S_202X");
my $xact = $C->xact;
my $S = $C->{'_pos'};
$C->{'infixish'} = [];
$C->{sym} = "X";
$self->_MATCHIFYr($S, "infix_prefix_meta_operator__S_202X", do {
my $C = $C;
if (($C) = ($C->_EXACT("X"))
and ($C) = ($C->before(sub {
my $C=shift;
if (my ($C) = ($C->before(sub {
my $C=shift;
$C->_PATTERN(qr/\G\S/)
}))) { ($C) } else { () }
}))
and ($C) = (scalar(do {
}, $C))
and ($C) = ($C->_OPTr(sub {
my $C=shift;
if (my ($C) = ($C->_BRACKETr(sub {
my $C=shift;
if (($C) = ($C->_SUBSUMEr(['infixish'], sub {
my $C = shift;
$C->infixish('X')
}))
and ($C) = (do {
my $M = $C;
$C->can_meta($M->{'infixish'}->[0], "cross with")
})
and ($C) = ($C->before(sub {
my $C=shift;
(($C) x !!do {
my $M = $C;
$M->{'O'} = $M->{'infixish'}->[0]->{'O'};
delete $M->{'O'}->{'prec'};
$M->{'sym'} .= $M->{'infixish'}->[0]->Str ;
})
}))) {
$C
} else { () }
}))) { ($C) } else { () }
}))) {
$C->_SUBSUMEr(['O'], sub {
my $C = shift;
$C->O(%list_infix, $self->Opairs)
})
} else { () }

});
}
;
## token infix_prefix_meta_operator:sym<Z> {
sub infix_prefix_meta_operator__S_203Z__PEEK { $_[0]->_AUTOLEXpeek('infix_prefix_meta_operator__S_203Z', $retree) }
sub infix_prefix_meta_operator__S_203Z {
no warnings 'recursion';
my $self = shift;


local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;

my $C = $self->cursor_xact("RULE infix_prefix_meta_operator__S_203Z");
my $xact = $C->xact;
my $S = $C->{'_pos'};
$C->{'infixish'} = [];
$C->{sym} = "Z";
$self->_MATCHIFYr($S, "infix_prefix_meta_operator__S_203Z", do {
my $C = $C;
if (($C) = ($C->_EXACT("Z"))
and ($C) = ($C->before(sub {
my $C=shift;
if (my ($C) = ($C->before(sub {
my $C=shift;
$C->_PATTERN(qr/\G\S/)
}))) { ($C) } else { () }
}))
and ($C) = (scalar(do {
}, $C))
and ($C) = ($C->_OPTr(sub {
my $C=shift;
if (my ($C) = ($C->_BRACKETr(sub {
my $C=shift;
if (($C) = ($C->_SUBSUMEr(['infixish'], sub {
my $C = shift;
$C->infixish('Z')
}))
and ($C) = (do {
my $M = $C;
$C->can_meta($M->{'infixish'}->[0], "zip with")
})
and ($C) = ($C->before(sub {
my $C=shift;
(($C) x !!do {
my $M = $C;
$M->{'O'} = $M->{'infixish'}->[0]->{'O'};
delete $M->{'O'}->{'prec'};
$M->{'sym'} .= $M->{'infixish'}->[0]->Str ;
})
}))) {
$C
} else { () }
}))) { ($C) } else { () }
}))) {
$C->_SUBSUMEr(['O'], sub {
my $C = shift;
$C->O(%list_infix, $self->Opairs)
})
} else { () }

});
}
;
## token infix_circumfix_meta_operator:sym<« »> {
sub infix_circumfix_meta_operator__S_204Fre_Nch__PEEK { $_[0]->_AUTOLEXpeek('infix_circumfix_meta_operator__S_204Fre_Nch', $retree) }
sub infix_circumfix_meta_operator__S_204Fre_Nch {
no warnings 'recursion';
my $self = shift;


local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;

my $C = $self->cursor_xact("RULE infix_circumfix_meta_operator__S_204Fre_Nch");
my $xact = $C->xact;
my $S = $C->{'_pos'};
$C->{sym} = "«\ »";
$self->_MATCHIFYr($S, "infix_circumfix_meta_operator__S_204Fre_Nch", do {
my $C = $C;
if (($C) = ($C->_BRACKETr(sub {
my $C=shift;
do {
my ($tag, $try);
my @try;
my $relex;

my $fate;
my $x;
if ($fate = $C->{'_fate'} and $fate->[1] eq 'infix_circumfix_meta_operator__S_204Fre_Nch_0') {
$C->deb("Fate passed to infix_circumfix_meta_operator__S_204Fre_Nch_0: ", ::fatestr($fate)) if $::DEBUG & DEBUG::fates;
($C->{'_fate'}, $tag, $try) = @$fate;
@try = ($try);
$x = 'ALT infix_circumfix_meta_operator__S_204Fre_Nch_0';    # some outer ltm is controlling us
}
else {
$x = 'ALTLTM infix_circumfix_meta_operator__S_204Fre_Nch_0'; # we are top level ltm
}
my $C = $C->cursor_xact($x);
my $xact = $C->{_xact};

my @gather = ();
for (;;) {
unless (@try) {
$relex //= $C->cursor_fate('STD::P6', 'infix_circumfix_meta_operator__S_204Fre_Nch_0', $retree);
@try = $relex->($C) or last;
}
$try = shift(@try) // next;

if (ref $try) {
($C->{'_fate'}, $tag, $try) = @$try;   # next candidate fate
}

$C->deb("infix_circumfix_meta_operator__S_204Fre_Nch_0 trying $tag $try") if $::DEBUG & DEBUG::try_processing;
push @gather, ((
sub {
my $C=shift;
$C->_EXACT("«")
},
sub {
my $C=shift;
$C->_EXACT("»")
}
)[$try])->($C);
last if @gather;
last if $xact->[-2];  # committed?
}
@gather;
};
}))
and ($C) = (scalar(do {
}, $C))
and ($C) = ($C->_SUBSUMEr(['infixish'], sub {
my $C = shift;
$C->infixish('hyper')
}))
and ($C) = ($C->_BRACKETr(sub {
my $C=shift;
do {    my $C = $C->cursor_xact('ALT ||');
my $xact = $C->xact;
my @gather;
do {
push @gather, do {
if (my ($C) = (do {
do {
my ($tag, $try);
my @try;
my $relex;

my $fate;
my $x;
if ($fate = $C->{'_fate'} and $fate->[1] eq 'infix_circumfix_meta_operator__S_204Fre_Nch_1') {
$C->deb("Fate passed to infix_circumfix_meta_operator__S_204Fre_Nch_1: ", ::fatestr($fate)) if $::DEBUG & DEBUG::fates;
($C->{'_fate'}, $tag, $try) = @$fate;
@try = ($try);
$x = 'ALT infix_circumfix_meta_operator__S_204Fre_Nch_1';    # some outer ltm is controlling us
}
else {
$x = 'ALTLTM infix_circumfix_meta_operator__S_204Fre_Nch_1'; # we are top level ltm
}
my $C = $C->cursor_xact($x);
my $xact = $C->{_xact};

my @gather = ();
for (;;) {
unless (@try) {
$relex //= $C->cursor_fate('STD::P6', 'infix_circumfix_meta_operator__S_204Fre_Nch_1', $retree);
@try = $relex->($C) or last;
}
$try = shift(@try) // next;

if (ref $try) {
($C->{'_fate'}, $tag, $try) = @$try;   # next candidate fate
}

$C->deb("infix_circumfix_meta_operator__S_204Fre_Nch_1 trying $tag $try") if $::DEBUG & DEBUG::try_processing;
push @gather, ((
sub {
my $C=shift;
$C->_EXACT("«")
},
sub {
my $C=shift;
$C->_EXACT("»")
}
)[$try])->($C);
last if @gather;
last if $xact->[-2];  # committed?
}
@gather;
};

})) { ($C) } else { () }

}
}
or $xact->[-2] or
do {
push @gather, do {
if (my ($C) = ($C->panic("Missing « or »"))) { ($C) } else { () }

}
};
@gather;
}
}))
and ($C) = (do {
my $M = $C;
$C->can_meta($M->{'infixish'}, "hyper with")
})
and ($C) = ($C->before(sub {
my $C=shift;
(($C) x !!do {
my $M = $C;
$M->{'O'} = $M->{'infixish'}->{'O'}})
}))) {
$C
} else { () }

});
}
;
## token infix_circumfix_meta_operator:sym«<< >>» {
sub infix_circumfix_meta_operator__S_205LtLt_GtGt__PEEK { $_[0]->_AUTOLEXpeek('infix_circumfix_meta_operator__S_205LtLt_GtGt', $retree) }
sub infix_circumfix_meta_operator__S_205LtLt_GtGt {
no warnings 'recursion';
my $self = shift;


local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;

my $C = $self->cursor_xact("RULE infix_circumfix_meta_operator__S_205LtLt_GtGt");
my $xact = $C->xact;
my $S = $C->{'_pos'};
$C->{sym} = "\<\<\ \>\>";
$self->_MATCHIFYr($S, "infix_circumfix_meta_operator__S_205LtLt_GtGt", do {
my $C = $C;
if (($C) = ($C->_BRACKETr(sub {
my $C=shift;
do {
my ($tag, $try);
my @try;
my $relex;

my $fate;
my $x;
if ($fate = $C->{'_fate'} and $fate->[1] eq 'infix_circumfix_meta_operator__S_205LtLt_GtGt_0') {
$C->deb("Fate passed to infix_circumfix_meta_operator__S_205LtLt_GtGt_0: ", ::fatestr($fate)) if $::DEBUG & DEBUG::fates;
($C->{'_fate'}, $tag, $try) = @$fate;
@try = ($try);
$x = 'ALT infix_circumfix_meta_operator__S_205LtLt_GtGt_0';    # some outer ltm is controlling us
}
else {
$x = 'ALTLTM infix_circumfix_meta_operator__S_205LtLt_GtGt_0'; # we are top level ltm
}
my $C = $C->cursor_xact($x);
my $xact = $C->{_xact};

my @gather = ();
for (;;) {
unless (@try) {
$relex //= $C->cursor_fate('STD::P6', 'infix_circumfix_meta_operator__S_205LtLt_GtGt_0', $retree);
@try = $relex->($C) or last;
}
$try = shift(@try) // next;

if (ref $try) {
($C->{'_fate'}, $tag, $try) = @$try;   # next candidate fate
}

$C->deb("infix_circumfix_meta_operator__S_205LtLt_GtGt_0 trying $tag $try") if $::DEBUG & DEBUG::try_processing;
push @gather, ((
sub {
my $C=shift;
$C->_EXACT("\<\<")
},
sub {
my $C=shift;
$C->_EXACT("\>\>")
}
)[$try])->($C);
last if @gather;
last if $xact->[-2];  # committed?
}
@gather;
};
}))
and ($C) = (scalar(do {
}, $C))
and ($C) = ($C->_SUBSUMEr(['infixish'], sub {
my $C = shift;
$C->infixish('HYPER')
}))
and ($C) = ($C->_BRACKETr(sub {
my $C=shift;
do {    my $C = $C->cursor_xact('ALT ||');
my $xact = $C->xact;
my @gather;
do {
push @gather, do {
if (my ($C) = (do {
do {
my ($tag, $try);
my @try;
my $relex;

my $fate;
my $x;
if ($fate = $C->{'_fate'} and $fate->[1] eq 'infix_circumfix_meta_operator__S_205LtLt_GtGt_1') {
$C->deb("Fate passed to infix_circumfix_meta_operator__S_205LtLt_GtGt_1: ", ::fatestr($fate)) if $::DEBUG & DEBUG::fates;
($C->{'_fate'}, $tag, $try) = @$fate;
@try = ($try);
$x = 'ALT infix_circumfix_meta_operator__S_205LtLt_GtGt_1';    # some outer ltm is controlling us
}
else {
$x = 'ALTLTM infix_circumfix_meta_operator__S_205LtLt_GtGt_1'; # we are top level ltm
}
my $C = $C->cursor_xact($x);
my $xact = $C->{_xact};

my @gather = ();
for (;;) {
unless (@try) {
$relex //= $C->cursor_fate('STD::P6', 'infix_circumfix_meta_operator__S_205LtLt_GtGt_1', $retree);
@try = $relex->($C) or last;
}
$try = shift(@try) // next;

if (ref $try) {
($C->{'_fate'}, $tag, $try) = @$try;   # next candidate fate
}

$C->deb("infix_circumfix_meta_operator__S_205LtLt_GtGt_1 trying $tag $try") if $::DEBUG & DEBUG::try_processing;
push @gather, ((
sub {
my $C=shift;
$C->_EXACT("\<\<")
},
sub {
my $C=shift;
$C->_EXACT("\>\>")
}
)[$try])->($C);
last if @gather;
last if $xact->[-2];  # committed?
}
@gather;
};

})) { ($C) } else { () }

}
}
or $xact->[-2] or
do {
push @gather, do {
if (my ($C) = ($C->panic("Missing << or >>"))) { ($C) } else { () }

}
};
@gather;
}
}))
and ($C) = (do {
my $M = $C;
$C->can_meta($M->{'infixish'}, "hyper with")
})
and ($C) = ($C->before(sub {
my $C=shift;
(($C) x !!do {
my $M = $C;
$M->{'O'} = $M->{'infixish'}->{'O'}})
}))) {
$C
} else { () }

});
}
;
## token infix_postfix_meta_operator:sym<=> ($op) {
sub infix_postfix_meta_operator__S_206Equal__PEEK { $_[0]->_AUTOLEXpeek('infix_postfix_meta_operator__S_206Equal', $retree) }
sub infix_postfix_meta_operator__S_206Equal {
no warnings 'recursion';
my $self = shift;

die 'Required argument op omitted' unless @_;
my $op = @_ ? shift() : undef;
my %prec;
local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;

my $C = $self->cursor_xact("RULE infix_postfix_meta_operator__S_206Equal");
my $xact = $C->xact;
my $S = $C->{'_pos'};
$C->{sym} = "\=";
$self->_MATCHIFYr($S, "infix_postfix_meta_operator__S_206Equal", do {
my $C = $C;
if (($C) = ($C->_EXACT("\="))
and ($C) = ($C->can_meta($op, "make assignment out of"))
and ($C) = ($C->_BRACKETr(sub {
my $C=shift;
do {    my $C = $C->cursor_xact('ALT ||');
my $xact = $C->xact;
my @gather;
do {
push @gather, do {
if (my ($C) = ($C->_NOTBEFORE(sub {
my $C=shift;
(($C) x !!do {
$op->{'O'}->{'diffy'} })
}))) { ($C) } else { () }

}
}
or $xact->[-2] or
do {
push @gather, do {
if (my ($C) = ($C->sorry("Can't make assignment out of " . $op->{'sym'} . " because " . $op->{'O'}->{'dba'} . " operators are diffy"))) { ($C) } else { () }

}
};
@gather;
}
}))
and ($C) = (scalar(do {
my $M = $C;
$M->{'sym'} = $op->{'sym'} . '=';
if ($op->{'O'}->{'prec'} gt $comma{'prec'}) {
%prec = %item_assignment}
else {
%prec = %list_assignment};
}, $C))) {
$C->_SUBSUMEr(['O'], sub {
my $C = shift;
$C->O($op->Opairs, %prec, dba => 'assignment operator', iffy => 0)
})
} else { () }

});
}
;
## token postcircumfix:sym<( )>
sub postcircumfix__S_207Paren_Thesis__PEEK { $_[0]->_AUTOLEXpeek('postcircumfix__S_207Paren_Thesis', $retree) }
sub postcircumfix__S_207Paren_Thesis {
no warnings 'recursion';
my $self = shift;


local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;

my $C = $self->cursor_xact("RULE postcircumfix__S_207Paren_Thesis");
my $xact = $C->xact;
my $S = $C->{'_pos'};
$C->{sym} = "\(\ \)";
$self->_MATCHIFYr($S, "postcircumfix__S_207Paren_Thesis", do {
if (my ($C) = ($C->_BRACKETr(sub {
my $C=shift;
local $::GOAL = "\)";
my $goalpos = $C;
if (($C) = ($C->_EXACT("\("))
and ($C) = (scalar(do {
}, $C))
and ($C) = ($C->_SUBSUMEr(['semiarglist'], sub {
my $C = shift;
$C->semiarglist
}))
and ($C) = ($C->_BRACKETr(sub {
my $C=shift;
do {    my $C = $C->cursor_xact('ALT ||');
my $xact = $C->xact;
my @gather;
do {
push @gather, $C->_EXACT("\)")
}
or $xact->[-2] or
do {
push @gather, do {
if (my ($C) = ($C->FAILGOAL($::GOAL, 'argument list', $goalpos))) { ($C) } else { () }

}
};
@gather;
}
}))) {
$C
} else { () }
}))) {
$C->_SUBSUMEr(['O'], sub {
my $C = shift;
$C->O(%methodcall)
})
} else { () }

});
}
;
## token postcircumfix:sym<[ ]> { :dba('subscript') '[' ~ ']' <semilist> <O(|%methodcall)> 
sub postcircumfix__S_208Bra_Ket__PEEK { $_[0]->_AUTOLEXpeek('postcircumfix__S_208Bra_Ket', $retree) }
sub postcircumfix__S_208Bra_Ket {
no warnings 'recursion';
my $self = shift;


local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;

my $C = $self->cursor_xact("RULE postcircumfix__S_208Bra_Ket");
my $xact = $C->xact;
my $S = $C->{'_pos'};
$C->{sym} = "\[\ \]";
$self->_MATCHIFYr($S, "postcircumfix__S_208Bra_Ket", do {
my $C = $C;
if (($C) = ($C->_BRACKETr(sub {
my $C=shift;
local $::GOAL = "\]";
my $goalpos = $C;
if (($C) = ($C->_EXACT("\["))
and ($C) = (scalar(do {
}, $C))
and ($C) = ($C->_SUBSUMEr(['semilist'], sub {
my $C = shift;
$C->semilist
}))
and ($C) = ($C->_BRACKETr(sub {
my $C=shift;
do {    my $C = $C->cursor_xact('ALT ||');
my $xact = $C->xact;
my @gather;
do {
push @gather, $C->_EXACT("\]")
}
or $xact->[-2] or
do {
push @gather, do {
if (my ($C) = ($C->FAILGOAL($::GOAL, 'subscript', $goalpos))) { ($C) } else { () }

}
};
@gather;
}
}))) {
$C
} else { () }
}))
and ($C) = ($C->_SUBSUMEr(['O'], sub {
my $C = shift;
$C->O(%methodcall)
}))) {
scalar(do {
my $M = $C;
my $innards = $M->{'semilist'}->Str;
$innards =~ s/^\s+//;
$innards =~ s/\s+$//;
if ($innards =~ /^\-\d+$/) {
$C->obs("[$innards] subscript to access from end of array","[*$innards]")};
}, $C)
} else { () }

});
}
;
## token postcircumfix:sym<{ }>
sub postcircumfix__S_209Cur_Ly__PEEK { $_[0]->_AUTOLEXpeek('postcircumfix__S_209Cur_Ly', $retree) }
sub postcircumfix__S_209Cur_Ly {
no warnings 'recursion';
my $self = shift;


local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;

my $C = $self->cursor_xact("RULE postcircumfix__S_209Cur_Ly");
my $xact = $C->xact;
my $S = $C->{'_pos'};
$C->{sym} = "\{\ \}";
$self->_MATCHIFYr($S, "postcircumfix__S_209Cur_Ly", do {
my $C = $C;
if (($C) = ($C->_BRACKETr(sub {
my $C=shift;
local $::GOAL = "\}";
my $goalpos = $C;
if (($C) = ($C->_EXACT("\{"))
and ($C) = (scalar(do {
}, $C))
and ($C) = ($C->_SUBSUMEr(['semilist'], sub {
my $C = shift;
$C->semilist
}))
and ($C) = ($C->_BRACKETr(sub {
my $C=shift;
do {    my $C = $C->cursor_xact('ALT ||');
my $xact = $C->xact;
my @gather;
do {
push @gather, $C->_EXACT("\}")
}
or $xact->[-2] or
do {
push @gather, do {
if (my ($C) = ($C->FAILGOAL($::GOAL, 'subscript', $goalpos))) { ($C) } else { () }

}
};
@gather;
}
}))) {
$C
} else { () }
}))
and ($C) = ($C->_SUBSUMEr(['O'], sub {
my $C = shift;
$C->O(%methodcall)
}))
and ($C) = ($C->curlycheck)) {
$C
} else { () }

});
}
;
## token postcircumfix:sym«< >» {
sub postcircumfix__S_210Lt_Gt__PEEK { $_[0]->_AUTOLEXpeek('postcircumfix__S_210Lt_Gt', $retree) }
sub postcircumfix__S_210Lt_Gt {
no warnings 'recursion';
my $self = shift;

my $pos;
local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;

my $C = $self->cursor_xact("RULE postcircumfix__S_210Lt_Gt");
my $xact = $C->xact;
my $S = $C->{'_pos'};
$C->{sym} = "\<\ \>";
$self->_MATCHIFYr($S, "postcircumfix__S_210Lt_Gt", do {
my $C = $C;
if (($C) = ($C->_EXACT("\<"))
and ($C) = (scalar(do {
$pos = $C->{'_pos'} }, $C))
and ($C) = ($C->_BRACKETr(sub {
my $C=shift;
do {    my $C = $C->cursor_xact('ALT ||');
my $xact = $C->xact;
my @gather;
do {
push @gather, do {
if (my ($C) = ($C->_SUBSUMEr(['nibble'], sub {
my $C = shift;
$C->nibble($C->cursor_fresh( $::LANG{'Q'} )->tweak('q' => 1)->tweak('w' => 1)->balanced('<','>'))
}))) {
$C->_EXACT("\>")
} else { () }

}
}
or $xact->[-2] or
do {
push @gather, do {
if (my ($C) = ($C->before(sub {
my $C=shift;
if (my ($C) = ($C->before(sub {
my $C=shift;
do {
my $C = $C;
if (($C) = ($C->_PATTERN(qr/\G[\x20\t\r]*+/))
and ($C) = ($C->_BRACKETr(sub {
my $C=shift;
do {
my ($tag, $try);
my @try;
my $relex;

my $fate;
my $x;
if ($fate = $C->{'_fate'} and $fate->[1] eq 'postcircumfix__S_210Lt_Gt_0') {
$C->deb("Fate passed to postcircumfix__S_210Lt_Gt_0: ", ::fatestr($fate)) if $::DEBUG & DEBUG::fates;
($C->{'_fate'}, $tag, $try) = @$fate;
@try = ($try);
$x = 'ALT postcircumfix__S_210Lt_Gt_0';    # some outer ltm is controlling us
}
else {
$x = 'ALTLTM postcircumfix__S_210Lt_Gt_0'; # we are top level ltm
}
my $C = $C->cursor_xact($x);
my $xact = $C->{_xact};

my @gather = ();
for (;;) {
unless (@try) {
$relex //= $C->cursor_fate('STD::P6', 'postcircumfix__S_210Lt_Gt_0', $retree);
@try = $relex->($C) or last;
}
$try = shift(@try) // next;

if (ref $try) {
($C->{'_fate'}, $tag, $try) = @$try;   # next candidate fate
}

$C->deb("postcircumfix__S_210Lt_Gt_0 trying $tag $try") if $::DEBUG & DEBUG::try_processing;
push @gather, ((
sub {
my $C=shift;
$C->_PATTERN(qr/\G\d/)
},
sub {
my $C=shift;
$C->_SUBSUMEr(['sigil'], sub {
my $C = shift;
$C->sigil
})
},
sub {
my $C=shift;
$C->_EXACT("\:")
}
)[$try])->($C);
last if @gather;
last if $xact->[-2];  # committed?
}
@gather;
};
}))) {
$C
} else { () }
};
}))) { ($C) } else { () }
}))) {
scalar(do {
$C->cursor_force($pos)->panic("Whitespace required before < operator") }, $C)
} else { () }

}
}
or $xact->[-2] or
do {
push @gather, scalar(do {
$C->cursor_force($pos)->panic("Unable to parse quote-words subscript; couldn't find right angle quote") }, $C)
};
@gather;
}
}))) {
$C->_SUBSUMEr(['O'], sub {
my $C = shift;
$C->O(%methodcall)
})
} else { () }

});
}
;
## token postcircumfix:sym«<< >>»
sub postcircumfix__S_211LtLt_GtGt__PEEK { $_[0]->_AUTOLEXpeek('postcircumfix__S_211LtLt_GtGt', $retree) }
sub postcircumfix__S_211LtLt_GtGt {
no warnings 'recursion';
my $self = shift;


local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;

my $C = $self->cursor_xact("RULE postcircumfix__S_211LtLt_GtGt");
my $xact = $C->xact;
my $S = $C->{'_pos'};
$C->{sym} = "\<\<\ \>\>";
$self->_MATCHIFYr($S, "postcircumfix__S_211LtLt_GtGt", do {
my $C = $C;
if (($C) = ($C->_EXACT("\<\<"))
and ($C) = ($C->_SUBSUMEr(['nibble'], sub {
my $C = shift;
$C->nibble($C->cursor_fresh( $::LANG{'Q'} )->tweak('qq' => 1)->tweak('ww' => 1)->balanced('<<','>>'))
}))
and ($C) = ($C->_BRACKETr(sub {
my $C=shift;
do {    my $C = $C->cursor_xact('ALT ||');
my $xact = $C->xact;
my @gather;
do {
push @gather, $C->_EXACT("\>\>")
}
or $xact->[-2] or
do {
push @gather, do {
if (my ($C) = ($C->panic("Unable to parse quote-words subscript; couldn't find right double-angle quote"))) { ($C) } else { () }

}
};
@gather;
}
}))) {
$C->_SUBSUMEr(['O'], sub {
my $C = shift;
$C->O(%methodcall)
})
} else { () }

});
}
;
## token postcircumfix:sym<« »>
sub postcircumfix__S_212Fre_Nch__PEEK { $_[0]->_AUTOLEXpeek('postcircumfix__S_212Fre_Nch', $retree) }
sub postcircumfix__S_212Fre_Nch {
no warnings 'recursion';
my $self = shift;


local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;

my $C = $self->cursor_xact("RULE postcircumfix__S_212Fre_Nch");
my $xact = $C->xact;
my $S = $C->{'_pos'};
$C->{sym} = "«\ »";
$self->_MATCHIFYr($S, "postcircumfix__S_212Fre_Nch", do {
my $C = $C;
if (($C) = ($C->_EXACT("«"))
and ($C) = ($C->_SUBSUMEr(['nibble'], sub {
my $C = shift;
$C->nibble($C->cursor_fresh( $::LANG{'Q'} )->tweak('qq' => 1)->tweak('ww' => 1)->balanced('«','»'))
}))
and ($C) = ($C->_BRACKETr(sub {
my $C=shift;
do {    my $C = $C->cursor_xact('ALT ||');
my $xact = $C->xact;
my @gather;
do {
push @gather, $C->_EXACT("»")
}
or $xact->[-2] or
do {
push @gather, do {
if (my ($C) = ($C->panic("Unable to parse quote-words subscript; couldn't find right double-angle quote"))) { ($C) } else { () }

}
};
@gather;
}
}))) {
$C->_SUBSUMEr(['O'], sub {
my $C = shift;
$C->O(%methodcall)
})
} else { () }

});
}
;
## token postop {
sub postop__PEEK { $_[0]->_AUTOLEXpeek('postop', $retree) }
sub postop {
no warnings 'recursion';
my $self = shift;


local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;

my $C = $self->cursor_xact("RULE postop");
my $xact = $C->xact;
my $S = $C->{'_pos'};
$self->_MATCHIFYr($S, "postop", do {
do {
my ($tag, $try);
my @try;
my $relex;

my $fate;
my $x;
if ($fate = $C->{'_fate'} and $fate->[1] eq 'postop_0') {
$C->deb("Fate passed to postop_0: ", ::fatestr($fate)) if $::DEBUG & DEBUG::fates;
($C->{'_fate'}, $tag, $try) = @$fate;
@try = ($try);
$x = 'ALT postop_0';    # some outer ltm is controlling us
}
else {
$x = 'ALTLTM postop_0'; # we are top level ltm
}
my $C = $C->cursor_xact($x);
my $xact = $C->{_xact};

my @gather = ();
for (;;) {
unless (@try) {
$relex //= $C->cursor_fate('STD::P6', 'postop_0', $retree);
@try = $relex->($C) or last;
}
$try = shift(@try) // next;

if (ref $try) {
($C->{'_fate'}, $tag, $try) = @$try;   # next candidate fate
}

$C->deb("postop_0 trying $tag $try") if $::DEBUG & DEBUG::try_processing;
push @gather, ((
sub {
my $C=shift;
if (my ($C) = ($C->_SUBSUMEr(['postfix'], sub {
my $C = shift;
$C->postfix
}))) {
scalar(do {
my $M = $C;
$M->{'O'} = $M->{'postfix'}->{'O'};
$M->{'sym'} = $M->{'postfix'}->{'sym'};
}, $C)
} else { () }
},
sub {
my $C=shift;
if (my ($C) = ($C->_SUBSUMEr(['postcircumfix'], sub {
my $C = shift;
$C->postcircumfix
}))) {
scalar(do {
my $M = $C;
$M->{'O'} = $M->{'postcircumfix'}->{'O'};
$M->{'sym'} = $M->{'postcircumfix'}->{'sym'};
}, $C)
} else { () }
}
)[$try])->($C);
last if @gather;
last if $xact->[-2];  # committed?
}
@gather;
};

});
}
;
## token methodop {
sub methodop__PEEK { $_[0]->_AUTOLEXpeek('methodop', $retree) }
sub methodop {
no warnings 'recursion';
my $self = shift;


local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;

my $C = $self->cursor_xact("RULE methodop");
my $xact = $C->xact;
my $S = $C->{'_pos'};
$C->{'arglist'} = [];
$C->{'args'} = [];
$self->_MATCHIFYr($S, "methodop", do {
my $C = $C;
if (($C) = ($C->_BRACKETr(sub {
my $C=shift;
do {
my ($tag, $try);
my @try;
my $relex;

my $fate;
my $x;
if ($fate = $C->{'_fate'} and $fate->[1] eq 'methodop_0') {
$C->deb("Fate passed to methodop_0: ", ::fatestr($fate)) if $::DEBUG & DEBUG::fates;
($C->{'_fate'}, $tag, $try) = @$fate;
@try = ($try);
$x = 'ALT methodop_0';    # some outer ltm is controlling us
}
else {
$x = 'ALTLTM methodop_0'; # we are top level ltm
}
my $C = $C->cursor_xact($x);
my $xact = $C->{_xact};

my @gather = ();
for (;;) {
unless (@try) {
$relex //= $C->cursor_fate('STD::P6', 'methodop_0', $retree);
@try = $relex->($C) or last;
}
$try = shift(@try) // next;

if (ref $try) {
($C->{'_fate'}, $tag, $try) = @$try;   # next candidate fate
}

$C->deb("methodop_0 trying $tag $try") if $::DEBUG & DEBUG::try_processing;
push @gather, ((
sub {
my $C=shift;
$C->_SUBSUMEr(['longname'], sub {
my $C = shift;
$C->longname
})
},
sub {
my $C=shift;
if (($C) = ($C->before(sub {
my $C=shift;
if (my ($C) = ($C->before(sub {
my $C=shift;
if (my ($C) = (do {
do {
my ($tag, $try);
my @try;
my $relex;

my $fate;
my $x;
if ($fate = $C->{'_fate'} and $fate->[1] eq 'methodop_1') {
$C->deb("Fate passed to methodop_1: ", ::fatestr($fate)) if $::DEBUG & DEBUG::fates;
($C->{'_fate'}, $tag, $try) = @$fate;
@try = ($try);
$x = 'ALT methodop_1';    # some outer ltm is controlling us
}
else {
$x = 'ALTLTM methodop_1'; # we are top level ltm
}
my $C = $C->cursor_xact($x);
my $xact = $C->{_xact};

my @gather = ();
for (;;) {
unless (@try) {
$relex //= $C->cursor_fate('STD::P6', 'methodop_1', $retree);
@try = $relex->($C) or last;
}
$try = shift(@try) // next;

if (ref $try) {
($C->{'_fate'}, $tag, $try) = @$try;   # next candidate fate
}

$C->deb("methodop_1 trying $tag $try") if $::DEBUG & DEBUG::try_processing;
push @gather, ((
sub {
my $C=shift;
$C->_EXACT("\$")
},
sub {
my $C=shift;
$C->_EXACT("\@")
},
sub {
my $C=shift;
$C->_EXACT("\&")
}
)[$try])->($C);
last if @gather;
last if $xact->[-2];  # committed?
}
@gather;
};

})) { ($C) } else { () }
}))) { ($C) } else { () }
}))
and ($C) = ($C->_SUBSUMEr(['variable'], sub {
my $C = shift;
$C->variable
}))) {
scalar(do {
my $M = $C;
$C->check_variable($M->{'variable'}) }, $C)
} else { () }
},
sub {
my $C=shift;
if (($C) = ($C->before(sub {
my $C=shift;
if (my ($C) = ($C->before(sub {
my $C=shift;
$C->_PATTERN(qr/\G['"]/)
}))) { ($C) } else { () }
}))
and ($C) = ($C->_BRACKETr(sub {
my $C=shift;
do {    my $C = $C->cursor_xact('ALT ||');
my $xact = $C->xact;
my @gather;
do {
push @gather, do {
if (my ($C) = ($C->_NOTBEFORE(sub {
my $C=shift;
(($C) x !!do {
$::QSIGIL})
}))) { ($C) } else { () }

}
}
or $xact->[-2] or
do {
push @gather, do {
if (my ($C) = ($C->_NOTBEFORE(sub {
my $C=shift;
if (my ($C) = ($C->before(sub {
my $C=shift;
if (my ($C) = (do {
if (my ($C) = ($C->_EXACT("\""))) {
LazyMap::lazymap(sub {
my $C=shift;
$C->_PATTERN(qr/\G\s/)
},
$C->_STARf(sub {
my $C=shift;
$C->_PATTERN(qr/\G[^"]/)
}))
} else { () }

})) { ($C) } else { () }
}))) { ($C) } else { () }
}))) { ($C) } else { () }

}
};
@gather;
}
}))
and ($C) = ($C->_SUBSUMEr(['quote'], sub {
my $C = shift;
$C->quote
}))
and ($C) = ($C->_BRACKETr(sub {
my $C=shift;
do {    my $C = $C->cursor_xact('ALT ||');
my $xact = $C->xact;
my @gather;
do {
push @gather, do {
if (my ($C) = ($C->before(sub {
my $C=shift;
if (my ($C) = ($C->before(sub {
my $C=shift;
if (my ($C) = (do {
do {
my ($tag, $try);
my @try;
my $relex;

my $fate;
my $x;
if ($fate = $C->{'_fate'} and $fate->[1] eq 'methodop_2') {
$C->deb("Fate passed to methodop_2: ", ::fatestr($fate)) if $::DEBUG & DEBUG::fates;
($C->{'_fate'}, $tag, $try) = @$fate;
@try = ($try);
$x = 'ALT methodop_2';    # some outer ltm is controlling us
}
else {
$x = 'ALTLTM methodop_2'; # we are top level ltm
}
my $C = $C->cursor_xact($x);
my $xact = $C->{_xact};

my @gather = ();
for (;;) {
unless (@try) {
$relex //= $C->cursor_fate('STD::P6', 'methodop_2', $retree);
@try = $relex->($C) or last;
}
$try = shift(@try) // next;

if (ref $try) {
($C->{'_fate'}, $tag, $try) = @$try;   # next candidate fate
}

$C->deb("methodop_2 trying $tag $try") if $::DEBUG & DEBUG::try_processing;
push @gather, ((
sub {
my $C=shift;
$C->_EXACT("\(")
},
sub {
my $C=shift;
$C->_EXACT("\.\(")
},
sub {
my $C=shift;
$C->_EXACT("\\")
}
)[$try])->($C);
last if @gather;
last if $xact->[-2];  # committed?
}
@gather;
};

})) { ($C) } else { () }
}))) { ($C) } else { () }
}))) { ($C) } else { () }

}
}
or $xact->[-2] or
do {
push @gather, do {
if (my ($C) = ($C->obs('. to concatenate strings or to call a quoted method', '~ to concatenate, or if you meant to call a quoted method, please supply the required parentheses'))) { ($C) } else { () }

}
};
@gather;
}
}))) {
scalar(do {
my $M = $C;
my $t = $M->{'quote'}->{'nibble'}->Str;
$t =~ /\W/ or $t =~ /^(WHO|WHAT|WHERE|WHEN|WHY|HOW)$/ or $C->worry("Useless use of quotes") ;
}, $C)
} else { () }
}
)[$try])->($C);
last if @gather;
last if $xact->[-2];  # committed?
}
@gather;
};
}))
and ($C) = ($C->_OPTr(sub {
my $C=shift;
if (my ($C) = ($C->unsp)) { ($C) } else { () }
}))) {
$C->_OPTr(sub {
my $C=shift;
if (my ($C) = ($C->_BRACKETr(sub {
my $C=shift;
do {
my ($tag, $try);
my @try;
my $relex;

my $fate;
my $x;
if ($fate = $C->{'_fate'} and $fate->[1] eq 'methodop_3') {
$C->deb("Fate passed to methodop_3: ", ::fatestr($fate)) if $::DEBUG & DEBUG::fates;
($C->{'_fate'}, $tag, $try) = @$fate;
@try = ($try);
$x = 'ALT methodop_3';    # some outer ltm is controlling us
}
else {
$x = 'ALTLTM methodop_3'; # we are top level ltm
}
my $C = $C->cursor_xact($x);
my $xact = $C->{_xact};

my @gather = ();
for (;;) {
unless (@try) {
$relex //= $C->cursor_fate('STD::P6', 'methodop_3', $retree);
@try = $relex->($C) or last;
}
$try = shift(@try) // next;

if (ref $try) {
($C->{'_fate'}, $tag, $try) = @$try;   # next candidate fate
}

$C->deb("methodop_3 trying $tag $try") if $::DEBUG & DEBUG::try_processing;
push @gather, ((
sub {
my $C=shift;
if (($C) = ($C->_EXACT("\:"))
and ($C) = ($C->before(sub {
my $C=shift;
if (my ($C) = ($C->before(sub {
my $C=shift;
if (my ($C) = (do {
do {
my ($tag, $try);
my @try;
my $relex;

my $fate;
my $x;
if ($fate = $C->{'_fate'} and $fate->[1] eq 'methodop_4') {
$C->deb("Fate passed to methodop_4: ", ::fatestr($fate)) if $::DEBUG & DEBUG::fates;
($C->{'_fate'}, $tag, $try) = @$fate;
@try = ($try);
$x = 'ALT methodop_4';    # some outer ltm is controlling us
}
else {
$x = 'ALTLTM methodop_4'; # we are top level ltm
}
my $C = $C->cursor_xact($x);
my $xact = $C->{_xact};

my @gather = ();
for (;;) {
unless (@try) {
$relex //= $C->cursor_fate('STD::P6', 'methodop_4', $retree);
@try = $relex->($C) or last;
}
$try = shift(@try) // next;

if (ref $try) {
($C->{'_fate'}, $tag, $try) = @$try;   # next candidate fate
}

$C->deb("methodop_4 trying $tag $try") if $::DEBUG & DEBUG::try_processing;
push @gather, ((
sub {
my $C=shift;
$C->_PATTERN(qr/\G\s/)
},
sub {
my $C=shift;
$C->_EXACT("\{")
}
)[$try])->($C);
last if @gather;
last if $xact->[-2];  # committed?
}
@gather;
};

})) { ($C) } else { () }
}))) { ($C) } else { () }
}))
and ($C) = ($C->_NOTBEFORE(sub {
my $C=shift;
(($C) x !!do {
$::QSIGIL })
}))) {
$C->_SUBSUMEr(['arglist'], sub {
my $C = shift;
$C->arglist
})
} else { () }
},
sub {
my $C=shift;
if (my ($C) = ($C->before(sub {
my $C=shift;
$C->_PATTERN(qr/\G[\\(]/)
}))) {
$C->_SUBSUMEr(['args'], sub {
my $C = shift;
$C->args
})
} else { () }
},
sub {
my $C=shift;
scalar(do {
$::MEMOS[$C->{'_pos'}]->{'baremeth'} = 1 }, $C)
}
)[$try])->($C);
last if @gather;
last if $xact->[-2];  # committed?
}
@gather;
};
}))) { ($C) } else { () }
})
} else { () }

});
}
;
## token semiarglist {
sub semiarglist__PEEK { $_[0]->_AUTOLEXpeek('semiarglist', $retree) }
sub semiarglist {
no warnings 'recursion';
my $self = shift;


local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;

my $C = $self->cursor_xact("RULE semiarglist");
my $xact = $C->xact;
my $S = $C->{'_pos'};
$C->{'arglist'} = [];
$self->_MATCHIFYr($S, "semiarglist", do {
my $C = $C;
if (($C) = ($C->_REPSEPr( sub {
my $C=shift;
$C->_EXACT("\;")
}, sub {
my $C=shift;
$C->_SUBSUMEr(['arglist'], sub {
my $C = shift;
$C->arglist
})
}))
and ($C) = ($C->ws)) {
$C
} else { () }

});
}
;
## token arglist {
sub arglist__PEEK { $_[0]->_AUTOLEXpeek('arglist', $retree) }
sub arglist {
no warnings 'recursion';
my $self = shift;

my $inv_ok = $::INVOCANT_OK;local $::endargs = 0;local $::GOAL = 'endargs';local $::QSIGIL = '';
local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;

my $C = $self->cursor_xact("RULE arglist");
my $xact = $C->xact;
my $S = $C->{'_pos'};
$self->_MATCHIFYr($S, "arglist", do {
my $C = $C;
if (($C) = ($C->ws)
and ($C) = ($C->_BRACKETr(sub {
my $C=shift;
do {
my ($tag, $try);
my @try;
my $relex;

my $fate;
my $x;
if ($fate = $C->{'_fate'} and $fate->[1] eq 'arglist_0') {
$C->deb("Fate passed to arglist_0: ", ::fatestr($fate)) if $::DEBUG & DEBUG::fates;
($C->{'_fate'}, $tag, $try) = @$fate;
@try = ($try);
$x = 'ALT arglist_0';    # some outer ltm is controlling us
}
else {
$x = 'ALTLTM arglist_0'; # we are top level ltm
}
my $C = $C->cursor_xact($x);
my $xact = $C->{_xact};

my @gather = ();
for (;;) {
unless (@try) {
$relex //= $C->cursor_fate('STD::P6', 'arglist_0', $retree);
@try = $relex->($C) or last;
}
$try = shift(@try) // next;

if (ref $try) {
($C->{'_fate'}, $tag, $try) = @$try;   # next candidate fate
}

$C->deb("arglist_0 trying $tag $try") if $::DEBUG & DEBUG::try_processing;
push @gather, ((
sub {
my $C=shift;
if (my ($C) = ($C->before(sub {
my $C=shift;
if (my ($C) = ($C->stdstopper)) { ($C) } else { () }
}))) { ($C) } else { () }
},
sub {
my $C=shift;
if (my ($C) = ($C->_SUBSUMEr(['EXPR'], sub {
my $C = shift;
$C->EXPR(\%list_prefix)
}))) {
scalar(do {
my $M = $C;
{
my $delims = $M->{'EXPR'}->{'delims'};
for (@$delims) {
if ($_->{'infix'}->{'wascolon'} // '') {
if ($inv_ok) {
$::INVOCANT_IS = $M->{'EXPR'}->{'list'}->[0]}}}
;
}}, $C)
} else { () }
}
)[$try])->($C);
last if @gather;
last if $xact->[-2];  # committed?
}
@gather;
};
}))) {
$C
} else { () }

});
}
;
## token term:lambda {
sub term__S_213lambda__PEEK { $_[0]->_AUTOLEXpeek('term__S_213lambda', $retree) }
sub term__S_213lambda {
no warnings 'recursion';
my $self = shift;


local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;

my $C = $self->cursor_xact("RULE term__S_213lambda");
my $xact = $C->xact;
my $S = $C->{'_pos'};
$C->{sym} = "lambda";
$self->_MATCHIFYr($S, "term__S_213lambda", do {
my $C = $C;
if (($C) = ($C->before(sub {
my $C=shift;
if (my ($C) = ($C->before(sub {
my $C=shift;
if (my ($C) = ($C->lambda)) { ($C) } else { () }
}))) { ($C) } else { () }
}))
and ($C) = ($C->_SUBSUMEr(['pblock'], sub {
my $C = shift;
$C->pblock
}))
and ($C) = (scalar(do {
my $M = $C;
{
if ($::BORG) {
$::BORG->{'block'} = $M->{'pblock'}}}}, $C))) {
$C->_SUBSUMEr(['O'], sub {
my $C = shift;
$C->O(%term)
})
} else { () }

});
}
;
## token circumfix:sym<{ }> {
sub circumfix__S_214Cur_Ly__PEEK { $_[0]->_AUTOLEXpeek('circumfix__S_214Cur_Ly', $retree) }
sub circumfix__S_214Cur_Ly {
no warnings 'recursion';
my $self = shift;


local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;

my $C = $self->cursor_xact("RULE circumfix__S_214Cur_Ly");
my $xact = $C->xact;
my $S = $C->{'_pos'};
$C->{sym} = "\{\ \}";
$self->_MATCHIFYr($S, "circumfix__S_214Cur_Ly", do {
my $C = $C;
if (($C) = ($C->before(sub {
my $C=shift;
if (my ($C) = ($C->before(sub {
my $C=shift;
$C->_EXACT("\{")
}))) { ($C) } else { () }
}))
and ($C) = ($C->_SUBSUMEr(['pblock'], sub {
my $C = shift;
$C->pblock
}))
and ($C) = (scalar(do {
my $M = $C;
{
if ($::BORG) {
$::BORG->{'block'} = $M->{'pblock'}}}}, $C))) {
$C->_SUBSUMEr(['O'], sub {
my $C = shift;
$C->O(%term)
})
} else { () }

});
}
;
## token postfix:sym<i>
sub postfix__S_215i__PEEK { $_[0]->_AUTOLEXpeek('postfix__S_215i', $retree) }
sub postfix__S_215i {
no warnings 'recursion';
my $self = shift;


local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;

my $C = $self->cursor_xact("RULE postfix__S_215i");
my $xact = $C->xact;
my $S = $C->{'_pos'};
$C->{sym} = "i";
$self->_MATCHIFYr($S, "postfix__S_215i", do {
if (my ($C) = ($C->_PATTERN(qr/\Gi\b/))) {
$C->_SUBSUMEr(['O'], sub {
my $C = shift;
$C->O(%methodcall)
})
} else { () }

});
}
;
## token infix:sym<.> ()
sub infix__S_216Dot__PEEK { $_[0]->_AUTOLEXpeek('infix__S_216Dot', $retree) }
sub infix__S_216Dot {
no warnings 'recursion';
my $self = shift;


local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;

my $C = $self->cursor_xact("RULE infix__S_216Dot");
my $xact = $C->xact;
my $S = $C->{'_pos'};
$C->{sym} = "\.";
$self->_MATCHIFYr($S, "infix__S_216Dot", do {
my $C = $C;
if (($C) = ($C->_PATTERN(qr/\G\.[\]\)\},:\s\$"']/))
and ($C) = ($C->obs('. to concatenate strings', '~'))) {
$C
} else { () }

});
}
;
## token postfix:sym['->'] () {
sub postfix__S_217MinusGt__PEEK { $_[0]->_AUTOLEXpeek('postfix__S_217MinusGt', $retree) }
sub postfix__S_217MinusGt {
no warnings 'recursion';
my $self = shift;


local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;

my $C = $self->cursor_xact("RULE postfix__S_217MinusGt");
my $xact = $C->xact;
my $S = $C->{'_pos'};
$C->{sym} = "\-\>";
$self->_MATCHIFYr($S, "postfix__S_217MinusGt", do {
my $C = $C;
if (($C) = ($C->_EXACT("\-\>"))
and ($C) = ($C->_BRACKETr(sub {
my $C=shift;
do {
my ($tag, $try);
my @try;
my $relex;

my $fate;
my $x;
if ($fate = $C->{'_fate'} and $fate->[1] eq 'postfix__S_217MinusGt_0') {
$C->deb("Fate passed to postfix__S_217MinusGt_0: ", ::fatestr($fate)) if $::DEBUG & DEBUG::fates;
($C->{'_fate'}, $tag, $try) = @$fate;
@try = ($try);
$x = 'ALT postfix__S_217MinusGt_0';    # some outer ltm is controlling us
}
else {
$x = 'ALTLTM postfix__S_217MinusGt_0'; # we are top level ltm
}
my $C = $C->cursor_xact($x);
my $xact = $C->{_xact};

my @gather = ();
for (;;) {
unless (@try) {
$relex //= $C->cursor_fate('STD::P6', 'postfix__S_217MinusGt_0', $retree);
@try = $relex->($C) or last;
}
$try = shift(@try) // next;

if (ref $try) {
($C->{'_fate'}, $tag, $try) = @$try;   # next candidate fate
}

$C->deb("postfix__S_217MinusGt_0 trying $tag $try") if $::DEBUG & DEBUG::try_processing;
push @gather, ((
sub {
my $C=shift;
if (($C) = ($C->_SUBSUMEr(['brack'], sub {
my $C = shift;
$C->_PATTERN(qr/\G[\[\{\(]/)
}))
and ($C) = (do {
my $M = $C;
$C->obs("'->" . $M->{'brack'}->Str . "' as postfix dereferencer", "'." . $M->{'brack'}->Str . "' or just '" . $M->{'brack'}->Str . "' to deref, or whitespace to delimit a pointy block")
})) {
$C
} else { () }
},
sub {
my $C=shift;
if (my ($C) = ($C->obs('-> as postfix', 'either . to call a method, or whitespace to delimit a pointy block'))) { ($C) } else { () }
}
)[$try])->($C);
last if @gather;
last if $xact->[-2];  # committed?
}
@gather;
};
}))) {
$C
} else { () }

});
}
;
## token postfix:sym<++>
sub postfix__S_218PlusPlus__PEEK { $_[0]->_AUTOLEXpeek('postfix__S_218PlusPlus', $retree) }
sub postfix__S_218PlusPlus {
no warnings 'recursion';
my $self = shift;


local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;

my $C = $self->cursor_xact("RULE postfix__S_218PlusPlus");
my $xact = $C->xact;
my $S = $C->{'_pos'};
$C->{sym} = "\+\+";
$self->_MATCHIFYr($S, "postfix__S_218PlusPlus", do {
if (my ($C) = ($C->_EXACT("\+\+"))) {
$C->_SUBSUMEr(['O'], sub {
my $C = shift;
$C->O(%autoincrement)
})
} else { () }

});
}
;
## token postfix:sym«--» ()
sub postfix__S_219MinusMinus__PEEK { $_[0]->_AUTOLEXpeek('postfix__S_219MinusMinus', $retree) }
sub postfix__S_219MinusMinus {
no warnings 'recursion';
my $self = shift;


local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;

my $C = $self->cursor_xact("RULE postfix__S_219MinusMinus");
my $xact = $C->xact;
my $S = $C->{'_pos'};
$C->{sym} = "\-\-";
$self->_MATCHIFYr($S, "postfix__S_219MinusMinus", do {
if (my ($C) = ($C->_EXACT("\-\-"))) {
$C->_SUBSUMEr(['O'], sub {
my $C = shift;
$C->O(%autoincrement)
})
} else { () }

});
}
;
## token prefix:sym<++>
sub prefix__S_220PlusPlus__PEEK { $_[0]->_AUTOLEXpeek('prefix__S_220PlusPlus', $retree) }
sub prefix__S_220PlusPlus {
no warnings 'recursion';
my $self = shift;


local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;

my $C = $self->cursor_xact("RULE prefix__S_220PlusPlus");
my $xact = $C->xact;
my $S = $C->{'_pos'};
$C->{sym} = "\+\+";
$self->_MATCHIFYr($S, "prefix__S_220PlusPlus", do {
if (my ($C) = ($C->_EXACT("\+\+"))) {
$C->_SUBSUMEr(['O'], sub {
my $C = shift;
$C->O(%autoincrement)
})
} else { () }

});
}
;
## token prefix:sym«--» ()
sub prefix__S_221MinusMinus__PEEK { $_[0]->_AUTOLEXpeek('prefix__S_221MinusMinus', $retree) }
sub prefix__S_221MinusMinus {
no warnings 'recursion';
my $self = shift;


local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;

my $C = $self->cursor_xact("RULE prefix__S_221MinusMinus");
my $xact = $C->xact;
my $S = $C->{'_pos'};
$C->{sym} = "\-\-";
$self->_MATCHIFYr($S, "prefix__S_221MinusMinus", do {
if (my ($C) = ($C->_EXACT("\-\-"))) {
$C->_SUBSUMEr(['O'], sub {
my $C = shift;
$C->O(%autoincrement)
})
} else { () }

});
}
;
## token infix:sym<**>
sub infix__S_222StarStar__PEEK { $_[0]->_AUTOLEXpeek('infix__S_222StarStar', $retree) }
sub infix__S_222StarStar {
no warnings 'recursion';
my $self = shift;


local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;

my $C = $self->cursor_xact("RULE infix__S_222StarStar");
my $xact = $C->xact;
my $S = $C->{'_pos'};
$C->{sym} = "\*\*";
$self->_MATCHIFYr($S, "infix__S_222StarStar", do {
if (my ($C) = ($C->_EXACT("\*\*"))) {
$C->_SUBSUMEr(['O'], sub {
my $C = shift;
$C->O(%exponentiation)
})
} else { () }

});
}
;
## token prefix:sym<!>
sub prefix__S_223Bang__PEEK { $_[0]->_AUTOLEXpeek('prefix__S_223Bang', $retree) }
sub prefix__S_223Bang {
no warnings 'recursion';
my $self = shift;


local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;

my $C = $self->cursor_xact("RULE prefix__S_223Bang");
my $xact = $C->xact;
my $S = $C->{'_pos'};
$C->{sym} = "\!";
$self->_MATCHIFYr($S, "prefix__S_223Bang", do {
if (my ($C) = ($C->_EXACT("\!"))) {
$C->_SUBSUMEr(['O'], sub {
my $C = shift;
$C->O(%symbolic_unary)
})
} else { () }

});
}
;
## token prefix:sym<+>
sub prefix__S_224Plus__PEEK { $_[0]->_AUTOLEXpeek('prefix__S_224Plus', $retree) }
sub prefix__S_224Plus {
no warnings 'recursion';
my $self = shift;


local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;

my $C = $self->cursor_xact("RULE prefix__S_224Plus");
my $xact = $C->xact;
my $S = $C->{'_pos'};
$C->{sym} = "\+";
$self->_MATCHIFYr($S, "prefix__S_224Plus", do {
if (my ($C) = ($C->_EXACT("\+"))) {
$C->_SUBSUMEr(['O'], sub {
my $C = shift;
$C->O(%symbolic_unary)
})
} else { () }

});
}
;
## token prefix:sym<->
sub prefix__S_225Minus__PEEK { $_[0]->_AUTOLEXpeek('prefix__S_225Minus', $retree) }
sub prefix__S_225Minus {
no warnings 'recursion';
my $self = shift;


local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;

my $C = $self->cursor_xact("RULE prefix__S_225Minus");
my $xact = $C->xact;
my $S = $C->{'_pos'};
$C->{sym} = "\-";
$self->_MATCHIFYr($S, "prefix__S_225Minus", do {
if (my ($C) = ($C->_EXACT("\-"))) {
$C->_SUBSUMEr(['O'], sub {
my $C = shift;
$C->O(%symbolic_unary)
})
} else { () }

});
}
;
## token prefix:sym<~~>
sub prefix__S_226TildeTilde__PEEK { $_[0]->_AUTOLEXpeek('prefix__S_226TildeTilde', $retree) }
sub prefix__S_226TildeTilde {
no warnings 'recursion';
my $self = shift;


local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;

my $C = $self->cursor_xact("RULE prefix__S_226TildeTilde");
my $xact = $C->xact;
my $S = $C->{'_pos'};
$C->{sym} = "\~\~";
$self->_MATCHIFYr($S, "prefix__S_226TildeTilde", do {
my $C = $C;
if (($C) = ($C->_EXACT("\~\~"))
and ($C) = ($C->dupprefix('~~'))) {
$C->_SUBSUMEr(['O'], sub {
my $C = shift;
$C->O(%symbolic_unary)
})
} else { () }

});
}
;
## token prefix:sym<~>
sub prefix__S_227Tilde__PEEK { $_[0]->_AUTOLEXpeek('prefix__S_227Tilde', $retree) }
sub prefix__S_227Tilde {
no warnings 'recursion';
my $self = shift;


local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;

my $C = $self->cursor_xact("RULE prefix__S_227Tilde");
my $xact = $C->xact;
my $S = $C->{'_pos'};
$C->{sym} = "\~";
$self->_MATCHIFYr($S, "prefix__S_227Tilde", do {
if (my ($C) = ($C->_EXACT("\~"))) {
$C->_SUBSUMEr(['O'], sub {
my $C = shift;
$C->O(%symbolic_unary)
})
} else { () }

});
}
;
## token prefix:sym<??>
sub prefix__S_228QuestionQuestion__PEEK { $_[0]->_AUTOLEXpeek('prefix__S_228QuestionQuestion', $retree) }
sub prefix__S_228QuestionQuestion {
no warnings 'recursion';
my $self = shift;


local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;

my $C = $self->cursor_xact("RULE prefix__S_228QuestionQuestion");
my $xact = $C->xact;
my $S = $C->{'_pos'};
$C->{sym} = "\?\?";
$self->_MATCHIFYr($S, "prefix__S_228QuestionQuestion", do {
my $C = $C;
if (($C) = ($C->_EXACT("\?\?"))
and ($C) = ($C->dupprefix('??'))) {
$C->_SUBSUMEr(['O'], sub {
my $C = shift;
$C->O(%symbolic_unary)
})
} else { () }

});
}
;
## token prefix:sym<?>
sub prefix__S_229Question__PEEK { $_[0]->_AUTOLEXpeek('prefix__S_229Question', $retree) }
sub prefix__S_229Question {
no warnings 'recursion';
my $self = shift;


local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;

my $C = $self->cursor_xact("RULE prefix__S_229Question");
my $xact = $C->xact;
my $S = $C->{'_pos'};
$C->{sym} = "\?";
$self->_MATCHIFYr($S, "prefix__S_229Question", do {
if (my ($C) = ($C->_EXACT("\?"))) {
$C->_SUBSUMEr(['O'], sub {
my $C = shift;
$C->O(%symbolic_unary)
})
} else { () }

});
}
;
## token prefix:sym<~^>
sub prefix__S_230TildeCaret__PEEK { $_[0]->_AUTOLEXpeek('prefix__S_230TildeCaret', $retree) }
sub prefix__S_230TildeCaret {
no warnings 'recursion';
my $self = shift;


local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;

my $C = $self->cursor_xact("RULE prefix__S_230TildeCaret");
my $xact = $C->xact;
my $S = $C->{'_pos'};
$C->{sym} = "\~\^";
$self->_MATCHIFYr($S, "prefix__S_230TildeCaret", do {
if (my ($C) = ($C->_EXACT("\~\^"))) {
$C->_SUBSUMEr(['O'], sub {
my $C = shift;
$C->O(%symbolic_unary)
})
} else { () }

});
}
;
## token prefix:sym<+^>
sub prefix__S_231PlusCaret__PEEK { $_[0]->_AUTOLEXpeek('prefix__S_231PlusCaret', $retree) }
sub prefix__S_231PlusCaret {
no warnings 'recursion';
my $self = shift;


local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;

my $C = $self->cursor_xact("RULE prefix__S_231PlusCaret");
my $xact = $C->xact;
my $S = $C->{'_pos'};
$C->{sym} = "\+\^";
$self->_MATCHIFYr($S, "prefix__S_231PlusCaret", do {
if (my ($C) = ($C->_EXACT("\+\^"))) {
$C->_SUBSUMEr(['O'], sub {
my $C = shift;
$C->O(%symbolic_unary)
})
} else { () }

});
}
;
## token prefix:sym<?^>
sub prefix__S_232QuestionCaret__PEEK { $_[0]->_AUTOLEXpeek('prefix__S_232QuestionCaret', $retree) }
sub prefix__S_232QuestionCaret {
no warnings 'recursion';
my $self = shift;


local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;

my $C = $self->cursor_xact("RULE prefix__S_232QuestionCaret");
my $xact = $C->xact;
my $S = $C->{'_pos'};
$C->{sym} = "\?\^";
$self->_MATCHIFYr($S, "prefix__S_232QuestionCaret", do {
if (my ($C) = ($C->_EXACT("\?\^"))) {
$C->_SUBSUMEr(['O'], sub {
my $C = shift;
$C->O(%symbolic_unary)
})
} else { () }

});
}
;
## token prefix:sym<^^>
sub prefix__S_233CaretCaret__PEEK { $_[0]->_AUTOLEXpeek('prefix__S_233CaretCaret', $retree) }
sub prefix__S_233CaretCaret {
no warnings 'recursion';
my $self = shift;


local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;

my $C = $self->cursor_xact("RULE prefix__S_233CaretCaret");
my $xact = $C->xact;
my $S = $C->{'_pos'};
$C->{sym} = "\^\^";
$self->_MATCHIFYr($S, "prefix__S_233CaretCaret", do {
my $C = $C;
if (($C) = ($C->_EXACT("\^\^"))
and ($C) = ($C->dupprefix('^^'))) {
$C->_SUBSUMEr(['O'], sub {
my $C = shift;
$C->O(%symbolic_unary)
})
} else { () }

});
}
;
## token prefix:sym<^>
sub prefix__S_234Caret__PEEK { $_[0]->_AUTOLEXpeek('prefix__S_234Caret', $retree) }
sub prefix__S_234Caret {
no warnings 'recursion';
my $self = shift;


local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;

my $C = $self->cursor_xact("RULE prefix__S_234Caret");
my $xact = $C->xact;
my $S = $C->{'_pos'};
$C->{sym} = "\^";
$self->_MATCHIFYr($S, "prefix__S_234Caret", do {
if (my ($C) = ($C->_EXACT("\^"))) {
$C->_SUBSUMEr(['O'], sub {
my $C = shift;
$C->O(%symbolic_unary)
})
} else { () }

});
}
;
## token prefix:sym<||>
sub prefix__S_235VertVert__PEEK { $_[0]->_AUTOLEXpeek('prefix__S_235VertVert', $retree) }
sub prefix__S_235VertVert {
no warnings 'recursion';
my $self = shift;


local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;

my $C = $self->cursor_xact("RULE prefix__S_235VertVert");
my $xact = $C->xact;
my $S = $C->{'_pos'};
$C->{sym} = "\|\|";
$self->_MATCHIFYr($S, "prefix__S_235VertVert", do {
if (my ($C) = ($C->_EXACT("\|\|"))) {
$C->_SUBSUMEr(['O'], sub {
my $C = shift;
$C->O(%symbolic_unary)
})
} else { () }

});
}
;
## token prefix:sym<|>
sub prefix__S_236Vert__PEEK { $_[0]->_AUTOLEXpeek('prefix__S_236Vert', $retree) }
sub prefix__S_236Vert {
no warnings 'recursion';
my $self = shift;


local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;

my $C = $self->cursor_xact("RULE prefix__S_236Vert");
my $xact = $C->xact;
my $S = $C->{'_pos'};
$C->{sym} = "\|";
$self->_MATCHIFYr($S, "prefix__S_236Vert", do {
if (my ($C) = ($C->_EXACT("\|"))) {
$C->_SUBSUMEr(['O'], sub {
my $C = shift;
$C->O(%symbolic_unary)
})
} else { () }

});
}
;
## token infix:sym<*>
sub infix__S_237Star__PEEK { $_[0]->_AUTOLEXpeek('infix__S_237Star', $retree) }
sub infix__S_237Star {
no warnings 'recursion';
my $self = shift;


local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;

my $C = $self->cursor_xact("RULE infix__S_237Star");
my $xact = $C->xact;
my $S = $C->{'_pos'};
$C->{sym} = "\*";
$self->_MATCHIFYr($S, "infix__S_237Star", do {
if (my ($C) = ($C->_EXACT("\*"))) {
$C->_SUBSUMEr(['O'], sub {
my $C = shift;
$C->O(%multiplicative)
})
} else { () }

});
}
;
## token infix:sym</>
sub infix__S_238Slash__PEEK { $_[0]->_AUTOLEXpeek('infix__S_238Slash', $retree) }
sub infix__S_238Slash {
no warnings 'recursion';
my $self = shift;


local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;

my $C = $self->cursor_xact("RULE infix__S_238Slash");
my $xact = $C->xact;
my $S = $C->{'_pos'};
$C->{sym} = "\/";
$self->_MATCHIFYr($S, "infix__S_238Slash", do {
if (my ($C) = ($C->_EXACT("\/"))) {
$C->_SUBSUMEr(['O'], sub {
my $C = shift;
$C->O(%multiplicative)
})
} else { () }

});
}
;
## token infix:sym<div>
sub infix__S_239div__PEEK { $_[0]->_AUTOLEXpeek('infix__S_239div', $retree) }
sub infix__S_239div {
no warnings 'recursion';
my $self = shift;


local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;

my $C = $self->cursor_xact("RULE infix__S_239div");
my $xact = $C->xact;
my $S = $C->{'_pos'};
$C->{sym} = "div";
$self->_MATCHIFYr($S, "infix__S_239div", do {
if (my ($C) = ($C->_EXACT("div"))) {
$C->_SUBSUMEr(['O'], sub {
my $C = shift;
$C->O(%multiplicative)
})
} else { () }

});
}
;
## token infix:sym<%>
sub infix__S_240Percent__PEEK { $_[0]->_AUTOLEXpeek('infix__S_240Percent', $retree) }
sub infix__S_240Percent {
no warnings 'recursion';
my $self = shift;


local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;

my $C = $self->cursor_xact("RULE infix__S_240Percent");
my $xact = $C->xact;
my $S = $C->{'_pos'};
$C->{sym} = "\%";
$self->_MATCHIFYr($S, "infix__S_240Percent", do {
if (my ($C) = ($C->_EXACT("\%"))) {
$C->_SUBSUMEr(['O'], sub {
my $C = shift;
$C->O(%multiplicative)
})
} else { () }

});
}
;
## token infix:sym<%%>
sub infix__S_241PercentPercent__PEEK { $_[0]->_AUTOLEXpeek('infix__S_241PercentPercent', $retree) }
sub infix__S_241PercentPercent {
no warnings 'recursion';
my $self = shift;


local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;

my $C = $self->cursor_xact("RULE infix__S_241PercentPercent");
my $xact = $C->xact;
my $S = $C->{'_pos'};
$C->{sym} = "\%\%";
$self->_MATCHIFYr($S, "infix__S_241PercentPercent", do {
if (my ($C) = ($C->_EXACT("\%\%"))) {
$C->_SUBSUMEr(['O'], sub {
my $C = shift;
$C->O(%multiplicative, iffy => 1)
})
} else { () }

});
}
;
## token infix:sym<mod>
sub infix__S_242mod__PEEK { $_[0]->_AUTOLEXpeek('infix__S_242mod', $retree) }
sub infix__S_242mod {
no warnings 'recursion';
my $self = shift;


local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;

my $C = $self->cursor_xact("RULE infix__S_242mod");
my $xact = $C->xact;
my $S = $C->{'_pos'};
$C->{sym} = "mod";
$self->_MATCHIFYr($S, "infix__S_242mod", do {
if (my ($C) = ($C->_EXACT("mod"))) {
$C->_SUBSUMEr(['O'], sub {
my $C = shift;
$C->O(%multiplicative)
})
} else { () }

});
}
;
## token infix:sym<+&>
sub infix__S_243PlusAmp__PEEK { $_[0]->_AUTOLEXpeek('infix__S_243PlusAmp', $retree) }
sub infix__S_243PlusAmp {
no warnings 'recursion';
my $self = shift;


local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;

my $C = $self->cursor_xact("RULE infix__S_243PlusAmp");
my $xact = $C->xact;
my $S = $C->{'_pos'};
$C->{sym} = "\+\&";
$self->_MATCHIFYr($S, "infix__S_243PlusAmp", do {
if (my ($C) = ($C->_EXACT("\+\&"))) {
$C->_SUBSUMEr(['O'], sub {
my $C = shift;
$C->O(%multiplicative)
})
} else { () }

});
}
;
## token infix:sym« << »
sub infix__S_244LtLt__PEEK { $_[0]->_AUTOLEXpeek('infix__S_244LtLt', $retree) }
sub infix__S_244LtLt {
no warnings 'recursion';
my $self = shift;


local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;

my $C = $self->cursor_xact("RULE infix__S_244LtLt");
my $xact = $C->xact;
my $S = $C->{'_pos'};
$C->{sym} = "\<\<";
$self->_MATCHIFYr($S, "infix__S_244LtLt", do {
my $C = $C;
if (($C) = ($C->_EXACT("\<\<"))
and ($C) = ($C->_NOTBEFORE(sub {
my $C=shift;
(($C) x !!do {
$::IN_META })
}))
and ($C) = ($C->before(sub {
my $C=shift;
if (my ($C) = ($C->before(sub {
my $C=shift;
$C->_PATTERN(qr/\G\s/)
}))) { ($C) } else { () }
}))
and ($C) = ($C->sorryobs('<< to do left shift', '+< or ~<'))) {
$C->_SUBSUMEr(['O'], sub {
my $C = shift;
$C->O(%multiplicative)
})
} else { () }

});
}
;
## token infix:sym« >> »
sub infix__S_245GtGt__PEEK { $_[0]->_AUTOLEXpeek('infix__S_245GtGt', $retree) }
sub infix__S_245GtGt {
no warnings 'recursion';
my $self = shift;


local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;

my $C = $self->cursor_xact("RULE infix__S_245GtGt");
my $xact = $C->xact;
my $S = $C->{'_pos'};
$C->{sym} = "\>\>";
$self->_MATCHIFYr($S, "infix__S_245GtGt", do {
my $C = $C;
if (($C) = ($C->_EXACT("\>\>"))
and ($C) = ($C->_NOTBEFORE(sub {
my $C=shift;
(($C) x !!do {
$::IN_META })
}))
and ($C) = ($C->before(sub {
my $C=shift;
if (my ($C) = ($C->before(sub {
my $C=shift;
$C->_PATTERN(qr/\G\s/)
}))) { ($C) } else { () }
}))
and ($C) = ($C->sorryobs('>> to do right shift', '+> or ~>'))) {
$C->_SUBSUMEr(['O'], sub {
my $C = shift;
$C->O(%multiplicative)
})
} else { () }

});
}
;
## token infix:sym<~&>
sub infix__S_246TildeAmp__PEEK { $_[0]->_AUTOLEXpeek('infix__S_246TildeAmp', $retree) }
sub infix__S_246TildeAmp {
no warnings 'recursion';
my $self = shift;


local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;

my $C = $self->cursor_xact("RULE infix__S_246TildeAmp");
my $xact = $C->xact;
my $S = $C->{'_pos'};
$C->{sym} = "\~\&";
$self->_MATCHIFYr($S, "infix__S_246TildeAmp", do {
if (my ($C) = ($C->_EXACT("\~\&"))) {
$C->_SUBSUMEr(['O'], sub {
my $C = shift;
$C->O(%multiplicative)
})
} else { () }

});
}
;
## token infix:sym<?&>
sub infix__S_247QuestionAmp__PEEK { $_[0]->_AUTOLEXpeek('infix__S_247QuestionAmp', $retree) }
sub infix__S_247QuestionAmp {
no warnings 'recursion';
my $self = shift;


local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;

my $C = $self->cursor_xact("RULE infix__S_247QuestionAmp");
my $xact = $C->xact;
my $S = $C->{'_pos'};
$C->{sym} = "\?\&";
$self->_MATCHIFYr($S, "infix__S_247QuestionAmp", do {
if (my ($C) = ($C->_EXACT("\?\&"))) {
$C->_SUBSUMEr(['O'], sub {
my $C = shift;
$C->O(%multiplicative, iffy => 1)
})
} else { () }

});
}
;
## token infix:sym« ~< »
sub infix__S_248TildeLt__PEEK { $_[0]->_AUTOLEXpeek('infix__S_248TildeLt', $retree) }
sub infix__S_248TildeLt {
no warnings 'recursion';
my $self = shift;


local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;

my $C = $self->cursor_xact("RULE infix__S_248TildeLt");
my $xact = $C->xact;
my $S = $C->{'_pos'};
$C->{sym} = "\~\<";
$self->_MATCHIFYr($S, "infix__S_248TildeLt", do {
my $C = $C;
if (($C) = ($C->_EXACT("\~\<"))
and ($C) = ($C->_BRACKETr(sub {
my $C=shift;
do {    my $C = $C->cursor_xact('ALT ||');
my $xact = $C->xact;
my @gather;
do {
push @gather, do {
if (my ($C) = ($C->_NOTBEFORE(sub {
my $C=shift;
(($C) x !!do {
$::IN_META })
}))) { ($C) } else { () }

}
}
or $xact->[-2] or
do {
push @gather, do {
if (my ($C) = ($C->before(sub {
my $C=shift;
if (my ($C) = ($C->before(sub {
my $C=shift;
$C->_EXACT("\<\<")
}))) { ($C) } else { () }
}))) { ($C) } else { () }

}
}
or $xact->[-2] or
do {
push @gather, do {
if (my ($C) = ($C->_NOTBEFORE(sub {
my $C=shift;
if (my ($C) = ($C->before(sub {
my $C=shift;
$C->_EXACT("\<")
}))) { ($C) } else { () }
}))) { ($C) } else { () }

}
};
@gather;
}
}))) {
$C->_SUBSUMEr(['O'], sub {
my $C = shift;
$C->O(%multiplicative)
})
} else { () }

});
}
;
## token infix:sym« ~> »
sub infix__S_249TildeGt__PEEK { $_[0]->_AUTOLEXpeek('infix__S_249TildeGt', $retree) }
sub infix__S_249TildeGt {
no warnings 'recursion';
my $self = shift;


local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;

my $C = $self->cursor_xact("RULE infix__S_249TildeGt");
my $xact = $C->xact;
my $S = $C->{'_pos'};
$C->{sym} = "\~\>";
$self->_MATCHIFYr($S, "infix__S_249TildeGt", do {
my $C = $C;
if (($C) = ($C->_EXACT("\~\>"))
and ($C) = ($C->_BRACKETr(sub {
my $C=shift;
do {    my $C = $C->cursor_xact('ALT ||');
my $xact = $C->xact;
my @gather;
do {
push @gather, do {
if (my ($C) = ($C->_NOTBEFORE(sub {
my $C=shift;
(($C) x !!do {
$::IN_META })
}))) { ($C) } else { () }

}
}
or $xact->[-2] or
do {
push @gather, do {
if (my ($C) = ($C->before(sub {
my $C=shift;
if (my ($C) = ($C->before(sub {
my $C=shift;
$C->_EXACT("\>\>")
}))) { ($C) } else { () }
}))) { ($C) } else { () }

}
}
or $xact->[-2] or
do {
push @gather, do {
if (my ($C) = ($C->_NOTBEFORE(sub {
my $C=shift;
if (my ($C) = ($C->before(sub {
my $C=shift;
$C->_EXACT("\>")
}))) { ($C) } else { () }
}))) { ($C) } else { () }

}
};
@gather;
}
}))) {
$C->_SUBSUMEr(['O'], sub {
my $C = shift;
$C->O(%multiplicative)
})
} else { () }

});
}
;
## token infix:sym« +< »
sub infix__S_250PlusLt__PEEK { $_[0]->_AUTOLEXpeek('infix__S_250PlusLt', $retree) }
sub infix__S_250PlusLt {
no warnings 'recursion';
my $self = shift;


local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;

my $C = $self->cursor_xact("RULE infix__S_250PlusLt");
my $xact = $C->xact;
my $S = $C->{'_pos'};
$C->{sym} = "\+\<";
$self->_MATCHIFYr($S, "infix__S_250PlusLt", do {
my $C = $C;
if (($C) = ($C->_EXACT("\+\<"))
and ($C) = ($C->_BRACKETr(sub {
my $C=shift;
do {    my $C = $C->cursor_xact('ALT ||');
my $xact = $C->xact;
my @gather;
do {
push @gather, do {
if (my ($C) = ($C->_NOTBEFORE(sub {
my $C=shift;
(($C) x !!do {
$::IN_META })
}))) { ($C) } else { () }

}
}
or $xact->[-2] or
do {
push @gather, do {
if (my ($C) = ($C->before(sub {
my $C=shift;
if (my ($C) = ($C->before(sub {
my $C=shift;
$C->_EXACT("\<\<")
}))) { ($C) } else { () }
}))) { ($C) } else { () }

}
}
or $xact->[-2] or
do {
push @gather, do {
if (my ($C) = ($C->_NOTBEFORE(sub {
my $C=shift;
if (my ($C) = ($C->before(sub {
my $C=shift;
$C->_EXACT("\<")
}))) { ($C) } else { () }
}))) { ($C) } else { () }

}
};
@gather;
}
}))) {
$C->_SUBSUMEr(['O'], sub {
my $C = shift;
$C->O(%multiplicative)
})
} else { () }

});
}
;
## token infix:sym« +> »
sub infix__S_251PlusGt__PEEK { $_[0]->_AUTOLEXpeek('infix__S_251PlusGt', $retree) }
sub infix__S_251PlusGt {
no warnings 'recursion';
my $self = shift;


local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;

my $C = $self->cursor_xact("RULE infix__S_251PlusGt");
my $xact = $C->xact;
my $S = $C->{'_pos'};
$C->{sym} = "\+\>";
$self->_MATCHIFYr($S, "infix__S_251PlusGt", do {
my $C = $C;
if (($C) = ($C->_EXACT("\+\>"))
and ($C) = ($C->_BRACKETr(sub {
my $C=shift;
do {    my $C = $C->cursor_xact('ALT ||');
my $xact = $C->xact;
my @gather;
do {
push @gather, do {
if (my ($C) = ($C->_NOTBEFORE(sub {
my $C=shift;
(($C) x !!do {
$::IN_META })
}))) { ($C) } else { () }

}
}
or $xact->[-2] or
do {
push @gather, do {
if (my ($C) = ($C->before(sub {
my $C=shift;
if (my ($C) = ($C->before(sub {
my $C=shift;
$C->_EXACT("\>\>")
}))) { ($C) } else { () }
}))) { ($C) } else { () }

}
}
or $xact->[-2] or
do {
push @gather, do {
if (my ($C) = ($C->_NOTBEFORE(sub {
my $C=shift;
if (my ($C) = ($C->before(sub {
my $C=shift;
$C->_EXACT("\>")
}))) { ($C) } else { () }
}))) { ($C) } else { () }

}
};
@gather;
}
}))) {
$C->_SUBSUMEr(['O'], sub {
my $C = shift;
$C->O(%multiplicative)
})
} else { () }

});
}
;
## token infix:sym<+>
sub infix__S_252Plus__PEEK { $_[0]->_AUTOLEXpeek('infix__S_252Plus', $retree) }
sub infix__S_252Plus {
no warnings 'recursion';
my $self = shift;


local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;

my $C = $self->cursor_xact("RULE infix__S_252Plus");
my $xact = $C->xact;
my $S = $C->{'_pos'};
$C->{sym} = "\+";
$self->_MATCHIFYr($S, "infix__S_252Plus", do {
my $C = $C;
if (($C) = ($C->_EXACT("\+"))
and ($C) = ($C->_NOTBEFORE(sub {
my $C=shift;
if (my ($C) = ($C->before(sub {
my $C=shift;
$C->_EXACT("\+")
}))) { ($C) } else { () }
}))) {
$C->_SUBSUMEr(['O'], sub {
my $C = shift;
$C->O(%additive)
})
} else { () }

});
}
;
## token infix:sym<->
sub infix__S_253Minus__PEEK { $_[0]->_AUTOLEXpeek('infix__S_253Minus', $retree) }
sub infix__S_253Minus {
no warnings 'recursion';
my $self = shift;


local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;

my $C = $self->cursor_xact("RULE infix__S_253Minus");
my $xact = $C->xact;
my $S = $C->{'_pos'};
$C->{sym} = "\-";
$self->_MATCHIFYr($S, "infix__S_253Minus", do {
my $C = $C;
if (($C) = ($C->_EXACT("\-"))
and ($C) = ($C->_NOTBEFORE(sub {
my $C=shift;
if (my ($C) = ($C->before(sub {
my $C=shift;
$C->_EXACT("\-")
}))) { ($C) } else { () }
}))) {
$C->_SUBSUMEr(['O'], sub {
my $C = shift;
$C->O(%additive)
})
} else { () }

});
}
;
## token infix:sym<+|>
sub infix__S_254PlusVert__PEEK { $_[0]->_AUTOLEXpeek('infix__S_254PlusVert', $retree) }
sub infix__S_254PlusVert {
no warnings 'recursion';
my $self = shift;


local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;

my $C = $self->cursor_xact("RULE infix__S_254PlusVert");
my $xact = $C->xact;
my $S = $C->{'_pos'};
$C->{sym} = "\+\|";
$self->_MATCHIFYr($S, "infix__S_254PlusVert", do {
if (my ($C) = ($C->_EXACT("\+\|"))) {
$C->_SUBSUMEr(['O'], sub {
my $C = shift;
$C->O(%additive)
})
} else { () }

});
}
;
## token infix:sym<+^>
sub infix__S_255PlusCaret__PEEK { $_[0]->_AUTOLEXpeek('infix__S_255PlusCaret', $retree) }
sub infix__S_255PlusCaret {
no warnings 'recursion';
my $self = shift;


local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;

my $C = $self->cursor_xact("RULE infix__S_255PlusCaret");
my $xact = $C->xact;
my $S = $C->{'_pos'};
$C->{sym} = "\+\^";
$self->_MATCHIFYr($S, "infix__S_255PlusCaret", do {
if (my ($C) = ($C->_EXACT("\+\^"))) {
$C->_SUBSUMEr(['O'], sub {
my $C = shift;
$C->O(%additive)
})
} else { () }

});
}
;
## token infix:sym<~|>
sub infix__S_256TildeVert__PEEK { $_[0]->_AUTOLEXpeek('infix__S_256TildeVert', $retree) }
sub infix__S_256TildeVert {
no warnings 'recursion';
my $self = shift;


local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;

my $C = $self->cursor_xact("RULE infix__S_256TildeVert");
my $xact = $C->xact;
my $S = $C->{'_pos'};
$C->{sym} = "\~\|";
$self->_MATCHIFYr($S, "infix__S_256TildeVert", do {
if (my ($C) = ($C->_EXACT("\~\|"))) {
$C->_SUBSUMEr(['O'], sub {
my $C = shift;
$C->O(%additive)
})
} else { () }

});
}
;
## token infix:sym<~^>
sub infix__S_257TildeCaret__PEEK { $_[0]->_AUTOLEXpeek('infix__S_257TildeCaret', $retree) }
sub infix__S_257TildeCaret {
no warnings 'recursion';
my $self = shift;


local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;

my $C = $self->cursor_xact("RULE infix__S_257TildeCaret");
my $xact = $C->xact;
my $S = $C->{'_pos'};
$C->{sym} = "\~\^";
$self->_MATCHIFYr($S, "infix__S_257TildeCaret", do {
if (my ($C) = ($C->_EXACT("\~\^"))) {
$C->_SUBSUMEr(['O'], sub {
my $C = shift;
$C->O(%additive)
})
} else { () }

});
}
;
## token infix:sym<?|>
sub infix__S_258QuestionVert__PEEK { $_[0]->_AUTOLEXpeek('infix__S_258QuestionVert', $retree) }
sub infix__S_258QuestionVert {
no warnings 'recursion';
my $self = shift;


local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;

my $C = $self->cursor_xact("RULE infix__S_258QuestionVert");
my $xact = $C->xact;
my $S = $C->{'_pos'};
$C->{sym} = "\?\|";
$self->_MATCHIFYr($S, "infix__S_258QuestionVert", do {
if (my ($C) = ($C->_EXACT("\?\|"))) {
$C->_SUBSUMEr(['O'], sub {
my $C = shift;
$C->O(%additive, iffy => 1)
})
} else { () }

});
}
;
## token infix:sym<?^>
sub infix__S_259QuestionCaret__PEEK { $_[0]->_AUTOLEXpeek('infix__S_259QuestionCaret', $retree) }
sub infix__S_259QuestionCaret {
no warnings 'recursion';
my $self = shift;


local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;

my $C = $self->cursor_xact("RULE infix__S_259QuestionCaret");
my $xact = $C->xact;
my $S = $C->{'_pos'};
$C->{sym} = "\?\^";
$self->_MATCHIFYr($S, "infix__S_259QuestionCaret", do {
if (my ($C) = ($C->_EXACT("\?\^"))) {
$C->_SUBSUMEr(['O'], sub {
my $C = shift;
$C->O(%additive)
})
} else { () }

});
}
;
## token infix:sym<x>
sub infix__S_260x__PEEK { $_[0]->_AUTOLEXpeek('infix__S_260x', $retree) }
sub infix__S_260x {
no warnings 'recursion';
my $self = shift;


local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;

my $C = $self->cursor_xact("RULE infix__S_260x");
my $xact = $C->xact;
my $S = $C->{'_pos'};
$C->{sym} = "x";
$self->_MATCHIFYr($S, "infix__S_260x", do {
if (my ($C) = ($C->_EXACT("x"))) {
$C->_SUBSUMEr(['O'], sub {
my $C = shift;
$C->O(%replication)
})
} else { () }

});
}
;
## token infix:sym<xx>
sub infix__S_261xx__PEEK { $_[0]->_AUTOLEXpeek('infix__S_261xx', $retree) }
sub infix__S_261xx {
no warnings 'recursion';
my $self = shift;


local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;

my $C = $self->cursor_xact("RULE infix__S_261xx");
my $xact = $C->xact;
my $S = $C->{'_pos'};
$C->{sym} = "xx";
$self->_MATCHIFYr($S, "infix__S_261xx", do {
if (my ($C) = ($C->_EXACT("xx"))) {
$C->_SUBSUMEr(['O'], sub {
my $C = shift;
$C->O(%replication)
})
} else { () }

});
}
;
## token infix:sym<~>
sub infix__S_262Tilde__PEEK { $_[0]->_AUTOLEXpeek('infix__S_262Tilde', $retree) }
sub infix__S_262Tilde {
no warnings 'recursion';
my $self = shift;


local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;

my $C = $self->cursor_xact("RULE infix__S_262Tilde");
my $xact = $C->xact;
my $S = $C->{'_pos'};
$C->{sym} = "\~";
$self->_MATCHIFYr($S, "infix__S_262Tilde", do {
if (my ($C) = ($C->_EXACT("\~"))) {
$C->_SUBSUMEr(['O'], sub {
my $C = shift;
$C->O(%concatenation)
})
} else { () }

});
}
;
## token infix:sym<&>
sub infix__S_263Amp__PEEK { $_[0]->_AUTOLEXpeek('infix__S_263Amp', $retree) }
sub infix__S_263Amp {
no warnings 'recursion';
my $self = shift;


local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;

my $C = $self->cursor_xact("RULE infix__S_263Amp");
my $xact = $C->xact;
my $S = $C->{'_pos'};
$C->{sym} = "\&";
$self->_MATCHIFYr($S, "infix__S_263Amp", do {
if (my ($C) = ($C->_EXACT("\&"))) {
$C->_SUBSUMEr(['O'], sub {
my $C = shift;
$C->O(%junctive_and, iffy => 1)
})
} else { () }

});
}
;
## token infix:sym<|>
sub infix__S_264Vert__PEEK { $_[0]->_AUTOLEXpeek('infix__S_264Vert', $retree) }
sub infix__S_264Vert {
no warnings 'recursion';
my $self = shift;


local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;

my $C = $self->cursor_xact("RULE infix__S_264Vert");
my $xact = $C->xact;
my $S = $C->{'_pos'};
$C->{sym} = "\|";
$self->_MATCHIFYr($S, "infix__S_264Vert", do {
if (my ($C) = ($C->_EXACT("\|"))) {
$C->_SUBSUMEr(['O'], sub {
my $C = shift;
$C->O(%junctive_or, iffy => 1)
})
} else { () }

});
}
;
## token infix:sym<^>
sub infix__S_265Caret__PEEK { $_[0]->_AUTOLEXpeek('infix__S_265Caret', $retree) }
sub infix__S_265Caret {
no warnings 'recursion';
my $self = shift;


local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;

my $C = $self->cursor_xact("RULE infix__S_265Caret");
my $xact = $C->xact;
my $S = $C->{'_pos'};
$C->{sym} = "\^";
$self->_MATCHIFYr($S, "infix__S_265Caret", do {
if (my ($C) = ($C->_EXACT("\^"))) {
$C->_SUBSUMEr(['O'], sub {
my $C = shift;
$C->O(%junctive_or, iffy => 1)
})
} else { () }

});
}
;
## token prefix:sleep
sub prefix__S_266sleep__PEEK { $_[0]->_AUTOLEXpeek('prefix__S_266sleep', $retree) }
sub prefix__S_266sleep {
no warnings 'recursion';
my $self = shift;


local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;

my $C = $self->cursor_xact("RULE prefix__S_266sleep");
my $xact = $C->xact;
my $S = $C->{'_pos'};
$C->{sym} = "sleep";
$self->_MATCHIFYr($S, "prefix__S_266sleep", do {
my $C = $C;
if (($C) = ($C->_PATTERN(qr/\Gsleep\b/))
and ($C) = ($C->before(sub {
my $C=shift;
if (my ($C) = ($C->before(sub {
my $C=shift;
$C->_PATTERN(qr/\G\s*+/)
}))) { ($C) } else { () }
}))) {
$C->_SUBSUMEr(['O'], sub {
my $C = shift;
$C->O(%named_unary)
})
} else { () }

});
}
;
## token prefix:abs
sub prefix__S_267abs__PEEK { $_[0]->_AUTOLEXpeek('prefix__S_267abs', $retree) }
sub prefix__S_267abs {
no warnings 'recursion';
my $self = shift;


local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;

my $C = $self->cursor_xact("RULE prefix__S_267abs");
my $xact = $C->xact;
my $S = $C->{'_pos'};
$C->{sym} = "abs";
$self->_MATCHIFYr($S, "prefix__S_267abs", do {
my $C = $C;
if (($C) = ($C->_PATTERN(qr/\Gabs\b/))
and ($C) = ($C->before(sub {
my $C=shift;
if (my ($C) = ($C->before(sub {
my $C=shift;
$C->_PATTERN(qr/\G\s*+/)
}))) { ($C) } else { () }
}))) {
$C->_SUBSUMEr(['O'], sub {
my $C = shift;
$C->O(%named_unary)
})
} else { () }

});
}
;
## token prefix:let
sub prefix__S_268let__PEEK { $_[0]->_AUTOLEXpeek('prefix__S_268let', $retree) }
sub prefix__S_268let {
no warnings 'recursion';
my $self = shift;


local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;

my $C = $self->cursor_xact("RULE prefix__S_268let");
my $xact = $C->xact;
my $S = $C->{'_pos'};
$C->{sym} = "let";
$self->_MATCHIFYr($S, "prefix__S_268let", do {
my $C = $C;
if (($C) = ($C->_PATTERN(qr/\Glet\b/))
and ($C) = ($C->before(sub {
my $C=shift;
if (my ($C) = ($C->before(sub {
my $C=shift;
$C->_PATTERN(qr/\G\s*+/)
}))) { ($C) } else { () }
}))) {
$C->_SUBSUMEr(['O'], sub {
my $C = shift;
$C->O(%named_unary)
})
} else { () }

});
}
;
## token prefix:temp
sub prefix__S_269temp__PEEK { $_[0]->_AUTOLEXpeek('prefix__S_269temp', $retree) }
sub prefix__S_269temp {
no warnings 'recursion';
my $self = shift;


local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;

my $C = $self->cursor_xact("RULE prefix__S_269temp");
my $xact = $C->xact;
my $S = $C->{'_pos'};
$C->{sym} = "temp";
$self->_MATCHIFYr($S, "prefix__S_269temp", do {
my $C = $C;
if (($C) = ($C->_PATTERN(qr/\Gtemp\b/))
and ($C) = ($C->before(sub {
my $C=shift;
if (my ($C) = ($C->before(sub {
my $C=shift;
$C->_PATTERN(qr/\G\s*+/)
}))) { ($C) } else { () }
}))) {
$C->_SUBSUMEr(['O'], sub {
my $C = shift;
$C->O(%named_unary)
})
} else { () }

});
}
;
## token infix:sym« <=> »
sub infix__S_270LtEqualGt__PEEK { $_[0]->_AUTOLEXpeek('infix__S_270LtEqualGt', $retree) }
sub infix__S_270LtEqualGt {
no warnings 'recursion';
my $self = shift;


local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;

my $C = $self->cursor_xact("RULE infix__S_270LtEqualGt");
my $xact = $C->xact;
my $S = $C->{'_pos'};
$C->{sym} = "\<\=\>";
$self->_MATCHIFYr($S, "infix__S_270LtEqualGt", do {
if (my ($C) = ($C->_EXACT("\<\=\>"))) {
$C->_SUBSUMEr(['O'], sub {
my $C = shift;
$C->O(%structural, returns => 'Order')
})
} else { () }

});
}
;
## token infix:cmp
sub infix__S_271cmp__PEEK { $_[0]->_AUTOLEXpeek('infix__S_271cmp', $retree) }
sub infix__S_271cmp {
no warnings 'recursion';
my $self = shift;


local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;

my $C = $self->cursor_xact("RULE infix__S_271cmp");
my $xact = $C->xact;
my $S = $C->{'_pos'};
$C->{sym} = "cmp";
$self->_MATCHIFYr($S, "infix__S_271cmp", do {
if (my ($C) = ($C->_EXACT("cmp"))) {
$C->_SUBSUMEr(['O'], sub {
my $C = shift;
$C->O(%structural, returns => 'Order')
})
} else { () }

});
}
;
## token infix:leg
sub infix__S_272leg__PEEK { $_[0]->_AUTOLEXpeek('infix__S_272leg', $retree) }
sub infix__S_272leg {
no warnings 'recursion';
my $self = shift;


local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;

my $C = $self->cursor_xact("RULE infix__S_272leg");
my $xact = $C->xact;
my $S = $C->{'_pos'};
$C->{sym} = "leg";
$self->_MATCHIFYr($S, "infix__S_272leg", do {
if (my ($C) = ($C->_EXACT("leg"))) {
$C->_SUBSUMEr(['O'], sub {
my $C = shift;
$C->O(%structural, returns => 'Order')
})
} else { () }

});
}
;
## token infix:but
sub infix__S_273but__PEEK { $_[0]->_AUTOLEXpeek('infix__S_273but', $retree) }
sub infix__S_273but {
no warnings 'recursion';
my $self = shift;


local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;

my $C = $self->cursor_xact("RULE infix__S_273but");
my $xact = $C->xact;
my $S = $C->{'_pos'};
$C->{sym} = "but";
$self->_MATCHIFYr($S, "infix__S_273but", do {
if (my ($C) = ($C->_EXACT("but"))) {
$C->_SUBSUMEr(['O'], sub {
my $C = shift;
$C->O(%structural)
})
} else { () }

});
}
;
## token infix:does
sub infix__S_274does__PEEK { $_[0]->_AUTOLEXpeek('infix__S_274does', $retree) }
sub infix__S_274does {
no warnings 'recursion';
my $self = shift;


local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;

my $C = $self->cursor_xact("RULE infix__S_274does");
my $xact = $C->xact;
my $S = $C->{'_pos'};
$C->{sym} = "does";
$self->_MATCHIFYr($S, "infix__S_274does", do {
if (my ($C) = ($C->_EXACT("does"))) {
$C->_SUBSUMEr(['O'], sub {
my $C = shift;
$C->O(%structural)
})
} else { () }

});
}
;
## token infix:sym<..>
sub infix__S_275DotDot__PEEK { $_[0]->_AUTOLEXpeek('infix__S_275DotDot', $retree) }
sub infix__S_275DotDot {
no warnings 'recursion';
my $self = shift;


local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;

my $C = $self->cursor_xact("RULE infix__S_275DotDot");
my $xact = $C->xact;
my $S = $C->{'_pos'};
$C->{sym} = "\.\.";
$self->_MATCHIFYr($S, "infix__S_275DotDot", do {
my $C = $C;
if (($C) = ($C->_EXACT("\.\."))
and ($C) = ($C->_OPTr(sub {
my $C=shift;
if (my ($C) = ($C->_BRACKETr(sub {
my $C=shift;
if (($C) = ($C->_NOTBEFORE(sub {
my $C=shift;
(($C) x !!do {
$::IN_META })
}))
and ($C) = ($C->before(sub {
my $C=shift;
if (my ($C) = ($C->before(sub {
my $C=shift;
if (my ($C) = (do {
do {
my ($tag, $try);
my @try;
my $relex;

my $fate;
my $x;
if ($fate = $C->{'_fate'} and $fate->[1] eq 'infix__S_275DotDot_0') {
$C->deb("Fate passed to infix__S_275DotDot_0: ", ::fatestr($fate)) if $::DEBUG & DEBUG::fates;
($C->{'_fate'}, $tag, $try) = @$fate;
@try = ($try);
$x = 'ALT infix__S_275DotDot_0';    # some outer ltm is controlling us
}
else {
$x = 'ALTLTM infix__S_275DotDot_0'; # we are top level ltm
}
my $C = $C->cursor_xact($x);
my $xact = $C->{_xact};

my @gather = ();
for (;;) {
unless (@try) {
$relex //= $C->cursor_fate('STD::P6', 'infix__S_275DotDot_0', $retree);
@try = $relex->($C) or last;
}
$try = shift(@try) // next;

if (ref $try) {
($C->{'_fate'}, $tag, $try) = @$try;   # next candidate fate
}

$C->deb("infix__S_275DotDot_0 trying $tag $try") if $::DEBUG & DEBUG::try_processing;
push @gather, ((
sub {
my $C=shift;
$C->_EXACT("\)")
},
sub {
my $C=shift;
$C->_EXACT("\]")
}
)[$try])->($C);
last if @gather;
last if $xact->[-2];  # committed?
}
@gather;
};

})) { ($C) } else { () }
}))) { ($C) } else { () }
}))
and ($C) = ($C->panic("Please use ..* for indefinite range"))) {
$C
} else { () }
}))) { ($C) } else { () }
}))) {
$C->_SUBSUMEr(['O'], sub {
my $C = shift;
$C->O(%structural)
})
} else { () }

});
}
;
## token infix:sym<^..>
sub infix__S_276CaretDotDot__PEEK { $_[0]->_AUTOLEXpeek('infix__S_276CaretDotDot', $retree) }
sub infix__S_276CaretDotDot {
no warnings 'recursion';
my $self = shift;


local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;

my $C = $self->cursor_xact("RULE infix__S_276CaretDotDot");
my $xact = $C->xact;
my $S = $C->{'_pos'};
$C->{sym} = "\^\.\.";
$self->_MATCHIFYr($S, "infix__S_276CaretDotDot", do {
if (my ($C) = ($C->_EXACT("\^\.\."))) {
$C->_SUBSUMEr(['O'], sub {
my $C = shift;
$C->O(%structural)
})
} else { () }

});
}
;
## token infix:sym<..^>
sub infix__S_277DotDotCaret__PEEK { $_[0]->_AUTOLEXpeek('infix__S_277DotDotCaret', $retree) }
sub infix__S_277DotDotCaret {
no warnings 'recursion';
my $self = shift;


local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;

my $C = $self->cursor_xact("RULE infix__S_277DotDotCaret");
my $xact = $C->xact;
my $S = $C->{'_pos'};
$C->{sym} = "\.\.\^";
$self->_MATCHIFYr($S, "infix__S_277DotDotCaret", do {
if (my ($C) = ($C->_EXACT("\.\.\^"))) {
$C->_SUBSUMEr(['O'], sub {
my $C = shift;
$C->O(%structural)
})
} else { () }

});
}
;
## token infix:sym<^..^>
sub infix__S_278CaretDotDotCaret__PEEK { $_[0]->_AUTOLEXpeek('infix__S_278CaretDotDotCaret', $retree) }
sub infix__S_278CaretDotDotCaret {
no warnings 'recursion';
my $self = shift;


local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;

my $C = $self->cursor_xact("RULE infix__S_278CaretDotDotCaret");
my $xact = $C->xact;
my $S = $C->{'_pos'};
$C->{sym} = "\^\.\.\^";
$self->_MATCHIFYr($S, "infix__S_278CaretDotDotCaret", do {
if (my ($C) = ($C->_EXACT("\^\.\.\^"))) {
$C->_SUBSUMEr(['O'], sub {
my $C = shift;
$C->O(%structural)
})
} else { () }

});
}
;
## token infix:sym<==>
sub infix__S_279EqualEqual__PEEK { $_[0]->_AUTOLEXpeek('infix__S_279EqualEqual', $retree) }
sub infix__S_279EqualEqual {
no warnings 'recursion';
my $self = shift;


local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;

my $C = $self->cursor_xact("RULE infix__S_279EqualEqual");
my $xact = $C->xact;
my $S = $C->{'_pos'};
$C->{sym} = "\=\=";
$self->_MATCHIFYr($S, "infix__S_279EqualEqual", do {
my $C = $C;
if (($C) = ($C->_EXACT("\=\="))
and ($C) = ($C->_NOTBEFORE(sub {
my $C=shift;
if (my ($C) = ($C->before(sub {
my $C=shift;
$C->_EXACT("\=")
}))) { ($C) } else { () }
}))) {
$C->_SUBSUMEr(['O'], sub {
my $C = shift;
$C->O(%chaining)
})
} else { () }

});
}
;
## token infix:sym<!=>
sub infix__S_280BangEqual__PEEK { $_[0]->_AUTOLEXpeek('infix__S_280BangEqual', $retree) }
sub infix__S_280BangEqual {
no warnings 'recursion';
my $self = shift;


local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;

my $C = $self->cursor_xact("RULE infix__S_280BangEqual");
my $xact = $C->xact;
my $S = $C->{'_pos'};
$C->{sym} = "\!\=";
$self->_MATCHIFYr($S, "infix__S_280BangEqual", do {
my $C = $C;
if (($C) = ($C->_EXACT("\!\="))
and ($C) = ($C->before(sub {
my $C=shift;
if (my ($C) = ($C->before(sub {
my $C=shift;
$C->_PATTERN(qr/\G\s/)
}))) { ($C) } else { () }
}))) {
$C->_SUBSUMEr(['O'], sub {
my $C = shift;
$C->O(%chaining)
})
} else { () }

});
}
;
## token infix:sym« < »
sub infix__S_281Lt__PEEK { $_[0]->_AUTOLEXpeek('infix__S_281Lt', $retree) }
sub infix__S_281Lt {
no warnings 'recursion';
my $self = shift;


local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;

my $C = $self->cursor_xact("RULE infix__S_281Lt");
my $xact = $C->xact;
my $S = $C->{'_pos'};
$C->{sym} = "\<";
$self->_MATCHIFYr($S, "infix__S_281Lt", do {
my $C = $C;
if (($C) = ($C->_EXACT("\<"))
and ($C) = ($C->_NOTBEFORE(sub {
my $C=shift;
if (my ($C) = ($C->before(sub {
my $C=shift;
$C->_EXACT("\<")
}))) { ($C) } else { () }
}))) {
$C->_SUBSUMEr(['O'], sub {
my $C = shift;
$C->O(%chaining)
})
} else { () }

});
}
;
## token infix:sym« <= »
sub infix__S_282LtEqual__PEEK { $_[0]->_AUTOLEXpeek('infix__S_282LtEqual', $retree) }
sub infix__S_282LtEqual {
no warnings 'recursion';
my $self = shift;


local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;

my $C = $self->cursor_xact("RULE infix__S_282LtEqual");
my $xact = $C->xact;
my $S = $C->{'_pos'};
$C->{sym} = "\<\=";
$self->_MATCHIFYr($S, "infix__S_282LtEqual", do {
if (my ($C) = ($C->_EXACT("\<\="))) {
$C->_SUBSUMEr(['O'], sub {
my $C = shift;
$C->O(%chaining)
})
} else { () }

});
}
;
## token infix:sym« > »
sub infix__S_283Gt__PEEK { $_[0]->_AUTOLEXpeek('infix__S_283Gt', $retree) }
sub infix__S_283Gt {
no warnings 'recursion';
my $self = shift;


local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;

my $C = $self->cursor_xact("RULE infix__S_283Gt");
my $xact = $C->xact;
my $S = $C->{'_pos'};
$C->{sym} = "\>";
$self->_MATCHIFYr($S, "infix__S_283Gt", do {
my $C = $C;
if (($C) = ($C->_EXACT("\>"))
and ($C) = ($C->_NOTBEFORE(sub {
my $C=shift;
if (my ($C) = ($C->before(sub {
my $C=shift;
$C->_EXACT("\>")
}))) { ($C) } else { () }
}))) {
$C->_SUBSUMEr(['O'], sub {
my $C = shift;
$C->O(%chaining)
})
} else { () }

});
}
;
## token infix:sym« >= »
sub infix__S_284GtEqual__PEEK { $_[0]->_AUTOLEXpeek('infix__S_284GtEqual', $retree) }
sub infix__S_284GtEqual {
no warnings 'recursion';
my $self = shift;


local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;

my $C = $self->cursor_xact("RULE infix__S_284GtEqual");
my $xact = $C->xact;
my $S = $C->{'_pos'};
$C->{sym} = "\>\=";
$self->_MATCHIFYr($S, "infix__S_284GtEqual", do {
if (my ($C) = ($C->_EXACT("\>\="))) {
$C->_SUBSUMEr(['O'], sub {
my $C = shift;
$C->O(%chaining)
})
} else { () }

});
}
;
## token infix:sym<~~>
sub infix__S_285TildeTilde__PEEK { $_[0]->_AUTOLEXpeek('infix__S_285TildeTilde', $retree) }
sub infix__S_285TildeTilde {
no warnings 'recursion';
my $self = shift;


local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;

my $C = $self->cursor_xact("RULE infix__S_285TildeTilde");
my $xact = $C->xact;
my $S = $C->{'_pos'};
$C->{sym} = "\~\~";
$self->_MATCHIFYr($S, "infix__S_285TildeTilde", do {
my $C = $C;
if (($C) = ($C->_EXACT("\~\~"))
and ($C) = ($C->_SUBSUMEr(['O'], sub {
my $C = shift;
$C->O(%chaining)
}))
and ($C) = ($C->before(sub {
my $C=shift;
if (my ($C) = ($C->dumbsmart)) { ($C) } else { () }
}))) {
$C
} else { () }

});
}
;
## token dumbsmart {
sub dumbsmart__PEEK { $_[0]->_AUTOLEXpeek('dumbsmart', $retree) }
sub dumbsmart {
no warnings 'recursion';
my $self = shift;


local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;

my $C = $self->cursor_xact("RULE dumbsmart");
my $xact = $C->xact;
my $S = $C->{'_pos'};
$C->{'0'} = [];
$self->_MATCHIFYr($S, "dumbsmart", $C->_OPTr(sub {
my $C=shift;
if (my ($C) = ($C->_BRACKETr(sub {
my $C=shift;
if (($C) = ($C->_PATTERN(qr/\G[\x20\t\r]*+/))
and ($C) = ($C->_SUBSUMEr(['0'], sub {
my $C = shift;
$C->_PAREN( sub {
my $C=shift;
if (my ($C) = (do {
do {
my ($tag, $try);
my @try;
my $relex;

my $fate;
my $x;
if ($fate = $C->{'_fate'} and $fate->[1] eq 'dumbsmart_0') {
$C->deb("Fate passed to dumbsmart_0: ", ::fatestr($fate)) if $::DEBUG & DEBUG::fates;
($C->{'_fate'}, $tag, $try) = @$fate;
@try = ($try);
$x = 'ALT dumbsmart_0';    # some outer ltm is controlling us
}
else {
$x = 'ALTLTM dumbsmart_0'; # we are top level ltm
}
my $C = $C->cursor_xact($x);
my $xact = $C->{_xact};

my @gather = ();
for (;;) {
unless (@try) {
$relex //= $C->cursor_fate('STD::P6', 'dumbsmart_0', $retree);
@try = $relex->($C) or last;
}
$try = shift(@try) // next;

if (ref $try) {
($C->{'_fate'}, $tag, $try) = @$try;   # next candidate fate
}

$C->deb("dumbsmart_0 trying $tag $try") if $::DEBUG & DEBUG::try_processing;
push @gather, ((
sub {
my $C=shift;
$C->_EXACT("True")
},
sub {
my $C=shift;
$C->_EXACT("False")
},
sub {
my $C=shift;
$C->_EXACT("Bool\:\:True")
},
sub {
my $C=shift;
$C->_EXACT("Bool\:\:False")
}
)[$try])->($C);
last if @gather;
last if $xact->[-2];  # committed?
}
@gather;
};

})) { ($C) } else { () }

})
}))
and ($C) = ($C->before(sub {
my $C=shift;
if (my ($C) = ($C->before(sub {
my $C=shift;
$C->_PATTERN(qr/\G\s/)
}))) { ($C) } else { () }
}))) {
scalar(do {
my $M = $C;
my $litbool = $M->{0}->[0]->Str;
my $true = $litbool =~ /True/;
$self->worry("Smartmatch against $litbool always " .
($true ? 'matches' : 'fails') .
"; if you mean to test the topic for\n    truthiness, please use " .
($true ? ':so or *.so or ?*' : ':!so or *.not or !*') .
' instead');
}, $C)
} else { () }
}))) { ($C) } else { () }
}));
}
;
## token infix:sym<!~>
sub infix__S_286BangTilde__PEEK { $_[0]->_AUTOLEXpeek('infix__S_286BangTilde', $retree) }
sub infix__S_286BangTilde {
no warnings 'recursion';
my $self = shift;


local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;

my $C = $self->cursor_xact("RULE infix__S_286BangTilde");
my $xact = $C->xact;
my $S = $C->{'_pos'};
$C->{sym} = "\!\~";
$self->_MATCHIFYr($S, "infix__S_286BangTilde", do {
my $C = $C;
if (($C) = ($C->_PATTERN(qr/\G\!\~\s/))
and ($C) = ($C->obs('!~ to do negated pattern matching', '!~~'))) {
$C->_SUBSUMEr(['O'], sub {
my $C = shift;
$C->O(%chaining)
})
} else { () }

});
}
;
## token infix:sym<=~>
sub infix__S_287EqualTilde__PEEK { $_[0]->_AUTOLEXpeek('infix__S_287EqualTilde', $retree) }
sub infix__S_287EqualTilde {
no warnings 'recursion';
my $self = shift;


local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;

my $C = $self->cursor_xact("RULE infix__S_287EqualTilde");
my $xact = $C->xact;
my $S = $C->{'_pos'};
$C->{sym} = "\=\~";
$self->_MATCHIFYr($S, "infix__S_287EqualTilde", do {
my $C = $C;
if (($C) = ($C->_EXACT("\=\~"))
and ($C) = ($C->obs('=~ to do pattern matching', '~~'))) {
$C->_SUBSUMEr(['O'], sub {
my $C = shift;
$C->O(%chaining)
})
} else { () }

});
}
;
## token infix:sym<eq>
sub infix__S_288eq__PEEK { $_[0]->_AUTOLEXpeek('infix__S_288eq', $retree) }
sub infix__S_288eq {
no warnings 'recursion';
my $self = shift;


local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;

my $C = $self->cursor_xact("RULE infix__S_288eq");
my $xact = $C->xact;
my $S = $C->{'_pos'};
$C->{sym} = "eq";
$self->_MATCHIFYr($S, "infix__S_288eq", do {
if (my ($C) = ($C->_EXACT("eq"))) {
$C->_SUBSUMEr(['O'], sub {
my $C = shift;
$C->O(%chaining)
})
} else { () }

});
}
;
## token infix:sym<ne>
sub infix__S_289ne__PEEK { $_[0]->_AUTOLEXpeek('infix__S_289ne', $retree) }
sub infix__S_289ne {
no warnings 'recursion';
my $self = shift;


local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;

my $C = $self->cursor_xact("RULE infix__S_289ne");
my $xact = $C->xact;
my $S = $C->{'_pos'};
$C->{sym} = "ne";
$self->_MATCHIFYr($S, "infix__S_289ne", do {
if (my ($C) = ($C->_EXACT("ne"))) {
$C->_SUBSUMEr(['O'], sub {
my $C = shift;
$C->O(%chaining)
})
} else { () }

});
}
;
## token infix:sym<lt>
sub infix__S_290lt__PEEK { $_[0]->_AUTOLEXpeek('infix__S_290lt', $retree) }
sub infix__S_290lt {
no warnings 'recursion';
my $self = shift;


local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;

my $C = $self->cursor_xact("RULE infix__S_290lt");
my $xact = $C->xact;
my $S = $C->{'_pos'};
$C->{sym} = "lt";
$self->_MATCHIFYr($S, "infix__S_290lt", do {
if (my ($C) = ($C->_EXACT("lt"))) {
$C->_SUBSUMEr(['O'], sub {
my $C = shift;
$C->O(%chaining)
})
} else { () }

});
}
;
## token infix:sym<le>
sub infix__S_291le__PEEK { $_[0]->_AUTOLEXpeek('infix__S_291le', $retree) }
sub infix__S_291le {
no warnings 'recursion';
my $self = shift;


local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;

my $C = $self->cursor_xact("RULE infix__S_291le");
my $xact = $C->xact;
my $S = $C->{'_pos'};
$C->{sym} = "le";
$self->_MATCHIFYr($S, "infix__S_291le", do {
if (my ($C) = ($C->_EXACT("le"))) {
$C->_SUBSUMEr(['O'], sub {
my $C = shift;
$C->O(%chaining)
})
} else { () }

});
}
;
## token infix:sym<gt>
sub infix__S_292gt__PEEK { $_[0]->_AUTOLEXpeek('infix__S_292gt', $retree) }
sub infix__S_292gt {
no warnings 'recursion';
my $self = shift;


local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;

my $C = $self->cursor_xact("RULE infix__S_292gt");
my $xact = $C->xact;
my $S = $C->{'_pos'};
$C->{sym} = "gt";
$self->_MATCHIFYr($S, "infix__S_292gt", do {
if (my ($C) = ($C->_EXACT("gt"))) {
$C->_SUBSUMEr(['O'], sub {
my $C = shift;
$C->O(%chaining)
})
} else { () }

});
}
;
## token infix:sym<ge>
sub infix__S_293ge__PEEK { $_[0]->_AUTOLEXpeek('infix__S_293ge', $retree) }
sub infix__S_293ge {
no warnings 'recursion';
my $self = shift;


local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;

my $C = $self->cursor_xact("RULE infix__S_293ge");
my $xact = $C->xact;
my $S = $C->{'_pos'};
$C->{sym} = "ge";
$self->_MATCHIFYr($S, "infix__S_293ge", do {
if (my ($C) = ($C->_EXACT("ge"))) {
$C->_SUBSUMEr(['O'], sub {
my $C = shift;
$C->O(%chaining)
})
} else { () }

});
}
;
## token infix:sym<=:=>
sub infix__S_294EqualColonEqual__PEEK { $_[0]->_AUTOLEXpeek('infix__S_294EqualColonEqual', $retree) }
sub infix__S_294EqualColonEqual {
no warnings 'recursion';
my $self = shift;


local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;

my $C = $self->cursor_xact("RULE infix__S_294EqualColonEqual");
my $xact = $C->xact;
my $S = $C->{'_pos'};
$C->{sym} = "\=\:\=";
$self->_MATCHIFYr($S, "infix__S_294EqualColonEqual", do {
if (my ($C) = ($C->_EXACT("\=\:\="))) {
$C->_SUBSUMEr(['O'], sub {
my $C = shift;
$C->O(%chaining)
})
} else { () }

});
}
;
## token infix:sym<===>
sub infix__S_295EqualEqualEqual__PEEK { $_[0]->_AUTOLEXpeek('infix__S_295EqualEqualEqual', $retree) }
sub infix__S_295EqualEqualEqual {
no warnings 'recursion';
my $self = shift;


local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;

my $C = $self->cursor_xact("RULE infix__S_295EqualEqualEqual");
my $xact = $C->xact;
my $S = $C->{'_pos'};
$C->{sym} = "\=\=\=";
$self->_MATCHIFYr($S, "infix__S_295EqualEqualEqual", do {
if (my ($C) = ($C->_EXACT("\=\=\="))) {
$C->_SUBSUMEr(['O'], sub {
my $C = shift;
$C->O(%chaining)
})
} else { () }

});
}
;
## token infix:sym<eqv>
sub infix__S_296eqv__PEEK { $_[0]->_AUTOLEXpeek('infix__S_296eqv', $retree) }
sub infix__S_296eqv {
no warnings 'recursion';
my $self = shift;


local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;

my $C = $self->cursor_xact("RULE infix__S_296eqv");
my $xact = $C->xact;
my $S = $C->{'_pos'};
$C->{sym} = "eqv";
$self->_MATCHIFYr($S, "infix__S_296eqv", do {
if (my ($C) = ($C->_EXACT("eqv"))) {
$C->_SUBSUMEr(['O'], sub {
my $C = shift;
$C->O(%chaining)
})
} else { () }

});
}
;
## token infix:sym<before>
sub infix__S_297before__PEEK { $_[0]->_AUTOLEXpeek('infix__S_297before', $retree) }
sub infix__S_297before {
no warnings 'recursion';
my $self = shift;


local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;

my $C = $self->cursor_xact("RULE infix__S_297before");
my $xact = $C->xact;
my $S = $C->{'_pos'};
$C->{sym} = "before";
$self->_MATCHIFYr($S, "infix__S_297before", do {
if (my ($C) = ($C->_EXACT("before"))) {
$C->_SUBSUMEr(['O'], sub {
my $C = shift;
$C->O(%chaining)
})
} else { () }

});
}
;
## token infix:sym<after>
sub infix__S_298after__PEEK { $_[0]->_AUTOLEXpeek('infix__S_298after', $retree) }
sub infix__S_298after {
no warnings 'recursion';
my $self = shift;


local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;

my $C = $self->cursor_xact("RULE infix__S_298after");
my $xact = $C->xact;
my $S = $C->{'_pos'};
$C->{sym} = "after";
$self->_MATCHIFYr($S, "infix__S_298after", do {
if (my ($C) = ($C->_EXACT("after"))) {
$C->_SUBSUMEr(['O'], sub {
my $C = shift;
$C->O(%chaining)
})
} else { () }

});
}
;
## token infix:sym<&&>
sub infix__S_299AmpAmp__PEEK { $_[0]->_AUTOLEXpeek('infix__S_299AmpAmp', $retree) }
sub infix__S_299AmpAmp {
no warnings 'recursion';
my $self = shift;


local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;

my $C = $self->cursor_xact("RULE infix__S_299AmpAmp");
my $xact = $C->xact;
my $S = $C->{'_pos'};
$C->{sym} = "\&\&";
$self->_MATCHIFYr($S, "infix__S_299AmpAmp", do {
if (my ($C) = ($C->_EXACT("\&\&"))) {
$C->_SUBSUMEr(['O'], sub {
my $C = shift;
$C->O(%tight_and, iffy => 1)
})
} else { () }

});
}
;
## token infix:sym<||>
sub infix__S_300VertVert__PEEK { $_[0]->_AUTOLEXpeek('infix__S_300VertVert', $retree) }
sub infix__S_300VertVert {
no warnings 'recursion';
my $self = shift;


local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;

my $C = $self->cursor_xact("RULE infix__S_300VertVert");
my $xact = $C->xact;
my $S = $C->{'_pos'};
$C->{sym} = "\|\|";
$self->_MATCHIFYr($S, "infix__S_300VertVert", do {
if (my ($C) = ($C->_EXACT("\|\|"))) {
$C->_SUBSUMEr(['O'], sub {
my $C = shift;
$C->O(%tight_or, iffy => 1)
})
} else { () }

});
}
;
## token infix:sym<^^>
sub infix__S_301CaretCaret__PEEK { $_[0]->_AUTOLEXpeek('infix__S_301CaretCaret', $retree) }
sub infix__S_301CaretCaret {
no warnings 'recursion';
my $self = shift;


local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;

my $C = $self->cursor_xact("RULE infix__S_301CaretCaret");
my $xact = $C->xact;
my $S = $C->{'_pos'};
$C->{sym} = "\^\^";
$self->_MATCHIFYr($S, "infix__S_301CaretCaret", do {
if (my ($C) = ($C->_EXACT("\^\^"))) {
$C->_SUBSUMEr(['O'], sub {
my $C = shift;
$C->O(%tight_or, iffy => 1)
})
} else { () }

});
}
;
## token infix:sym<//>
sub infix__S_302SlashSlash__PEEK { $_[0]->_AUTOLEXpeek('infix__S_302SlashSlash', $retree) }
sub infix__S_302SlashSlash {
no warnings 'recursion';
my $self = shift;


local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;

my $C = $self->cursor_xact("RULE infix__S_302SlashSlash");
my $xact = $C->xact;
my $S = $C->{'_pos'};
$C->{sym} = "\/\/";
$self->_MATCHIFYr($S, "infix__S_302SlashSlash", do {
if (my ($C) = ($C->_EXACT("\/\/"))) {
$C->_SUBSUMEr(['O'], sub {
my $C = shift;
$C->O(%tight_or)
})
} else { () }

});
}
;
## token infix:sym<min>
sub infix__S_303min__PEEK { $_[0]->_AUTOLEXpeek('infix__S_303min', $retree) }
sub infix__S_303min {
no warnings 'recursion';
my $self = shift;


local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;

my $C = $self->cursor_xact("RULE infix__S_303min");
my $xact = $C->xact;
my $S = $C->{'_pos'};
$C->{sym} = "min";
$self->_MATCHIFYr($S, "infix__S_303min", do {
if (my ($C) = ($C->_EXACT("min"))) {
$C->_SUBSUMEr(['O'], sub {
my $C = shift;
$C->O(%tight_or)
})
} else { () }

});
}
;
## token infix:sym<max>
sub infix__S_304max__PEEK { $_[0]->_AUTOLEXpeek('infix__S_304max', $retree) }
sub infix__S_304max {
no warnings 'recursion';
my $self = shift;


local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;

my $C = $self->cursor_xact("RULE infix__S_304max");
my $xact = $C->xact;
my $S = $C->{'_pos'};
$C->{sym} = "max";
$self->_MATCHIFYr($S, "infix__S_304max", do {
if (my ($C) = ($C->_EXACT("max"))) {
$C->_SUBSUMEr(['O'], sub {
my $C = shift;
$C->O(%tight_or)
})
} else { () }

});
}
;
## token infix:sym<?? !!> {
sub infix__S_305QuestionQuestion_BangBang__PEEK { $_[0]->_AUTOLEXpeek('infix__S_305QuestionQuestion_BangBang', $retree) }
sub infix__S_305QuestionQuestion_BangBang {
no warnings 'recursion';
my $self = shift;

local $::GOAL = '!!';
local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;

my $C = $self->cursor_xact("RULE infix__S_305QuestionQuestion_BangBang");
my $xact = $C->xact;
my $S = $C->{'_pos'};
$C->{sym} = "\?\?\ \!\!";
$self->_MATCHIFYr($S, "infix__S_305QuestionQuestion_BangBang", do {
my $C = $C;
if (($C) = ($C->_EXACT("\?\?"))
and ($C) = ($C->ws)
and ($C) = ($C->_SUBSUMEr(['EXPR'], sub {
my $C = shift;
$C->EXPR(\%item_assignment)
}))
and ($C) = ($C->_BRACKETr(sub {
my $C=shift;
do {    my $C = $C->cursor_xact('ALT ||');
my $xact = $C->xact;
my @gather;
do {
push @gather, $C->_EXACT("\!\!")
}
or $xact->[-2] or
do {
push @gather, do {
my $C = $C;
if (($C) = ($C->before(sub {
my $C=shift;
if (my ($C) = ($C->before(sub {
my $C=shift;
$C->_PATTERN(qr/\G\:\:[^=]/)
}))) { ($C) } else { () }
}))
and ($C) = ($C->panic("Please use !! rather than ::"))) {
$C
} else { () }

}
}
or $xact->[-2] or
do {
push @gather, do {
if (my ($C) = ($C->_SUBSUMEr(['infixish'], sub {
my $C = shift;
$C->infixish
}))) {
scalar(do {
my $M = $C;
{
my $b = $M->{'infixish'}->Str;
if ($b eq ':') {
$C->panic("Please use !! rather than $b")}
else {
$C->panic("Precedence of $b is too loose to use between ?? and !!; please use parens around inner expression")};
}}, $C)
} else { () }

}
}
or $xact->[-2] or
do {
push @gather, do {
my $C = $C;
if (($C) = ($C->before(sub {
my $C=shift;
if (my ($C) = ($C->before(sub {
my $C=shift;
if (my ($C) = (LazyMap::lazymap(sub {
my $C=shift;
$C->_OPTr(sub {
my $C=shift;
if (my ($C) = ($C->_BRACKETr(sub {
my $C=shift;
if (my ($C) = ($C->_EXACT("\n"))) {
$C->_STARf(sub {
my $C=shift;
$C->_NOTCHAR( sub { my $C=shift;
$C->_EXACT("\n")
})
})
} else { () }
}))) { ($C) } else { () }
})
},
$C->_STARf(sub {
my $C=shift;
$C->_NOTCHAR( sub { my $C=shift;
$C->_EXACT("\n")
})
})))) { ($C) } else { () }
}))) { ($C) } else { () }
}))
and ($C) = ($C->_EXACT("\!\!"))
and ($C) = ($C->sorry("Bogus code found before the !!"))
and ($C) = ($C->panic("Confused"))) {
$C
} else { () }

}
}
or $xact->[-2] or
do {
push @gather, do {
my $C = $C;
if (($C) = ($C->sorry("Found ?? but no !!"))
and ($C) = ($C->panic("Confused"))) {
$C
} else { () }

}
};
@gather;
}
}))) {
$C->_SUBSUMEr(['O'], sub {
my $C = shift;
$C->O(%conditional, _reducecheck => 'raise_middle')
})
} else { () }

});
}
;
## token infix:sym<!!> {
sub infix__S_306BangBang__PEEK { $_[0]->_AUTOLEXpeek('infix__S_306BangBang', $retree) }
sub infix__S_306BangBang {
no warnings 'recursion';
my $self = shift;


local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;

my $C = $self->cursor_xact("RULE infix__S_306BangBang");
my $xact = $C->xact;
my $S = $C->{'_pos'};
$C->{sym} = "\!\!";
$self->_MATCHIFYr($S, "infix__S_306BangBang", do {
my $C = $C;
if (($C) = ($C->_EXACT("\!\!"))
and ($C) = ($C->_COMMITLTM())
and ($C) = ($C->_BRACKETr(sub {
my $C=shift;
do {    my $C = $C->cursor_xact('ALT ||');
my $xact = $C->xact;
my @gather;
do {
push @gather, do {
my $C = $C;
if (($C) = ($C->suppose(sub {
my $C=shift;
$C->_SUBSUMEr(['infixish'], sub {
my $C = shift;
$C->infixish
})
}))
and ($C) = ($C->panic("An infix may not start with !!"))) {
$C
} else { () }

}
}
or $xact->[-2] or
do {
push @gather, do {
if (my ($C) = ($C->panic("Ternary !! seems to be missing its ??"))) { ($C) } else { () }

}
};
@gather;
}
}))) {
$C
} else { () }

});
}
;
## method raise_middle
sub raise_middle {
no warnings 'recursion';
my $self = shift;
$self->{'middle'} = $self->{'infix'}->{'EXPR'};
$self;
};
## token infix:sym<?>
sub infix__S_307Question__PEEK { $_[0]->_AUTOLEXpeek('infix__S_307Question', $retree) }
sub infix__S_307Question {
no warnings 'recursion';
my $self = shift;


local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;

my $C = $self->cursor_xact("RULE infix__S_307Question");
my $xact = $C->xact;
my $S = $C->{'_pos'};
$C->{sym} = "\?";
$self->_MATCHIFYr($S, "infix__S_307Question", do {
my $C = $C;
if (($C) = ($C->_EXACT("\?"))
and ($C) = (scalar(do {
}, $C))
and ($C) = ($C->_NOTBEFORE(sub {
my $C=shift;
if (my ($C) = ($C->before(sub {
my $C=shift;
$C->_EXACT("\?")
}))) { ($C) } else { () }
}))
and ($C) = ($C->before(sub {
my $C=shift;
if (my ($C) = ($C->before(sub {
my $C=shift;
if (my ($C) = (LazyMap::lazymap(sub {
my $C=shift;
$C->_EXACT("\:")
},
$C->_STARf(sub {
my $C=shift;
$C->_PATTERN(qr/\G[^;]/)
})))) { ($C) } else { () }
}))) { ($C) } else { () }
}))
and ($C) = ($C->obs('?: for the conditional operator', '??!!'))) {
$C->_SUBSUMEr(['O'], sub {
my $C = shift;
$C->O(%conditional)
})
} else { () }

});
}
;
## token infix:sym<ff>
sub infix__S_308ff__PEEK { $_[0]->_AUTOLEXpeek('infix__S_308ff', $retree) }
sub infix__S_308ff {
no warnings 'recursion';
my $self = shift;


local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;

my $C = $self->cursor_xact("RULE infix__S_308ff");
my $xact = $C->xact;
my $S = $C->{'_pos'};
$C->{sym} = "ff";
$self->_MATCHIFYr($S, "infix__S_308ff", do {
if (my ($C) = ($C->_EXACT("ff"))) {
$C->_SUBSUMEr(['O'], sub {
my $C = shift;
$C->O(%conditional)
})
} else { () }

});
}
;
## token infix:sym<^ff>
sub infix__S_309Caretff__PEEK { $_[0]->_AUTOLEXpeek('infix__S_309Caretff', $retree) }
sub infix__S_309Caretff {
no warnings 'recursion';
my $self = shift;


local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;

my $C = $self->cursor_xact("RULE infix__S_309Caretff");
my $xact = $C->xact;
my $S = $C->{'_pos'};
$C->{sym} = "\^ff";
$self->_MATCHIFYr($S, "infix__S_309Caretff", do {
if (my ($C) = ($C->_EXACT("\^ff"))) {
$C->_SUBSUMEr(['O'], sub {
my $C = shift;
$C->O(%conditional)
})
} else { () }

});
}
;
## token infix:sym<ff^>
sub infix__S_310ffCaret__PEEK { $_[0]->_AUTOLEXpeek('infix__S_310ffCaret', $retree) }
sub infix__S_310ffCaret {
no warnings 'recursion';
my $self = shift;


local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;

my $C = $self->cursor_xact("RULE infix__S_310ffCaret");
my $xact = $C->xact;
my $S = $C->{'_pos'};
$C->{sym} = "ff\^";
$self->_MATCHIFYr($S, "infix__S_310ffCaret", do {
if (my ($C) = ($C->_EXACT("ff\^"))) {
$C->_SUBSUMEr(['O'], sub {
my $C = shift;
$C->O(%conditional)
})
} else { () }

});
}
;
## token infix:sym<^ff^>
sub infix__S_311CaretffCaret__PEEK { $_[0]->_AUTOLEXpeek('infix__S_311CaretffCaret', $retree) }
sub infix__S_311CaretffCaret {
no warnings 'recursion';
my $self = shift;


local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;

my $C = $self->cursor_xact("RULE infix__S_311CaretffCaret");
my $xact = $C->xact;
my $S = $C->{'_pos'};
$C->{sym} = "\^ff\^";
$self->_MATCHIFYr($S, "infix__S_311CaretffCaret", do {
if (my ($C) = ($C->_EXACT("\^ff\^"))) {
$C->_SUBSUMEr(['O'], sub {
my $C = shift;
$C->O(%conditional)
})
} else { () }

});
}
;
## token infix:sym<fff>
sub infix__S_312fff__PEEK { $_[0]->_AUTOLEXpeek('infix__S_312fff', $retree) }
sub infix__S_312fff {
no warnings 'recursion';
my $self = shift;


local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;

my $C = $self->cursor_xact("RULE infix__S_312fff");
my $xact = $C->xact;
my $S = $C->{'_pos'};
$C->{sym} = "fff";
$self->_MATCHIFYr($S, "infix__S_312fff", do {
if (my ($C) = ($C->_EXACT("fff"))) {
$C->_SUBSUMEr(['O'], sub {
my $C = shift;
$C->O(%conditional)
})
} else { () }

});
}
;
## token infix:sym<^fff>
sub infix__S_313Caretfff__PEEK { $_[0]->_AUTOLEXpeek('infix__S_313Caretfff', $retree) }
sub infix__S_313Caretfff {
no warnings 'recursion';
my $self = shift;


local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;

my $C = $self->cursor_xact("RULE infix__S_313Caretfff");
my $xact = $C->xact;
my $S = $C->{'_pos'};
$C->{sym} = "\^fff";
$self->_MATCHIFYr($S, "infix__S_313Caretfff", do {
if (my ($C) = ($C->_EXACT("\^fff"))) {
$C->_SUBSUMEr(['O'], sub {
my $C = shift;
$C->O(%conditional)
})
} else { () }

});
}
;
## token infix:sym<fff^>
sub infix__S_314fffCaret__PEEK { $_[0]->_AUTOLEXpeek('infix__S_314fffCaret', $retree) }
sub infix__S_314fffCaret {
no warnings 'recursion';
my $self = shift;


local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;

my $C = $self->cursor_xact("RULE infix__S_314fffCaret");
my $xact = $C->xact;
my $S = $C->{'_pos'};
$C->{sym} = "fff\^";
$self->_MATCHIFYr($S, "infix__S_314fffCaret", do {
if (my ($C) = ($C->_EXACT("fff\^"))) {
$C->_SUBSUMEr(['O'], sub {
my $C = shift;
$C->O(%conditional)
})
} else { () }

});
}
;
## token infix:sym<^fff^>
sub infix__S_315CaretfffCaret__PEEK { $_[0]->_AUTOLEXpeek('infix__S_315CaretfffCaret', $retree) }
sub infix__S_315CaretfffCaret {
no warnings 'recursion';
my $self = shift;


local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;

my $C = $self->cursor_xact("RULE infix__S_315CaretfffCaret");
my $xact = $C->xact;
my $S = $C->{'_pos'};
$C->{sym} = "\^fff\^";
$self->_MATCHIFYr($S, "infix__S_315CaretfffCaret", do {
if (my ($C) = ($C->_EXACT("\^fff\^"))) {
$C->_SUBSUMEr(['O'], sub {
my $C = shift;
$C->O(%conditional)
})
} else { () }

});
}
;
## token infix:sym<=> ()
sub infix__S_316Equal__PEEK { $_[0]->_AUTOLEXpeek('infix__S_316Equal', $retree) }
sub infix__S_316Equal {
no warnings 'recursion';
my $self = shift;


local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;

my $C = $self->cursor_xact("RULE infix__S_316Equal");
my $xact = $C->xact;
my $S = $C->{'_pos'};
$C->{sym} = "\=";
$self->_MATCHIFYr($S, "infix__S_316Equal", do {
my $C = $C;
if (($C) = ($C->_EXACT("\="))
and ($C) = ($C->_BRACKETr(sub {
my $C=shift;
do {    my $C = $C->cursor_xact('ALT ||');
my $xact = $C->xact;
my @gather;
do {
push @gather, do {
if (my ($C) = ($C->before(sub {
my $C=shift;
(($C) x !!do {
$::LEFTSIGIL eq '$' })
}))) {
$C->_SUBSUMEr(['O'], sub {
my $C = shift;
$C->O(%item_assignment)
})
} else { () }

}
}
or $xact->[-2] or
do {
push @gather, $C->_SUBSUMEr(['O'], sub {
my $C = shift;
$C->O(%list_assignment)
})
};
@gather;
}
}))) {
$C
} else { () }

});
}
;
## token infix:sym<:=>
sub infix__S_317ColonEqual__PEEK { $_[0]->_AUTOLEXpeek('infix__S_317ColonEqual', $retree) }
sub infix__S_317ColonEqual {
no warnings 'recursion';
my $self = shift;


local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;

my $C = $self->cursor_xact("RULE infix__S_317ColonEqual");
my $xact = $C->xact;
my $S = $C->{'_pos'};
$C->{sym} = "\:\=";
$self->_MATCHIFYr($S, "infix__S_317ColonEqual", do {
if (my ($C) = ($C->_EXACT("\:\="))) {
$C->_SUBSUMEr(['O'], sub {
my $C = shift;
$C->O(%list_assignment)
})
} else { () }

});
}
;
## token infix:sym<::=>
sub infix__S_318ColonColonEqual__PEEK { $_[0]->_AUTOLEXpeek('infix__S_318ColonColonEqual', $retree) }
sub infix__S_318ColonColonEqual {
no warnings 'recursion';
my $self = shift;


local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;

my $C = $self->cursor_xact("RULE infix__S_318ColonColonEqual");
my $xact = $C->xact;
my $S = $C->{'_pos'};
$C->{sym} = "\:\:\=";
$self->_MATCHIFYr($S, "infix__S_318ColonColonEqual", do {
if (my ($C) = ($C->_EXACT("\:\:\="))) {
$C->_SUBSUMEr(['O'], sub {
my $C = shift;
$C->O(%list_assignment)
})
} else { () }

});
}
;
## token infix:sym<.=> {
sub infix__S_319DotEqual__PEEK { $_[0]->_AUTOLEXpeek('infix__S_319DotEqual', $retree) }
sub infix__S_319DotEqual {
no warnings 'recursion';
my $self = shift;


local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;

my $C = $self->cursor_xact("RULE infix__S_319DotEqual");
my $xact = $C->xact;
my $S = $C->{'_pos'};
$C->{sym} = "\.\=";
$self->_MATCHIFYr($S, "infix__S_319DotEqual", do {
if (my ($C) = ($C->_EXACT("\.\="))) {
$C->_SUBSUMEr(['O'], sub {
my $C = shift;
$C->O(%item_assignment,
nextterm => 'dottyopish',
_reducecheck => 'check_doteq'
)
})
} else { () }

});
}
;
## method check_doteq
sub check_doteq {
no warnings 'recursion';
my $self = shift;
return $self if $self->{'left'}->{'scope_declarator'};
my $ok = 0;
eval {
my $methop = $self->{'right'}->{'methodop'};
my $name = $methop->{'longname'}->Str;
if (grep {
$_ eq $name }  <new clone sort subst trans reverse uniq map samecase substr flip fmt pick>) {
$ok = 1}
elsif (not $methop->{'args'}->[0]) {
$ok = 1};
};
$self->cursor_force($self->{'infix'}->{'_pos'})->worryobs('.= as append operator', '~=') unless $ok;
$self;
};
## token infix:sym« => »
sub infix__S_320EqualGt__PEEK { $_[0]->_AUTOLEXpeek('infix__S_320EqualGt', $retree) }
sub infix__S_320EqualGt {
no warnings 'recursion';
my $self = shift;


local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;

my $C = $self->cursor_xact("RULE infix__S_320EqualGt");
my $xact = $C->xact;
my $S = $C->{'_pos'};
$C->{sym} = "\=\>";
$self->_MATCHIFYr($S, "infix__S_320EqualGt", do {
if (my ($C) = ($C->_EXACT("\=\>"))) {
$C->_SUBSUMEr(['O'], sub {
my $C = shift;
$C->O(%item_assignment, fiddly => 0)
})
} else { () }

});
}
;
## token prefix:sym<so>
sub prefix__S_321so__PEEK { $_[0]->_AUTOLEXpeek('prefix__S_321so', $retree) }
sub prefix__S_321so {
no warnings 'recursion';
my $self = shift;


local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;

my $C = $self->cursor_xact("RULE prefix__S_321so");
my $xact = $C->xact;
my $S = $C->{'_pos'};
$C->{sym} = "so";
$self->_MATCHIFYr($S, "prefix__S_321so", do {
if (my ($C) = ($C->_PATTERN(qr/\Gso\b/))) {
$C->_SUBSUMEr(['O'], sub {
my $C = shift;
$C->O(%loose_unary)
})
} else { () }

});
}
;
## token prefix:sym<not>
sub prefix__S_322not__PEEK { $_[0]->_AUTOLEXpeek('prefix__S_322not', $retree) }
sub prefix__S_322not {
no warnings 'recursion';
my $self = shift;


local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;

my $C = $self->cursor_xact("RULE prefix__S_322not");
my $xact = $C->xact;
my $S = $C->{'_pos'};
$C->{sym} = "not";
$self->_MATCHIFYr($S, "prefix__S_322not", do {
if (my ($C) = ($C->_PATTERN(qr/\Gnot\b/))) {
$C->_SUBSUMEr(['O'], sub {
my $C = shift;
$C->O(%loose_unary)
})
} else { () }

});
}
;
## token infix:sym<,> {
sub infix__S_323Comma__PEEK { $_[0]->_AUTOLEXpeek('infix__S_323Comma', $retree) }
sub infix__S_323Comma {
no warnings 'recursion';
my $self = shift;


local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;

my $C = $self->cursor_xact("RULE infix__S_323Comma");
my $xact = $C->xact;
my $S = $C->{'_pos'};
$C->{sym} = "\,";
$self->_MATCHIFYr($S, "infix__S_323Comma", do {
my $C = $C;
if (($C) = ($C->_EXACT("\,"))
and ($C) = ($C->_SUBSUMEr(['O'], sub {
my $C = shift;
$C->O(%comma, fiddly => 0)
}))) {
$C->_OPTr(sub {
my $C=shift;
if (my ($C) = ($C->_BRACKETr(sub {
my $C=shift;
if (($C) = ($C->before(sub {
my $C=shift;
if (my ($C) = ($C->before(sub {
my $C=shift;
$C->_PATTERN(qr/\G[\x20\t\r]*+\.\.\./)
}))) { ($C) } else { () }
}))
and ($C) = ($C->worry("Comma found before apparent series operator; please remove comma (or put parens\n    around the ... listop, or use 'fail' instead of ...)"))) {
$C
} else { () }
}))) { ($C) } else { () }
})
} else { () }

});
}
;
## token infix:sym<:> {
sub infix__S_324Colon__PEEK { $_[0]->_AUTOLEXpeek('infix__S_324Colon', $retree) }
sub infix__S_324Colon {
no warnings 'recursion';
my $self = shift;


local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;

my $C = $self->cursor_xact("RULE infix__S_324Colon");
my $xact = $C->xact;
my $S = $C->{'_pos'};
$C->{sym} = "\:";
$self->_MATCHIFYr($S, "infix__S_324Colon", do {
my $C = $C;
if (($C) = ($C->_EXACT("\:"))
and ($C) = ($C->before(sub {
my $C=shift;
if (my ($C) = ($C->before(sub {
my $C=shift;
if (my ($C) = (do {
do {
my ($tag, $try);
my @try;
my $relex;

my $fate;
my $x;
if ($fate = $C->{'_fate'} and $fate->[1] eq 'infix__S_324Colon_0') {
$C->deb("Fate passed to infix__S_324Colon_0: ", ::fatestr($fate)) if $::DEBUG & DEBUG::fates;
($C->{'_fate'}, $tag, $try) = @$fate;
@try = ($try);
$x = 'ALT infix__S_324Colon_0';    # some outer ltm is controlling us
}
else {
$x = 'ALTLTM infix__S_324Colon_0'; # we are top level ltm
}
my $C = $C->cursor_xact($x);
my $xact = $C->{_xact};

my @gather = ();
for (;;) {
unless (@try) {
$relex //= $C->cursor_fate('STD::P6', 'infix__S_324Colon_0', $retree);
@try = $relex->($C) or last;
}
$try = shift(@try) // next;

if (ref $try) {
($C->{'_fate'}, $tag, $try) = @$try;   # next candidate fate
}

$C->deb("infix__S_324Colon_0 trying $tag $try") if $::DEBUG & DEBUG::try_processing;
push @gather, ((
sub {
my $C=shift;
$C->_PATTERN(qr/\G\s/)
},
sub {
my $C=shift;
$C->_SUBSUMEr(['terminator'], sub {
my $C = shift;
$C->terminator
})
}
)[$try])->($C);
last if @gather;
last if $xact->[-2];  # committed?
}
@gather;
};

})) { ($C) } else { () }
}))) { ($C) } else { () }
}))
and ($C) = (scalar(do {
my $M = $C;
$C->sorry("Illegal use of colon as invocant marker") unless $::INVOCANT_OK-- or $::PRECLIM ge $item_assignment_prec;
$M->{'sym'} = ',';
$M->{'wascolon'} = 1;
}, $C))) {
$C->_SUBSUMEr(['O'], sub {
my $C = shift;
$C->O(%comma)
})
} else { () }

});
}
;
## token infix:sym<X>
sub infix__S_325X__PEEK { $_[0]->_AUTOLEXpeek('infix__S_325X', $retree) }
sub infix__S_325X {
no warnings 'recursion';
my $self = shift;


local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;

my $C = $self->cursor_xact("RULE infix__S_325X");
my $xact = $C->xact;
my $S = $C->{'_pos'};
$C->{sym} = "X";
$self->_MATCHIFYr($S, "infix__S_325X", do {
if (my ($C) = ($C->_EXACT("X"))) {
$C->_SUBSUMEr(['O'], sub {
my $C = shift;
$C->O(%list_infix)
})
} else { () }

});
}
;
## token infix:sym<Z>
sub infix__S_326Z__PEEK { $_[0]->_AUTOLEXpeek('infix__S_326Z', $retree) }
sub infix__S_326Z {
no warnings 'recursion';
my $self = shift;


local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;

my $C = $self->cursor_xact("RULE infix__S_326Z");
my $xact = $C->xact;
my $S = $C->{'_pos'};
$C->{sym} = "Z";
$self->_MATCHIFYr($S, "infix__S_326Z", do {
if (my ($C) = ($C->_EXACT("Z"))) {
$C->_SUBSUMEr(['O'], sub {
my $C = shift;
$C->O(%list_infix)
})
} else { () }

});
}
;
## token infix:sym<minmax>
sub infix__S_327minmax__PEEK { $_[0]->_AUTOLEXpeek('infix__S_327minmax', $retree) }
sub infix__S_327minmax {
no warnings 'recursion';
my $self = shift;


local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;

my $C = $self->cursor_xact("RULE infix__S_327minmax");
my $xact = $C->xact;
my $S = $C->{'_pos'};
$C->{sym} = "minmax";
$self->_MATCHIFYr($S, "infix__S_327minmax", do {
if (my ($C) = ($C->_EXACT("minmax"))) {
$C->_SUBSUMEr(['O'], sub {
my $C = shift;
$C->O(%list_infix)
})
} else { () }

});
}
;
## token infix:sym<...>
sub infix__S_328DotDotDot__PEEK { $_[0]->_AUTOLEXpeek('infix__S_328DotDotDot', $retree) }
sub infix__S_328DotDotDot {
no warnings 'recursion';
my $self = shift;


local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;

my $C = $self->cursor_xact("RULE infix__S_328DotDotDot");
my $xact = $C->xact;
my $S = $C->{'_pos'};
$C->{sym} = "\.\.\.";
$self->_MATCHIFYr($S, "infix__S_328DotDotDot", do {
if (my ($C) = ($C->_EXACT("\.\.\."))) {
$C->_SUBSUMEr(['O'], sub {
my $C = shift;
$C->O(%list_infix)
})
} else { () }

});
}
;
## token term:sym<...>
sub term__S_329DotDotDot__PEEK { $_[0]->_AUTOLEXpeek('term__S_329DotDotDot', $retree) }
sub term__S_329DotDotDot {
no warnings 'recursion';
my $self = shift;


local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;

my $C = $self->cursor_xact("RULE term__S_329DotDotDot");
my $xact = $C->xact;
my $S = $C->{'_pos'};
$C->{'args'} = [];
$C->{sym} = "\.\.\.";
$self->_MATCHIFYr($S, "term__S_329DotDotDot", do {
my $C = $C;
if (($C) = ($C->_EXACT("\.\.\."))
and ($C) = ($C->_OPTr(sub {
my $C=shift;
$C->_SUBSUMEr(['args'], sub {
my $C = shift;
$C->args
})
}))) {
$C->_SUBSUMEr(['O'], sub {
my $C = shift;
$C->O(%list_prefix)
})
} else { () }

});
}
;
## token term:sym<???>
sub term__S_330QuestionQuestionQuestion__PEEK { $_[0]->_AUTOLEXpeek('term__S_330QuestionQuestionQuestion', $retree) }
sub term__S_330QuestionQuestionQuestion {
no warnings 'recursion';
my $self = shift;


local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;

my $C = $self->cursor_xact("RULE term__S_330QuestionQuestionQuestion");
my $xact = $C->xact;
my $S = $C->{'_pos'};
$C->{'args'} = [];
$C->{sym} = "\?\?\?";
$self->_MATCHIFYr($S, "term__S_330QuestionQuestionQuestion", do {
my $C = $C;
if (($C) = ($C->_EXACT("\?\?\?"))
and ($C) = ($C->_OPTr(sub {
my $C=shift;
$C->_SUBSUMEr(['args'], sub {
my $C = shift;
$C->args
})
}))) {
$C->_SUBSUMEr(['O'], sub {
my $C = shift;
$C->O(%list_prefix)
})
} else { () }

});
}
;
## token term:sym<!!!>
sub term__S_331BangBangBang__PEEK { $_[0]->_AUTOLEXpeek('term__S_331BangBangBang', $retree) }
sub term__S_331BangBangBang {
no warnings 'recursion';
my $self = shift;


local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;

my $C = $self->cursor_xact("RULE term__S_331BangBangBang");
my $xact = $C->xact;
my $S = $C->{'_pos'};
$C->{'args'} = [];
$C->{sym} = "\!\!\!";
$self->_MATCHIFYr($S, "term__S_331BangBangBang", do {
my $C = $C;
if (($C) = ($C->_EXACT("\!\!\!"))
and ($C) = ($C->_OPTr(sub {
my $C=shift;
$C->_SUBSUMEr(['args'], sub {
my $C = shift;
$C->args
})
}))) {
$C->_SUBSUMEr(['O'], sub {
my $C = shift;
$C->O(%list_prefix)
})
} else { () }

});
}
;
my %deftrap = (
'say' => 1, 'print' => 1, 'abs' => 1, 'alarm' => 1, 'chomp' => 1, 'chop' => 1, 'chr' => 1, 'chroot' => 1, 'cos' => 1,
'defined' => 1, 'eval' => 1, 'exp' => 1, 'glob' => 1, 'lc' => 1, 'lcfirst' => 1, 'log' => 1, 'lstat' => 1, 'mkdir' => 1,
'ord' => 1, 'readlink' => 1, 'readpipe' => 1, 'require' => 1, 'reverse' => 1, 'rmdir' => 1, 'sin' => 1,
'split' => 1, 'sqrt' => 1, 'stat' => 1, 'uc' => 1, 'ucfirst' => 1, 'unlink' => 1,
'WHAT' => 1, 'WHICH' => 1, 'WHERE' => 1, 'HOW' => 1, 'WHENCE' => 1, 'VAR' => 1,
);
## token term:identifier
sub term__S_332identifier__PEEK { $_[0]->_AUTOLEXpeek('term__S_332identifier', $retree) }
sub term__S_332identifier {
no warnings 'recursion';
my $self = shift;

my $name;my $pos;my $isname = 0;
local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;

my $C = $self->cursor_xact("RULE term__S_332identifier");
my $xact = $C->xact;
my $S = $C->{'_pos'};
$C->{sym} = "identifier";
$self->_MATCHIFYr($S, "term__S_332identifier", do {
my $C = $C;
if (($C) = ($C->_SUBSUMEr(['identifier'], sub {
my $C = shift;
$C->identifier
}))
and ($C) = ($C->before(sub {
my $C=shift;
if (my ($C) = ($C->before(sub {
my $C=shift;
$C->{'unsp'} = [];
$C->_OPTr(sub {
my $C=shift;
if (my ($C) = ($C->_BRACKETr(sub {
my $C=shift;
do {
my ($tag, $try);
my @try;
my $relex;

my $fate;
my $x;
if ($fate = $C->{'_fate'} and $fate->[1] eq 'term__S_332identifier_0') {
$C->deb("Fate passed to term__S_332identifier_0: ", ::fatestr($fate)) if $::DEBUG & DEBUG::fates;
($C->{'_fate'}, $tag, $try) = @$fate;
@try = ($try);
$x = 'ALT term__S_332identifier_0';    # some outer ltm is controlling us
}
else {
$x = 'ALTLTM term__S_332identifier_0'; # we are top level ltm
}
my $C = $C->cursor_xact($x);
my $xact = $C->{_xact};

my @gather = ();
for (;;) {
unless (@try) {
$relex //= $C->cursor_fate('STD::P6', 'term__S_332identifier_0', $retree);
@try = $relex->($C) or last;
}
$try = shift(@try) // next;

if (ref $try) {
($C->{'_fate'}, $tag, $try) = @$try;   # next candidate fate
}

$C->deb("term__S_332identifier_0 trying $tag $try") if $::DEBUG & DEBUG::try_processing;
push @gather, ((
sub {
my $C=shift;
$C->_SUBSUMEr(['unsp'], sub {
my $C = shift;
$C->unsp
})
},
sub {
my $C=shift;
$C->_EXACT("\(")
}
)[$try])->($C);
last if @gather;
last if $xact->[-2];  # committed?
}
@gather;
};
}))) { ($C) } else { () }
})
}))) { ($C) } else { () }
}))
and ($C) = ($C->_NOTBEFORE(sub {
my $C=shift;
$C->_PATTERN(qr/\G[:]/)
}))
and ($C) = (scalar(do {
my $M = $C;
{
$name = $M->{'identifier'}->Str;
$pos = $C->{'_pos'};
$isname = $C->is_name($name);
$C->check_nodecl($name) if $isname;
}}, $C))
and ($C) = ($C->_SUBSUMEr(['args'], sub {
my $C = shift;
$C->args($isname)
}))
and ($C) = (scalar(do {
my $M = $C;
$self->add_mystery($M->{'identifier'},$pos,substr($::ORIG,$pos,1)) unless $M->{'args'}->{'invocant'}}, $C))
and ($C) = (scalar(do {
my $M = $C;
{
if ($::BORG and $::BORG->{'block'}) {
if (not $::BORG->{'name'}) {
$::BORG->{'culprit'} = $M->{'identifier'}->cursor($pos);
$::BORG->{'name'} = $name;
}};
if ($deftrap{$name}) {
my $al = $M->{'args'}->{'arglist'}->[0];
my $ok = 0;
$ok = 1 if $al and $al->from != $al->to;
$ok = 1 if $M->{'args'}->{'semiarglist'};
if (not $ok) {
$M->{'identifier'}->worryobs("bare '$name'", ".$name if you meant \$_, or use an explicit invocant or argument")};
};
}}, $C))) {
$C->_SUBSUMEr(['O'], sub {
my $C = shift;
$C->O(%term)
})
} else { () }

});
}
;
## token args ($istype = 0) {
sub args__PEEK { $_[0]->_AUTOLEXpeek('args', $retree) }
sub args {
no warnings 'recursion';
my $self = shift;

my $istype = @_ ? shift() : 0;
my $listopish = 0;local $::GOAL = '';local $::INVOCANT_OK = 1;local $::INVOCANT_IS;
local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;

my $C = $self->cursor_xact("RULE args");
my $xact = $C->xact;
my $S = $C->{'_pos'};
$C->{'arglist'} = [];
$self->_MATCHIFYr($S, "args", do {
my $C = $C;
if (($C) = ($C->_BRACKETr(sub {
my $C=shift;
do {
my ($tag, $try);
my @try;
my $relex;

my $fate;
my $x;
if ($fate = $C->{'_fate'} and $fate->[1] eq 'args_0') {
$C->deb("Fate passed to args_0: ", ::fatestr($fate)) if $::DEBUG & DEBUG::fates;
($C->{'_fate'}, $tag, $try) = @$fate;
@try = ($try);
$x = 'ALT args_0';    # some outer ltm is controlling us
}
else {
$x = 'ALTLTM args_0'; # we are top level ltm
}
my $C = $C->cursor_xact($x);
my $xact = $C->{_xact};

my @gather = ();
for (;;) {
unless (@try) {
$relex //= $C->cursor_fate('STD::P6', 'args_0', $retree);
@try = $relex->($C) or last;
}
$try = shift(@try) // next;

if (ref $try) {
($C->{'_fate'}, $tag, $try) = @$try;   # next candidate fate
}

$C->deb("args_0 trying $tag $try") if $::DEBUG & DEBUG::try_processing;
push @gather, ((
sub {
my $C=shift;
if (my ($C) = ($C->_BRACKETr(sub {
my $C=shift;
local $::GOAL = "\)";
my $goalpos = $C;
if (($C) = ($C->_EXACT("\("))
and ($C) = (scalar(do {
}, $C))
and ($C) = ($C->_SUBSUMEr(['semiarglist'], sub {
my $C = shift;
$C->semiarglist
}))
and ($C) = ($C->_BRACKETr(sub {
my $C=shift;
do {    my $C = $C->cursor_xact('ALT ||');
my $xact = $C->xact;
my @gather;
do {
push @gather, $C->_EXACT("\)")
}
or $xact->[-2] or
do {
push @gather, do {
if (my ($C) = ($C->FAILGOAL($::GOAL, 'argument list', $goalpos))) { ($C) } else { () }

}
};
@gather;
}
}))) {
$C
} else { () }
}))) { ($C) } else { () }
},
sub {
my $C=shift;
if (($C) = ($C->unsp)
and ($C) = ($C->_BRACKETr(sub {
my $C=shift;
local $::GOAL = "\)";
my $goalpos = $C;
if (($C) = ($C->_EXACT("\("))
and ($C) = (scalar(do {
}, $C))
and ($C) = ($C->_SUBSUMEr(['semiarglist'], sub {
my $C = shift;
$C->semiarglist
}))
and ($C) = ($C->_BRACKETr(sub {
my $C=shift;
do {    my $C = $C->cursor_xact('ALT ||');
my $xact = $C->xact;
my @gather;
do {
push @gather, $C->_EXACT("\)")
}
or $xact->[-2] or
do {
push @gather, do {
if (my ($C) = ($C->FAILGOAL($::GOAL, 'argument list', $goalpos))) { ($C) } else { () }

}
};
@gather;
}
}))) {
$C
} else { () }
}))) {
$C
} else { () }
},
sub {
my $C=shift;
if (my ($C) = (scalar(do {
$listopish = 1 }, $C))) {
$C->_OPTr(sub {
my $C=shift;
if (my ($C) = ($C->_BRACKETr(sub {
my $C=shift;
if (($C) = ($C->before(sub {
my $C=shift;
if (my ($C) = ($C->before(sub {
my $C=shift;
$C->_PATTERN(qr/\G\s/)
}))) { ($C) } else { () }
}))
and ($C) = ($C->_NOTBEFORE(sub {
my $C=shift;
(($C) x !!do {
$istype })
}))
and ($C) = ($C->ws)
and ($C) = ($C->_NOTBEFORE(sub {
my $C=shift;
if (my ($C) = ($C->infixstopper)) { ($C) } else { () }
}))) {
$C->_SUBSUMEr(['arglist'], sub {
my $C = shift;
$C->arglist
})
} else { () }
}))) { ($C) } else { () }
})
} else { () }
}
)[$try])->($C);
last if @gather;
last if $xact->[-2];  # committed?
}
@gather;
};
}))
and ($C) = (scalar(do {
my $M = $C;
$M->{'invocant'} = $::INVOCANT_IS}, $C))
and ($C) = ($C->_BRACKETr(sub {
my $C=shift;
do {    my $C = $C->cursor_xact('ALT ||');
my $xact = $C->xact;
my @gather;
do {
push @gather, do {
if (my ($C) = ($C->before(sub {
my $C=shift;
(($C) x !!do {
$listopish })
}))) { ($C) } else { () }

}
}
or $xact->[-2] or
do {
push @gather, do {
my $C = $C;
if (($C) = ($C->_EXACT("\:"))
and ($C) = ($C->before(sub {
my $C=shift;
if (my ($C) = ($C->before(sub {
my $C=shift;
$C->_PATTERN(qr/\G\s/)
}))) { ($C) } else { () }
}))) {
$C->_SUBSUMEr(['moreargs'], sub {
my $C = shift;
$C->arglist
})
} else { () }

}
}
or $xact->[-2] or
do {
push @gather, scalar(do {
my $M = $C;
{
$M->{'O'} = {
}}}, $C)
};
@gather;
}
}))) {
$C
} else { () }

});
}
;
## token term:name
sub term__S_333name__PEEK { $_[0]->_AUTOLEXpeek('term__S_333name', $retree) }
sub term__S_333name {
no warnings 'recursion';
my $self = shift;

my $name;my $pos;
local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;

my $C = $self->cursor_xact("RULE term__S_333name");
my $xact = $C->xact;
my $S = $C->{'_pos'};
$C->{'postcircumfix'} = [];
$C->{sym} = "name";
$self->_MATCHIFYr($S, "term__S_333name", do {
my $C = $C;
if (($C) = ($C->_SUBSUMEr(['longname'], sub {
my $C = shift;
$C->longname
}))
and ($C) = (scalar(do {
my $M = $C;
$name = $M->{'longname'}->Str;
$pos = $C->{'_pos'};
}, $C))
and ($C) = ($C->_BRACKETr(sub {
my $C=shift;
do {    my $C = $C->cursor_xact('ALT ||');
my $xact = $C->xact;
my @gather;
do {
push @gather, do {
my $C = $C;
if (($C) = ($C->before(sub {
my $C=shift;
(($C) x !!do {
$C->is_name($name) or substr($name,0,2) eq '::'
})
}))
and ($C) = (scalar(do {
$C->check_nodecl($name)}, $C))
and ($C) = ($C->_OPTr(sub {
my $C=shift;
if (my ($C) = ($C->unsp)) { ($C) } else { () }
}))
and ($C) = ($C->_OPTr(sub {
my $C=shift;
if (my ($C) = ($C->_BRACKETr(sub {
my $C=shift;
if (my ($C) = ($C->before(sub {
my $C=shift;
if (my ($C) = ($C->before(sub {
my $C=shift;
$C->_EXACT("\[")
}))) { ($C) } else { () }
}))) {
$C->_SUBSUMEr(['postcircumfix'], sub {
my $C = shift;
$C->postcircumfix
})
} else { () }
}))) { ($C) } else { () }
}))) {
$C->_OPTr(sub {
my $C=shift;
if (my ($C) = ($C->_BRACKETr(sub {
my $C=shift;
if (($C) = ($C->before(sub {
my $C=shift;
if (my ($C) = ($C->after(sub {
my $C=shift;
$C->_PATTERN(qr/\G(?<=\:\:)/)
}))) { ($C) } else { () }
}))
and ($C) = ($C->before(sub {
my $C=shift;
if (my ($C) = ($C->before(sub {
my $C=shift;
if (my ($C) = ($C->_BRACKETr(sub {
my $C=shift;
do {
my ($tag, $try);
my @try;
my $relex;

my $fate;
my $x;
if ($fate = $C->{'_fate'} and $fate->[1] eq 'term__S_333name_0') {
$C->deb("Fate passed to term__S_333name_0: ", ::fatestr($fate)) if $::DEBUG & DEBUG::fates;
($C->{'_fate'}, $tag, $try) = @$fate;
@try = ($try);
$x = 'ALT term__S_333name_0';    # some outer ltm is controlling us
}
else {
$x = 'ALTLTM term__S_333name_0'; # we are top level ltm
}
my $C = $C->cursor_xact($x);
my $xact = $C->{_xact};

my @gather = ();
for (;;) {
unless (@try) {
$relex //= $C->cursor_fate('STD::P6', 'term__S_333name_0', $retree);
@try = $relex->($C) or last;
}
$try = shift(@try) // next;

if (ref $try) {
($C->{'_fate'}, $tag, $try) = @$try;   # next candidate fate
}

$C->deb("term__S_333name_0 trying $tag $try") if $::DEBUG & DEBUG::try_processing;
push @gather, ((
sub {
my $C=shift;
$C->_EXACT("«")
},
sub {
my $C=shift;
$C->_EXACT("\<")
},
sub {
my $C=shift;
$C->_EXACT("\{")
},
sub {
my $C=shift;
$C->_EXACT("\<\<")
}
)[$try])->($C);
last if @gather;
last if $xact->[-2];  # committed?
}
@gather;
};
}))) { ($C) } else { () }
}))) { ($C) } else { () }
}))
and ($C) = ($C->_SUBSUMEr(['postcircumfix'], sub {
my $C = shift;
$C->postcircumfix
}))) {
scalar(do {
$::VAR = $C->cursor_all($self->{'_pos'}, $C->{'_pos'}) }, $C)
} else { () }
}))) { ($C) } else { () }
})
} else { () }

}
}
or $xact->[-2] or
do {
push @gather, do {
my $C = $C;
if (($C) = ($C->_SUBSUMEr(['args'], sub {
my $C = shift;
$C->args
}))
and ($C) = (scalar(do {
my $M = $C;
$self->add_mystery($M->{'longname'},$pos,'termish') unless $M->{'args'}->{'invocant'}}, $C))) {
scalar(do {
my $M = $C;
{
if ($::BORG and $::BORG->{'block'}) {
if (not $::BORG->{'name'}) {
$::BORG->{'culprit'} = $M->{'longname'}->cursor($pos);
$::BORG->{'name'} //= $name;
}}}}, $C)
} else { () }

}
};
@gather;
}
}))) {
$C->_SUBSUMEr(['O'], sub {
my $C = shift;
$C->O(%term)
})
} else { () }

});
}
;
## method check_nodecl($name)
sub check_nodecl {
no warnings 'recursion';
my $self = shift;
die 'Required argument name omitted' unless @_;
my $name = @_ ? shift() : undef;
if ($name lt 'a') {
$::MEMOS[$self->{'_pos'}]->{'nodecl'} = $name}};
## token infix:sym<and>
sub infix__S_334and__PEEK { $_[0]->_AUTOLEXpeek('infix__S_334and', $retree) }
sub infix__S_334and {
no warnings 'recursion';
my $self = shift;


local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;

my $C = $self->cursor_xact("RULE infix__S_334and");
my $xact = $C->xact;
my $S = $C->{'_pos'};
$C->{sym} = "and";
$self->_MATCHIFYr($S, "infix__S_334and", do {
if (my ($C) = ($C->_EXACT("and"))) {
$C->_SUBSUMEr(['O'], sub {
my $C = shift;
$C->O(%loose_and, iffy => 1)
})
} else { () }

});
}
;
## token infix:sym<andthen>
sub infix__S_335andthen__PEEK { $_[0]->_AUTOLEXpeek('infix__S_335andthen', $retree) }
sub infix__S_335andthen {
no warnings 'recursion';
my $self = shift;


local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;

my $C = $self->cursor_xact("RULE infix__S_335andthen");
my $xact = $C->xact;
my $S = $C->{'_pos'};
$C->{sym} = "andthen";
$self->_MATCHIFYr($S, "infix__S_335andthen", do {
if (my ($C) = ($C->_EXACT("andthen"))) {
$C->_SUBSUMEr(['O'], sub {
my $C = shift;
$C->O(%loose_and)
})
} else { () }

});
}
;
## token infix:sym<or>
sub infix__S_336or__PEEK { $_[0]->_AUTOLEXpeek('infix__S_336or', $retree) }
sub infix__S_336or {
no warnings 'recursion';
my $self = shift;


local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;

my $C = $self->cursor_xact("RULE infix__S_336or");
my $xact = $C->xact;
my $S = $C->{'_pos'};
$C->{sym} = "or";
$self->_MATCHIFYr($S, "infix__S_336or", do {
if (my ($C) = ($C->_EXACT("or"))) {
$C->_SUBSUMEr(['O'], sub {
my $C = shift;
$C->O(%loose_or, iffy => 1)
})
} else { () }

});
}
;
## token infix:sym<orelse>
sub infix__S_337orelse__PEEK { $_[0]->_AUTOLEXpeek('infix__S_337orelse', $retree) }
sub infix__S_337orelse {
no warnings 'recursion';
my $self = shift;


local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;

my $C = $self->cursor_xact("RULE infix__S_337orelse");
my $xact = $C->xact;
my $S = $C->{'_pos'};
$C->{sym} = "orelse";
$self->_MATCHIFYr($S, "infix__S_337orelse", do {
if (my ($C) = ($C->_EXACT("orelse"))) {
$C->_SUBSUMEr(['O'], sub {
my $C = shift;
$C->O(%loose_or)
})
} else { () }

});
}
;
## token infix:sym<xor>
sub infix__S_338xor__PEEK { $_[0]->_AUTOLEXpeek('infix__S_338xor', $retree) }
sub infix__S_338xor {
no warnings 'recursion';
my $self = shift;


local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;

my $C = $self->cursor_xact("RULE infix__S_338xor");
my $xact = $C->xact;
my $S = $C->{'_pos'};
$C->{sym} = "xor";
$self->_MATCHIFYr($S, "infix__S_338xor", do {
if (my ($C) = ($C->_EXACT("xor"))) {
$C->_SUBSUMEr(['O'], sub {
my $C = shift;
$C->O(%loose_or, iffy => 1)
})
} else { () }

});
}
;
## token infix:sym« <== »
sub infix__S_339LtEqualEqual__PEEK { $_[0]->_AUTOLEXpeek('infix__S_339LtEqualEqual', $retree) }
sub infix__S_339LtEqualEqual {
no warnings 'recursion';
my $self = shift;


local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;

my $C = $self->cursor_xact("RULE infix__S_339LtEqualEqual");
my $xact = $C->xact;
my $S = $C->{'_pos'};
$C->{sym} = "\<\=\=";
$self->_MATCHIFYr($S, "infix__S_339LtEqualEqual", do {
if (my ($C) = ($C->_EXACT("\<\=\="))) {
$C->_SUBSUMEr(['O'], sub {
my $C = shift;
$C->O(%sequencer)
})
} else { () }

});
}
;
## token infix:sym« ==> »
sub infix__S_340EqualEqualGt__PEEK { $_[0]->_AUTOLEXpeek('infix__S_340EqualEqualGt', $retree) }
sub infix__S_340EqualEqualGt {
no warnings 'recursion';
my $self = shift;


local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;

my $C = $self->cursor_xact("RULE infix__S_340EqualEqualGt");
my $xact = $C->xact;
my $S = $C->{'_pos'};
$C->{sym} = "\=\=\>";
$self->_MATCHIFYr($S, "infix__S_340EqualEqualGt", do {
if (my ($C) = ($C->_EXACT("\=\=\>"))) {
$C->_SUBSUMEr(['O'], sub {
my $C = shift;
$C->O(%sequencer)
})
} else { () }

});
}
;
## token infix:sym« <<== »
sub infix__S_341LtLtEqualEqual__PEEK { $_[0]->_AUTOLEXpeek('infix__S_341LtLtEqualEqual', $retree) }
sub infix__S_341LtLtEqualEqual {
no warnings 'recursion';
my $self = shift;


local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;

my $C = $self->cursor_xact("RULE infix__S_341LtLtEqualEqual");
my $xact = $C->xact;
my $S = $C->{'_pos'};
$C->{sym} = "\<\<\=\=";
$self->_MATCHIFYr($S, "infix__S_341LtLtEqualEqual", do {
if (my ($C) = ($C->_EXACT("\<\<\=\="))) {
$C->_SUBSUMEr(['O'], sub {
my $C = shift;
$C->O(%sequencer)
})
} else { () }

});
}
;
## token infix:sym« ==>> »
sub infix__S_342EqualEqualGtGt__PEEK { $_[0]->_AUTOLEXpeek('infix__S_342EqualEqualGtGt', $retree) }
sub infix__S_342EqualEqualGtGt {
no warnings 'recursion';
my $self = shift;


local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;

my $C = $self->cursor_xact("RULE infix__S_342EqualEqualGtGt");
my $xact = $C->xact;
my $S = $C->{'_pos'};
$C->{sym} = "\=\=\>\>";
$self->_MATCHIFYr($S, "infix__S_342EqualEqualGtGt", do {
if (my ($C) = ($C->_EXACT("\=\=\>\>"))) {
$C->_SUBSUMEr(['O'], sub {
my $C = shift;
$C->O(%sequencer)
})
} else { () }

});
}
;
## token terminator:sym<;>
sub terminator__S_343Semi__PEEK { $_[0]->_AUTOLEXpeek('terminator__S_343Semi', $retree) }
sub terminator__S_343Semi {
no warnings 'recursion';
my $self = shift;


local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;

my $C = $self->cursor_xact("RULE terminator__S_343Semi");
my $xact = $C->xact;
my $S = $C->{'_pos'};
$C->{sym} = "\;";
$self->_MATCHIFYr($S, "terminator__S_343Semi", do {
if (my ($C) = ($C->_EXACT("\;"))) {
$C->_SUBSUMEr(['O'], sub {
my $C = shift;
$C->O(%terminator)
})
} else { () }

});
}
;
## token terminator:sym<if>
sub terminator__S_344if__PEEK { $_[0]->_AUTOLEXpeek('terminator__S_344if', $retree) }
sub terminator__S_344if {
no warnings 'recursion';
my $self = shift;


local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;

my $C = $self->cursor_xact("RULE terminator__S_344if");
my $xact = $C->xact;
my $S = $C->{'_pos'};
$C->{sym} = "if";
$self->_MATCHIFYr($S, "terminator__S_344if", do {
my $C = $C;
if (($C) = ($C->_PATTERN(qr/\Gif\b/))
and ($C) = ($C->nofun)) {
$C->_SUBSUMEr(['O'], sub {
my $C = shift;
$C->O(%terminator)
})
} else { () }

});
}
;
## token terminator:sym<unless>
sub terminator__S_345unless__PEEK { $_[0]->_AUTOLEXpeek('terminator__S_345unless', $retree) }
sub terminator__S_345unless {
no warnings 'recursion';
my $self = shift;


local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;

my $C = $self->cursor_xact("RULE terminator__S_345unless");
my $xact = $C->xact;
my $S = $C->{'_pos'};
$C->{sym} = "unless";
$self->_MATCHIFYr($S, "terminator__S_345unless", do {
my $C = $C;
if (($C) = ($C->_PATTERN(qr/\Gunless\b/))
and ($C) = ($C->nofun)) {
$C->_SUBSUMEr(['O'], sub {
my $C = shift;
$C->O(%terminator)
})
} else { () }

});
}
;
## token terminator:sym<while>
sub terminator__S_346while__PEEK { $_[0]->_AUTOLEXpeek('terminator__S_346while', $retree) }
sub terminator__S_346while {
no warnings 'recursion';
my $self = shift;


local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;

my $C = $self->cursor_xact("RULE terminator__S_346while");
my $xact = $C->xact;
my $S = $C->{'_pos'};
$C->{sym} = "while";
$self->_MATCHIFYr($S, "terminator__S_346while", do {
my $C = $C;
if (($C) = ($C->_PATTERN(qr/\Gwhile\b/))
and ($C) = ($C->nofun)) {
$C->_SUBSUMEr(['O'], sub {
my $C = shift;
$C->O(%terminator)
})
} else { () }

});
}
;
## token terminator:sym<until>
sub terminator__S_347until__PEEK { $_[0]->_AUTOLEXpeek('terminator__S_347until', $retree) }
sub terminator__S_347until {
no warnings 'recursion';
my $self = shift;


local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;

my $C = $self->cursor_xact("RULE terminator__S_347until");
my $xact = $C->xact;
my $S = $C->{'_pos'};
$C->{sym} = "until";
$self->_MATCHIFYr($S, "terminator__S_347until", do {
my $C = $C;
if (($C) = ($C->_PATTERN(qr/\Guntil\b/))
and ($C) = ($C->nofun)) {
$C->_SUBSUMEr(['O'], sub {
my $C = shift;
$C->O(%terminator)
})
} else { () }

});
}
;
## token terminator:sym<for>
sub terminator__S_348for__PEEK { $_[0]->_AUTOLEXpeek('terminator__S_348for', $retree) }
sub terminator__S_348for {
no warnings 'recursion';
my $self = shift;


local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;

my $C = $self->cursor_xact("RULE terminator__S_348for");
my $xact = $C->xact;
my $S = $C->{'_pos'};
$C->{sym} = "for";
$self->_MATCHIFYr($S, "terminator__S_348for", do {
my $C = $C;
if (($C) = ($C->_PATTERN(qr/\Gfor\b/))
and ($C) = ($C->nofun)) {
$C->_SUBSUMEr(['O'], sub {
my $C = shift;
$C->O(%terminator)
})
} else { () }

});
}
;
## token terminator:sym<given>
sub terminator__S_349given__PEEK { $_[0]->_AUTOLEXpeek('terminator__S_349given', $retree) }
sub terminator__S_349given {
no warnings 'recursion';
my $self = shift;


local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;

my $C = $self->cursor_xact("RULE terminator__S_349given");
my $xact = $C->xact;
my $S = $C->{'_pos'};
$C->{sym} = "given";
$self->_MATCHIFYr($S, "terminator__S_349given", do {
my $C = $C;
if (($C) = ($C->_PATTERN(qr/\Ggiven\b/))
and ($C) = ($C->nofun)) {
$C->_SUBSUMEr(['O'], sub {
my $C = shift;
$C->O(%terminator)
})
} else { () }

});
}
;
## token terminator:sym<when>
sub terminator__S_350when__PEEK { $_[0]->_AUTOLEXpeek('terminator__S_350when', $retree) }
sub terminator__S_350when {
no warnings 'recursion';
my $self = shift;


local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;

my $C = $self->cursor_xact("RULE terminator__S_350when");
my $xact = $C->xact;
my $S = $C->{'_pos'};
$C->{sym} = "when";
$self->_MATCHIFYr($S, "terminator__S_350when", do {
my $C = $C;
if (($C) = ($C->_PATTERN(qr/\Gwhen\b/))
and ($C) = ($C->nofun)) {
$C->_SUBSUMEr(['O'], sub {
my $C = shift;
$C->O(%terminator)
})
} else { () }

});
}
;
## token terminator:sym« --> »
sub terminator__S_351MinusMinusGt__PEEK { $_[0]->_AUTOLEXpeek('terminator__S_351MinusMinusGt', $retree) }
sub terminator__S_351MinusMinusGt {
no warnings 'recursion';
my $self = shift;


local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;

my $C = $self->cursor_xact("RULE terminator__S_351MinusMinusGt");
my $xact = $C->xact;
my $S = $C->{'_pos'};
$C->{sym} = "\-\-\>";
$self->_MATCHIFYr($S, "terminator__S_351MinusMinusGt", do {
if (my ($C) = ($C->_EXACT("\-\-\>"))) {
$C->_SUBSUMEr(['O'], sub {
my $C = shift;
$C->O(%terminator)
})
} else { () }

});
}
;
## token terminator:sym<!!>
sub terminator__S_352BangBang__PEEK { $_[0]->_AUTOLEXpeek('terminator__S_352BangBang', $retree) }
sub terminator__S_352BangBang {
no warnings 'recursion';
my $self = shift;


local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;

my $C = $self->cursor_xact("RULE terminator__S_352BangBang");
my $xact = $C->xact;
my $S = $C->{'_pos'};
$C->{sym} = "\!\!";
$self->_MATCHIFYr($S, "terminator__S_352BangBang", do {
my $C = $C;
if (($C) = ($C->_EXACT("\!\!"))
and ($C) = ($C->before(sub {
my $C=shift;
(($C) x !!do {
$::GOAL eq '!!' })
}))) {
$C->_SUBSUMEr(['O'], sub {
my $C = shift;
$C->O(%terminator)
})
} else { () }

});
}
;
## regex infixstopper {
sub infixstopper__PEEK { $_[0]->_AUTOLEXpeek('infixstopper', $retree) }
sub infixstopper {
no warnings 'recursion';
my $self = shift;


local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;

my $C = $self->cursor_xact("RULE infixstopper");
my $xact = $C->xact;
my $S = $C->{'_pos'};
$self->_MATCHIFY($S, "infixstopper", $C->_BRACKET(sub {
my $C=shift;
do {
my ($tag, $try);
my @try;
my $relex;

my $fate;
my $x;
if ($fate = $C->{'_fate'} and $fate->[1] eq 'infixstopper_0') {
$C->deb("Fate passed to infixstopper_0: ", ::fatestr($fate)) if $::DEBUG & DEBUG::fates;
($C->{'_fate'}, $tag, $try) = @$fate;
@try = ($try);
$x = 'ALT infixstopper_0';    # some outer ltm is controlling us
}
else {
$x = 'ALTLTM infixstopper_0'; # we are top level ltm
}
my $C = $C->cursor_xact($x);
my $xact = $C->{_xact};

my @gather = ();
for (;;) {
unless (@try) {
$relex //= $C->cursor_fate('STD::P6', 'infixstopper_0', $retree);
@try = $relex->($C) or last;
}
$try = shift(@try) // next;

if (ref $try) {
($C->{'_fate'}, $tag, $try) = @$try;   # next candidate fate
}

$C->deb("infixstopper_0 trying $tag $try") if $::DEBUG & DEBUG::try_processing;
push @gather, ((
sub {
my $C=shift;
$C->before(sub {
my $C=shift;
$C->_SUBSUME(['stopper'], sub {
my $C = shift;
$C->stopper
})
})
},
sub {
my $C=shift;
LazyMap::lazymap(sub {
my $C=shift;
$C->before(sub {
my $C=shift;
(($C) x !!do {
$::GOAL eq '!!' })
})
},
$C->before(sub {
my $C=shift;
$C->_EXACT("\!\!")
}))
},
sub {
my $C=shift;
LazyMap::lazymap(sub {
my $C=shift;
$C->before(sub {
my $C=shift;
(($C) x !!do {
($::GOAL eq '{' or $::GOAL eq 'endargs') and $::MEMOS[$C->{'_pos'}]->{'ws'} })
})
},
$C->before(sub {
my $C=shift;
do {
my ($tag, $try);
my @try;
my $relex;

my $fate;
my $x;
if ($fate = $C->{'_fate'} and $fate->[1] eq 'infixstopper_1') {
$C->deb("Fate passed to infixstopper_1: ", ::fatestr($fate)) if $::DEBUG & DEBUG::fates;
($C->{'_fate'}, $tag, $try) = @$fate;
@try = ($try);
$x = 'ALT infixstopper_1';    # some outer ltm is controlling us
}
else {
$x = 'ALTLTM infixstopper_1'; # we are top level ltm
}
my $C = $C->cursor_xact($x);
my $xact = $C->{_xact};

my @gather = ();
for (;;) {
unless (@try) {
$relex //= $C->cursor_fate('STD::P6', 'infixstopper_1', $retree);
@try = $relex->($C) or last;
}
$try = shift(@try) // next;

if (ref $try) {
($C->{'_fate'}, $tag, $try) = @$try;   # next candidate fate
}

$C->deb("infixstopper_1 trying $tag $try") if $::DEBUG & DEBUG::try_processing;
push @gather, ((
sub {
my $C=shift;
$C->_EXACT("\{")
},
sub {
my $C=shift;
$C->_SUBSUME(['lambda'], sub {
my $C = shift;
$C->lambda
})
}
)[$try])->($C);
last if @gather;
last if $xact->[-2];  # committed?
}
@gather;
};
}))
},
sub {
my $C=shift;
$C->before(sub {
my $C=shift;
(($C) x !!do {
$::GOAL eq 'endargs' and $::MEMOS[$C->{'_pos'}]->{'endargs'} })
})
}
)[$try])->($C);
last if @gather;
last if $xact->[-2];  # committed?
}
@gather;
};
}));
}
;
1; };
{ package STD::Q;
use Moose ':all' => { -prefix => "moose_" };
use Encode;
moose_extends('STD');
our $ALLROLES = { 'STD::Q', 1 };
our $REGEXES = {
ALL => [ qw// ],
};


no warnings 'qw', 'recursion';
my $retree;

$DB::deep = $DB::deep = 1000; # suppress used-once warning

use YAML::XS;

$SIG{__WARN__} = sub { die @_,"   statement started at line ", 'Cursor'->lineof($::LASTSTATE), "
" } if $::DEBUG;

{ package STD::Q::b1;
use Moose::Role ':all' => { -prefix => "moose_" };
use Encode;
our $ALLROLES = { 'STD::Q::b1', 1 };
our $REGEXES = {
ALL => [ qw/backslash escape/ ],
backslash => [ qw/backslash__S_001qq__PEEK backslash__S_002Back__PEEK backslash__S_003stopper__PEEK backslash__S_004a__PEEK backslash__S_005b__PEEK backslash__S_006c__PEEK backslash__S_007e__PEEK backslash__S_008f__PEEK backslash__S_009n__PEEK backslash__S_010o__PEEK backslash__S_011r__PEEK backslash__S_012t__PEEK backslash__S_013x__PEEK backslash__S_0140__PEEK/ ],
escape => [ qw/escape__S_000Back__PEEK/ ],
};


no warnings 'qw', 'recursion';
my $retree;

$DB::deep = $DB::deep = 1000; # suppress used-once warning

use YAML::XS;

$SIG{__WARN__} = sub { die @_,"   statement started at line ", 'Cursor'->lineof($::LASTSTATE), "
" } if $::DEBUG;

$retree = YAML::XS::Load(Encode::encode_utf8(<<'RETREE_END'));
---
backslash__S_001qq: !!perl/hash:RE_ast
  dba: backslash
  dic: STD::Q::b1
  re: !!perl/hash:RE_sequence
    zyg:
    - !!perl/hash:RE_assertion
      assert: '?'
      re: !!perl/hash:RE_method_re
        name: before
        nobind: 1
        re: !!perl/hash:RE_string
          i: 0
          text: q
    - !!perl/hash:RE_block {}
backslash__S_002Back: !!perl/hash:RE_ast
  dba: backslash
  dic: STD::Q::b1
  re: !!perl/hash:RE_bindnamed
    atom: !!perl/hash:RE_method
      i: 0
      name: sym
      rest: ''
      sym: \
backslash__S_003stopper: !!perl/hash:RE_ast
  dba: backslash
  dic: STD::Q::b1
  re: !!perl/hash:RE_bindnamed
    atom: !!perl/hash:RE_method
      name: stopper
      rest: ''
backslash__S_004a: !!perl/hash:RE_ast
  dba: backslash
  dic: STD::Q::b1
  re: !!perl/hash:RE_method
    i: 0
    name: sym
    rest: ''
    sym: a
backslash__S_005b: !!perl/hash:RE_ast
  dba: backslash
  dic: STD::Q::b1
  re: !!perl/hash:RE_method
    i: 0
    name: sym
    rest: ''
    sym: b
backslash__S_006c: !!perl/hash:RE_ast
  dba: backslash
  dic: STD::Q::b1
  re: !!perl/hash:RE_sequence
    zyg:
    - !!perl/hash:RE_method
      i: 0
      name: sym
      rest: ''
      sym: c
    - !!perl/hash:RE_method
      name: charspec
      rest: ''
backslash__S_007e: !!perl/hash:RE_ast
  dba: backslash
  dic: STD::Q::b1
  re: !!perl/hash:RE_method
    i: 0
    name: sym
    rest: ''
    sym: e
backslash__S_008f: !!perl/hash:RE_ast
  dba: backslash
  dic: STD::Q::b1
  re: !!perl/hash:RE_method
    i: 0
    name: sym
    rest: ''
    sym: f
backslash__S_009n: !!perl/hash:RE_ast
  dba: backslash
  dic: STD::Q::b1
  re: !!perl/hash:RE_method
    i: 0
    name: sym
    rest: ''
    sym: n
backslash__S_010o: !!perl/hash:RE_ast
  dba: octal character
  dic: STD::Q::b1
  re: !!perl/hash:RE_sequence
    zyg:
    - !!perl/hash:RE_method
      i: 0
      name: sym
      rest: ''
      sym: o
    - !!perl/hash:RE_bracket
      re: &1 !!perl/hash:RE_any
        altname: backslash__S_010o_0
        dba: octal character
        dic: STD::Q::b1
        zyg:
        - !!perl/hash:RE_method
          alt: backslash__S_010o_0 0
          name: octint
          rest: ''
        - !!perl/hash:RE_bracket
          alt: backslash__S_010o_0 1
          re: !!perl/hash:RE_sequence
            zyg:
            - !!perl/hash:RE_string
              i: 0
              text: '['
            - !!perl/hash:RE_block {}
            - !!perl/hash:RE_method
              name: octints
              rest: ''
            - !!perl/hash:RE_bracket
              re: !!perl/hash:RE_first
                zyg:
                - !!perl/hash:RE_string
                  i: 0
                  text: ']'
                - !!perl/hash:RE_method
                  name: FAILGOAL
                  rest: 1
backslash__S_010o_0: *1
backslash__S_011r: !!perl/hash:RE_ast
  dba: backslash
  dic: STD::Q::b1
  re: !!perl/hash:RE_method
    i: 0
    name: sym
    rest: ''
    sym: r
backslash__S_012t: !!perl/hash:RE_ast
  dba: backslash
  dic: STD::Q::b1
  re: !!perl/hash:RE_method
    i: 0
    name: sym
    rest: ''
    sym: t
backslash__S_013x: !!perl/hash:RE_ast
  dba: hex character
  dic: STD::Q::b1
  re: !!perl/hash:RE_sequence
    zyg:
    - !!perl/hash:RE_method
      i: 0
      name: sym
      rest: ''
      sym: x
    - !!perl/hash:RE_bracket
      re: &2 !!perl/hash:RE_any
        altname: backslash__S_013x_0
        dba: hex character
        dic: STD::Q::b1
        zyg:
        - !!perl/hash:RE_method
          alt: backslash__S_013x_0 0
          name: hexint
          rest: ''
        - !!perl/hash:RE_bracket
          alt: backslash__S_013x_0 1
          re: !!perl/hash:RE_sequence
            zyg:
            - !!perl/hash:RE_string
              i: 0
              text: '['
            - !!perl/hash:RE_block {}
            - !!perl/hash:RE_method
              name: hexints
              rest: ''
            - !!perl/hash:RE_bracket
              re: !!perl/hash:RE_first
                zyg:
                - !!perl/hash:RE_string
                  i: 0
                  text: ']'
                - !!perl/hash:RE_method
                  name: FAILGOAL
                  rest: 1
backslash__S_013x_0: *2
backslash__S_0140: !!perl/hash:RE_ast
  dba: backslash
  dic: STD::Q::b1
  re: !!perl/hash:RE_method
    i: 0
    name: sym
    rest: ''
    sym: '0'
escape__S_000Back: !!perl/hash:RE_ast
  dba: escape
  dic: STD::Q::b1
  re: !!perl/hash:RE_sequence
    zyg:
    - !!perl/hash:RE_method
      i: 0
      name: sym
      rest: ''
      sym: \
    - !!perl/hash:RE_block {}
    - !!perl/hash:RE_bindnamed
      atom: !!perl/hash:RE_method
        name: backslash
        rest: ''
RETREE_END
## token escape:sym<\\> { <sym> {} <item=.backslash> }
sub escape__S_000Back__PEEK { $_[0]->_AUTOLEXpeek('escape__S_000Back', $retree) }
sub escape__S_000Back {
no warnings 'recursion';
my $self = shift;


local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;

my $C = $self->cursor_xact("RULE escape__S_000Back");
my $xact = $C->xact;
my $S = $C->{'_pos'};
$C->{sym} = "\\";
$self->_MATCHIFYr($S, "escape__S_000Back", do {
my $C = $C;
if (($C) = ($C->_EXACT("\\"))
and ($C) = (scalar(do {
}, $C))) {
$C->_SUBSUMEr(['item'], sub {
my $C = shift;
$C->backslash
})
} else { () }

});
}
;
## token backslash:qq { <?before 'q'> { $<quote> = $¢.cursor_fresh(%*LANG<MAIN>).quote(); } }
sub backslash__S_001qq__PEEK { $_[0]->_AUTOLEXpeek('backslash__S_001qq', $retree) }
sub backslash__S_001qq {
no warnings 'recursion';
my $self = shift;


local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;

my $C = $self->cursor_xact("RULE backslash__S_001qq");
my $xact = $C->xact;
my $S = $C->{'_pos'};
$C->{sym} = "qq";
$self->_MATCHIFYr($S, "backslash__S_001qq", do {
if (my ($C) = ($C->before(sub {
my $C=shift;
if (my ($C) = ($C->before(sub {
my $C=shift;
$C->_EXACT("q")
}))) { ($C) } else { () }
}))) {
scalar(do {
my $M = $C;
$M->{'quote'} = $C->cursor_fresh($::LANG{'MAIN'})->quote()}, $C)
} else { () }

});
}
;
## token backslash:sym<\\> { <text=.sym> }
sub backslash__S_002Back__PEEK { $_[0]->_AUTOLEXpeek('backslash__S_002Back', $retree) }
sub backslash__S_002Back {
no warnings 'recursion';
my $self = shift;


local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;

my $C = $self->cursor_xact("RULE backslash__S_002Back");
my $xact = $C->xact;
my $S = $C->{'_pos'};
$C->{sym} = "\\";
$self->_MATCHIFYr($S, "backslash__S_002Back", $C->_SUBSUMEr(['text'], sub {
my $C = shift;
$C->_EXACT("\\")
}));
}
;
## token backslash:stopper { <text=.stopper> }
sub backslash__S_003stopper__PEEK { $_[0]->_AUTOLEXpeek('backslash__S_003stopper', $retree) }
sub backslash__S_003stopper {
no warnings 'recursion';
my $self = shift;


local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;

my $C = $self->cursor_xact("RULE backslash__S_003stopper");
my $xact = $C->xact;
my $S = $C->{'_pos'};
$C->{sym} = "stopper";
$self->_MATCHIFYr($S, "backslash__S_003stopper", $C->_SUBSUMEr(['text'], sub {
my $C = shift;
$C->stopper
}));
}
;
## token backslash:a { <sym> }
sub backslash__S_004a__PEEK { $_[0]->_AUTOLEXpeek('backslash__S_004a', $retree) }
sub backslash__S_004a {
no warnings 'recursion';
my $self = shift;


local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;

my $C = $self->cursor_xact("RULE backslash__S_004a");
my $xact = $C->xact;
my $S = $C->{'_pos'};
$C->{sym} = "a";
$self->_MATCHIFYr($S, "backslash__S_004a", $C->_EXACT("a"));
}
;
## token backslash:b { <sym> }
sub backslash__S_005b__PEEK { $_[0]->_AUTOLEXpeek('backslash__S_005b', $retree) }
sub backslash__S_005b {
no warnings 'recursion';
my $self = shift;


local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;

my $C = $self->cursor_xact("RULE backslash__S_005b");
my $xact = $C->xact;
my $S = $C->{'_pos'};
$C->{sym} = "b";
$self->_MATCHIFYr($S, "backslash__S_005b", $C->_EXACT("b"));
}
;
## token backslash:c { <sym> <charspec> }
sub backslash__S_006c__PEEK { $_[0]->_AUTOLEXpeek('backslash__S_006c', $retree) }
sub backslash__S_006c {
no warnings 'recursion';
my $self = shift;


local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;

my $C = $self->cursor_xact("RULE backslash__S_006c");
my $xact = $C->xact;
my $S = $C->{'_pos'};
$C->{sym} = "c";
$self->_MATCHIFYr($S, "backslash__S_006c", do {
if (my ($C) = ($C->_EXACT("c"))) {
$C->_SUBSUMEr(['charspec'], sub {
my $C = shift;
$C->charspec
})
} else { () }

});
}
;
## token backslash:e { <sym> }
sub backslash__S_007e__PEEK { $_[0]->_AUTOLEXpeek('backslash__S_007e', $retree) }
sub backslash__S_007e {
no warnings 'recursion';
my $self = shift;


local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;

my $C = $self->cursor_xact("RULE backslash__S_007e");
my $xact = $C->xact;
my $S = $C->{'_pos'};
$C->{sym} = "e";
$self->_MATCHIFYr($S, "backslash__S_007e", $C->_EXACT("e"));
}
;
## token backslash:f { <sym> }
sub backslash__S_008f__PEEK { $_[0]->_AUTOLEXpeek('backslash__S_008f', $retree) }
sub backslash__S_008f {
no warnings 'recursion';
my $self = shift;


local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;

my $C = $self->cursor_xact("RULE backslash__S_008f");
my $xact = $C->xact;
my $S = $C->{'_pos'};
$C->{sym} = "f";
$self->_MATCHIFYr($S, "backslash__S_008f", $C->_EXACT("f"));
}
;
## token backslash:n { <sym> }
sub backslash__S_009n__PEEK { $_[0]->_AUTOLEXpeek('backslash__S_009n', $retree) }
sub backslash__S_009n {
no warnings 'recursion';
my $self = shift;


local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;

my $C = $self->cursor_xact("RULE backslash__S_009n");
my $xact = $C->xact;
my $S = $C->{'_pos'};
$C->{sym} = "n";
$self->_MATCHIFYr($S, "backslash__S_009n", $C->_EXACT("n"));
}
;
## token backslash:o { :dba('octal character') <sym> [ <octint> | '[' ~ ']' <octints> ] }
sub backslash__S_010o__PEEK { $_[0]->_AUTOLEXpeek('backslash__S_010o', $retree) }
sub backslash__S_010o {
no warnings 'recursion';
my $self = shift;


local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;

my $C = $self->cursor_xact("RULE backslash__S_010o");
my $xact = $C->xact;
my $S = $C->{'_pos'};
$C->{sym} = "o";
$self->_MATCHIFYr($S, "backslash__S_010o", do {
my $C = $C;
if (($C) = ($C->_EXACT("o"))
and ($C) = ($C->_BRACKETr(sub {
my $C=shift;
do {
my ($tag, $try);
my @try;
my $relex;

my $fate;
my $x;
if ($fate = $C->{'_fate'} and $fate->[1] eq 'backslash__S_010o_0') {
$C->deb("Fate passed to backslash__S_010o_0: ", ::fatestr($fate)) if $::DEBUG & DEBUG::fates;
($C->{'_fate'}, $tag, $try) = @$fate;
@try = ($try);
$x = 'ALT backslash__S_010o_0';    # some outer ltm is controlling us
}
else {
$x = 'ALTLTM backslash__S_010o_0'; # we are top level ltm
}
my $C = $C->cursor_xact($x);
my $xact = $C->{_xact};

my @gather = ();
for (;;) {
unless (@try) {
$relex //= $C->cursor_fate('STD::Q::b1', 'backslash__S_010o_0', $retree);
@try = $relex->($C) or last;
}
$try = shift(@try) // next;

if (ref $try) {
($C->{'_fate'}, $tag, $try) = @$try;   # next candidate fate
}

$C->deb("backslash__S_010o_0 trying $tag $try") if $::DEBUG & DEBUG::try_processing;
push @gather, ((
sub {
my $C=shift;
$C->_SUBSUMEr(['octint'], sub {
my $C = shift;
$C->octint
})
},
sub {
my $C=shift;
if (my ($C) = ($C->_BRACKETr(sub {
my $C=shift;
local $::GOAL = "\]";
my $goalpos = $C;
if (($C) = ($C->_EXACT("\["))
and ($C) = (scalar(do {
}, $C))
and ($C) = ($C->_SUBSUMEr(['octints'], sub {
my $C = shift;
$C->octints
}))
and ($C) = ($C->_BRACKETr(sub {
my $C=shift;
do {    my $C = $C->cursor_xact('ALT ||');
my $xact = $C->xact;
my @gather;
do {
push @gather, $C->_EXACT("\]")
}
or $xact->[-2] or
do {
push @gather, do {
if (my ($C) = ($C->FAILGOAL($::GOAL, 'octal character', $goalpos))) { ($C) } else { () }

}
};
@gather;
}
}))) {
$C
} else { () }
}))) { ($C) } else { () }
}
)[$try])->($C);
last if @gather;
last if $xact->[-2];  # committed?
}
@gather;
};
}))) {
$C
} else { () }

});
}
;
## token backslash:r { <sym> }
sub backslash__S_011r__PEEK { $_[0]->_AUTOLEXpeek('backslash__S_011r', $retree) }
sub backslash__S_011r {
no warnings 'recursion';
my $self = shift;


local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;

my $C = $self->cursor_xact("RULE backslash__S_011r");
my $xact = $C->xact;
my $S = $C->{'_pos'};
$C->{sym} = "r";
$self->_MATCHIFYr($S, "backslash__S_011r", $C->_EXACT("r"));
}
;
## token backslash:t { <sym> }
sub backslash__S_012t__PEEK { $_[0]->_AUTOLEXpeek('backslash__S_012t', $retree) }
sub backslash__S_012t {
no warnings 'recursion';
my $self = shift;


local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;

my $C = $self->cursor_xact("RULE backslash__S_012t");
my $xact = $C->xact;
my $S = $C->{'_pos'};
$C->{sym} = "t";
$self->_MATCHIFYr($S, "backslash__S_012t", $C->_EXACT("t"));
}
;
## token backslash:x { :dba('hex character') <sym> [ <hexint> | '[' ~ ']' <hexints> ] }
sub backslash__S_013x__PEEK { $_[0]->_AUTOLEXpeek('backslash__S_013x', $retree) }
sub backslash__S_013x {
no warnings 'recursion';
my $self = shift;


local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;

my $C = $self->cursor_xact("RULE backslash__S_013x");
my $xact = $C->xact;
my $S = $C->{'_pos'};
$C->{sym} = "x";
$self->_MATCHIFYr($S, "backslash__S_013x", do {
my $C = $C;
if (($C) = ($C->_EXACT("x"))
and ($C) = ($C->_BRACKETr(sub {
my $C=shift;
do {
my ($tag, $try);
my @try;
my $relex;

my $fate;
my $x;
if ($fate = $C->{'_fate'} and $fate->[1] eq 'backslash__S_013x_0') {
$C->deb("Fate passed to backslash__S_013x_0: ", ::fatestr($fate)) if $::DEBUG & DEBUG::fates;
($C->{'_fate'}, $tag, $try) = @$fate;
@try = ($try);
$x = 'ALT backslash__S_013x_0';    # some outer ltm is controlling us
}
else {
$x = 'ALTLTM backslash__S_013x_0'; # we are top level ltm
}
my $C = $C->cursor_xact($x);
my $xact = $C->{_xact};

my @gather = ();
for (;;) {
unless (@try) {
$relex //= $C->cursor_fate('STD::Q::b1', 'backslash__S_013x_0', $retree);
@try = $relex->($C) or last;
}
$try = shift(@try) // next;

if (ref $try) {
($C->{'_fate'}, $tag, $try) = @$try;   # next candidate fate
}

$C->deb("backslash__S_013x_0 trying $tag $try") if $::DEBUG & DEBUG::try_processing;
push @gather, ((
sub {
my $C=shift;
$C->_SUBSUMEr(['hexint'], sub {
my $C = shift;
$C->hexint
})
},
sub {
my $C=shift;
if (my ($C) = ($C->_BRACKETr(sub {
my $C=shift;
local $::GOAL = "\]";
my $goalpos = $C;
if (($C) = ($C->_EXACT("\["))
and ($C) = (scalar(do {
}, $C))
and ($C) = ($C->_SUBSUMEr(['hexints'], sub {
my $C = shift;
$C->hexints
}))
and ($C) = ($C->_BRACKETr(sub {
my $C=shift;
do {    my $C = $C->cursor_xact('ALT ||');
my $xact = $C->xact;
my @gather;
do {
push @gather, $C->_EXACT("\]")
}
or $xact->[-2] or
do {
push @gather, do {
if (my ($C) = ($C->FAILGOAL($::GOAL, 'hex character', $goalpos))) { ($C) } else { () }

}
};
@gather;
}
}))) {
$C
} else { () }
}))) { ($C) } else { () }
}
)[$try])->($C);
last if @gather;
last if $xact->[-2];  # committed?
}
@gather;
};
}))) {
$C
} else { () }

});
}
;
## token backslash:sym<0> { <sym> }
sub backslash__S_0140__PEEK { $_[0]->_AUTOLEXpeek('backslash__S_0140', $retree) }
sub backslash__S_0140 {
no warnings 'recursion';
my $self = shift;


local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;

my $C = $self->cursor_xact("RULE backslash__S_0140");
my $xact = $C->xact;
my $S = $C->{'_pos'};
$self->_MATCHIFYr($S, "backslash__S_0140", $C->_EXACT("0"));
}
;
1; };
{ package STD::Q::b0;
use Moose::Role ':all' => { -prefix => "moose_" };
use Encode;
our $ALLROLES = { 'STD::Q::b0', 1 };
our $REGEXES = {
ALL => [ qw/escape/ ],
escape => [ qw/escape__S_000Back__PEEK/ ],
};


no warnings 'qw', 'recursion';
my $retree;

$DB::deep = $DB::deep = 1000; # suppress used-once warning

use YAML::XS;

$SIG{__WARN__} = sub { die @_,"   statement started at line ", 'Cursor'->lineof($::LASTSTATE), "
" } if $::DEBUG;

$retree = YAML::XS::Load(Encode::encode_utf8(<<'RETREE_END'));
---
escape__S_000Back: !!perl/hash:RE_ast
  dba: escape
  dic: STD::Q::b0
  re: !!perl/hash:RE_assertion
    assert: '!'
    re: !!perl/hash:RE_noop
      nobind: 1
RETREE_END
## token escape:sym<\\> { <!> }
sub escape__S_000Back__PEEK { $_[0]->_AUTOLEXpeek('escape__S_000Back', $retree) }
sub escape__S_000Back {
no warnings 'recursion';
my $self = shift;


local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;

my $C = $self->cursor_xact("RULE escape__S_000Back");
my $xact = $C->xact;
my $S = $C->{'_pos'};
$C->{sym} = "\\";
$self->_MATCHIFYr($S, "escape__S_000Back", $C->_NOTBEFORE(sub {
my $C=shift;
$C
}));
}
1; };
{ package STD::Q::c1;
use Moose::Role ':all' => { -prefix => "moose_" };
use Encode;
our $ALLROLES = { 'STD::Q::c1', 1 };
our $REGEXES = {
ALL => [ qw/escape/ ],
escape => [ qw/escape__S_000Cur_Ly__PEEK/ ],
};


no warnings 'qw', 'recursion';
my $retree;

$DB::deep = $DB::deep = 1000; # suppress used-once warning

use YAML::XS;

$SIG{__WARN__} = sub { die @_,"   statement started at line ", 'Cursor'->lineof($::LASTSTATE), "
" } if $::DEBUG;

$retree = YAML::XS::Load(Encode::encode_utf8(<<'RETREE_END'));
---
escape__S_000Cur_Ly: !!perl/hash:RE_ast
  dba: escape
  dic: STD::Q::c1
  re: !!perl/hash:RE_sequence
    zyg:
    - !!perl/hash:RE_assertion
      assert: '?'
      re: !!perl/hash:RE_method_re
        name: before
        nobind: 1
        re: !!perl/hash:RE_string
          i: 0
          text: '{'
    - !!perl/hash:RE_bracket
      re: !!perl/hash:RE_sequence
        zyg:
        - !!perl/hash:RE_decl {}
        - !!perl/hash:RE_method
          name: embeddedblock
          rest: ''
RETREE_END
## token escape:sym<{ }> { <?before '{'> [ :lang(%*LANG<MAIN>) <embeddedblock> ] }
sub escape__S_000Cur_Ly__PEEK { $_[0]->_AUTOLEXpeek('escape__S_000Cur_Ly', $retree) }
sub escape__S_000Cur_Ly {
no warnings 'recursion';
my $self = shift;


local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;

my $C = $self->cursor_xact("RULE escape__S_000Cur_Ly");
my $xact = $C->xact;
my $S = $C->{'_pos'};
$C->{sym} = "\{\ \}";
$self->_MATCHIFYr($S, "escape__S_000Cur_Ly", do {
my $C = $C;
if (($C) = ($C->before(sub {
my $C=shift;
if (my ($C) = ($C->before(sub {
my $C=shift;
$C->_EXACT("\{")
}))) { ($C) } else { () }
}))
and ($C) = ($C->_BRACKETr(sub {
my $C=shift;
my $newlang = ($::LANG{'MAIN'});
$C = bless($C, (ref($newlang) || $newlang));
$C->_SUBSUMEr(['embeddedblock'], sub {
my $C = shift;
$C->embeddedblock
})
}))) {
$C
} else { () }

});
}
1; };
{ package STD::Q::c0;
use Moose::Role ':all' => { -prefix => "moose_" };
use Encode;
our $ALLROLES = { 'STD::Q::c0', 1 };
our $REGEXES = {
ALL => [ qw/escape/ ],
escape => [ qw/escape__S_000Cur_Ly__PEEK/ ],
};


no warnings 'qw', 'recursion';
my $retree;

$DB::deep = $DB::deep = 1000; # suppress used-once warning

use YAML::XS;

$SIG{__WARN__} = sub { die @_,"   statement started at line ", 'Cursor'->lineof($::LASTSTATE), "
" } if $::DEBUG;

$retree = YAML::XS::Load(Encode::encode_utf8(<<'RETREE_END'));
---
escape__S_000Cur_Ly: !!perl/hash:RE_ast
  dba: escape
  dic: STD::Q::c0
  re: !!perl/hash:RE_assertion
    assert: '!'
    re: !!perl/hash:RE_noop
      nobind: 1
RETREE_END
## token escape:sym<{ }> { <!> }
sub escape__S_000Cur_Ly__PEEK { $_[0]->_AUTOLEXpeek('escape__S_000Cur_Ly', $retree) }
sub escape__S_000Cur_Ly {
no warnings 'recursion';
my $self = shift;


local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;

my $C = $self->cursor_xact("RULE escape__S_000Cur_Ly");
my $xact = $C->xact;
my $S = $C->{'_pos'};
$C->{sym} = "\{\ \}";
$self->_MATCHIFYr($S, "escape__S_000Cur_Ly", $C->_NOTBEFORE(sub {
my $C=shift;
$C
}));
}
1; };
{ package STD::Q::s1;
use Moose::Role ':all' => { -prefix => "moose_" };
use Encode;
our $ALLROLES = { 'STD::Q::s1', 1 };
our $REGEXES = {
ALL => [ qw/escape/ ],
escape => [ qw/escape__S_000Dollar__PEEK/ ],
};


no warnings 'qw', 'recursion';
my $retree;

$DB::deep = $DB::deep = 1000; # suppress used-once warning

use YAML::XS;

$SIG{__WARN__} = sub { die @_,"   statement started at line ", 'Cursor'->lineof($::LASTSTATE), "
" } if $::DEBUG;

$retree = YAML::XS::Load(Encode::encode_utf8(<<'RETREE_END'));
---
escape__S_000Dollar: !!perl/hash:RE_ast
  dba: escape
  dic: STD::Q::s1
  re: !!perl/hash:RE_first
    zyg:
    - !!perl/hash:RE_sequence
      zyg:
      - !!perl/hash:RE_assertion
        assert: '?'
        re: !!perl/hash:RE_method_re
          name: before
          nobind: 1
          re: !!perl/hash:RE_string
            i: 0
            text: $
      - !!perl/hash:RE_bracket
        re: !!perl/hash:RE_sequence
          zyg:
          - !!perl/hash:RE_decl {}
          - !!perl/hash:RE_method
            name: EXPR
            rest: 1
    - !!perl/hash:RE_method
      name: panic
      rest: 1
RETREE_END
## token escape:sym<$> {
sub escape__S_000Dollar__PEEK { $_[0]->_AUTOLEXpeek('escape__S_000Dollar', $retree) }
sub escape__S_000Dollar {
no warnings 'recursion';
my $self = shift;

local $::QSIGIL = '$';
local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;

my $C = $self->cursor_xact("RULE escape__S_000Dollar");
my $xact = $C->xact;
my $S = $C->{'_pos'};
$C->{sym} = "\$";
$self->_MATCHIFYr($S, "escape__S_000Dollar", do {    my $C = $C->cursor_xact('ALT ||');
my $xact = $C->xact;
my @gather;
do {
push @gather, do {
my $C = $C;
if (($C) = ($C->before(sub {
my $C=shift;
if (my ($C) = ($C->before(sub {
my $C=shift;
$C->_EXACT("\$")
}))) { ($C) } else { () }
}))
and ($C) = ($C->_BRACKETr(sub {
my $C=shift;
my $newlang = ($::LANG{'MAIN'});
$C = bless($C, (ref($newlang) || $newlang));
$C->_SUBSUMEr(['EXPR'], sub {
my $C = shift;
$C->EXPR(\%methodcall)
})
}))) {
$C
} else { () }

}
}
or $xact->[-2] or
do {
push @gather, do {
if (my ($C) = ($C->panic("Non-variable \$ must be backslashed"))) { ($C) } else { () }

}
};
@gather;
});
}
1; };
{ package STD::Q::s0;
use Moose::Role ':all' => { -prefix => "moose_" };
use Encode;
our $ALLROLES = { 'STD::Q::s0', 1 };
our $REGEXES = {
ALL => [ qw/escape/ ],
escape => [ qw/escape__S_000Dollar__PEEK/ ],
};


no warnings 'qw', 'recursion';
my $retree;

$DB::deep = $DB::deep = 1000; # suppress used-once warning

use YAML::XS;

$SIG{__WARN__} = sub { die @_,"   statement started at line ", 'Cursor'->lineof($::LASTSTATE), "
" } if $::DEBUG;

$retree = YAML::XS::Load(Encode::encode_utf8(<<'RETREE_END'));
---
escape__S_000Dollar: !!perl/hash:RE_ast
  dba: escape
  dic: STD::Q::s0
  re: !!perl/hash:RE_assertion
    assert: '!'
    re: !!perl/hash:RE_noop
      nobind: 1
RETREE_END
## token escape:sym<$> { <!> }
sub escape__S_000Dollar__PEEK { $_[0]->_AUTOLEXpeek('escape__S_000Dollar', $retree) }
sub escape__S_000Dollar {
no warnings 'recursion';
my $self = shift;


local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;

my $C = $self->cursor_xact("RULE escape__S_000Dollar");
my $xact = $C->xact;
my $S = $C->{'_pos'};
$C->{sym} = "\$";
$self->_MATCHIFYr($S, "escape__S_000Dollar", $C->_NOTBEFORE(sub {
my $C=shift;
$C
}));
}
1; };
{ package STD::Q::a1;
use Moose::Role ':all' => { -prefix => "moose_" };
use Encode;
our $ALLROLES = { 'STD::Q::a1', 1 };
our $REGEXES = {
ALL => [ qw/escape/ ],
escape => [ qw/escape__S_000At__PEEK/ ],
};


no warnings 'qw', 'recursion';
my $retree;

$DB::deep = $DB::deep = 1000; # suppress used-once warning

use YAML::XS;

$SIG{__WARN__} = sub { die @_,"   statement started at line ", 'Cursor'->lineof($::LASTSTATE), "
" } if $::DEBUG;

$retree = YAML::XS::Load(Encode::encode_utf8(<<'RETREE_END'));
---
escape__S_000At: !!perl/hash:RE_ast
  dba: escape
  dic: STD::Q::a1
  re: !!perl/hash:RE_sequence
    zyg:
    - !!perl/hash:RE_assertion
      assert: '?'
      re: !!perl/hash:RE_method_re
        name: before
        nobind: 1
        re: !!perl/hash:RE_string
          i: 0
          text: '@'
    - !!perl/hash:RE_bracket
      re: &1 !!perl/hash:RE_any
        altname: escape__S_000At_0
        dba: escape
        dic: STD::Q::a1
        zyg:
        - !!perl/hash:RE_sequence
          alt: escape__S_000At_0 0
          zyg:
          - !!perl/hash:RE_decl {}
          - !!perl/hash:RE_method
            name: EXPR
            rest: 1
        - !!perl/hash:RE_assertion
          alt: escape__S_000At_0 1
          assert: '!'
          re: !!perl/hash:RE_noop
            nobind: 1
escape__S_000At_0: *1
RETREE_END
## token escape:sym<@> {
sub escape__S_000At__PEEK { $_[0]->_AUTOLEXpeek('escape__S_000At', $retree) }
sub escape__S_000At {
no warnings 'recursion';
my $self = shift;

local $::QSIGIL = '@';
local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;

my $C = $self->cursor_xact("RULE escape__S_000At");
my $xact = $C->xact;
my $S = $C->{'_pos'};
$C->{sym} = "\@";
$self->_MATCHIFYr($S, "escape__S_000At", do {
my $C = $C;
if (($C) = ($C->before(sub {
my $C=shift;
if (my ($C) = ($C->before(sub {
my $C=shift;
$C->_EXACT("\@")
}))) { ($C) } else { () }
}))
and ($C) = ($C->_BRACKETr(sub {
my $C=shift;
do {
my ($tag, $try);
my @try;
my $relex;

my $fate;
my $x;
if ($fate = $C->{'_fate'} and $fate->[1] eq 'escape__S_000At_0') {
$C->deb("Fate passed to escape__S_000At_0: ", ::fatestr($fate)) if $::DEBUG & DEBUG::fates;
($C->{'_fate'}, $tag, $try) = @$fate;
@try = ($try);
$x = 'ALT escape__S_000At_0';    # some outer ltm is controlling us
}
else {
$x = 'ALTLTM escape__S_000At_0'; # we are top level ltm
}
my $C = $C->cursor_xact($x);
my $xact = $C->{_xact};

my @gather = ();
for (;;) {
unless (@try) {
$relex //= $C->cursor_fate('STD::Q::a1', 'escape__S_000At_0', $retree);
@try = $relex->($C) or last;
}
$try = shift(@try) // next;

if (ref $try) {
($C->{'_fate'}, $tag, $try) = @$try;   # next candidate fate
}

$C->deb("escape__S_000At_0 trying $tag $try") if $::DEBUG & DEBUG::try_processing;
push @gather, ((
sub {
my $C=shift;
if (my ($C) = (do {
my $newlang = ($::LANG{'MAIN'});
$C = bless($C, (ref($newlang) || $newlang));
$C->_SUBSUMEr(['EXPR'], sub {
my $C = shift;
$C->EXPR(\%methodcall)
})

})) { ($C) } else { () }
},
sub {
my $C=shift;
if (my ($C) = ($C->_NOTBEFORE(sub {
my $C=shift;
$C
}))) { ($C) } else { () }
}
)[$try])->($C);
last if @gather;
last if $xact->[-2];  # committed?
}
@gather;
};
}))) {
$C
} else { () }

});
}
1; };
{ package STD::Q::a0;
use Moose::Role ':all' => { -prefix => "moose_" };
use Encode;
our $ALLROLES = { 'STD::Q::a0', 1 };
our $REGEXES = {
ALL => [ qw/escape/ ],
escape => [ qw/escape__S_000At__PEEK/ ],
};


no warnings 'qw', 'recursion';
my $retree;

$DB::deep = $DB::deep = 1000; # suppress used-once warning

use YAML::XS;

$SIG{__WARN__} = sub { die @_,"   statement started at line ", 'Cursor'->lineof($::LASTSTATE), "
" } if $::DEBUG;

$retree = YAML::XS::Load(Encode::encode_utf8(<<'RETREE_END'));
---
escape__S_000At: !!perl/hash:RE_ast
  dba: escape
  dic: STD::Q::a0
  re: !!perl/hash:RE_assertion
    assert: '!'
    re: !!perl/hash:RE_noop
      nobind: 1
RETREE_END
## token escape:sym<@> { <!> }
sub escape__S_000At__PEEK { $_[0]->_AUTOLEXpeek('escape__S_000At', $retree) }
sub escape__S_000At {
no warnings 'recursion';
my $self = shift;


local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;

my $C = $self->cursor_xact("RULE escape__S_000At");
my $xact = $C->xact;
my $S = $C->{'_pos'};
$C->{sym} = "\@";
$self->_MATCHIFYr($S, "escape__S_000At", $C->_NOTBEFORE(sub {
my $C=shift;
$C
}));
}
1; };
{ package STD::Q::h1;
use Moose::Role ':all' => { -prefix => "moose_" };
use Encode;
our $ALLROLES = { 'STD::Q::h1', 1 };
our $REGEXES = {
ALL => [ qw/escape/ ],
escape => [ qw/escape__S_000Percent__PEEK/ ],
};


no warnings 'qw', 'recursion';
my $retree;

$DB::deep = $DB::deep = 1000; # suppress used-once warning

use YAML::XS;

$SIG{__WARN__} = sub { die @_,"   statement started at line ", 'Cursor'->lineof($::LASTSTATE), "
" } if $::DEBUG;

$retree = YAML::XS::Load(Encode::encode_utf8(<<'RETREE_END'));
---
escape__S_000Percent: !!perl/hash:RE_ast
  dba: escape
  dic: STD::Q::h1
  re: !!perl/hash:RE_sequence
    zyg:
    - !!perl/hash:RE_assertion
      assert: '?'
      re: !!perl/hash:RE_method_re
        name: before
        nobind: 1
        re: !!perl/hash:RE_string
          i: 0
          text: '%'
    - !!perl/hash:RE_bracket
      re: &1 !!perl/hash:RE_any
        altname: escape__S_000Percent_0
        dba: escape
        dic: STD::Q::h1
        zyg:
        - !!perl/hash:RE_sequence
          alt: escape__S_000Percent_0 0
          zyg:
          - !!perl/hash:RE_decl {}
          - !!perl/hash:RE_method
            name: EXPR
            rest: 1
        - !!perl/hash:RE_assertion
          alt: escape__S_000Percent_0 1
          assert: '!'
          re: !!perl/hash:RE_noop
            nobind: 1
escape__S_000Percent_0: *1
RETREE_END
## token escape:sym<%> {
sub escape__S_000Percent__PEEK { $_[0]->_AUTOLEXpeek('escape__S_000Percent', $retree) }
sub escape__S_000Percent {
no warnings 'recursion';
my $self = shift;

local $::QSIGIL = '%';
local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;

my $C = $self->cursor_xact("RULE escape__S_000Percent");
my $xact = $C->xact;
my $S = $C->{'_pos'};
$C->{sym} = "\%";
$self->_MATCHIFYr($S, "escape__S_000Percent", do {
my $C = $C;
if (($C) = ($C->before(sub {
my $C=shift;
if (my ($C) = ($C->before(sub {
my $C=shift;
$C->_EXACT("\%")
}))) { ($C) } else { () }
}))
and ($C) = ($C->_BRACKETr(sub {
my $C=shift;
do {
my ($tag, $try);
my @try;
my $relex;

my $fate;
my $x;
if ($fate = $C->{'_fate'} and $fate->[1] eq 'escape__S_000Percent_0') {
$C->deb("Fate passed to escape__S_000Percent_0: ", ::fatestr($fate)) if $::DEBUG & DEBUG::fates;
($C->{'_fate'}, $tag, $try) = @$fate;
@try = ($try);
$x = 'ALT escape__S_000Percent_0';    # some outer ltm is controlling us
}
else {
$x = 'ALTLTM escape__S_000Percent_0'; # we are top level ltm
}
my $C = $C->cursor_xact($x);
my $xact = $C->{_xact};

my @gather = ();
for (;;) {
unless (@try) {
$relex //= $C->cursor_fate('STD::Q::h1', 'escape__S_000Percent_0', $retree);
@try = $relex->($C) or last;
}
$try = shift(@try) // next;

if (ref $try) {
($C->{'_fate'}, $tag, $try) = @$try;   # next candidate fate
}

$C->deb("escape__S_000Percent_0 trying $tag $try") if $::DEBUG & DEBUG::try_processing;
push @gather, ((
sub {
my $C=shift;
if (my ($C) = (do {
my $newlang = ($::LANG{'MAIN'});
$C = bless($C, (ref($newlang) || $newlang));
$C->_SUBSUMEr(['EXPR'], sub {
my $C = shift;
$C->EXPR(\%methodcall)
})

})) { ($C) } else { () }
},
sub {
my $C=shift;
if (my ($C) = ($C->_NOTBEFORE(sub {
my $C=shift;
$C
}))) { ($C) } else { () }
}
)[$try])->($C);
last if @gather;
last if $xact->[-2];  # committed?
}
@gather;
};
}))) {
$C
} else { () }

});
}
1; };
{ package STD::Q::h0;
use Moose::Role ':all' => { -prefix => "moose_" };
use Encode;
our $ALLROLES = { 'STD::Q::h0', 1 };
our $REGEXES = {
ALL => [ qw/escape/ ],
escape => [ qw/escape__S_000Percent__PEEK/ ],
};


no warnings 'qw', 'recursion';
my $retree;

$DB::deep = $DB::deep = 1000; # suppress used-once warning

use YAML::XS;

$SIG{__WARN__} = sub { die @_,"   statement started at line ", 'Cursor'->lineof($::LASTSTATE), "
" } if $::DEBUG;

$retree = YAML::XS::Load(Encode::encode_utf8(<<'RETREE_END'));
---
escape__S_000Percent: !!perl/hash:RE_ast
  dba: escape
  dic: STD::Q::h0
  re: !!perl/hash:RE_assertion
    assert: '!'
    re: !!perl/hash:RE_noop
      nobind: 1
RETREE_END
## token escape:sym<%> { <!> }
sub escape__S_000Percent__PEEK { $_[0]->_AUTOLEXpeek('escape__S_000Percent', $retree) }
sub escape__S_000Percent {
no warnings 'recursion';
my $self = shift;


local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;

my $C = $self->cursor_xact("RULE escape__S_000Percent");
my $xact = $C->xact;
my $S = $C->{'_pos'};
$C->{sym} = "\%";
$self->_MATCHIFYr($S, "escape__S_000Percent", $C->_NOTBEFORE(sub {
my $C=shift;
$C
}));
}
1; };
{ package STD::Q::f1;
use Moose::Role ':all' => { -prefix => "moose_" };
use Encode;
our $ALLROLES = { 'STD::Q::f1', 1 };
our $REGEXES = {
ALL => [ qw/escape/ ],
escape => [ qw/escape__S_000Amp__PEEK/ ],
};


no warnings 'qw', 'recursion';
my $retree;

$DB::deep = $DB::deep = 1000; # suppress used-once warning

use YAML::XS;

$SIG{__WARN__} = sub { die @_,"   statement started at line ", 'Cursor'->lineof($::LASTSTATE), "
" } if $::DEBUG;

$retree = YAML::XS::Load(Encode::encode_utf8(<<'RETREE_END'));
---
escape__S_000Amp: !!perl/hash:RE_ast
  dba: escape
  dic: STD::Q::f1
  re: !!perl/hash:RE_sequence
    zyg:
    - !!perl/hash:RE_assertion
      assert: '?'
      re: !!perl/hash:RE_method_re
        name: before
        nobind: 1
        re: !!perl/hash:RE_string
          i: 0
          text: '&'
    - !!perl/hash:RE_bracket
      re: &1 !!perl/hash:RE_any
        altname: escape__S_000Amp_0
        dba: escape
        dic: STD::Q::f1
        zyg:
        - !!perl/hash:RE_sequence
          alt: escape__S_000Amp_0 0
          zyg:
          - !!perl/hash:RE_decl {}
          - !!perl/hash:RE_method
            name: EXPR
            rest: 1
        - !!perl/hash:RE_assertion
          alt: escape__S_000Amp_0 1
          assert: '!'
          re: !!perl/hash:RE_noop
            nobind: 1
escape__S_000Amp_0: *1
RETREE_END
## token escape:sym<&> {
sub escape__S_000Amp__PEEK { $_[0]->_AUTOLEXpeek('escape__S_000Amp', $retree) }
sub escape__S_000Amp {
no warnings 'recursion';
my $self = shift;

local $::QSIGIL = '&';
local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;

my $C = $self->cursor_xact("RULE escape__S_000Amp");
my $xact = $C->xact;
my $S = $C->{'_pos'};
$C->{sym} = "\&";
$self->_MATCHIFYr($S, "escape__S_000Amp", do {
my $C = $C;
if (($C) = ($C->before(sub {
my $C=shift;
if (my ($C) = ($C->before(sub {
my $C=shift;
$C->_EXACT("\&")
}))) { ($C) } else { () }
}))
and ($C) = ($C->_BRACKETr(sub {
my $C=shift;
do {
my ($tag, $try);
my @try;
my $relex;

my $fate;
my $x;
if ($fate = $C->{'_fate'} and $fate->[1] eq 'escape__S_000Amp_0') {
$C->deb("Fate passed to escape__S_000Amp_0: ", ::fatestr($fate)) if $::DEBUG & DEBUG::fates;
($C->{'_fate'}, $tag, $try) = @$fate;
@try = ($try);
$x = 'ALT escape__S_000Amp_0';    # some outer ltm is controlling us
}
else {
$x = 'ALTLTM escape__S_000Amp_0'; # we are top level ltm
}
my $C = $C->cursor_xact($x);
my $xact = $C->{_xact};

my @gather = ();
for (;;) {
unless (@try) {
$relex //= $C->cursor_fate('STD::Q::f1', 'escape__S_000Amp_0', $retree);
@try = $relex->($C) or last;
}
$try = shift(@try) // next;

if (ref $try) {
($C->{'_fate'}, $tag, $try) = @$try;   # next candidate fate
}

$C->deb("escape__S_000Amp_0 trying $tag $try") if $::DEBUG & DEBUG::try_processing;
push @gather, ((
sub {
my $C=shift;
if (my ($C) = (do {
my $newlang = ($::LANG{'MAIN'});
$C = bless($C, (ref($newlang) || $newlang));
$C->_SUBSUMEr(['EXPR'], sub {
my $C = shift;
$C->EXPR(\%methodcall)
})

})) { ($C) } else { () }
},
sub {
my $C=shift;
if (my ($C) = ($C->_NOTBEFORE(sub {
my $C=shift;
$C
}))) { ($C) } else { () }
}
)[$try])->($C);
last if @gather;
last if $xact->[-2];  # committed?
}
@gather;
};
}))) {
$C
} else { () }

});
}
1; };
{ package STD::Q::f0;
use Moose::Role ':all' => { -prefix => "moose_" };
use Encode;
our $ALLROLES = { 'STD::Q::f0', 1 };
our $REGEXES = {
ALL => [ qw/escape/ ],
escape => [ qw/escape__S_000Amp__PEEK/ ],
};


no warnings 'qw', 'recursion';
my $retree;

$DB::deep = $DB::deep = 1000; # suppress used-once warning

use YAML::XS;

$SIG{__WARN__} = sub { die @_,"   statement started at line ", 'Cursor'->lineof($::LASTSTATE), "
" } if $::DEBUG;

$retree = YAML::XS::Load(Encode::encode_utf8(<<'RETREE_END'));
---
escape__S_000Amp: !!perl/hash:RE_ast
  dba: escape
  dic: STD::Q::f0
  re: !!perl/hash:RE_assertion
    assert: '!'
    re: !!perl/hash:RE_noop
      nobind: 1
RETREE_END
## token escape:sym<&> { <!> }
sub escape__S_000Amp__PEEK { $_[0]->_AUTOLEXpeek('escape__S_000Amp', $retree) }
sub escape__S_000Amp {
no warnings 'recursion';
my $self = shift;


local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;

my $C = $self->cursor_xact("RULE escape__S_000Amp");
my $xact = $C->xact;
my $S = $C->{'_pos'};
$C->{sym} = "\&";
$self->_MATCHIFYr($S, "escape__S_000Amp", $C->_NOTBEFORE(sub {
my $C=shift;
$C
}));
}
1; };
{ package STD::Q::p1;
use Moose::Role ':all' => { -prefix => "moose_" };
use Encode;
our $ALLROLES = { 'STD::Q::p1', 1 };
our $REGEXES = {
ALL => [ qw// ],
};


no warnings 'qw', 'recursion';
my $retree;

$DB::deep = $DB::deep = 1000; # suppress used-once warning

use YAML::XS;

$SIG{__WARN__} = sub { die @_,"   statement started at line ", 'Cursor'->lineof($::LASTSTATE), "
" } if $::DEBUG;

## method postprocess ($s)
sub postprocess {
no warnings 'recursion';
my $self = shift;
die 'Required argument s omitted' unless @_;
my $s = @_ ? shift() : undef;
$s->parsepath }  1; };
{ package STD::Q::p0;
use Moose::Role ':all' => { -prefix => "moose_" };
use Encode;
our $ALLROLES = { 'STD::Q::p0', 1 };
our $REGEXES = {
ALL => [ qw// ],
};


no warnings 'qw', 'recursion';
my $retree;

$DB::deep = $DB::deep = 1000; # suppress used-once warning

use YAML::XS;

$SIG{__WARN__} = sub { die @_,"   statement started at line ", 'Cursor'->lineof($::LASTSTATE), "
" } if $::DEBUG;

## method postprocess ($s)
sub postprocess {
no warnings 'recursion';
my $self = shift;
die 'Required argument s omitted' unless @_;
my $s = @_ ? shift() : undef;
$s }  1; };
{ package STD::Q::w1;
use Moose::Role ':all' => { -prefix => "moose_" };
use Encode;
our $ALLROLES = { 'STD::Q::w1', 1 };
our $REGEXES = {
ALL => [ qw// ],
};


no warnings 'qw', 'recursion';
my $retree;

$DB::deep = $DB::deep = 1000; # suppress used-once warning

use YAML::XS;

$SIG{__WARN__} = sub { die @_,"   statement started at line ", 'Cursor'->lineof($::LASTSTATE), "
" } if $::DEBUG;

## method postprocess ($s)
sub postprocess {
no warnings 'recursion';
my $self = shift;
die 'Required argument s omitted' unless @_;
my $s = @_ ? shift() : undef;
$s->words }  1; };
{ package STD::Q::w0;
use Moose::Role ':all' => { -prefix => "moose_" };
use Encode;
our $ALLROLES = { 'STD::Q::w0', 1 };
our $REGEXES = {
ALL => [ qw// ],
};


no warnings 'qw', 'recursion';
my $retree;

$DB::deep = $DB::deep = 1000; # suppress used-once warning

use YAML::XS;

$SIG{__WARN__} = sub { die @_,"   statement started at line ", 'Cursor'->lineof($::LASTSTATE), "
" } if $::DEBUG;

## method postprocess ($s)
sub postprocess {
no warnings 'recursion';
my $self = shift;
die 'Required argument s omitted' unless @_;
my $s = @_ ? shift() : undef;
$s }  1; };
{ package STD::Q::ww1;
use Moose::Role ':all' => { -prefix => "moose_" };
use Encode;
our $ALLROLES = { 'STD::Q::ww1', 1 };
our $REGEXES = {
ALL => [ qw// ],
};


no warnings 'qw', 'recursion';
my $retree;

$DB::deep = $DB::deep = 1000; # suppress used-once warning

use YAML::XS;

$SIG{__WARN__} = sub { die @_,"   statement started at line ", 'Cursor'->lineof($::LASTSTATE), "
" } if $::DEBUG;

## method postprocess ($s)
sub postprocess {
no warnings 'recursion';
my $self = shift;
die 'Required argument s omitted' unless @_;
my $s = @_ ? shift() : undef;
$s->words }  1; };
{ package STD::Q::ww0;
use Moose::Role ':all' => { -prefix => "moose_" };
use Encode;
our $ALLROLES = { 'STD::Q::ww0', 1 };
our $REGEXES = {
ALL => [ qw// ],
};


no warnings 'qw', 'recursion';
my $retree;

$DB::deep = $DB::deep = 1000; # suppress used-once warning

use YAML::XS;

$SIG{__WARN__} = sub { die @_,"   statement started at line ", 'Cursor'->lineof($::LASTSTATE), "
" } if $::DEBUG;

## method postprocess ($s)
sub postprocess {
no warnings 'recursion';
my $self = shift;
die 'Required argument s omitted' unless @_;
my $s = @_ ? shift() : undef;
$s }  1; };
{ package STD::Q::x1;
use Moose::Role ':all' => { -prefix => "moose_" };
use Encode;
our $ALLROLES = { 'STD::Q::x1', 1 };
our $REGEXES = {
ALL => [ qw// ],
};


no warnings 'qw', 'recursion';
my $retree;

$DB::deep = $DB::deep = 1000; # suppress used-once warning

use YAML::XS;

$SIG{__WARN__} = sub { die @_,"   statement started at line ", 'Cursor'->lineof($::LASTSTATE), "
" } if $::DEBUG;

## method postprocess ($s)
sub postprocess {
no warnings 'recursion';
my $self = shift;
die 'Required argument s omitted' unless @_;
my $s = @_ ? shift() : undef;
$s->run }  1; };
{ package STD::Q::x0;
use Moose::Role ':all' => { -prefix => "moose_" };
use Encode;
our $ALLROLES = { 'STD::Q::x0', 1 };
our $REGEXES = {
ALL => [ qw// ],
};


no warnings 'qw', 'recursion';
my $retree;

$DB::deep = $DB::deep = 1000; # suppress used-once warning

use YAML::XS;

$SIG{__WARN__} = sub { die @_,"   statement started at line ", 'Cursor'->lineof($::LASTSTATE), "
" } if $::DEBUG;

## method postprocess ($s)
sub postprocess {
no warnings 'recursion';
my $self = shift;
die 'Required argument s omitted' unless @_;
my $s = @_ ? shift() : undef;
$s }  1; };
{ package STD::Q::q;
use Moose::Role ':all' => { -prefix => "moose_" };
use Encode;
our $ALLROLES = { 'STD::Q::q', 1 };
our $REGEXES = {
ALL => [ qw/backslash escape stopper/ ],
backslash => [ qw/backslash__S_001qq__PEEK backslash__S_002Back__PEEK backslash__S_003stopper__PEEK backslash__S_004misc__PEEK/ ],
escape => [ qw/escape__S_000Back__PEEK/ ],
};


no warnings 'qw', 'recursion';
my $retree;

$DB::deep = $DB::deep = 1000; # suppress used-once warning

use YAML::XS;

$SIG{__WARN__} = sub { die @_,"   statement started at line ", 'Cursor'->lineof($::LASTSTATE), "
" } if $::DEBUG;

$retree = YAML::XS::Load(Encode::encode_utf8(<<'RETREE_END'));
---
backslash__S_001qq: !!perl/hash:RE_ast
  dba: backslash
  dic: STD::Q::q
  re: !!perl/hash:RE_sequence
    zyg:
    - !!perl/hash:RE_assertion
      assert: '?'
      re: !!perl/hash:RE_method_re
        name: before
        nobind: 1
        re: !!perl/hash:RE_string
          i: 0
          text: q
    - !!perl/hash:RE_block {}
backslash__S_002Back: !!perl/hash:RE_ast
  dba: backslash
  dic: STD::Q::q
  re: !!perl/hash:RE_bindnamed
    atom: !!perl/hash:RE_method
      i: 0
      name: sym
      rest: ''
      sym: \
backslash__S_003stopper: !!perl/hash:RE_ast
  dba: backslash
  dic: STD::Q::q
  re: !!perl/hash:RE_bindnamed
    atom: !!perl/hash:RE_method
      name: stopper
      rest: ''
backslash__S_004misc: !!perl/hash:RE_ast
  dba: backslash
  dic: STD::Q::q
  re: !!perl/hash:RE_sequence
    zyg:
    - !!perl/hash:RE_block {}
    - !!perl/hash:RE_bindpos
      atom: !!perl/hash:RE_paren
        re: !!perl/hash:RE_meta
          min: 1
          text: .
    - !!perl/hash:RE_block {}
escape__S_000Back: !!perl/hash:RE_ast
  dba: escape
  dic: STD::Q::q
  re: !!perl/hash:RE_sequence
    zyg:
    - !!perl/hash:RE_method
      i: 0
      name: sym
      rest: ''
      sym: \
    - !!perl/hash:RE_bindnamed
      atom: !!perl/hash:RE_method
        name: backslash
        rest: ''
stopper: !!perl/hash:RE_ast
  dba: stopper
  dic: STD::Q::q
  re: !!perl/hash:RE_meta
    min: 1
    text: \'
RETREE_END
## token stopper { \' }
sub stopper__PEEK { $_[0]->_AUTOLEXpeek('stopper', $retree) }
sub stopper {
no warnings 'recursion';
my $self = shift;


local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;

my $C = $self->cursor_xact("RULE stopper");
my $xact = $C->xact;
my $S = $C->{'_pos'};
$self->_MATCHIFYr($S, "stopper", $C->_EXACT("\'"));
}
;
## token escape:sym<\\> { <sym> <item=.backslash> }
sub escape__S_000Back__PEEK { $_[0]->_AUTOLEXpeek('escape__S_000Back', $retree) }
sub escape__S_000Back {
no warnings 'recursion';
my $self = shift;


local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;

my $C = $self->cursor_xact("RULE escape__S_000Back");
my $xact = $C->xact;
my $S = $C->{'_pos'};
$C->{sym} = "\\";
$self->_MATCHIFYr($S, "escape__S_000Back", do {
if (my ($C) = ($C->_EXACT("\\"))) {
$C->_SUBSUMEr(['item'], sub {
my $C = shift;
$C->backslash
})
} else { () }

});
}
;
## token backslash:qq { <?before 'q'> { $<quote> = $¢.cursor_fresh(%*LANG<MAIN>).quote(); } }
sub backslash__S_001qq__PEEK { $_[0]->_AUTOLEXpeek('backslash__S_001qq', $retree) }
sub backslash__S_001qq {
no warnings 'recursion';
my $self = shift;


local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;

my $C = $self->cursor_xact("RULE backslash__S_001qq");
my $xact = $C->xact;
my $S = $C->{'_pos'};
$C->{sym} = "qq";
$self->_MATCHIFYr($S, "backslash__S_001qq", do {
if (my ($C) = ($C->before(sub {
my $C=shift;
if (my ($C) = ($C->before(sub {
my $C=shift;
$C->_EXACT("q")
}))) { ($C) } else { () }
}))) {
scalar(do {
my $M = $C;
$M->{'quote'} = $C->cursor_fresh($::LANG{'MAIN'})->quote()}, $C)
} else { () }

});
}
;
## token backslash:sym<\\> { <text=.sym> }
sub backslash__S_002Back__PEEK { $_[0]->_AUTOLEXpeek('backslash__S_002Back', $retree) }
sub backslash__S_002Back {
no warnings 'recursion';
my $self = shift;


local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;

my $C = $self->cursor_xact("RULE backslash__S_002Back");
my $xact = $C->xact;
my $S = $C->{'_pos'};
$C->{sym} = "\\";
$self->_MATCHIFYr($S, "backslash__S_002Back", $C->_SUBSUMEr(['text'], sub {
my $C = shift;
$C->_EXACT("\\")
}));
}
;
## token backslash:stopper { <text=.stopper> }
sub backslash__S_003stopper__PEEK { $_[0]->_AUTOLEXpeek('backslash__S_003stopper', $retree) }
sub backslash__S_003stopper {
no warnings 'recursion';
my $self = shift;


local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;

my $C = $self->cursor_xact("RULE backslash__S_003stopper");
my $xact = $C->xact;
my $S = $C->{'_pos'};
$C->{sym} = "stopper";
$self->_MATCHIFYr($S, "backslash__S_003stopper", $C->_SUBSUMEr(['text'], sub {
my $C = shift;
$C->stopper
}));
}
;
## token backslash:misc { {} (.) { $<text> = "\\" ~ $0.Str; } }
sub backslash__S_004misc__PEEK { $_[0]->_AUTOLEXpeek('backslash__S_004misc', $retree) }
sub backslash__S_004misc {
no warnings 'recursion';
my $self = shift;


local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;

my $C = $self->cursor_xact("RULE backslash__S_004misc");
my $xact = $C->xact;
my $S = $C->{'_pos'};
$C->{sym} = "misc";
$self->_MATCHIFYr($S, "backslash__S_004misc", do {
my $C = $C;
if (($C) = (scalar(do {
}, $C))
and ($C) = ($C->_SUBSUMEr(['0'], sub {
my $C = shift;
$C->_PAREN( sub {
my $C=shift;
$C->cursor_incr()

})
}))) {
scalar(do {
my $M = $C;
$M->{'text'} = "\\" . $M->{0}->Str}, $C)
} else { () }

});
}
;
## method tweak (:single(:$q)!)
;
## method tweak (:double(:$qq)!)
;
## method tweak (:cclass(:$cc)!)
;
moose_around tweak  => sub {
my $orig = shift;
no warnings 'recursion';
{
local @_ = @_;
return scalar do { # work around #38809
my $self = shift;
my %args = @_;
last unless exists $args{single} || exists $args{q};
my $q = exists $args{single} ? delete $args{single} : exists $args{q} ? delete $args{q} : undef;
$self->panic("Too late for :q")     };
}
{
local @_ = @_;
return scalar do { # work around #38809
my $self = shift;
my %args = @_;
last unless exists $args{double} || exists $args{qq};
my $qq = exists $args{double} ? delete $args{double} : exists $args{qq} ? delete $args{qq} : undef;
$self->panic("Too late for :qq")     };
}
{
local @_ = @_;
return scalar do { # work around #38809
my $self = shift;
my %args = @_;
last unless exists $args{cclass} || exists $args{cc};
my $cc = exists $args{cclass} ? delete $args{cclass} : exists $args{cc} ? delete $args{cc} : undef;
$self->panic("Too late for :cc")     };
}
$orig->(@_);
};

1; };
{ package STD::Q::qq;
use Moose::Role ':all' => { -prefix => "moose_" };
use Encode;
moose_with('STD::Q::b1');
moose_with('STD::Q::c1');
moose_with('STD::Q::s1');
moose_with('STD::Q::a1');
moose_with('STD::Q::h1');
moose_with('STD::Q::f1');
our $REGEXES = {
ALL => [ qw/backslash stopper/ ],
backslash => [ qw/backslash__S_000misc__PEEK/ ],
};


no warnings 'qw', 'recursion';
my $retree;

$DB::deep = $DB::deep = 1000; # suppress used-once warning

use YAML::XS;

$SIG{__WARN__} = sub { die @_,"   statement started at line ", 'Cursor'->lineof($::LASTSTATE), "
" } if $::DEBUG;

$retree = YAML::XS::Load(Encode::encode_utf8(<<'RETREE_END'));
---
backslash__S_000misc: !!perl/hash:RE_ast
  dba: backslash
  dic: STD::Q::qq
  re: !!perl/hash:RE_sequence
    zyg:
    - !!perl/hash:RE_block {}
    - !!perl/hash:RE_bracket
      re: &1 !!perl/hash:RE_any
        altname: backslash__S_000misc_0
        dba: backslash
        dic: STD::Q::qq
        zyg:
        - !!perl/hash:RE_sequence
          alt: backslash__S_000misc_0 0
          zyg:
          - !!perl/hash:RE_bindpos
            atom: !!perl/hash:RE_paren
              re: !!perl/hash:RE_meta
                min: 1
                text: \W
          - !!perl/hash:RE_block {}
        - !!perl/hash:RE_sequence
          alt: backslash__S_000misc_0 1
          zyg:
          - !!perl/hash:RE_bindnamed
            atom: !!perl/hash:RE_paren
              re: !!perl/hash:RE_meta
                min: 1
                text: \w
          - !!perl/hash:RE_method
            name: sorry
            rest: 1
backslash__S_000misc_0: *1
stopper: !!perl/hash:RE_ast
  dba: stopper
  dic: STD::Q::qq
  re: !!perl/hash:RE_meta
    min: 1
    text: \"
RETREE_END
## token stopper { \" }
sub stopper__PEEK { $_[0]->_AUTOLEXpeek('stopper', $retree) }
sub stopper {
no warnings 'recursion';
my $self = shift;


local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;

my $C = $self->cursor_xact("RULE stopper");
my $xact = $C->xact;
my $S = $C->{'_pos'};
$self->_MATCHIFYr($S, "stopper", $C->_EXACT("\""));
}
;
## token backslash:misc { {} [ (\W) { $<text> = $0.Str; } | $<x>=(\w) <.sorry("Unrecognized backslash s
sub backslash__S_000misc__PEEK { $_[0]->_AUTOLEXpeek('backslash__S_000misc', $retree) }
sub backslash__S_000misc {
no warnings 'recursion';
my $self = shift;


local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;

my $C = $self->cursor_xact("RULE backslash__S_000misc");
my $xact = $C->xact;
my $S = $C->{'_pos'};
$C->{sym} = "misc";
$self->_MATCHIFYr($S, "backslash__S_000misc", do {
my $C = $C;
if (($C) = (scalar(do {
}, $C))
and ($C) = ($C->_BRACKETr(sub {
my $C=shift;
do {
my ($tag, $try);
my @try;
my $relex;

my $fate;
my $x;
if ($fate = $C->{'_fate'} and $fate->[1] eq 'backslash__S_000misc_0') {
$C->deb("Fate passed to backslash__S_000misc_0: ", ::fatestr($fate)) if $::DEBUG & DEBUG::fates;
($C->{'_fate'}, $tag, $try) = @$fate;
@try = ($try);
$x = 'ALT backslash__S_000misc_0';    # some outer ltm is controlling us
}
else {
$x = 'ALTLTM backslash__S_000misc_0'; # we are top level ltm
}
my $C = $C->cursor_xact($x);
my $xact = $C->{_xact};

my @gather = ();
for (;;) {
unless (@try) {
$relex //= $C->cursor_fate('STD::Q::qq', 'backslash__S_000misc_0', $retree);
@try = $relex->($C) or last;
}
$try = shift(@try) // next;

if (ref $try) {
($C->{'_fate'}, $tag, $try) = @$try;   # next candidate fate
}

$C->deb("backslash__S_000misc_0 trying $tag $try") if $::DEBUG & DEBUG::try_processing;
push @gather, ((
sub {
my $C=shift;
if (my ($C) = ($C->_SUBSUMEr(['0'], sub {
my $C = shift;
$C->_PAREN( sub {
my $C=shift;
$C->_PATTERN(qr/\G\W/)

})
}))) {
scalar(do {
my $M = $C;
$M->{'text'} = $M->{0}->Str}, $C)
} else { () }
},
sub {
my $C=shift;
if (($C) = ($C->_SUBSUMEr(['x'], sub {
my $C = shift;
$C->_PAREN( sub {
my $C=shift;
$C->_PATTERN(qr/\G\w/)

})
}))
and ($C) = (do {
my $M = $C;
$C->sorry("Unrecognized backslash sequence: '\\" . $M->{'x'}->Str . "'")
})) {
$C
} else { () }
}
)[$try])->($C);
last if @gather;
last if $xact->[-2];  # committed?
}
@gather;
};
}))) {
$C
} else { () }

});
}
;
## method tweak (:single(:$q)!)
;
## method tweak (:double(:$qq)!)
;
## method tweak (:cclass(:$cc)!)
;
moose_around tweak  => sub {
my $orig = shift;
no warnings 'recursion';
{
local @_ = @_;
return scalar do { # work around #38809
my $self = shift;
my %args = @_;
last unless exists $args{single} || exists $args{q};
my $q = exists $args{single} ? delete $args{single} : exists $args{q} ? delete $args{q} : undef;
$self->panic("Too late for :q")     };
}
{
local @_ = @_;
return scalar do { # work around #38809
my $self = shift;
my %args = @_;
last unless exists $args{double} || exists $args{qq};
my $qq = exists $args{double} ? delete $args{double} : exists $args{qq} ? delete $args{qq} : undef;
$self->panic("Too late for :qq")     };
}
{
local @_ = @_;
return scalar do { # work around #38809
my $self = shift;
my %args = @_;
last unless exists $args{cclass} || exists $args{cc};
my $cc = exists $args{cclass} ? delete $args{cclass} : exists $args{cc} ? delete $args{cc} : undef;
$self->panic("Too late for :cc")     };
}
$orig->(@_);
};

1; };
{ package STD::Q::cc;
use Moose::Role ':all' => { -prefix => "moose_" };
use Encode;
our $ALLROLES = { 'STD::Q::cc', 1 };
our $REGEXES = {
ALL => [ qw/backslash escape stopper/ ],
backslash => [ qw/backslash__S_006stopper__PEEK backslash__S_007a__PEEK backslash__S_008b__PEEK backslash__S_009c__PEEK backslash__S_010d__PEEK backslash__S_011e__PEEK backslash__S_012f__PEEK backslash__S_013h__PEEK backslash__S_014n__PEEK backslash__S_015o__PEEK backslash__S_016r__PEEK backslash__S_017s__PEEK backslash__S_018t__PEEK backslash__S_019v__PEEK backslash__S_020w__PEEK backslash__S_021x__PEEK backslash__S_0220__PEEK backslash__S_023misc__PEEK/ ],
escape => [ qw/escape__S_000ws__PEEK escape__S_001Sharp__PEEK escape__S_002Back__PEEK escape__S_003DotDot__PEEK escape__S_004Minus__PEEK escape__S_005ch__PEEK/ ],
};


no warnings 'qw', 'recursion';
my $retree;

$DB::deep = $DB::deep = 1000; # suppress used-once warning

use YAML::XS;

$SIG{__WARN__} = sub { die @_,"   statement started at line ", 'Cursor'->lineof($::LASTSTATE), "
" } if $::DEBUG;

$retree = YAML::XS::Load(Encode::encode_utf8(<<'RETREE_END'));
---
backslash__S_006stopper: !!perl/hash:RE_ast
  dba: backslash
  dic: STD::Q::cc
  re: !!perl/hash:RE_bindnamed
    atom: !!perl/hash:RE_method
      name: stopper
      rest: ''
backslash__S_007a: !!perl/hash:RE_ast
  dba: backslash
  dic: STD::Q::cc
  re: !!perl/hash:RE_method
    i: 1
    name: sym
    rest: ''
    sym: a
backslash__S_008b: !!perl/hash:RE_ast
  dba: backslash
  dic: STD::Q::cc
  re: !!perl/hash:RE_method
    i: 1
    name: sym
    rest: ''
    sym: b
backslash__S_009c: !!perl/hash:RE_ast
  dba: backslash
  dic: STD::Q::cc
  re: !!perl/hash:RE_sequence
    zyg:
    - !!perl/hash:RE_method
      i: 1
      name: sym
      rest: ''
      sym: c
    - !!perl/hash:RE_method
      name: charspec
      rest: ''
backslash__S_010d: !!perl/hash:RE_ast
  dba: backslash
  dic: STD::Q::cc
  re: !!perl/hash:RE_sequence
    zyg:
    - !!perl/hash:RE_method
      i: 1
      name: sym
      rest: ''
      sym: d
    - !!perl/hash:RE_block {}
backslash__S_011e: !!perl/hash:RE_ast
  dba: backslash
  dic: STD::Q::cc
  re: !!perl/hash:RE_method
    i: 1
    name: sym
    rest: ''
    sym: e
backslash__S_012f: !!perl/hash:RE_ast
  dba: backslash
  dic: STD::Q::cc
  re: !!perl/hash:RE_method
    i: 1
    name: sym
    rest: ''
    sym: f
backslash__S_013h: !!perl/hash:RE_ast
  dba: backslash
  dic: STD::Q::cc
  re: !!perl/hash:RE_sequence
    zyg:
    - !!perl/hash:RE_method
      i: 1
      name: sym
      rest: ''
      sym: h
    - !!perl/hash:RE_block {}
backslash__S_014n: !!perl/hash:RE_ast
  dba: backslash
  dic: STD::Q::cc
  re: !!perl/hash:RE_method
    i: 1
    name: sym
    rest: ''
    sym: n
backslash__S_015o: !!perl/hash:RE_ast
  dba: octal character
  dic: STD::Q::cc
  re: !!perl/hash:RE_sequence
    zyg:
    - !!perl/hash:RE_method
      i: 1
      name: sym
      rest: ''
      sym: o
    - !!perl/hash:RE_bracket
      re: &1 !!perl/hash:RE_any
        altname: backslash__S_015o_0
        dba: octal character
        dic: STD::Q::cc
        zyg:
        - !!perl/hash:RE_method
          alt: backslash__S_015o_0 0
          name: octint
          rest: ''
        - !!perl/hash:RE_bracket
          alt: backslash__S_015o_0 1
          re: !!perl/hash:RE_sequence
            zyg:
            - !!perl/hash:RE_string
              i: 1
              text: '['
            - !!perl/hash:RE_block {}
            - !!perl/hash:RE_method
              name: octints
              rest: ''
            - !!perl/hash:RE_bracket
              re: !!perl/hash:RE_first
                zyg:
                - !!perl/hash:RE_string
                  i: 1
                  text: ']'
                - !!perl/hash:RE_method
                  name: FAILGOAL
                  rest: 1
backslash__S_015o_0: *1
backslash__S_016r: !!perl/hash:RE_ast
  dba: backslash
  dic: STD::Q::cc
  re: !!perl/hash:RE_method
    i: 1
    name: sym
    rest: ''
    sym: r
backslash__S_017s: !!perl/hash:RE_ast
  dba: backslash
  dic: STD::Q::cc
  re: !!perl/hash:RE_sequence
    zyg:
    - !!perl/hash:RE_method
      i: 1
      name: sym
      rest: ''
      sym: s
    - !!perl/hash:RE_block {}
backslash__S_018t: !!perl/hash:RE_ast
  dba: backslash
  dic: STD::Q::cc
  re: !!perl/hash:RE_method
    i: 1
    name: sym
    rest: ''
    sym: t
backslash__S_019v: !!perl/hash:RE_ast
  dba: backslash
  dic: STD::Q::cc
  re: !!perl/hash:RE_sequence
    zyg:
    - !!perl/hash:RE_method
      i: 1
      name: sym
      rest: ''
      sym: v
    - !!perl/hash:RE_block {}
backslash__S_020w: !!perl/hash:RE_ast
  dba: backslash
  dic: STD::Q::cc
  re: !!perl/hash:RE_sequence
    zyg:
    - !!perl/hash:RE_method
      i: 1
      name: sym
      rest: ''
      sym: w
    - !!perl/hash:RE_block {}
backslash__S_021x: !!perl/hash:RE_ast
  dba: hex character
  dic: STD::Q::cc
  re: !!perl/hash:RE_sequence
    zyg:
    - !!perl/hash:RE_method
      i: 1
      name: sym
      rest: ''
      sym: x
    - !!perl/hash:RE_bracket
      re: &2 !!perl/hash:RE_any
        altname: backslash__S_021x_0
        dba: hex character
        dic: STD::Q::cc
        zyg:
        - !!perl/hash:RE_method
          alt: backslash__S_021x_0 0
          name: hexint
          rest: ''
        - !!perl/hash:RE_bracket
          alt: backslash__S_021x_0 1
          re: !!perl/hash:RE_sequence
            zyg:
            - !!perl/hash:RE_string
              i: 1
              text: '['
            - !!perl/hash:RE_block {}
            - !!perl/hash:RE_method
              name: hexints
              rest: ''
            - !!perl/hash:RE_bracket
              re: !!perl/hash:RE_first
                zyg:
                - !!perl/hash:RE_string
                  i: 1
                  text: ']'
                - !!perl/hash:RE_method
                  name: FAILGOAL
                  rest: 1
backslash__S_021x_0: *2
backslash__S_0220: !!perl/hash:RE_ast
  dba: backslash
  dic: STD::Q::cc
  re: !!perl/hash:RE_method
    i: 0
    name: sym
    rest: ''
    sym: '0'
backslash__S_023misc: !!perl/hash:RE_ast
  dba: backslash
  dic: STD::Q::cc
  re: !!perl/hash:RE_sequence
    zyg:
    - !!perl/hash:RE_block {}
    - !!perl/hash:RE_bracket
      re: &3 !!perl/hash:RE_any
        altname: backslash__S_023misc_0
        dba: backslash
        dic: STD::Q::cc
        zyg:
        - !!perl/hash:RE_sequence
          alt: backslash__S_023misc_0 0
          zyg:
          - !!perl/hash:RE_bindpos
            atom: !!perl/hash:RE_paren
              re: !!perl/hash:RE_meta
                min: 1
                text: \W
          - !!perl/hash:RE_block {}
        - !!perl/hash:RE_sequence
          alt: backslash__S_023misc_0 1
          zyg:
          - !!perl/hash:RE_bindnamed
            atom: !!perl/hash:RE_paren
              re: !!perl/hash:RE_meta
                min: 1
                text: \w
          - !!perl/hash:RE_method
            name: sorry
            rest: 1
backslash__S_023misc_0: *3
escape__S_000ws: !!perl/hash:RE_ast
  dba: escape
  dic: STD::Q::cc
  re: !!perl/hash:RE_sequence
    zyg:
    - !!perl/hash:RE_quantified_atom
      atom: !!perl/hash:RE_meta
        min: 1
        text: \s
      quant:
      - +
    - !!perl/hash:RE_quantified_atom
      atom: !!perl/hash:RE_bracket
        re: !!perl/hash:RE_sequence
          zyg:
          - !!perl/hash:RE_assertion
            assert: '?'
            re: !!perl/hash:RE_method_re
              name: before
              nobind: 1
              re: !!perl/hash:RE_string
                i: 0
                text: '#'
          - !!perl/hash:RE_method
            name: ws
            rest: ''
      quant:
      - '?'
escape__S_001Sharp: !!perl/hash:RE_ast
  dba: escape
  dic: STD::Q::cc
  re: !!perl/hash:RE_sequence
    zyg:
    - !!perl/hash:RE_string
      i: 0
      text: '#'
    - !!perl/hash:RE_method
      name: panic
      rest: 1
escape__S_002Back: !!perl/hash:RE_ast
  dba: escape
  dic: STD::Q::cc
  re: !!perl/hash:RE_sequence
    zyg:
    - !!perl/hash:RE_method
      i: 0
      name: sym
      rest: ''
      sym: \
    - !!perl/hash:RE_bindnamed
      atom: !!perl/hash:RE_method
        name: backslash
        rest: ''
    - !!perl/hash:RE_method
      name: ccstate
      rest: 1
escape__S_003DotDot: !!perl/hash:RE_ast
  dba: escape
  dic: STD::Q::cc
  re: !!perl/hash:RE_sequence
    zyg:
    - !!perl/hash:RE_method
      i: 0
      name: sym
      rest: ''
      sym: ..
    - !!perl/hash:RE_bracket
      re: !!perl/hash:RE_first
        zyg:
        - !!perl/hash:RE_sequence
          zyg:
          - !!perl/hash:RE_assertion
            assert: '?'
            re: !!perl/hash:RE_block
              nobind: 1
          - !!perl/hash:RE_method
            name: sorry
            rest: 1
        - !!perl/hash:RE_assertion
          assert: '?'
          re: !!perl/hash:RE_method_re
            name: before
            nobind: 1
            re: !!perl/hash:RE_sequence
              zyg:
              - !!perl/hash:RE_quantified_atom
                atom: !!perl/hash:RE_meta
                  min: 1
                  text: \s
                quant:
                - '*'
              - !!perl/hash:RE_assertion
                assert: '!'
                re: !!perl/hash:RE_method
                  name: stopper
                  rest: ''
              - !!perl/hash:RE_assertion
                assert: '!'
                re: !!perl/hash:RE_method_re
                  name: before
                  nobind: 1
                  re: !!perl/hash:RE_string
                    i: 0
                    text: ..
              - !!perl/hash:RE_meta
                min: 1
                text: \S
        - !!perl/hash:RE_method
          name: sorry
          rest: 1
    - !!perl/hash:RE_block {}
escape__S_004Minus: !!perl/hash:RE_ast
  dba: escape
  dic: STD::Q::cc
  re: !!perl/hash:RE_sequence
    zyg:
    - !!perl/hash:RE_string
      i: 0
      text: '-'
    - !!perl/hash:RE_assertion
      assert: '?'
      re: !!perl/hash:RE_block
        nobind: 1
    - !!perl/hash:RE_quantified_atom
      atom: !!perl/hash:RE_meta
        min: 1
        text: \s
      quant:
      - '*'
    - !!perl/hash:RE_assertion
      assert: '!'
      re: !!perl/hash:RE_method
        name: stopper
        rest: ''
    - !!perl/hash:RE_meta
      min: 1
      text: \S
    - !!perl/hash:RE_method
      name: obs
      rest: 1
escape__S_005ch: !!perl/hash:RE_ast
  dba: escape
  dic: STD::Q::cc
  re: !!perl/hash:RE_sequence
    zyg:
    - !!perl/hash:RE_bindnamed
      atom: !!perl/hash:RE_bracket
        re: !!perl/hash:RE_meta
          min: 1
          text: \S
    - !!perl/hash:RE_method
      name: ccstate
      rest: 1
stopper: !!perl/hash:RE_ast
  dba: stopper
  dic: STD::Q::cc
  re: !!perl/hash:RE_meta
    min: 1
    text: \'
RETREE_END
## token stopper { \' }
sub stopper__PEEK { $_[0]->_AUTOLEXpeek('stopper', $retree) }
sub stopper {
no warnings 'recursion';
my $self = shift;


local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;

my $C = $self->cursor_xact("RULE stopper");
my $xact = $C->xact;
my $S = $C->{'_pos'};
$self->_MATCHIFYr($S, "stopper", $C->_EXACT("\'"));
}
;
## method ccstate ($s)
sub ccstate {
no warnings 'recursion';
my $self = shift;
die 'Required argument s omitted' unless @_;
my $s = @_ ? shift() : undef;
if ($::CCSTATE eq '..') {
$::CCSTATE = ''}
else {
$::CCSTATE = $s};
$self;
};
## token escape:ws { \s+ [ <?before '#'> <.ws> ]? }
sub escape__S_000ws__PEEK { $_[0]->_AUTOLEXpeek('escape__S_000ws', $retree) }
sub escape__S_000ws {
no warnings 'recursion';
my $self = shift;


local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;

my $C = $self->cursor_xact("RULE escape__S_000ws");
my $xact = $C->xact;
my $S = $C->{'_pos'};
$C->{sym} = "ws";
$self->_MATCHIFYr($S, "escape__S_000ws", do {
if (my ($C) = ($C->_PATTERN(qr/\G\s++/))) {
$C->_OPTr(sub {
my $C=shift;
if (my ($C) = ($C->_BRACKETr(sub {
my $C=shift;
if (($C) = ($C->before(sub {
my $C=shift;
if (my ($C) = ($C->before(sub {
my $C=shift;
$C->_EXACT("\#")
}))) { ($C) } else { () }
}))
and ($C) = ($C->ws)) {
$C
} else { () }
}))) { ($C) } else { () }
})
} else { () }

});
}
;
## token escape:sym<#> { '#' <.panic: "Please backslash # for literal char or put whitespace in front f
sub escape__S_001Sharp__PEEK { $_[0]->_AUTOLEXpeek('escape__S_001Sharp', $retree) }
sub escape__S_001Sharp {
no warnings 'recursion';
my $self = shift;


local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;

my $C = $self->cursor_xact("RULE escape__S_001Sharp");
my $xact = $C->xact;
my $S = $C->{'_pos'};
$C->{sym} = "\#";
$self->_MATCHIFYr($S, "escape__S_001Sharp", do {
my $C = $C;
if (($C) = ($C->_EXACT("\#"))
and ($C) = ($C->panic("Please backslash # for literal char or put whitespace in front for comment"))) {
$C
} else { () }

});
}
;
## token escape:sym<\\> { <sym> <item=.backslash>  <.ccstate('\\' ~ $<item>.Str)> }
sub escape__S_002Back__PEEK { $_[0]->_AUTOLEXpeek('escape__S_002Back', $retree) }
sub escape__S_002Back {
no warnings 'recursion';
my $self = shift;


local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;

my $C = $self->cursor_xact("RULE escape__S_002Back");
my $xact = $C->xact;
my $S = $C->{'_pos'};
$C->{sym} = "\\";
$self->_MATCHIFYr($S, "escape__S_002Back", do {
my $C = $C;
if (($C) = ($C->_EXACT("\\"))
and ($C) = ($C->_SUBSUMEr(['item'], sub {
my $C = shift;
$C->backslash
}))
and ($C) = (do {
my $M = $C;
$C->ccstate('\\' . $M->{'item'}->Str)
})) {
$C
} else { () }

});
}
;
## token escape:sym<..> { <sym>
sub escape__S_003DotDot__PEEK { $_[0]->_AUTOLEXpeek('escape__S_003DotDot', $retree) }
sub escape__S_003DotDot {
no warnings 'recursion';
my $self = shift;


local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;

my $C = $self->cursor_xact("RULE escape__S_003DotDot");
my $xact = $C->xact;
my $S = $C->{'_pos'};
$C->{sym} = "\.\.";
$self->_MATCHIFYr($S, "escape__S_003DotDot", do {
my $C = $C;
if (($C) = ($C->_EXACT("\.\."))
and ($C) = ($C->_BRACKETr(sub {
my $C=shift;
do {    my $C = $C->cursor_xact('ALT ||');
my $xact = $C->xact;
my @gather;
do {
push @gather, do {
my $C = $C;
if (($C) = ($C->before(sub {
my $C=shift;
(($C) x !!do {
$::CCSTATE eq '' or $::CCSTATE eq '..' })
}))
and ($C) = ($C->sorry("Range missing start character on the left"))) {
$C
} else { () }

}
}
or $xact->[-2] or
do {
push @gather, do {
if (my ($C) = ($C->before(sub {
my $C=shift;
if (my ($C) = ($C->before(sub {
my $C=shift;
do {
my $C = $C;
if (($C) = ($C->_PATTERN(qr/\G\s*+/))
and ($C) = ($C->_NOTBEFORE(sub {
my $C=shift;
if (my ($C) = ($C->stopper)) { ($C) } else { () }
}))
and ($C) = ($C->_NOTBEFORE(sub {
my $C=shift;
if (my ($C) = ($C->before(sub {
my $C=shift;
$C->_EXACT("\.\.")
}))) { ($C) } else { () }
}))) {
$C->_PATTERN(qr/\G\S/)
} else { () }
};
}))) { ($C) } else { () }
}))) { ($C) } else { () }

}
}
or $xact->[-2] or
do {
push @gather, do {
if (my ($C) = ($C->sorry("Range missing stop character on the right"))) { ($C) } else { () }

}
};
@gather;
}
}))) {
scalar(do {
$::CCSTATE = '..'}, $C)
} else { () }

});
}
;
## token escape:sym<-> { '-' <?{ $*CCSTATE ne '' }> \s* <!stopper> \S <.obs('- as character range','..'
sub escape__S_004Minus__PEEK { $_[0]->_AUTOLEXpeek('escape__S_004Minus', $retree) }
sub escape__S_004Minus {
no warnings 'recursion';
my $self = shift;


local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;

my $C = $self->cursor_xact("RULE escape__S_004Minus");
my $xact = $C->xact;
my $S = $C->{'_pos'};
$C->{sym} = "\-";
$self->_MATCHIFYr($S, "escape__S_004Minus", do {
my $C = $C;
if (($C) = ($C->_EXACT("\-"))
and ($C) = ($C->before(sub {
my $C=shift;
(($C) x !!do {
$::CCSTATE ne '' })
}))
and ($C) = ($C->_PATTERN(qr/\G\s*+/))
and ($C) = ($C->_NOTBEFORE(sub {
my $C=shift;
if (my ($C) = ($C->stopper)) { ($C) } else { () }
}))
and ($C) = ($C->_PATTERN(qr/\G\S/))
and ($C) = ($C->obs('- as character range','..'))) {
$C
} else { () }

});
}
;
## token escape:ch { $<ch> = [\S] <.ccstate($<ch>.Str)> }
sub escape__S_005ch__PEEK { $_[0]->_AUTOLEXpeek('escape__S_005ch', $retree) }
sub escape__S_005ch {
no warnings 'recursion';
my $self = shift;


local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;

my $C = $self->cursor_xact("RULE escape__S_005ch");
my $xact = $C->xact;
my $S = $C->{'_pos'};
$C->{sym} = "ch";
$self->_MATCHIFYr($S, "escape__S_005ch", do {
my $C = $C;
if (($C) = ($C->_SUBSUMEr(['ch'], sub {
my $C = shift;
$C->_BRACKETr(sub {
my $C=shift;
$C->_PATTERN(qr/\G\S/)
})
}))
and ($C) = (do {
my $M = $C;
$C->ccstate($M->{'ch'}->Str)
})) {
$C
} else { () }

});
}
;
## token backslash:stopper { <text=.stopper> }
sub backslash__S_006stopper__PEEK { $_[0]->_AUTOLEXpeek('backslash__S_006stopper', $retree) }
sub backslash__S_006stopper {
no warnings 'recursion';
my $self = shift;


local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;

my $C = $self->cursor_xact("RULE backslash__S_006stopper");
my $xact = $C->xact;
my $S = $C->{'_pos'};
$C->{sym} = "stopper";
$self->_MATCHIFYr($S, "backslash__S_006stopper", $C->_SUBSUMEr(['text'], sub {
my $C = shift;
$C->stopper
}));
}
;
## token backslash:a { :i <sym> }
sub backslash__S_007a__PEEK { $_[0]->_AUTOLEXpeek('backslash__S_007a', $retree) }
sub backslash__S_007a {
no warnings 'recursion';
my $self = shift;


local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;

my $C = $self->cursor_xact("RULE backslash__S_007a");
my $xact = $C->xact;
my $S = $C->{'_pos'};
$C->{sym} = "a";
$self->_MATCHIFYr($S, "backslash__S_007a", $C->_PATTERN(qr/\G(?i:a)/));
}
;
## token backslash:b { :i <sym> }
sub backslash__S_008b__PEEK { $_[0]->_AUTOLEXpeek('backslash__S_008b', $retree) }
sub backslash__S_008b {
no warnings 'recursion';
my $self = shift;


local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;

my $C = $self->cursor_xact("RULE backslash__S_008b");
my $xact = $C->xact;
my $S = $C->{'_pos'};
$C->{sym} = "b";
$self->_MATCHIFYr($S, "backslash__S_008b", $C->_PATTERN(qr/\G(?i:b)/));
}
;
## token backslash:c { :i <sym> <charspec> }
sub backslash__S_009c__PEEK { $_[0]->_AUTOLEXpeek('backslash__S_009c', $retree) }
sub backslash__S_009c {
no warnings 'recursion';
my $self = shift;


local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;

my $C = $self->cursor_xact("RULE backslash__S_009c");
my $xact = $C->xact;
my $S = $C->{'_pos'};
$C->{sym} = "c";
$self->_MATCHIFYr($S, "backslash__S_009c", do {
if (my ($C) = ($C->_PATTERN(qr/\G(?i:c)/))) {
$C->_SUBSUMEr(['charspec'], sub {
my $C = shift;
$C->charspec
})
} else { () }

});
}
;
## token backslash:d { :i <sym> { $*CCSTATE = '' } }
sub backslash__S_010d__PEEK { $_[0]->_AUTOLEXpeek('backslash__S_010d', $retree) }
sub backslash__S_010d {
no warnings 'recursion';
my $self = shift;


local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;

my $C = $self->cursor_xact("RULE backslash__S_010d");
my $xact = $C->xact;
my $S = $C->{'_pos'};
$C->{sym} = "d";
$self->_MATCHIFYr($S, "backslash__S_010d", do {
if (my ($C) = ($C->_PATTERN(qr/\G(?i:d)/))) {
scalar(do {
$::CCSTATE = '' }, $C)
} else { () }

});
}
;
## token backslash:e { :i <sym> }
sub backslash__S_011e__PEEK { $_[0]->_AUTOLEXpeek('backslash__S_011e', $retree) }
sub backslash__S_011e {
no warnings 'recursion';
my $self = shift;


local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;

my $C = $self->cursor_xact("RULE backslash__S_011e");
my $xact = $C->xact;
my $S = $C->{'_pos'};
$C->{sym} = "e";
$self->_MATCHIFYr($S, "backslash__S_011e", $C->_PATTERN(qr/\G(?i:e)/));
}
;
## token backslash:f { :i <sym> }
sub backslash__S_012f__PEEK { $_[0]->_AUTOLEXpeek('backslash__S_012f', $retree) }
sub backslash__S_012f {
no warnings 'recursion';
my $self = shift;


local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;

my $C = $self->cursor_xact("RULE backslash__S_012f");
my $xact = $C->xact;
my $S = $C->{'_pos'};
$C->{sym} = "f";
$self->_MATCHIFYr($S, "backslash__S_012f", $C->_PATTERN(qr/\G(?i:f)/));
}
;
## token backslash:h { :i <sym> { $*CCSTATE = '' } }
sub backslash__S_013h__PEEK { $_[0]->_AUTOLEXpeek('backslash__S_013h', $retree) }
sub backslash__S_013h {
no warnings 'recursion';
my $self = shift;


local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;

my $C = $self->cursor_xact("RULE backslash__S_013h");
my $xact = $C->xact;
my $S = $C->{'_pos'};
$C->{sym} = "h";
$self->_MATCHIFYr($S, "backslash__S_013h", do {
if (my ($C) = ($C->_PATTERN(qr/\G(?i:h)/))) {
scalar(do {
$::CCSTATE = '' }, $C)
} else { () }

});
}
;
## token backslash:n { :i <sym> }
sub backslash__S_014n__PEEK { $_[0]->_AUTOLEXpeek('backslash__S_014n', $retree) }
sub backslash__S_014n {
no warnings 'recursion';
my $self = shift;


local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;

my $C = $self->cursor_xact("RULE backslash__S_014n");
my $xact = $C->xact;
my $S = $C->{'_pos'};
$C->{sym} = "n";
$self->_MATCHIFYr($S, "backslash__S_014n", $C->_PATTERN(qr/\G(?i:n)/));
}
;
## token backslash:o { :i :dba('octal character') <sym> [ <octint> | '[' ~ ']' <octints> ] }
sub backslash__S_015o__PEEK { $_[0]->_AUTOLEXpeek('backslash__S_015o', $retree) }
sub backslash__S_015o {
no warnings 'recursion';
my $self = shift;


local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;

my $C = $self->cursor_xact("RULE backslash__S_015o");
my $xact = $C->xact;
my $S = $C->{'_pos'};
$C->{sym} = "o";
$self->_MATCHIFYr($S, "backslash__S_015o", do {
my $C = $C;
if (($C) = ($C->_PATTERN(qr/\G(?i:o)/))
and ($C) = ($C->_BRACKETr(sub {
my $C=shift;
do {
my ($tag, $try);
my @try;
my $relex;

my $fate;
my $x;
if ($fate = $C->{'_fate'} and $fate->[1] eq 'backslash__S_015o_0') {
$C->deb("Fate passed to backslash__S_015o_0: ", ::fatestr($fate)) if $::DEBUG & DEBUG::fates;
($C->{'_fate'}, $tag, $try) = @$fate;
@try = ($try);
$x = 'ALT backslash__S_015o_0';    # some outer ltm is controlling us
}
else {
$x = 'ALTLTM backslash__S_015o_0'; # we are top level ltm
}
my $C = $C->cursor_xact($x);
my $xact = $C->{_xact};

my @gather = ();
for (;;) {
unless (@try) {
$relex //= $C->cursor_fate('STD::Q::cc', 'backslash__S_015o_0', $retree);
@try = $relex->($C) or last;
}
$try = shift(@try) // next;

if (ref $try) {
($C->{'_fate'}, $tag, $try) = @$try;   # next candidate fate
}

$C->deb("backslash__S_015o_0 trying $tag $try") if $::DEBUG & DEBUG::try_processing;
push @gather, ((
sub {
my $C=shift;
$C->_SUBSUMEr(['octint'], sub {
my $C = shift;
$C->octint
})
},
sub {
my $C=shift;
if (my ($C) = ($C->_BRACKETr(sub {
my $C=shift;
local $::GOAL = "\]";
my $goalpos = $C;
if (($C) = ($C->_PATTERN(qr/\G(?i:\[)/))
and ($C) = (scalar(do {
}, $C))
and ($C) = ($C->_SUBSUMEr(['octints'], sub {
my $C = shift;
$C->octints
}))
and ($C) = ($C->_BRACKETr(sub {
my $C=shift;
do {    my $C = $C->cursor_xact('ALT ||');
my $xact = $C->xact;
my @gather;
do {
push @gather, $C->_PATTERN(qr/\G(?i:\])/)
}
or $xact->[-2] or
do {
push @gather, do {
if (my ($C) = ($C->FAILGOAL($::GOAL, 'octal character', $goalpos))) { ($C) } else { () }

}
};
@gather;
}
}))) {
$C
} else { () }
}))) { ($C) } else { () }
}
)[$try])->($C);
last if @gather;
last if $xact->[-2];  # committed?
}
@gather;
};
}))) {
$C
} else { () }

});
}
;
## token backslash:r { :i <sym> }
sub backslash__S_016r__PEEK { $_[0]->_AUTOLEXpeek('backslash__S_016r', $retree) }
sub backslash__S_016r {
no warnings 'recursion';
my $self = shift;


local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;

my $C = $self->cursor_xact("RULE backslash__S_016r");
my $xact = $C->xact;
my $S = $C->{'_pos'};
$C->{sym} = "r";
$self->_MATCHIFYr($S, "backslash__S_016r", $C->_PATTERN(qr/\G(?i:r)/));
}
;
## token backslash:s { :i <sym> { $*CCSTATE = '' } }
sub backslash__S_017s__PEEK { $_[0]->_AUTOLEXpeek('backslash__S_017s', $retree) }
sub backslash__S_017s {
no warnings 'recursion';
my $self = shift;


local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;

my $C = $self->cursor_xact("RULE backslash__S_017s");
my $xact = $C->xact;
my $S = $C->{'_pos'};
$C->{sym} = "s";
$self->_MATCHIFYr($S, "backslash__S_017s", do {
if (my ($C) = ($C->_PATTERN(qr/\G(?i:s)/))) {
scalar(do {
$::CCSTATE = '' }, $C)
} else { () }

});
}
;
## token backslash:t { :i <sym> }
sub backslash__S_018t__PEEK { $_[0]->_AUTOLEXpeek('backslash__S_018t', $retree) }
sub backslash__S_018t {
no warnings 'recursion';
my $self = shift;


local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;

my $C = $self->cursor_xact("RULE backslash__S_018t");
my $xact = $C->xact;
my $S = $C->{'_pos'};
$C->{sym} = "t";
$self->_MATCHIFYr($S, "backslash__S_018t", $C->_PATTERN(qr/\G(?i:t)/));
}
;
## token backslash:v { :i <sym> { $*CCSTATE = '' } }
sub backslash__S_019v__PEEK { $_[0]->_AUTOLEXpeek('backslash__S_019v', $retree) }
sub backslash__S_019v {
no warnings 'recursion';
my $self = shift;


local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;

my $C = $self->cursor_xact("RULE backslash__S_019v");
my $xact = $C->xact;
my $S = $C->{'_pos'};
$C->{sym} = "v";
$self->_MATCHIFYr($S, "backslash__S_019v", do {
if (my ($C) = ($C->_PATTERN(qr/\G(?i:v)/))) {
scalar(do {
$::CCSTATE = '' }, $C)
} else { () }

});
}
;
## token backslash:w { :i <sym> { $*CCSTATE = '' } }
sub backslash__S_020w__PEEK { $_[0]->_AUTOLEXpeek('backslash__S_020w', $retree) }
sub backslash__S_020w {
no warnings 'recursion';
my $self = shift;


local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;

my $C = $self->cursor_xact("RULE backslash__S_020w");
my $xact = $C->xact;
my $S = $C->{'_pos'};
$C->{sym} = "w";
$self->_MATCHIFYr($S, "backslash__S_020w", do {
if (my ($C) = ($C->_PATTERN(qr/\G(?i:w)/))) {
scalar(do {
$::CCSTATE = '' }, $C)
} else { () }

});
}
;
## token backslash:x { :i :dba('hex character') <sym> [ <hexint> | '[' ~ ']' <hexints> ] }
sub backslash__S_021x__PEEK { $_[0]->_AUTOLEXpeek('backslash__S_021x', $retree) }
sub backslash__S_021x {
no warnings 'recursion';
my $self = shift;


local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;

my $C = $self->cursor_xact("RULE backslash__S_021x");
my $xact = $C->xact;
my $S = $C->{'_pos'};
$C->{sym} = "x";
$self->_MATCHIFYr($S, "backslash__S_021x", do {
my $C = $C;
if (($C) = ($C->_PATTERN(qr/\G(?i:x)/))
and ($C) = ($C->_BRACKETr(sub {
my $C=shift;
do {
my ($tag, $try);
my @try;
my $relex;

my $fate;
my $x;
if ($fate = $C->{'_fate'} and $fate->[1] eq 'backslash__S_021x_0') {
$C->deb("Fate passed to backslash__S_021x_0: ", ::fatestr($fate)) if $::DEBUG & DEBUG::fates;
($C->{'_fate'}, $tag, $try) = @$fate;
@try = ($try);
$x = 'ALT backslash__S_021x_0';    # some outer ltm is controlling us
}
else {
$x = 'ALTLTM backslash__S_021x_0'; # we are top level ltm
}
my $C = $C->cursor_xact($x);
my $xact = $C->{_xact};

my @gather = ();
for (;;) {
unless (@try) {
$relex //= $C->cursor_fate('STD::Q::cc', 'backslash__S_021x_0', $retree);
@try = $relex->($C) or last;
}
$try = shift(@try) // next;

if (ref $try) {
($C->{'_fate'}, $tag, $try) = @$try;   # next candidate fate
}

$C->deb("backslash__S_021x_0 trying $tag $try") if $::DEBUG & DEBUG::try_processing;
push @gather, ((
sub {
my $C=shift;
$C->_SUBSUMEr(['hexint'], sub {
my $C = shift;
$C->hexint
})
},
sub {
my $C=shift;
if (my ($C) = ($C->_BRACKETr(sub {
my $C=shift;
local $::GOAL = "\]";
my $goalpos = $C;
if (($C) = ($C->_PATTERN(qr/\G(?i:\[)/))
and ($C) = (scalar(do {
}, $C))
and ($C) = ($C->_SUBSUMEr(['hexints'], sub {
my $C = shift;
$C->hexints
}))
and ($C) = ($C->_BRACKETr(sub {
my $C=shift;
do {    my $C = $C->cursor_xact('ALT ||');
my $xact = $C->xact;
my @gather;
do {
push @gather, $C->_PATTERN(qr/\G(?i:\])/)
}
or $xact->[-2] or
do {
push @gather, do {
if (my ($C) = ($C->FAILGOAL($::GOAL, 'hex character', $goalpos))) { ($C) } else { () }

}
};
@gather;
}
}))) {
$C
} else { () }
}))) { ($C) } else { () }
}
)[$try])->($C);
last if @gather;
last if $xact->[-2];  # committed?
}
@gather;
};
}))) {
$C
} else { () }

});
}
;
## token backslash:sym<0> { <sym> }
sub backslash__S_0220__PEEK { $_[0]->_AUTOLEXpeek('backslash__S_0220', $retree) }
sub backslash__S_0220 {
no warnings 'recursion';
my $self = shift;


local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;

my $C = $self->cursor_xact("RULE backslash__S_0220");
my $xact = $C->xact;
my $S = $C->{'_pos'};
$self->_MATCHIFYr($S, "backslash__S_0220", $C->_EXACT("0"));
}
;
## token backslash:misc { {} [ (\W) { $<text> = $0.Str; } | $<x>=(\w) <.sorry("Unrecognized backslash s
sub backslash__S_023misc__PEEK { $_[0]->_AUTOLEXpeek('backslash__S_023misc', $retree) }
sub backslash__S_023misc {
no warnings 'recursion';
my $self = shift;


local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;

my $C = $self->cursor_xact("RULE backslash__S_023misc");
my $xact = $C->xact;
my $S = $C->{'_pos'};
$C->{sym} = "misc";
$self->_MATCHIFYr($S, "backslash__S_023misc", do {
my $C = $C;
if (($C) = (scalar(do {
}, $C))
and ($C) = ($C->_BRACKETr(sub {
my $C=shift;
do {
my ($tag, $try);
my @try;
my $relex;

my $fate;
my $x;
if ($fate = $C->{'_fate'} and $fate->[1] eq 'backslash__S_023misc_0') {
$C->deb("Fate passed to backslash__S_023misc_0: ", ::fatestr($fate)) if $::DEBUG & DEBUG::fates;
($C->{'_fate'}, $tag, $try) = @$fate;
@try = ($try);
$x = 'ALT backslash__S_023misc_0';    # some outer ltm is controlling us
}
else {
$x = 'ALTLTM backslash__S_023misc_0'; # we are top level ltm
}
my $C = $C->cursor_xact($x);
my $xact = $C->{_xact};

my @gather = ();
for (;;) {
unless (@try) {
$relex //= $C->cursor_fate('STD::Q::cc', 'backslash__S_023misc_0', $retree);
@try = $relex->($C) or last;
}
$try = shift(@try) // next;

if (ref $try) {
($C->{'_fate'}, $tag, $try) = @$try;   # next candidate fate
}

$C->deb("backslash__S_023misc_0 trying $tag $try") if $::DEBUG & DEBUG::try_processing;
push @gather, ((
sub {
my $C=shift;
if (my ($C) = ($C->_SUBSUMEr(['0'], sub {
my $C = shift;
$C->_PAREN( sub {
my $C=shift;
$C->_PATTERN(qr/\G\W/)

})
}))) {
scalar(do {
my $M = $C;
$M->{'text'} = $M->{0}->Str}, $C)
} else { () }
},
sub {
my $C=shift;
if (($C) = ($C->_SUBSUMEr(['x'], sub {
my $C = shift;
$C->_PAREN( sub {
my $C=shift;
$C->_PATTERN(qr/\G\w/)

})
}))
and ($C) = (do {
my $M = $C;
$C->sorry("Unrecognized backslash sequence: '\\" . $M->{'x'}->Str . "'")
})) {
$C
} else { () }
}
)[$try])->($C);
last if @gather;
last if $xact->[-2];  # committed?
}
@gather;
};
}))) {
$C
} else { () }

});
}
;
## method tweak (:single(:$q)!)
;
## method tweak (:double(:$qq)!)
;
## method tweak (:cclass(:$cc)!)
;
moose_around tweak  => sub {
my $orig = shift;
no warnings 'recursion';
{
local @_ = @_;
return scalar do { # work around #38809
my $self = shift;
my %args = @_;
last unless exists $args{single} || exists $args{q};
my $q = exists $args{single} ? delete $args{single} : exists $args{q} ? delete $args{q} : undef;
$self->panic("Too late for :q")     };
}
{
local @_ = @_;
return scalar do { # work around #38809
my $self = shift;
my %args = @_;
last unless exists $args{double} || exists $args{qq};
my $qq = exists $args{double} ? delete $args{double} : exists $args{qq} ? delete $args{qq} : undef;
$self->panic("Too late for :qq")     };
}
{
local @_ = @_;
return scalar do { # work around #38809
my $self = shift;
my %args = @_;
last unless exists $args{cclass} || exists $args{cc};
my $cc = exists $args{cclass} ? delete $args{cclass} : exists $args{cc} ? delete $args{cc} : undef;
$self->panic("Too late for :cc")     };
}
$orig->(@_);
};

1; };
{ package STD::Q::p5;
use Moose::Role ':all' => { -prefix => "moose_" };
use Encode;
our $ALLROLES = { 'STD::Q::p5', 1 };
our $REGEXES = {
ALL => [ qw// ],
};


no warnings 'qw', 'recursion';
my $retree;

$DB::deep = $DB::deep = 1000; # suppress used-once warning

use YAML::XS;

$SIG{__WARN__} = sub { die @_,"   statement started at line ", 'Cursor'->lineof($::LASTSTATE), "
" } if $::DEBUG;

## method tweak (:$g!)
;
## method tweak (:$i!)
;
## method tweak (:$m!)
;
## method tweak (:$s!)
;
## method tweak (:$x!)
;
## method tweak (:$p!)
;
## method tweak (:$c!)
;
moose_around tweak  => sub {
my $orig = shift;
no warnings 'recursion';
{
local @_ = @_;
return scalar do { # work around #38809
my $self = shift;
my %args = @_;
last unless exists $args{g};
my $g = exists $args{g} ? delete $args{g} : undef;
$self     };
}
{
local @_ = @_;
return scalar do { # work around #38809
my $self = shift;
my %args = @_;
last unless exists $args{i};
my $i = exists $args{i} ? delete $args{i} : undef;
$self     };
}
{
local @_ = @_;
return scalar do { # work around #38809
my $self = shift;
my %args = @_;
last unless exists $args{m};
my $m = exists $args{m} ? delete $args{m} : undef;
$self     };
}
{
local @_ = @_;
return scalar do { # work around #38809
my $self = shift;
my %args = @_;
last unless exists $args{s};
my $s = exists $args{s} ? delete $args{s} : undef;
$self     };
}
{
local @_ = @_;
return scalar do { # work around #38809
my $self = shift;
my %args = @_;
last unless exists $args{x};
my $x = exists $args{x} ? delete $args{x} : undef;
$self     };
}
{
local @_ = @_;
return scalar do { # work around #38809
my $self = shift;
my %args = @_;
last unless exists $args{p};
my $p = exists $args{p} ? delete $args{p} : undef;
$self     };
}
{
local @_ = @_;
return scalar do { # work around #38809
my $self = shift;
my %args = @_;
last unless exists $args{c};
my $c = exists $args{c} ? delete $args{c} : undef;
$self     };
}
$orig->(@_);
};

1; };
## method tweak (:single(:$q)!)
;
## method tweak (:double(:$qq)!)
;
## method tweak (:cclass(:$cc)!)
;
## method tweak (:backslash(:$b)!)
;
## method tweak (:scalar(:$s)!)
;
## method tweak (:array(:$a)!)
;
## method tweak (:hash(:$h)!)
;
## method tweak (:function(:$f)!)
;
## method tweak (:closure(:$c)!)
;
## method tweak (:path(:$p)!)
;
## method tweak (:exec(:$x)!)
;
## method tweak (:words(:$w)!)
;
## method tweak (:quotewords(:$ww)!)
;
## method tweak (:heredoc(:$to)!)
;
## method tweak (:$regex!)
;
## method tweak (*%x)
;
moose_around tweak  => sub {
my $orig = shift;
no warnings 'recursion';
{
local @_ = @_;
return scalar do { # work around #38809
my $self = shift;
my %args = @_;
last unless exists $args{single} || exists $args{q};
my $q = exists $args{single} ? delete $args{single} : exists $args{q} ? delete $args{q} : undef;
$self->truly($q,':q');
$self->mixin( 'STD::Q::q' );
};
}
{
local @_ = @_;
return scalar do { # work around #38809
my $self = shift;
my %args = @_;
last unless exists $args{double} || exists $args{qq};
my $qq = exists $args{double} ? delete $args{double} : exists $args{qq} ? delete $args{qq} : undef;
$self->truly($qq, ':qq');
$self->mixin( 'STD::Q::qq' );
};
}
{
local @_ = @_;
return scalar do { # work around #38809
my $self = shift;
my %args = @_;
last unless exists $args{cclass} || exists $args{cc};
my $cc = exists $args{cclass} ? delete $args{cclass} : exists $args{cc} ? delete $args{cc} : undef;
$self->truly($cc, ':cc');
$self->mixin( 'STD::Q::cc' );
};
}
{
local @_ = @_;
return scalar do { # work around #38809
my $self = shift;
my %args = @_;
last unless exists $args{backslash} || exists $args{b};
my $b = exists $args{backslash} ? delete $args{backslash} : exists $args{b} ? delete $args{b} : undef;
$self->mixin($b ? 'STD::Q::b1' : 'STD::Q::b0')     };
}
{
local @_ = @_;
return scalar do { # work around #38809
my $self = shift;
my %args = @_;
last unless exists $args{scalar} || exists $args{s};
my $s = exists $args{scalar} ? delete $args{scalar} : exists $args{s} ? delete $args{s} : undef;
$self->mixin($s ? 'STD::Q::s1' : 'STD::Q::s0')     };
}
{
local @_ = @_;
return scalar do { # work around #38809
my $self = shift;
my %args = @_;
last unless exists $args{array} || exists $args{a};
my $a = exists $args{array} ? delete $args{array} : exists $args{a} ? delete $args{a} : undef;
$self->mixin($a ? 'STD::Q::a1' : 'STD::Q::a0')     };
}
{
local @_ = @_;
return scalar do { # work around #38809
my $self = shift;
my %args = @_;
last unless exists $args{hash} || exists $args{h};
my $h = exists $args{hash} ? delete $args{hash} : exists $args{h} ? delete $args{h} : undef;
$self->mixin($h ? 'STD::Q::h1' : 'STD::Q::h0')     };
}
{
local @_ = @_;
return scalar do { # work around #38809
my $self = shift;
my %args = @_;
last unless exists $args{function} || exists $args{f};
my $f = exists $args{function} ? delete $args{function} : exists $args{f} ? delete $args{f} : undef;
$self->mixin($f ? 'STD::Q::f1' : 'STD::Q::f0')     };
}
{
local @_ = @_;
return scalar do { # work around #38809
my $self = shift;
my %args = @_;
last unless exists $args{closure} || exists $args{c};
my $c = exists $args{closure} ? delete $args{closure} : exists $args{c} ? delete $args{c} : undef;
$self->mixin($c ? 'STD::Q::c1' : 'STD::Q::c0')     };
}
{
local @_ = @_;
return scalar do { # work around #38809
my $self = shift;
my %args = @_;
last unless exists $args{path} || exists $args{p};
my $p = exists $args{path} ? delete $args{path} : exists $args{p} ? delete $args{p} : undef;
$self->mixin($p ? 'STD::Q::p1' : 'STD::Q::p0')     };
}
{
local @_ = @_;
return scalar do { # work around #38809
my $self = shift;
my %args = @_;
last unless exists $args{exec} || exists $args{x};
my $x = exists $args{exec} ? delete $args{exec} : exists $args{x} ? delete $args{x} : undef;
$self->mixin($x ? 'STD::Q::x1' : 'STD::Q::x0')     };
}
{
local @_ = @_;
return scalar do { # work around #38809
my $self = shift;
my %args = @_;
last unless exists $args{words} || exists $args{w};
my $w = exists $args{words} ? delete $args{words} : exists $args{w} ? delete $args{w} : undef;
$self->mixin($w ? 'STD::Q::w1' : 'STD::Q::w0')     };
}
{
local @_ = @_;
return scalar do { # work around #38809
my $self = shift;
my %args = @_;
last unless exists $args{quotewords} || exists $args{ww};
my $ww = exists $args{quotewords} ? delete $args{quotewords} : exists $args{ww} ? delete $args{ww} : undef;
$self->mixin($ww ? 'STD::Q::ww1' : 'STD::Q::ww0')     };
}
{
local @_ = @_;
return scalar do { # work around #38809
my $self = shift;
my %args = @_;
last unless exists $args{heredoc} || exists $args{to};
my $to = exists $args{heredoc} ? delete $args{heredoc} : exists $args{to} ? delete $args{to} : undef;
$self->truly($to, ':to');
$self->cursor_herelang;
};
}
{
local @_ = @_;
return scalar do { # work around #38809
my $self = shift;
my %args = @_;
last unless exists $args{regex};
my $regex = exists $args{regex} ? delete $args{regex} : undef;
return $::LANG{'Regex'}    };
}
{
local @_ = @_;
return scalar do { # work around #38809
my $self = shift;
my %args = @_;
my %x = %args;
my @k = keys(%x);
$self->sorry("Unrecognized quote modifier: " . join('',@k));
};
}
$orig->(@_);
};

1; };
{ package STD::Quasi;
use Moose ':all' => { -prefix => "moose_" };
use Encode;
moose_extends('STD::P6');
our $ALLROLES = { 'STD::Quasi', 1 };
our $REGEXES = {
ALL => [ qw/term/ ],
term => [ qw/term__S_000unquote__PEEK/ ],
};


no warnings 'qw', 'recursion';
my $retree;

$DB::deep = $DB::deep = 1000; # suppress used-once warning

use YAML::XS;

$SIG{__WARN__} = sub { die @_,"   statement started at line ", 'Cursor'->lineof($::LASTSTATE), "
" } if $::DEBUG;

$retree = YAML::XS::Load(Encode::encode_utf8(<<'RETREE_END'));
---
term__S_000unquote: !!perl/hash:RE_ast
  dba: term
  dic: STD::Quasi
  re: !!perl/hash:RE_sequence
    zyg:
    - !!perl/hash:RE_method
      name: starter
      rest: ''
    - !!perl/hash:RE_method
      name: starter
      rest: ''
    - !!perl/hash:RE_method
      name: starter
      rest: ''
    - !!perl/hash:RE_method
      name: ws
      rest: ''
    - !!perl/hash:RE_bracket
      re: !!perl/hash:RE_first
        zyg:
        - !!perl/hash:RE_sequence
          zyg:
          - !!perl/hash:RE_method
            name: EXPR
            rest: ''
          - !!perl/hash:RE_method
            name: stopper
            rest: ''
          - !!perl/hash:RE_method
            name: stopper
            rest: ''
          - !!perl/hash:RE_method
            name: stopper
            rest: ''
        - !!perl/hash:RE_method
          name: panic
          rest: 1
RETREE_END
## token term:unquote {
sub term__S_000unquote__PEEK { $_[0]->_AUTOLEXpeek('term__S_000unquote', $retree) }
sub term__S_000unquote {
no warnings 'recursion';
my $self = shift;

local $::QUASIMODO = 0;
local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;

my $C = $self->cursor_xact("RULE term__S_000unquote");
my $xact = $C->xact;
my $S = $C->{'_pos'};
$C->{'starter'} = [];
$C->{'stopper'} = [];
$C->{sym} = "unquote";
$self->_MATCHIFYr($S, "term__S_000unquote", do {
my $C = $C;
if (($C) = ($C->_SUBSUMEr(['starter'], sub {
my $C = shift;
$C->starter
}))
and ($C) = ($C->_SUBSUMEr(['starter'], sub {
my $C = shift;
$C->starter
}))
and ($C) = ($C->_SUBSUMEr(['starter'], sub {
my $C = shift;
$C->starter
}))
and ($C) = ($C->ws)
and ($C) = ($C->_BRACKETr(sub {
my $C=shift;
do {    my $C = $C->cursor_xact('ALT ||');
my $xact = $C->xact;
my @gather;
do {
push @gather, do {
my $C = $C;
if (($C) = ($C->_SUBSUMEr(['EXPR'], sub {
my $C = shift;
$C->EXPR
}))
and ($C) = ($C->_SUBSUMEr(['stopper'], sub {
my $C = shift;
$C->stopper
}))
and ($C) = ($C->_SUBSUMEr(['stopper'], sub {
my $C = shift;
$C->stopper
}))) {
$C->_SUBSUMEr(['stopper'], sub {
my $C = shift;
$C->stopper
})
} else { () }

}
}
or $xact->[-2] or
do {
push @gather, do {
if (my ($C) = ($C->panic("Confused"))) { ($C) } else { () }

}
};
@gather;
}
}))) {
$C
} else { () }

});
}
;
## method tweak (:$ast!)
;
## method tweak (:$lang!)
;
## method tweak (:$unquote!)
;
## method tweak (:$COMPILING!)
;
## method tweak (*%x)
;
moose_around tweak  => sub {
my $orig = shift;
no warnings 'recursion';
{
local @_ = @_;
return scalar do { # work around #38809
my $self = shift;
my %args = @_;
last unless exists $args{ast};
my $ast = exists $args{ast} ? delete $args{ast} : undef;
$self    };
}
{
local @_ = @_;
return scalar do { # work around #38809
my $self = shift;
my %args = @_;
last unless exists $args{lang};
my $lang = exists $args{lang} ? delete $args{lang} : undef;
$self->cursor_fresh( $lang )    };
}
{
local @_ = @_;
return scalar do { # work around #38809
my $self = shift;
my %args = @_;
last unless exists $args{unquote};
my $unquote = exists $args{unquote} ? delete $args{unquote} : undef;
$self    };
}
{
local @_ = @_;
return scalar do { # work around #38809
my $self = shift;
my %args = @_;
last unless exists $args{COMPILING};
my $COMPILING = exists $args{COMPILING} ? delete $args{COMPILING} : undef;
$::QUASIMODO = 1;
$self;
};
}
{
local @_ = @_;
return scalar do { # work around #38809
my $self = shift;
my %args = @_;
my %x = %args;
my @k = keys(%x);
$self->sorry("Unrecognized quasiquote modifier: " . join('',@k));
};
}
$orig->(@_);
};

1; };
## method EXPR ($preclvl?)
sub EXPR {
no warnings 'recursion';
my $self = shift;
my $preclvl = @_ ? shift() : undef;
local $::CTX = $self->callm if $::DEBUG & DEBUG::trace_call;
my $preclim = $preclvl ? $preclvl->{'prec'} // $LOOSEST : $LOOSEST;
local $::LEFTSIGIL = '';
local $::PRECLIM = $preclim;
my @termstack;
my @opstack;
my $termish = 'termish';
push @opstack, {
'O' => \%terminator, 'sym' => '' };
my $here = $self;
my $S = $here->{'_pos'};
$self->deb("In EXPR, at $S") if $::DEBUG & DEBUG::EXPR;
my $reduce = sub{
$self->deb("entering reduce, termstack == ", 0+@termstack, " opstack == ", 0+@opstack) if $::DEBUG & DEBUG::EXPR;
my $op = pop @opstack;
my $sym = $op->{'sym'};
given ($op->{'O'}->{'assoc'} // 'unary') {
when ('chain') {
$self->deb("reducing chain") if $::DEBUG & DEBUG::EXPR;
my @chain;
push @chain, pop(@termstack);
push @chain, $op;
while (@opstack) {
last if $op->{'O'}->{'prec'} ne $opstack[-1]->{'O'}->{'prec'};
push @chain, pop(@termstack);
push @chain, pop(@opstack);
}
;
push @chain, pop(@termstack);
my $endpos = $chain[0]->{'_pos'};
@chain = reverse @chain if @chain > 1;
my $startpos = $chain[0]->from;
my $nop = $op->cursor_fresh();
$nop->prepbind(@chain);
$nop->{'chain'} = [@chain];
$nop->{'_arity'} = 'CHAIN';
$nop->from = $startpos;
$nop->{'_pos'} = $endpos;
my @caps;
my $i = 0;
for (@chain) {
push(@caps, $i++ % 2 ? 'op' : 'term' );
push(@caps, $_);
}
;
$nop->{'~CAPS'} = \@caps;
push @termstack, $nop->_REDUCE($startpos, 'CHAIN');
delete $termstack[-1]->{'PRE'};
delete $termstack[-1]->{'POST'};
}
;
when ('list') {
$self->deb("reducing list") if $::DEBUG & DEBUG::EXPR;
my @list;
my @delims = $op;
push @list, pop(@termstack);
while (@opstack) {
$self->deb($sym . " vs " . $opstack[-1]->{'sym'}) if $::DEBUG & DEBUG::EXPR;
last if $sym ne $opstack[-1]->{'sym'};
if (@termstack and defined $termstack[0]) {
push @list, pop(@termstack)}
else {
$self->worry("Missing term in " . $sym . " list")};
push @delims, pop(@opstack);
}
;
if (@termstack and defined $termstack[0]) {
push @list, pop(@termstack)}
else {
$self->worry("Missing final term in '" . $sym . "' list")};
my $endpos = $list[0]->{'_pos'};
@list = reverse @list if @list > 1;
my $startpos = $list[0]->from;
@delims = reverse @delims if @delims > 1;
my $nop = $op->cursor_fresh();
$nop->prepbind(@list,@delims);
$nop->{'sym'} = $sym;
$nop->{'O'} = $op->{'O'};
$nop->{'list'} = [@list];
$nop->{'delims'} = [@delims];
$nop->{'_arity'} = 'LIST';
$nop->from = $startpos;
$nop->{'_pos'} = $endpos;
if (@list) {
my @caps;
push @caps, 'elem', $list[0] if $list[0];
for (0..@delims-1) {
my $d = $delims[$_];
my $l = $list[$_+1];
push @caps, 'delim', $d;
push @caps, 'elem', $l if $l;
}
;
$nop->{'~CAPS'} = \@caps;
};
push @termstack, $nop->_REDUCE($startpos, 'LIST');
delete $termstack[-1]->{'PRE'};
delete $termstack[-1]->{'POST'};
}
;
when ('unary') {
$self->deb("reducing") if $::DEBUG & DEBUG::EXPR;
$self->deb("Termstack size: ", 0+@termstack) if $::DEBUG & DEBUG::EXPR;
$self->deb($op->dump) if $::DEBUG & DEBUG::EXPR;
my $arg = pop @termstack;
$op->prepbind($arg);
$op->{'arg'} = $arg;
my $a = $op->{'~CAPS'};
$op->{'_arity'} = 'UNARY';
if ($arg->from < $op->from) {
$op->from = $arg->from;
unshift @$a, 'arg', $arg;
push @termstack, $op->_REDUCE($op->from, 'POSTFIX');
delete $termstack[-1]->{'PRE'};
delete $termstack[-1]->{'POST'};
}
elsif ($arg->{'_pos'} > $op->{'_pos'}) {
$op->{'_pos'} = $arg->{'_pos'};
push @$a, 'arg', $arg;
push @termstack, $op->_REDUCE($op->from, 'PREFIX');
delete $termstack[-1]->{'PRE'};
delete $termstack[-1]->{'POST'};
};
}
;
default {
$self->deb("reducing") if $::DEBUG & DEBUG::EXPR;
$self->deb("Termstack size: ", 0+@termstack) if $::DEBUG & DEBUG::EXPR;
my $right = pop @termstack;
my $left = pop @termstack;
$op->prepbind($left,$right);
$op->{'right'} = $right;
$op->{'left'} = $left;
$op->from = $left->from;
$op->{'_pos'} = $right->{'_pos'};
$op->{'_arity'} = 'BINARY';
my $a = $op->{'~CAPS'};
unshift @$a, 'left', $left;
push @$a, 'right', $right;
$self->deb($op->dump) if $::DEBUG & DEBUG::EXPR;
my $ck;
if ($ck = $op->{'O'}->{'_reducecheck'}) {
$op = $op->$ck};
push @termstack, $op->_REDUCE($op->from, 'INFIX');
delete $termstack[-1]->{'PRE'};
delete $termstack[-1]->{'POST'};
}
;
}
;
};
TERM:
for (;;) {
$self->deb("In loop, at ", $here->{'_pos'}) if $::DEBUG & DEBUG::EXPR;
my $oldpos = $here->{'_pos'};
$here = $here->cursor_fresh();
$::LEFTSIGIL = $opstack[-1]->{'O'}->{'prec'} gt $item_assignment_prec ? '@' : '';
my @t = $here->$termish;
if (not @t or not $here = $t[0] or ($here->{'_pos'} == $oldpos and $termish eq 'termish')) {
$here->panic("Bogus term") if @opstack > 1;
return ();
};
$termish = 'termish';
my $PRE = delete $here->{'PRE'} // [];
my $POST = delete $here->{'POST'} // [];
my @PRE = @$PRE;
my @POST = reverse @$POST;
my $M = $here;
while (@PRE and @POST) {
my $postO = $POST[0]->{'O'};
my $preO = $PRE[0]->{'O'};
if ($postO->{'prec'} lt $preO->{'prec'}) {
push @opstack, shift @POST}
elsif ($postO->{'prec'} gt $preO->{'prec'}) {
push @opstack, shift @PRE}
elsif ($postO->{'uassoc'} eq 'left') {
push @opstack, shift @POST}
elsif ($postO->{'uassoc'} eq 'right') {
push @opstack, shift @PRE}
else {
$here->sorry('"' . $PRE[0]->{'sym'} . '" and "' . $POST[0]->{'sym'} . '" are not associative')};
}
;
push @opstack, @PRE,@POST;
push @termstack, $here->{'term'};
delete $termstack[-1]->{'POST'};
$self->deb("after push: " . (0+@termstack)) if $::DEBUG & DEBUG::EXPR;
last TERM if $preclim eq $methodcall_prec;
for (;;) {
$oldpos = $here->{'_pos'};
last TERM if ($::MEMOS[$oldpos]->{'endstmt'} // 0) == 2;
$here = $here->cursor_fresh->ws;
my @infix = $here->cursor_fresh->infixish();
last TERM unless @infix;
my $infix = $infix[0];
last TERM unless $infix->{'_pos'} > $oldpos;
if (not $infix->{'sym'}) {
die $infix->dump if $::DEBUG & DEBUG::EXPR};
my $inO = $infix->{'O'};
my $inprec = $inO->{'prec'};
if (not defined $inprec) {
$self->deb("No prec given in infix!") if $::DEBUG & DEBUG::EXPR;
die $infix->dump if $::DEBUG & DEBUG::EXPR;
$inprec = $terminator{'prec'};
};
if ($inprec le $preclim) {
if ($preclim ne $LOOSEST) {
my $dba = $preclvl->{'dba'};
my $h = $::HIGHEXPECT;
%$h = ();
$h->{"an infix operator with precedence tighter than $dba"} = 1;
};
last TERM;
};
$here = $infix->cursor_fresh->ws();
$inO->{'prec'} = $inO->{'sub'} if $inO->{'sub'};
while ($opstack[-1]->{'O'}->{'prec'} gt $inprec) {
$reduce->()}

# Not much point in reducing the sentinels...
;
last if $inprec lt $LOOSEST;
if ($infix->{'fake'}) {
push @opstack, $infix;
$reduce->();
next;
};
if ($opstack[-1]->{'O'}->{'prec'} eq $inprec) {
my $assoc = 1;
given ($inO->{'assoc'}) {
when ('non')   {
$assoc = 0}
;
when ('left')  {
$reduce->() }
;
when ('right') {
}
;
when ('chain') {
}
;
when ('unary') {
}
;
when ('list')  {
$assoc = 0 unless $infix->{'sym'} eq $opstack[-1]->{'sym'}}
;
default {
$here->panic('Unknown associativity "' . $_ . '" for "' . $infix->{'sym'} . '"') }
;
}
;
if (not $assoc) {
$here->sorry('"' . $opstack[-1]->{'sym'} . '" and "' . $infix->Str . '" are non-associative and require parens')};
};
$termish = $inO->{'nextterm'} if $inO->{'nextterm'};
push @opstack, $infix;
last;
};
};
$reduce->() while 0+@opstack > 1;
if (@termstack) {
0+@termstack == 1 or $here->panic("Internal operator parser error, termstack == " . (0+@termstack));
$termstack[0]->from = $self->{'_pos'};
$termstack[0]->{'_pos'} = $here->{'_pos'};
};
$self->_MATCHIFYr($S, "EXPR", @termstack);
};
{ package STD::Regex;
use Moose ':all' => { -prefix => "moose_" };
use Encode;
moose_extends('STD');
our $ALLROLES = { 'STD::Regex', 1 };
our $REGEXES = {
ALL => [ qw/assertion atom backslash category cclass_elem infixish infixstopper metachar mod_arg mod_internal nibbler normspace quant_atom_list quantified_atom quantifier quantmod regex_infix sign termish unsp ws/ ],
assertion => [ qw/assertion__S_073DotDotDot__PEEK assertion__S_074QuestionQuestionQuestion__PEEK assertion__S_075BangBangBang__PEEK assertion__S_076Question__PEEK assertion__S_077Bang__PEEK assertion__S_078Star__PEEK assertion__S_079Cur_Ly__PEEK assertion__S_080variable__PEEK assertion__S_081method__PEEK assertion__S_082name__PEEK assertion__S_083Bra__PEEK assertion__S_084Plus__PEEK assertion__S_085Minus__PEEK assertion__S_086Dot__PEEK assertion__S_087Comma__PEEK assertion__S_088TildeTilde__PEEK assertion__S_089bogus__PEEK/ ],
backslash => [ qw/backslash__S_047unspace__PEEK backslash__S_0480__PEEK backslash__S_049A__PEEK backslash__S_050a__PEEK backslash__S_051B__PEEK backslash__S_052b__PEEK backslash__S_053c__PEEK backslash__S_054d__PEEK backslash__S_055e__PEEK backslash__S_056f__PEEK backslash__S_057h__PEEK backslash__S_058n__PEEK backslash__S_059o__PEEK backslash__S_060p__PEEK backslash__S_061Q__PEEK backslash__S_062r__PEEK backslash__S_063s__PEEK backslash__S_064t__PEEK backslash__S_065v__PEEK backslash__S_066w__PEEK backslash__S_067x__PEEK backslash__S_068z__PEEK backslash__S_069Z__PEEK backslash__S_070misc__PEEK backslash__S_071oldbackref__PEEK backslash__S_072oops__PEEK/ ],
category => [ qw/category__S_000metachar__PEEK category__S_001backslash__PEEK category__S_002assertion__PEEK category__S_003quantifier__PEEK category__S_004mod_internal__PEEK/ ],
metachar => [ qw/metachar__S_009Gt__PEEK metachar__S_010AmpAmp__PEEK metachar__S_011Amp__PEEK metachar__S_012VertVert__PEEK metachar__S_013Vert__PEEK metachar__S_014Ket__PEEK metachar__S_015Thesis__PEEK metachar__S_016Semi__PEEK metachar__S_017CurStarLy__PEEK metachar__S_018BraStarKet__PEEK metachar__S_019quant__PEEK metachar__S_020sigwhite__PEEK metachar__S_021unsp__PEEK metachar__S_022Cur_Ly__PEEK metachar__S_023mod__PEEK metachar__S_024Minus__PEEK metachar__S_025Colon__PEEK metachar__S_026ColonColon__PEEK metachar__S_027ColonColonColon__PEEK metachar__S_028Bra_Ket__PEEK metachar__S_029Paren_Thesis__PEEK metachar__S_030LtParen__PEEK metachar__S_031ThesisGt__PEEK metachar__S_032LtLt__PEEK metachar__S_033GtGt__PEEK metachar__S_034Fre__PEEK metachar__S_035Nch__PEEK metachar__S_036qw__PEEK metachar__S_037Lt_Gt__PEEK metachar__S_038Back__PEEK metachar__S_039Dot__PEEK metachar__S_040CaretCaret__PEEK metachar__S_041Caret__PEEK metachar__S_042DollarDollar__PEEK metachar__S_043Dollar__PEEK metachar__S_044Single_Single__PEEK metachar__S_045Double_Double__PEEK metachar__S_046var__PEEK/ ],
mod_internal => [ qw/mod_internal__S_090Colonmy__PEEK mod_internal__S_091Coloni__PEEK mod_internal__S_092ColonBangi__PEEK mod_internal__S_093ColoniParen_Thesis__PEEK mod_internal__S_094Colon0i__PEEK mod_internal__S_095Colona__PEEK mod_internal__S_096ColonBanga__PEEK mod_internal__S_097ColonaParen_Thesis__PEEK mod_internal__S_098Colon0a__PEEK mod_internal__S_099Colons__PEEK mod_internal__S_100ColonBangs__PEEK mod_internal__S_101ColonsParen_Thesis__PEEK mod_internal__S_102Colon0s__PEEK mod_internal__S_103Colonr__PEEK mod_internal__S_104ColonBangr__PEEK mod_internal__S_105ColonrParen_Thesis__PEEK mod_internal__S_106Colon0r__PEEK mod_internal__S_107ColonPerl5__PEEK mod_internal__S_108p6adv__PEEK mod_internal__S_109oops__PEEK/ ],
quantifier => [ qw/quantifier__S_110Star__PEEK quantifier__S_111Plus__PEEK quantifier__S_112Question__PEEK quantifier__S_113Colon__PEEK quantifier__S_114StarStar__PEEK quantifier__S_115Tilde__PEEK quantifier__S_116TildeTilde__PEEK quantifier__S_117CurNCommaMLy__PEEK/ ],
regex_infix => [ qw/regex_infix__S_005VertVert__PEEK regex_infix__S_006AmpAmp__PEEK regex_infix__S_007Vert__PEEK regex_infix__S_008Amp__PEEK/ ],
};


no warnings 'qw', 'recursion';
my $retree;

$DB::deep = $DB::deep = 1000; # suppress used-once warning

use YAML::XS;

$SIG{__WARN__} = sub { die @_,"   statement started at line ", 'Cursor'->lineof($::LASTSTATE), "
" } if $::DEBUG;

$retree = YAML::XS::Load(Encode::encode_utf8(<<'RETREE_END'));
---
assertion:*:
  dic: STD::Regex
assertion__S_073DotDotDot: !!perl/hash:RE_ast
  dba: assertion
  dic: STD::Regex
  re: !!perl/hash:RE_method
    i: 0
    name: sym
    rest: ''
    sym: '...'
assertion__S_074QuestionQuestionQuestion: !!perl/hash:RE_ast
  dba: assertion
  dic: STD::Regex
  re: !!perl/hash:RE_method
    i: 0
    name: sym
    rest: ''
    sym: ???
assertion__S_075BangBangBang: !!perl/hash:RE_ast
  dba: assertion
  dic: STD::Regex
  re: !!perl/hash:RE_method
    i: 0
    name: sym
    rest: ''
    sym: '!!!'
assertion__S_076Question: !!perl/hash:RE_ast
  dba: assertion
  dic: STD::Regex
  re: !!perl/hash:RE_sequence
    zyg:
    - !!perl/hash:RE_method
      i: 0
      name: sym
      rest: ''
      sym: '?'
    - !!perl/hash:RE_bracket
      re: &1 !!perl/hash:RE_any
        altname: assertion__S_076Question_0
        dba: assertion
        dic: STD::Regex
        zyg:
        - !!perl/hash:RE_assertion
          alt: assertion__S_076Question_0 0
          assert: '?'
          re: !!perl/hash:RE_method_re
            name: before
            nobind: 1
            re: !!perl/hash:RE_string
              i: 0
              text: '>'
        - !!perl/hash:RE_method
          alt: assertion__S_076Question_0 1
          name: assertion
          rest: ''
assertion__S_076Question_0: *1
assertion__S_077Bang: !!perl/hash:RE_ast
  dba: assertion
  dic: STD::Regex
  re: !!perl/hash:RE_sequence
    zyg:
    - !!perl/hash:RE_method
      i: 0
      name: sym
      rest: ''
      sym: '!'
    - !!perl/hash:RE_bracket
      re: &2 !!perl/hash:RE_any
        altname: assertion__S_077Bang_0
        dba: assertion
        dic: STD::Regex
        zyg:
        - !!perl/hash:RE_assertion
          alt: assertion__S_077Bang_0 0
          assert: '?'
          re: !!perl/hash:RE_method_re
            name: before
            nobind: 1
            re: !!perl/hash:RE_string
              i: 0
              text: '>'
        - !!perl/hash:RE_method
          alt: assertion__S_077Bang_0 1
          name: assertion
          rest: ''
assertion__S_077Bang_0: *2
assertion__S_078Star: !!perl/hash:RE_ast
  dba: assertion
  dic: STD::Regex
  re: !!perl/hash:RE_sequence
    zyg:
    - !!perl/hash:RE_method
      i: 0
      name: sym
      rest: ''
      sym: '*'
    - !!perl/hash:RE_bracket
      re: &3 !!perl/hash:RE_any
        altname: assertion__S_078Star_0
        dba: assertion
        dic: STD::Regex
        zyg:
        - !!perl/hash:RE_assertion
          alt: assertion__S_078Star_0 0
          assert: '?'
          re: !!perl/hash:RE_method_re
            name: before
            nobind: 1
            re: !!perl/hash:RE_string
              i: 0
              text: '>'
        - !!perl/hash:RE_sequence
          alt: assertion__S_078Star_0 1
          zyg:
          - !!perl/hash:RE_method
            name: ws
            rest: ''
          - !!perl/hash:RE_method
            name: nibbler
            rest: ''
assertion__S_078Star_0: *3
assertion__S_079Cur_Ly: !!perl/hash:RE_ast
  dba: assertion
  dic: STD::Regex
  re: !!perl/hash:RE_method
    name: embeddedblock
    rest: ''
assertion__S_080variable: !!perl/hash:RE_ast
  dba: assertion
  dic: STD::Regex
  re: !!perl/hash:RE_sequence
    zyg:
    - !!perl/hash:RE_assertion
      assert: '?'
      re: !!perl/hash:RE_method_re
        name: before
        nobind: 1
        re: !!perl/hash:RE_method
          name: sigil
          rest: ''
    - !!perl/hash:RE_bracket
      re: !!perl/hash:RE_sequence
        zyg:
        - !!perl/hash:RE_decl {}
        - !!perl/hash:RE_bindnamed
          atom: !!perl/hash:RE_method
            name: EXPR
            rest: 1
assertion__S_081method: !!perl/hash:RE_ast
  dba: assertion
  dic: STD::Regex
  re: !!perl/hash:RE_sequence
    zyg:
    - !!perl/hash:RE_string
      i: 0
      text: .
    - !!perl/hash:RE_bracket
      re: &4 !!perl/hash:RE_any
        altname: assertion__S_081method_0
        dba: assertion
        dic: STD::Regex
        zyg:
        - !!perl/hash:RE_sequence
          alt: assertion__S_081method_0 0
          zyg:
          - !!perl/hash:RE_assertion
            assert: '?'
            re: !!perl/hash:RE_method_re
              name: before
              nobind: 1
              re: !!perl/hash:RE_method
                name: alpha
                rest: ''
          - !!perl/hash:RE_method
            name: assertion
            rest: ''
        - !!perl/hash:RE_bracket
          alt: assertion__S_081method_0 1
          re: !!perl/hash:RE_sequence
            zyg:
            - !!perl/hash:RE_decl {}
            - !!perl/hash:RE_method
              name: dottyop
              rest: ''
assertion__S_081method_0: *4
assertion__S_082name: !!perl/hash:RE_ast
  dba: assertion
  dic: STD::Regex
  re: !!perl/hash:RE_sequence
    zyg:
    - !!perl/hash:RE_bracket
      re: !!perl/hash:RE_sequence
        zyg:
        - !!perl/hash:RE_decl {}
        - !!perl/hash:RE_method
          name: longname
          rest: ''
    - !!perl/hash:RE_quantified_atom
      atom: !!perl/hash:RE_bracket
        re: &5 !!perl/hash:RE_any
          altname: assertion__S_082name_0
          dba: assertion
          dic: STD::Regex
          zyg:
          - !!perl/hash:RE_sequence
            alt: assertion__S_082name_0 0
            zyg:
            - !!perl/hash:RE_assertion
              assert: '?'
              re: !!perl/hash:RE_method_re
                name: before
                nobind: 1
                re: !!perl/hash:RE_string
                  i: 0
                  text: '>'
            - !!perl/hash:RE_block {}
          - !!perl/hash:RE_sequence
            alt: assertion__S_082name_0 1
            zyg:
            - !!perl/hash:RE_quantified_atom
              atom: !!perl/hash:RE_method
                name: normspace
                rest: ''
              quant:
              - '?'
            - !!perl/hash:RE_method
              name: nibbler
              rest: ''
            - !!perl/hash:RE_method
              name: ws
              rest: ''
          - !!perl/hash:RE_sequence
            alt: assertion__S_082name_0 2
            zyg:
            - !!perl/hash:RE_string
              i: 0
              text: =
            - !!perl/hash:RE_method
              name: assertion
              rest: ''
          - !!perl/hash:RE_sequence
            alt: assertion__S_082name_0 3
            zyg:
            - !!perl/hash:RE_string
              i: 0
              text: ':'
            - !!perl/hash:RE_bracket
              re: !!perl/hash:RE_sequence
                zyg:
                - !!perl/hash:RE_decl {}
                - !!perl/hash:RE_method
                  name: ws
                  rest: ''
                - !!perl/hash:RE_method
                  name: arglist
                  rest: ''
          - !!perl/hash:RE_sequence
            alt: assertion__S_082name_0 4
            zyg:
            - !!perl/hash:RE_string
              i: 0
              text: (
            - !!perl/hash:RE_block {}
            - !!perl/hash:RE_bracket
              re: !!perl/hash:RE_sequence
                zyg:
                - !!perl/hash:RE_decl {}
                - !!perl/hash:RE_method
                  name: arglist
                  rest: ''
            - !!perl/hash:RE_bracket
              re: !!perl/hash:RE_first
                zyg:
                - !!perl/hash:RE_string
                  i: 0
                  text: )
                - !!perl/hash:RE_method
                  name: panic
                  rest: 1
      quant:
      - '?'
assertion__S_082name_0: *5
assertion__S_083Bra: !!perl/hash:RE_ast
  dba: assertion
  dic: STD::Regex
  re: !!perl/hash:RE_sequence
    zyg:
    - !!perl/hash:RE_assertion
      assert: '?'
      re: !!perl/hash:RE_method_re
        name: before
        nobind: 1
        re: !!perl/hash:RE_string
          i: 0
          text: '['
    - !!perl/hash:RE_quantified_atom
      atom: !!perl/hash:RE_method
        name: cclass_elem
        rest: ''
      quant:
      - +
assertion__S_084Plus: !!perl/hash:RE_ast
  dba: assertion
  dic: STD::Regex
  re: !!perl/hash:RE_sequence
    zyg:
    - !!perl/hash:RE_assertion
      assert: '?'
      re: !!perl/hash:RE_method_re
        name: before
        nobind: 1
        re: !!perl/hash:RE_string
          i: 0
          text: +
    - !!perl/hash:RE_quantified_atom
      atom: !!perl/hash:RE_method
        name: cclass_elem
        rest: ''
      quant:
      - +
assertion__S_085Minus: !!perl/hash:RE_ast
  dba: assertion
  dic: STD::Regex
  re: !!perl/hash:RE_sequence
    zyg:
    - !!perl/hash:RE_assertion
      assert: '?'
      re: !!perl/hash:RE_method_re
        name: before
        nobind: 1
        re: !!perl/hash:RE_string
          i: 0
          text: '-'
    - !!perl/hash:RE_quantified_atom
      atom: !!perl/hash:RE_method
        name: cclass_elem
        rest: ''
      quant:
      - +
assertion__S_086Dot: !!perl/hash:RE_ast
  dba: assertion
  dic: STD::Regex
  re: !!perl/hash:RE_method
    i: 0
    name: sym
    rest: ''
    sym: .
assertion__S_087Comma: !!perl/hash:RE_ast
  dba: assertion
  dic: STD::Regex
  re: !!perl/hash:RE_method
    i: 0
    name: sym
    rest: ''
    sym: ','
assertion__S_088TildeTilde: !!perl/hash:RE_ast
  dba: assertion
  dic: STD::Regex
  re: !!perl/hash:RE_sequence
    zyg:
    - !!perl/hash:RE_method
      i: 0
      name: sym
      rest: ''
      sym: ~~
    - !!perl/hash:RE_bracket
      re: &6 !!perl/hash:RE_any
        altname: assertion__S_088TildeTilde_0
        dba: assertion
        dic: STD::Regex
        zyg:
        - !!perl/hash:RE_assertion
          alt: assertion__S_088TildeTilde_0 0
          assert: '?'
          re: !!perl/hash:RE_method_re
            name: before
            nobind: 1
            re: !!perl/hash:RE_string
              i: 0
              text: '>'
        - !!perl/hash:RE_quantified_atom
          alt: assertion__S_088TildeTilde_0 1
          atom: !!perl/hash:RE_meta
            min: 1
            text: \d
          quant:
          - +
        - !!perl/hash:RE_method
          alt: assertion__S_088TildeTilde_0 2
          name: desigilname
          rest: ''
assertion__S_088TildeTilde_0: *6
assertion__S_089bogus: !!perl/hash:RE_ast
  dba: assertion
  dic: STD::Regex
  re: !!perl/hash:RE_method
    name: panic
    rest: 1
atom: !!perl/hash:RE_ast
  dba: regex atom
  dic: STD::Regex
  re: !!perl/hash:RE_bracket
    re: &7 !!perl/hash:RE_any
      altname: atom_0
      dba: regex atom
      dic: STD::Regex
      zyg:
      - !!perl/hash:RE_meta
        alt: atom_0 0
        min: 1
        text: \w
      - !!perl/hash:RE_sequence
        alt: atom_0 1
        zyg:
        - !!perl/hash:RE_method
          name: metachar
          rest: ''
        - !!perl/hash:RE_meta
          text: '::'
atom_0: *7
backslash:*:
  dic: STD::Regex
backslash__S_047unspace: !!perl/hash:RE_ast
  dba: backslash
  dic: STD::Regex
  re: !!perl/hash:RE_sequence
    zyg:
    - !!perl/hash:RE_assertion
      assert: '?'
      re: !!perl/hash:RE_method_re
        name: before
        nobind: 1
        re: !!perl/hash:RE_meta
          min: 1
          text: \s
    - !!perl/hash:RE_method
      name: SUPER::ws
      rest: ''
backslash__S_0480: !!perl/hash:RE_ast
  dba: backslash
  dic: STD::Regex
  re: !!perl/hash:RE_sequence
    zyg:
    - !!perl/hash:RE_string
      i: 0
      text: '0'
    - !!perl/hash:RE_assertion
      assert: '!'
      re: !!perl/hash:RE_method_re
        name: before
        nobind: 1
        re: !!perl/hash:RE_cclass
          i: 0
          text: '[0..7]'
backslash__S_049A: !!perl/hash:RE_ast
  dba: backslash
  dic: STD::Regex
  re: !!perl/hash:RE_sequence
    zyg:
    - !!perl/hash:RE_method
      i: 0
      name: sym
      rest: ''
      sym: A
    - !!perl/hash:RE_method
      name: obs
      rest: 1
backslash__S_050a: !!perl/hash:RE_ast
  dba: backslash
  dic: STD::Regex
  re: !!perl/hash:RE_sequence
    zyg:
    - !!perl/hash:RE_method
      i: 0
      name: sym
      rest: ''
      sym: a
    - !!perl/hash:RE_method
      name: sorry
      rest: 1
backslash__S_051B: !!perl/hash:RE_ast
  dba: backslash
  dic: STD::Regex
  re: !!perl/hash:RE_sequence
    zyg:
    - !!perl/hash:RE_method
      i: 0
      name: sym
      rest: ''
      sym: B
    - !!perl/hash:RE_method
      name: obs
      rest: 1
backslash__S_052b: !!perl/hash:RE_ast
  dba: backslash
  dic: STD::Regex
  re: !!perl/hash:RE_sequence
    zyg:
    - !!perl/hash:RE_method
      i: 0
      name: sym
      rest: ''
      sym: b
    - !!perl/hash:RE_method
      name: obs
      rest: 1
backslash__S_053c: !!perl/hash:RE_ast
  dba: backslash
  dic: STD::Regex
  re: !!perl/hash:RE_sequence
    zyg:
    - !!perl/hash:RE_method
      i: 1
      name: sym
      rest: ''
      sym: c
    - !!perl/hash:RE_method
      name: charspec
      rest: ''
backslash__S_054d: !!perl/hash:RE_ast
  dba: backslash
  dic: STD::Regex
  re: !!perl/hash:RE_method
    i: 1
    name: sym
    rest: ''
    sym: d
backslash__S_055e: !!perl/hash:RE_ast
  dba: backslash
  dic: STD::Regex
  re: !!perl/hash:RE_method
    i: 1
    name: sym
    rest: ''
    sym: e
backslash__S_056f: !!perl/hash:RE_ast
  dba: backslash
  dic: STD::Regex
  re: !!perl/hash:RE_method
    i: 1
    name: sym
    rest: ''
    sym: f
backslash__S_057h: !!perl/hash:RE_ast
  dba: backslash
  dic: STD::Regex
  re: !!perl/hash:RE_method
    i: 1
    name: sym
    rest: ''
    sym: h
backslash__S_058n: !!perl/hash:RE_ast
  dba: backslash
  dic: STD::Regex
  re: !!perl/hash:RE_method
    i: 1
    name: sym
    rest: ''
    sym: n
backslash__S_059o: !!perl/hash:RE_ast
  dba: octal character
  dic: STD::Regex
  re: !!perl/hash:RE_sequence
    zyg:
    - !!perl/hash:RE_method
      i: 1
      name: sym
      rest: ''
      sym: o
    - !!perl/hash:RE_bracket
      re: &8 !!perl/hash:RE_any
        altname: backslash__S_059o_0
        dba: octal character
        dic: STD::Regex
        zyg:
        - !!perl/hash:RE_method
          alt: backslash__S_059o_0 0
          name: octint
          rest: ''
        - !!perl/hash:RE_bracket
          alt: backslash__S_059o_0 1
          re: !!perl/hash:RE_sequence
            zyg:
            - !!perl/hash:RE_string
              i: 1
              text: '['
            - !!perl/hash:RE_block {}
            - !!perl/hash:RE_method
              name: octints
              rest: ''
            - !!perl/hash:RE_bracket
              re: !!perl/hash:RE_first
                zyg:
                - !!perl/hash:RE_string
                  i: 1
                  text: ']'
                - !!perl/hash:RE_method
                  name: FAILGOAL
                  rest: 1
backslash__S_059o_0: *8
backslash__S_060p: !!perl/hash:RE_ast
  dba: backslash
  dic: STD::Regex
  re: !!perl/hash:RE_sequence
    zyg:
    - !!perl/hash:RE_bindnamed
      atom: !!perl/hash:RE_cclass
        i: 0
        text: '[pP]'
    - !!perl/hash:RE_block {}
    - !!perl/hash:RE_bracket
      re: !!perl/hash:RE_first
        zyg:
        - !!perl/hash:RE_sequence
          zyg:
          - !!perl/hash:RE_bindpos
            atom: !!perl/hash:RE_paren
              re: !!perl/hash:RE_meta
                min: 1
                text: \w
          - !!perl/hash:RE_block {}
        - !!perl/hash:RE_sequence
          zyg:
          - !!perl/hash:RE_string
            i: 0
            text: '{'
          - !!perl/hash:RE_bindnamed
            atom: !!perl/hash:RE_bracket
              re: !!perl/hash:RE_quantified_atom
                atom: !!perl/hash:RE_meta
                  min: 1
                  text: \w
                quant:
                - +
          - !!perl/hash:RE_string
            i: 0
            text: '}'
          - !!perl/hash:RE_block {}
        - !!perl/hash:RE_sequence
          zyg:
          - !!perl/hash:RE_string
            i: 0
            text: '{'
          - !!perl/hash:RE_bindnamed
            atom: !!perl/hash:RE_bracket
              re: !!perl/hash:RE_quantified_atom
                atom: !!perl/hash:RE_meta
                  min: 1
                  text: \w
                quant:
                - +
          - !!perl/hash:RE_meta
            min: 1
            text: \=
          - !!perl/hash:RE_bindnamed
            atom: !!perl/hash:RE_bracket
              re: !!perl/hash:RE_quantified_atom
                atom: !!perl/hash:RE_cclass
                  i: 0
                  text: -[\}]
                quant:
                - '*'
          - !!perl/hash:RE_string
            i: 0
            text: '}'
          - !!perl/hash:RE_block {}
backslash__S_061Q: !!perl/hash:RE_ast
  dba: backslash
  dic: STD::Regex
  re: !!perl/hash:RE_sequence
    zyg:
    - !!perl/hash:RE_method
      i: 0
      name: sym
      rest: ''
      sym: Q
    - !!perl/hash:RE_method
      name: obs
      rest: 1
backslash__S_062r: !!perl/hash:RE_ast
  dba: backslash
  dic: STD::Regex
  re: !!perl/hash:RE_method
    i: 1
    name: sym
    rest: ''
    sym: r
backslash__S_063s: !!perl/hash:RE_ast
  dba: backslash
  dic: STD::Regex
  re: !!perl/hash:RE_method
    i: 1
    name: sym
    rest: ''
    sym: s
backslash__S_064t: !!perl/hash:RE_ast
  dba: backslash
  dic: STD::Regex
  re: !!perl/hash:RE_method
    i: 1
    name: sym
    rest: ''
    sym: t
backslash__S_065v: !!perl/hash:RE_ast
  dba: backslash
  dic: STD::Regex
  re: !!perl/hash:RE_method
    i: 1
    name: sym
    rest: ''
    sym: v
backslash__S_066w: !!perl/hash:RE_ast
  dba: backslash
  dic: STD::Regex
  re: !!perl/hash:RE_method
    i: 1
    name: sym
    rest: ''
    sym: w
backslash__S_067x: !!perl/hash:RE_ast
  dba: hex character
  dic: STD::Regex
  re: !!perl/hash:RE_sequence
    zyg:
    - !!perl/hash:RE_method
      i: 1
      name: sym
      rest: ''
      sym: x
    - !!perl/hash:RE_bracket
      re: &9 !!perl/hash:RE_any
        altname: backslash__S_067x_0
        dba: hex character
        dic: STD::Regex
        zyg:
        - !!perl/hash:RE_method
          alt: backslash__S_067x_0 0
          name: hexint
          rest: ''
        - !!perl/hash:RE_bracket
          alt: backslash__S_067x_0 1
          re: !!perl/hash:RE_sequence
            zyg:
            - !!perl/hash:RE_string
              i: 1
              text: '['
            - !!perl/hash:RE_block {}
            - !!perl/hash:RE_method
              name: hexints
              rest: ''
            - !!perl/hash:RE_bracket
              re: !!perl/hash:RE_first
                zyg:
                - !!perl/hash:RE_string
                  i: 1
                  text: ']'
                - !!perl/hash:RE_method
                  name: FAILGOAL
                  rest: 1
backslash__S_067x_0: *9
backslash__S_068z: !!perl/hash:RE_ast
  dba: backslash
  dic: STD::Regex
  re: !!perl/hash:RE_sequence
    zyg:
    - !!perl/hash:RE_method
      i: 0
      name: sym
      rest: ''
      sym: z
    - !!perl/hash:RE_method
      name: obs
      rest: 1
backslash__S_069Z: !!perl/hash:RE_ast
  dba: backslash
  dic: STD::Regex
  re: !!perl/hash:RE_sequence
    zyg:
    - !!perl/hash:RE_method
      i: 0
      name: sym
      rest: ''
      sym: Z
    - !!perl/hash:RE_method
      name: obs
      rest: 1
backslash__S_070misc: !!perl/hash:RE_ast
  dba: backslash
  dic: STD::Regex
  re: !!perl/hash:RE_bindnamed
    atom: !!perl/hash:RE_paren
      re: !!perl/hash:RE_meta
        min: 1
        text: \W
backslash__S_071oldbackref: !!perl/hash:RE_ast
  dba: backslash
  dic: STD::Regex
  re: !!perl/hash:RE_sequence
    zyg:
    - !!perl/hash:RE_bindpos
      atom: !!perl/hash:RE_paren
        re: !!perl/hash:RE_sequence
          zyg:
          - !!perl/hash:RE_cclass
            i: 0
            text: '[1..9]'
          - !!perl/hash:RE_quantified_atom
            atom: !!perl/hash:RE_meta
              min: 1
              text: \d
            quant:
            - '*'
    - !!perl/hash:RE_block {}
backslash__S_072oops: !!perl/hash:RE_ast
  dba: backslash
  dic: STD::Regex
  re: !!perl/hash:RE_sequence
    zyg:
    - !!perl/hash:RE_method
      name: sorry
      rest: 1
    - !!perl/hash:RE_meta
      min: 1
      text: .
category__S_000metachar: !!perl/hash:RE_ast
  dba: category
  dic: STD::Regex
  re: !!perl/hash:RE_method
    i: 0
    name: sym
    rest: ''
    sym: metachar
category__S_001backslash: !!perl/hash:RE_ast
  dba: category
  dic: STD::Regex
  re: !!perl/hash:RE_method
    i: 0
    name: sym
    rest: ''
    sym: backslash
category__S_002assertion: !!perl/hash:RE_ast
  dba: category
  dic: STD::Regex
  re: !!perl/hash:RE_method
    i: 0
    name: sym
    rest: ''
    sym: assertion
category__S_003quantifier: !!perl/hash:RE_ast
  dba: category
  dic: STD::Regex
  re: !!perl/hash:RE_method
    i: 0
    name: sym
    rest: ''
    sym: quantifier
category__S_004mod_internal: !!perl/hash:RE_ast
  dba: category
  dic: STD::Regex
  re: !!perl/hash:RE_method
    i: 0
    name: sym
    rest: ''
    sym: mod_internal
cclass_elem: !!perl/hash:RE_ast
  dba: character class element
  dic: STD::Regex
  re: !!perl/hash:RE_sequence
    zyg:
    - !!perl/hash:RE_method
      name: sign
      rest: ''
    - !!perl/hash:RE_quantified_atom
      atom: !!perl/hash:RE_method
        name: normspace
        rest: ''
      quant:
      - '?'
    - !!perl/hash:RE_bracket
      re: &10 !!perl/hash:RE_any
        altname: cclass_elem_0
        dba: character class element
        dic: STD::Regex
        zyg:
        - !!perl/hash:RE_method
          alt: cclass_elem_0 0
          name: name
          rest: ''
        - !!perl/hash:RE_sequence
          alt: cclass_elem_0 1
          zyg:
          - !!perl/hash:RE_method_re
            name: before
            re: !!perl/hash:RE_string
              i: 0
              text: '['
          - !!perl/hash:RE_method
            name: quibble
            rest: 1
    - !!perl/hash:RE_quantified_atom
      atom: !!perl/hash:RE_method
        name: normspace
        rest: ''
      quant:
      - '?'
cclass_elem_0: *10
infixish: !!perl/hash:RE_ast
  dba: infixish
  dic: STD::Regex
  re: !!perl/hash:RE_sequence
    zyg:
    - !!perl/hash:RE_assertion
      assert: '!'
      re: !!perl/hash:RE_method
        name: infixstopper
        rest: ''
    - !!perl/hash:RE_assertion
      assert: '!'
      re: !!perl/hash:RE_method
        name: stdstopper
        rest: ''
    - !!perl/hash:RE_method
      name: regex_infix
      rest: ''
    - !!perl/hash:RE_block {}
infixstopper: !!perl/hash:RE_ast
  dba: infix stopper
  dic: STD::Regex
  re: !!perl/hash:RE_bracket
    re: &11 !!perl/hash:RE_any
      altname: infixstopper_0
      dba: infix stopper
      dic: STD::Regex
      zyg:
      - !!perl/hash:RE_assertion
        alt: infixstopper_0 0
        assert: '?'
        re: !!perl/hash:RE_method_re
          name: before
          nobind: 1
          re: !!perl/hash:RE_cclass
            i: 0
            text: '[\) \} \]]'
      - !!perl/hash:RE_assertion
        alt: infixstopper_0 1
        assert: '?'
        re: !!perl/hash:RE_method_re
          name: before
          nobind: 1
          re: !!perl/hash:RE_sequence
            zyg:
            - !!perl/hash:RE_string
              i: 0
              text: '>'
            - !!perl/hash:RE_cclass
              i: 0
              text: -[>)]
      - !!perl/hash:RE_assertion
        alt: infixstopper_0 2
        assert: '?'
        re: !!perl/hash:RE_method_re
          name: before
          nobind: 1
          re: !!perl/hash:RE_method
            name: stopper
            rest: ''
infixstopper_0: *11
metachar:*:
  dic: STD::Regex
metachar__S_009Gt: !!perl/hash:RE_ast
  dba: metachar
  dic: STD::Regex
  re: !!perl/hash:RE_sequence
    zyg:
    - !!perl/hash:RE_string
      i: 0
      text: '>'
    - !!perl/hash:RE_assertion
      assert: '!'
      re: !!perl/hash:RE_method_re
        name: before
        nobind: 1
        re: !!perl/hash:RE_string
          i: 0
          text: '>'
    - !!perl/hash:RE_meta
      text: '::'
    - !!perl/hash:RE_method
      name: fail
      rest: ''
metachar__S_010AmpAmp: !!perl/hash:RE_ast
  dba: metachar
  dic: STD::Regex
  re: !!perl/hash:RE_sequence
    zyg:
    - !!perl/hash:RE_string
      i: 0
      text: '&&'
    - !!perl/hash:RE_meta
      text: '::'
    - !!perl/hash:RE_method
      name: fail
      rest: ''
metachar__S_011Amp: !!perl/hash:RE_ast
  dba: metachar
  dic: STD::Regex
  re: !!perl/hash:RE_sequence
    zyg:
    - !!perl/hash:RE_string
      i: 0
      text: '&'
    - !!perl/hash:RE_meta
      text: '::'
    - !!perl/hash:RE_method
      name: fail
      rest: ''
metachar__S_012VertVert: !!perl/hash:RE_ast
  dba: metachar
  dic: STD::Regex
  re: !!perl/hash:RE_sequence
    zyg:
    - !!perl/hash:RE_string
      i: 0
      text: '||'
    - !!perl/hash:RE_meta
      text: '::'
    - !!perl/hash:RE_method
      name: fail
      rest: ''
metachar__S_013Vert: !!perl/hash:RE_ast
  dba: metachar
  dic: STD::Regex
  re: !!perl/hash:RE_sequence
    zyg:
    - !!perl/hash:RE_string
      i: 0
      text: '|'
    - !!perl/hash:RE_meta
      text: '::'
    - !!perl/hash:RE_method
      name: fail
      rest: ''
metachar__S_014Ket: !!perl/hash:RE_ast
  dba: metachar
  dic: STD::Regex
  re: !!perl/hash:RE_sequence
    zyg:
    - !!perl/hash:RE_string
      i: 0
      text: ']'
    - !!perl/hash:RE_meta
      text: '::'
    - !!perl/hash:RE_method
      name: fail
      rest: ''
metachar__S_015Thesis: !!perl/hash:RE_ast
  dba: metachar
  dic: STD::Regex
  re: !!perl/hash:RE_sequence
    zyg:
    - !!perl/hash:RE_string
      i: 0
      text: )
    - !!perl/hash:RE_meta
      text: '::'
    - !!perl/hash:RE_method
      name: fail
      rest: ''
metachar__S_016Semi: !!perl/hash:RE_ast
  dba: metachar
  dic: STD::Regex
  re: !!perl/hash:RE_sequence
    zyg:
    - !!perl/hash:RE_string
      i: 0
      text: ;
    - !!perl/hash:RE_block {}
    - !!perl/hash:RE_bracket
      re: !!perl/hash:RE_first
        zyg:
        - !!perl/hash:RE_sequence
          zyg:
          - !!perl/hash:RE_assertion
            assert: '?'
            re: !!perl/hash:RE_method_re
              name: before
              nobind: 1
              re: !!perl/hash:RE_sequence
                zyg:
                - !!perl/hash:RE_quantified_atom
                  atom: !!perl/hash:RE_meta
                    min: 1
                    text: \N
                  quant:
                  - '*'
                - !!perl/hash:RE_method
                  name: stopper
                  rest: ''
          - !!perl/hash:RE_method
            name: panic
            rest: 1
        - !!perl/hash:RE_sequence
          zyg:
          - !!perl/hash:RE_assertion
            assert: '?'
            re: !!perl/hash:RE_method_re
              name: before
              nobind: 1
              re: !!perl/hash:RE_meta
                min: 1
                text: .
          - !!perl/hash:RE_method
            name: panic
            rest: 1
        - !!perl/hash:RE_method
          name: panic
          rest: 1
metachar__S_017CurStarLy: !!perl/hash:RE_ast
  dba: metachar
  dic: STD::Regex
  re: !!perl/hash:RE_sequence
    zyg:
    - !!perl/hash:RE_bindnamed
      atom: !!perl/hash:RE_method
        i: 0
        name: sym
        rest: ''
        sym: '{*}'
    - !!perl/hash:RE_assertion
      assert: '?'
      re: !!perl/hash:RE_block
        nobind: 1
metachar__S_018BraStarKet: !!perl/hash:RE_ast
  dba: metachar
  dic: STD::Regex
  re: !!perl/hash:RE_sequence
    zyg:
    - !!perl/hash:RE_bindnamed
      atom: !!perl/hash:RE_method
        i: 0
        name: sym
        rest: ''
        sym: '[*]'
    - !!perl/hash:RE_assertion
      assert: '?'
      re: !!perl/hash:RE_block
        nobind: 1
metachar__S_019quant: !!perl/hash:RE_ast
  dba: metachar
  dic: STD::Regex
  re: !!perl/hash:RE_sequence
    zyg:
    - !!perl/hash:RE_method
      name: quantifier
      rest: ''
    - !!perl/hash:RE_method
      name: sorry
      rest: 1
metachar__S_020sigwhite: !!perl/hash:RE_ast
  dba: metachar
  dic: STD::Regex
  re: !!perl/hash:RE_method
    name: normspace
    rest: ''
metachar__S_021unsp: !!perl/hash:RE_ast
  dba: metachar
  dic: STD::Regex
  re: !!perl/hash:RE_method
    name: unsp
    rest: ''
metachar__S_022Cur_Ly: !!perl/hash:RE_ast
  dba: metachar
  dic: STD::Regex
  re: !!perl/hash:RE_sequence
    zyg:
    - !!perl/hash:RE_assertion
      assert: '?'
      re: !!perl/hash:RE_method_re
        name: before
        nobind: 1
        re: !!perl/hash:RE_string
          i: 0
          text: '{'
    - !!perl/hash:RE_method
      name: embeddedblock
      rest: ''
    - !!perl/hash:RE_block {}
metachar__S_023mod: !!perl/hash:RE_ast
  dba: metachar
  dic: STD::Regex
  re: !!perl/hash:RE_sequence
    zyg:
    - !!perl/hash:RE_assertion
      assert: '?'
      re: !!perl/hash:RE_method_re
        name: before
        nobind: 1
        re: !!perl/hash:RE_string
          i: 0
          text: ':'
    - !!perl/hash:RE_method
      name: mod_internal
      rest: ''
    - !!perl/hash:RE_block {}
metachar__S_024Minus: !!perl/hash:RE_ast
  dba: metachar
  dic: STD::Regex
  re: !!perl/hash:RE_sequence
    zyg:
    - !!perl/hash:RE_string
      i: 0
      text: '-'
    - !!perl/hash:RE_assertion
      assert: '?'
      re: !!perl/hash:RE_block
        nobind: 1
    - !!perl/hash:RE_method
      name: sorry
      rest: 1
metachar__S_025Colon: !!perl/hash:RE_ast
  dba: metachar
  dic: STD::Regex
  re: !!perl/hash:RE_sequence
    zyg:
    - !!perl/hash:RE_method
      i: 0
      name: sym
      rest: ''
      sym: ':'
    - !!perl/hash:RE_assertion
      assert: '?'
      re: !!perl/hash:RE_method_re
        name: before
        nobind: 1
        re: !!perl/hash:RE_meta
          min: 1
          text: \s
    - !!perl/hash:RE_method
      name: panic
      rest: 1
metachar__S_026ColonColon: !!perl/hash:RE_ast
  dba: metachar
  dic: STD::Regex
  re: !!perl/hash:RE_method
    i: 0
    name: sym
    rest: ''
    sym: '::'
metachar__S_027ColonColonColon: !!perl/hash:RE_ast
  dba: metachar
  dic: STD::Regex
  re: !!perl/hash:RE_method
    i: 0
    name: sym
    rest: ''
    sym: ':::'
metachar__S_028Bra_Ket: !!perl/hash:RE_ast
  dba: bracketed regex
  dic: STD::Regex
  re: !!perl/hash:RE_sequence
    zyg:
    - !!perl/hash:RE_bracket
      re: !!perl/hash:RE_sequence
        zyg:
        - !!perl/hash:RE_string
          i: 0
          text: '['
        - !!perl/hash:RE_block {}
        - !!perl/hash:RE_method
          name: nibbler
          rest: ''
        - !!perl/hash:RE_bracket
          re: !!perl/hash:RE_first
            zyg:
            - !!perl/hash:RE_string
              i: 0
              text: ']'
            - !!perl/hash:RE_method
              name: FAILGOAL
              rest: 1
    - !!perl/hash:RE_block {}
    - !!perl/hash:RE_block {}
metachar__S_029Paren_Thesis: !!perl/hash:RE_ast
  dba: capture parens
  dic: STD::Regex
  re: !!perl/hash:RE_sequence
    zyg:
    - !!perl/hash:RE_bracket
      re: !!perl/hash:RE_sequence
        zyg:
        - !!perl/hash:RE_string
          i: 0
          text: (
        - !!perl/hash:RE_block {}
        - !!perl/hash:RE_method
          name: nibbler
          rest: ''
        - !!perl/hash:RE_bracket
          re: !!perl/hash:RE_first
            zyg:
            - !!perl/hash:RE_string
              i: 0
              text: )
            - !!perl/hash:RE_method
              name: FAILGOAL
              rest: 1
    - !!perl/hash:RE_block {}
metachar__S_030LtParen: !!perl/hash:RE_ast
  dba: metachar
  dic: STD::Regex
  re: !!perl/hash:RE_string
    i: 0
    text: <(
metachar__S_031ThesisGt: !!perl/hash:RE_ast
  dba: metachar
  dic: STD::Regex
  re: !!perl/hash:RE_string
    i: 0
    text: )>
metachar__S_032LtLt: !!perl/hash:RE_ast
  dba: metachar
  dic: STD::Regex
  re: !!perl/hash:RE_string
    i: 0
    text: <<
metachar__S_033GtGt: !!perl/hash:RE_ast
  dba: metachar
  dic: STD::Regex
  re: !!perl/hash:RE_string
    i: 0
    text: '>>'
metachar__S_034Fre: !!perl/hash:RE_ast
  dba: metachar
  dic: STD::Regex
  re: !!perl/hash:RE_string
    i: 0
    text: «
metachar__S_035Nch: !!perl/hash:RE_ast
  dba: metachar
  dic: STD::Regex
  re: !!perl/hash:RE_string
    i: 0
    text: »
metachar__S_036qw: !!perl/hash:RE_ast
  dba: metachar
  dic: STD::Regex
  re: !!perl/hash:RE_sequence
    zyg:
    - !!perl/hash:RE_assertion
      assert: '?'
      re: !!perl/hash:RE_method_re
        name: before
        nobind: 1
        re: !!perl/hash:RE_sequence
          zyg:
          - !!perl/hash:RE_string
            i: 0
            text: <
          - !!perl/hash:RE_meta
            min: 1
            text: \s
    - !!perl/hash:RE_method
      name: circumfix
      rest: ''
metachar__S_037Lt_Gt: !!perl/hash:RE_ast
  dba: metachar
  dic: STD::Regex
  re: !!perl/hash:RE_bracket
    re: !!perl/hash:RE_sequence
      zyg:
      - !!perl/hash:RE_string
        i: 0
        text: <
      - !!perl/hash:RE_block {}
      - !!perl/hash:RE_method
        name: assertion
        rest: ''
      - !!perl/hash:RE_bracket
        re: !!perl/hash:RE_first
          zyg:
          - !!perl/hash:RE_string
            i: 0
            text: '>'
          - !!perl/hash:RE_method
            name: FAILGOAL
            rest: 1
metachar__S_038Back: !!perl/hash:RE_ast
  dba: metachar
  dic: STD::Regex
  re: !!perl/hash:RE_sequence
    zyg:
    - !!perl/hash:RE_method
      i: 0
      name: sym
      rest: ''
      sym: \
    - !!perl/hash:RE_method
      name: backslash
      rest: ''
metachar__S_039Dot: !!perl/hash:RE_ast
  dba: metachar
  dic: STD::Regex
  re: !!perl/hash:RE_method
    i: 0
    name: sym
    rest: ''
    sym: .
metachar__S_040CaretCaret: !!perl/hash:RE_ast
  dba: metachar
  dic: STD::Regex
  re: !!perl/hash:RE_method
    i: 0
    name: sym
    rest: ''
    sym: ^^
metachar__S_041Caret: !!perl/hash:RE_ast
  dba: metachar
  dic: STD::Regex
  re: !!perl/hash:RE_method
    i: 0
    name: sym
    rest: ''
    sym: ^
metachar__S_042DollarDollar: !!perl/hash:RE_ast
  dba: metachar
  dic: STD::Regex
  re: !!perl/hash:RE_sequence
    zyg:
    - !!perl/hash:RE_method
      i: 0
      name: sym
      rest: ''
      sym: $$
    - !!perl/hash:RE_quantified_atom
      atom: !!perl/hash:RE_bracket
        re: !!perl/hash:RE_sequence
          zyg:
          - !!perl/hash:RE_bindpos
            atom: !!perl/hash:RE_paren
              re: !!perl/hash:RE_quantified_atom
                atom: !!perl/hash:RE_meta
                  min: 1
                  text: \w
                quant:
                - +
          - !!perl/hash:RE_method
            name: obs
            rest: 1
      quant:
      - '?'
metachar__S_043Dollar: !!perl/hash:RE_ast
  dba: metachar
  dic: STD::Regex
  re: !!perl/hash:RE_sequence
    zyg:
    - !!perl/hash:RE_string
      i: 0
      text: $
    - !!perl/hash:RE_assertion
      assert: '?'
      re: !!perl/hash:RE_method_re
        name: before
        nobind: 1
        re: &12 !!perl/hash:RE_any
          altname: metachar__S_043Dollar_0
          dba: metachar
          dic: STD::Regex
          zyg:
          - !!perl/hash:RE_meta
            alt: metachar__S_043Dollar_0 0
            min: 1
            text: \s
          - !!perl/hash:RE_string
            alt: metachar__S_043Dollar_0 1
            i: 0
            text: '|'
          - !!perl/hash:RE_string
            alt: metachar__S_043Dollar_0 2
            i: 0
            text: '&'
          - !!perl/hash:RE_string
            alt: metachar__S_043Dollar_0 3
            i: 0
            text: )
          - !!perl/hash:RE_string
            alt: metachar__S_043Dollar_0 4
            i: 0
            text: ']'
          - !!perl/hash:RE_string
            alt: metachar__S_043Dollar_0 5
            i: 0
            text: '>'
          - !!perl/hash:RE_meta
            alt: metachar__S_043Dollar_0 6
            text: $
          - !!perl/hash:RE_method
            alt: metachar__S_043Dollar_0 7
            name: stopper
            rest: ''
metachar__S_043Dollar_0: *12
metachar__S_044Single_Single: !!perl/hash:RE_ast
  dba: metachar
  dic: STD::Regex
  re: !!perl/hash:RE_sequence
    zyg:
    - !!perl/hash:RE_assertion
      assert: '?'
      re: !!perl/hash:RE_method_re
        name: before
        nobind: 1
        re: !!perl/hash:RE_double
          i: 0
          text: ''''
    - !!perl/hash:RE_bracket
      re: !!perl/hash:RE_sequence
        zyg:
        - !!perl/hash:RE_decl {}
        - !!perl/hash:RE_method
          name: quote
          rest: ''
metachar__S_045Double_Double: !!perl/hash:RE_ast
  dba: metachar
  dic: STD::Regex
  re: !!perl/hash:RE_sequence
    zyg:
    - !!perl/hash:RE_assertion
      assert: '?'
      re: !!perl/hash:RE_method_re
        name: before
        nobind: 1
        re: !!perl/hash:RE_string
          i: 0
          text: '"'
    - !!perl/hash:RE_bracket
      re: !!perl/hash:RE_sequence
        zyg:
        - !!perl/hash:RE_decl {}
        - !!perl/hash:RE_method
          name: quote
          rest: ''
metachar__S_046var: !!perl/hash:RE_ast
  dba: metachar
  dic: STD::Regex
  re: !!perl/hash:RE_sequence
    zyg:
    - !!perl/hash:RE_assertion
      assert: '!'
      re: !!perl/hash:RE_method_re
        name: before
        nobind: 1
        re: !!perl/hash:RE_string
          i: 0
          text: $$
    - !!perl/hash:RE_assertion
      assert: '?'
      re: !!perl/hash:RE_method_re
        name: before
        nobind: 1
        re: !!perl/hash:RE_method
          name: sigil
          rest: ''
    - !!perl/hash:RE_bracket
      re: !!perl/hash:RE_sequence
        zyg:
        - !!perl/hash:RE_decl {}
        - !!perl/hash:RE_method
          name: variable
          rest: ''
    - !!perl/hash:RE_block {}
    - !!perl/hash:RE_bracket
      re: !!perl/hash:RE_first
        zyg:
        - !!perl/hash:RE_sequence
          zyg:
          - !!perl/hash:RE_bindnamed
            atom: !!perl/hash:RE_paren
              re: !!perl/hash:RE_sequence
                zyg:
                - !!perl/hash:RE_quantified_atom
                  atom: !!perl/hash:RE_meta
                    min: 1
                    text: \s
                  quant:
                  - '*'
                - !!perl/hash:RE_string
                  i: 0
                  text: =
                - !!perl/hash:RE_quantified_atom
                  atom: !!perl/hash:RE_meta
                    min: 1
                    text: \s
                  quant:
                  - '*'
                - !!perl/hash:RE_method
                  name: quantified_atom
                  rest: ''
          - !!perl/hash:RE_block {}
        - !!perl/hash:RE_sequence
          zyg:
          - !!perl/hash:RE_block {}
          - !!perl/hash:RE_quantified_atom
            atom: !!perl/hash:RE_bracket
              re: !!perl/hash:RE_sequence
                zyg:
                - !!perl/hash:RE_assertion
                  assert: '?'
                  re: !!perl/hash:RE_method_re
                    name: before
                    nobind: 1
                    re: !!perl/hash:RE_sequence
                      zyg:
                      - !!perl/hash:RE_quantified_atom
                        atom: !!perl/hash:RE_string
                          i: 0
                          text: .
                        quant:
                        - '?'
                      - !!perl/hash:RE_cclass
                        i: 0
                        text: '[ \[ \{ \< ]'
                - !!perl/hash:RE_method
                  name: worry
                  rest: 1
            quant:
            - '?'
mod_arg: !!perl/hash:RE_ast
  dba: modifier argument
  dic: STD::Regex
  re: !!perl/hash:RE_bracket
    re: !!perl/hash:RE_sequence
      zyg:
      - !!perl/hash:RE_string
        i: 0
        text: (
      - !!perl/hash:RE_block {}
      - !!perl/hash:RE_bracket
        re: !!perl/hash:RE_sequence
          zyg:
          - !!perl/hash:RE_decl {}
          - !!perl/hash:RE_method
            name: semilist
            rest: ''
      - !!perl/hash:RE_bracket
        re: !!perl/hash:RE_first
          zyg:
          - !!perl/hash:RE_string
            i: 0
            text: )
          - !!perl/hash:RE_method
            name: FAILGOAL
            rest: 1
mod_internal:*:
  dic: STD::Regex
mod_internal__S_090Colonmy: !!perl/hash:RE_ast
  dba: mod_internal
  dic: STD::Regex
  re: !!perl/hash:RE_sequence
    zyg:
    - !!perl/hash:RE_string
      i: 0
      text: ':'
    - !!perl/hash:RE_assertion
      assert: '?'
      re: !!perl/hash:RE_method_re
        name: before
        nobind: 1
        re: !!perl/hash:RE_sequence
          zyg:
          - !!perl/hash:RE_bracket
            re: &13 !!perl/hash:RE_any
              altname: mod_internal__S_090Colonmy_0
              dba: mod_internal
              dic: STD::Regex
              zyg:
              - !!perl/hash:RE_string
                alt: mod_internal__S_090Colonmy_0 0
                i: 0
                text: my
              - !!perl/hash:RE_string
                alt: mod_internal__S_090Colonmy_0 1
                i: 0
                text: state
              - !!perl/hash:RE_string
                alt: mod_internal__S_090Colonmy_0 2
                i: 0
                text: our
              - !!perl/hash:RE_string
                alt: mod_internal__S_090Colonmy_0 3
                i: 0
                text: anon
              - !!perl/hash:RE_string
                alt: mod_internal__S_090Colonmy_0 4
                i: 0
                text: constant
              - !!perl/hash:RE_string
                alt: mod_internal__S_090Colonmy_0 5
                i: 0
                text: temp
              - !!perl/hash:RE_string
                alt: mod_internal__S_090Colonmy_0 6
                i: 0
                text: let
          - !!perl/hash:RE_meta
            min: 1
            text: \s
    - !!perl/hash:RE_bracket
      re: !!perl/hash:RE_sequence
        zyg:
        - !!perl/hash:RE_decl {}
        - !!perl/hash:RE_method
          name: statement
          rest: ''
        - !!perl/hash:RE_method
          name: eat_terminator
          rest: ''
mod_internal__S_090Colonmy_0: *13
mod_internal__S_091Coloni: !!perl/hash:RE_ast
  dba: mod_internal
  dic: STD::Regex
  re: !!perl/hash:RE_sequence
    zyg:
    - !!perl/hash:RE_bindnamed
      atom: !!perl/hash:RE_bracket
        re: &14 !!perl/hash:RE_any
          altname: mod_internal__S_091Coloni_0
          dba: mod_internal
          dic: STD::Regex
          zyg:
          - !!perl/hash:RE_string
            alt: mod_internal__S_091Coloni_0 0
            i: 0
            text: :i
          - !!perl/hash:RE_string
            alt: mod_internal__S_091Coloni_0 1
            i: 0
            text: :ignorecase
    - !!perl/hash:RE_meta
      text: »
    - !!perl/hash:RE_block {}
mod_internal__S_091Coloni_0: *14
mod_internal__S_092ColonBangi: !!perl/hash:RE_ast
  dba: mod_internal
  dic: STD::Regex
  re: !!perl/hash:RE_sequence
    zyg:
    - !!perl/hash:RE_bindnamed
      atom: !!perl/hash:RE_bracket
        re: &15 !!perl/hash:RE_any
          altname: mod_internal__S_092ColonBangi_0
          dba: mod_internal
          dic: STD::Regex
          zyg:
          - !!perl/hash:RE_string
            alt: mod_internal__S_092ColonBangi_0 0
            i: 0
            text: :!i
          - !!perl/hash:RE_string
            alt: mod_internal__S_092ColonBangi_0 1
            i: 0
            text: :!ignorecase
    - !!perl/hash:RE_meta
      text: »
    - !!perl/hash:RE_block {}
mod_internal__S_092ColonBangi_0: *15
mod_internal__S_093ColoniParen_Thesis: !!perl/hash:RE_ast
  dba: mod_internal
  dic: STD::Regex
  re: !!perl/hash:RE_sequence
    zyg:
    - !!perl/hash:RE_bindnamed
      atom: !!perl/hash:RE_bracket
        re: &16 !!perl/hash:RE_any
          altname: mod_internal__S_093ColoniParen_Thesis_0
          dba: mod_internal
          dic: STD::Regex
          zyg:
          - !!perl/hash:RE_string
            alt: mod_internal__S_093ColoniParen_Thesis_0 0
            i: 0
            text: :i
          - !!perl/hash:RE_string
            alt: mod_internal__S_093ColoniParen_Thesis_0 1
            i: 0
            text: :ignorecase
    - !!perl/hash:RE_method
      name: mod_arg
      rest: ''
    - !!perl/hash:RE_block {}
mod_internal__S_093ColoniParen_Thesis_0: *16
mod_internal__S_094Colon0i: !!perl/hash:RE_ast
  dba: mod_internal
  dic: STD::Regex
  re: !!perl/hash:RE_sequence
    zyg:
    - !!perl/hash:RE_string
      i: 0
      text: ':'
    - !!perl/hash:RE_bindpos
      atom: !!perl/hash:RE_paren
        re: !!perl/hash:RE_quantified_atom
          atom: !!perl/hash:RE_meta
            min: 1
            text: \d
          quant:
          - +
    - !!perl/hash:RE_bracket
      re: &17 !!perl/hash:RE_any
        altname: mod_internal__S_094Colon0i_0
        dba: mod_internal
        dic: STD::Regex
        zyg:
        - !!perl/hash:RE_string
          alt: mod_internal__S_094Colon0i_0 0
          i: 0
          text: i
        - !!perl/hash:RE_string
          alt: mod_internal__S_094Colon0i_0 1
          i: 0
          text: ignorecase
    - !!perl/hash:RE_block {}
mod_internal__S_094Colon0i_0: *17
mod_internal__S_095Colona: !!perl/hash:RE_ast
  dba: mod_internal
  dic: STD::Regex
  re: !!perl/hash:RE_sequence
    zyg:
    - !!perl/hash:RE_bindnamed
      atom: !!perl/hash:RE_bracket
        re: &18 !!perl/hash:RE_any
          altname: mod_internal__S_095Colona_0
          dba: mod_internal
          dic: STD::Regex
          zyg:
          - !!perl/hash:RE_string
            alt: mod_internal__S_095Colona_0 0
            i: 0
            text: :a
          - !!perl/hash:RE_string
            alt: mod_internal__S_095Colona_0 1
            i: 0
            text: :ignoreaccent
    - !!perl/hash:RE_meta
      text: »
    - !!perl/hash:RE_block {}
mod_internal__S_095Colona_0: *18
mod_internal__S_096ColonBanga: !!perl/hash:RE_ast
  dba: mod_internal
  dic: STD::Regex
  re: !!perl/hash:RE_sequence
    zyg:
    - !!perl/hash:RE_bindnamed
      atom: !!perl/hash:RE_bracket
        re: &19 !!perl/hash:RE_any
          altname: mod_internal__S_096ColonBanga_0
          dba: mod_internal
          dic: STD::Regex
          zyg:
          - !!perl/hash:RE_string
            alt: mod_internal__S_096ColonBanga_0 0
            i: 0
            text: :!a
          - !!perl/hash:RE_string
            alt: mod_internal__S_096ColonBanga_0 1
            i: 0
            text: :!ignoreaccent
    - !!perl/hash:RE_meta
      text: »
    - !!perl/hash:RE_block {}
mod_internal__S_096ColonBanga_0: *19
mod_internal__S_097ColonaParen_Thesis: !!perl/hash:RE_ast
  dba: mod_internal
  dic: STD::Regex
  re: !!perl/hash:RE_sequence
    zyg:
    - !!perl/hash:RE_bindnamed
      atom: !!perl/hash:RE_bracket
        re: &20 !!perl/hash:RE_any
          altname: mod_internal__S_097ColonaParen_Thesis_0
          dba: mod_internal
          dic: STD::Regex
          zyg:
          - !!perl/hash:RE_string
            alt: mod_internal__S_097ColonaParen_Thesis_0 0
            i: 0
            text: :a
          - !!perl/hash:RE_string
            alt: mod_internal__S_097ColonaParen_Thesis_0 1
            i: 0
            text: :ignoreaccent
    - !!perl/hash:RE_method
      name: mod_arg
      rest: ''
    - !!perl/hash:RE_block {}
mod_internal__S_097ColonaParen_Thesis_0: *20
mod_internal__S_098Colon0a: !!perl/hash:RE_ast
  dba: mod_internal
  dic: STD::Regex
  re: !!perl/hash:RE_sequence
    zyg:
    - !!perl/hash:RE_string
      i: 0
      text: ':'
    - !!perl/hash:RE_bindpos
      atom: !!perl/hash:RE_paren
        re: !!perl/hash:RE_quantified_atom
          atom: !!perl/hash:RE_meta
            min: 1
            text: \d
          quant:
          - +
    - !!perl/hash:RE_bracket
      re: &21 !!perl/hash:RE_any
        altname: mod_internal__S_098Colon0a_0
        dba: mod_internal
        dic: STD::Regex
        zyg:
        - !!perl/hash:RE_string
          alt: mod_internal__S_098Colon0a_0 0
          i: 0
          text: a
        - !!perl/hash:RE_string
          alt: mod_internal__S_098Colon0a_0 1
          i: 0
          text: ignoreaccent
    - !!perl/hash:RE_block {}
mod_internal__S_098Colon0a_0: *21
mod_internal__S_099Colons: !!perl/hash:RE_ast
  dba: mod_internal
  dic: STD::Regex
  re: !!perl/hash:RE_sequence
    zyg:
    - !!perl/hash:RE_string
      i: 0
      text: :s
    - !!perl/hash:RE_quantified_atom
      atom: !!perl/hash:RE_string
        i: 0
        text: igspace
      quant:
      - '?'
    - !!perl/hash:RE_meta
      text: »
    - !!perl/hash:RE_block {}
mod_internal__S_100ColonBangs: !!perl/hash:RE_ast
  dba: mod_internal
  dic: STD::Regex
  re: !!perl/hash:RE_sequence
    zyg:
    - !!perl/hash:RE_string
      i: 0
      text: :!s
    - !!perl/hash:RE_quantified_atom
      atom: !!perl/hash:RE_string
        i: 0
        text: igspace
      quant:
      - '?'
    - !!perl/hash:RE_meta
      text: »
    - !!perl/hash:RE_block {}
mod_internal__S_101ColonsParen_Thesis: !!perl/hash:RE_ast
  dba: mod_internal
  dic: STD::Regex
  re: !!perl/hash:RE_sequence
    zyg:
    - !!perl/hash:RE_string
      i: 0
      text: :s
    - !!perl/hash:RE_quantified_atom
      atom: !!perl/hash:RE_string
        i: 0
        text: igspace
      quant:
      - '?'
    - !!perl/hash:RE_method
      name: mod_arg
      rest: ''
    - !!perl/hash:RE_block {}
mod_internal__S_102Colon0s: !!perl/hash:RE_ast
  dba: mod_internal
  dic: STD::Regex
  re: !!perl/hash:RE_sequence
    zyg:
    - !!perl/hash:RE_string
      i: 0
      text: ':'
    - !!perl/hash:RE_bindpos
      atom: !!perl/hash:RE_paren
        re: !!perl/hash:RE_quantified_atom
          atom: !!perl/hash:RE_meta
            min: 1
            text: \d
          quant:
          - +
    - !!perl/hash:RE_string
      i: 0
      text: s
    - !!perl/hash:RE_quantified_atom
      atom: !!perl/hash:RE_string
        i: 0
        text: igspace
      quant:
      - '?'
    - !!perl/hash:RE_meta
      text: »
    - !!perl/hash:RE_block {}
mod_internal__S_103Colonr: !!perl/hash:RE_ast
  dba: mod_internal
  dic: STD::Regex
  re: !!perl/hash:RE_sequence
    zyg:
    - !!perl/hash:RE_string
      i: 0
      text: :r
    - !!perl/hash:RE_quantified_atom
      atom: !!perl/hash:RE_string
        i: 0
        text: atchet
      quant:
      - '?'
    - !!perl/hash:RE_meta
      text: »
    - !!perl/hash:RE_block {}
mod_internal__S_104ColonBangr: !!perl/hash:RE_ast
  dba: mod_internal
  dic: STD::Regex
  re: !!perl/hash:RE_sequence
    zyg:
    - !!perl/hash:RE_string
      i: 0
      text: :!r
    - !!perl/hash:RE_quantified_atom
      atom: !!perl/hash:RE_string
        i: 0
        text: atchet
      quant:
      - '?'
    - !!perl/hash:RE_meta
      text: »
    - !!perl/hash:RE_block {}
mod_internal__S_105ColonrParen_Thesis: !!perl/hash:RE_ast
  dba: mod_internal
  dic: STD::Regex
  re: !!perl/hash:RE_sequence
    zyg:
    - !!perl/hash:RE_string
      i: 0
      text: :r
    - !!perl/hash:RE_quantified_atom
      atom: !!perl/hash:RE_string
        i: 0
        text: atchet
      quant:
      - '?'
    - !!perl/hash:RE_meta
      text: »
    - !!perl/hash:RE_method
      name: mod_arg
      rest: ''
    - !!perl/hash:RE_block {}
mod_internal__S_106Colon0r: !!perl/hash:RE_ast
  dba: mod_internal
  dic: STD::Regex
  re: !!perl/hash:RE_sequence
    zyg:
    - !!perl/hash:RE_string
      i: 0
      text: ':'
    - !!perl/hash:RE_bindpos
      atom: !!perl/hash:RE_paren
        re: !!perl/hash:RE_quantified_atom
          atom: !!perl/hash:RE_meta
            min: 1
            text: \d
          quant:
          - +
    - !!perl/hash:RE_string
      i: 0
      text: r
    - !!perl/hash:RE_quantified_atom
      atom: !!perl/hash:RE_string
        i: 0
        text: atchet
      quant:
      - '?'
    - !!perl/hash:RE_meta
      text: »
    - !!perl/hash:RE_block {}
mod_internal__S_107ColonPerl5: !!perl/hash:RE_ast
  dba: mod_internal
  dic: STD::Regex
  re: !!perl/hash:RE_sequence
    zyg:
    - !!perl/hash:RE_bracket
      re: &22 !!perl/hash:RE_any
        altname: mod_internal__S_107ColonPerl5_0
        dba: mod_internal
        dic: STD::Regex
        zyg:
        - !!perl/hash:RE_string
          alt: mod_internal__S_107ColonPerl5_0 0
          i: 0
          text: :Perl5
        - !!perl/hash:RE_string
          alt: mod_internal__S_107ColonPerl5_0 1
          i: 0
          text: :P5
    - !!perl/hash:RE_method
      name: require_P5
      rest: ''
    - !!perl/hash:RE_bracket
      re: !!perl/hash:RE_sequence
        zyg:
        - !!perl/hash:RE_decl {}
        - !!perl/hash:RE_method
          name: nibbler
          rest: ''
mod_internal__S_107ColonPerl5_0: *22
mod_internal__S_108p6adv: !!perl/hash:RE_ast
  dba: mod_internal
  dic: STD::Regex
  re: !!perl/hash:RE_sequence
    zyg:
    - !!perl/hash:RE_assertion
      assert: '?'
      re: !!perl/hash:RE_method_re
        name: before
        nobind: 1
        re: !!perl/hash:RE_sequence
          zyg:
          - !!perl/hash:RE_string
            i: 0
            text: ':'
          - !!perl/hash:RE_bracket
            re: &23 !!perl/hash:RE_any
              altname: mod_internal__S_108p6adv_0
              dba: mod_internal
              dic: STD::Regex
              zyg:
              - !!perl/hash:RE_string
                alt: mod_internal__S_108p6adv_0 0
                i: 0
                text: dba
              - !!perl/hash:RE_string
                alt: mod_internal__S_108p6adv_0 1
                i: 0
                text: lang
          - !!perl/hash:RE_meta
            text: »
    - !!perl/hash:RE_bracket
      re: !!perl/hash:RE_sequence
        zyg:
        - !!perl/hash:RE_decl {}
        - !!perl/hash:RE_method
          name: quotepair
          rest: ''
    - !!perl/hash:RE_block {}
mod_internal__S_108p6adv_0: *23
mod_internal__S_109oops: !!perl/hash:RE_ast
  dba: mod_internal
  dic: STD::Regex
  re: !!perl/hash:RE_sequence
    zyg:
    - !!perl/hash:RE_block {}
    - !!perl/hash:RE_bindpos
      atom: !!perl/hash:RE_paren
        re: !!perl/hash:RE_sequence
          zyg:
          - !!perl/hash:RE_string
            i: 0
            text: ':'
          - !!perl/hash:RE_quantified_atom
            atom: !!perl/hash:RE_meta
              min: 1
              text: \w
            quant:
            - +
    - !!perl/hash:RE_method
      name: sorry
      rest: 1
nibbler: !!perl/hash:RE_ast
  dba: nibbler
  dic: STD::Regex
  re: !!perl/hash:RE_sequence
    zyg:
    - !!perl/hash:RE_method
      name: ws
      rest: ''
    - !!perl/hash:RE_quantified_atom
      atom: !!perl/hash:RE_bracket
        re: !!perl/hash:RE_sequence
          zyg:
          - !!perl/hash:RE_method
            name: ws
            rest: ''
          - !!perl/hash:RE_quantified_atom
            atom: !!perl/hash:RE_method
              name: normspace
              rest: ''
            quant:
            - '?'
          - !!perl/hash:RE_method
            name: ws
            rest: ''
          - !!perl/hash:RE_qw
            min: 1
            text: < || | && & >
          - !!perl/hash:RE_method
            name: ws
            rest: ''
      quant:
      - '?'
    - !!perl/hash:RE_method
      name: ws
      rest: ''
    - !!perl/hash:RE_method
      name: EXPR
      rest: ''
    - !!perl/hash:RE_method
      name: ws
      rest: ''
    - !!perl/hash:RE_bracket
      re: !!perl/hash:RE_first
        zyg:
        - !!perl/hash:RE_assertion
          assert: '?'
          re: !!perl/hash:RE_method
            name: infixstopper
            rest: ''
        - !!perl/hash:RE_sequence
          zyg:
          - !!perl/hash:RE_meta
            text: $$
          - !!perl/hash:RE_method
            name: ws
            rest: ''
          - !!perl/hash:RE_method
            name: panic
            rest: 1
          - !!perl/hash:RE_method
            name: ws
            rest: ''
        - !!perl/hash:RE_sequence
          zyg:
          - !!perl/hash:RE_bindpos
            atom: !!perl/hash:RE_paren
              re: !!perl/hash:RE_meta
                min: 1
                text: \W
          - !!perl/hash:RE_method
            name: sorry
            rest: 1
          - !!perl/hash:RE_method
            name: ws
            rest: ''
        - !!perl/hash:RE_sequence
          zyg:
          - !!perl/hash:RE_method
            name: panic
            rest: 1
          - !!perl/hash:RE_method
            name: ws
            rest: ''
normspace: !!perl/hash:RE_ast
  dba: normspace
  dic: STD::Regex
  re: !!perl/hash:RE_sequence
    zyg:
    - !!perl/hash:RE_assertion
      assert: '?'
      re: !!perl/hash:RE_method_re
        name: before
        nobind: 1
        re: &24 !!perl/hash:RE_any
          altname: normspace_0
          dba: normspace
          dic: STD::Regex
          zyg:
          - !!perl/hash:RE_meta
            alt: normspace_0 0
            min: 1
            text: \s
          - !!perl/hash:RE_string
            alt: normspace_0 1
            i: 0
            text: '#'
    - !!perl/hash:RE_bracket
      re: !!perl/hash:RE_sequence
        zyg:
        - !!perl/hash:RE_decl {}
        - !!perl/hash:RE_method
          name: ws
          rest: ''
normspace_0: *24
quant_atom_list: !!perl/hash:RE_ast
  dba: quant_atom_list
  dic: STD::Regex
  re: !!perl/hash:RE_quantified_atom
    atom: !!perl/hash:RE_method
      name: quantified_atom
      rest: ''
    quant:
    - +
quantified_atom: !!perl/hash:RE_ast
  dba: quantified_atom
  dic: STD::Regex
  re: !!perl/hash:RE_sequence
    zyg:
    - !!perl/hash:RE_assertion
      assert: '!'
      re: !!perl/hash:RE_method
        name: stopper
        rest: ''
    - !!perl/hash:RE_assertion
      assert: '!'
      re: !!perl/hash:RE_method
        name: regex_infix
        rest: ''
    - !!perl/hash:RE_method
      name: atom
      rest: ''
    - !!perl/hash:RE_quantified_atom
      atom: !!perl/hash:RE_bracket
        re: !!perl/hash:RE_sequence
          zyg:
          - !!perl/hash:RE_quantified_atom
            atom: !!perl/hash:RE_method
              name: normspace
              rest: ''
            quant:
            - '?'
          - !!perl/hash:RE_method
            name: quantifier
            rest: ''
      quant:
      - '?'
quantifier:*:
  dic: STD::Regex
quantifier__S_110Star: !!perl/hash:RE_ast
  dba: quantifier
  dic: STD::Regex
  re: !!perl/hash:RE_sequence
    zyg:
    - !!perl/hash:RE_method
      i: 0
      name: sym
      rest: ''
      sym: '*'
    - !!perl/hash:RE_method
      name: quantmod
      rest: ''
quantifier__S_111Plus: !!perl/hash:RE_ast
  dba: quantifier
  dic: STD::Regex
  re: !!perl/hash:RE_sequence
    zyg:
    - !!perl/hash:RE_method
      i: 0
      name: sym
      rest: ''
      sym: +
    - !!perl/hash:RE_method
      name: quantmod
      rest: ''
quantifier__S_112Question: !!perl/hash:RE_ast
  dba: quantifier
  dic: STD::Regex
  re: !!perl/hash:RE_sequence
    zyg:
    - !!perl/hash:RE_method
      i: 0
      name: sym
      rest: ''
      sym: '?'
    - !!perl/hash:RE_method
      name: quantmod
      rest: ''
quantifier__S_113Colon: !!perl/hash:RE_ast
  dba: quantifier
  dic: STD::Regex
  re: !!perl/hash:RE_sequence
    zyg:
    - !!perl/hash:RE_method
      i: 0
      name: sym
      rest: ''
      sym: ':'
    - !!perl/hash:RE_block {}
    - !!perl/hash:RE_assertion
      assert: '?'
      re: !!perl/hash:RE_method_re
        name: before
        nobind: 1
        re: !!perl/hash:RE_meta
          min: 1
          text: \s
quantifier__S_114StarStar: !!perl/hash:RE_ast
  dba: quantifier
  dic: STD::Regex
  re: !!perl/hash:RE_sequence
    zyg:
    - !!perl/hash:RE_method
      i: 0
      name: sym
      rest: ''
      sym: '**'
    - !!perl/hash:RE_meta
      text: '::'
    - !!perl/hash:RE_quantified_atom
      atom: !!perl/hash:RE_method
        name: normspace
        rest: ''
      quant:
      - '?'
    - !!perl/hash:RE_method
      name: quantmod
      rest: ''
    - !!perl/hash:RE_quantified_atom
      atom: !!perl/hash:RE_method
        name: normspace
        rest: ''
      quant:
      - '?'
    - !!perl/hash:RE_bracket
      re: &25 !!perl/hash:RE_any
        altname: quantifier__S_114StarStar_0
        dba: quantifier
        dic: STD::Regex
        zyg:
        - !!perl/hash:RE_sequence
          alt: quantifier__S_114StarStar_0 0
          zyg:
          - !!perl/hash:RE_quantified_atom
            atom: !!perl/hash:RE_meta
              min: 1
              text: \d
            quant:
            - +
          - !!perl/hash:RE_quantified_atom
            atom: !!perl/hash:RE_meta
              min: 1
              text: \s
            quant:
            - +
          - !!perl/hash:RE_string
            i: 0
            text: ..
          - !!perl/hash:RE_method
            name: panic
            rest: 1
        - !!perl/hash:RE_sequence
          alt: quantifier__S_114StarStar_0 1
          zyg:
          - !!perl/hash:RE_bindpos
            atom: !!perl/hash:RE_paren
              re: !!perl/hash:RE_quantified_atom
                atom: !!perl/hash:RE_meta
                  min: 1
                  text: \d
                quant:
                - +
          - !!perl/hash:RE_quantified_atom
            atom: !!perl/hash:RE_bracket
              re: !!perl/hash:RE_sequence
                zyg:
                - !!perl/hash:RE_string
                  i: 0
                  text: ..
                - !!perl/hash:RE_bracket
                  re: &26 !!perl/hash:RE_any
                    altname: quantifier__S_114StarStar_1
                    dba: quantifier
                    dic: STD::Regex
                    zyg:
                    - !!perl/hash:RE_sequence
                      alt: quantifier__S_114StarStar_1 0
                      zyg:
                      - !!perl/hash:RE_bindpos
                        atom: !!perl/hash:RE_paren
                          re: !!perl/hash:RE_quantified_atom
                            atom: !!perl/hash:RE_meta
                              min: 1
                              text: \d
                            quant:
                            - +
                      - !!perl/hash:RE_block {}
                    - !!perl/hash:RE_string
                      alt: quantifier__S_114StarStar_1 1
                      i: 0
                      text: '*'
                    - !!perl/hash:RE_method
                      alt: quantifier__S_114StarStar_1 2
                      name: panic
                      rest: 1
            quant:
            - '?'
        - !!perl/hash:RE_method
          alt: quantifier__S_114StarStar_0 2
          name: embeddedblock
          rest: ''
        - !!perl/hash:RE_method
          alt: quantifier__S_114StarStar_0 3
          name: quantified_atom
          rest: ''
quantifier__S_114StarStar_0: *25
quantifier__S_114StarStar_1: *26
quantifier__S_115Tilde: !!perl/hash:RE_ast
  dba: quantifier
  dic: STD::Regex
  re: !!perl/hash:RE_sequence
    zyg:
    - !!perl/hash:RE_method
      i: 0
      name: sym
      rest: ''
      sym: '~'
    - !!perl/hash:RE_meta
      text: '::'
    - !!perl/hash:RE_quantified_atom
      atom: !!perl/hash:RE_method
        name: normspace
        rest: ''
      quant:
      - '?'
    - !!perl/hash:RE_method
      name: quantified_atom
      rest: ''
    - !!perl/hash:RE_quantified_atom
      atom: !!perl/hash:RE_method
        name: normspace
        rest: ''
      quant:
      - '?'
    - !!perl/hash:RE_method
      name: quantified_atom
      rest: ''
quantifier__S_116TildeTilde: !!perl/hash:RE_ast
  dba: quantifier
  dic: STD::Regex
  re: !!perl/hash:RE_sequence
    zyg:
    - !!perl/hash:RE_bracket
      re: &27 !!perl/hash:RE_any
        altname: quantifier__S_116TildeTilde_0
        dba: quantifier
        dic: STD::Regex
        zyg:
        - !!perl/hash:RE_sequence
          alt: quantifier__S_116TildeTilde_0 0
          zyg:
          - !!perl/hash:RE_string
            i: 0
            text: '!'
          - !!perl/hash:RE_method
            i: 0
            name: sym
            rest: ''
            sym: ~~
        - !!perl/hash:RE_method
          alt: quantifier__S_116TildeTilde_0 1
          i: 0
          name: sym
          rest: ''
          sym: ~~
    - !!perl/hash:RE_method
      name: normspace
      rest: ''
    - !!perl/hash:RE_method
      name: quantified_atom
      rest: ''
quantifier__S_116TildeTilde_0: *27
quantifier__S_117CurNCommaMLy: !!perl/hash:RE_ast
  dba: quantifier
  dic: STD::Regex
  re: !!perl/hash:RE_sequence
    zyg:
    - !!perl/hash:RE_block {}
    - !!perl/hash:RE_string
      i: 0
      text: '{'
    - !!perl/hash:RE_bindpos
      atom: !!perl/hash:RE_paren
        re: !!perl/hash:RE_quantified_atom
          atom: !!perl/hash:RE_meta
            min: 1
            text: \d
          quant:
          - +
    - !!perl/hash:RE_bindpos
      atom: !!perl/hash:RE_paren
        re: !!perl/hash:RE_quantified_atom
          atom: !!perl/hash:RE_string
            i: 0
            text: ','
          quant:
          - '?'
    - !!perl/hash:RE_bindpos
      atom: !!perl/hash:RE_paren
        re: !!perl/hash:RE_quantified_atom
          atom: !!perl/hash:RE_meta
            min: 1
            text: \d
          quant:
          - '*'
    - !!perl/hash:RE_string
      i: 0
      text: '}'
    - !!perl/hash:RE_block {}
quantmod: !!perl/hash:RE_ast
  dba: quantmod
  dic: STD::Regex
  re: !!perl/hash:RE_sequence
    zyg:
    - !!perl/hash:RE_quantified_atom
      atom: !!perl/hash:RE_string
        i: 0
        text: ':'
      quant:
      - '?'
    - !!perl/hash:RE_quantified_atom
      atom: !!perl/hash:RE_bracket
        re: &28 !!perl/hash:RE_any
          altname: quantmod_0
          dba: quantmod
          dic: STD::Regex
          zyg:
          - !!perl/hash:RE_string
            alt: quantmod_0 0
            i: 0
            text: '?'
          - !!perl/hash:RE_string
            alt: quantmod_0 1
            i: 0
            text: '!'
          - !!perl/hash:RE_string
            alt: quantmod_0 2
            i: 0
            text: +
      quant:
      - '?'
quantmod_0: *28
regex_infix:*:
  dic: STD::Regex
regex_infix__S_005VertVert: !!perl/hash:RE_ast
  dba: regex_infix
  dic: STD::Regex
  re: !!perl/hash:RE_sequence
    zyg:
    - !!perl/hash:RE_method
      i: 0
      name: sym
      rest: ''
      sym: '||'
    - !!perl/hash:RE_method
      name: O
      rest: 1
regex_infix__S_006AmpAmp: !!perl/hash:RE_ast
  dba: regex_infix
  dic: STD::Regex
  re: !!perl/hash:RE_sequence
    zyg:
    - !!perl/hash:RE_method
      i: 0
      name: sym
      rest: ''
      sym: '&&'
    - !!perl/hash:RE_method
      name: O
      rest: 1
regex_infix__S_007Vert: !!perl/hash:RE_ast
  dba: regex_infix
  dic: STD::Regex
  re: !!perl/hash:RE_sequence
    zyg:
    - !!perl/hash:RE_method
      i: 0
      name: sym
      rest: ''
      sym: '|'
    - !!perl/hash:RE_method
      name: O
      rest: 1
regex_infix__S_008Amp: !!perl/hash:RE_ast
  dba: regex_infix
  dic: STD::Regex
  re: !!perl/hash:RE_sequence
    zyg:
    - !!perl/hash:RE_method
      i: 0
      name: sym
      rest: ''
      sym: '&'
    - !!perl/hash:RE_method
      name: O
      rest: 1
sign: !!perl/hash:RE_ast
  dba: sign
  dic: STD::Regex
  re: &29 !!perl/hash:RE_any
    altname: sign_0
    dba: sign
    dic: STD::Regex
    zyg:
    - !!perl/hash:RE_string
      alt: sign_0 0
      i: 0
      text: +
    - !!perl/hash:RE_string
      alt: sign_0 1
      i: 0
      text: '-'
    - !!perl/hash:RE_assertion
      alt: sign_0 2
      assert: '?'
      re: !!perl/hash:RE_noop
        nobind: 1
sign_0: *29
termish: !!perl/hash:RE_ast
  dba: termish
  dic: STD::Regex
  re: !!perl/hash:RE_sequence
    zyg:
    - !!perl/hash:RE_method
      name: ws
      rest: ''
    - !!perl/hash:RE_bracket
      re: !!perl/hash:RE_first
        zyg:
        - !!perl/hash:RE_sequence
          zyg:
          - !!perl/hash:RE_bindnamed
            atom: !!perl/hash:RE_method
              name: quant_atom_list
              rest: ''
          - !!perl/hash:RE_assertion
            assert: '?'
            re: !!perl/hash:RE_block
              nobind: 1
        - !!perl/hash:RE_sequence
          zyg:
          - !!perl/hash:RE_quantified_atom
            atom: !!perl/hash:RE_method
              name: normspace
              rest: ''
            quant:
            - '?'
          - !!perl/hash:RE_bracket
            re: !!perl/hash:RE_first
              zyg:
              - !!perl/hash:RE_sequence
                zyg:
                - !!perl/hash:RE_assertion
                  assert: '?'
                  re: !!perl/hash:RE_method_re
                    name: before
                    nobind: 1
                    re: &30 !!perl/hash:RE_any
                      altname: termish_0
                      dba: termish
                      dic: STD::Regex
                      zyg:
                      - !!perl/hash:RE_method
                        alt: termish_0 0
                        name: stopper
                        rest: ''
                      - !!perl/hash:RE_cclass
                        alt: termish_0 1
                        i: 0
                        text: '[&|~]'
                - !!perl/hash:RE_method
                  name: panic
                  rest: 1
              - !!perl/hash:RE_sequence
                zyg:
                - !!perl/hash:RE_assertion
                  assert: '?'
                  re: !!perl/hash:RE_method_re
                    name: before
                    nobind: 1
                    re: !!perl/hash:RE_cclass
                      i: 0
                      text: '[ \] \) \> ]'
                - !!perl/hash:RE_block {}
              - !!perl/hash:RE_sequence
                zyg:
                - !!perl/hash:RE_meta
                  text: $$
                - !!perl/hash:RE_method
                  name: panic
                  rest: 1
              - !!perl/hash:RE_sequence
                zyg:
                - !!perl/hash:RE_meta
                  min: 1
                  text: \W
                - !!perl/hash:RE_method
                  name: sorry
                  rest: 1
              - !!perl/hash:RE_method
                name: panic
                rest: 1
termish_0: *30
unsp: !!perl/hash:RE_ast
  dba: unsp
  dic: STD::Regex
  re: !!perl/hash:RE_sequence
    zyg:
    - !!perl/hash:RE_string
      i: 0
      text: \
    - !!perl/hash:RE_assertion
      assert: '?'
      re: !!perl/hash:RE_method_re
        name: before
        nobind: 1
        re: &31 !!perl/hash:RE_any
          altname: unsp_0
          dba: unsp
          dic: STD::Regex
          zyg:
          - !!perl/hash:RE_meta
            alt: unsp_0 0
            min: 1
            text: \s
          - !!perl/hash:RE_string
            alt: unsp_0 1
            i: 0
            text: '#'
    - !!perl/hash:RE_method
      name: panic
      rest: 1
unsp_0: *31
ws: !!perl/hash:RE_ast
  dba: ws
  dic: STD::Regex
  re: !!perl/hash:RE_assertion
    assert: '?'
    re: !!perl/hash:RE_noop
      nobind: 1
RETREE_END
## method tweak (:Perl5(:$P5)!)
;
## method tweak (:overlap(:$ov)!)
;
## method tweak (:exhaustive(:$ex)!)
;
## method tweak (:continue(:$c)!)
;
## method tweak (:pos(:$p)!)
;
## method tweak (:sigspace(:$s)!)
;
## method tweak (:ratchet(:$r)!)
;
## method tweak (:global(:$g)!)
;
## method tweak (:ignorecase(:$i)!)
;
## method tweak (:ignoreaccent(:$a)!)
;
## method tweak (:samecase(:$ii)!)
;
## method tweak (:sameaccent(:$aa)!)
;
## method tweak (:$nth!)
;
## method tweak (:st(:$nd)!)
;
## method tweak (:rd(:$th)!)
;
## method tweak (:$x!)
;
## method tweak (:$bytes!)
;
## method tweak (:$codes!)
;
## method tweak (:$graphs!)
;
## method tweak (:$chars!)
;
## method tweak (:$rw!)
;
## token category:metachar { <sym> }
sub category__S_000metachar__PEEK { $_[0]->_AUTOLEXpeek('category__S_000metachar', $retree) }
sub category__S_000metachar {
no warnings 'recursion';
my $self = shift;


local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;

my $C = $self->cursor_xact("RULE category__S_000metachar");
my $xact = $C->xact;
my $S = $C->{'_pos'};
$C->{sym} = "metachar";
$self->_MATCHIFYr($S, "category__S_000metachar", $C->_EXACT("metachar"));
}
;
## token metachar {*}
sub metachar__PEEK { $_[0]->_AUTOLEXpeek('metachar:*',$retree); }
sub metachar {
my $self = shift;
my $subs;

local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;

my $C = $self->cursor_xact('RULE metachar');
my $S = $C->{'_pos'};

my @result = do {
my ($tag, $try);
my @try;
my $relex;
my $x;
if (my $fate = $C->{'_fate'}) {
if ($fate->[1] eq 'metachar') {
$C->deb("Fate passed to metachar: ", ::fatestr($fate)) if $::DEBUG & DEBUG::fates;
($C->{'_fate'}, $tag, $try) = @$fate;
@try = ($try);
$x = 'ALT metachar';
}
else {
$x = 'ALTLTM metachar';
}
}
else {
$x = 'ALTLTM metachar';
}
my $C = $C->cursor_xact($x);
my $xact = $C->{_xact};

my @gather = ();
for (;;) {
unless (@try) {
$relex //= $C->cursor_fate('STD::Regex', 'metachar:*', $retree);
@try = $relex->($C) or last;
}
$try = shift(@try) // next;

if (ref $try) {
($C->{'_fate'}, $tag, $try) = @$try;       # next candidate fate
}

$C->deb("metachar trying $tag $try") if $::DEBUG & DEBUG::try_processing;
push @gather, $C->$try(@_);
last if @gather;
last if $xact->[-2];  # committed?
}
$self->_MATCHIFYr($S, "metachar", @gather);
};
@result;
}
;
## token category:backslash { <sym> }
sub category__S_001backslash__PEEK { $_[0]->_AUTOLEXpeek('category__S_001backslash', $retree) }
sub category__S_001backslash {
no warnings 'recursion';
my $self = shift;


local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;

my $C = $self->cursor_xact("RULE category__S_001backslash");
my $xact = $C->xact;
my $S = $C->{'_pos'};
$C->{sym} = "backslash";
$self->_MATCHIFYr($S, "category__S_001backslash", $C->_EXACT("backslash"));
}
;
## token backslash {*}
sub backslash__PEEK { $_[0]->_AUTOLEXpeek('backslash:*',$retree); }
sub backslash {
my $self = shift;
my $subs;

local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;

my $C = $self->cursor_xact('RULE backslash');
my $S = $C->{'_pos'};

my @result = do {
my ($tag, $try);
my @try;
my $relex;
my $x;
if (my $fate = $C->{'_fate'}) {
if ($fate->[1] eq 'backslash') {
$C->deb("Fate passed to backslash: ", ::fatestr($fate)) if $::DEBUG & DEBUG::fates;
($C->{'_fate'}, $tag, $try) = @$fate;
@try = ($try);
$x = 'ALT backslash';
}
else {
$x = 'ALTLTM backslash';
}
}
else {
$x = 'ALTLTM backslash';
}
my $C = $C->cursor_xact($x);
my $xact = $C->{_xact};

my @gather = ();
for (;;) {
unless (@try) {
$relex //= $C->cursor_fate('STD::Regex', 'backslash:*', $retree);
@try = $relex->($C) or last;
}
$try = shift(@try) // next;

if (ref $try) {
($C->{'_fate'}, $tag, $try) = @$try;       # next candidate fate
}

$C->deb("backslash trying $tag $try") if $::DEBUG & DEBUG::try_processing;
push @gather, $C->$try(@_);
last if @gather;
last if $xact->[-2];  # committed?
}
$self->_MATCHIFYr($S, "backslash", @gather);
};
@result;
}
;
## token category:assertion { <sym> }
sub category__S_002assertion__PEEK { $_[0]->_AUTOLEXpeek('category__S_002assertion', $retree) }
sub category__S_002assertion {
no warnings 'recursion';
my $self = shift;


local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;

my $C = $self->cursor_xact("RULE category__S_002assertion");
my $xact = $C->xact;
my $S = $C->{'_pos'};
$C->{sym} = "assertion";
$self->_MATCHIFYr($S, "category__S_002assertion", $C->_EXACT("assertion"));
}
;
## token assertion {*}
sub assertion__PEEK { $_[0]->_AUTOLEXpeek('assertion:*',$retree); }
sub assertion {
my $self = shift;
my $subs;

local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;

my $C = $self->cursor_xact('RULE assertion');
my $S = $C->{'_pos'};

my @result = do {
my ($tag, $try);
my @try;
my $relex;
my $x;
if (my $fate = $C->{'_fate'}) {
if ($fate->[1] eq 'assertion') {
$C->deb("Fate passed to assertion: ", ::fatestr($fate)) if $::DEBUG & DEBUG::fates;
($C->{'_fate'}, $tag, $try) = @$fate;
@try = ($try);
$x = 'ALT assertion';
}
else {
$x = 'ALTLTM assertion';
}
}
else {
$x = 'ALTLTM assertion';
}
my $C = $C->cursor_xact($x);
my $xact = $C->{_xact};

my @gather = ();
for (;;) {
unless (@try) {
$relex //= $C->cursor_fate('STD::Regex', 'assertion:*', $retree);
@try = $relex->($C) or last;
}
$try = shift(@try) // next;

if (ref $try) {
($C->{'_fate'}, $tag, $try) = @$try;       # next candidate fate
}

$C->deb("assertion trying $tag $try") if $::DEBUG & DEBUG::try_processing;
push @gather, $C->$try(@_);
last if @gather;
last if $xact->[-2];  # committed?
}
$self->_MATCHIFYr($S, "assertion", @gather);
};
@result;
}
;
## token category:quantifier { <sym> }
sub category__S_003quantifier__PEEK { $_[0]->_AUTOLEXpeek('category__S_003quantifier', $retree) }
sub category__S_003quantifier {
no warnings 'recursion';
my $self = shift;


local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;

my $C = $self->cursor_xact("RULE category__S_003quantifier");
my $xact = $C->xact;
my $S = $C->{'_pos'};
$C->{sym} = "quantifier";
$self->_MATCHIFYr($S, "category__S_003quantifier", $C->_EXACT("quantifier"));
}
;
## token quantifier {*}
sub quantifier__PEEK { $_[0]->_AUTOLEXpeek('quantifier:*',$retree); }
sub quantifier {
my $self = shift;
my $subs;

local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;

my $C = $self->cursor_xact('RULE quantifier');
my $S = $C->{'_pos'};

my @result = do {
my ($tag, $try);
my @try;
my $relex;
my $x;
if (my $fate = $C->{'_fate'}) {
if ($fate->[1] eq 'quantifier') {
$C->deb("Fate passed to quantifier: ", ::fatestr($fate)) if $::DEBUG & DEBUG::fates;
($C->{'_fate'}, $tag, $try) = @$fate;
@try = ($try);
$x = 'ALT quantifier';
}
else {
$x = 'ALTLTM quantifier';
}
}
else {
$x = 'ALTLTM quantifier';
}
my $C = $C->cursor_xact($x);
my $xact = $C->{_xact};

my @gather = ();
for (;;) {
unless (@try) {
$relex //= $C->cursor_fate('STD::Regex', 'quantifier:*', $retree);
@try = $relex->($C) or last;
}
$try = shift(@try) // next;

if (ref $try) {
($C->{'_fate'}, $tag, $try) = @$try;       # next candidate fate
}

$C->deb("quantifier trying $tag $try") if $::DEBUG & DEBUG::try_processing;
push @gather, $C->$try(@_);
last if @gather;
last if $xact->[-2];  # committed?
}
$self->_MATCHIFYr($S, "quantifier", @gather);
};
@result;
}
;
## token category:mod_internal { <sym> }
sub category__S_004mod_internal__PEEK { $_[0]->_AUTOLEXpeek('category__S_004mod_internal', $retree) }
sub category__S_004mod_internal {
no warnings 'recursion';
my $self = shift;


local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;

my $C = $self->cursor_xact("RULE category__S_004mod_internal");
my $xact = $C->xact;
my $S = $C->{'_pos'};
$C->{sym} = "mod_internal";
$self->_MATCHIFYr($S, "category__S_004mod_internal", $C->_EXACT("mod_internal"));
}
;
## token mod_internal {*}
sub mod_internal__PEEK { $_[0]->_AUTOLEXpeek('mod_internal:*',$retree); }
sub mod_internal {
my $self = shift;
my $subs;

local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;

my $C = $self->cursor_xact('RULE mod_internal');
my $S = $C->{'_pos'};

my @result = do {
my ($tag, $try);
my @try;
my $relex;
my $x;
if (my $fate = $C->{'_fate'}) {
if ($fate->[1] eq 'mod_internal') {
$C->deb("Fate passed to mod_internal: ", ::fatestr($fate)) if $::DEBUG & DEBUG::fates;
($C->{'_fate'}, $tag, $try) = @$fate;
@try = ($try);
$x = 'ALT mod_internal';
}
else {
$x = 'ALTLTM mod_internal';
}
}
else {
$x = 'ALTLTM mod_internal';
}
my $C = $C->cursor_xact($x);
my $xact = $C->{_xact};

my @gather = ();
for (;;) {
unless (@try) {
$relex //= $C->cursor_fate('STD::Regex', 'mod_internal:*', $retree);
@try = $relex->($C) or last;
}
$try = shift(@try) // next;

if (ref $try) {
($C->{'_fate'}, $tag, $try) = @$try;       # next candidate fate
}

$C->deb("mod_internal trying $tag $try") if $::DEBUG & DEBUG::try_processing;
push @gather, $C->$try(@_);
last if @gather;
last if $xact->[-2];  # committed?
}
$self->_MATCHIFYr($S, "mod_internal", @gather);
};
@result;
}
;
## token regex_infix {*}
sub regex_infix__PEEK { $_[0]->_AUTOLEXpeek('regex_infix:*',$retree); }
sub regex_infix {
my $self = shift;
my $subs;

local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;

my $C = $self->cursor_xact('RULE regex_infix');
my $S = $C->{'_pos'};

my @result = do {
my ($tag, $try);
my @try;
my $relex;
my $x;
if (my $fate = $C->{'_fate'}) {
if ($fate->[1] eq 'regex_infix') {
$C->deb("Fate passed to regex_infix: ", ::fatestr($fate)) if $::DEBUG & DEBUG::fates;
($C->{'_fate'}, $tag, $try) = @$fate;
@try = ($try);
$x = 'ALT regex_infix';
}
else {
$x = 'ALTLTM regex_infix';
}
}
else {
$x = 'ALTLTM regex_infix';
}
my $C = $C->cursor_xact($x);
my $xact = $C->{_xact};

my @gather = ();
for (;;) {
unless (@try) {
$relex //= $C->cursor_fate('STD::Regex', 'regex_infix:*', $retree);
@try = $relex->($C) or last;
}
$try = shift(@try) // next;

if (ref $try) {
($C->{'_fate'}, $tag, $try) = @$try;       # next candidate fate
}

$C->deb("regex_infix trying $tag $try") if $::DEBUG & DEBUG::try_processing;
push @gather, $C->$try(@_);
last if @gather;
last if $xact->[-2];  # committed?
}
$self->_MATCHIFYr($S, "regex_infix", @gather);
};
@result;
}
;
## token ws { <?> }
sub ws__PEEK { $_[0]->_AUTOLEXpeek('ws', $retree) }
sub ws {
no warnings 'recursion';
my $self = shift;


local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;

my $C = $self->cursor_xact("RULE ws");
my $xact = $C->xact;
my $S = $C->{'_pos'};
$self->_MATCHIFYr($S, "ws", $C->before(sub {
my $C=shift;
$C
}));
}
;
## token normspace {
sub normspace__PEEK { $_[0]->_AUTOLEXpeek('normspace', $retree) }
sub normspace {
no warnings 'recursion';
my $self = shift;


local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;

my $C = $self->cursor_xact("RULE normspace");
my $xact = $C->xact;
my $S = $C->{'_pos'};
$self->_MATCHIFYr($S, "normspace", do {
my $C = $C;
if (($C) = ($C->before(sub {
my $C=shift;
if (my ($C) = ($C->before(sub {
my $C=shift;
if (my ($C) = (do {
do {
my ($tag, $try);
my @try;
my $relex;

my $fate;
my $x;
if ($fate = $C->{'_fate'} and $fate->[1] eq 'normspace_0') {
$C->deb("Fate passed to normspace_0: ", ::fatestr($fate)) if $::DEBUG & DEBUG::fates;
($C->{'_fate'}, $tag, $try) = @$fate;
@try = ($try);
$x = 'ALT normspace_0';    # some outer ltm is controlling us
}
else {
$x = 'ALTLTM normspace_0'; # we are top level ltm
}
my $C = $C->cursor_xact($x);
my $xact = $C->{_xact};

my @gather = ();
for (;;) {
unless (@try) {
$relex //= $C->cursor_fate('STD::Regex', 'normspace_0', $retree);
@try = $relex->($C) or last;
}
$try = shift(@try) // next;

if (ref $try) {
($C->{'_fate'}, $tag, $try) = @$try;   # next candidate fate
}

$C->deb("normspace_0 trying $tag $try") if $::DEBUG & DEBUG::try_processing;
push @gather, ((
sub {
my $C=shift;
$C->_PATTERN(qr/\G\s/)
},
sub {
my $C=shift;
$C->_EXACT("\#")
}
)[$try])->($C);
last if @gather;
last if $xact->[-2];  # committed?
}
@gather;
};

})) { ($C) } else { () }
}))) { ($C) } else { () }
}))
and ($C) = ($C->_BRACKETr(sub {
my $C=shift;
my $newlang = ($::LANG{'MAIN'});
$C = bless($C, (ref($newlang) || $newlang));
do {
if (my ($C) = ($C->ws)) { ($C) } else { () }

}
}))) {
$C
} else { () }

});
}
;
## token unsp { '\\' <?before \s | '#'> <.panic: "No unspace allowed in regex; if you meant to match th
sub unsp__PEEK { $_[0]->_AUTOLEXpeek('unsp', $retree) }
sub unsp {
no warnings 'recursion';
my $self = shift;


local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;

my $C = $self->cursor_xact("RULE unsp");
my $xact = $C->xact;
my $S = $C->{'_pos'};
$self->_MATCHIFYr($S, "unsp", do {
my $C = $C;
if (($C) = ($C->_EXACT("\\"))
and ($C) = ($C->before(sub {
my $C=shift;
if (my ($C) = ($C->before(sub {
my $C=shift;
if (my ($C) = (do {
do {
my ($tag, $try);
my @try;
my $relex;

my $fate;
my $x;
if ($fate = $C->{'_fate'} and $fate->[1] eq 'unsp_0') {
$C->deb("Fate passed to unsp_0: ", ::fatestr($fate)) if $::DEBUG & DEBUG::fates;
($C->{'_fate'}, $tag, $try) = @$fate;
@try = ($try);
$x = 'ALT unsp_0';    # some outer ltm is controlling us
}
else {
$x = 'ALTLTM unsp_0'; # we are top level ltm
}
my $C = $C->cursor_xact($x);
my $xact = $C->{_xact};

my @gather = ();
for (;;) {
unless (@try) {
$relex //= $C->cursor_fate('STD::Regex', 'unsp_0', $retree);
@try = $relex->($C) or last;
}
$try = shift(@try) // next;

if (ref $try) {
($C->{'_fate'}, $tag, $try) = @$try;   # next candidate fate
}

$C->deb("unsp_0 trying $tag $try") if $::DEBUG & DEBUG::try_processing;
push @gather, ((
sub {
my $C=shift;
$C->_PATTERN(qr/\G\s/)
},
sub {
my $C=shift;
$C->_EXACT("\#")
}
)[$try])->($C);
last if @gather;
last if $xact->[-2];  # committed?
}
@gather;
};

})) { ($C) } else { () }
}))) { ($C) } else { () }
}))
and ($C) = (do {
my $M = $C;
$C->panic("No unspace allowed in regex; if you meant to match the literal character, please enclose in single quotes ('" . substr($::ORIG,$C->{'_pos'},1) . "') or use a backslashed form like \\x" . sprintf("%M->{02}x", ord(substr($::ORIG,$C->{'_pos'},1))))
})) {
$C
} else { () }

});
}
;
## rule nibbler {
sub nibbler__PEEK { $_[0]->_AUTOLEXpeek('nibbler', $retree) }
sub nibbler {
no warnings 'recursion';
my $self = shift;

local %::RX = %::RX;
local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;

my $C = $self->cursor_xact("RULE nibbler");
my $xact = $C->xact;
my $S = $C->{'_pos'};
$self->_MATCHIFYr($S, "nibbler", do {
my $C = $C;
if (($C) = ($C->ws)
and ($C) = ($C->_OPTr(sub {
my $C=shift;
if (my ($C) = ($C->_BRACKETr(sub {
my $C=shift;
if (($C) = ($C->ws)
and ($C) = ($C->_OPTr(sub {
my $C=shift;
if (my ($C) = ($C->normspace)) { ($C) } else { () }
}))
and ($C) = ($C->ws)
and ($C) = ($C->_ARRAY( qw< || | && & > ))
and ($C) = ($C->ws)) {
$C
} else { () }
}))) { ($C) } else { () }
}))
and ($C) = ($C->ws)
and ($C) = ($C->_SUBSUMEr(['EXPR'], sub {
my $C = shift;
$C->EXPR
}))
and ($C) = ($C->ws)
and ($C) = ($C->_BRACKETr(sub {
my $C=shift;
do {    my $C = $C->cursor_xact('ALT ||');
my $xact = $C->xact;
my @gather;
do {
push @gather, do {
if (my ($C) = ($C->before(sub {
my $C=shift;
if (my ($C) = ($C->infixstopper)) { ($C) } else { () }
}))) { ($C) } else { () }

}
}
or $xact->[-2] or
do {
push @gather, do {
my $C = $C;
if (($C) = ($C->_PATTERN(qr/\G(?m:$)/))
and ($C) = ($C->ws)
and ($C) = ($C->panic("Regex not terminated"))
and ($C) = ($C->ws)) {
$C
} else { () }

}
}
or $xact->[-2] or
do {
push @gather, do {
my $C = $C;
if (($C) = ($C->_SUBSUMEr(['0'], sub {
my $C = shift;
$C->_PAREN( sub {
my $C=shift;
$C->_PATTERN(qr/\G\W/)

})
}))
and ($C) = (do {
my $M = $C;
$C->sorry("Unrecognized regex metacharacter " . $M->{0}->Str . " (must be quoted to match literally)")
})
and ($C) = ($C->ws)) {
$C
} else { () }

}
}
or $xact->[-2] or
do {
push @gather, do {
my $C = $C;
if (($C) = ($C->panic("Regex not terminated"))
and ($C) = ($C->ws)) {
$C
} else { () }

}
};
@gather;
}
}))) {
$C
} else { () }

});
}
;
## token termish {
sub termish__PEEK { $_[0]->_AUTOLEXpeek('termish', $retree) }
sub termish {
no warnings 'recursion';
my $self = shift;


local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;

my $C = $self->cursor_xact("RULE termish");
my $xact = $C->xact;
my $S = $C->{'_pos'};
$C->{'normspace'} = [];
$self->_MATCHIFYr($S, "termish", do {
my $C = $C;
if (($C) = ($C->ws)
and ($C) = ($C->_BRACKETr(sub {
my $C=shift;
do {    my $C = $C->cursor_xact('ALT ||');
my $xact = $C->xact;
my @gather;
do {
push @gather, do {
my $C = $C;
if (($C) = ($C->_SUBSUMEr(['term'], sub {
my $C = shift;
$C->quant_atom_list
}))
and ($C) = ($C->before(sub {
my $C=shift;
(($C) x !!do {
my $M = $C;
$::RX{'s'} or $M->{'term'}->Str =~ /\S/ })
}))) {
$C
} else { () }

}
}
or $xact->[-2] or
do {
push @gather, do {
my $C = $C;
if (($C) = ($C->_OPTr(sub {
my $C=shift;
$C->_SUBSUMEr(['normspace'], sub {
my $C = shift;
$C->normspace
})
}))
and ($C) = ($C->_BRACKETr(sub {
my $C=shift;
do {    my $C = $C->cursor_xact('ALT ||');
my $xact = $C->xact;
my @gather;
do {
push @gather, do {
my $C = $C;
if (($C) = ($C->before(sub {
my $C=shift;
if (my ($C) = ($C->before(sub {
my $C=shift;
if (my ($C) = (do {
do {
my ($tag, $try);
my @try;
my $relex;

my $fate;
my $x;
if ($fate = $C->{'_fate'} and $fate->[1] eq 'termish_0') {
$C->deb("Fate passed to termish_0: ", ::fatestr($fate)) if $::DEBUG & DEBUG::fates;
($C->{'_fate'}, $tag, $try) = @$fate;
@try = ($try);
$x = 'ALT termish_0';    # some outer ltm is controlling us
}
else {
$x = 'ALTLTM termish_0'; # we are top level ltm
}
my $C = $C->cursor_xact($x);
my $xact = $C->{_xact};

my @gather = ();
for (;;) {
unless (@try) {
$relex //= $C->cursor_fate('STD::Regex', 'termish_0', $retree);
@try = $relex->($C) or last;
}
$try = shift(@try) // next;

if (ref $try) {
($C->{'_fate'}, $tag, $try) = @$try;   # next candidate fate
}

$C->deb("termish_0 trying $tag $try") if $::DEBUG & DEBUG::try_processing;
push @gather, ((
sub {
my $C=shift;
$C->_SUBSUMEr(['stopper'], sub {
my $C = shift;
$C->stopper
})
},
sub {
my $C=shift;
$C->_PATTERN(qr/\G[&|~]/)
}
)[$try])->($C);
last if @gather;
last if $xact->[-2];  # committed?
}
@gather;
};

})) { ($C) } else { () }
}))) { ($C) } else { () }
}))
and ($C) = ($C->panic("Null pattern not allowed"))) {
$C
} else { () }

}
}
or $xact->[-2] or
do {
push @gather, do {
if (my ($C) = ($C->before(sub {
my $C=shift;
if (my ($C) = ($C->before(sub {
my $C=shift;
$C->_PATTERN(qr/\G[\]\)\>]/)
}))) { ($C) } else { () }
}))) {
scalar(do {
{
my $c = substr($::ORIG,$C->{'_pos'},1);
if ($::GOAL eq $c) {
$C->panic("Null pattern not allowed")}
else {
$C->panic("Unmatched closing $c")};
}}, $C)
} else { () }

}
}
or $xact->[-2] or
do {
push @gather, do {
my $C = $C;
if (($C) = ($C->_PATTERN(qr/\G(?m:$)/))
and ($C) = ($C->panic("Regex not terminated"))) {
$C
} else { () }

}
}
or $xact->[-2] or
do {
push @gather, do {
my $C = $C;
if (($C) = ($C->_PATTERN(qr/\G\W/))
and ($C) = ($C->sorry("Unrecognized regex metacharacter (must be quoted to match literally)"))) {
$C
} else { () }

}
}
or $xact->[-2] or
do {
push @gather, do {
if (my ($C) = ($C->panic("Regex not terminated"))) { ($C) } else { () }

}
};
@gather;
}
}))) {
$C
} else { () }

}
};
@gather;
}
}))) {
$C
} else { () }

});
}
;
## token quant_atom_list {
sub quant_atom_list__PEEK { $_[0]->_AUTOLEXpeek('quant_atom_list', $retree) }
sub quant_atom_list {
no warnings 'recursion';
my $self = shift;


local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;

my $C = $self->cursor_xact("RULE quant_atom_list");
my $xact = $C->xact;
my $S = $C->{'_pos'};
$C->{'quantified_atom'} = [];
$self->_MATCHIFYr($S, "quant_atom_list", $C->_PLUSr(sub {
my $C=shift;
$C->_SUBSUMEr(['quantified_atom'], sub {
my $C = shift;
$C->quantified_atom
})
}));
}
;
## token infixish {
sub infixish__PEEK { $_[0]->_AUTOLEXpeek('infixish', $retree) }
sub infixish {
no warnings 'recursion';
my $self = shift;


local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;

my $C = $self->cursor_xact("RULE infixish");
my $xact = $C->xact;
my $S = $C->{'_pos'};
$self->_MATCHIFYr($S, "infixish", do {
my $C = $C;
if (($C) = ($C->_NOTBEFORE(sub {
my $C=shift;
if (my ($C) = ($C->infixstopper)) { ($C) } else { () }
}))
and ($C) = ($C->_NOTBEFORE(sub {
my $C=shift;
if (my ($C) = ($C->stdstopper)) { ($C) } else { () }
}))
and ($C) = ($C->_SUBSUMEr(['regex_infix'], sub {
my $C = shift;
$C->regex_infix
}))) {
scalar(do {
my $M = $C;
$M->{'O'} = $M->{'regex_infix'}->{'O'};
$M->{'sym'} = $M->{'regex_infix'}->{'sym'};
}, $C)
} else { () }

});
}
;
## regex infixstopper {
sub infixstopper__PEEK { $_[0]->_AUTOLEXpeek('infixstopper', $retree) }
sub infixstopper {
no warnings 'recursion';
my $self = shift;


local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;

my $C = $self->cursor_xact("RULE infixstopper");
my $xact = $C->xact;
my $S = $C->{'_pos'};
$self->_MATCHIFY($S, "infixstopper", $C->_BRACKET(sub {
my $C=shift;
do {
my ($tag, $try);
my @try;
my $relex;

my $fate;
my $x;
if ($fate = $C->{'_fate'} and $fate->[1] eq 'infixstopper_0') {
$C->deb("Fate passed to infixstopper_0: ", ::fatestr($fate)) if $::DEBUG & DEBUG::fates;
($C->{'_fate'}, $tag, $try) = @$fate;
@try = ($try);
$x = 'ALT infixstopper_0';    # some outer ltm is controlling us
}
else {
$x = 'ALTLTM infixstopper_0'; # we are top level ltm
}
my $C = $C->cursor_xact($x);
my $xact = $C->{_xact};

my @gather = ();
for (;;) {
unless (@try) {
$relex //= $C->cursor_fate('STD::Regex', 'infixstopper_0', $retree);
@try = $relex->($C) or last;
}
$try = shift(@try) // next;

if (ref $try) {
($C->{'_fate'}, $tag, $try) = @$try;   # next candidate fate
}

$C->deb("infixstopper_0 trying $tag $try") if $::DEBUG & DEBUG::try_processing;
push @gather, ((
sub {
my $C=shift;
$C->before(sub {
my $C=shift;
$C->_PATTERN(qr/\G[\)\}\]]/)
})
},
sub {
my $C=shift;
$C->before(sub {
my $C=shift;
$C->_PATTERN(qr/\G\>[^>)]/)
})
},
sub {
my $C=shift;
$C->before(sub {
my $C=shift;
$C->_SUBSUME(['stopper'], sub {
my $C = shift;
$C->stopper
})
})
}
)[$try])->($C);
last if @gather;
last if $xact->[-2];  # committed?
}
@gather;
};
}));
}
;
## token regex_infix:sym<||> { <sym> <O(|%tight_or)>  }
sub regex_infix__S_005VertVert__PEEK { $_[0]->_AUTOLEXpeek('regex_infix__S_005VertVert', $retree) }
sub regex_infix__S_005VertVert {
no warnings 'recursion';
my $self = shift;


local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;

my $C = $self->cursor_xact("RULE regex_infix__S_005VertVert");
my $xact = $C->xact;
my $S = $C->{'_pos'};
$C->{sym} = "\|\|";
$self->_MATCHIFYr($S, "regex_infix__S_005VertVert", do {
if (my ($C) = ($C->_EXACT("\|\|"))) {
$C->_SUBSUMEr(['O'], sub {
my $C = shift;
$C->O(%tight_or)
})
} else { () }

});
}
;
## token regex_infix:sym<&&> { <sym> <O(|%tight_and)>  }
sub regex_infix__S_006AmpAmp__PEEK { $_[0]->_AUTOLEXpeek('regex_infix__S_006AmpAmp', $retree) }
sub regex_infix__S_006AmpAmp {
no warnings 'recursion';
my $self = shift;


local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;

my $C = $self->cursor_xact("RULE regex_infix__S_006AmpAmp");
my $xact = $C->xact;
my $S = $C->{'_pos'};
$C->{sym} = "\&\&";
$self->_MATCHIFYr($S, "regex_infix__S_006AmpAmp", do {
if (my ($C) = ($C->_EXACT("\&\&"))) {
$C->_SUBSUMEr(['O'], sub {
my $C = shift;
$C->O(%tight_and)
})
} else { () }

});
}
;
## token regex_infix:sym<|> { <sym> <O(|%junctive_or)>  }
sub regex_infix__S_007Vert__PEEK { $_[0]->_AUTOLEXpeek('regex_infix__S_007Vert', $retree) }
sub regex_infix__S_007Vert {
no warnings 'recursion';
my $self = shift;


local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;

my $C = $self->cursor_xact("RULE regex_infix__S_007Vert");
my $xact = $C->xact;
my $S = $C->{'_pos'};
$C->{sym} = "\|";
$self->_MATCHIFYr($S, "regex_infix__S_007Vert", do {
if (my ($C) = ($C->_EXACT("\|"))) {
$C->_SUBSUMEr(['O'], sub {
my $C = shift;
$C->O(%junctive_or)
})
} else { () }

});
}
;
## token regex_infix:sym<&> { <sym> <O(|%junctive_and)>  }
sub regex_infix__S_008Amp__PEEK { $_[0]->_AUTOLEXpeek('regex_infix__S_008Amp', $retree) }
sub regex_infix__S_008Amp {
no warnings 'recursion';
my $self = shift;


local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;

my $C = $self->cursor_xact("RULE regex_infix__S_008Amp");
my $xact = $C->xact;
my $S = $C->{'_pos'};
$C->{sym} = "\&";
$self->_MATCHIFYr($S, "regex_infix__S_008Amp", do {
if (my ($C) = ($C->_EXACT("\&"))) {
$C->_SUBSUMEr(['O'], sub {
my $C = shift;
$C->O(%junctive_and)
})
} else { () }

});
}
;
## token quantified_atom {
sub quantified_atom__PEEK { $_[0]->_AUTOLEXpeek('quantified_atom', $retree) }
sub quantified_atom {
no warnings 'recursion';
my $self = shift;


local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;

my $C = $self->cursor_xact("RULE quantified_atom");
my $xact = $C->xact;
my $S = $C->{'_pos'};
$C->{'normspace'} = [];
$C->{'quantifier'} = [];
$self->_MATCHIFYr($S, "quantified_atom", do {
my $C = $C;
if (($C) = ($C->_NOTBEFORE(sub {
my $C=shift;
if (my ($C) = ($C->stopper)) { ($C) } else { () }
}))
and ($C) = ($C->_NOTBEFORE(sub {
my $C=shift;
if (my ($C) = ($C->regex_infix)) { ($C) } else { () }
}))
and ($C) = ($C->_SUBSUMEr(['atom'], sub {
my $C = shift;
$C->atom
}))) {
$C->_OPTr(sub {
my $C=shift;
if (my ($C) = ($C->_BRACKETr(sub {
my $C=shift;
if (my ($C) = ($C->_OPTr(sub {
my $C=shift;
$C->_SUBSUMEr(['normspace'], sub {
my $C = shift;
$C->normspace
})
}))) {
$C->_SUBSUMEr(['quantifier'], sub {
my $C = shift;
$C->quantifier
})
} else { () }
}))) { ($C) } else { () }
})
} else { () }

});
}
;
## token atom {
sub atom__PEEK { $_[0]->_AUTOLEXpeek('atom', $retree) }
sub atom {
no warnings 'recursion';
my $self = shift;


local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;

my $C = $self->cursor_xact("RULE atom");
my $xact = $C->xact;
my $S = $C->{'_pos'};
$self->_MATCHIFYr($S, "atom", $C->_BRACKETr(sub {
my $C=shift;
do {
my ($tag, $try);
my @try;
my $relex;

my $fate;
my $x;
if ($fate = $C->{'_fate'} and $fate->[1] eq 'atom_0') {
$C->deb("Fate passed to atom_0: ", ::fatestr($fate)) if $::DEBUG & DEBUG::fates;
($C->{'_fate'}, $tag, $try) = @$fate;
@try = ($try);
$x = 'ALT atom_0';    # some outer ltm is controlling us
}
else {
$x = 'ALTLTM atom_0'; # we are top level ltm
}
my $C = $C->cursor_xact($x);
my $xact = $C->{_xact};

my @gather = ();
for (;;) {
unless (@try) {
$relex //= $C->cursor_fate('STD::Regex', 'atom_0', $retree);
@try = $relex->($C) or last;
}
$try = shift(@try) // next;

if (ref $try) {
($C->{'_fate'}, $tag, $try) = @$try;   # next candidate fate
}

$C->deb("atom_0 trying $tag $try") if $::DEBUG & DEBUG::try_processing;
push @gather, ((
sub {
my $C=shift;
$C->_PATTERN(qr/\G\w/)
},
sub {
my $C=shift;
if (my ($C) = ($C->_SUBSUMEr(['metachar'], sub {
my $C = shift;
$C->metachar
}))) {
$C->_COMMITLTM()
} else { () }
}
)[$try])->($C);
last if @gather;
last if $xact->[-2];  # committed?
}
@gather;
};
}));
}
;
## token metachar:sym« > » { '>'<!before '>'> :: <fail> }
sub metachar__S_009Gt__PEEK { $_[0]->_AUTOLEXpeek('metachar__S_009Gt', $retree) }
sub metachar__S_009Gt {
no warnings 'recursion';
my $self = shift;


local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;

my $C = $self->cursor_xact("RULE metachar__S_009Gt");
my $xact = $C->xact;
my $S = $C->{'_pos'};
$C->{sym} = "\>";
$self->_MATCHIFYr($S, "metachar__S_009Gt", do {
my $C = $C;
if (($C) = ($C->_EXACT("\>"))
and ($C) = ($C->_NOTBEFORE(sub {
my $C=shift;
if (my ($C) = ($C->before(sub {
my $C=shift;
$C->_EXACT("\>")
}))) { ($C) } else { () }
}))
and ($C) = ($C->_COMMITLTM())) {
$C->_SUBSUMEr(['fail'], sub {
my $C = shift;
$C->fail
})
} else { () }

});
}
;
## token metachar:sym<&&>  { '&&' :: <fail> }
sub metachar__S_010AmpAmp__PEEK { $_[0]->_AUTOLEXpeek('metachar__S_010AmpAmp', $retree) }
sub metachar__S_010AmpAmp {
no warnings 'recursion';
my $self = shift;


local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;

my $C = $self->cursor_xact("RULE metachar__S_010AmpAmp");
my $xact = $C->xact;
my $S = $C->{'_pos'};
$C->{sym} = "\&\&";
$self->_MATCHIFYr($S, "metachar__S_010AmpAmp", do {
my $C = $C;
if (($C) = ($C->_EXACT("\&\&"))
and ($C) = ($C->_COMMITLTM())) {
$C->_SUBSUMEr(['fail'], sub {
my $C = shift;
$C->fail
})
} else { () }

});
}
;
## token metachar:sym<&>   { '&'  :: <fail> }
sub metachar__S_011Amp__PEEK { $_[0]->_AUTOLEXpeek('metachar__S_011Amp', $retree) }
sub metachar__S_011Amp {
no warnings 'recursion';
my $self = shift;


local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;

my $C = $self->cursor_xact("RULE metachar__S_011Amp");
my $xact = $C->xact;
my $S = $C->{'_pos'};
$C->{sym} = "\&";
$self->_MATCHIFYr($S, "metachar__S_011Amp", do {
my $C = $C;
if (($C) = ($C->_EXACT("\&"))
and ($C) = ($C->_COMMITLTM())) {
$C->_SUBSUMEr(['fail'], sub {
my $C = shift;
$C->fail
})
} else { () }

});
}
;
## token metachar:sym<||>  { '||' :: <fail> }
sub metachar__S_012VertVert__PEEK { $_[0]->_AUTOLEXpeek('metachar__S_012VertVert', $retree) }
sub metachar__S_012VertVert {
no warnings 'recursion';
my $self = shift;


local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;

my $C = $self->cursor_xact("RULE metachar__S_012VertVert");
my $xact = $C->xact;
my $S = $C->{'_pos'};
$C->{sym} = "\|\|";
$self->_MATCHIFYr($S, "metachar__S_012VertVert", do {
my $C = $C;
if (($C) = ($C->_EXACT("\|\|"))
and ($C) = ($C->_COMMITLTM())) {
$C->_SUBSUMEr(['fail'], sub {
my $C = shift;
$C->fail
})
} else { () }

});
}
;
## token metachar:sym<|>   { '|'  :: <fail> }
sub metachar__S_013Vert__PEEK { $_[0]->_AUTOLEXpeek('metachar__S_013Vert', $retree) }
sub metachar__S_013Vert {
no warnings 'recursion';
my $self = shift;


local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;

my $C = $self->cursor_xact("RULE metachar__S_013Vert");
my $xact = $C->xact;
my $S = $C->{'_pos'};
$C->{sym} = "\|";
$self->_MATCHIFYr($S, "metachar__S_013Vert", do {
my $C = $C;
if (($C) = ($C->_EXACT("\|"))
and ($C) = ($C->_COMMITLTM())) {
$C->_SUBSUMEr(['fail'], sub {
my $C = shift;
$C->fail
})
} else { () }

});
}
;
## token metachar:sym<]>   { ']'  :: <fail> }
sub metachar__S_014Ket__PEEK { $_[0]->_AUTOLEXpeek('metachar__S_014Ket', $retree) }
sub metachar__S_014Ket {
no warnings 'recursion';
my $self = shift;


local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;

my $C = $self->cursor_xact("RULE metachar__S_014Ket");
my $xact = $C->xact;
my $S = $C->{'_pos'};
$C->{sym} = "\]";
$self->_MATCHIFYr($S, "metachar__S_014Ket", do {
my $C = $C;
if (($C) = ($C->_EXACT("\]"))
and ($C) = ($C->_COMMITLTM())) {
$C->_SUBSUMEr(['fail'], sub {
my $C = shift;
$C->fail
})
} else { () }

});
}
;
## token metachar:sym<)>   { ')'  :: <fail> }
sub metachar__S_015Thesis__PEEK { $_[0]->_AUTOLEXpeek('metachar__S_015Thesis', $retree) }
sub metachar__S_015Thesis {
no warnings 'recursion';
my $self = shift;


local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;

my $C = $self->cursor_xact("RULE metachar__S_015Thesis");
my $xact = $C->xact;
my $S = $C->{'_pos'};
$C->{sym} = "\)";
$self->_MATCHIFYr($S, "metachar__S_015Thesis", do {
my $C = $C;
if (($C) = ($C->_EXACT("\)"))
and ($C) = ($C->_COMMITLTM())) {
$C->_SUBSUMEr(['fail'], sub {
my $C = shift;
$C->fail
})
} else { () }

});
}
;
## token metachar:sym<;>   {
sub metachar__S_016Semi__PEEK { $_[0]->_AUTOLEXpeek('metachar__S_016Semi', $retree) }
sub metachar__S_016Semi {
no warnings 'recursion';
my $self = shift;


local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;

my $C = $self->cursor_xact("RULE metachar__S_016Semi");
my $xact = $C->xact;
my $S = $C->{'_pos'};
$C->{sym} = "\;";
$self->_MATCHIFYr($S, "metachar__S_016Semi", do {
my $C = $C;
if (($C) = ($C->_EXACT("\;"))
and ($C) = (scalar(do {
}, $C))
and ($C) = ($C->_BRACKETr(sub {
my $C=shift;
do {    my $C = $C->cursor_xact('ALT ||');
my $xact = $C->xact;
my @gather;
do {
push @gather, do {
my $C = $C;
if (($C) = ($C->before(sub {
my $C=shift;
if (my ($C) = ($C->before(sub {
my $C=shift;
if (my ($C) = (LazyMap::lazymap(sub {
my $C=shift;
$C->_SUBSUMEr(['stopper'], sub {
my $C = shift;
$C->stopper
})
},
$C->_STARf(sub {
my $C=shift;
$C->_NOTCHAR( sub { my $C=shift;
$C->_EXACT("\n")
})
})))) { ($C) } else { () }
}))) { ($C) } else { () }
}))
and ($C) = ($C->panic("Semicolon must be quoted"))) {
$C
} else { () }

}
}
or $xact->[-2] or
do {
push @gather, do {
my $C = $C;
if (($C) = ($C->before(sub {
my $C=shift;
if (my ($C) = ($C->before(sub {
my $C=shift;
$C->cursor_incr()
}))) { ($C) } else { () }
}))
and ($C) = ($C->panic("Regex missing terminator (or semicolon must be quoted?)"))) {
$C
} else { () }

}
}
or $xact->[-2] or
do {
push @gather, do {
if (my ($C) = ($C->panic("Regex missing terminator"))) { ($C) } else { () }

}
};
@gather;
}
}))) {
$C
} else { () }

});
}
;
## token metachar:sym<{*}> { <onlystar=.sym> <?{ $*MULTINESS eq 'proto' }> }
sub metachar__S_017CurStarLy__PEEK { $_[0]->_AUTOLEXpeek('metachar__S_017CurStarLy', $retree) }
sub metachar__S_017CurStarLy {
no warnings 'recursion';
my $self = shift;


local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;

my $C = $self->cursor_xact("RULE metachar__S_017CurStarLy");
my $xact = $C->xact;
my $S = $C->{'_pos'};
$C->{sym} = "\{\*\}";
$self->_MATCHIFYr($S, "metachar__S_017CurStarLy", do {
my $C = $C;
if (($C) = ($C->_SUBSUMEr(['onlystar'], sub {
my $C = shift;
$C->_EXACT("\{\*\}")
}))
and ($C) = ($C->before(sub {
my $C=shift;
(($C) x !!do {
$::MULTINESS eq 'proto' })
}))) {
$C
} else { () }

});
}
;
## token metachar:sym<[*]> { <onlystar=.sym> <?{ $*MULTINESS eq 'proto' }> }
sub metachar__S_018BraStarKet__PEEK { $_[0]->_AUTOLEXpeek('metachar__S_018BraStarKet', $retree) }
sub metachar__S_018BraStarKet {
no warnings 'recursion';
my $self = shift;


local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;

my $C = $self->cursor_xact("RULE metachar__S_018BraStarKet");
my $xact = $C->xact;
my $S = $C->{'_pos'};
$C->{sym} = "\[\*\]";
$self->_MATCHIFYr($S, "metachar__S_018BraStarKet", do {
my $C = $C;
if (($C) = ($C->_SUBSUMEr(['onlystar'], sub {
my $C = shift;
$C->_EXACT("\[\*\]")
}))
and ($C) = ($C->before(sub {
my $C=shift;
(($C) x !!do {
$::MULTINESS eq 'proto' })
}))) {
$C
} else { () }

});
}
;
## token metachar:quant { <quantifier> <.sorry: "Quantifier quantifies nothing"> }
sub metachar__S_019quant__PEEK { $_[0]->_AUTOLEXpeek('metachar__S_019quant', $retree) }
sub metachar__S_019quant {
no warnings 'recursion';
my $self = shift;


local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;

my $C = $self->cursor_xact("RULE metachar__S_019quant");
my $xact = $C->xact;
my $S = $C->{'_pos'};
$C->{sym} = "quant";
$self->_MATCHIFYr($S, "metachar__S_019quant", do {
my $C = $C;
if (($C) = ($C->_SUBSUMEr(['quantifier'], sub {
my $C = shift;
$C->quantifier
}))
and ($C) = ($C->sorry("Quantifier quantifies nothing"))) {
$C
} else { () }

});
}
;
## token metachar:sigwhite {
sub metachar__S_020sigwhite__PEEK { $_[0]->_AUTOLEXpeek('metachar__S_020sigwhite', $retree) }
sub metachar__S_020sigwhite {
no warnings 'recursion';
my $self = shift;


local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;

my $C = $self->cursor_xact("RULE metachar__S_020sigwhite");
my $xact = $C->xact;
my $S = $C->{'_pos'};
$C->{sym} = "sigwhite";
$self->_MATCHIFYr($S, "metachar__S_020sigwhite", $C->_SUBSUMEr(['normspace'], sub {
my $C = shift;
$C->normspace
}));
}
;
## token metachar:unsp   { <unsp> }
sub metachar__S_021unsp__PEEK { $_[0]->_AUTOLEXpeek('metachar__S_021unsp', $retree) }
sub metachar__S_021unsp {
no warnings 'recursion';
my $self = shift;


local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;

my $C = $self->cursor_xact("RULE metachar__S_021unsp");
my $xact = $C->xact;
my $S = $C->{'_pos'};
$C->{sym} = "unsp";
$self->_MATCHIFYr($S, "metachar__S_021unsp", $C->_SUBSUMEr(['unsp'], sub {
my $C = shift;
$C->unsp
}));
}
;
## token metachar:sym<{ }> {
sub metachar__S_022Cur_Ly__PEEK { $_[0]->_AUTOLEXpeek('metachar__S_022Cur_Ly', $retree) }
sub metachar__S_022Cur_Ly {
no warnings 'recursion';
my $self = shift;


local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;

my $C = $self->cursor_xact("RULE metachar__S_022Cur_Ly");
my $xact = $C->xact;
my $S = $C->{'_pos'};
$C->{sym} = "\{\ \}";
$self->_MATCHIFYr($S, "metachar__S_022Cur_Ly", do {
my $C = $C;
if (($C) = ($C->before(sub {
my $C=shift;
if (my ($C) = ($C->before(sub {
my $C=shift;
$C->_EXACT("\{")
}))) { ($C) } else { () }
}))
and ($C) = ($C->_SUBSUMEr(['embeddedblock'], sub {
my $C = shift;
$C->embeddedblock
}))) {
scalar(do {
my $M = $C;
{
$M->{'sym'} = <{ }> }}, $C)
} else { () }

});
}
;
## token metachar:mod {
sub metachar__S_023mod__PEEK { $_[0]->_AUTOLEXpeek('metachar__S_023mod', $retree) }
sub metachar__S_023mod {
no warnings 'recursion';
my $self = shift;


local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;

my $C = $self->cursor_xact("RULE metachar__S_023mod");
my $xact = $C->xact;
my $S = $C->{'_pos'};
$C->{sym} = "mod";
$self->_MATCHIFYr($S, "metachar__S_023mod", do {
my $C = $C;
if (($C) = ($C->before(sub {
my $C=shift;
if (my ($C) = ($C->before(sub {
my $C=shift;
$C->_EXACT("\:")
}))) { ($C) } else { () }
}))
and ($C) = ($C->_SUBSUMEr(['mod_internal'], sub {
my $C = shift;
$C->mod_internal
}))) {
scalar(do {
my $M = $C;
$M->{'sym'} = $M->{'mod_internal'}->{'sym'} }, $C)
} else { () }

});
}
;
## token metachar:sym<-> {
sub metachar__S_024Minus__PEEK { $_[0]->_AUTOLEXpeek('metachar__S_024Minus', $retree) }
sub metachar__S_024Minus {
no warnings 'recursion';
my $self = shift;


local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;

my $C = $self->cursor_xact("RULE metachar__S_024Minus");
my $xact = $C->xact;
my $S = $C->{'_pos'};
$C->{sym} = "\-";
$self->_MATCHIFYr($S, "metachar__S_024Minus", do {
my $C = $C;
if (($C) = ($C->_EXACT("\-"))
and ($C) = ($C->before(sub {
my $C=shift;
(($C) x !!do {
$::GOAL eq ']' })
}))
and ($C) = ($C->sorry("Invalid regex metacharacter (must be quoted to match literally)"))) {
$C
} else { () }

});
}
;
## token metachar:sym<:> {
sub metachar__S_025Colon__PEEK { $_[0]->_AUTOLEXpeek('metachar__S_025Colon', $retree) }
sub metachar__S_025Colon {
no warnings 'recursion';
my $self = shift;


local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;

my $C = $self->cursor_xact("RULE metachar__S_025Colon");
my $xact = $C->xact;
my $S = $C->{'_pos'};
$C->{sym} = "\:";
$self->_MATCHIFYr($S, "metachar__S_025Colon", do {
my $C = $C;
if (($C) = ($C->_EXACT("\:"))
and ($C) = ($C->before(sub {
my $C=shift;
if (my ($C) = ($C->before(sub {
my $C=shift;
$C->_PATTERN(qr/\G\s/)
}))) { ($C) } else { () }
}))
and ($C) = ($C->panic("Backtrack control ':' does not seem to have a preceding atom to control"))) {
$C
} else { () }

});
}
;
## token metachar:sym<::> {
sub metachar__S_026ColonColon__PEEK { $_[0]->_AUTOLEXpeek('metachar__S_026ColonColon', $retree) }
sub metachar__S_026ColonColon {
no warnings 'recursion';
my $self = shift;


local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;

my $C = $self->cursor_xact("RULE metachar__S_026ColonColon");
my $xact = $C->xact;
my $S = $C->{'_pos'};
$C->{sym} = "\:\:";
$self->_MATCHIFYr($S, "metachar__S_026ColonColon", $C->_EXACT("\:\:"));
}
;
## token metachar:sym<:::> {
sub metachar__S_027ColonColonColon__PEEK { $_[0]->_AUTOLEXpeek('metachar__S_027ColonColonColon', $retree) }
sub metachar__S_027ColonColonColon {
no warnings 'recursion';
my $self = shift;


local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;

my $C = $self->cursor_xact("RULE metachar__S_027ColonColonColon");
my $xact = $C->xact;
my $S = $C->{'_pos'};
$C->{sym} = "\:\:\:";
$self->_MATCHIFYr($S, "metachar__S_027ColonColonColon", $C->_EXACT("\:\:\:"));
}
;
## token metachar:sym<[ ]> {
sub metachar__S_028Bra_Ket__PEEK { $_[0]->_AUTOLEXpeek('metachar__S_028Bra_Ket', $retree) }
sub metachar__S_028Bra_Ket {
no warnings 'recursion';
my $self = shift;


local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;

my $C = $self->cursor_xact("RULE metachar__S_028Bra_Ket");
my $xact = $C->xact;
my $S = $C->{'_pos'};
$C->{sym} = "\[\ \]";
$self->_MATCHIFYr($S, "metachar__S_028Bra_Ket", do {
my $C = $C;
if (($C) = ($C->_BRACKETr(sub {
my $C=shift;
local $::GOAL = "\]";
my $goalpos = $C;
if (($C) = ($C->_EXACT("\["))
and ($C) = (scalar(do {
}, $C))
and ($C) = ($C->_SUBSUMEr(['nibbler'], sub {
my $C = shift;
$C->nibbler
}))
and ($C) = ($C->_BRACKETr(sub {
my $C=shift;
do {    my $C = $C->cursor_xact('ALT ||');
my $xact = $C->xact;
my @gather;
do {
push @gather, $C->_EXACT("\]")
}
or $xact->[-2] or
do {
push @gather, do {
if (my ($C) = ($C->FAILGOAL($::GOAL, 'bracketed regex', $goalpos))) { ($C) } else { () }

}
};
@gather;
}
}))) {
$C
} else { () }
}))
and ($C) = (scalar(do {
my $M = $C;
$C->check_old_cclass($M->{'nibbler'}->Str)}, $C))) {
scalar(do {
my $M = $C;
$M->{'sym'} = <[ ]>}, $C)
} else { () }

});
}
;
## token metachar:sym<( )> {
sub metachar__S_029Paren_Thesis__PEEK { $_[0]->_AUTOLEXpeek('metachar__S_029Paren_Thesis', $retree) }
sub metachar__S_029Paren_Thesis {
no warnings 'recursion';
my $self = shift;


local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;

my $C = $self->cursor_xact("RULE metachar__S_029Paren_Thesis");
my $xact = $C->xact;
my $S = $C->{'_pos'};
$C->{sym} = "\(\ \)";
$self->_MATCHIFYr($S, "metachar__S_029Paren_Thesis", do {
if (my ($C) = ($C->_BRACKETr(sub {
my $C=shift;
local $::GOAL = "\)";
my $goalpos = $C;
if (($C) = ($C->_EXACT("\("))
and ($C) = (scalar(do {
}, $C))
and ($C) = ($C->_SUBSUMEr(['nibbler'], sub {
my $C = shift;
$C->nibbler
}))
and ($C) = ($C->_BRACKETr(sub {
my $C=shift;
do {    my $C = $C->cursor_xact('ALT ||');
my $xact = $C->xact;
my @gather;
do {
push @gather, $C->_EXACT("\)")
}
or $xact->[-2] or
do {
push @gather, do {
if (my ($C) = ($C->FAILGOAL($::GOAL, 'capture parens', $goalpos))) { ($C) } else { () }

}
};
@gather;
}
}))) {
$C
} else { () }
}))) {
scalar(do {
my $M = $C;
$M->{'sym'} = <( )> }, $C)
} else { () }

});
}
;
## token metachar:sym« <( » { '<(' }
sub metachar__S_030LtParen__PEEK { $_[0]->_AUTOLEXpeek('metachar__S_030LtParen', $retree) }
sub metachar__S_030LtParen {
no warnings 'recursion';
my $self = shift;


local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;

my $C = $self->cursor_xact("RULE metachar__S_030LtParen");
my $xact = $C->xact;
my $S = $C->{'_pos'};
$C->{sym} = "\<\(";
$self->_MATCHIFYr($S, "metachar__S_030LtParen", $C->_EXACT("\<\("));
}
;
## token metachar:sym« )> » { ')>' }
sub metachar__S_031ThesisGt__PEEK { $_[0]->_AUTOLEXpeek('metachar__S_031ThesisGt', $retree) }
sub metachar__S_031ThesisGt {
no warnings 'recursion';
my $self = shift;


local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;

my $C = $self->cursor_xact("RULE metachar__S_031ThesisGt");
my $xact = $C->xact;
my $S = $C->{'_pos'};
$C->{sym} = "\)\>";
$self->_MATCHIFYr($S, "metachar__S_031ThesisGt", $C->_EXACT("\)\>"));
}
;
## token metachar:sym« << » { '<<' }
sub metachar__S_032LtLt__PEEK { $_[0]->_AUTOLEXpeek('metachar__S_032LtLt', $retree) }
sub metachar__S_032LtLt {
no warnings 'recursion';
my $self = shift;


local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;

my $C = $self->cursor_xact("RULE metachar__S_032LtLt");
my $xact = $C->xact;
my $S = $C->{'_pos'};
$C->{sym} = "\<\<";
$self->_MATCHIFYr($S, "metachar__S_032LtLt", $C->_EXACT("\<\<"));
}
;
## token metachar:sym« >> » { '>>' }
sub metachar__S_033GtGt__PEEK { $_[0]->_AUTOLEXpeek('metachar__S_033GtGt', $retree) }
sub metachar__S_033GtGt {
no warnings 'recursion';
my $self = shift;


local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;

my $C = $self->cursor_xact("RULE metachar__S_033GtGt");
my $xact = $C->xact;
my $S = $C->{'_pos'};
$C->{sym} = "\>\>";
$self->_MATCHIFYr($S, "metachar__S_033GtGt", $C->_EXACT("\>\>"));
}
;
## token metachar:sym< « > { '«' }
sub metachar__S_034Fre__PEEK { $_[0]->_AUTOLEXpeek('metachar__S_034Fre', $retree) }
sub metachar__S_034Fre {
no warnings 'recursion';
my $self = shift;


local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;

my $C = $self->cursor_xact("RULE metachar__S_034Fre");
my $xact = $C->xact;
my $S = $C->{'_pos'};
$C->{sym} = "«";
$self->_MATCHIFYr($S, "metachar__S_034Fre", $C->_EXACT("«"));
}
;
## token metachar:sym< » > { '»' }
sub metachar__S_035Nch__PEEK { $_[0]->_AUTOLEXpeek('metachar__S_035Nch', $retree) }
sub metachar__S_035Nch {
no warnings 'recursion';
my $self = shift;


local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;

my $C = $self->cursor_xact("RULE metachar__S_035Nch");
my $xact = $C->xact;
my $S = $C->{'_pos'};
$C->{sym} = "»";
$self->_MATCHIFYr($S, "metachar__S_035Nch", $C->_EXACT("»"));
}
;
## token metachar:qw {
sub metachar__S_036qw__PEEK { $_[0]->_AUTOLEXpeek('metachar__S_036qw', $retree) }
sub metachar__S_036qw {
no warnings 'recursion';
my $self = shift;


local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;

my $C = $self->cursor_xact("RULE metachar__S_036qw");
my $xact = $C->xact;
my $S = $C->{'_pos'};
$C->{sym} = "qw";
$self->_MATCHIFYr($S, "metachar__S_036qw", do {
if (my ($C) = ($C->before(sub {
my $C=shift;
if (my ($C) = ($C->before(sub {
my $C=shift;
$C->_PATTERN(qr/\G\<\s/)
}))) { ($C) } else { () }
}))) {
$C->_SUBSUMEr(['circumfix'], sub {
my $C = shift;
$C->circumfix
})
} else { () }

});
}
;
## token metachar:sym«< >» {
sub metachar__S_037Lt_Gt__PEEK { $_[0]->_AUTOLEXpeek('metachar__S_037Lt_Gt', $retree) }
sub metachar__S_037Lt_Gt {
no warnings 'recursion';
my $self = shift;


local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;

my $C = $self->cursor_xact("RULE metachar__S_037Lt_Gt");
my $xact = $C->xact;
my $S = $C->{'_pos'};
$C->{sym} = "\<\ \>";
$self->_MATCHIFYr($S, "metachar__S_037Lt_Gt", $C->_BRACKETr(sub {
my $C=shift;
local $::GOAL = "\>";
my $goalpos = $C;
my $newlang = $C->unbalanced($::GOAL);
$C = bless($C, (ref($newlang) || $newlang));
if (($C) = ($C->_EXACT("\<"))
and ($C) = (scalar(do {
}, $C))
and ($C) = ($C->_SUBSUMEr(['assertion'], sub {
my $C = shift;
$C->assertion
}))
and ($C) = ($C->_BRACKETr(sub {
my $C=shift;
do {    my $C = $C->cursor_xact('ALT ||');
my $xact = $C->xact;
my @gather;
do {
push @gather, $C->_EXACT("\>")
}
or $xact->[-2] or
do {
push @gather, do {
if (my ($C) = ($C->FAILGOAL($::GOAL, 'metachar', $goalpos))) { ($C) } else { () }

}
};
@gather;
}
}))) {
$C
} else { () }
}));
}
;
## token metachar:sym<\\> { <sym> <backslash> }
sub metachar__S_038Back__PEEK { $_[0]->_AUTOLEXpeek('metachar__S_038Back', $retree) }
sub metachar__S_038Back {
no warnings 'recursion';
my $self = shift;


local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;

my $C = $self->cursor_xact("RULE metachar__S_038Back");
my $xact = $C->xact;
my $S = $C->{'_pos'};
$C->{sym} = "\\";
$self->_MATCHIFYr($S, "metachar__S_038Back", do {
if (my ($C) = ($C->_EXACT("\\"))) {
$C->_SUBSUMEr(['backslash'], sub {
my $C = shift;
$C->backslash
})
} else { () }

});
}
;
## token metachar:sym<.>  { <sym> }
sub metachar__S_039Dot__PEEK { $_[0]->_AUTOLEXpeek('metachar__S_039Dot', $retree) }
sub metachar__S_039Dot {
no warnings 'recursion';
my $self = shift;


local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;

my $C = $self->cursor_xact("RULE metachar__S_039Dot");
my $xact = $C->xact;
my $S = $C->{'_pos'};
$C->{sym} = "\.";
$self->_MATCHIFYr($S, "metachar__S_039Dot", $C->_EXACT("\."));
}
;
## token metachar:sym<^^> { <sym> }
sub metachar__S_040CaretCaret__PEEK { $_[0]->_AUTOLEXpeek('metachar__S_040CaretCaret', $retree) }
sub metachar__S_040CaretCaret {
no warnings 'recursion';
my $self = shift;


local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;

my $C = $self->cursor_xact("RULE metachar__S_040CaretCaret");
my $xact = $C->xact;
my $S = $C->{'_pos'};
$C->{sym} = "\^\^";
$self->_MATCHIFYr($S, "metachar__S_040CaretCaret", $C->_EXACT("\^\^"));
}
;
## token metachar:sym<^>  { <sym> }
sub metachar__S_041Caret__PEEK { $_[0]->_AUTOLEXpeek('metachar__S_041Caret', $retree) }
sub metachar__S_041Caret {
no warnings 'recursion';
my $self = shift;


local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;

my $C = $self->cursor_xact("RULE metachar__S_041Caret");
my $xact = $C->xact;
my $S = $C->{'_pos'};
$C->{sym} = "\^";
$self->_MATCHIFYr($S, "metachar__S_041Caret", $C->_EXACT("\^"));
}
;
## token metachar:sym<$$> {
sub metachar__S_042DollarDollar__PEEK { $_[0]->_AUTOLEXpeek('metachar__S_042DollarDollar', $retree) }
sub metachar__S_042DollarDollar {
no warnings 'recursion';
my $self = shift;


local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;

my $C = $self->cursor_xact("RULE metachar__S_042DollarDollar");
my $xact = $C->xact;
my $S = $C->{'_pos'};
$C->{'0'} = [];
$C->{sym} = "\$\$";
$self->_MATCHIFYr($S, "metachar__S_042DollarDollar", do {
if (my ($C) = ($C->_EXACT("\$\$"))) {
$C->_OPTr(sub {
my $C=shift;
if (my ($C) = ($C->_BRACKETr(sub {
my $C=shift;
if (($C) = ($C->_SUBSUMEr(['0'], sub {
my $C = shift;
$C->_PAREN( sub {
my $C=shift;
$C->_PATTERN(qr/\G\w++/)

})
}))
and ($C) = (do {
my $M = $C;
$C->obs("\$\$" . $M->{0}->Str . " to deref var inside a regex", "\$(\$" . $M->{0}->Str . ")")
})) {
$C
} else { () }
}))) { ($C) } else { () }
})
} else { () }

});
}
;
## token metachar:sym<$>  {
sub metachar__S_043Dollar__PEEK { $_[0]->_AUTOLEXpeek('metachar__S_043Dollar', $retree) }
sub metachar__S_043Dollar {
no warnings 'recursion';
my $self = shift;


local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;

my $C = $self->cursor_xact("RULE metachar__S_043Dollar");
my $xact = $C->xact;
my $S = $C->{'_pos'};
$C->{sym} = "\$";
$self->_MATCHIFYr($S, "metachar__S_043Dollar", do {
my $C = $C;
if (($C) = ($C->_EXACT("\$"))
and ($C) = ($C->before(sub {
my $C=shift;
if (my ($C) = ($C->before(sub {
my $C=shift;
if (my ($C) = (do {
do {
my ($tag, $try);
my @try;
my $relex;

my $fate;
my $x;
if ($fate = $C->{'_fate'} and $fate->[1] eq 'metachar__S_043Dollar_0') {
$C->deb("Fate passed to metachar__S_043Dollar_0: ", ::fatestr($fate)) if $::DEBUG & DEBUG::fates;
($C->{'_fate'}, $tag, $try) = @$fate;
@try = ($try);
$x = 'ALT metachar__S_043Dollar_0';    # some outer ltm is controlling us
}
else {
$x = 'ALTLTM metachar__S_043Dollar_0'; # we are top level ltm
}
my $C = $C->cursor_xact($x);
my $xact = $C->{_xact};

my @gather = ();
for (;;) {
unless (@try) {
$relex //= $C->cursor_fate('STD::Regex', 'metachar__S_043Dollar_0', $retree);
@try = $relex->($C) or last;
}
$try = shift(@try) // next;

if (ref $try) {
($C->{'_fate'}, $tag, $try) = @$try;   # next candidate fate
}

$C->deb("metachar__S_043Dollar_0 trying $tag $try") if $::DEBUG & DEBUG::try_processing;
push @gather, ((
sub {
my $C=shift;
$C->_PATTERN(qr/\G\s/)
},
sub {
my $C=shift;
$C->_EXACT("\|")
},
sub {
my $C=shift;
$C->_EXACT("\&")
},
sub {
my $C=shift;
$C->_EXACT("\)")
},
sub {
my $C=shift;
$C->_EXACT("\]")
},
sub {
my $C=shift;
$C->_EXACT("\>")
},
sub {
my $C=shift;
$C->_PATTERN(qr/\G\z/)
},
sub {
my $C=shift;
if (my ($C) = ($C->stopper)) { ($C) } else { () }
}
)[$try])->($C);
last if @gather;
last if $xact->[-2];  # committed?
}
@gather;
};

})) { ($C) } else { () }
}))) { ($C) } else { () }
}))) {
$C
} else { () }

});
}
;
## token metachar:sym<' '> { <?before "'"> [:lang(%*LANG<MAIN>) <quote>] }
sub metachar__S_044Single_Single__PEEK { $_[0]->_AUTOLEXpeek('metachar__S_044Single_Single', $retree) }
sub metachar__S_044Single_Single {
no warnings 'recursion';
my $self = shift;


local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;

my $C = $self->cursor_xact("RULE metachar__S_044Single_Single");
my $xact = $C->xact;
my $S = $C->{'_pos'};
$C->{sym} = "\'\ \'";
$self->_MATCHIFYr($S, "metachar__S_044Single_Single", do {
my $C = $C;
if (($C) = ($C->before(sub {
my $C=shift;
if (my ($C) = ($C->before(sub {
my $C=shift;
$C->_EXACT("\'")
}))) { ($C) } else { () }
}))
and ($C) = ($C->_BRACKETr(sub {
my $C=shift;
my $newlang = ($::LANG{'MAIN'});
$C = bless($C, (ref($newlang) || $newlang));
$C->_SUBSUMEr(['quote'], sub {
my $C = shift;
$C->quote
})
}))) {
$C
} else { () }

});
}
;
## token metachar:sym<" "> { <?before '"'> [:lang(%*LANG<MAIN>) <quote>] }
sub metachar__S_045Double_Double__PEEK { $_[0]->_AUTOLEXpeek('metachar__S_045Double_Double', $retree) }
sub metachar__S_045Double_Double {
no warnings 'recursion';
my $self = shift;


local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;

my $C = $self->cursor_xact("RULE metachar__S_045Double_Double");
my $xact = $C->xact;
my $S = $C->{'_pos'};
$C->{sym} = "\"\ \"";
$self->_MATCHIFYr($S, "metachar__S_045Double_Double", do {
my $C = $C;
if (($C) = ($C->before(sub {
my $C=shift;
if (my ($C) = ($C->before(sub {
my $C=shift;
$C->_EXACT("\"")
}))) { ($C) } else { () }
}))
and ($C) = ($C->_BRACKETr(sub {
my $C=shift;
my $newlang = ($::LANG{'MAIN'});
$C = bless($C, (ref($newlang) || $newlang));
$C->_SUBSUMEr(['quote'], sub {
my $C = shift;
$C->quote
})
}))) {
$C
} else { () }

});
}
;
## token metachar:var {
sub metachar__S_046var__PEEK { $_[0]->_AUTOLEXpeek('metachar__S_046var', $retree) }
sub metachar__S_046var {
no warnings 'recursion';
my $self = shift;

local $::QSIGIL = substr($::ORIG,$self->{'_pos'},1);
local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;

my $C = $self->cursor_xact("RULE metachar__S_046var");
my $xact = $C->xact;
my $S = $C->{'_pos'};
$C->{sym} = "var";
$self->_MATCHIFYr($S, "metachar__S_046var", do {
my $C = $C;
if (($C) = ($C->_NOTBEFORE(sub {
my $C=shift;
if (my ($C) = ($C->before(sub {
my $C=shift;
$C->_EXACT("\$\$")
}))) { ($C) } else { () }
}))
and ($C) = ($C->before(sub {
my $C=shift;
if (my ($C) = ($C->before(sub {
my $C=shift;
$C->_SUBSUMEr(['sigil'], sub {
my $C = shift;
$C->sigil
})
}))) { ($C) } else { () }
}))
and ($C) = ($C->_BRACKETr(sub {
my $C=shift;
my $newlang = ($::LANG{'MAIN'});
$C = bless($C, (ref($newlang) || $newlang));
$C->_SUBSUMEr(['variable'], sub {
my $C = shift;
$C->variable
})
}))
and ($C) = (scalar(do {
my $M = $C;
$M->{'sym'} = $M->{'variable'}->Str}, $C))
and ($C) = ($C->_BRACKETr(sub {
my $C=shift;
do {    my $C = $C->cursor_xact('ALT ||');
my $xact = $C->xact;
my @gather;
do {
push @gather, do {
if (my ($C) = ($C->_SUBSUMEr(['binding'], sub {
my $C = shift;
$C->_PAREN( sub {
my $C=shift;
if (my ($C) = ($C->_PATTERN(qr/\G\s*+\=\s*+/))) {
$C->_SUBSUMEr(['quantified_atom'], sub {
my $C = shift;
$C->quantified_atom
})
} else { () }

})
}))) {
scalar(do {
my $M = $C;
$C->check_variable($M->{'variable'}) unless substr($M->{'sym'},1,1) eq '<' }, $C)
} else { () }

}
}
or $xact->[-2] or
do {
push @gather, do {
if (my ($C) = (scalar(do {
my $M = $C;
$C->check_variable($M->{'variable'}) }, $C))) {
$C->_OPTr(sub {
my $C=shift;
if (my ($C) = ($C->_BRACKETr(sub {
my $C=shift;
if (($C) = ($C->before(sub {
my $C=shift;
if (my ($C) = ($C->before(sub {
my $C=shift;
$C->_PATTERN(qr/\G\.?+[\[\{\<]/)
}))) { ($C) } else { () }
}))
and ($C) = ($C->worry("Apparent subscript will be treated as regex"))) {
$C
} else { () }
}))) { ($C) } else { () }
})
} else { () }

}
};
@gather;
}
}))) {
$C
} else { () }

});
}
;
## token backslash:unspace { <?before \s> <.SUPER::ws> }
sub backslash__S_047unspace__PEEK { $_[0]->_AUTOLEXpeek('backslash__S_047unspace', $retree) }
sub backslash__S_047unspace {
no warnings 'recursion';
my $self = shift;


local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;

my $C = $self->cursor_xact("RULE backslash__S_047unspace");
my $xact = $C->xact;
my $S = $C->{'_pos'};
$C->{sym} = "unspace";
$self->_MATCHIFYr($S, "backslash__S_047unspace", do {
my $C = $C;
if (($C) = ($C->before(sub {
my $C=shift;
if (my ($C) = ($C->before(sub {
my $C=shift;
$C->_PATTERN(qr/\G\s/)
}))) { ($C) } else { () }
}))
and ($C) = ($C->SUPER::ws)) {
$C
} else { () }

});
}
;
## token backslash:sym<0> { '0' <!before <[0..7]> > }
sub backslash__S_0480__PEEK { $_[0]->_AUTOLEXpeek('backslash__S_0480', $retree) }
sub backslash__S_0480 {
no warnings 'recursion';
my $self = shift;


local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;

my $C = $self->cursor_xact("RULE backslash__S_0480");
my $xact = $C->xact;
my $S = $C->{'_pos'};
$self->_MATCHIFYr($S, "backslash__S_0480", do {
my $C = $C;
if (($C) = ($C->_EXACT("0"))
and ($C) = ($C->_NOTBEFORE(sub {
my $C=shift;
if (my ($C) = ($C->before(sub {
my $C=shift;
$C->_PATTERN(qr/\G[0-7]/)
}))) { ($C) } else { () }
}))) {
$C
} else { () }

});
}
;
## token backslash:A { <sym> <.obs('\\A as beginning-of-string matcher', '^')> }
sub backslash__S_049A__PEEK { $_[0]->_AUTOLEXpeek('backslash__S_049A', $retree) }
sub backslash__S_049A {
no warnings 'recursion';
my $self = shift;


local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;

my $C = $self->cursor_xact("RULE backslash__S_049A");
my $xact = $C->xact;
my $S = $C->{'_pos'};
$C->{sym} = "A";
$self->_MATCHIFYr($S, "backslash__S_049A", do {
my $C = $C;
if (($C) = ($C->_EXACT("A"))
and ($C) = ($C->obs('\\A as beginning-of-string matcher', '^'))) {
$C
} else { () }

});
}
;
## token backslash:a { <sym> <.sorry: "\\a is allowed only in strings, not regexes"> }
sub backslash__S_050a__PEEK { $_[0]->_AUTOLEXpeek('backslash__S_050a', $retree) }
sub backslash__S_050a {
no warnings 'recursion';
my $self = shift;


local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;

my $C = $self->cursor_xact("RULE backslash__S_050a");
my $xact = $C->xact;
my $S = $C->{'_pos'};
$C->{sym} = "a";
$self->_MATCHIFYr($S, "backslash__S_050a", do {
my $C = $C;
if (($C) = ($C->_EXACT("a"))
and ($C) = ($C->sorry("\\a is allowed only in strings, not regexes"))) {
$C
} else { () }

});
}
;
## token backslash:B { <sym> <.obs('\\B as word non-boundary', '<!wb>')> }
sub backslash__S_051B__PEEK { $_[0]->_AUTOLEXpeek('backslash__S_051B', $retree) }
sub backslash__S_051B {
no warnings 'recursion';
my $self = shift;


local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;

my $C = $self->cursor_xact("RULE backslash__S_051B");
my $xact = $C->xact;
my $S = $C->{'_pos'};
$C->{sym} = "B";
$self->_MATCHIFYr($S, "backslash__S_051B", do {
my $C = $C;
if (($C) = ($C->_EXACT("B"))
and ($C) = ($C->obs('\\B as word non-boundary', '<!wb>'))) {
$C
} else { () }

});
}
;
## token backslash:b { <sym> <.obs('\\b as word boundary', '<?wb> (or either of « or »)')> }
sub backslash__S_052b__PEEK { $_[0]->_AUTOLEXpeek('backslash__S_052b', $retree) }
sub backslash__S_052b {
no warnings 'recursion';
my $self = shift;


local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;

my $C = $self->cursor_xact("RULE backslash__S_052b");
my $xact = $C->xact;
my $S = $C->{'_pos'};
$C->{sym} = "b";
$self->_MATCHIFYr($S, "backslash__S_052b", do {
my $C = $C;
if (($C) = ($C->_EXACT("b"))
and ($C) = ($C->obs('\\b as word boundary', '<?wb> (or either of « or »)'))) {
$C
} else { () }

});
}
;
## token backslash:c { :i <sym> <charspec> }
sub backslash__S_053c__PEEK { $_[0]->_AUTOLEXpeek('backslash__S_053c', $retree) }
sub backslash__S_053c {
no warnings 'recursion';
my $self = shift;


local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;

my $C = $self->cursor_xact("RULE backslash__S_053c");
my $xact = $C->xact;
my $S = $C->{'_pos'};
$C->{sym} = "c";
$self->_MATCHIFYr($S, "backslash__S_053c", do {
if (my ($C) = ($C->_PATTERN(qr/\G(?i:c)/))) {
$C->_SUBSUMEr(['charspec'], sub {
my $C = shift;
$C->charspec
})
} else { () }

});
}
;
## token backslash:d { :i <sym> }
sub backslash__S_054d__PEEK { $_[0]->_AUTOLEXpeek('backslash__S_054d', $retree) }
sub backslash__S_054d {
no warnings 'recursion';
my $self = shift;


local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;

my $C = $self->cursor_xact("RULE backslash__S_054d");
my $xact = $C->xact;
my $S = $C->{'_pos'};
$C->{sym} = "d";
$self->_MATCHIFYr($S, "backslash__S_054d", $C->_PATTERN(qr/\G(?i:d)/));
}
;
## token backslash:e { :i <sym> }
sub backslash__S_055e__PEEK { $_[0]->_AUTOLEXpeek('backslash__S_055e', $retree) }
sub backslash__S_055e {
no warnings 'recursion';
my $self = shift;


local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;

my $C = $self->cursor_xact("RULE backslash__S_055e");
my $xact = $C->xact;
my $S = $C->{'_pos'};
$C->{sym} = "e";
$self->_MATCHIFYr($S, "backslash__S_055e", $C->_PATTERN(qr/\G(?i:e)/));
}
;
## token backslash:f { :i <sym> }
sub backslash__S_056f__PEEK { $_[0]->_AUTOLEXpeek('backslash__S_056f', $retree) }
sub backslash__S_056f {
no warnings 'recursion';
my $self = shift;


local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;

my $C = $self->cursor_xact("RULE backslash__S_056f");
my $xact = $C->xact;
my $S = $C->{'_pos'};
$C->{sym} = "f";
$self->_MATCHIFYr($S, "backslash__S_056f", $C->_PATTERN(qr/\G(?i:f)/));
}
;
## token backslash:h { :i <sym> }
sub backslash__S_057h__PEEK { $_[0]->_AUTOLEXpeek('backslash__S_057h', $retree) }
sub backslash__S_057h {
no warnings 'recursion';
my $self = shift;


local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;

my $C = $self->cursor_xact("RULE backslash__S_057h");
my $xact = $C->xact;
my $S = $C->{'_pos'};
$C->{sym} = "h";
$self->_MATCHIFYr($S, "backslash__S_057h", $C->_PATTERN(qr/\G(?i:h)/));
}
;
## token backslash:n { :i <sym> }
sub backslash__S_058n__PEEK { $_[0]->_AUTOLEXpeek('backslash__S_058n', $retree) }
sub backslash__S_058n {
no warnings 'recursion';
my $self = shift;


local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;

my $C = $self->cursor_xact("RULE backslash__S_058n");
my $xact = $C->xact;
my $S = $C->{'_pos'};
$C->{sym} = "n";
$self->_MATCHIFYr($S, "backslash__S_058n", $C->_PATTERN(qr/\G(?i:n)/));
}
;
## token backslash:o { :i :dba('octal character') <sym> [ <octint> | '[' ~ ']' <octints> ] }
sub backslash__S_059o__PEEK { $_[0]->_AUTOLEXpeek('backslash__S_059o', $retree) }
sub backslash__S_059o {
no warnings 'recursion';
my $self = shift;


local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;

my $C = $self->cursor_xact("RULE backslash__S_059o");
my $xact = $C->xact;
my $S = $C->{'_pos'};
$C->{sym} = "o";
$self->_MATCHIFYr($S, "backslash__S_059o", do {
my $C = $C;
if (($C) = ($C->_PATTERN(qr/\G(?i:o)/))
and ($C) = ($C->_BRACKETr(sub {
my $C=shift;
do {
my ($tag, $try);
my @try;
my $relex;

my $fate;
my $x;
if ($fate = $C->{'_fate'} and $fate->[1] eq 'backslash__S_059o_0') {
$C->deb("Fate passed to backslash__S_059o_0: ", ::fatestr($fate)) if $::DEBUG & DEBUG::fates;
($C->{'_fate'}, $tag, $try) = @$fate;
@try = ($try);
$x = 'ALT backslash__S_059o_0';    # some outer ltm is controlling us
}
else {
$x = 'ALTLTM backslash__S_059o_0'; # we are top level ltm
}
my $C = $C->cursor_xact($x);
my $xact = $C->{_xact};

my @gather = ();
for (;;) {
unless (@try) {
$relex //= $C->cursor_fate('STD::Regex', 'backslash__S_059o_0', $retree);
@try = $relex->($C) or last;
}
$try = shift(@try) // next;

if (ref $try) {
($C->{'_fate'}, $tag, $try) = @$try;   # next candidate fate
}

$C->deb("backslash__S_059o_0 trying $tag $try") if $::DEBUG & DEBUG::try_processing;
push @gather, ((
sub {
my $C=shift;
$C->_SUBSUMEr(['octint'], sub {
my $C = shift;
$C->octint
})
},
sub {
my $C=shift;
if (my ($C) = ($C->_BRACKETr(sub {
my $C=shift;
local $::GOAL = "\]";
my $goalpos = $C;
if (($C) = ($C->_PATTERN(qr/\G(?i:\[)/))
and ($C) = (scalar(do {
}, $C))
and ($C) = ($C->_SUBSUMEr(['octints'], sub {
my $C = shift;
$C->octints
}))
and ($C) = ($C->_BRACKETr(sub {
my $C=shift;
do {    my $C = $C->cursor_xact('ALT ||');
my $xact = $C->xact;
my @gather;
do {
push @gather, $C->_PATTERN(qr/\G(?i:\])/)
}
or $xact->[-2] or
do {
push @gather, do {
if (my ($C) = ($C->FAILGOAL($::GOAL, 'octal character', $goalpos))) { ($C) } else { () }

}
};
@gather;
}
}))) {
$C
} else { () }
}))) { ($C) } else { () }
}
)[$try])->($C);
last if @gather;
last if $xact->[-2];  # committed?
}
@gather;
};
}))) {
$C
} else { () }

});
}
;
## token backslash:p {
sub backslash__S_060p__PEEK { $_[0]->_AUTOLEXpeek('backslash__S_060p', $retree) }
sub backslash__S_060p {
no warnings 'recursion';
my $self = shift;

my $s;my $m;my $p;
local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;

my $C = $self->cursor_xact("RULE backslash__S_060p");
my $xact = $C->xact;
my $S = $C->{'_pos'};
$C->{sym} = "p";
$self->_MATCHIFYr($S, "backslash__S_060p", do {
my $C = $C;
if (($C) = ($C->_SUBSUMEr(['sym'], sub {
my $C = shift;
$C->_PATTERN(qr/\G[pP]/)
}))
and ($C) = (scalar(do {
my $M = $C;
$s = $M->{'sym'}->Str;
$m = $s lt 'a' ? '-' : '+';
}, $C))
and ($C) = ($C->_BRACKETr(sub {
my $C=shift;
do {    my $C = $C->cursor_xact('ALT ||');
my $xact = $C->xact;
my @gather;
do {
push @gather, do {
if (my ($C) = ($C->_SUBSUMEr(['0'], sub {
my $C = shift;
$C->_PAREN( sub {
my $C=shift;
$C->_PATTERN(qr/\G\w/)

})
}))) {
scalar(do {
my $M = $C;
$p = $M->{0}->Str;
$C->obs("\\$s$p", '<' . $m . "is$p>");
}, $C)
} else { () }

}
}
or $xact->[-2] or
do {
push @gather, do {
my $C = $C;
if (($C) = ($C->_EXACT("\{"))
and ($C) = ($C->_SUBSUMEr(['param'], sub {
my $C = shift;
$C->_BRACKETr(sub {
my $C=shift;
$C->_PATTERN(qr/\G\w++/)
})
}))
and ($C) = ($C->_EXACT("\}"))) {
scalar(do {
my $M = $C;
$p = $M->{'param'}->Str;
$C->obs("\\$s\{$p\}", '<' . $m . "is$p>");
}, $C)
} else { () }

}
}
or $xact->[-2] or
do {
push @gather, do {
my $C = $C;
if (($C) = ($C->_EXACT("\{"))
and ($C) = ($C->_SUBSUMEr(['param'], sub {
my $C = shift;
$C->_BRACKETr(sub {
my $C=shift;
$C->_PATTERN(qr/\G\w++/)
})
}))
and ($C) = ($C->_EXACT("\="))
and ($C) = ($C->_SUBSUMEr(['val'], sub {
my $C = shift;
$C->_BRACKETr(sub {
my $C=shift;
$C->_PATTERN(qr/\G(?:[^\}])*+/)
})
}))
and ($C) = ($C->_EXACT("\}"))) {
scalar(do {
my $M = $C;
$p = $M->{'param'}->Str;
my $v = $M->{'val'}->Str;
$C->obs("\\$s\{$p=$v\}", '<' . $m . "is$p\('$v')>");
}, $C)
} else { () }

}
};
@gather;
}
}))) {
$C
} else { () }

});
}
;
## token backslash:Q { <sym> <.obs('\\Q as quotemeta', 'quotes or literal variable match')> }
sub backslash__S_061Q__PEEK { $_[0]->_AUTOLEXpeek('backslash__S_061Q', $retree) }
sub backslash__S_061Q {
no warnings 'recursion';
my $self = shift;


local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;

my $C = $self->cursor_xact("RULE backslash__S_061Q");
my $xact = $C->xact;
my $S = $C->{'_pos'};
$C->{sym} = "Q";
$self->_MATCHIFYr($S, "backslash__S_061Q", do {
my $C = $C;
if (($C) = ($C->_EXACT("Q"))
and ($C) = ($C->obs('\\Q as quotemeta', 'quotes or literal variable match'))) {
$C
} else { () }

});
}
;
## token backslash:r { :i <sym> }
sub backslash__S_062r__PEEK { $_[0]->_AUTOLEXpeek('backslash__S_062r', $retree) }
sub backslash__S_062r {
no warnings 'recursion';
my $self = shift;


local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;

my $C = $self->cursor_xact("RULE backslash__S_062r");
my $xact = $C->xact;
my $S = $C->{'_pos'};
$C->{sym} = "r";
$self->_MATCHIFYr($S, "backslash__S_062r", $C->_PATTERN(qr/\G(?i:r)/));
}
;
## token backslash:s { :i <sym> }
sub backslash__S_063s__PEEK { $_[0]->_AUTOLEXpeek('backslash__S_063s', $retree) }
sub backslash__S_063s {
no warnings 'recursion';
my $self = shift;


local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;

my $C = $self->cursor_xact("RULE backslash__S_063s");
my $xact = $C->xact;
my $S = $C->{'_pos'};
$C->{sym} = "s";
$self->_MATCHIFYr($S, "backslash__S_063s", $C->_PATTERN(qr/\G(?i:s)/));
}
;
## token backslash:t { :i <sym> }
sub backslash__S_064t__PEEK { $_[0]->_AUTOLEXpeek('backslash__S_064t', $retree) }
sub backslash__S_064t {
no warnings 'recursion';
my $self = shift;


local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;

my $C = $self->cursor_xact("RULE backslash__S_064t");
my $xact = $C->xact;
my $S = $C->{'_pos'};
$C->{sym} = "t";
$self->_MATCHIFYr($S, "backslash__S_064t", $C->_PATTERN(qr/\G(?i:t)/));
}
;
## token backslash:v { :i <sym> }
sub backslash__S_065v__PEEK { $_[0]->_AUTOLEXpeek('backslash__S_065v', $retree) }
sub backslash__S_065v {
no warnings 'recursion';
my $self = shift;


local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;

my $C = $self->cursor_xact("RULE backslash__S_065v");
my $xact = $C->xact;
my $S = $C->{'_pos'};
$C->{sym} = "v";
$self->_MATCHIFYr($S, "backslash__S_065v", $C->_PATTERN(qr/\G(?i:v)/));
}
;
## token backslash:w { :i <sym> }
sub backslash__S_066w__PEEK { $_[0]->_AUTOLEXpeek('backslash__S_066w', $retree) }
sub backslash__S_066w {
no warnings 'recursion';
my $self = shift;


local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;

my $C = $self->cursor_xact("RULE backslash__S_066w");
my $xact = $C->xact;
my $S = $C->{'_pos'};
$C->{sym} = "w";
$self->_MATCHIFYr($S, "backslash__S_066w", $C->_PATTERN(qr/\G(?i:w)/));
}
;
## token backslash:x { :i :dba('hex character') <sym> [ <hexint> | '[' ~ ']' <hexints> ] }
sub backslash__S_067x__PEEK { $_[0]->_AUTOLEXpeek('backslash__S_067x', $retree) }
sub backslash__S_067x {
no warnings 'recursion';
my $self = shift;


local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;

my $C = $self->cursor_xact("RULE backslash__S_067x");
my $xact = $C->xact;
my $S = $C->{'_pos'};
$C->{sym} = "x";
$self->_MATCHIFYr($S, "backslash__S_067x", do {
my $C = $C;
if (($C) = ($C->_PATTERN(qr/\G(?i:x)/))
and ($C) = ($C->_BRACKETr(sub {
my $C=shift;
do {
my ($tag, $try);
my @try;
my $relex;

my $fate;
my $x;
if ($fate = $C->{'_fate'} and $fate->[1] eq 'backslash__S_067x_0') {
$C->deb("Fate passed to backslash__S_067x_0: ", ::fatestr($fate)) if $::DEBUG & DEBUG::fates;
($C->{'_fate'}, $tag, $try) = @$fate;
@try = ($try);
$x = 'ALT backslash__S_067x_0';    # some outer ltm is controlling us
}
else {
$x = 'ALTLTM backslash__S_067x_0'; # we are top level ltm
}
my $C = $C->cursor_xact($x);
my $xact = $C->{_xact};

my @gather = ();
for (;;) {
unless (@try) {
$relex //= $C->cursor_fate('STD::Regex', 'backslash__S_067x_0', $retree);
@try = $relex->($C) or last;
}
$try = shift(@try) // next;

if (ref $try) {
($C->{'_fate'}, $tag, $try) = @$try;   # next candidate fate
}

$C->deb("backslash__S_067x_0 trying $tag $try") if $::DEBUG & DEBUG::try_processing;
push @gather, ((
sub {
my $C=shift;
$C->_SUBSUMEr(['hexint'], sub {
my $C = shift;
$C->hexint
})
},
sub {
my $C=shift;
if (my ($C) = ($C->_BRACKETr(sub {
my $C=shift;
local $::GOAL = "\]";
my $goalpos = $C;
if (($C) = ($C->_PATTERN(qr/\G(?i:\[)/))
and ($C) = (scalar(do {
}, $C))
and ($C) = ($C->_SUBSUMEr(['hexints'], sub {
my $C = shift;
$C->hexints
}))
and ($C) = ($C->_BRACKETr(sub {
my $C=shift;
do {    my $C = $C->cursor_xact('ALT ||');
my $xact = $C->xact;
my @gather;
do {
push @gather, $C->_PATTERN(qr/\G(?i:\])/)
}
or $xact->[-2] or
do {
push @gather, do {
if (my ($C) = ($C->FAILGOAL($::GOAL, 'hex character', $goalpos))) { ($C) } else { () }

}
};
@gather;
}
}))) {
$C
} else { () }
}))) { ($C) } else { () }
}
)[$try])->($C);
last if @gather;
last if $xact->[-2];  # committed?
}
@gather;
};
}))) {
$C
} else { () }

});
}
;
## token backslash:z { <sym> <.obs('\\z as end-of-string matcher', '$')> }
sub backslash__S_068z__PEEK { $_[0]->_AUTOLEXpeek('backslash__S_068z', $retree) }
sub backslash__S_068z {
no warnings 'recursion';
my $self = shift;


local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;

my $C = $self->cursor_xact("RULE backslash__S_068z");
my $xact = $C->xact;
my $S = $C->{'_pos'};
$C->{sym} = "z";
$self->_MATCHIFYr($S, "backslash__S_068z", do {
my $C = $C;
if (($C) = ($C->_EXACT("z"))
and ($C) = ($C->obs('\\z as end-of-string matcher', '$'))) {
$C
} else { () }

});
}
;
## token backslash:Z { <sym> <.obs('\\Z as end-of-string matcher', '\\n?$')> }
sub backslash__S_069Z__PEEK { $_[0]->_AUTOLEXpeek('backslash__S_069Z', $retree) }
sub backslash__S_069Z {
no warnings 'recursion';
my $self = shift;


local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;

my $C = $self->cursor_xact("RULE backslash__S_069Z");
my $xact = $C->xact;
my $S = $C->{'_pos'};
$C->{sym} = "Z";
$self->_MATCHIFYr($S, "backslash__S_069Z", do {
my $C = $C;
if (($C) = ($C->_EXACT("Z"))
and ($C) = ($C->obs('\\Z as end-of-string matcher', '\\n?$'))) {
$C
} else { () }

});
}
;
## token backslash:misc { $<litchar>=(\W) }
sub backslash__S_070misc__PEEK { $_[0]->_AUTOLEXpeek('backslash__S_070misc', $retree) }
sub backslash__S_070misc {
no warnings 'recursion';
my $self = shift;


local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;

my $C = $self->cursor_xact("RULE backslash__S_070misc");
my $xact = $C->xact;
my $S = $C->{'_pos'};
$C->{sym} = "misc";
$self->_MATCHIFYr($S, "backslash__S_070misc", $C->_SUBSUMEr(['litchar'], sub {
my $C = shift;
$C->_PAREN( sub {
my $C=shift;
$C->_PATTERN(qr/\G\W/)

})
}));
}
;
## token backslash:oldbackref { (<[1..9]>\d*) { my $d = $0.Str; $¢.sorryobs("the 1-based special form '
sub backslash__S_071oldbackref__PEEK { $_[0]->_AUTOLEXpeek('backslash__S_071oldbackref', $retree) }
sub backslash__S_071oldbackref {
no warnings 'recursion';
my $self = shift;


local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;

my $C = $self->cursor_xact("RULE backslash__S_071oldbackref");
my $xact = $C->xact;
my $S = $C->{'_pos'};
$C->{sym} = "oldbackref";
$self->_MATCHIFYr($S, "backslash__S_071oldbackref", do {
if (my ($C) = ($C->_SUBSUMEr(['0'], sub {
my $C = shift;
$C->_PAREN( sub {
my $C=shift;
$C->_PATTERN(qr/\G[1-9]\d*+/)

})
}))) {
scalar(do {
my $M = $C;
my $d = $M->{0}->Str;
$C->sorryobs("the 1-based special form '\\$d' as a backreference", "the 0-based variable '\$" . ($d - 1) . "' instead" );
}, $C)
} else { () }

});
}
;
## token backslash:oops { <.sorry: "Unrecognized regex backslash sequence"> . }
sub backslash__S_072oops__PEEK { $_[0]->_AUTOLEXpeek('backslash__S_072oops', $retree) }
sub backslash__S_072oops {
no warnings 'recursion';
my $self = shift;


local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;

my $C = $self->cursor_xact("RULE backslash__S_072oops");
my $xact = $C->xact;
my $S = $C->{'_pos'};
$C->{sym} = "oops";
$self->_MATCHIFYr($S, "backslash__S_072oops", do {
if (my ($C) = ($C->sorry("Unrecognized regex backslash sequence"))) {
$C->cursor_incr()
} else { () }

});
}
;
## token assertion:sym<...> { <sym> }
sub assertion__S_073DotDotDot__PEEK { $_[0]->_AUTOLEXpeek('assertion__S_073DotDotDot', $retree) }
sub assertion__S_073DotDotDot {
no warnings 'recursion';
my $self = shift;


local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;

my $C = $self->cursor_xact("RULE assertion__S_073DotDotDot");
my $xact = $C->xact;
my $S = $C->{'_pos'};
$C->{sym} = "\.\.\.";
$self->_MATCHIFYr($S, "assertion__S_073DotDotDot", $C->_EXACT("\.\.\."));
}
;
## token assertion:sym<???> { <sym> }
sub assertion__S_074QuestionQuestionQuestion__PEEK { $_[0]->_AUTOLEXpeek('assertion__S_074QuestionQuestionQuestion', $retree) }
sub assertion__S_074QuestionQuestionQuestion {
no warnings 'recursion';
my $self = shift;


local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;

my $C = $self->cursor_xact("RULE assertion__S_074QuestionQuestionQuestion");
my $xact = $C->xact;
my $S = $C->{'_pos'};
$C->{sym} = "\?\?\?";
$self->_MATCHIFYr($S, "assertion__S_074QuestionQuestionQuestion", $C->_EXACT("\?\?\?"));
}
;
## token assertion:sym<!!!> { <sym> }
sub assertion__S_075BangBangBang__PEEK { $_[0]->_AUTOLEXpeek('assertion__S_075BangBangBang', $retree) }
sub assertion__S_075BangBangBang {
no warnings 'recursion';
my $self = shift;


local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;

my $C = $self->cursor_xact("RULE assertion__S_075BangBangBang");
my $xact = $C->xact;
my $S = $C->{'_pos'};
$C->{sym} = "\!\!\!";
$self->_MATCHIFYr($S, "assertion__S_075BangBangBang", $C->_EXACT("\!\!\!"));
}
;
## token assertion:sym<?> { <sym> [ <?before '>'> | <assertion> ] }
sub assertion__S_076Question__PEEK { $_[0]->_AUTOLEXpeek('assertion__S_076Question', $retree) }
sub assertion__S_076Question {
no warnings 'recursion';
my $self = shift;


local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;

my $C = $self->cursor_xact("RULE assertion__S_076Question");
my $xact = $C->xact;
my $S = $C->{'_pos'};
$C->{sym} = "\?";
$self->_MATCHIFYr($S, "assertion__S_076Question", do {
my $C = $C;
if (($C) = ($C->_EXACT("\?"))
and ($C) = ($C->_BRACKETr(sub {
my $C=shift;
do {
my ($tag, $try);
my @try;
my $relex;

my $fate;
my $x;
if ($fate = $C->{'_fate'} and $fate->[1] eq 'assertion__S_076Question_0') {
$C->deb("Fate passed to assertion__S_076Question_0: ", ::fatestr($fate)) if $::DEBUG & DEBUG::fates;
($C->{'_fate'}, $tag, $try) = @$fate;
@try = ($try);
$x = 'ALT assertion__S_076Question_0';    # some outer ltm is controlling us
}
else {
$x = 'ALTLTM assertion__S_076Question_0'; # we are top level ltm
}
my $C = $C->cursor_xact($x);
my $xact = $C->{_xact};

my @gather = ();
for (;;) {
unless (@try) {
$relex //= $C->cursor_fate('STD::Regex', 'assertion__S_076Question_0', $retree);
@try = $relex->($C) or last;
}
$try = shift(@try) // next;

if (ref $try) {
($C->{'_fate'}, $tag, $try) = @$try;   # next candidate fate
}

$C->deb("assertion__S_076Question_0 trying $tag $try") if $::DEBUG & DEBUG::try_processing;
push @gather, ((
sub {
my $C=shift;
if (my ($C) = ($C->before(sub {
my $C=shift;
if (my ($C) = ($C->before(sub {
my $C=shift;
$C->_EXACT("\>")
}))) { ($C) } else { () }
}))) { ($C) } else { () }
},
sub {
my $C=shift;
$C->_SUBSUMEr(['assertion'], sub {
my $C = shift;
$C->assertion
})
}
)[$try])->($C);
last if @gather;
last if $xact->[-2];  # committed?
}
@gather;
};
}))) {
$C
} else { () }

});
}
;
## token assertion:sym<!> { <sym> [ <?before '>'> | <assertion> ] }
sub assertion__S_077Bang__PEEK { $_[0]->_AUTOLEXpeek('assertion__S_077Bang', $retree) }
sub assertion__S_077Bang {
no warnings 'recursion';
my $self = shift;


local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;

my $C = $self->cursor_xact("RULE assertion__S_077Bang");
my $xact = $C->xact;
my $S = $C->{'_pos'};
$C->{sym} = "\!";
$self->_MATCHIFYr($S, "assertion__S_077Bang", do {
my $C = $C;
if (($C) = ($C->_EXACT("\!"))
and ($C) = ($C->_BRACKETr(sub {
my $C=shift;
do {
my ($tag, $try);
my @try;
my $relex;

my $fate;
my $x;
if ($fate = $C->{'_fate'} and $fate->[1] eq 'assertion__S_077Bang_0') {
$C->deb("Fate passed to assertion__S_077Bang_0: ", ::fatestr($fate)) if $::DEBUG & DEBUG::fates;
($C->{'_fate'}, $tag, $try) = @$fate;
@try = ($try);
$x = 'ALT assertion__S_077Bang_0';    # some outer ltm is controlling us
}
else {
$x = 'ALTLTM assertion__S_077Bang_0'; # we are top level ltm
}
my $C = $C->cursor_xact($x);
my $xact = $C->{_xact};

my @gather = ();
for (;;) {
unless (@try) {
$relex //= $C->cursor_fate('STD::Regex', 'assertion__S_077Bang_0', $retree);
@try = $relex->($C) or last;
}
$try = shift(@try) // next;

if (ref $try) {
($C->{'_fate'}, $tag, $try) = @$try;   # next candidate fate
}

$C->deb("assertion__S_077Bang_0 trying $tag $try") if $::DEBUG & DEBUG::try_processing;
push @gather, ((
sub {
my $C=shift;
if (my ($C) = ($C->before(sub {
my $C=shift;
if (my ($C) = ($C->before(sub {
my $C=shift;
$C->_EXACT("\>")
}))) { ($C) } else { () }
}))) { ($C) } else { () }
},
sub {
my $C=shift;
$C->_SUBSUMEr(['assertion'], sub {
my $C = shift;
$C->assertion
})
}
)[$try])->($C);
last if @gather;
last if $xact->[-2];  # committed?
}
@gather;
};
}))) {
$C
} else { () }

});
}
;
## token assertion:sym<*> { <sym> [ <?before '>'> | <.ws> <nibbler> ] }
sub assertion__S_078Star__PEEK { $_[0]->_AUTOLEXpeek('assertion__S_078Star', $retree) }
sub assertion__S_078Star {
no warnings 'recursion';
my $self = shift;


local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;

my $C = $self->cursor_xact("RULE assertion__S_078Star");
my $xact = $C->xact;
my $S = $C->{'_pos'};
$C->{sym} = "\*";
$self->_MATCHIFYr($S, "assertion__S_078Star", do {
my $C = $C;
if (($C) = ($C->_EXACT("\*"))
and ($C) = ($C->_BRACKETr(sub {
my $C=shift;
do {
my ($tag, $try);
my @try;
my $relex;

my $fate;
my $x;
if ($fate = $C->{'_fate'} and $fate->[1] eq 'assertion__S_078Star_0') {
$C->deb("Fate passed to assertion__S_078Star_0: ", ::fatestr($fate)) if $::DEBUG & DEBUG::fates;
($C->{'_fate'}, $tag, $try) = @$fate;
@try = ($try);
$x = 'ALT assertion__S_078Star_0';    # some outer ltm is controlling us
}
else {
$x = 'ALTLTM assertion__S_078Star_0'; # we are top level ltm
}
my $C = $C->cursor_xact($x);
my $xact = $C->{_xact};

my @gather = ();
for (;;) {
unless (@try) {
$relex //= $C->cursor_fate('STD::Regex', 'assertion__S_078Star_0', $retree);
@try = $relex->($C) or last;
}
$try = shift(@try) // next;

if (ref $try) {
($C->{'_fate'}, $tag, $try) = @$try;   # next candidate fate
}

$C->deb("assertion__S_078Star_0 trying $tag $try") if $::DEBUG & DEBUG::try_processing;
push @gather, ((
sub {
my $C=shift;
if (my ($C) = ($C->before(sub {
my $C=shift;
if (my ($C) = ($C->before(sub {
my $C=shift;
$C->_EXACT("\>")
}))) { ($C) } else { () }
}))) { ($C) } else { () }
},
sub {
my $C=shift;
if (my ($C) = ($C->ws)) {
$C->_SUBSUMEr(['nibbler'], sub {
my $C = shift;
$C->nibbler
})
} else { () }
}
)[$try])->($C);
last if @gather;
last if $xact->[-2];  # committed?
}
@gather;
};
}))) {
$C
} else { () }

});
}
;
## token assertion:sym<{ }> { <embeddedblock> }
sub assertion__S_079Cur_Ly__PEEK { $_[0]->_AUTOLEXpeek('assertion__S_079Cur_Ly', $retree) }
sub assertion__S_079Cur_Ly {
no warnings 'recursion';
my $self = shift;


local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;

my $C = $self->cursor_xact("RULE assertion__S_079Cur_Ly");
my $xact = $C->xact;
my $S = $C->{'_pos'};
$C->{sym} = "\{\ \}";
$self->_MATCHIFYr($S, "assertion__S_079Cur_Ly", $C->_SUBSUMEr(['embeddedblock'], sub {
my $C = shift;
$C->embeddedblock
}));
}
;
## token assertion:variable {
sub assertion__S_080variable__PEEK { $_[0]->_AUTOLEXpeek('assertion__S_080variable', $retree) }
sub assertion__S_080variable {
no warnings 'recursion';
my $self = shift;


local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;

my $C = $self->cursor_xact("RULE assertion__S_080variable");
my $xact = $C->xact;
my $S = $C->{'_pos'};
$C->{sym} = "variable";
$self->_MATCHIFYr($S, "assertion__S_080variable", do {
my $C = $C;
if (($C) = ($C->before(sub {
my $C=shift;
if (my ($C) = ($C->before(sub {
my $C=shift;
$C->_SUBSUMEr(['sigil'], sub {
my $C = shift;
$C->sigil
})
}))) { ($C) } else { () }
}))
and ($C) = ($C->_BRACKETr(sub {
my $C=shift;
my $newlang = ($C->cursor_fresh($::LANG{'MAIN'})->unbalanced('>'));
$C = bless($C, (ref($newlang) || $newlang));
$C->_SUBSUMEr(['variable'], sub {
my $C = shift;
$C->EXPR(\%LOOSEST)
})
}))) {
$C
} else { () }

});
}
;
## token assertion:method {
sub assertion__S_081method__PEEK { $_[0]->_AUTOLEXpeek('assertion__S_081method', $retree) }
sub assertion__S_081method {
no warnings 'recursion';
my $self = shift;


local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;

my $C = $self->cursor_xact("RULE assertion__S_081method");
my $xact = $C->xact;
my $S = $C->{'_pos'};
$C->{sym} = "method";
$self->_MATCHIFYr($S, "assertion__S_081method", do {
my $C = $C;
if (($C) = ($C->_EXACT("\."))
and ($C) = ($C->_BRACKETr(sub {
my $C=shift;
do {
my ($tag, $try);
my @try;
my $relex;

my $fate;
my $x;
if ($fate = $C->{'_fate'} and $fate->[1] eq 'assertion__S_081method_0') {
$C->deb("Fate passed to assertion__S_081method_0: ", ::fatestr($fate)) if $::DEBUG & DEBUG::fates;
($C->{'_fate'}, $tag, $try) = @$fate;
@try = ($try);
$x = 'ALT assertion__S_081method_0';    # some outer ltm is controlling us
}
else {
$x = 'ALTLTM assertion__S_081method_0'; # we are top level ltm
}
my $C = $C->cursor_xact($x);
my $xact = $C->{_xact};

my @gather = ();
for (;;) {
unless (@try) {
$relex //= $C->cursor_fate('STD::Regex', 'assertion__S_081method_0', $retree);
@try = $relex->($C) or last;
}
$try = shift(@try) // next;

if (ref $try) {
($C->{'_fate'}, $tag, $try) = @$try;   # next candidate fate
}

$C->deb("assertion__S_081method_0 trying $tag $try") if $::DEBUG & DEBUG::try_processing;
push @gather, ((
sub {
my $C=shift;
if (my ($C) = ($C->before(sub {
my $C=shift;
if (my ($C) = ($C->before(sub {
my $C=shift;
$C->_PATTERN(qr/\G[_[:alpha:]]/)
}))) { ($C) } else { () }
}))) {
$C->_SUBSUMEr(['assertion'], sub {
my $C = shift;
$C->assertion
})
} else { () }
},
sub {
my $C=shift;
if (my ($C) = ($C->_BRACKETr(sub {
my $C=shift;
my $newlang = ($C->cursor_fresh($::LANG{'MAIN'})->unbalanced('>'));
$C = bless($C, (ref($newlang) || $newlang));
$C->_SUBSUMEr(['dottyop'], sub {
my $C = shift;
$C->dottyop
})
}))) { ($C) } else { () }
}
)[$try])->($C);
last if @gather;
last if $xact->[-2];  # committed?
}
@gather;
};
}))) {
$C
} else { () }

});
}
;
## token assertion:name { [ :lang($¢.cursor_fresh(%*LANG<MAIN>).unbalanced('>')) <longname> ]
sub assertion__S_082name__PEEK { $_[0]->_AUTOLEXpeek('assertion__S_082name', $retree) }
sub assertion__S_082name {
no warnings 'recursion';
my $self = shift;


local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;

my $C = $self->cursor_xact("RULE assertion__S_082name");
my $xact = $C->xact;
my $S = $C->{'_pos'};
$C->{'arglist'} = [];
$C->{'assertion'} = [];
$C->{'nibbler'} = [];
$C->{sym} = "name";
$self->_MATCHIFYr($S, "assertion__S_082name", do {
if (my ($C) = ($C->_BRACKETr(sub {
my $C=shift;
my $newlang = ($C->cursor_fresh($::LANG{'MAIN'})->unbalanced('>'));
$C = bless($C, (ref($newlang) || $newlang));
$C->_SUBSUMEr(['longname'], sub {
my $C = shift;
$C->longname
})
}))) {
$C->_OPTr(sub {
my $C=shift;
if (my ($C) = ($C->_BRACKETr(sub {
my $C=shift;
do {
my ($tag, $try);
my @try;
my $relex;

my $fate;
my $x;
if ($fate = $C->{'_fate'} and $fate->[1] eq 'assertion__S_082name_0') {
$C->deb("Fate passed to assertion__S_082name_0: ", ::fatestr($fate)) if $::DEBUG & DEBUG::fates;
($C->{'_fate'}, $tag, $try) = @$fate;
@try = ($try);
$x = 'ALT assertion__S_082name_0';    # some outer ltm is controlling us
}
else {
$x = 'ALTLTM assertion__S_082name_0'; # we are top level ltm
}
my $C = $C->cursor_xact($x);
my $xact = $C->{_xact};

my @gather = ();
for (;;) {
unless (@try) {
$relex //= $C->cursor_fate('STD::Regex', 'assertion__S_082name_0', $retree);
@try = $relex->($C) or last;
}
$try = shift(@try) // next;

if (ref $try) {
($C->{'_fate'}, $tag, $try) = @$try;   # next candidate fate
}

$C->deb("assertion__S_082name_0 trying $tag $try") if $::DEBUG & DEBUG::try_processing;
push @gather, ((
sub {
my $C=shift;
if (my ($C) = ($C->before(sub {
my $C=shift;
if (my ($C) = ($C->before(sub {
my $C=shift;
$C->_EXACT("\>")
}))) { ($C) } else { () }
}))) {
scalar(do {
my $M = $C;
my $n = $M->{'longname'}->Str;
if ($n eq 'before' or $n eq 'after') {
$C->panic("$n requires an argument")};
}, $C)
} else { () }
},
sub {
my $C=shift;
if (($C) = ($C->_OPTr(sub {
my $C=shift;
if (my ($C) = ($C->normspace)) { ($C) } else { () }
}))
and ($C) = ($C->_SUBSUMEr(['nibbler'], sub {
my $C = shift;
$C->nibbler
}))
and ($C) = ($C->ws)) {
$C
} else { () }
},
sub {
my $C=shift;
if (my ($C) = ($C->_EXACT("\="))) {
$C->_SUBSUMEr(['assertion'], sub {
my $C = shift;
$C->assertion
})
} else { () }
},
sub {
my $C=shift;
if (($C) = ($C->_EXACT("\:"))
and ($C) = ($C->_BRACKETr(sub {
my $C=shift;
my $newlang = ($C->cursor_fresh($::LANG{'MAIN'})->unbalanced('>'));
$C = bless($C, (ref($newlang) || $newlang));
do {
if (my ($C) = ($C->ws)) {
$C->_SUBSUMEr(['arglist'], sub {
my $C = shift;
$C->arglist
})
} else { () }

}
}))) {
$C
} else { () }
},
sub {
my $C=shift;
if (($C) = ($C->_EXACT("\("))
and ($C) = (scalar(do {
}, $C))
and ($C) = ($C->_BRACKETr(sub {
my $C=shift;
my $newlang = ($::LANG{'MAIN'});
$C = bless($C, (ref($newlang) || $newlang));
$C->_SUBSUMEr(['arglist'], sub {
my $C = shift;
$C->arglist
})
}))
and ($C) = ($C->_BRACKETr(sub {
my $C=shift;
do {    my $C = $C->cursor_xact('ALT ||');
my $xact = $C->xact;
my @gather;
do {
push @gather, $C->_EXACT("\)")
}
or $xact->[-2] or
do {
push @gather, do {
if (my ($C) = ($C->panic("Assertion call missing right parenthesis"))) { ($C) } else { () }

}
};
@gather;
}
}))) {
$C
} else { () }
}
)[$try])->($C);
last if @gather;
last if $xact->[-2];  # committed?
}
@gather;
};
}))) { ($C) } else { () }
})
} else { () }

});
}
;
## token assertion:sym<[> { <?before '['> <cclass_elem>+ }
sub assertion__S_083Bra__PEEK { $_[0]->_AUTOLEXpeek('assertion__S_083Bra', $retree) }
sub assertion__S_083Bra {
no warnings 'recursion';
my $self = shift;


local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;

my $C = $self->cursor_xact("RULE assertion__S_083Bra");
my $xact = $C->xact;
my $S = $C->{'_pos'};
$C->{'cclass_elem'} = [];
$C->{sym} = "\[";
$self->_MATCHIFYr($S, "assertion__S_083Bra", do {
if (my ($C) = ($C->before(sub {
my $C=shift;
if (my ($C) = ($C->before(sub {
my $C=shift;
$C->_EXACT("\[")
}))) { ($C) } else { () }
}))) {
$C->_PLUSr(sub {
my $C=shift;
$C->_SUBSUMEr(['cclass_elem'], sub {
my $C = shift;
$C->cclass_elem
})
})
} else { () }

});
}
;
## token assertion:sym<+> { <?before '+'> <cclass_elem>+ }
sub assertion__S_084Plus__PEEK { $_[0]->_AUTOLEXpeek('assertion__S_084Plus', $retree) }
sub assertion__S_084Plus {
no warnings 'recursion';
my $self = shift;


local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;

my $C = $self->cursor_xact("RULE assertion__S_084Plus");
my $xact = $C->xact;
my $S = $C->{'_pos'};
$C->{'cclass_elem'} = [];
$C->{sym} = "\+";
$self->_MATCHIFYr($S, "assertion__S_084Plus", do {
if (my ($C) = ($C->before(sub {
my $C=shift;
if (my ($C) = ($C->before(sub {
my $C=shift;
$C->_EXACT("\+")
}))) { ($C) } else { () }
}))) {
$C->_PLUSr(sub {
my $C=shift;
$C->_SUBSUMEr(['cclass_elem'], sub {
my $C = shift;
$C->cclass_elem
})
})
} else { () }

});
}
;
## token assertion:sym<-> { <?before '-'> <cclass_elem>+ }
sub assertion__S_085Minus__PEEK { $_[0]->_AUTOLEXpeek('assertion__S_085Minus', $retree) }
sub assertion__S_085Minus {
no warnings 'recursion';
my $self = shift;


local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;

my $C = $self->cursor_xact("RULE assertion__S_085Minus");
my $xact = $C->xact;
my $S = $C->{'_pos'};
$C->{'cclass_elem'} = [];
$C->{sym} = "\-";
$self->_MATCHIFYr($S, "assertion__S_085Minus", do {
if (my ($C) = ($C->before(sub {
my $C=shift;
if (my ($C) = ($C->before(sub {
my $C=shift;
$C->_EXACT("\-")
}))) { ($C) } else { () }
}))) {
$C->_PLUSr(sub {
my $C=shift;
$C->_SUBSUMEr(['cclass_elem'], sub {
my $C = shift;
$C->cclass_elem
})
})
} else { () }

});
}
;
## token assertion:sym<.> { <sym> }
sub assertion__S_086Dot__PEEK { $_[0]->_AUTOLEXpeek('assertion__S_086Dot', $retree) }
sub assertion__S_086Dot {
no warnings 'recursion';
my $self = shift;


local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;

my $C = $self->cursor_xact("RULE assertion__S_086Dot");
my $xact = $C->xact;
my $S = $C->{'_pos'};
$C->{sym} = "\.";
$self->_MATCHIFYr($S, "assertion__S_086Dot", $C->_EXACT("\."));
}
;
## token assertion:sym<,> { <sym> }
sub assertion__S_087Comma__PEEK { $_[0]->_AUTOLEXpeek('assertion__S_087Comma', $retree) }
sub assertion__S_087Comma {
no warnings 'recursion';
my $self = shift;


local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;

my $C = $self->cursor_xact("RULE assertion__S_087Comma");
my $xact = $C->xact;
my $S = $C->{'_pos'};
$C->{sym} = "\,";
$self->_MATCHIFYr($S, "assertion__S_087Comma", $C->_EXACT("\,"));
}
;
## token assertion:sym<~~> { <sym> [ <?before '>'> | \d+ | <desigilname> ] }
sub assertion__S_088TildeTilde__PEEK { $_[0]->_AUTOLEXpeek('assertion__S_088TildeTilde', $retree) }
sub assertion__S_088TildeTilde {
no warnings 'recursion';
my $self = shift;


local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;

my $C = $self->cursor_xact("RULE assertion__S_088TildeTilde");
my $xact = $C->xact;
my $S = $C->{'_pos'};
$C->{sym} = "\~\~";
$self->_MATCHIFYr($S, "assertion__S_088TildeTilde", do {
my $C = $C;
if (($C) = ($C->_EXACT("\~\~"))
and ($C) = ($C->_BRACKETr(sub {
my $C=shift;
do {
my ($tag, $try);
my @try;
my $relex;

my $fate;
my $x;
if ($fate = $C->{'_fate'} and $fate->[1] eq 'assertion__S_088TildeTilde_0') {
$C->deb("Fate passed to assertion__S_088TildeTilde_0: ", ::fatestr($fate)) if $::DEBUG & DEBUG::fates;
($C->{'_fate'}, $tag, $try) = @$fate;
@try = ($try);
$x = 'ALT assertion__S_088TildeTilde_0';    # some outer ltm is controlling us
}
else {
$x = 'ALTLTM assertion__S_088TildeTilde_0'; # we are top level ltm
}
my $C = $C->cursor_xact($x);
my $xact = $C->{_xact};

my @gather = ();
for (;;) {
unless (@try) {
$relex //= $C->cursor_fate('STD::Regex', 'assertion__S_088TildeTilde_0', $retree);
@try = $relex->($C) or last;
}
$try = shift(@try) // next;

if (ref $try) {
($C->{'_fate'}, $tag, $try) = @$try;   # next candidate fate
}

$C->deb("assertion__S_088TildeTilde_0 trying $tag $try") if $::DEBUG & DEBUG::try_processing;
push @gather, ((
sub {
my $C=shift;
if (my ($C) = ($C->before(sub {
my $C=shift;
if (my ($C) = ($C->before(sub {
my $C=shift;
$C->_EXACT("\>")
}))) { ($C) } else { () }
}))) { ($C) } else { () }
},
sub {
my $C=shift;
$C->_PATTERN(qr/\G\d++/)
},
sub {
my $C=shift;
$C->_SUBSUMEr(['desigilname'], sub {
my $C = shift;
$C->desigilname
})
}
)[$try])->($C);
last if @gather;
last if $xact->[-2];  # committed?
}
@gather;
};
}))) {
$C
} else { () }

});
}
;
## token assertion:bogus { <.panic: "Unrecognized regex assertion"> }
sub assertion__S_089bogus__PEEK { $_[0]->_AUTOLEXpeek('assertion__S_089bogus', $retree) }
sub assertion__S_089bogus {
no warnings 'recursion';
my $self = shift;


local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;

my $C = $self->cursor_xact("RULE assertion__S_089bogus");
my $xact = $C->xact;
my $S = $C->{'_pos'};
$C->{sym} = "bogus";
$self->_MATCHIFYr($S, "assertion__S_089bogus", $C->panic("Unrecognized regex assertion"));
}
;
## token sign { '+' | '-' | <?> }
sub sign__PEEK { $_[0]->_AUTOLEXpeek('sign', $retree) }
sub sign {
no warnings 'recursion';
my $self = shift;


local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;

my $C = $self->cursor_xact("RULE sign");
my $xact = $C->xact;
my $S = $C->{'_pos'};
$self->_MATCHIFYr($S, "sign", do {
do {
my ($tag, $try);
my @try;
my $relex;

my $fate;
my $x;
if ($fate = $C->{'_fate'} and $fate->[1] eq 'sign_0') {
$C->deb("Fate passed to sign_0: ", ::fatestr($fate)) if $::DEBUG & DEBUG::fates;
($C->{'_fate'}, $tag, $try) = @$fate;
@try = ($try);
$x = 'ALT sign_0';    # some outer ltm is controlling us
}
else {
$x = 'ALTLTM sign_0'; # we are top level ltm
}
my $C = $C->cursor_xact($x);
my $xact = $C->{_xact};

my @gather = ();
for (;;) {
unless (@try) {
$relex //= $C->cursor_fate('STD::Regex', 'sign_0', $retree);
@try = $relex->($C) or last;
}
$try = shift(@try) // next;

if (ref $try) {
($C->{'_fate'}, $tag, $try) = @$try;   # next candidate fate
}

$C->deb("sign_0 trying $tag $try") if $::DEBUG & DEBUG::try_processing;
push @gather, ((
sub {
my $C=shift;
$C->_EXACT("\+")
},
sub {
my $C=shift;
$C->_EXACT("\-")
},
sub {
my $C=shift;
if (my ($C) = ($C->before(sub {
my $C=shift;
$C
}))) { ($C) } else { () }
}
)[$try])->($C);
last if @gather;
last if $xact->[-2];  # committed?
}
@gather;
};

});
}
;
## token cclass_elem {
sub cclass_elem__PEEK { $_[0]->_AUTOLEXpeek('cclass_elem', $retree) }
sub cclass_elem {
no warnings 'recursion';
my $self = shift;

local $::CCSTATE = '';
local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;

my $C = $self->cursor_xact("RULE cclass_elem");
my $xact = $C->xact;
my $S = $C->{'_pos'};
$self->_MATCHIFYr($S, "cclass_elem", do {
my $C = $C;
if (($C) = ($C->_SUBSUMEr(['sign'], sub {
my $C = shift;
$C->sign
}))
and ($C) = ($C->_OPTr(sub {
my $C=shift;
if (my ($C) = ($C->normspace)) { ($C) } else { () }
}))
and ($C) = ($C->_BRACKETr(sub {
my $C=shift;
do {
my ($tag, $try);
my @try;
my $relex;

my $fate;
my $x;
if ($fate = $C->{'_fate'} and $fate->[1] eq 'cclass_elem_0') {
$C->deb("Fate passed to cclass_elem_0: ", ::fatestr($fate)) if $::DEBUG & DEBUG::fates;
($C->{'_fate'}, $tag, $try) = @$fate;
@try = ($try);
$x = 'ALT cclass_elem_0';    # some outer ltm is controlling us
}
else {
$x = 'ALTLTM cclass_elem_0'; # we are top level ltm
}
my $C = $C->cursor_xact($x);
my $xact = $C->{_xact};

my @gather = ();
for (;;) {
unless (@try) {
$relex //= $C->cursor_fate('STD::Regex', 'cclass_elem_0', $retree);
@try = $relex->($C) or last;
}
$try = shift(@try) // next;

if (ref $try) {
($C->{'_fate'}, $tag, $try) = @$try;   # next candidate fate
}

$C->deb("cclass_elem_0 trying $tag $try") if $::DEBUG & DEBUG::try_processing;
push @gather, ((
sub {
my $C=shift;
$C->_SUBSUMEr(['name'], sub {
my $C = shift;
$C->name
})
},
sub {
my $C=shift;
if (my ($C) = ($C->_SUBSUMEr(['before'], sub {
my $C = shift;
$C->before(sub {
my $C=shift;
$C->_EXACT("\[")
})
}))) {
$C->_SUBSUMEr(['quibble'], sub {
my $C = shift;
$C->quibble($C->cursor_fresh( $::LANG{'Q'} )->tweak('cc' => 1))
})
} else { () }
}
)[$try])->($C);
last if @gather;
last if $xact->[-2];  # committed?
}
@gather;
};
}))) {
$C->_OPTr(sub {
my $C=shift;
if (my ($C) = ($C->normspace)) { ($C) } else { () }
})
} else { () }

});
}
;
## token mod_arg { :dba('modifier argument') '(' ~ ')' [:lang(%*LANG<MAIN>) <semilist> ] }
sub mod_arg__PEEK { $_[0]->_AUTOLEXpeek('mod_arg', $retree) }
sub mod_arg {
no warnings 'recursion';
my $self = shift;


local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;

my $C = $self->cursor_xact("RULE mod_arg");
my $xact = $C->xact;
my $S = $C->{'_pos'};
$self->_MATCHIFYr($S, "mod_arg", $C->_BRACKETr(sub {
my $C=shift;
local $::GOAL = "\)";
my $goalpos = $C;
if (($C) = ($C->_EXACT("\("))
and ($C) = (scalar(do {
}, $C))
and ($C) = ($C->_BRACKETr(sub {
my $C=shift;
my $newlang = ($::LANG{'MAIN'});
$C = bless($C, (ref($newlang) || $newlang));
$C->_SUBSUMEr(['semilist'], sub {
my $C = shift;
$C->semilist
})
}))
and ($C) = ($C->_BRACKETr(sub {
my $C=shift;
do {    my $C = $C->cursor_xact('ALT ||');
my $xact = $C->xact;
my @gather;
do {
push @gather, $C->_EXACT("\)")
}
or $xact->[-2] or
do {
push @gather, do {
if (my ($C) = ($C->FAILGOAL($::GOAL, 'modifier argument', $goalpos))) { ($C) } else { () }

}
};
@gather;
}
}))) {
$C
} else { () }
}));
}
;
## token mod_internal:sym<:my>    { ':' <?before ['my'|'state'|'our'|'anon'|'constant'|'temp'|'let'] \s
sub mod_internal__S_090Colonmy__PEEK { $_[0]->_AUTOLEXpeek('mod_internal__S_090Colonmy', $retree) }
sub mod_internal__S_090Colonmy {
no warnings 'recursion';
my $self = shift;


local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;

my $C = $self->cursor_xact("RULE mod_internal__S_090Colonmy");
my $xact = $C->xact;
my $S = $C->{'_pos'};
$C->{sym} = "\:my";
$self->_MATCHIFYr($S, "mod_internal__S_090Colonmy", do {
my $C = $C;
if (($C) = ($C->_EXACT("\:"))
and ($C) = ($C->before(sub {
my $C=shift;
if (my ($C) = ($C->before(sub {
my $C=shift;
if (my ($C) = ($C->_BRACKETr(sub {
my $C=shift;
do {
my ($tag, $try);
my @try;
my $relex;

my $fate;
my $x;
if ($fate = $C->{'_fate'} and $fate->[1] eq 'mod_internal__S_090Colonmy_0') {
$C->deb("Fate passed to mod_internal__S_090Colonmy_0: ", ::fatestr($fate)) if $::DEBUG & DEBUG::fates;
($C->{'_fate'}, $tag, $try) = @$fate;
@try = ($try);
$x = 'ALT mod_internal__S_090Colonmy_0';    # some outer ltm is controlling us
}
else {
$x = 'ALTLTM mod_internal__S_090Colonmy_0'; # we are top level ltm
}
my $C = $C->cursor_xact($x);
my $xact = $C->{_xact};

my @gather = ();
for (;;) {
unless (@try) {
$relex //= $C->cursor_fate('STD::Regex', 'mod_internal__S_090Colonmy_0', $retree);
@try = $relex->($C) or last;
}
$try = shift(@try) // next;

if (ref $try) {
($C->{'_fate'}, $tag, $try) = @$try;   # next candidate fate
}

$C->deb("mod_internal__S_090Colonmy_0 trying $tag $try") if $::DEBUG & DEBUG::try_processing;
push @gather, ((
sub {
my $C=shift;
$C->_EXACT("my")
},
sub {
my $C=shift;
$C->_EXACT("state")
},
sub {
my $C=shift;
$C->_EXACT("our")
},
sub {
my $C=shift;
$C->_EXACT("anon")
},
sub {
my $C=shift;
$C->_EXACT("constant")
},
sub {
my $C=shift;
$C->_EXACT("temp")
},
sub {
my $C=shift;
$C->_EXACT("let")
}
)[$try])->($C);
last if @gather;
last if $xact->[-2];  # committed?
}
@gather;
};
}))) {
$C->_PATTERN(qr/\G\s/)
} else { () }
}))) { ($C) } else { () }
}))
and ($C) = ($C->_BRACKETr(sub {
my $C=shift;
my $newlang = ($::LANG{'MAIN'});
$C = bless($C, (ref($newlang) || $newlang));
do {
if (my ($C) = ($C->_SUBSUMEr(['statement'], sub {
my $C = shift;
$C->statement
}))) {
$C->_SUBSUMEr(['eat_terminator'], sub {
my $C = shift;
$C->eat_terminator
})
} else { () }

}
}))) {
$C
} else { () }

});
}
;
## token mod_internal:sym<:i>    { $<sym>=[':i'|':ignorecase'] » { %*RX<i> = 1 } }
sub mod_internal__S_091Coloni__PEEK { $_[0]->_AUTOLEXpeek('mod_internal__S_091Coloni', $retree) }
sub mod_internal__S_091Coloni {
no warnings 'recursion';
my $self = shift;


local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;

my $C = $self->cursor_xact("RULE mod_internal__S_091Coloni");
my $xact = $C->xact;
my $S = $C->{'_pos'};
$C->{sym} = "\:i";
$self->_MATCHIFYr($S, "mod_internal__S_091Coloni", do {
my $C = $C;
if (($C) = ($C->_SUBSUMEr(['sym'], sub {
my $C = shift;
$C->_BRACKETr(sub {
my $C=shift;
do {
my ($tag, $try);
my @try;
my $relex;

my $fate;
my $x;
if ($fate = $C->{'_fate'} and $fate->[1] eq 'mod_internal__S_091Coloni_0') {
$C->deb("Fate passed to mod_internal__S_091Coloni_0: ", ::fatestr($fate)) if $::DEBUG & DEBUG::fates;
($C->{'_fate'}, $tag, $try) = @$fate;
@try = ($try);
$x = 'ALT mod_internal__S_091Coloni_0';    # some outer ltm is controlling us
}
else {
$x = 'ALTLTM mod_internal__S_091Coloni_0'; # we are top level ltm
}
my $C = $C->cursor_xact($x);
my $xact = $C->{_xact};

my @gather = ();
for (;;) {
unless (@try) {
$relex //= $C->cursor_fate('STD::Regex', 'mod_internal__S_091Coloni_0', $retree);
@try = $relex->($C) or last;
}
$try = shift(@try) // next;

if (ref $try) {
($C->{'_fate'}, $tag, $try) = @$try;   # next candidate fate
}

$C->deb("mod_internal__S_091Coloni_0 trying $tag $try") if $::DEBUG & DEBUG::try_processing;
push @gather, ((
sub {
my $C=shift;
$C->_EXACT("\:i")
},
sub {
my $C=shift;
$C->_EXACT("\:ignorecase")
}
)[$try])->($C);
last if @gather;
last if $xact->[-2];  # committed?
}
@gather;
};
})
}))
and ($C) = ($C->_PATTERN(qr/\G\b/))) {
scalar(do {
$::RX{'i'} = 1 }, $C)
} else { () }

});
}
;
## token mod_internal:sym<:!i>   { $<sym>=[':!i'|':!ignorecase'] » { %*RX<i> = 0 } }
sub mod_internal__S_092ColonBangi__PEEK { $_[0]->_AUTOLEXpeek('mod_internal__S_092ColonBangi', $retree) }
sub mod_internal__S_092ColonBangi {
no warnings 'recursion';
my $self = shift;


local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;

my $C = $self->cursor_xact("RULE mod_internal__S_092ColonBangi");
my $xact = $C->xact;
my $S = $C->{'_pos'};
$C->{sym} = "\:\!i";
$self->_MATCHIFYr($S, "mod_internal__S_092ColonBangi", do {
my $C = $C;
if (($C) = ($C->_SUBSUMEr(['sym'], sub {
my $C = shift;
$C->_BRACKETr(sub {
my $C=shift;
do {
my ($tag, $try);
my @try;
my $relex;

my $fate;
my $x;
if ($fate = $C->{'_fate'} and $fate->[1] eq 'mod_internal__S_092ColonBangi_0') {
$C->deb("Fate passed to mod_internal__S_092ColonBangi_0: ", ::fatestr($fate)) if $::DEBUG & DEBUG::fates;
($C->{'_fate'}, $tag, $try) = @$fate;
@try = ($try);
$x = 'ALT mod_internal__S_092ColonBangi_0';    # some outer ltm is controlling us
}
else {
$x = 'ALTLTM mod_internal__S_092ColonBangi_0'; # we are top level ltm
}
my $C = $C->cursor_xact($x);
my $xact = $C->{_xact};

my @gather = ();
for (;;) {
unless (@try) {
$relex //= $C->cursor_fate('STD::Regex', 'mod_internal__S_092ColonBangi_0', $retree);
@try = $relex->($C) or last;
}
$try = shift(@try) // next;

if (ref $try) {
($C->{'_fate'}, $tag, $try) = @$try;   # next candidate fate
}

$C->deb("mod_internal__S_092ColonBangi_0 trying $tag $try") if $::DEBUG & DEBUG::try_processing;
push @gather, ((
sub {
my $C=shift;
$C->_EXACT("\:\!i")
},
sub {
my $C=shift;
$C->_EXACT("\:\!ignorecase")
}
)[$try])->($C);
last if @gather;
last if $xact->[-2];  # committed?
}
@gather;
};
})
}))
and ($C) = ($C->_PATTERN(qr/\G\b/))) {
scalar(do {
$::RX{'i'} = 0 }, $C)
} else { () }

});
}
;
## token mod_internal:sym<:i( )> { $<sym>=[':i'|':ignorecase'] <mod_arg> { %*RX<i> = eval $<mod_arg>.St
sub mod_internal__S_093ColoniParen_Thesis__PEEK { $_[0]->_AUTOLEXpeek('mod_internal__S_093ColoniParen_Thesis', $retree) }
sub mod_internal__S_093ColoniParen_Thesis {
no warnings 'recursion';
my $self = shift;


local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;

my $C = $self->cursor_xact("RULE mod_internal__S_093ColoniParen_Thesis");
my $xact = $C->xact;
my $S = $C->{'_pos'};
$C->{sym} = "\:i\(\ \)";
$self->_MATCHIFYr($S, "mod_internal__S_093ColoniParen_Thesis", do {
my $C = $C;
if (($C) = ($C->_SUBSUMEr(['sym'], sub {
my $C = shift;
$C->_BRACKETr(sub {
my $C=shift;
do {
my ($tag, $try);
my @try;
my $relex;

my $fate;
my $x;
if ($fate = $C->{'_fate'} and $fate->[1] eq 'mod_internal__S_093ColoniParen_Thesis_0') {
$C->deb("Fate passed to mod_internal__S_093ColoniParen_Thesis_0: ", ::fatestr($fate)) if $::DEBUG & DEBUG::fates;
($C->{'_fate'}, $tag, $try) = @$fate;
@try = ($try);
$x = 'ALT mod_internal__S_093ColoniParen_Thesis_0';    # some outer ltm is controlling us
}
else {
$x = 'ALTLTM mod_internal__S_093ColoniParen_Thesis_0'; # we are top level ltm
}
my $C = $C->cursor_xact($x);
my $xact = $C->{_xact};

my @gather = ();
for (;;) {
unless (@try) {
$relex //= $C->cursor_fate('STD::Regex', 'mod_internal__S_093ColoniParen_Thesis_0', $retree);
@try = $relex->($C) or last;
}
$try = shift(@try) // next;

if (ref $try) {
($C->{'_fate'}, $tag, $try) = @$try;   # next candidate fate
}

$C->deb("mod_internal__S_093ColoniParen_Thesis_0 trying $tag $try") if $::DEBUG & DEBUG::try_processing;
push @gather, ((
sub {
my $C=shift;
$C->_EXACT("\:i")
},
sub {
my $C=shift;
$C->_EXACT("\:ignorecase")
}
)[$try])->($C);
last if @gather;
last if $xact->[-2];  # committed?
}
@gather;
};
})
}))
and ($C) = ($C->_SUBSUMEr(['mod_arg'], sub {
my $C = shift;
$C->mod_arg
}))) {
scalar(do {
my $M = $C;
$::RX{'i'} = eval $M->{'mod_arg'}->Str }, $C)
} else { () }

});
}
;
## token mod_internal:sym<:0i>   { ':' (\d+) ['i'|'ignorecase'] { %*RX<i> = $0 } }
sub mod_internal__S_094Colon0i__PEEK { $_[0]->_AUTOLEXpeek('mod_internal__S_094Colon0i', $retree) }
sub mod_internal__S_094Colon0i {
no warnings 'recursion';
my $self = shift;


local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;

my $C = $self->cursor_xact("RULE mod_internal__S_094Colon0i");
my $xact = $C->xact;
my $S = $C->{'_pos'};
$C->{sym} = "\:0i";
$self->_MATCHIFYr($S, "mod_internal__S_094Colon0i", do {
my $C = $C;
if (($C) = ($C->_EXACT("\:"))
and ($C) = ($C->_SUBSUMEr(['0'], sub {
my $C = shift;
$C->_PAREN( sub {
my $C=shift;
$C->_PATTERN(qr/\G\d++/)

})
}))
and ($C) = ($C->_BRACKETr(sub {
my $C=shift;
do {
my ($tag, $try);
my @try;
my $relex;

my $fate;
my $x;
if ($fate = $C->{'_fate'} and $fate->[1] eq 'mod_internal__S_094Colon0i_0') {
$C->deb("Fate passed to mod_internal__S_094Colon0i_0: ", ::fatestr($fate)) if $::DEBUG & DEBUG::fates;
($C->{'_fate'}, $tag, $try) = @$fate;
@try = ($try);
$x = 'ALT mod_internal__S_094Colon0i_0';    # some outer ltm is controlling us
}
else {
$x = 'ALTLTM mod_internal__S_094Colon0i_0'; # we are top level ltm
}
my $C = $C->cursor_xact($x);
my $xact = $C->{_xact};

my @gather = ();
for (;;) {
unless (@try) {
$relex //= $C->cursor_fate('STD::Regex', 'mod_internal__S_094Colon0i_0', $retree);
@try = $relex->($C) or last;
}
$try = shift(@try) // next;

if (ref $try) {
($C->{'_fate'}, $tag, $try) = @$try;   # next candidate fate
}

$C->deb("mod_internal__S_094Colon0i_0 trying $tag $try") if $::DEBUG & DEBUG::try_processing;
push @gather, ((
sub {
my $C=shift;
$C->_EXACT("i")
},
sub {
my $C=shift;
$C->_EXACT("ignorecase")
}
)[$try])->($C);
last if @gather;
last if $xact->[-2];  # committed?
}
@gather;
};
}))) {
scalar(do {
my $M = $C;
$::RX{'i'} = $M->{0} }, $C)
} else { () }

});
}
;
## token mod_internal:sym<:a>    { $<sym>=[':a'|':ignoreaccent'] » { %*RX<a> = 1 } }
sub mod_internal__S_095Colona__PEEK { $_[0]->_AUTOLEXpeek('mod_internal__S_095Colona', $retree) }
sub mod_internal__S_095Colona {
no warnings 'recursion';
my $self = shift;


local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;

my $C = $self->cursor_xact("RULE mod_internal__S_095Colona");
my $xact = $C->xact;
my $S = $C->{'_pos'};
$C->{sym} = "\:a";
$self->_MATCHIFYr($S, "mod_internal__S_095Colona", do {
my $C = $C;
if (($C) = ($C->_SUBSUMEr(['sym'], sub {
my $C = shift;
$C->_BRACKETr(sub {
my $C=shift;
do {
my ($tag, $try);
my @try;
my $relex;

my $fate;
my $x;
if ($fate = $C->{'_fate'} and $fate->[1] eq 'mod_internal__S_095Colona_0') {
$C->deb("Fate passed to mod_internal__S_095Colona_0: ", ::fatestr($fate)) if $::DEBUG & DEBUG::fates;
($C->{'_fate'}, $tag, $try) = @$fate;
@try = ($try);
$x = 'ALT mod_internal__S_095Colona_0';    # some outer ltm is controlling us
}
else {
$x = 'ALTLTM mod_internal__S_095Colona_0'; # we are top level ltm
}
my $C = $C->cursor_xact($x);
my $xact = $C->{_xact};

my @gather = ();
for (;;) {
unless (@try) {
$relex //= $C->cursor_fate('STD::Regex', 'mod_internal__S_095Colona_0', $retree);
@try = $relex->($C) or last;
}
$try = shift(@try) // next;

if (ref $try) {
($C->{'_fate'}, $tag, $try) = @$try;   # next candidate fate
}

$C->deb("mod_internal__S_095Colona_0 trying $tag $try") if $::DEBUG & DEBUG::try_processing;
push @gather, ((
sub {
my $C=shift;
$C->_EXACT("\:a")
},
sub {
my $C=shift;
$C->_EXACT("\:ignoreaccent")
}
)[$try])->($C);
last if @gather;
last if $xact->[-2];  # committed?
}
@gather;
};
})
}))
and ($C) = ($C->_PATTERN(qr/\G\b/))) {
scalar(do {
$::RX{'a'} = 1 }, $C)
} else { () }

});
}
;
## token mod_internal:sym<:!a>   { $<sym>=[':!a'|':!ignoreaccent'] » { %*RX<a> = 0 } }
sub mod_internal__S_096ColonBanga__PEEK { $_[0]->_AUTOLEXpeek('mod_internal__S_096ColonBanga', $retree) }
sub mod_internal__S_096ColonBanga {
no warnings 'recursion';
my $self = shift;


local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;

my $C = $self->cursor_xact("RULE mod_internal__S_096ColonBanga");
my $xact = $C->xact;
my $S = $C->{'_pos'};
$C->{sym} = "\:\!a";
$self->_MATCHIFYr($S, "mod_internal__S_096ColonBanga", do {
my $C = $C;
if (($C) = ($C->_SUBSUMEr(['sym'], sub {
my $C = shift;
$C->_BRACKETr(sub {
my $C=shift;
do {
my ($tag, $try);
my @try;
my $relex;

my $fate;
my $x;
if ($fate = $C->{'_fate'} and $fate->[1] eq 'mod_internal__S_096ColonBanga_0') {
$C->deb("Fate passed to mod_internal__S_096ColonBanga_0: ", ::fatestr($fate)) if $::DEBUG & DEBUG::fates;
($C->{'_fate'}, $tag, $try) = @$fate;
@try = ($try);
$x = 'ALT mod_internal__S_096ColonBanga_0';    # some outer ltm is controlling us
}
else {
$x = 'ALTLTM mod_internal__S_096ColonBanga_0'; # we are top level ltm
}
my $C = $C->cursor_xact($x);
my $xact = $C->{_xact};

my @gather = ();
for (;;) {
unless (@try) {
$relex //= $C->cursor_fate('STD::Regex', 'mod_internal__S_096ColonBanga_0', $retree);
@try = $relex->($C) or last;
}
$try = shift(@try) // next;

if (ref $try) {
($C->{'_fate'}, $tag, $try) = @$try;   # next candidate fate
}

$C->deb("mod_internal__S_096ColonBanga_0 trying $tag $try") if $::DEBUG & DEBUG::try_processing;
push @gather, ((
sub {
my $C=shift;
$C->_EXACT("\:\!a")
},
sub {
my $C=shift;
$C->_EXACT("\:\!ignoreaccent")
}
)[$try])->($C);
last if @gather;
last if $xact->[-2];  # committed?
}
@gather;
};
})
}))
and ($C) = ($C->_PATTERN(qr/\G\b/))) {
scalar(do {
$::RX{'a'} = 0 }, $C)
} else { () }

});
}
;
## token mod_internal:sym<:a( )> { $<sym>=[':a'|':ignoreaccent'] <mod_arg> { %*RX<a> = eval $<mod_arg>.
sub mod_internal__S_097ColonaParen_Thesis__PEEK { $_[0]->_AUTOLEXpeek('mod_internal__S_097ColonaParen_Thesis', $retree) }
sub mod_internal__S_097ColonaParen_Thesis {
no warnings 'recursion';
my $self = shift;


local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;

my $C = $self->cursor_xact("RULE mod_internal__S_097ColonaParen_Thesis");
my $xact = $C->xact;
my $S = $C->{'_pos'};
$C->{sym} = "\:a\(\ \)";
$self->_MATCHIFYr($S, "mod_internal__S_097ColonaParen_Thesis", do {
my $C = $C;
if (($C) = ($C->_SUBSUMEr(['sym'], sub {
my $C = shift;
$C->_BRACKETr(sub {
my $C=shift;
do {
my ($tag, $try);
my @try;
my $relex;

my $fate;
my $x;
if ($fate = $C->{'_fate'} and $fate->[1] eq 'mod_internal__S_097ColonaParen_Thesis_0') {
$C->deb("Fate passed to mod_internal__S_097ColonaParen_Thesis_0: ", ::fatestr($fate)) if $::DEBUG & DEBUG::fates;
($C->{'_fate'}, $tag, $try) = @$fate;
@try = ($try);
$x = 'ALT mod_internal__S_097ColonaParen_Thesis_0';    # some outer ltm is controlling us
}
else {
$x = 'ALTLTM mod_internal__S_097ColonaParen_Thesis_0'; # we are top level ltm
}
my $C = $C->cursor_xact($x);
my $xact = $C->{_xact};

my @gather = ();
for (;;) {
unless (@try) {
$relex //= $C->cursor_fate('STD::Regex', 'mod_internal__S_097ColonaParen_Thesis_0', $retree);
@try = $relex->($C) or last;
}
$try = shift(@try) // next;

if (ref $try) {
($C->{'_fate'}, $tag, $try) = @$try;   # next candidate fate
}

$C->deb("mod_internal__S_097ColonaParen_Thesis_0 trying $tag $try") if $::DEBUG & DEBUG::try_processing;
push @gather, ((
sub {
my $C=shift;
$C->_EXACT("\:a")
},
sub {
my $C=shift;
$C->_EXACT("\:ignoreaccent")
}
)[$try])->($C);
last if @gather;
last if $xact->[-2];  # committed?
}
@gather;
};
})
}))
and ($C) = ($C->_SUBSUMEr(['mod_arg'], sub {
my $C = shift;
$C->mod_arg
}))) {
scalar(do {
my $M = $C;
$::RX{'a'} = eval $M->{'mod_arg'}->Str }, $C)
} else { () }

});
}
;
## token mod_internal:sym<:0a>   { ':' (\d+) ['a'|'ignoreaccent'] { %*RX<a> = $0 } }
sub mod_internal__S_098Colon0a__PEEK { $_[0]->_AUTOLEXpeek('mod_internal__S_098Colon0a', $retree) }
sub mod_internal__S_098Colon0a {
no warnings 'recursion';
my $self = shift;


local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;

my $C = $self->cursor_xact("RULE mod_internal__S_098Colon0a");
my $xact = $C->xact;
my $S = $C->{'_pos'};
$C->{sym} = "\:0a";
$self->_MATCHIFYr($S, "mod_internal__S_098Colon0a", do {
my $C = $C;
if (($C) = ($C->_EXACT("\:"))
and ($C) = ($C->_SUBSUMEr(['0'], sub {
my $C = shift;
$C->_PAREN( sub {
my $C=shift;
$C->_PATTERN(qr/\G\d++/)

})
}))
and ($C) = ($C->_BRACKETr(sub {
my $C=shift;
do {
my ($tag, $try);
my @try;
my $relex;

my $fate;
my $x;
if ($fate = $C->{'_fate'} and $fate->[1] eq 'mod_internal__S_098Colon0a_0') {
$C->deb("Fate passed to mod_internal__S_098Colon0a_0: ", ::fatestr($fate)) if $::DEBUG & DEBUG::fates;
($C->{'_fate'}, $tag, $try) = @$fate;
@try = ($try);
$x = 'ALT mod_internal__S_098Colon0a_0';    # some outer ltm is controlling us
}
else {
$x = 'ALTLTM mod_internal__S_098Colon0a_0'; # we are top level ltm
}
my $C = $C->cursor_xact($x);
my $xact = $C->{_xact};

my @gather = ();
for (;;) {
unless (@try) {
$relex //= $C->cursor_fate('STD::Regex', 'mod_internal__S_098Colon0a_0', $retree);
@try = $relex->($C) or last;
}
$try = shift(@try) // next;

if (ref $try) {
($C->{'_fate'}, $tag, $try) = @$try;   # next candidate fate
}

$C->deb("mod_internal__S_098Colon0a_0 trying $tag $try") if $::DEBUG & DEBUG::try_processing;
push @gather, ((
sub {
my $C=shift;
$C->_EXACT("a")
},
sub {
my $C=shift;
$C->_EXACT("ignoreaccent")
}
)[$try])->($C);
last if @gather;
last if $xact->[-2];  # committed?
}
@gather;
};
}))) {
scalar(do {
my $M = $C;
$::RX{'a'} = $M->{0} }, $C)
} else { () }

});
}
;
## token mod_internal:sym<:s>    { ':s' 'igspace'? » { %*RX<s> = 1 } }
sub mod_internal__S_099Colons__PEEK { $_[0]->_AUTOLEXpeek('mod_internal__S_099Colons', $retree) }
sub mod_internal__S_099Colons {
no warnings 'recursion';
my $self = shift;


local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;

my $C = $self->cursor_xact("RULE mod_internal__S_099Colons");
my $xact = $C->xact;
my $S = $C->{'_pos'};
$C->{sym} = "\:s";
$self->_MATCHIFYr($S, "mod_internal__S_099Colons", do {
if (my ($C) = ($C->_PATTERN(qr/\G\:s(?:igspace)?+\b/))) {
scalar(do {
$::RX{'s'} = 1 }, $C)
} else { () }

});
}
;
## token mod_internal:sym<:!s>   { ':!s' 'igspace'? » { %*RX<s> = 0 } }
sub mod_internal__S_100ColonBangs__PEEK { $_[0]->_AUTOLEXpeek('mod_internal__S_100ColonBangs', $retree) }
sub mod_internal__S_100ColonBangs {
no warnings 'recursion';
my $self = shift;


local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;

my $C = $self->cursor_xact("RULE mod_internal__S_100ColonBangs");
my $xact = $C->xact;
my $S = $C->{'_pos'};
$C->{sym} = "\:\!s";
$self->_MATCHIFYr($S, "mod_internal__S_100ColonBangs", do {
if (my ($C) = ($C->_PATTERN(qr/\G\:\!s(?:igspace)?+\b/))) {
scalar(do {
$::RX{'s'} = 0 }, $C)
} else { () }

});
}
;
## token mod_internal:sym<:s( )> { ':s' 'igspace'? <mod_arg> { %*RX<s> = eval $<mod_arg>.Str } }
sub mod_internal__S_101ColonsParen_Thesis__PEEK { $_[0]->_AUTOLEXpeek('mod_internal__S_101ColonsParen_Thesis', $retree) }
sub mod_internal__S_101ColonsParen_Thesis {
no warnings 'recursion';
my $self = shift;


local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;

my $C = $self->cursor_xact("RULE mod_internal__S_101ColonsParen_Thesis");
my $xact = $C->xact;
my $S = $C->{'_pos'};
$C->{sym} = "\:s\(\ \)";
$self->_MATCHIFYr($S, "mod_internal__S_101ColonsParen_Thesis", do {
my $C = $C;
if (($C) = ($C->_PATTERN(qr/\G\:s(?:igspace)?+/))
and ($C) = ($C->_SUBSUMEr(['mod_arg'], sub {
my $C = shift;
$C->mod_arg
}))) {
scalar(do {
my $M = $C;
$::RX{'s'} = eval $M->{'mod_arg'}->Str }, $C)
} else { () }

});
}
;
## token mod_internal:sym<:0s>   { ':' (\d+) 's' 'igspace'? » { %*RX<s> = $0 } }
sub mod_internal__S_102Colon0s__PEEK { $_[0]->_AUTOLEXpeek('mod_internal__S_102Colon0s', $retree) }
sub mod_internal__S_102Colon0s {
no warnings 'recursion';
my $self = shift;


local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;

my $C = $self->cursor_xact("RULE mod_internal__S_102Colon0s");
my $xact = $C->xact;
my $S = $C->{'_pos'};
$C->{sym} = "\:0s";
$self->_MATCHIFYr($S, "mod_internal__S_102Colon0s", do {
my $C = $C;
if (($C) = ($C->_EXACT("\:"))
and ($C) = ($C->_SUBSUMEr(['0'], sub {
my $C = shift;
$C->_PAREN( sub {
my $C=shift;
$C->_PATTERN(qr/\G\d++/)

})
}))
and ($C) = ($C->_PATTERN(qr/\Gs(?:igspace)?+\b/))) {
scalar(do {
my $M = $C;
$::RX{'s'} = $M->{0} }, $C)
} else { () }

});
}
;
## token mod_internal:sym<:r>    { ':r' 'atchet'? » { %*RX<r> = 1 } }
sub mod_internal__S_103Colonr__PEEK { $_[0]->_AUTOLEXpeek('mod_internal__S_103Colonr', $retree) }
sub mod_internal__S_103Colonr {
no warnings 'recursion';
my $self = shift;


local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;

my $C = $self->cursor_xact("RULE mod_internal__S_103Colonr");
my $xact = $C->xact;
my $S = $C->{'_pos'};
$C->{sym} = "\:r";
$self->_MATCHIFYr($S, "mod_internal__S_103Colonr", do {
if (my ($C) = ($C->_PATTERN(qr/\G\:r(?:atchet)?+\b/))) {
scalar(do {
$::RX{'r'} = 1 }, $C)
} else { () }

});
}
;
## token mod_internal:sym<:!r>   { ':!r' 'atchet'? » { %*RX<r> = 0 } }
sub mod_internal__S_104ColonBangr__PEEK { $_[0]->_AUTOLEXpeek('mod_internal__S_104ColonBangr', $retree) }
sub mod_internal__S_104ColonBangr {
no warnings 'recursion';
my $self = shift;


local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;

my $C = $self->cursor_xact("RULE mod_internal__S_104ColonBangr");
my $xact = $C->xact;
my $S = $C->{'_pos'};
$C->{sym} = "\:\!r";
$self->_MATCHIFYr($S, "mod_internal__S_104ColonBangr", do {
if (my ($C) = ($C->_PATTERN(qr/\G\:\!r(?:atchet)?+\b/))) {
scalar(do {
$::RX{'r'} = 0 }, $C)
} else { () }

});
}
;
## token mod_internal:sym<:r( )> { ':r' 'atchet'? » <mod_arg> { %*RX<r> = eval $<mod_arg>.Str } }
sub mod_internal__S_105ColonrParen_Thesis__PEEK { $_[0]->_AUTOLEXpeek('mod_internal__S_105ColonrParen_Thesis', $retree) }
sub mod_internal__S_105ColonrParen_Thesis {
no warnings 'recursion';
my $self = shift;


local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;

my $C = $self->cursor_xact("RULE mod_internal__S_105ColonrParen_Thesis");
my $xact = $C->xact;
my $S = $C->{'_pos'};
$C->{sym} = "\:r\(\ \)";
$self->_MATCHIFYr($S, "mod_internal__S_105ColonrParen_Thesis", do {
my $C = $C;
if (($C) = ($C->_PATTERN(qr/\G\:r(?:atchet)?+\b/))
and ($C) = ($C->_SUBSUMEr(['mod_arg'], sub {
my $C = shift;
$C->mod_arg
}))) {
scalar(do {
my $M = $C;
$::RX{'r'} = eval $M->{'mod_arg'}->Str }, $C)
} else { () }

});
}
;
## token mod_internal:sym<:0r>   { ':' (\d+) 'r' 'atchet'? » { %*RX<r> = $0 } }
sub mod_internal__S_106Colon0r__PEEK { $_[0]->_AUTOLEXpeek('mod_internal__S_106Colon0r', $retree) }
sub mod_internal__S_106Colon0r {
no warnings 'recursion';
my $self = shift;


local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;

my $C = $self->cursor_xact("RULE mod_internal__S_106Colon0r");
my $xact = $C->xact;
my $S = $C->{'_pos'};
$C->{sym} = "\:0r";
$self->_MATCHIFYr($S, "mod_internal__S_106Colon0r", do {
my $C = $C;
if (($C) = ($C->_EXACT("\:"))
and ($C) = ($C->_SUBSUMEr(['0'], sub {
my $C = shift;
$C->_PAREN( sub {
my $C=shift;
$C->_PATTERN(qr/\G\d++/)

})
}))
and ($C) = ($C->_PATTERN(qr/\Gr(?:atchet)?+\b/))) {
scalar(do {
my $M = $C;
$::RX{'r'} = $M->{0} }, $C)
} else { () }

});
}
;
## token mod_internal:sym<:Perl5>    { [':Perl5' | ':P5'] <.require_P5> [ :lang( $¢.cursor_fresh( %*LAN
sub mod_internal__S_107ColonPerl5__PEEK { $_[0]->_AUTOLEXpeek('mod_internal__S_107ColonPerl5', $retree) }
sub mod_internal__S_107ColonPerl5 {
no warnings 'recursion';
my $self = shift;


local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;

my $C = $self->cursor_xact("RULE mod_internal__S_107ColonPerl5");
my $xact = $C->xact;
my $S = $C->{'_pos'};
$C->{sym} = "\:Perl5";
$self->_MATCHIFYr($S, "mod_internal__S_107ColonPerl5", do {
my $C = $C;
if (($C) = ($C->_BRACKETr(sub {
my $C=shift;
do {
my ($tag, $try);
my @try;
my $relex;

my $fate;
my $x;
if ($fate = $C->{'_fate'} and $fate->[1] eq 'mod_internal__S_107ColonPerl5_0') {
$C->deb("Fate passed to mod_internal__S_107ColonPerl5_0: ", ::fatestr($fate)) if $::DEBUG & DEBUG::fates;
($C->{'_fate'}, $tag, $try) = @$fate;
@try = ($try);
$x = 'ALT mod_internal__S_107ColonPerl5_0';    # some outer ltm is controlling us
}
else {
$x = 'ALTLTM mod_internal__S_107ColonPerl5_0'; # we are top level ltm
}
my $C = $C->cursor_xact($x);
my $xact = $C->{_xact};

my @gather = ();
for (;;) {
unless (@try) {
$relex //= $C->cursor_fate('STD::Regex', 'mod_internal__S_107ColonPerl5_0', $retree);
@try = $relex->($C) or last;
}
$try = shift(@try) // next;

if (ref $try) {
($C->{'_fate'}, $tag, $try) = @$try;   # next candidate fate
}

$C->deb("mod_internal__S_107ColonPerl5_0 trying $tag $try") if $::DEBUG & DEBUG::try_processing;
push @gather, ((
sub {
my $C=shift;
$C->_EXACT("\:Perl5")
},
sub {
my $C=shift;
$C->_EXACT("\:P5")
}
)[$try])->($C);
last if @gather;
last if $xact->[-2];  # committed?
}
@gather;
};
}))
and ($C) = ($C->require_P5)
and ($C) = ($C->_BRACKETr(sub {
my $C=shift;
my $newlang = ( $C->cursor_fresh( $::LANG{'P5Regex'} )->unbalanced($::GOAL) );
$C = bless($C, (ref($newlang) || $newlang));
$C->_SUBSUMEr(['nibbler'], sub {
my $C = shift;
$C->nibbler
})
}))) {
$C
} else { () }

});
}
;
## token mod_internal:p6adv {
sub mod_internal__S_108p6adv__PEEK { $_[0]->_AUTOLEXpeek('mod_internal__S_108p6adv', $retree) }
sub mod_internal__S_108p6adv {
no warnings 'recursion';
my $self = shift;


local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;

my $C = $self->cursor_xact("RULE mod_internal__S_108p6adv");
my $xact = $C->xact;
my $S = $C->{'_pos'};
$C->{sym} = "p6adv";
$self->_MATCHIFYr($S, "mod_internal__S_108p6adv", do {
my $C = $C;
if (($C) = ($C->before(sub {
my $C=shift;
if (my ($C) = ($C->before(sub {
my $C=shift;
do {
my $C = $C;
if (($C) = ($C->_EXACT("\:"))
and ($C) = ($C->_BRACKETr(sub {
my $C=shift;
do {
my ($tag, $try);
my @try;
my $relex;

my $fate;
my $x;
if ($fate = $C->{'_fate'} and $fate->[1] eq 'mod_internal__S_108p6adv_0') {
$C->deb("Fate passed to mod_internal__S_108p6adv_0: ", ::fatestr($fate)) if $::DEBUG & DEBUG::fates;
($C->{'_fate'}, $tag, $try) = @$fate;
@try = ($try);
$x = 'ALT mod_internal__S_108p6adv_0';    # some outer ltm is controlling us
}
else {
$x = 'ALTLTM mod_internal__S_108p6adv_0'; # we are top level ltm
}
my $C = $C->cursor_xact($x);
my $xact = $C->{_xact};

my @gather = ();
for (;;) {
unless (@try) {
$relex //= $C->cursor_fate('STD::Regex', 'mod_internal__S_108p6adv_0', $retree);
@try = $relex->($C) or last;
}
$try = shift(@try) // next;

if (ref $try) {
($C->{'_fate'}, $tag, $try) = @$try;   # next candidate fate
}

$C->deb("mod_internal__S_108p6adv_0 trying $tag $try") if $::DEBUG & DEBUG::try_processing;
push @gather, ((
sub {
my $C=shift;
$C->_EXACT("dba")
},
sub {
my $C=shift;
$C->_EXACT("lang")
}
)[$try])->($C);
last if @gather;
last if $xact->[-2];  # committed?
}
@gather;
};
}))) {
$C->_PATTERN(qr/\G\b/)
} else { () }
};
}))) { ($C) } else { () }
}))
and ($C) = ($C->_BRACKETr(sub {
my $C=shift;
my $newlang = ($::LANG{'MAIN'});
$C = bless($C, (ref($newlang) || $newlang));
$C->_SUBSUMEr(['quotepair'], sub {
my $C = shift;
$C->quotepair
})
}))) {
scalar(do {
my $M = $C;
$M->{'sym'} = ':' . $M->{'quotepair'}->{'k'} }, $C)
} else { () }

});
}
;
## token mod_internal:oops { {} (':'\w+) <.sorry: "Unrecognized regex modifier " ~ $0.Str > }
sub mod_internal__S_109oops__PEEK { $_[0]->_AUTOLEXpeek('mod_internal__S_109oops', $retree) }
sub mod_internal__S_109oops {
no warnings 'recursion';
my $self = shift;


local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;

my $C = $self->cursor_xact("RULE mod_internal__S_109oops");
my $xact = $C->xact;
my $S = $C->{'_pos'};
$C->{sym} = "oops";
$self->_MATCHIFYr($S, "mod_internal__S_109oops", do {
my $C = $C;
if (($C) = (scalar(do {
}, $C))
and ($C) = ($C->_SUBSUMEr(['0'], sub {
my $C = shift;
$C->_PAREN( sub {
my $C=shift;
$C->_PATTERN(qr/\G\:\w++/)

})
}))
and ($C) = (do {
my $M = $C;
$C->sorry("Unrecognized regex modifier " . $M->{0}->Str )
})) {
$C
} else { () }

});
}
;
## token quantifier:sym<*>  { <sym> <quantmod> }
sub quantifier__S_110Star__PEEK { $_[0]->_AUTOLEXpeek('quantifier__S_110Star', $retree) }
sub quantifier__S_110Star {
no warnings 'recursion';
my $self = shift;


local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;

my $C = $self->cursor_xact("RULE quantifier__S_110Star");
my $xact = $C->xact;
my $S = $C->{'_pos'};
$C->{sym} = "\*";
$self->_MATCHIFYr($S, "quantifier__S_110Star", do {
if (my ($C) = ($C->_EXACT("\*"))) {
$C->_SUBSUMEr(['quantmod'], sub {
my $C = shift;
$C->quantmod
})
} else { () }

});
}
;
## token quantifier:sym<+>  { <sym> <quantmod> }
sub quantifier__S_111Plus__PEEK { $_[0]->_AUTOLEXpeek('quantifier__S_111Plus', $retree) }
sub quantifier__S_111Plus {
no warnings 'recursion';
my $self = shift;


local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;

my $C = $self->cursor_xact("RULE quantifier__S_111Plus");
my $xact = $C->xact;
my $S = $C->{'_pos'};
$C->{sym} = "\+";
$self->_MATCHIFYr($S, "quantifier__S_111Plus", do {
if (my ($C) = ($C->_EXACT("\+"))) {
$C->_SUBSUMEr(['quantmod'], sub {
my $C = shift;
$C->quantmod
})
} else { () }

});
}
;
## token quantifier:sym<?>  { <sym> <quantmod> }
sub quantifier__S_112Question__PEEK { $_[0]->_AUTOLEXpeek('quantifier__S_112Question', $retree) }
sub quantifier__S_112Question {
no warnings 'recursion';
my $self = shift;


local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;

my $C = $self->cursor_xact("RULE quantifier__S_112Question");
my $xact = $C->xact;
my $S = $C->{'_pos'};
$C->{sym} = "\?";
$self->_MATCHIFYr($S, "quantifier__S_112Question", do {
if (my ($C) = ($C->_EXACT("\?"))) {
$C->_SUBSUMEr(['quantmod'], sub {
my $C = shift;
$C->quantmod
})
} else { () }

});
}
;
## token quantifier:sym<:>  { <sym> {} <?before \s> }
sub quantifier__S_113Colon__PEEK { $_[0]->_AUTOLEXpeek('quantifier__S_113Colon', $retree) }
sub quantifier__S_113Colon {
no warnings 'recursion';
my $self = shift;


local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;

my $C = $self->cursor_xact("RULE quantifier__S_113Colon");
my $xact = $C->xact;
my $S = $C->{'_pos'};
$C->{sym} = "\:";
$self->_MATCHIFYr($S, "quantifier__S_113Colon", do {
my $C = $C;
if (($C) = ($C->_EXACT("\:"))
and ($C) = (scalar(do {
}, $C))
and ($C) = ($C->before(sub {
my $C=shift;
if (my ($C) = ($C->before(sub {
my $C=shift;
$C->_PATTERN(qr/\G\s/)
}))) { ($C) } else { () }
}))) {
$C
} else { () }

});
}
;
## token quantifier:sym<**> { <sym> :: <normspace>? <quantmod> <normspace>?
sub quantifier__S_114StarStar__PEEK { $_[0]->_AUTOLEXpeek('quantifier__S_114StarStar', $retree) }
sub quantifier__S_114StarStar {
no warnings 'recursion';
my $self = shift;


local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;

my $C = $self->cursor_xact("RULE quantifier__S_114StarStar");
my $xact = $C->xact;
my $S = $C->{'_pos'};
$C->{'1'} = [];
$C->{'normspace'} = [];
$C->{sym} = "\*\*";
$self->_MATCHIFYr($S, "quantifier__S_114StarStar", do {
my $C = $C;
if (($C) = ($C->_EXACT("\*\*"))
and ($C) = ($C->_COMMITLTM())
and ($C) = ($C->_OPTr(sub {
my $C=shift;
$C->_SUBSUMEr(['normspace'], sub {
my $C = shift;
$C->normspace
})
}))
and ($C) = ($C->_SUBSUMEr(['quantmod'], sub {
my $C = shift;
$C->quantmod
}))
and ($C) = ($C->_OPTr(sub {
my $C=shift;
$C->_SUBSUMEr(['normspace'], sub {
my $C = shift;
$C->normspace
})
}))
and ($C) = ($C->_BRACKETr(sub {
my $C=shift;
do {
my ($tag, $try);
my @try;
my $relex;

my $fate;
my $x;
if ($fate = $C->{'_fate'} and $fate->[1] eq 'quantifier__S_114StarStar_0') {
$C->deb("Fate passed to quantifier__S_114StarStar_0: ", ::fatestr($fate)) if $::DEBUG & DEBUG::fates;
($C->{'_fate'}, $tag, $try) = @$fate;
@try = ($try);
$x = 'ALT quantifier__S_114StarStar_0';    # some outer ltm is controlling us
}
else {
$x = 'ALTLTM quantifier__S_114StarStar_0'; # we are top level ltm
}
my $C = $C->cursor_xact($x);
my $xact = $C->{_xact};

my @gather = ();
for (;;) {
unless (@try) {
$relex //= $C->cursor_fate('STD::Regex', 'quantifier__S_114StarStar_0', $retree);
@try = $relex->($C) or last;
}
$try = shift(@try) // next;

if (ref $try) {
($C->{'_fate'}, $tag, $try) = @$try;   # next candidate fate
}

$C->deb("quantifier__S_114StarStar_0 trying $tag $try") if $::DEBUG & DEBUG::try_processing;
push @gather, ((
sub {
my $C=shift;
if (($C) = ($C->_PATTERN(qr/\G\d++\s++\.\./))
and ($C) = ($C->panic("Spaces not allowed in bare range"))) {
$C
} else { () }
},
sub {
my $C=shift;
if (my ($C) = ($C->_SUBSUMEr(['0'], sub {
my $C = shift;
$C->_PAREN( sub {
my $C=shift;
$C->_PATTERN(qr/\G\d++/)

})
}))) {
$C->_OPTr(sub {
my $C=shift;
if (my ($C) = ($C->_BRACKETr(sub {
my $C=shift;
if (($C) = ($C->_EXACT("\.\."))
and ($C) = ($C->_BRACKETr(sub {
my $C=shift;
do {
my ($tag, $try);
my @try;
my $relex;

my $fate;
my $x;
if ($fate = $C->{'_fate'} and $fate->[1] eq 'quantifier__S_114StarStar_1') {
$C->deb("Fate passed to quantifier__S_114StarStar_1: ", ::fatestr($fate)) if $::DEBUG & DEBUG::fates;
($C->{'_fate'}, $tag, $try) = @$fate;
@try = ($try);
$x = 'ALT quantifier__S_114StarStar_1';    # some outer ltm is controlling us
}
else {
$x = 'ALTLTM quantifier__S_114StarStar_1'; # we are top level ltm
}
my $C = $C->cursor_xact($x);
my $xact = $C->{_xact};

my @gather = ();
for (;;) {
unless (@try) {
$relex //= $C->cursor_fate('STD::Regex', 'quantifier__S_114StarStar_1', $retree);
@try = $relex->($C) or last;
}
$try = shift(@try) // next;

if (ref $try) {
($C->{'_fate'}, $tag, $try) = @$try;   # next candidate fate
}

$C->deb("quantifier__S_114StarStar_1 trying $tag $try") if $::DEBUG & DEBUG::try_processing;
push @gather, ((
sub {
my $C=shift;
if (my ($C) = ($C->_SUBSUMEr(['1'], sub {
my $C = shift;
$C->_PAREN( sub {
my $C=shift;
$C->_PATTERN(qr/\G\d++/)

})
}))) {
scalar(do {
my $M = $C;
$C->panic("Empty range") if $M->{0}->Str > $M->{1}->[0]->Str }, $C)
} else { () }
},
sub {
my $C=shift;
$C->_EXACT("\*")
},
sub {
my $C=shift;
if (my ($C) = ($C->panic("Malformed range"))) { ($C) } else { () }
}
)[$try])->($C);
last if @gather;
last if $xact->[-2];  # committed?
}
@gather;
};
}))) {
$C
} else { () }
}))) { ($C) } else { () }
})
} else { () }
},
sub {
my $C=shift;
$C->_SUBSUMEr(['embeddedblock'], sub {
my $C = shift;
$C->embeddedblock
})
},
sub {
my $C=shift;
$C->_SUBSUMEr(['quantified_atom'], sub {
my $C = shift;
$C->quantified_atom
})
}
)[$try])->($C);
last if @gather;
last if $xact->[-2];  # committed?
}
@gather;
};
}))) {
$C
} else { () }

});
}
;
## token quantifier:sym<~> {
sub quantifier__S_115Tilde__PEEK { $_[0]->_AUTOLEXpeek('quantifier__S_115Tilde', $retree) }
sub quantifier__S_115Tilde {
no warnings 'recursion';
my $self = shift;


local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;

my $C = $self->cursor_xact("RULE quantifier__S_115Tilde");
my $xact = $C->xact;
my $S = $C->{'_pos'};
$C->{'normspace'} = [];
$C->{'quantified_atom'} = [];
$C->{sym} = "\~";
$self->_MATCHIFYr($S, "quantifier__S_115Tilde", do {
my $C = $C;
if (($C) = ($C->_EXACT("\~"))
and ($C) = ($C->_COMMITLTM())
and ($C) = ($C->_OPTr(sub {
my $C=shift;
$C->_SUBSUMEr(['normspace'], sub {
my $C = shift;
$C->normspace
})
}))
and ($C) = ($C->_SUBSUMEr(['quantified_atom'], sub {
my $C = shift;
$C->quantified_atom
}))
and ($C) = ($C->_OPTr(sub {
my $C=shift;
$C->_SUBSUMEr(['normspace'], sub {
my $C = shift;
$C->normspace
})
}))) {
$C->_SUBSUMEr(['quantified_atom'], sub {
my $C = shift;
$C->quantified_atom
})
} else { () }

});
}
;
## token quantifier:sym<~~> {
sub quantifier__S_116TildeTilde__PEEK { $_[0]->_AUTOLEXpeek('quantifier__S_116TildeTilde', $retree) }
sub quantifier__S_116TildeTilde {
no warnings 'recursion';
my $self = shift;


local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;

my $C = $self->cursor_xact("RULE quantifier__S_116TildeTilde");
my $xact = $C->xact;
my $S = $C->{'_pos'};
$C->{sym} = "\~\~";
$self->_MATCHIFYr($S, "quantifier__S_116TildeTilde", do {
my $C = $C;
if (($C) = ($C->_BRACKETr(sub {
my $C=shift;
do {
my ($tag, $try);
my @try;
my $relex;

my $fate;
my $x;
if ($fate = $C->{'_fate'} and $fate->[1] eq 'quantifier__S_116TildeTilde_0') {
$C->deb("Fate passed to quantifier__S_116TildeTilde_0: ", ::fatestr($fate)) if $::DEBUG & DEBUG::fates;
($C->{'_fate'}, $tag, $try) = @$fate;
@try = ($try);
$x = 'ALT quantifier__S_116TildeTilde_0';    # some outer ltm is controlling us
}
else {
$x = 'ALTLTM quantifier__S_116TildeTilde_0'; # we are top level ltm
}
my $C = $C->cursor_xact($x);
my $xact = $C->{_xact};

my @gather = ();
for (;;) {
unless (@try) {
$relex //= $C->cursor_fate('STD::Regex', 'quantifier__S_116TildeTilde_0', $retree);
@try = $relex->($C) or last;
}
$try = shift(@try) // next;

if (ref $try) {
($C->{'_fate'}, $tag, $try) = @$try;   # next candidate fate
}

$C->deb("quantifier__S_116TildeTilde_0 trying $tag $try") if $::DEBUG & DEBUG::try_processing;
push @gather, ((
sub {
my $C=shift;
$C->_EXACT("\!\~\~")
},
sub {
my $C=shift;
$C->_EXACT("\~\~")
}
)[$try])->($C);
last if @gather;
last if $xact->[-2];  # committed?
}
@gather;
};
}))
and ($C) = ($C->_SUBSUMEr(['normspace'], sub {
my $C = shift;
$C->normspace
}))) {
$C->_SUBSUMEr(['quantified_atom'], sub {
my $C = shift;
$C->quantified_atom
})
} else { () }

});
}
;
## token quantmod { ':'? [ '?' | '!' | '+' ]? }
sub quantmod__PEEK { $_[0]->_AUTOLEXpeek('quantmod', $retree) }
sub quantmod {
no warnings 'recursion';
my $self = shift;


local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;

my $C = $self->cursor_xact("RULE quantmod");
my $xact = $C->xact;
my $S = $C->{'_pos'};
$self->_MATCHIFYr($S, "quantmod", do {
if (my ($C) = ($C->_PATTERN(qr/\G\:?+/))) {
$C->_OPTr(sub {
my $C=shift;
if (my ($C) = ($C->_BRACKETr(sub {
my $C=shift;
do {
my ($tag, $try);
my @try;
my $relex;

my $fate;
my $x;
if ($fate = $C->{'_fate'} and $fate->[1] eq 'quantmod_0') {
$C->deb("Fate passed to quantmod_0: ", ::fatestr($fate)) if $::DEBUG & DEBUG::fates;
($C->{'_fate'}, $tag, $try) = @$fate;
@try = ($try);
$x = 'ALT quantmod_0';    # some outer ltm is controlling us
}
else {
$x = 'ALTLTM quantmod_0'; # we are top level ltm
}
my $C = $C->cursor_xact($x);
my $xact = $C->{_xact};

my @gather = ();
for (;;) {
unless (@try) {
$relex //= $C->cursor_fate('STD::Regex', 'quantmod_0', $retree);
@try = $relex->($C) or last;
}
$try = shift(@try) // next;

if (ref $try) {
($C->{'_fate'}, $tag, $try) = @$try;   # next candidate fate
}

$C->deb("quantmod_0 trying $tag $try") if $::DEBUG & DEBUG::try_processing;
push @gather, ((
sub {
my $C=shift;
$C->_EXACT("\?")
},
sub {
my $C=shift;
$C->_EXACT("\!")
},
sub {
my $C=shift;
$C->_EXACT("\+")
}
)[$try])->($C);
last if @gather;
last if $xact->[-2];  # committed?
}
@gather;
};
}))) { ($C) } else { () }
})
} else { () }

});
}
;
## token quantifier:sym<{N,M}> {
sub quantifier__S_117CurNCommaMLy__PEEK { $_[0]->_AUTOLEXpeek('quantifier__S_117CurNCommaMLy', $retree) }
sub quantifier__S_117CurNCommaMLy {
no warnings 'recursion';
my $self = shift;


local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;

my $C = $self->cursor_xact("RULE quantifier__S_117CurNCommaMLy");
my $xact = $C->xact;
my $S = $C->{'_pos'};
$C->{sym} = "\{N\,M\}";
$self->_MATCHIFYr($S, "quantifier__S_117CurNCommaMLy", do {
my $C = $C;
if (($C) = (scalar(do {
}, $C))
and ($C) = ($C->_EXACT("\{"))
and ($C) = ($C->_SUBSUMEr(['0'], sub {
my $C = shift;
$C->_PAREN( sub {
my $C=shift;
$C->_PATTERN(qr/\G\d++/)

})
}))
and ($C) = ($C->_SUBSUMEr(['1'], sub {
my $C = shift;
$C->_PAREN( sub {
my $C=shift;
$C->_PATTERN(qr/\G\,?+/)

})
}))
and ($C) = ($C->_SUBSUMEr(['2'], sub {
my $C = shift;
$C->_PAREN( sub {
my $C=shift;
$C->_PATTERN(qr/\G\d*+/)

})
}))
and ($C) = ($C->_EXACT("\}"))) {
scalar(do {
my $M = $C;
my $all = substr($::ORIG, $self->{'_pos'}, $C->{'_pos'} - $self->{'_pos'});
my $repl = length($M->{1}->Str) ?
($M->{0}->Str . '..' . ($M->{2}->Str || '*')) : $M->{0}->Str;
$C->sorryobs($all . " as general quantifier", 'X**' . $repl);
}, $C)
} else { () }

});
}
;
moose_around tweak  => sub {
my $orig = shift;
no warnings 'recursion';
{
local @_ = @_;
return scalar do { # work around #38809
my $self = shift;
my %args = @_;
last unless exists $args{Perl5} || exists $args{P5};
my $P5 = exists $args{Perl5} ? delete $args{Perl5} : exists $args{P5} ? delete $args{P5} : undef;
$self->require_P5;
$self->cursor_fresh( $::LANG{'Q'} )->mixin( 'STD::Q::q' )->mixin( 'STD::Q::p5' ) ;
};
}
{
local @_ = @_;
return scalar do { # work around #38809
my $self = shift;
my %args = @_;
last unless exists $args{overlap} || exists $args{ov};
my $ov = exists $args{overlap} ? delete $args{overlap} : exists $args{ov} ? delete $args{ov} : undef;
$::RX{'ov'} = $ov;
$self;
};
}
{
local @_ = @_;
return scalar do { # work around #38809
my $self = shift;
my %args = @_;
last unless exists $args{exhaustive} || exists $args{ex};
my $ex = exists $args{exhaustive} ? delete $args{exhaustive} : exists $args{ex} ? delete $args{ex} : undef;
$::RX{'ex'} = $ex;
$self;
};
}
{
local @_ = @_;
return scalar do { # work around #38809
my $self = shift;
my %args = @_;
last unless exists $args{continue} || exists $args{c};
my $c = exists $args{continue} ? delete $args{continue} : exists $args{c} ? delete $args{c} : undef;
$::RX{'c'} = $c;
$self;
};
}
{
local @_ = @_;
return scalar do { # work around #38809
my $self = shift;
my %args = @_;
last unless exists $args{pos} || exists $args{p};
my $p = exists $args{pos} ? delete $args{pos} : exists $args{p} ? delete $args{p} : undef;
$::RX{'p'} = $p;
$self;
};
}
{
local @_ = @_;
return scalar do { # work around #38809
my $self = shift;
my %args = @_;
last unless exists $args{sigspace} || exists $args{s};
my $s = exists $args{sigspace} ? delete $args{sigspace} : exists $args{s} ? delete $args{s} : undef;
$::RX{'s'} = $s;
$self;
};
}
{
local @_ = @_;
return scalar do { # work around #38809
my $self = shift;
my %args = @_;
last unless exists $args{ratchet} || exists $args{r};
my $r = exists $args{ratchet} ? delete $args{ratchet} : exists $args{r} ? delete $args{r} : undef;
$::RX{'r'} = $r;
$self;
};
}
{
local @_ = @_;
return scalar do { # work around #38809
my $self = shift;
my %args = @_;
last unless exists $args{global} || exists $args{g};
my $g = exists $args{global} ? delete $args{global} : exists $args{g} ? delete $args{g} : undef;
$::RX{'g'} = $g;
$self;
};
}
{
local @_ = @_;
return scalar do { # work around #38809
my $self = shift;
my %args = @_;
last unless exists $args{ignorecase} || exists $args{i};
my $i = exists $args{ignorecase} ? delete $args{ignorecase} : exists $args{i} ? delete $args{i} : undef;
$::RX{'i'} = $i;
$self;
};
}
{
local @_ = @_;
return scalar do { # work around #38809
my $self = shift;
my %args = @_;
last unless exists $args{ignoreaccent} || exists $args{a};
my $a = exists $args{ignoreaccent} ? delete $args{ignoreaccent} : exists $args{a} ? delete $args{a} : undef;
$::RX{'a'} = $a;
$self;
};
}
{
local @_ = @_;
return scalar do { # work around #38809
my $self = shift;
my %args = @_;
last unless exists $args{samecase} || exists $args{ii};
my $ii = exists $args{samecase} ? delete $args{samecase} : exists $args{ii} ? delete $args{ii} : undef;
$::RX{'ii'} = $ii;
$self;
};
}
{
local @_ = @_;
return scalar do { # work around #38809
my $self = shift;
my %args = @_;
last unless exists $args{sameaccent} || exists $args{aa};
my $aa = exists $args{sameaccent} ? delete $args{sameaccent} : exists $args{aa} ? delete $args{aa} : undef;
$::RX{'aa'} = $aa;
$self;
};
}
{
local @_ = @_;
return scalar do { # work around #38809
my $self = shift;
my %args = @_;
last unless exists $args{nth};
my $nth = exists $args{nth} ? delete $args{nth} : undef;
$::RX{'nth'} = $nth;
$self;
};
}
{
local @_ = @_;
return scalar do { # work around #38809
my $self = shift;
my %args = @_;
last unless exists $args{st} || exists $args{nd};
my $nd = exists $args{st} ? delete $args{st} : exists $args{nd} ? delete $args{nd} : undef;
$::RX{'nth'} = $nd;
$self;
};
}
{
local @_ = @_;
return scalar do { # work around #38809
my $self = shift;
my %args = @_;
last unless exists $args{rd} || exists $args{th};
my $th = exists $args{rd} ? delete $args{rd} : exists $args{th} ? delete $args{th} : undef;
$::RX{'nth'} = $th;
$self;
};
}
{
local @_ = @_;
return scalar do { # work around #38809
my $self = shift;
my %args = @_;
last unless exists $args{x};
my $x = exists $args{x} ? delete $args{x} : undef;
$::RX{'x'} = $x;
$self;
};
}
{
local @_ = @_;
return scalar do { # work around #38809
my $self = shift;
my %args = @_;
last unless exists $args{bytes};
my $bytes = exists $args{bytes} ? delete $args{bytes} : undef;
$::RX{'bytes'} = $bytes;
$self;
};
}
{
local @_ = @_;
return scalar do { # work around #38809
my $self = shift;
my %args = @_;
last unless exists $args{codes};
my $codes = exists $args{codes} ? delete $args{codes} : undef;
$::RX{'codes'} = $codes;
$self;
};
}
{
local @_ = @_;
return scalar do { # work around #38809
my $self = shift;
my %args = @_;
last unless exists $args{graphs};
my $graphs = exists $args{graphs} ? delete $args{graphs} : undef;
$::RX{'graphs'} = $graphs;
$self;
};
}
{
local @_ = @_;
return scalar do { # work around #38809
my $self = shift;
my %args = @_;
last unless exists $args{chars};
my $chars = exists $args{chars} ? delete $args{chars} : undef;
$::RX{'chars'} = $chars;
$self;
};
}
{
local @_ = @_;
return scalar do { # work around #38809
my $self = shift;
my %args = @_;
last unless exists $args{rw};
my $rw = exists $args{rw} ? delete $args{rw} : undef;
$::RX{'rw'} = $rw;
$self;
};
}
$orig->(@_);
};

1; };
## method require_P5
sub require_P5 {
no warnings 'recursion';
my $self = shift;
require STD_P5;
$self;
};
## method require_P6
sub require_P6 {
no warnings 'recursion';
my $self = shift;
require STD_P6;
$self;
};
## method newlex ($needsig = 0)
sub newlex {
no warnings 'recursion';
my $self = shift;
my $needsig = @_ ? shift() : 0;
my $oid = $::CURLEX->id;
$ALL->{$oid} == $::CURLEX or die "internal error: current lex id is invalid";
my $line = $self->lineof($self->{'_pos'});
my $id;
if ($::NEWLEX) {
$::NEWLEX->{'OUTER::'} = $::CURLEX->idref;
$::CURLEX = $::NEWLEX;
$::NEWLEX = 0;
$id = $::CURLEX->id;
}
else {
$id = 'MY:file<' . $::FILE->{'name'} . '>:line(' . $line . '):pos(' . $self->{'_pos'} . ')';
$::CURLEX = Stash->new(
'OUTER::' => [$oid],
'!file' => $::FILE, '!line' => $line,
'!id' => [$id],
);
};
$::CURLEX->{'!NEEDSIG'} = 1 if $needsig;
$::CURLEX->{'!IN_DECL'} = $::IN_DECL if $::IN_DECL;
$ALL->{$id} = $::CURLEX;
$self->{'LEX'} = $::CURLEX;
$::DECLARAND->{'curlex'} = $::CURLEX if $::DECLARAND;
$self;
};
## method finishlex
sub finishlex {
no warnings 'recursion';
my $self = shift;
my $line = $self->lineof($self->{'_pos'});
$::CURLEX->{'$_'} //= NAME->new( name => '$_', file => $::FILE, line => $line, dynamic => 1, scope => 'my' );
$::CURLEX->{'$/'} //= NAME->new( name => '$/', file => $::FILE, line => $line, dynamic => 1, scope => 'my' );
$::CURLEX->{'$!'} //= NAME->new( name => '$!', file => $::FILE, line => $line, dynamic => 1, scope => 'my' );
$::SIGNUM = 0;
$self;
};
## method getsig
sub getsig {
no warnings 'recursion';
my $self = shift;
my $pv = $::CURLEX->{'%?PLACEHOLDERS'};
my $sig;
if (delete $::CURLEX->{'!NEEDSIG'}) {
if ($pv) {
my $h_ = delete $pv->{'%_'};
my $a_ = delete $pv->{'@_'};
$sig = join ', ', sort {
substr($a,1) cmp substr($b,1) }  keys %$pv;
$sig .= ', *@_' if $a_;
$sig .= ', *%_' if $h_;
}
else {
$sig = '$_ is ref = OUTER::<$_>'};
$::CURLEX->{'$?SIGNATURE'} = $sig;
}
else {
$sig = $::CURLEX->{'$?SIGNATURE'}};
$self->{'sig'} = $self->makestr(TEXT => $sig);
$self->{'lex'} = $::CURLEX->idref;
if (($::DECLARAND->{'mult'}//'') ne 'proto') {
for (keys %$::CURLEX) {
my $desc = $::CURLEX->{$_};
next unless $_ =~ m/(\$|\@|\%|\&)\w/;
next if $_ eq '$_' or $_ eq '@_' or $_ eq '%_';
next if $desc->{'used'};
next if $desc->{'rebind'};
next if $desc->{'dynamic'};
next if $desc->{'scope'} eq 'state';
next if $desc->{'stub'};
my $pos = $desc->{'declaredat'} // $self->{'_pos'};
$self->cursor($pos)->worry("$_ is declared but not used");
}
};
$self;
};
## method getdecl
sub getdecl {
no warnings 'recursion';
my $self = shift;
$self->{'decl'} = $::DECLARAND;
$self;
};
## method is_name ($n, $curlex = $*CURLEX)
sub is_name {
no warnings 'recursion';
my $self = shift;
die 'Required argument n omitted' unless @_;
my $n = @_ ? shift() : undef;
my $curlex = @_ ? shift() : $::CURLEX;
my $name = $n;
$self->deb("is_name $name") if $::DEBUG & DEBUG::symtab;
my $curpkg = $::CURPKG;
return 1 if $name =~ /\:\:\(/;
my @components = $self->canonicalize_name($name);
if (@components > 1) {
return 1 if $components[0] eq 'COMPILING::';
return 1 if $components[0] eq 'CALLER::';
return 1 if $components[0] eq 'CONTEXT::';
if ($curpkg = $self->find_top_pkg($components[0])) {
$self->deb("Found lexical package ", $components[0]) if $::DEBUG & DEBUG::symtab;
shift @components;
}
else {
$self->deb("Looking for GLOBAL::<$name>") if $::DEBUG & DEBUG::symtab;
$curpkg = $::GLOBAL;
};
while (@components > 1) {
my $pkg = shift @components;
$curpkg = $curpkg->{$pkg};
return 0 unless $curpkg;
eval {
my $outlexid = $curpkg->[0];
return 0 unless $outlexid;
$curpkg = $ALL->{$outlexid};
return 0 unless $curpkg;
};
$self->deb("Found $pkg okay") if $::DEBUG & DEBUG::symtab;
}
;
};
$name = shift(@components)//'';
$self->deb("Looking for $name") if $::DEBUG & DEBUG::symtab;
return 1 if $name eq '';
my $lex = $curlex;
while ($lex) {
$self->deb("Looking in ", $lex->id) if $::DEBUG & DEBUG::symtab;
if ($lex->{$name}) {
$self->deb("Found $name in ", $lex->id) if $::DEBUG & DEBUG::symtab;
$lex->{$name}->{'used'} = 1;
return 1;
};
my $oid = $lex->{'OUTER::'}->[0] || last;
$lex = $ALL->{$oid};
}
;
return 1 if $curpkg->{$name};
return 1 if $::GLOBAL->{$name};
$self->deb("$name not found") if $::DEBUG & DEBUG::symtab;
return 0;
};
## method find_stash ($n, $curlex = $*CURLEX)
sub find_stash {
no warnings 'recursion';
my $self = shift;
die 'Required argument n omitted' unless @_;
my $n = @_ ? shift() : undef;
my $curlex = @_ ? shift() : $::CURLEX;
my $name = $n;
$self->deb("find_stash $name") if $::DEBUG & DEBUG::symtab;
return () if $name =~ /\:\:\(/;
my @components = $self->canonicalize_name($name);
if (@components > 1) {
return () if $components[0] eq 'COMPILING::';
return () if $components[0] eq 'CALLER::';
return () if $components[0] eq 'CONTEXT::';
if ($curlex = $self->find_top_pkg($components[0])) {
$self->deb("Found lexical package ", $components[0]) if $::DEBUG & DEBUG::symtab;
shift @components;
}
else {
$self->deb("Looking for GLOBAL::<$name>") if $::DEBUG & DEBUG::symtab;
$curlex = $::GLOBAL;
};
while (@components > 1) {
my $lex = shift @components;
$curlex = $curlex->{$lex};
return () unless $curlex;
eval {
my $outlexid = $curlex->[0];
return 0 unless $outlexid;
$curlex = $ALL->{$outlexid};
return () unless $curlex;
};
$self->deb("Found $lex okay") if $::DEBUG & DEBUG::symtab;
}
;
};
$name = shift(@components)//'';
return $curlex if $name eq '';
my $lex = $curlex;
while ($lex) {
return $_ if $_ = $lex->{$name};
my $oid = $lex->{'OUTER::'}->[0] || last;
$lex = $ALL->{$oid};
}
;
return $_ if $_ = $curlex->{$name};
return $_ if $_ = $::GLOBAL->{$name};
return ();
};
## method find_top_pkg ($name)
sub find_top_pkg {
no warnings 'recursion';
my $self = shift;
die 'Required argument name omitted' unless @_;
my $name = @_ ? shift() : undef;
$self->deb("find_top_pkg $name") if $::DEBUG & DEBUG::symtab;
$name .= '::' unless $name =~ /\:\:$/;
if ($name eq 'OUR::') {
return $::CURPKG}
elsif ($name eq 'MY::') {
return $::CURLEX}
elsif ($name eq 'OUTER::') {
return $ALL->{$::CURLEX->{'OUTER::'}->[0]}}
elsif ($name eq 'CORE::') {
return $::CORE}
elsif ($name eq 'SETTING::') {
return $::SETTING}
elsif ($name eq 'UNIT::') {
return $::UNIT};
my $lex = $::CURLEX;
while ($lex) {
return $lex->{$name} if $lex->{$name};
my $oid = $lex->{'OUTER::'}->[0] || last;
$lex = $ALL->{$oid};
}
;
return 0;
};
## method add_name ($name)
sub add_name {
no warnings 'recursion';
my $self = shift;
die 'Required argument name omitted' unless @_;
my $name = @_ ? shift() : undef;
my $scope = $::SCOPE || 'my';
my $pkgdecl = $::PKGDECL || 'symbol';
return $self if $scope eq 'anon' or $pkgdecl eq 'slang';
$self->deb("Adding $scope $name") if $::DEBUG & DEBUG::symtab;
if ($scope eq 'augment' or $scope eq 'supersede') {
$self->is_name($name) or
$self->worry("Can't $scope $pkgdecl $name because it doesn't exist");
$::MONKEY_TYPING or
$self->sorry("Can't $scope $pkgdecl $name without MONKEY_TYPING");
}
else {
if ($scope eq 'our') {
$self->add_our_name($name)}
else {
$self->add_my_name($name)}};
$self;
};
## method add_my_name ($n, $d = Nil, $p = Nil)
sub add_my_name {
no warnings 'recursion';
my $self = shift;
die 'Required argument n omitted' unless @_;
my $n = @_ ? shift() : undef;
my $d = @_ ? shift() : ();
my $p = @_ ? shift() : ();
my $name = $n;
$self->deb("add_my_name $name in ", $::CURLEX->id) if $::DEBUG & DEBUG::symtab;
return $self if $name =~ /\:\:\(/;
my $curstash = $::CURLEX;
my @components = $self->canonicalize_name($name);
my $sid = $curstash->id // '???';
while (@components > 1) {
my $pkg = shift @components;
$sid .= "::$pkg";
my $newstash = $curstash->{$pkg} //= Stash->new(
'PARENT::' => $curstash->idref,
'!stub' => 1,
'!id' => [$sid] );
$self->deb("Adding new package $pkg in ", $curstash->id) if $::DEBUG & DEBUG::symtab;
$curstash = $newstash;
}
;
$name = my $shortname = shift @components;
return $self unless defined $name and $name ne '';
return $self if $name eq '$' or $name eq '@' or $name eq '%';
return $self->add_categorical(substr($name,1)) if $name =~ /^\&\w+\:/;
if ($shortname =~ /\:/) {
$shortname =~ s/\:.*//};
my $declaring = $d // NAME->new(
name => $name,
file => $::FILE, line => $self->line,
mult => ($::MULTINESS||'only'),
of   => $::OFTYPE,
scope => $::SCOPE,
);
my $old = $curstash->{$name};
if ($old and $old->{'line'} and not $old->{'stub'}) {
$self->deb("$name exists, curstash = ", $curstash->id) if $::DEBUG & DEBUG::symtab;
my $omult = $old->{'mult'} // '';
if ($declaring == $old) {
}
elsif ($::SCOPE eq 'use') {
}
elsif ($::MULTINESS eq 'multi' and $omult ne 'only') {
}
elsif ($omult eq 'proto' and $::MULTINESS ne 'proto' and $::MULTINESS ne 'only') {
}
elsif ($::PKGDECL eq 'role') {
}
elsif ($::SIGNUM and $old->{'signum'} and $::SIGNUM != $old->{'signum'}) {
$old->{'signum'} = $::SIGNUM}
else {
my $ofile = $old->file // 0;
my $oline = $old->line // '???';
my $loc = '';
if ($ofile) {
if ($ofile != $::FILE) {
my $oname = $ofile->{'name'};
$loc = " (see $oname line $oline)";
}
else {
$loc = " (see line $oline)"}};
if ($old->olex) {
my $rebind = $old->{'rebind'};
my $truename = $old->{'varbind'}->{'truename'};
$self->sorry("Lexical symbol '$name' is already bound to an outer symbol$loc;\n  the implicit outer binding at line $rebind must be rewritten as $truename\n  before you can unambiguously declare a new '$name' in this scope");
}
elsif ($name =~ /^\w/) {
$self->sorry("Illegal redeclaration of symbol '$name'$loc")}
elsif ($name =~ s/^\&//) {
$self->sorry("Illegal redeclaration of routine '$name'$loc") unless $name eq ''}
else {
$self->worry("Useless redeclaration of variable $name$loc")};
return $self;
};
}
else {
$::DECLARAND = $curstash->{$name} = $declaring;
$curstash->{$shortname} = $declaring unless $shortname eq $name;
$::DECLARAND->{'declaredat'} = $self->{'_pos'};
$::DECLARAND->{'inlex'} = $curstash->idref;
$::DECLARAND->{'signum'} = $::SIGNUM if $::SIGNUM;
$::DECLARAND->{'const'} ||= 1 if $::IN_DECL eq 'constant';
$::DECLARAND->{'used'} = 1 if substr($name,0,1) eq '&' and @::MYSTERY{substr($name,1)};
if (!$::DECLARAND->{'const'} and $shortname =~ /^\w+$/) {
$curstash->{"&$shortname"} //= $curstash->{$shortname};
$curstash->{"&$shortname"}->{'used'} = 1;
$sid .= "::$name";
if ($name !~ /\:\</) {
$::NEWPKG = $curstash->{$name . '::'} = ($p // Stash->new(
'PARENT::' => $curstash->idref,
'!file' => $::FILE, '!line' => $self->line,
'!id' => [$sid] ))};
};
};
$self;
};
## method add_our_name ($n)
sub add_our_name {
no warnings 'recursion';
my $self = shift;
die 'Required argument n omitted' unless @_;
my $n = @_ ? shift() : undef;
my $name = $n;
$self->deb("add_our_name $name in " . $::CURPKG->id) if $::DEBUG & DEBUG::symtab;
return $self if $name =~ /\:\:\(/;
my $curstash = $::CURPKG;
$self->deb("curstash $curstash global $::GLOBAL ", join ' ', %$::GLOBAL) if $::DEBUG & DEBUG::symtab;
$name =~ s/\:ver\<.*?\>//;
$name =~ s/\:auth\<.*?\>//;
my @components = $self->canonicalize_name($name);
if (@components > 1) {
my $c = $self->find_top_pkg($components[0]);
if ($c) {
shift @components;
$curstash = $c;
};
};
my $sid = $curstash->id // '???';
while (@components > 1) {
my $pkg = shift @components;
$sid .= "::$pkg";
my $newstash = $curstash->{$pkg} //= Stash->new(
'PARENT::' => $curstash->idref,
'!stub' => 1,
'!id' => [$sid] );
$curstash = $newstash;
$self->deb("Adding new package $pkg in $curstash ") if $::DEBUG & DEBUG::symtab;
}
;
$name = my $shortname = shift @components;
return $self unless defined $name and $name ne '';
if ($shortname =~ /\:/) {
$shortname =~ s/\:.*//};
my $declaring = $::DECLARAND // NAME->new(
name => $name,
file => $::FILE, line => $self->line,
mult => ($::MULTINESS||'only'),
of   => $::OFTYPE,
scope => $::SCOPE,
);
my $old = $curstash->{$name};
if ($old and $old->{'line'} and not $old->{'stub'}) {
my $omult = $old->{'mult'} // '';
if ($declaring == $old) {
}
elsif ($::SCOPE eq 'use') {
}
elsif ($::MULTINESS eq 'multi' and $omult ne 'only') {
}
elsif ($omult eq 'proto' and $::MULTINESS ne 'proto' and $::MULTINESS ne 'only') {
}
elsif ($::PKGDECL eq 'role') {
}
else {
my $ofile = $old->file // 0;
my $oline = $old->line // '???';
my $loc = '';
if ($ofile) {
if ($ofile != $::FILE) {
my $oname = $ofile->{'name'};
$loc = " (from $oname line $oline)";
}
else {
$loc = " (from line $oline)"}};
$sid = $self->clean_id($sid, $name);
if ($name =~ /^\w/) {
$self->sorry("Illegal redeclaration of symbol '$sid'$loc")}
elsif ($name =~ s/^\&//) {
$self->sorry("Illegal redeclaration of routine '$sid'$loc") unless $name eq ''}
else {
};
return $self;
};
}
else {
$::DECLARAND = $curstash->{$name} = $declaring;
$curstash->{$shortname} //= $declaring unless $shortname eq $name;
$::DECLARAND->{'inpkg'} = $curstash->idref;
if ($shortname =~ /^\w+$/ and $::IN_DECL ne 'constant') {
$curstash->{"&$shortname"} //= $declaring;
$curstash->{"&$shortname"}->{'used'} = 1;
$sid .= "::$name";
$::NEWPKG = $curstash->{$name . '::'} //= Stash->new(
'PARENT::' => $curstash->idref,
'!file' => $::FILE, '!line' => $self->line,
'!id' => [$sid] );
};
};
$self->add_my_name($n, $declaring, $curstash->{$name . '::'}) if $curstash == $::CURPKG;
$self;
};
## method add_mystery ($token,$pos,$ctx)
sub add_mystery {
no warnings 'recursion';
my $self = shift;
die 'Required argument token omitted' unless @_;
my $token = @_ ? shift() : undef;
die 'Required argument pos omitted' unless @_;
my $pos = @_ ? shift() : undef;
die 'Required argument ctx omitted' unless @_;
my $ctx = @_ ? shift() : undef;
my $name = $token->Str;
return $self if $::IN_PANIC;
if ($self->is_known('&' . $name) or $self->is_known($name)) {
$self->deb("$name is known") if $::DEBUG & DEBUG::symtab}
else {
$self->deb("add_mystery $name $::CURLEX") if $::DEBUG & DEBUG::symtab;
$::MYSTERY{$name}->{'lex'} = $::CURLEX;
$::MYSTERY{$name}->{'token'} = $token;
$::MYSTERY{$name}->{'ctx'} = $ctx;
$::MYSTERY{$name}->{'line'} .= ',' if $::MYSTERY{$name}->{'line'};
$::MYSTERY{$name}->{'line'} .= $self->lineof($pos);
};
$self;
};
## method explain_mystery()
sub explain_mystery {
no warnings 'recursion';
my $self = shift;
my %post_types;
my %unk_types;
my %unk_routines;
my $m = '';
for (keys(%::MYSTERY)) {
my $p = $::MYSTERY{$_}->{'lex'};
if ($self->is_name($_, $p)) {
$post_types{$_} = $::MYSTERY{$_};
next;
};
next if $self->is_known($_, $p) or $self->is_known('&' . $_, $p);
if ($_ lt 'a') {
$unk_types{$_} = $::MYSTERY{$_}}
else {
$unk_routines{$_} = $::MYSTERY{$_}};
}
;
if (%post_types) {
my @tmp = sort keys(%post_types);
$m .= "Illegally post-declared type" . ('s' x (@tmp != 1)) . ":\n";
for (@tmp) {
$m .= "\t'$_' used at line " . $post_types{$_}->{'line'} . "\n"}
;
};
if (%unk_types) {
my @tmp = sort keys(%unk_types);
$m .= "Undeclared name" . ('s' x (@tmp != 1)) . ":\n";
for (@tmp) {
$m .= "\t'$_' used at line " . $unk_types{$_}->{'line'} . "\n"}
;
};
if (%unk_routines) {
my @tmp = sort keys(%unk_routines);
$m .= "Undeclared routine" . ('s' x (@tmp != 1)) . ":\n";
for (@tmp) {
$m .= "\t'$_' used at line " . $unk_routines{$_}->{'line'} . "\n"}
;
};
$self->sorry($m) if $m;
$self;
};
## method load_setting ($setting)
sub load_setting {
no warnings 'recursion';
my $self = shift;
die 'Required argument setting omitted' unless @_;
my $setting = @_ ? shift() : undef;
$ALL = $self->load_lex($setting);
$::CORE = $ALL->{'CORE'};
$::CORE->{'!id'} //= ['CORE'];
$::SETTING = $ALL->{'SETTING'};
$::CURLEX = $::SETTING;
$::GLOBAL = $::CORE->{'GLOBAL::'} = Stash->new(
'!file' => $::FILE, '!line' => 1,
'!id' => ['GLOBAL'],
);
$::CURPKG = $::GLOBAL;
};
## method is_known ($n, $curlex = $*CURLEX)
sub is_known {
no warnings 'recursion';
my $self = shift;
die 'Required argument n omitted' unless @_;
my $n = @_ ? shift() : undef;
my $curlex = @_ ? shift() : $::CURLEX;
my $name = $n;
$self->deb("is_known $name") if $::DEBUG & DEBUG::symtab;
return 1 if $::QUASIMODO;
return 1 if $::CURPKG->{$name};
return 0 if $name =~ /\:\:\(/;
my $curpkg = $::CURPKG;
my @components = $self->canonicalize_name($name);
if (@components > 1) {
return 1 if $components[0] eq 'COMPILING::';
return 1 if $components[0] eq 'CALLER::';
return 1 if $components[0] eq 'CONTEXT::';
if ($curpkg = $self->find_top_pkg($components[0])) {
$self->deb("Found lexical package ", $components[0]) if $::DEBUG & DEBUG::symtab;
shift @components;
}
else {
$self->deb("Looking for GLOBAL::<$name>") if $::DEBUG & DEBUG::symtab;
$curpkg = $::GLOBAL;
};
while (@components > 1) {
my $pkg = shift @components;
$self->deb("Looking for $pkg in $curpkg ", join ' ', keys(%$curpkg)) if $::DEBUG & DEBUG::symtab;
$curpkg = $curpkg->{$pkg};
return 0 unless $curpkg;
eval {
my $outlexid = $curpkg->[0];
return 0 unless $outlexid;
$curpkg = $ALL->{$outlexid};
return 0 unless $curpkg;
};
$self->deb("Found $pkg okay, now in $curpkg ") if $::DEBUG & DEBUG::symtab;
}
;
};
$name = shift(@components)//'';
$self->deb("Final component is $name") if $::DEBUG & DEBUG::symtab;
return 1 if $name eq '';
if ($curpkg->{$name}) {
$self->deb("Found") if $::DEBUG & DEBUG::symtab;
$curpkg->{$name}->{'used'}++;
return 1;
};
return 0 if $curpkg != $::CURPKG and $curpkg->{'!id'}->[0] =~ /^GLOBAL($|\:\:)/;
my $varbind = {
truename => '???' };
return 1 if $n !~ /\:\:/ and $self->lex_can_find_name($curlex,$name,$varbind);
$self->deb("Not Found") if $::DEBUG & DEBUG::symtab;
return 0;
};
## method lex_can_find_name ($lex, $name, $varbind)
sub lex_can_find_name {
no warnings 'recursion';
my $self = shift;
die 'Required argument lex omitted' unless @_;
my $lex = @_ ? shift() : undef;
die 'Required argument name omitted' unless @_;
my $name = @_ ? shift() : undef;
die 'Required argument varbind omitted' unless @_;
my $varbind = @_ ? shift() : undef;
$self->deb("Looking in ", $lex->id) if $::DEBUG & DEBUG::symtab;
if ($lex->{$name}) {
$self->deb("Found $name in ", $lex->id) if $::DEBUG & DEBUG::symtab;
$lex->{$name}->{'used'}++;
return 1;
};
my $outlexid = $lex->{'OUTER::'}->[0];
return 0 unless $outlexid;
my $outlex = $ALL->{$outlexid};
if ($self->lex_can_find_name($outlex,$name,$varbind)) {
my $outname = $outlex->{$name}->{'name'};
my $outfile = $outlex->{$name}->{'file'};
my $outline = $outlex->{$name}->{'line'};
$outname = '<' . $outname . '>' unless $outname =~ /\:\:\</;
$outname = "OUTER::" . $outname;
$lex->{$name} = NAME->new(
olex => $lex->idref,
name => $outname,
file => $outfile, line => $outline,
rebind => $self->line,
varbind => $varbind,
mult => 'only',
scope => $lex->{$name}->{'scope'},
);
$varbind->{'truename'} = $outname;
return 1;
};
return 0;
};
## method add_routine ($name)
sub add_routine {
no warnings 'recursion';
my $self = shift;
die 'Required argument name omitted' unless @_;
my $name = @_ ? shift() : undef;
$::MEMOS[$self->{'_pos'}]->{'wasname'} = $name if $self->is_name($name);
my $vname = '&' . $name;
$self->add_name($vname);
$self;
};
## method add_variable ($name)
sub add_variable {
no warnings 'recursion';
my $self = shift;
die 'Required argument name omitted' unless @_;
my $name = @_ ? shift() : undef;
my $scope = $::SCOPE || 'our';
return $self if $scope eq 'anon';
if ($scope eq 'our') {
$self->add_our_name($name)}
else {
$self->add_my_name($name)};
$self;
};
## method add_constant($name,$value)
sub add_constant {
no warnings 'recursion';
my $self = shift;
die 'Required argument name omitted' unless @_;
my $name = @_ ? shift() : undef;
die 'Required argument value omitted' unless @_;
my $value = @_ ? shift() : undef;
local $::IN_DECL = 'constant';
$self->deb("add_constant $name = $value in", $::CURLEX->id) if $::DEBUG & DEBUG::symtab;
local $::DECLARAND;
$self->add_my_name($name);
$::DECLARAND->{'value'} = $value;
$self;
};
## method add_placeholder($name)
sub add_placeholder {
no warnings 'recursion';
my $self = shift;
die 'Required argument name omitted' unless @_;
my $name = @_ ? shift() : undef;
my $decl = $::CURLEX->{'!IN_DECL'} // '';
$decl = ' ' . $decl if $decl;
local $::IN_DECL = 'variable';
if ($::SIGNUM) {
return $self->sorry("Placeholder variable $name is not allowed in the$decl signature")}
elsif (my $siggy = $::CURLEX->{'$?SIGNATURE'}) {
return $self->sorry("Placeholder variable $name cannot override existing signature $siggy")};
if (not $::CURLEX->{'!NEEDSIG'}) {
if ($::CURLEX == $::UNIT) {
return $self->sorry("Placeholder variable $name may not be used outside of a block")};
return $self->sorry("Placeholder variable $name may not be used here because the surrounding$decl block takes no signature");
};
if ($name =~ /\:\:/) {
return $self->sorry("Placeholder variable $name may not be package qualified")};
my $varname = $name;
my $twigil;
my $signame;
$twigil = '^' if $varname =~ s/\^//;
$signame = $twigil = ':' if $varname =~ s/\://;
$signame .= $varname;
return $self if $::CURLEX->{'%?PLACEHOLDERS'}->{$signame}++;
if ($::CURLEX->{$varname}) {
return $self->sorry("$varname has already been used as a non-placeholder in the surrounding$decl block,\n  so you will confuse the reader if you suddenly declare $name here")};
$self->add_my_name($varname);
$::CURLEX->{$varname}->{'used'} = 1;
$self;
};
## method check_variable ($variable)
sub check_variable {
no warnings 'recursion';
my $self = shift;
die 'Required argument variable omitted' unless @_;
my $variable = @_ ? shift() : undef;
my $name = $variable->Str;
$self->deb("check_variable $name") if $::DEBUG & DEBUG::symtab;
my ($sigil, $twigil, $first) = $name =~ /(\$|\@|\%|\&)(\W*)(.?)/;
given ($twigil) {
when ('') {
my $ok = 0;
$ok ||= $::IN_DECL;
$ok ||= $sigil eq '&';
$ok ||= $first lt 'A';
$ok ||= $self->is_known($name);
$ok ||= $name =~ /.\:\:/ && $name !~ /MY|UNIT|OUTER|SETTING|CORE/;
if (not $ok) {
my $id = $name;
$id =~ s/^\W\W?//;
if ($name eq '@_' or $name eq '%_') {
$variable->add_placeholder($name)}
else {
if (my $scope = $::MEMOS[$variable->from]->{'declend'}) {
return $variable->sorry("Variable $name is not predeclared (declarators are tighter than comma, so maybe your '$scope' signature needs parens?)")}
elsif ($id !~ /\:\:/) {
if ($self->is_known('@' . $id)) {
return $variable->sorry("Variable $name is not predeclared (did you mean \@$id?)")}
elsif ($self->is_known('%' . $id)) {
return $variable->sorry("Variable $name is not predeclared (did you mean \%$id?)")}};
return $variable->sorry("Variable $name is not predeclared");
};
}
elsif ($::CURLEX->{$name}) {
$::CURLEX->{$name}->{'used'}++};
}
;
when ('^') {
local $::MULTINESS = 'multi';
$variable->add_placeholder($name);
}
;
when (':') {
local $::MULTINESS = 'multi';
$variable->add_placeholder($name);
}
;
when ('~') {
return @::LANG{substr($name,2)}}
;
when ('?') {
if ($name =~ /\:\:/) {
my ($first) = $self->canonicalize_name($name);
$variable->worry("Unrecognized variable: $name") unless $first =~ /^(CALLER|CONTEXT|OUTER|MY|SETTING|CORE)\:\:$/;
}
else {
my $v = $variable->lookup_compiler_var($name);
$variable->{'value'} = $v if $v;
}}
;
}
;
$self;
};
## method lookup_compiler_var($name, $default = Nil)
sub lookup_compiler_var {
no warnings 'recursion';
my $self = shift;
die 'Required argument name omitted' unless @_;
my $name = @_ ? shift() : undef;
my $default = @_ ? shift() : ();
my $lex = $::CURLEX->{$name};
if (defined $lex) {
if (exists $lex->{'thunk'}) {
return $lex->{'thunk'}->()}
else {
return $lex->{'value'}}};
given ($name) {
when ('$?FILE')     {
return $::FILE->{'name'}}
;
when ('$?LINE')     {
return $self->lineof($self->{'_pos'})}
;
when ('$?POSITION') {
return $self->{'_pos'}}

;
when ('$?LANG')     {
return \%::LANG}

;
when ('$?LEXINFO')   {
return $::CURLEX}

;
when ('$?PACKAGE')  {
return $::CURPKG}
;
when ('$?MODULE')   {
return $::CURPKG}
;
when ('$?CLASS')    {
return $::CURPKG}
;
when ('$?ROLE')     {
return $::CURPKG}
;
when ('$?GRAMMAR')  {
return $::CURPKG}

;
when ('$?PACKAGENAME') {
return $::CURPKG->id }

;
when ('$?OS')       {
return 'unimpl'}
;
when ('$?DISTRO')   {
return 'unimpl'}
;
when ('$?VM')       {
return 'unimpl'}
;
when ('$?XVM')      {
return 'unimpl'}
;
when ('$?PERL')     {
return 'unimpl'}

;
when ('$?USAGE')    {
return 'unimpl'}

;
when ('&?ROUTINE')  {
return 'unimpl'}
;
when ('&?BLOCK')    {
return 'unimpl'}

;
when ('%?CONFIG')    {
return 'unimpl'}
;
when ('%?DEEPMAGIC') {
return 'unimpl'}

;
my $dynvar = $self->lookup_dynvar($name);
return $dynvar if defined $dynvar;
return $default if defined $default;
default {
$self->worry("Unrecognized variable: $name");
return 0;
}
;
}
;
};
## method panic (Str $s)
sub panic {
no warnings 'recursion';
my $self = shift;
die 'Required argument s omitted' unless @_;
my $s = @_ ? shift() : undef;
die "Recursive panic" if $::IN_PANIC;
$::IN_PANIC++;
$self->deb("panic $s") if $::DEBUG;
my $m;
my $here = $self;
my $highvalid = $self->{'_pos'} <= $::HIGHWATER;
$here = $self->cursor($::HIGHWATER) if $highvalid;
my $first = $here->lineof($::LAST_NIBBLE->from);
my $last = $here->lineof($::LAST_NIBBLE->{'_pos'});
if ($first != $last) {
if ($here->lineof($here->{'_pos'}) == $last) {
$m .= "(Possible runaway string from line $first)\n"}
else {
$first = $here->lineof($::LAST_NIBBLE_MULTILINE->from);
$last = $here->lineof($::LAST_NIBBLE_MULTILINE->{'_pos'});
if ($here->lineof($here->{'_pos'}) - $last < $last - $first)  {
$m .= "(Possible runaway string from line $first to line $last)\n"};
}};
$m .= $s;
if ($highvalid) {
$m .= $::HIGHMESS if $::HIGHMESS;
$::HIGHMESS = $m;
}
else {
$::HIGHMESS .= $s . "\n"};
$m .= $here->locmess;
$m .= "\n" unless $m =~ /\n$/;
if ($highvalid and %$::HIGHEXPECT) {
my @keys = sort keys %$::HIGHEXPECT;
if (@keys > 1) {
$m .= "    expecting any of:\n\t" . join("\n\t", sort keys %$::HIGHEXPECT) . "\n"}
else {
$m .= "    expecting @keys\n" unless $keys[0] eq 'whitespace'};
};
if ($m =~ /infix|nofun/ and not $m =~ /regex/ and not $m =~ /infix_circumfix/) {
my @t = $here->suppose( sub {
$here->term } );
if (@t) {
my $endpos = $here->{'_pos'};
my $startpos = $::MEMOS[$endpos]->{'ws'} // $endpos;
if ($self->lineof($startpos) != $self->lineof($endpos)) {
$m =~ s|Confused|Two terms in a row (previous line missing its semicolon?)|}
elsif ($::MEMOS[$here->{'_pos'} - 1]->{'baremeth'}) {
$m =~ s|Confused|Two terms in a row (method call requires colon or parens to take arguments)|}
elsif ($::MEMOS[$here->{'_pos'} - 1]->{'arraycomp'}) {
$m =~ s|Confused|Two terms in a row (preceding is not a valid reduce operator)|}
else {
$m =~ s|Confused|Two terms in a row|};
}
elsif (my $type = $::MEMOS[$here->{'_pos'} - 1]->{'nodecl'}) {
my @t = $here->suppose( sub {
$here->variable } );
if (@t) {
my $variable = $t[0]->Str;
$m =~ s|Confused|Bare type $type cannot declare $variable without a preceding scope declarator such as 'my'|;
};
};
}
elsif (my $type = $::MEMOS[$here->{'_pos'} - 1]->{'wasname'}) {
my @t = $here->suppose( sub {
$here->identifier } );
my $name = $t[0]->Str;
my $s = $::SCOPE ? "'$::SCOPE'" : '(missing) scope declarator';
my $d = $::IN_DECL;
$d = "$::MULTINESS $d" if $::MULTINESS and $::MULTINESS ne $d;
$m =~ s|Malformed block|Return type $type is not allowed between '$d' and '$name'; please put it:\n  after the $s but before the '$d',\n  within the signature following the '-->' marker, or\n  as the argument of a 'returns' trait after the signature.|;
};
if (@::WORRIES) {
$m .= "Other potential difficulties:\n  " . join( "\n  ", @::WORRIES) . "\n"};
$::IN_PANIC--;
die $m if $::IN_SUPPOSE;
$::IN_PANIC++;
print STDERR $Cursor::RED, '===', $Cursor::CLEAR, 'SORRY!', $Cursor::RED, '===', $Cursor::CLEAR, "\n"
unless $::FATALS++;
print STDERR $m;
$self->explain_mystery();
$::IN_PANIC--;
die "Parse failed\n";
};
## regex is_ok {
sub is_ok__PEEK { $_[0]->_AUTOLEXpeek('is_ok', $retree) }
sub is_ok {
no warnings 'recursion';
my $self = shift;


local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;

my $C = $self->cursor_xact("RULE is_ok");
my $xact = $C->xact;
my $S = $C->{'_pos'};
$self->_MATCHIFY($S, "is_ok", LazyMap::lazymap(sub {
my $C=shift;
if (my ($C) = ($C->_EXACT("\#OK"))) {
LazyMap::lazymap(sub {
my $C=shift;
LazyMap::lazymap(sub {
my $C=shift;
LazyMap::lazymap(sub {
my $C=shift;
$C->_PATTERN(qr/\G(?m:$)/)
},
$C->_STARf(sub {
my $C=shift;
$C->_PATTERN(qr/\G[\x20\t\r]/)
}))
},
$C->_SUBSUME(['okif'], sub {
my $C = shift;
$C->_BRACKET(sub {
my $C=shift;
$C->_STARf(sub {
my $C=shift;
$C->_NOTCHAR( sub { my $C=shift;
$C->_EXACT("\n")
})
})
})
}))
},
$C->_STARf(sub {
my $C=shift;
$C->_PATTERN(qr/\G[\x20\t\r]/)
}))
} else { () }
},
$C->_STARf(sub {
my $C=shift;
$C->_NOTCHAR( sub { my $C=shift;
$C->_EXACT("\n")
})
})));
}
;
## method worry (Str $s)
sub worry {
no warnings 'recursion';
my $self = shift;
die 'Required argument s omitted' unless @_;
my $s = @_ ? shift() : undef;
my $m = $s . $self->locmess;
my ($okmaybe) = $self->suppose( sub {
$self->is_ok});
if ($okmaybe) {
my $okif = $okmaybe->{'okif'}->Str;
return $self if $okif eq '' or $s =~ /$okif/;
};
push @::WORRIES, $m unless $::WORRIES{$s}++;
$self;
};
## method sorry (Str $s)
sub sorry {
no warnings 'recursion';
my $self = shift;
die 'Required argument s omitted' unless @_;
my $s = @_ ? shift() : undef;
$self->deb("sorry $s") if $::DEBUG;
print STDERR $Cursor::RED, '===', $Cursor::CLEAR, 'SORRY!', $Cursor::RED, '===', $Cursor::CLEAR, "\n"
unless $::IN_SUPPOSE or $::FATALS++;
if ($s) {
my $m = $s;
$m .= $self->locmess . "\n" unless $m =~ /\n$/;
if ($::FATALS > 10 or $::IN_SUPPOSE) {
die $m}
else {
print STDERR $m unless $::WORRIES{$m}++};
};
$self;
};
## method obs (Str $old, Str $new, Str $when = ' in Perl 6')
sub obs {
no warnings 'recursion';
my $self = shift;
die 'Required argument old omitted' unless @_;
my $old = @_ ? shift() : undef;
die 'Required argument new omitted' unless @_;
my $new = @_ ? shift() : undef;
my $when = @_ ? shift() : ' in Perl 6';
%$::HIGHEXPECT = ();
$self->panic("Unsupported use of $old;$when please use $new");
};
## method sorryobs (Str $old, Str $new, Str $when = ' in Perl 6')
sub sorryobs {
no warnings 'recursion';
my $self = shift;
die 'Required argument old omitted' unless @_;
my $old = @_ ? shift() : undef;
die 'Required argument new omitted' unless @_;
my $new = @_ ? shift() : undef;
my $when = @_ ? shift() : ' in Perl 6';
%$::HIGHEXPECT = ();
$self->sorry("Unsupported use of $old;$when please use $new");
$self;
};
## method worryobs (Str $old, Str $new, Str $when = ' in Perl 6')
sub worryobs {
no warnings 'recursion';
my $self = shift;
die 'Required argument old omitted' unless @_;
my $old = @_ ? shift() : undef;
die 'Required argument new omitted' unless @_;
my $new = @_ ? shift() : undef;
my $when = @_ ? shift() : ' in Perl 6';
$self->worry("Unsupported use of $old;$when please use $new");
$self;
};
## method dupprefix (Str $bad)
sub dupprefix {
no warnings 'recursion';
my $self = shift;
die 'Required argument bad omitted' unless @_;
my $bad = @_ ? shift() : undef;
my $c = substr($bad,0,1);
$self->panic("Expecting a term, but found either infix $bad or redundant prefix $c\n  (to suppress this message, please use space between $c $c)");
};
## method badinfix (Str $bad)
sub badinfix {
no warnings 'recursion';
my $self = shift;
die 'Required argument bad omitted' unless @_;
my $bad = @_ ? shift() : undef;
$self->panic("Preceding context expects a term, but found infix $bad instead")};
## token term:sym<miscbad> {
sub term__S_062miscbad__PEEK { $_[0]->_AUTOLEXpeek('term__S_062miscbad', $retree) }
sub term__S_062miscbad {
no warnings 'recursion';
my $self = shift;


local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;

my $C = $self->cursor_xact("RULE term__S_062miscbad");
my $xact = $C->xact;
my $S = $C->{'_pos'};
$C->{sym} = "miscbad";
$self->_MATCHIFYr($S, "term__S_062miscbad", do {
my $C = $C;
if (($C) = (scalar(do {
}, $C))
and ($C) = ($C->_NOTBEFORE(sub {
my $C=shift;
(($C) x !!do {
$::QSIGIL })
}))
and ($C) = (scalar(do {
{
my ($bad) = $C->suppose( sub {
$C->infixish});
$::HIGHWATER = -1;
$::HIGHMESS = '';
$self->badinfix($bad->Str) if $bad;
}}, $C))
and ($C) = ($C->_NOTBEFORE(sub {
my $C=shift;
$C
}))) {
$C
} else { () }

});
}
;
1; }
