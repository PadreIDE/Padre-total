use 5.010;
use utf8;
# Emulate context vars by localizing 'our' vars living in main\n";
our $BORG;
our $CTX;
our $CURPAD;
our $CURPKG;
our $DECLARAND;
our $DELIM;
our $GOAL;
our $HIGHEXPECT;
our $INVOCANT_IS;
our $INVOCANT_OK;
our $IN_DECL;
our $IN_META;
our $IN_REDUCE;
our $LEFTSIGIL;
our $MONKEY_TYPING;
our $MULTINESS;
our $NEWPAD;
our $NEWPKG;
our $OFTYPE;
our $PKGDECL;
our $PRECLIM;
our $QSIGIL;
our $QUASIMODO;
our $SCOPE;
our $SIGNUM;
our $VAR;
our $begin_compunit;
our $endargs;
our $endsym;
our $sym;
our $zone;
our %LANG;
our %MYSTERY;

our $moreinput;

our %INSTANTIATED;
require 'mangle.pl';

package STD;
use Moose ':all' => { -prefix => "moose_" };
use Cursor; # for base class as well as DEBUG constants
moose_extends('Cursor');

no warnings 'qw', 'recursion';

my $retree;

$DB::deep = $DB::deep = 1000; # suppress used-once warning

sub BUILD {
my $self = shift;
}

use YAML::XS;

$SIG{__WARN__} = sub { die @_,"   statement started at line ", 'STD'->lineof($::LASTSTATE), "\n" } if $::DEBUG;

# STD.pm
#
# Copyright 2007-2010, Larry Wall
#
# You may copy this software under the terms of the Artistic License,
#     version 2.0 or later.


use DEBUG;
use NAME;
use Stash;
use Cursor;

our $ALL;

# =begin comment
# 
#     Contextuals used in STD
#     =======================
#     # per parse
#     my $*ACTIONS;         # class or object which defines reduce actions
#     my $*SETTINGNAME;     # name of core setting
#     my $*TMP_PREFIX;      # where to put tmp files
#     my $*ORIG;            # the original program string
#     my @*ORIG;            # same thing as individual chars
#     my @*MEMOS;           # per-position info such as ws and line number
#     my $*HIGHWATER;      # where we were last looking for things
#     my $*HIGHMESS;       # current parse failure message
#     my $*HIGHEXPECT;     # things we were looking for at the bleeding edge
#     my $*IN_PANIC;       # don't panic recursively
# 
#     # symbol table management
#     our $ALL;            # all the stashes, keyed by id
#     my $*CORE;            # the CORE scope
#     my $*SETTING;         # the SETTING scope
#     my $*GLOBAL;          # the GLOBAL scope
#     my $*PROCESS;         # the PROCESS scope
#     my $*UNIT;            # the UNIT scope
#     my $*CURPAD;      # current lexical scope
#     my $*CURPKG;          # current package scope
# 
#     my %*MYSTERY;     # names we assume may be post-declared functions
# 
#     # tree attributes, marked as propagating up (u) down (d) or up-and-down (u/d)
#     my %*LANG;            # (d) braided languages: MAIN, Q, Regex, etc
# 
#     my $*IN_DECL;     # (d) a declarator is looking for a name to declare
#     my $*SCOPE = "";      # (d) which scope declarator we're under
#     my $*MULTINESS;       # (d) which multi declarator we're under
#     my $*PKGDECL ::= "";         # (d) current package declarator
#     my $*NEWPKG;      # (u/d) new package being declared
#     my $*NEWPAD;      # (u/d) new lexpad being declared
#     my $*DECLARAND;   # (u/d) new object associated with declaration
# 
#     my $*GOAL ::= "(eof)";  # (d) which special terminator we're most wanting
#     my $*IN_REDUCE;   # (d) attempting to parse an [op] construct
#     my $*IN_META;     # (d) parsing a metaoperator like [..]
#     my $*QUASIMODO;   # (d) don't carp about quasi variables
#     my $*LEFTSIGIL;   # (u) sigil of LHS for item vs list assignment
#     my $*QSIGIL;      # (d) sigil of current interpolation
# 
#     my $*INVOCANT_OK; # (d) parsing a list that allows an invocant
#     my $*INVOCANT_IS; # (u) invocant of args match
# 
#     my $*BORG;            # (u/d) who to blame if we're missing a block
# 
# =end comment

# =begin notes
# 
#     Some rules are named by syntactic category plus an additional symbol
#     specified in adverbial form, either in bare :name form or in :sym<name>
#     form.  (It does not matter which form you use for identifier symbols,
#     except that to specify a symbol "sym" you must use the :sym<sym> form
#     of adverb.)  If you use the <sym> rule within the rule, it will parse the
#     symbol at that point.  At the final reduction point of a rule, if $sym
#     has been set, that is used as the final symbol name for the rule.  This
#     need not match the symbol specified as part the rule name; that is just
#     for disambiguating the name.  However, if no $sym is set, the original
#     symbol will be used by default.
# 
#     Note that some of these rules are written strangely because we're
#     still bootstrapping via a preprocessor, gimme5.  For instance,
#     blocks that contain nested braces are delimited by double braces
#     so that the preprocessor does not need to parse Perl 6 code.
# 
#     This grammar relies on transitive longest-token semantics, though
#     initially we made a feeble attempt to order rules so a procedural
#     interpretation of alternation could usually produce a correct parse.
#     (This is becoming less true over time.)
# 
# =end notes

## method TOP ($STOP = '')
sub TOP {
my $self = shift;
my $STOP = shift() // '';


my $lang = $self->cursor_fresh( 'STD::P6' );

if ($STOP) {
local $::GOAL = $STOP;
$lang->unitstop($STOP)->comp_unit;
}
else {
$lang->comp_unit;
}
}

##############
# Precedence #
##############

# The internal precedence levels are *not* part of the public interface.
# The current values are mere implementation; they may change at any time.
# Users should specify precedence only in relation to existing levels.

our %term            = ('dba' => ('term')            , 'prec' => 'z=');
our %methodcall      = ('dba' => ('methodcall')      , 'prec' => 'y=', 'assoc' => 'unary', 'uassoc' => 'left', 'fiddly' => 1);
our %autoincrement   = ('dba' => ('autoincrement')   , 'prec' => 'x=', 'assoc' => 'unary', 'uassoc' => 'non');
our %exponentiation  = ('dba' => ('exponentiation')  , 'prec' => 'w=', 'assoc' => 'right');
our %symbolic_unary  = ('dba' => ('symbolic unary')  , 'prec' => 'v=', 'assoc' => 'unary', 'uassoc' => 'left');
our %multiplicative  = ('dba' => ('multiplicative')  , 'prec' => 'u=', 'assoc' => 'left');
our %additive        = ('dba' => ('additive')        , 'prec' => 't=', 'assoc' => 'left');
our %replication     = ('dba' => ('replication')     , 'prec' => 's=', 'assoc' => 'left');
our %concatenation   = ('dba' => ('concatenation')   , 'prec' => 'r=', 'assoc' => 'list');
our %junctive_and    = ('dba' => ('junctive and')    , 'prec' => 'q=', 'assoc' => 'list');
our %junctive_or     = ('dba' => ('junctive or')     , 'prec' => 'p=', 'assoc' => 'list');
our %named_unary     = ('dba' => ('named unary')     , 'prec' => 'o=', 'assoc' => 'unary', 'uassoc' => 'left');
our %structural      = ('dba' => ('structural infix'), 'prec' => 'n=', 'assoc' => 'non', 'diffy' => 1);
our %chaining        = ('dba' => ('chaining')        , 'prec' => 'm=', 'assoc' => 'chain', 'diffy' => 1, 'iffy' => 1);
our %tight_and       = ('dba' => ('tight and')       , 'prec' => 'l=', 'assoc' => 'list');
our %tight_or        = ('dba' => ('tight or')        , 'prec' => 'k=', 'assoc' => 'list');
our %conditional     = ('dba' => ('conditional')     , 'prec' => 'j=', 'assoc' => 'right', 'fiddly' => 1);
our %item_assignment = ('dba' => ('item assignment') , 'prec' => 'i=', 'assoc' => 'right');
our %list_assignment = ('dba' => ('list assignment') , 'prec' => 'i=', 'assoc' => 'right', 'sub' => 'e=', 'fiddly' => 1);
our %loose_unary     = ('dba' => ('loose unary')     , 'prec' => 'h=', 'assoc' => 'unary', 'uassoc' => 'left');
our %comma           = ('dba' => ('comma')           , 'prec' => 'g=', 'assoc' => 'list', 'nextterm' => 'nulltermish', 'fiddly' => 1);
our %list_infix      = ('dba' => ('list infix')      , 'prec' => 'f=', 'assoc' => 'list');
our %list_prefix     = ('dba' => ('list prefix')     , 'prec' => 'e=', 'assoc' => 'unary', 'uassoc' => 'left');
our %loose_and       = ('dba' => ('loose and')       , 'prec' => 'd=', 'assoc' => 'list');
our %loose_or        = ('dba' => ('loose or')        , 'prec' => 'c=', 'assoc' => 'list');
our %sequencer       = ('dba' => ('sequencer')       , 'prec' => 'b=', 'assoc' => 'list', 'nextterm' => 'statement', 'fiddly' => 1);
our %LOOSEST         = ('dba' => ('LOOSEST')         , 'prec' => 'a=!');
our %terminator      = ('dba' => ('terminator')      , 'prec' => 'a=', 'assoc' => 'list');

# "epsilon" tighter than terminator
#constant $LOOSEST = %LOOSEST<prec>;
my $LOOSEST = "a=!"; # XXX preceding line is busted
my $item_assignment_prec = 'i=';
my $methodcall_prec = 'y=';

##############
# Categories #
##############

# Categories are designed to be easily extensible in derived grammars
# by merely adding more rules in the same category.  The rules within
# a given category start with the category name followed by a differentiating
# adverbial qualifier to serve (along with the category) as the longer name.

# The endsym context, if specified, says what to implicitly check for in each
# rule right after the initial <sym>.  Normally this is used to make sure
# there's appropriate whitespace.  # Note that endsym isn't called if <sym>
# isn't called.

local $::endsym = "null";
local $::endargs = -1;

#proto token category { <...> }
sub category__PEEK { $_[0]->_AUTOLEXpeek('category:*',$retree); }
sub category {
my $self = shift;
my $subs;

local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;

my $C = $self->cursor_xact('RULE category');
my $S = $C->{'_pos'};

my @result = do {
my $trystate;
my ($tag, $try);
my @try;
my $relex;
my $x;
if (my $fate = $C->{'_fate'}) {
if ($fate->[1] eq 'category') {
$C->deb("Fate passed to category: ", ::fatestr($fate)) if $::DEBUG & DEBUG::fates;
($C->{'_fate'}, $tag, $try) = @$fate;
@try = ($try);
$x = 'ALT category';
}
else {
$x = 'ALTLTM category';
}
}
else {
$x = 'ALTLTM category';
}
my $C = $C->cursor_xact($x);
my $xact = $C->xact;

my @gather = ();
for (;;) {
if (not @try) {
$relex //= $C->cursor_fate('STD', 'category:*', $retree);
@try = $relex->($C, $trystate);
}
last unless @try;
$try = shift(@try) // next;

if (ref $try eq 'ARRAY') {
($C->{'_fate'}, $tag, $try) = @$try;	# next candidate fate
}

$C->deb("category trying $tag $try") if $::DEBUG & DEBUG::try_processing;
push @gather, $C->$try(@_);
last if $xact->[-2];  # committed?
last if @gather;
}
$self->_MATCHIFYr($S, "category", @gather);
};
@result;
}


## token category__S_000category (:$*sym = 'category')
##      token category:category { <sym> }

sub category__S_000category__PEEK { $_[0]->_AUTOLEXpeek('category__S_000category',$retree) }
sub category__S_000category {
no warnings 'recursion';
my $self = shift;
local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;
my %args = @_;
local $::sym = $args{sym} // 'category';


my $C = $self->cursor_xact("RULE category__S_000category");
my $xact = $C->xact;
my $S = $C->{'_pos'};
$C->{'sym'} = ref $sym ? join(' ', @$sym) : $sym;

$self->_MATCHIFYr($S, "category__S_000category", 
$C->_PATTERN(qr/\Gcategory/)
);
}

## token category__S_001sigil (:$*sym = 'sigil')
##      token category:sigil { <sym> }

sub category__S_001sigil__PEEK { $_[0]->_AUTOLEXpeek('category__S_001sigil',$retree) }
sub category__S_001sigil {
no warnings 'recursion';
my $self = shift;
local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;
my %args = @_;
local $::sym = $args{sym} // 'sigil';


my $C = $self->cursor_xact("RULE category__S_001sigil");
my $xact = $C->xact;
my $S = $C->{'_pos'};
$C->{'sym'} = ref $sym ? join(' ', @$sym) : $sym;

$self->_MATCHIFYr($S, "category__S_001sigil", 
$C->_PATTERN(qr/\Gsigil/)
);
}
#proto token sigil { <...> }
sub sigil__PEEK { $_[0]->_AUTOLEXpeek('sigil:*',$retree); }
sub sigil {
my $self = shift;
my $subs;

local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;

my $C = $self->cursor_xact('RULE sigil');
my $S = $C->{'_pos'};

my @result = do {
my $trystate;
my ($tag, $try);
my @try;
my $relex;
my $x;
if (my $fate = $C->{'_fate'}) {
if ($fate->[1] eq 'sigil') {
$C->deb("Fate passed to sigil: ", ::fatestr($fate)) if $::DEBUG & DEBUG::fates;
($C->{'_fate'}, $tag, $try) = @$fate;
@try = ($try);
$x = 'ALT sigil';
}
else {
$x = 'ALTLTM sigil';
}
}
else {
$x = 'ALTLTM sigil';
}
my $C = $C->cursor_xact($x);
my $xact = $C->xact;

my @gather = ();
for (;;) {
if (not @try) {
$relex //= $C->cursor_fate('STD', 'sigil:*', $retree);
@try = $relex->($C, $trystate);
}
last unless @try;
$try = shift(@try) // next;

if (ref $try eq 'ARRAY') {
($C->{'_fate'}, $tag, $try) = @$try;	# next candidate fate
}

$C->deb("sigil trying $tag $try") if $::DEBUG & DEBUG::try_processing;
push @gather, $C->$try(@_);
last if $xact->[-2];  # committed?
last if @gather;
}
$self->_MATCHIFYr($S, "sigil", @gather);
};
@result;
}


## token category__S_002twigil (:$*sym = 'twigil')
##      token category:twigil { <sym> }

sub category__S_002twigil__PEEK { $_[0]->_AUTOLEXpeek('category__S_002twigil',$retree) }
sub category__S_002twigil {
no warnings 'recursion';
my $self = shift;
local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;
my %args = @_;
local $::sym = $args{sym} // 'twigil';


my $C = $self->cursor_xact("RULE category__S_002twigil");
my $xact = $C->xact;
my $S = $C->{'_pos'};
$C->{'sym'} = ref $sym ? join(' ', @$sym) : $sym;

$self->_MATCHIFYr($S, "category__S_002twigil", 
$C->_PATTERN(qr/\Gtwigil/)
);
}
#proto token twigil (:$*endsym = 'begid') { <...> }
sub twigil__PEEK { $_[0]->_AUTOLEXpeek('twigil:*',$retree); }
sub twigil {
my $self = shift;
my $subs;

local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;

my $C = $self->cursor_xact('RULE twigil');
my $S = $C->{'_pos'};

my @result = do {
my $trystate;
my ($tag, $try);
my @try;
my $relex;
my $x;
if (my $fate = $C->{'_fate'}) {
if ($fate->[1] eq 'twigil') {
$C->deb("Fate passed to twigil: ", ::fatestr($fate)) if $::DEBUG & DEBUG::fates;
($C->{'_fate'}, $tag, $try) = @$fate;
@try = ($try);
$x = 'ALT twigil';
}
else {
$x = 'ALTLTM twigil';
}
}
else {
$x = 'ALTLTM twigil';
}
my $C = $C->cursor_xact($x);
my $xact = $C->xact;

my @gather = ();
for (;;) {
if (not @try) {
$relex //= $C->cursor_fate('STD', 'twigil:*', $retree);
@try = $relex->($C, $trystate);
}
last unless @try;
$try = shift(@try) // next;

if (ref $try eq 'ARRAY') {
($C->{'_fate'}, $tag, $try) = @$try;	# next candidate fate
}

$C->deb("twigil trying $tag $try") if $::DEBUG & DEBUG::try_processing;
push @gather, $C->$try(@_);
last if $xact->[-2];  # committed?
last if @gather;
}
$self->_MATCHIFYr($S, "twigil", @gather);
};
@result;
}


## token category__S_003special_variable (:$*sym = 'special_variable')
##      token category:special_variable { <sym> }

sub category__S_003special_variable__PEEK { $_[0]->_AUTOLEXpeek('category__S_003special_variable',$retree) }
sub category__S_003special_variable {
no warnings 'recursion';
my $self = shift;
local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;
my %args = @_;
local $::sym = $args{sym} // 'special_variable';


my $C = $self->cursor_xact("RULE category__S_003special_variable");
my $xact = $C->xact;
my $S = $C->{'_pos'};
$C->{'sym'} = ref $sym ? join(' ', @$sym) : $sym;

$self->_MATCHIFYr($S, "category__S_003special_variable", 
$C->_PATTERN(qr/\Gspecial_variable/)
);
}
#proto token special_variable { <...> }
sub special_variable__PEEK { $_[0]->_AUTOLEXpeek('special_variable:*',$retree); }
sub special_variable {
my $self = shift;
my $subs;

local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;

my $C = $self->cursor_xact('RULE special_variable');
my $S = $C->{'_pos'};

my @result = do {
my $trystate;
my ($tag, $try);
my @try;
my $relex;
my $x;
if (my $fate = $C->{'_fate'}) {
if ($fate->[1] eq 'special_variable') {
$C->deb("Fate passed to special_variable: ", ::fatestr($fate)) if $::DEBUG & DEBUG::fates;
($C->{'_fate'}, $tag, $try) = @$fate;
@try = ($try);
$x = 'ALT special_variable';
}
else {
$x = 'ALTLTM special_variable';
}
}
else {
$x = 'ALTLTM special_variable';
}
my $C = $C->cursor_xact($x);
my $xact = $C->xact;

my @gather = ();
for (;;) {
if (not @try) {
$relex //= $C->cursor_fate('STD', 'special_variable:*', $retree);
@try = $relex->($C, $trystate);
}
last unless @try;
$try = shift(@try) // next;

if (ref $try eq 'ARRAY') {
($C->{'_fate'}, $tag, $try) = @$try;	# next candidate fate
}

$C->deb("special_variable trying $tag $try") if $::DEBUG & DEBUG::try_processing;
push @gather, $C->$try(@_);
last if $xact->[-2];  # committed?
last if @gather;
}
$self->_MATCHIFYr($S, "special_variable", @gather);
};
@result;
}


## token category__S_004comment (:$*sym = 'comment')
##      token category:comment { <sym> }

sub category__S_004comment__PEEK { $_[0]->_AUTOLEXpeek('category__S_004comment',$retree) }
sub category__S_004comment {
no warnings 'recursion';
my $self = shift;
local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;
my %args = @_;
local $::sym = $args{sym} // 'comment';


my $C = $self->cursor_xact("RULE category__S_004comment");
my $xact = $C->xact;
my $S = $C->{'_pos'};
$C->{'sym'} = ref $sym ? join(' ', @$sym) : $sym;

$self->_MATCHIFYr($S, "category__S_004comment", 
$C->_PATTERN(qr/\Gcomment/)
);
}
#proto token comment { <...> }
sub comment__PEEK { $_[0]->_AUTOLEXpeek('comment:*',$retree); }
sub comment {
my $self = shift;
my $subs;

local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;

my $C = $self->cursor_xact('RULE comment');
my $S = $C->{'_pos'};

my @result = do {
my $trystate;
my ($tag, $try);
my @try;
my $relex;
my $x;
if (my $fate = $C->{'_fate'}) {
if ($fate->[1] eq 'comment') {
$C->deb("Fate passed to comment: ", ::fatestr($fate)) if $::DEBUG & DEBUG::fates;
($C->{'_fate'}, $tag, $try) = @$fate;
@try = ($try);
$x = 'ALT comment';
}
else {
$x = 'ALTLTM comment';
}
}
else {
$x = 'ALTLTM comment';
}
my $C = $C->cursor_xact($x);
my $xact = $C->xact;

my @gather = ();
for (;;) {
if (not @try) {
$relex //= $C->cursor_fate('STD', 'comment:*', $retree);
@try = $relex->($C, $trystate);
}
last unless @try;
$try = shift(@try) // next;

if (ref $try eq 'ARRAY') {
($C->{'_fate'}, $tag, $try) = @$try;	# next candidate fate
}

$C->deb("comment trying $tag $try") if $::DEBUG & DEBUG::try_processing;
push @gather, $C->$try(@_);
last if $xact->[-2];  # committed?
last if @gather;
}
$self->_MATCHIFYr($S, "comment", @gather);
};
@result;
}


## token category__S_005version (:$*sym = 'version')
##      token category:version { <sym> }

sub category__S_005version__PEEK { $_[0]->_AUTOLEXpeek('category__S_005version',$retree) }
sub category__S_005version {
no warnings 'recursion';
my $self = shift;
local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;
my %args = @_;
local $::sym = $args{sym} // 'version';


my $C = $self->cursor_xact("RULE category__S_005version");
my $xact = $C->xact;
my $S = $C->{'_pos'};
$C->{'sym'} = ref $sym ? join(' ', @$sym) : $sym;

$self->_MATCHIFYr($S, "category__S_005version", 
$C->_PATTERN(qr/\Gversion/)
);
}
#proto token version { <...> }
sub version__PEEK { $_[0]->_AUTOLEXpeek('version:*',$retree); }
sub version {
my $self = shift;
my $subs;

local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;

my $C = $self->cursor_xact('RULE version');
my $S = $C->{'_pos'};

my @result = do {
my $trystate;
my ($tag, $try);
my @try;
my $relex;
my $x;
if (my $fate = $C->{'_fate'}) {
if ($fate->[1] eq 'version') {
$C->deb("Fate passed to version: ", ::fatestr($fate)) if $::DEBUG & DEBUG::fates;
($C->{'_fate'}, $tag, $try) = @$fate;
@try = ($try);
$x = 'ALT version';
}
else {
$x = 'ALTLTM version';
}
}
else {
$x = 'ALTLTM version';
}
my $C = $C->cursor_xact($x);
my $xact = $C->xact;

my @gather = ();
for (;;) {
if (not @try) {
$relex //= $C->cursor_fate('STD', 'version:*', $retree);
@try = $relex->($C, $trystate);
}
last unless @try;
$try = shift(@try) // next;

if (ref $try eq 'ARRAY') {
($C->{'_fate'}, $tag, $try) = @$try;	# next candidate fate
}

$C->deb("version trying $tag $try") if $::DEBUG & DEBUG::try_processing;
push @gather, $C->$try(@_);
last if $xact->[-2];  # committed?
last if @gather;
}
$self->_MATCHIFYr($S, "version", @gather);
};
@result;
}


## token category__S_006module_name (:$*sym = 'module_name')
##      token category:module_name { <sym> }

sub category__S_006module_name__PEEK { $_[0]->_AUTOLEXpeek('category__S_006module_name',$retree) }
sub category__S_006module_name {
no warnings 'recursion';
my $self = shift;
local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;
my %args = @_;
local $::sym = $args{sym} // 'module_name';


my $C = $self->cursor_xact("RULE category__S_006module_name");
my $xact = $C->xact;
my $S = $C->{'_pos'};
$C->{'sym'} = ref $sym ? join(' ', @$sym) : $sym;

$self->_MATCHIFYr($S, "category__S_006module_name", 
$C->_PATTERN(qr/\Gmodule_name/)
);
}
#proto token module_name { <...> }
sub module_name__PEEK { $_[0]->_AUTOLEXpeek('module_name:*',$retree); }
sub module_name {
my $self = shift;
my $subs;

local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;

my $C = $self->cursor_xact('RULE module_name');
my $S = $C->{'_pos'};

my @result = do {
my $trystate;
my ($tag, $try);
my @try;
my $relex;
my $x;
if (my $fate = $C->{'_fate'}) {
if ($fate->[1] eq 'module_name') {
$C->deb("Fate passed to module_name: ", ::fatestr($fate)) if $::DEBUG & DEBUG::fates;
($C->{'_fate'}, $tag, $try) = @$fate;
@try = ($try);
$x = 'ALT module_name';
}
else {
$x = 'ALTLTM module_name';
}
}
else {
$x = 'ALTLTM module_name';
}
my $C = $C->cursor_xact($x);
my $xact = $C->xact;

my @gather = ();
for (;;) {
if (not @try) {
$relex //= $C->cursor_fate('STD', 'module_name:*', $retree);
@try = $relex->($C, $trystate);
}
last unless @try;
$try = shift(@try) // next;

if (ref $try eq 'ARRAY') {
($C->{'_fate'}, $tag, $try) = @$try;	# next candidate fate
}

$C->deb("module_name trying $tag $try") if $::DEBUG & DEBUG::try_processing;
push @gather, $C->$try(@_);
last if $xact->[-2];  # committed?
last if @gather;
}
$self->_MATCHIFYr($S, "module_name", @gather);
};
@result;
}


## token category__S_007value (:$*sym = 'value')
##      token category:value { <sym> }

sub category__S_007value__PEEK { $_[0]->_AUTOLEXpeek('category__S_007value',$retree) }
sub category__S_007value {
no warnings 'recursion';
my $self = shift;
local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;
my %args = @_;
local $::sym = $args{sym} // 'value';


my $C = $self->cursor_xact("RULE category__S_007value");
my $xact = $C->xact;
my $S = $C->{'_pos'};
$C->{'sym'} = ref $sym ? join(' ', @$sym) : $sym;

$self->_MATCHIFYr($S, "category__S_007value", 
$C->_PATTERN(qr/\Gvalue/)
);
}
#proto token value { <...> }
sub value__PEEK { $_[0]->_AUTOLEXpeek('value:*',$retree); }
sub value {
my $self = shift;
my $subs;

local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;

my $C = $self->cursor_xact('RULE value');
my $S = $C->{'_pos'};

my @result = do {
my $trystate;
my ($tag, $try);
my @try;
my $relex;
my $x;
if (my $fate = $C->{'_fate'}) {
if ($fate->[1] eq 'value') {
$C->deb("Fate passed to value: ", ::fatestr($fate)) if $::DEBUG & DEBUG::fates;
($C->{'_fate'}, $tag, $try) = @$fate;
@try = ($try);
$x = 'ALT value';
}
else {
$x = 'ALTLTM value';
}
}
else {
$x = 'ALTLTM value';
}
my $C = $C->cursor_xact($x);
my $xact = $C->xact;

my @gather = ();
for (;;) {
if (not @try) {
$relex //= $C->cursor_fate('STD', 'value:*', $retree);
@try = $relex->($C, $trystate);
}
last unless @try;
$try = shift(@try) // next;

if (ref $try eq 'ARRAY') {
($C->{'_fate'}, $tag, $try) = @$try;	# next candidate fate
}

$C->deb("value trying $tag $try") if $::DEBUG & DEBUG::try_processing;
push @gather, $C->$try(@_);
last if $xact->[-2];  # committed?
last if @gather;
}
$self->_MATCHIFYr($S, "value", @gather);
};
@result;
}


## token category__S_008term (:$*sym = 'term')
##      token category:term { <sym> }

sub category__S_008term__PEEK { $_[0]->_AUTOLEXpeek('category__S_008term',$retree) }
sub category__S_008term {
no warnings 'recursion';
my $self = shift;
local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;
my %args = @_;
local $::sym = $args{sym} // 'term';


my $C = $self->cursor_xact("RULE category__S_008term");
my $xact = $C->xact;
my $S = $C->{'_pos'};
$C->{'sym'} = ref $sym ? join(' ', @$sym) : $sym;

$self->_MATCHIFYr($S, "category__S_008term", 
$C->_PATTERN(qr/\Gterm/)
);
}
#proto token term { <...> }
sub term__PEEK { $_[0]->_AUTOLEXpeek('term:*',$retree); }
sub term {
my $self = shift;
my $subs;

local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;

my $C = $self->cursor_xact('RULE term');
my $S = $C->{'_pos'};

my @result = do {
my $trystate;
my ($tag, $try);
my @try;
my $relex;
my $x;
if (my $fate = $C->{'_fate'}) {
if ($fate->[1] eq 'term') {
$C->deb("Fate passed to term: ", ::fatestr($fate)) if $::DEBUG & DEBUG::fates;
($C->{'_fate'}, $tag, $try) = @$fate;
@try = ($try);
$x = 'ALT term';
}
else {
$x = 'ALTLTM term';
}
}
else {
$x = 'ALTLTM term';
}
my $C = $C->cursor_xact($x);
my $xact = $C->xact;

my @gather = ();
for (;;) {
if (not @try) {
$relex //= $C->cursor_fate('STD', 'term:*', $retree);
@try = $relex->($C, $trystate);
}
last unless @try;
$try = shift(@try) // next;

if (ref $try eq 'ARRAY') {
($C->{'_fate'}, $tag, $try) = @$try;	# next candidate fate
}

$C->deb("term trying $tag $try") if $::DEBUG & DEBUG::try_processing;
push @gather, $C->$try(@_);
last if $xact->[-2];  # committed?
last if @gather;
}
$self->_MATCHIFYr($S, "term", @gather);
};
@result;
}


## token category__S_009strtonum (:$*sym = 'strtonum')
##      token category:strtonum { <sym> }

sub category__S_009strtonum__PEEK { $_[0]->_AUTOLEXpeek('category__S_009strtonum',$retree) }
sub category__S_009strtonum {
no warnings 'recursion';
my $self = shift;
local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;
my %args = @_;
local $::sym = $args{sym} // 'strtonum';


my $C = $self->cursor_xact("RULE category__S_009strtonum");
my $xact = $C->xact;
my $S = $C->{'_pos'};
$C->{'sym'} = ref $sym ? join(' ', @$sym) : $sym;

$self->_MATCHIFYr($S, "category__S_009strtonum", 
$C->_PATTERN(qr/\Gstrtonum/)
);
}
#proto token strtonum { <...> }
sub strtonum__PEEK { $_[0]->_AUTOLEXpeek('strtonum:*',$retree); }
sub strtonum {
my $self = shift;
my $subs;

local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;

my $C = $self->cursor_xact('RULE strtonum');
my $S = $C->{'_pos'};

my @result = do {
my $trystate;
my ($tag, $try);
my @try;
my $relex;
my $x;
if (my $fate = $C->{'_fate'}) {
if ($fate->[1] eq 'strtonum') {
$C->deb("Fate passed to strtonum: ", ::fatestr($fate)) if $::DEBUG & DEBUG::fates;
($C->{'_fate'}, $tag, $try) = @$fate;
@try = ($try);
$x = 'ALT strtonum';
}
else {
$x = 'ALTLTM strtonum';
}
}
else {
$x = 'ALTLTM strtonum';
}
my $C = $C->cursor_xact($x);
my $xact = $C->xact;

my @gather = ();
for (;;) {
if (not @try) {
$relex //= $C->cursor_fate('STD', 'strtonum:*', $retree);
@try = $relex->($C, $trystate);
}
last unless @try;
$try = shift(@try) // next;

if (ref $try eq 'ARRAY') {
($C->{'_fate'}, $tag, $try) = @$try;	# next candidate fate
}

$C->deb("strtonum trying $tag $try") if $::DEBUG & DEBUG::try_processing;
push @gather, $C->$try(@_);
last if $xact->[-2];  # committed?
last if @gather;
}
$self->_MATCHIFYr($S, "strtonum", @gather);
};
@result;
}


## token category__S_010quote (:$*sym = 'quote')
##      token category:quote { <sym> }

sub category__S_010quote__PEEK { $_[0]->_AUTOLEXpeek('category__S_010quote',$retree) }
sub category__S_010quote {
no warnings 'recursion';
my $self = shift;
local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;
my %args = @_;
local $::sym = $args{sym} // 'quote';


my $C = $self->cursor_xact("RULE category__S_010quote");
my $xact = $C->xact;
my $S = $C->{'_pos'};
$C->{'sym'} = ref $sym ? join(' ', @$sym) : $sym;

$self->_MATCHIFYr($S, "category__S_010quote", 
$C->_PATTERN(qr/\Gquote/)
);
}
#proto token quote () { <...> }
sub quote__PEEK { $_[0]->_AUTOLEXpeek('quote:*',$retree); }
sub quote {
my $self = shift;
my $subs;

local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;

my $C = $self->cursor_xact('RULE quote');
my $S = $C->{'_pos'};

my @result = do {
my $trystate;
my ($tag, $try);
my @try;
my $relex;
my $x;
if (my $fate = $C->{'_fate'}) {
if ($fate->[1] eq 'quote') {
$C->deb("Fate passed to quote: ", ::fatestr($fate)) if $::DEBUG & DEBUG::fates;
($C->{'_fate'}, $tag, $try) = @$fate;
@try = ($try);
$x = 'ALT quote';
}
else {
$x = 'ALTLTM quote';
}
}
else {
$x = 'ALTLTM quote';
}
my $C = $C->cursor_xact($x);
my $xact = $C->xact;

my @gather = ();
for (;;) {
if (not @try) {
$relex //= $C->cursor_fate('STD', 'quote:*', $retree);
@try = $relex->($C, $trystate);
}
last unless @try;
$try = shift(@try) // next;

if (ref $try eq 'ARRAY') {
($C->{'_fate'}, $tag, $try) = @$try;	# next candidate fate
}

$C->deb("quote trying $tag $try") if $::DEBUG & DEBUG::try_processing;
push @gather, $C->$try(@_);
last if $xact->[-2];  # committed?
last if @gather;
}
$self->_MATCHIFYr($S, "quote", @gather);
};
@result;
}


## token category__S_011prefix (:$*sym = 'prefix')
##      token category:prefix { <sym> }

sub category__S_011prefix__PEEK { $_[0]->_AUTOLEXpeek('category__S_011prefix',$retree) }
sub category__S_011prefix {
no warnings 'recursion';
my $self = shift;
local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;
my %args = @_;
local $::sym = $args{sym} // 'prefix';


my $C = $self->cursor_xact("RULE category__S_011prefix");
my $xact = $C->xact;
my $S = $C->{'_pos'};
$C->{'sym'} = ref $sym ? join(' ', @$sym) : $sym;

$self->_MATCHIFYr($S, "category__S_011prefix", 
$C->_PATTERN(qr/\Gprefix/)
);
}
#proto token prefix is unary is defequiv(%symbolic_unary) { <...> }
sub prefix__PEEK { $_[0]->_AUTOLEXpeek('prefix:*',$retree); }
sub prefix {
my $self = shift;
my $subs;

local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;

my $C = $self->cursor_xact('RULE prefix');
my $S = $C->{'_pos'};

my @result = do {
my $trystate;
my ($tag, $try);
my @try;
my $relex;
my $x;
if (my $fate = $C->{'_fate'}) {
if ($fate->[1] eq 'prefix') {
$C->deb("Fate passed to prefix: ", ::fatestr($fate)) if $::DEBUG & DEBUG::fates;
($C->{'_fate'}, $tag, $try) = @$fate;
@try = ($try);
$x = 'ALT prefix';
}
else {
$x = 'ALTLTM prefix';
}
}
else {
$x = 'ALTLTM prefix';
}
my $C = $C->cursor_xact($x);
my $xact = $C->xact;

my @gather = ();
for (;;) {
if (not @try) {
$relex //= $C->cursor_fate('STD', 'prefix:*', $retree);
@try = $relex->($C, $trystate);
}
last unless @try;
$try = shift(@try) // next;

if (ref $try eq 'ARRAY') {
($C->{'_fate'}, $tag, $try) = @$try;	# next candidate fate
}

$C->deb("prefix trying $tag $try") if $::DEBUG & DEBUG::try_processing;
push @gather, $C->$try(@_);
last if $xact->[-2];  # committed?
last if @gather;
}
$self->_MATCHIFYr($S, "prefix", @gather);
};
@result;
}


## token category__S_012infix (:$*sym = 'infix')
##      token category:infix { <sym> }

sub category__S_012infix__PEEK { $_[0]->_AUTOLEXpeek('category__S_012infix',$retree) }
sub category__S_012infix {
no warnings 'recursion';
my $self = shift;
local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;
my %args = @_;
local $::sym = $args{sym} // 'infix';


my $C = $self->cursor_xact("RULE category__S_012infix");
my $xact = $C->xact;
my $S = $C->{'_pos'};
$C->{'sym'} = ref $sym ? join(' ', @$sym) : $sym;

$self->_MATCHIFYr($S, "category__S_012infix", 
$C->_PATTERN(qr/\Ginfix/)
);
}
#proto token infix is binary is defequiv(%additive) { <...> }
sub infix__PEEK { $_[0]->_AUTOLEXpeek('infix:*',$retree); }
sub infix {
my $self = shift;
my $subs;

local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;

my $C = $self->cursor_xact('RULE infix');
my $S = $C->{'_pos'};

my @result = do {
my $trystate;
my ($tag, $try);
my @try;
my $relex;
my $x;
if (my $fate = $C->{'_fate'}) {
if ($fate->[1] eq 'infix') {
$C->deb("Fate passed to infix: ", ::fatestr($fate)) if $::DEBUG & DEBUG::fates;
($C->{'_fate'}, $tag, $try) = @$fate;
@try = ($try);
$x = 'ALT infix';
}
else {
$x = 'ALTLTM infix';
}
}
else {
$x = 'ALTLTM infix';
}
my $C = $C->cursor_xact($x);
my $xact = $C->xact;

my @gather = ();
for (;;) {
if (not @try) {
$relex //= $C->cursor_fate('STD', 'infix:*', $retree);
@try = $relex->($C, $trystate);
}
last unless @try;
$try = shift(@try) // next;

if (ref $try eq 'ARRAY') {
($C->{'_fate'}, $tag, $try) = @$try;	# next candidate fate
}

$C->deb("infix trying $tag $try") if $::DEBUG & DEBUG::try_processing;
push @gather, $C->$try(@_);
last if $xact->[-2];  # committed?
last if @gather;
}
$self->_MATCHIFYr($S, "infix", @gather);
};
@result;
}


## token category__S_013postfix (:$*sym = 'postfix')
##      token category:postfix { <sym> }

sub category__S_013postfix__PEEK { $_[0]->_AUTOLEXpeek('category__S_013postfix',$retree) }
sub category__S_013postfix {
no warnings 'recursion';
my $self = shift;
local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;
my %args = @_;
local $::sym = $args{sym} // 'postfix';


my $C = $self->cursor_xact("RULE category__S_013postfix");
my $xact = $C->xact;
my $S = $C->{'_pos'};
$C->{'sym'} = ref $sym ? join(' ', @$sym) : $sym;

$self->_MATCHIFYr($S, "category__S_013postfix", 
$C->_PATTERN(qr/\Gpostfix/)
);
}
#proto token postfix is unary is defequiv(%autoincrement) { <...> }
sub postfix__PEEK { $_[0]->_AUTOLEXpeek('postfix:*',$retree); }
sub postfix {
my $self = shift;
my $subs;

local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;

my $C = $self->cursor_xact('RULE postfix');
my $S = $C->{'_pos'};

my @result = do {
my $trystate;
my ($tag, $try);
my @try;
my $relex;
my $x;
if (my $fate = $C->{'_fate'}) {
if ($fate->[1] eq 'postfix') {
$C->deb("Fate passed to postfix: ", ::fatestr($fate)) if $::DEBUG & DEBUG::fates;
($C->{'_fate'}, $tag, $try) = @$fate;
@try = ($try);
$x = 'ALT postfix';
}
else {
$x = 'ALTLTM postfix';
}
}
else {
$x = 'ALTLTM postfix';
}
my $C = $C->cursor_xact($x);
my $xact = $C->xact;

my @gather = ();
for (;;) {
if (not @try) {
$relex //= $C->cursor_fate('STD', 'postfix:*', $retree);
@try = $relex->($C, $trystate);
}
last unless @try;
$try = shift(@try) // next;

if (ref $try eq 'ARRAY') {
($C->{'_fate'}, $tag, $try) = @$try;	# next candidate fate
}

$C->deb("postfix trying $tag $try") if $::DEBUG & DEBUG::try_processing;
push @gather, $C->$try(@_);
last if $xact->[-2];  # committed?
last if @gather;
}
$self->_MATCHIFYr($S, "postfix", @gather);
};
@result;
}


## token category__S_014dotty (:$*sym = 'dotty')
##      token category:dotty { <sym> }

sub category__S_014dotty__PEEK { $_[0]->_AUTOLEXpeek('category__S_014dotty',$retree) }
sub category__S_014dotty {
no warnings 'recursion';
my $self = shift;
local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;
my %args = @_;
local $::sym = $args{sym} // 'dotty';


my $C = $self->cursor_xact("RULE category__S_014dotty");
my $xact = $C->xact;
my $S = $C->{'_pos'};
$C->{'sym'} = ref $sym ? join(' ', @$sym) : $sym;

$self->_MATCHIFYr($S, "category__S_014dotty", 
$C->_PATTERN(qr/\Gdotty/)
);
}
#proto token dotty (:$*endsym = 'unspacey') { <...> }
sub dotty__PEEK { $_[0]->_AUTOLEXpeek('dotty:*',$retree); }
sub dotty {
my $self = shift;
my $subs;

local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;

my $C = $self->cursor_xact('RULE dotty');
my $S = $C->{'_pos'};

my @result = do {
my $trystate;
my ($tag, $try);
my @try;
my $relex;
my $x;
if (my $fate = $C->{'_fate'}) {
if ($fate->[1] eq 'dotty') {
$C->deb("Fate passed to dotty: ", ::fatestr($fate)) if $::DEBUG & DEBUG::fates;
($C->{'_fate'}, $tag, $try) = @$fate;
@try = ($try);
$x = 'ALT dotty';
}
else {
$x = 'ALTLTM dotty';
}
}
else {
$x = 'ALTLTM dotty';
}
my $C = $C->cursor_xact($x);
my $xact = $C->xact;

my @gather = ();
for (;;) {
if (not @try) {
$relex //= $C->cursor_fate('STD', 'dotty:*', $retree);
@try = $relex->($C, $trystate);
}
last unless @try;
$try = shift(@try) // next;

if (ref $try eq 'ARRAY') {
($C->{'_fate'}, $tag, $try) = @$try;	# next candidate fate
}

$C->deb("dotty trying $tag $try") if $::DEBUG & DEBUG::try_processing;
push @gather, $C->$try(@_);
last if $xact->[-2];  # committed?
last if @gather;
}
$self->_MATCHIFYr($S, "dotty", @gather);
};
@result;
}


## token category__S_015circumfix (:$*sym = 'circumfix')
##      token category:circumfix { <sym> }

sub category__S_015circumfix__PEEK { $_[0]->_AUTOLEXpeek('category__S_015circumfix',$retree) }
sub category__S_015circumfix {
no warnings 'recursion';
my $self = shift;
local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;
my %args = @_;
local $::sym = $args{sym} // 'circumfix';


my $C = $self->cursor_xact("RULE category__S_015circumfix");
my $xact = $C->xact;
my $S = $C->{'_pos'};
$C->{'sym'} = ref $sym ? join(' ', @$sym) : $sym;

$self->_MATCHIFYr($S, "category__S_015circumfix", 
$C->_PATTERN(qr/\Gcircumfix/)
);
}
#proto token circumfix { <...> }
sub circumfix__PEEK { $_[0]->_AUTOLEXpeek('circumfix:*',$retree); }
sub circumfix {
my $self = shift;
my $subs;

local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;

my $C = $self->cursor_xact('RULE circumfix');
my $S = $C->{'_pos'};

my @result = do {
my $trystate;
my ($tag, $try);
my @try;
my $relex;
my $x;
if (my $fate = $C->{'_fate'}) {
if ($fate->[1] eq 'circumfix') {
$C->deb("Fate passed to circumfix: ", ::fatestr($fate)) if $::DEBUG & DEBUG::fates;
($C->{'_fate'}, $tag, $try) = @$fate;
@try = ($try);
$x = 'ALT circumfix';
}
else {
$x = 'ALTLTM circumfix';
}
}
else {
$x = 'ALTLTM circumfix';
}
my $C = $C->cursor_xact($x);
my $xact = $C->xact;

my @gather = ();
for (;;) {
if (not @try) {
$relex //= $C->cursor_fate('STD', 'circumfix:*', $retree);
@try = $relex->($C, $trystate);
}
last unless @try;
$try = shift(@try) // next;

if (ref $try eq 'ARRAY') {
($C->{'_fate'}, $tag, $try) = @$try;	# next candidate fate
}

$C->deb("circumfix trying $tag $try") if $::DEBUG & DEBUG::try_processing;
push @gather, $C->$try(@_);
last if $xact->[-2];  # committed?
last if @gather;
}
$self->_MATCHIFYr($S, "circumfix", @gather);
};
@result;
}


## token category__S_016postcircumfix (:$*sym = 'postcircumfix')
##      token category:postcircumfix { <sym> }

sub category__S_016postcircumfix__PEEK { $_[0]->_AUTOLEXpeek('category__S_016postcircumfix',$retree) }
sub category__S_016postcircumfix {
no warnings 'recursion';
my $self = shift;
local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;
my %args = @_;
local $::sym = $args{sym} // 'postcircumfix';


my $C = $self->cursor_xact("RULE category__S_016postcircumfix");
my $xact = $C->xact;
my $S = $C->{'_pos'};
$C->{'sym'} = ref $sym ? join(' ', @$sym) : $sym;

$self->_MATCHIFYr($S, "category__S_016postcircumfix", 
$C->_PATTERN(qr/\Gpostcircumfix/)
);
}
#proto token postcircumfix is unary { <...> }  # unary as far as EXPR knows...
sub postcircumfix__PEEK { $_[0]->_AUTOLEXpeek('postcircumfix:*',$retree); }
sub postcircumfix {
my $self = shift;
my $subs;

local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;

my $C = $self->cursor_xact('RULE postcircumfix');
my $S = $C->{'_pos'};

my @result = do {
my $trystate;
my ($tag, $try);
my @try;
my $relex;
my $x;
if (my $fate = $C->{'_fate'}) {
if ($fate->[1] eq 'postcircumfix') {
$C->deb("Fate passed to postcircumfix: ", ::fatestr($fate)) if $::DEBUG & DEBUG::fates;
($C->{'_fate'}, $tag, $try) = @$fate;
@try = ($try);
$x = 'ALT postcircumfix';
}
else {
$x = 'ALTLTM postcircumfix';
}
}
else {
$x = 'ALTLTM postcircumfix';
}
my $C = $C->cursor_xact($x);
my $xact = $C->xact;

my @gather = ();
for (;;) {
if (not @try) {
$relex //= $C->cursor_fate('STD', 'postcircumfix:*', $retree);
@try = $relex->($C, $trystate);
}
last unless @try;
$try = shift(@try) // next;

if (ref $try eq 'ARRAY') {
($C->{'_fate'}, $tag, $try) = @$try;	# next candidate fate
}

$C->deb("postcircumfix trying $tag $try") if $::DEBUG & DEBUG::try_processing;
push @gather, $C->$try(@_);
last if $xact->[-2];  # committed?
last if @gather;
}
$self->_MATCHIFYr($S, "postcircumfix", @gather);
};
@result;
}


## token category__S_017quote_mod (:$*sym = 'quote_mod')
##      token category:quote_mod { <sym> }

sub category__S_017quote_mod__PEEK { $_[0]->_AUTOLEXpeek('category__S_017quote_mod',$retree) }
sub category__S_017quote_mod {
no warnings 'recursion';
my $self = shift;
local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;
my %args = @_;
local $::sym = $args{sym} // 'quote_mod';


my $C = $self->cursor_xact("RULE category__S_017quote_mod");
my $xact = $C->xact;
my $S = $C->{'_pos'};
$C->{'sym'} = ref $sym ? join(' ', @$sym) : $sym;

$self->_MATCHIFYr($S, "category__S_017quote_mod", 
$C->_PATTERN(qr/\Gquote_mod/)
);
}
#proto token quote_mod { <...> }
sub quote_mod__PEEK { $_[0]->_AUTOLEXpeek('quote_mod:*',$retree); }
sub quote_mod {
my $self = shift;
my $subs;

local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;

my $C = $self->cursor_xact('RULE quote_mod');
my $S = $C->{'_pos'};

my @result = do {
my $trystate;
my ($tag, $try);
my @try;
my $relex;
my $x;
if (my $fate = $C->{'_fate'}) {
if ($fate->[1] eq 'quote_mod') {
$C->deb("Fate passed to quote_mod: ", ::fatestr($fate)) if $::DEBUG & DEBUG::fates;
($C->{'_fate'}, $tag, $try) = @$fate;
@try = ($try);
$x = 'ALT quote_mod';
}
else {
$x = 'ALTLTM quote_mod';
}
}
else {
$x = 'ALTLTM quote_mod';
}
my $C = $C->cursor_xact($x);
my $xact = $C->xact;

my @gather = ();
for (;;) {
if (not @try) {
$relex //= $C->cursor_fate('STD', 'quote_mod:*', $retree);
@try = $relex->($C, $trystate);
}
last unless @try;
$try = shift(@try) // next;

if (ref $try eq 'ARRAY') {
($C->{'_fate'}, $tag, $try) = @$try;	# next candidate fate
}

$C->deb("quote_mod trying $tag $try") if $::DEBUG & DEBUG::try_processing;
push @gather, $C->$try(@_);
last if $xact->[-2];  # committed?
last if @gather;
}
$self->_MATCHIFYr($S, "quote_mod", @gather);
};
@result;
}


## token category__S_018trait_mod (:$*sym = 'trait_mod')
##      token category:trait_mod { <sym> }

sub category__S_018trait_mod__PEEK { $_[0]->_AUTOLEXpeek('category__S_018trait_mod',$retree) }
sub category__S_018trait_mod {
no warnings 'recursion';
my $self = shift;
local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;
my %args = @_;
local $::sym = $args{sym} // 'trait_mod';


my $C = $self->cursor_xact("RULE category__S_018trait_mod");
my $xact = $C->xact;
my $S = $C->{'_pos'};
$C->{'sym'} = ref $sym ? join(' ', @$sym) : $sym;

$self->_MATCHIFYr($S, "category__S_018trait_mod", 
$C->_PATTERN(qr/\Gtrait_mod/)
);
}
#proto token trait_mod (:$*endsym = 'spacey') { <...> }
sub trait_mod__PEEK { $_[0]->_AUTOLEXpeek('trait_mod:*',$retree); }
sub trait_mod {
my $self = shift;
my $subs;

local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;

my $C = $self->cursor_xact('RULE trait_mod');
my $S = $C->{'_pos'};

my @result = do {
my $trystate;
my ($tag, $try);
my @try;
my $relex;
my $x;
if (my $fate = $C->{'_fate'}) {
if ($fate->[1] eq 'trait_mod') {
$C->deb("Fate passed to trait_mod: ", ::fatestr($fate)) if $::DEBUG & DEBUG::fates;
($C->{'_fate'}, $tag, $try) = @$fate;
@try = ($try);
$x = 'ALT trait_mod';
}
else {
$x = 'ALTLTM trait_mod';
}
}
else {
$x = 'ALTLTM trait_mod';
}
my $C = $C->cursor_xact($x);
my $xact = $C->xact;

my @gather = ();
for (;;) {
if (not @try) {
$relex //= $C->cursor_fate('STD', 'trait_mod:*', $retree);
@try = $relex->($C, $trystate);
}
last unless @try;
$try = shift(@try) // next;

if (ref $try eq 'ARRAY') {
($C->{'_fate'}, $tag, $try) = @$try;	# next candidate fate
}

$C->deb("trait_mod trying $tag $try") if $::DEBUG & DEBUG::try_processing;
push @gather, $C->$try(@_);
last if $xact->[-2];  # committed?
last if @gather;
}
$self->_MATCHIFYr($S, "trait_mod", @gather);
};
@result;
}


## token category__S_019type_declarator (:$*sym = 'type_declarator')
##      token category:type_declarator { <sym> }

sub category__S_019type_declarator__PEEK { $_[0]->_AUTOLEXpeek('category__S_019type_declarator',$retree) }
sub category__S_019type_declarator {
no warnings 'recursion';
my $self = shift;
local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;
my %args = @_;
local $::sym = $args{sym} // 'type_declarator';


my $C = $self->cursor_xact("RULE category__S_019type_declarator");
my $xact = $C->xact;
my $S = $C->{'_pos'};
$C->{'sym'} = ref $sym ? join(' ', @$sym) : $sym;

$self->_MATCHIFYr($S, "category__S_019type_declarator", 
$C->_PATTERN(qr/\Gtype_declarator/)
);
}
#proto token type_declarator (:$*endsym = 'spacey') { <...> }
sub type_declarator__PEEK { $_[0]->_AUTOLEXpeek('type_declarator:*',$retree); }
sub type_declarator {
my $self = shift;
my $subs;

local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;

my $C = $self->cursor_xact('RULE type_declarator');
my $S = $C->{'_pos'};

my @result = do {
my $trystate;
my ($tag, $try);
my @try;
my $relex;
my $x;
if (my $fate = $C->{'_fate'}) {
if ($fate->[1] eq 'type_declarator') {
$C->deb("Fate passed to type_declarator: ", ::fatestr($fate)) if $::DEBUG & DEBUG::fates;
($C->{'_fate'}, $tag, $try) = @$fate;
@try = ($try);
$x = 'ALT type_declarator';
}
else {
$x = 'ALTLTM type_declarator';
}
}
else {
$x = 'ALTLTM type_declarator';
}
my $C = $C->cursor_xact($x);
my $xact = $C->xact;

my @gather = ();
for (;;) {
if (not @try) {
$relex //= $C->cursor_fate('STD', 'type_declarator:*', $retree);
@try = $relex->($C, $trystate);
}
last unless @try;
$try = shift(@try) // next;

if (ref $try eq 'ARRAY') {
($C->{'_fate'}, $tag, $try) = @$try;	# next candidate fate
}

$C->deb("type_declarator trying $tag $try") if $::DEBUG & DEBUG::try_processing;
push @gather, $C->$try(@_);
last if $xact->[-2];  # committed?
last if @gather;
}
$self->_MATCHIFYr($S, "type_declarator", @gather);
};
@result;
}


## token category__S_020scope_declarator (:$*sym = 'scope_declarator')
##      token category:scope_declarator { <sym> }

sub category__S_020scope_declarator__PEEK { $_[0]->_AUTOLEXpeek('category__S_020scope_declarator',$retree) }
sub category__S_020scope_declarator {
no warnings 'recursion';
my $self = shift;
local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;
my %args = @_;
local $::sym = $args{sym} // 'scope_declarator';


my $C = $self->cursor_xact("RULE category__S_020scope_declarator");
my $xact = $C->xact;
my $S = $C->{'_pos'};
$C->{'sym'} = ref $sym ? join(' ', @$sym) : $sym;

$self->_MATCHIFYr($S, "category__S_020scope_declarator", 
$C->_PATTERN(qr/\Gscope_declarator/)
);
}
#proto token scope_declarator (:$*endsym = 'nofun') { <...> }
sub scope_declarator__PEEK { $_[0]->_AUTOLEXpeek('scope_declarator:*',$retree); }
sub scope_declarator {
my $self = shift;
my $subs;

local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;

my $C = $self->cursor_xact('RULE scope_declarator');
my $S = $C->{'_pos'};

my @result = do {
my $trystate;
my ($tag, $try);
my @try;
my $relex;
my $x;
if (my $fate = $C->{'_fate'}) {
if ($fate->[1] eq 'scope_declarator') {
$C->deb("Fate passed to scope_declarator: ", ::fatestr($fate)) if $::DEBUG & DEBUG::fates;
($C->{'_fate'}, $tag, $try) = @$fate;
@try = ($try);
$x = 'ALT scope_declarator';
}
else {
$x = 'ALTLTM scope_declarator';
}
}
else {
$x = 'ALTLTM scope_declarator';
}
my $C = $C->cursor_xact($x);
my $xact = $C->xact;

my @gather = ();
for (;;) {
if (not @try) {
$relex //= $C->cursor_fate('STD', 'scope_declarator:*', $retree);
@try = $relex->($C, $trystate);
}
last unless @try;
$try = shift(@try) // next;

if (ref $try eq 'ARRAY') {
($C->{'_fate'}, $tag, $try) = @$try;	# next candidate fate
}

$C->deb("scope_declarator trying $tag $try") if $::DEBUG & DEBUG::try_processing;
push @gather, $C->$try(@_);
last if $xact->[-2];  # committed?
last if @gather;
}
$self->_MATCHIFYr($S, "scope_declarator", @gather);
};
@result;
}


## token category__S_021package_declarator (:$*sym = 'package_declarator')
##      token category:package_declarator { <sym> }

sub category__S_021package_declarator__PEEK { $_[0]->_AUTOLEXpeek('category__S_021package_declarator',$retree) }
sub category__S_021package_declarator {
no warnings 'recursion';
my $self = shift;
local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;
my %args = @_;
local $::sym = $args{sym} // 'package_declarator';


my $C = $self->cursor_xact("RULE category__S_021package_declarator");
my $xact = $C->xact;
my $S = $C->{'_pos'};
$C->{'sym'} = ref $sym ? join(' ', @$sym) : $sym;

$self->_MATCHIFYr($S, "category__S_021package_declarator", 
$C->_PATTERN(qr/\Gpackage_declarator/)
);
}
#proto token package_declarator (:$*endsym = 'spacey') { <...> }
sub package_declarator__PEEK { $_[0]->_AUTOLEXpeek('package_declarator:*',$retree); }
sub package_declarator {
my $self = shift;
my $subs;

local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;

my $C = $self->cursor_xact('RULE package_declarator');
my $S = $C->{'_pos'};

my @result = do {
my $trystate;
my ($tag, $try);
my @try;
my $relex;
my $x;
if (my $fate = $C->{'_fate'}) {
if ($fate->[1] eq 'package_declarator') {
$C->deb("Fate passed to package_declarator: ", ::fatestr($fate)) if $::DEBUG & DEBUG::fates;
($C->{'_fate'}, $tag, $try) = @$fate;
@try = ($try);
$x = 'ALT package_declarator';
}
else {
$x = 'ALTLTM package_declarator';
}
}
else {
$x = 'ALTLTM package_declarator';
}
my $C = $C->cursor_xact($x);
my $xact = $C->xact;

my @gather = ();
for (;;) {
if (not @try) {
$relex //= $C->cursor_fate('STD', 'package_declarator:*', $retree);
@try = $relex->($C, $trystate);
}
last unless @try;
$try = shift(@try) // next;

if (ref $try eq 'ARRAY') {
($C->{'_fate'}, $tag, $try) = @$try;	# next candidate fate
}

$C->deb("package_declarator trying $tag $try") if $::DEBUG & DEBUG::try_processing;
push @gather, $C->$try(@_);
last if $xact->[-2];  # committed?
last if @gather;
}
$self->_MATCHIFYr($S, "package_declarator", @gather);
};
@result;
}


## token category__S_022multi_declarator (:$*sym = 'multi_declarator')
##      token category:multi_declarator { <sym> }

sub category__S_022multi_declarator__PEEK { $_[0]->_AUTOLEXpeek('category__S_022multi_declarator',$retree) }
sub category__S_022multi_declarator {
no warnings 'recursion';
my $self = shift;
local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;
my %args = @_;
local $::sym = $args{sym} // 'multi_declarator';


my $C = $self->cursor_xact("RULE category__S_022multi_declarator");
my $xact = $C->xact;
my $S = $C->{'_pos'};
$C->{'sym'} = ref $sym ? join(' ', @$sym) : $sym;

$self->_MATCHIFYr($S, "category__S_022multi_declarator", 
$C->_PATTERN(qr/\Gmulti_declarator/)
);
}
#proto token multi_declarator (:$*endsym = 'spacey') { <...> }
sub multi_declarator__PEEK { $_[0]->_AUTOLEXpeek('multi_declarator:*',$retree); }
sub multi_declarator {
my $self = shift;
my $subs;

local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;

my $C = $self->cursor_xact('RULE multi_declarator');
my $S = $C->{'_pos'};

my @result = do {
my $trystate;
my ($tag, $try);
my @try;
my $relex;
my $x;
if (my $fate = $C->{'_fate'}) {
if ($fate->[1] eq 'multi_declarator') {
$C->deb("Fate passed to multi_declarator: ", ::fatestr($fate)) if $::DEBUG & DEBUG::fates;
($C->{'_fate'}, $tag, $try) = @$fate;
@try = ($try);
$x = 'ALT multi_declarator';
}
else {
$x = 'ALTLTM multi_declarator';
}
}
else {
$x = 'ALTLTM multi_declarator';
}
my $C = $C->cursor_xact($x);
my $xact = $C->xact;

my @gather = ();
for (;;) {
if (not @try) {
$relex //= $C->cursor_fate('STD', 'multi_declarator:*', $retree);
@try = $relex->($C, $trystate);
}
last unless @try;
$try = shift(@try) // next;

if (ref $try eq 'ARRAY') {
($C->{'_fate'}, $tag, $try) = @$try;	# next candidate fate
}

$C->deb("multi_declarator trying $tag $try") if $::DEBUG & DEBUG::try_processing;
push @gather, $C->$try(@_);
last if $xact->[-2];  # committed?
last if @gather;
}
$self->_MATCHIFYr($S, "multi_declarator", @gather);
};
@result;
}


## token category__S_023routine_declarator (:$*sym = 'routine_declarator')
##      token category:routine_declarator { <sym> }

sub category__S_023routine_declarator__PEEK { $_[0]->_AUTOLEXpeek('category__S_023routine_declarator',$retree) }
sub category__S_023routine_declarator {
no warnings 'recursion';
my $self = shift;
local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;
my %args = @_;
local $::sym = $args{sym} // 'routine_declarator';


my $C = $self->cursor_xact("RULE category__S_023routine_declarator");
my $xact = $C->xact;
my $S = $C->{'_pos'};
$C->{'sym'} = ref $sym ? join(' ', @$sym) : $sym;

$self->_MATCHIFYr($S, "category__S_023routine_declarator", 
$C->_PATTERN(qr/\Groutine_declarator/)
);
}
#proto token routine_declarator (:$*endsym = 'nofun') { <...> }
sub routine_declarator__PEEK { $_[0]->_AUTOLEXpeek('routine_declarator:*',$retree); }
sub routine_declarator {
my $self = shift;
my $subs;

local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;

my $C = $self->cursor_xact('RULE routine_declarator');
my $S = $C->{'_pos'};

my @result = do {
my $trystate;
my ($tag, $try);
my @try;
my $relex;
my $x;
if (my $fate = $C->{'_fate'}) {
if ($fate->[1] eq 'routine_declarator') {
$C->deb("Fate passed to routine_declarator: ", ::fatestr($fate)) if $::DEBUG & DEBUG::fates;
($C->{'_fate'}, $tag, $try) = @$fate;
@try = ($try);
$x = 'ALT routine_declarator';
}
else {
$x = 'ALTLTM routine_declarator';
}
}
else {
$x = 'ALTLTM routine_declarator';
}
my $C = $C->cursor_xact($x);
my $xact = $C->xact;

my @gather = ();
for (;;) {
if (not @try) {
$relex //= $C->cursor_fate('STD', 'routine_declarator:*', $retree);
@try = $relex->($C, $trystate);
}
last unless @try;
$try = shift(@try) // next;

if (ref $try eq 'ARRAY') {
($C->{'_fate'}, $tag, $try) = @$try;	# next candidate fate
}

$C->deb("routine_declarator trying $tag $try") if $::DEBUG & DEBUG::try_processing;
push @gather, $C->$try(@_);
last if $xact->[-2];  # committed?
last if @gather;
}
$self->_MATCHIFYr($S, "routine_declarator", @gather);
};
@result;
}


## token category__S_024regex_declarator (:$*sym = 'regex_declarator')
##      token category:regex_declarator { <sym> }

sub category__S_024regex_declarator__PEEK { $_[0]->_AUTOLEXpeek('category__S_024regex_declarator',$retree) }
sub category__S_024regex_declarator {
no warnings 'recursion';
my $self = shift;
local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;
my %args = @_;
local $::sym = $args{sym} // 'regex_declarator';


my $C = $self->cursor_xact("RULE category__S_024regex_declarator");
my $xact = $C->xact;
my $S = $C->{'_pos'};
$C->{'sym'} = ref $sym ? join(' ', @$sym) : $sym;

$self->_MATCHIFYr($S, "category__S_024regex_declarator", 
$C->_PATTERN(qr/\Gregex_declarator/)
);
}
#proto token regex_declarator (:$*endsym = 'spacey') { <...> }
sub regex_declarator__PEEK { $_[0]->_AUTOLEXpeek('regex_declarator:*',$retree); }
sub regex_declarator {
my $self = shift;
my $subs;

local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;

my $C = $self->cursor_xact('RULE regex_declarator');
my $S = $C->{'_pos'};

my @result = do {
my $trystate;
my ($tag, $try);
my @try;
my $relex;
my $x;
if (my $fate = $C->{'_fate'}) {
if ($fate->[1] eq 'regex_declarator') {
$C->deb("Fate passed to regex_declarator: ", ::fatestr($fate)) if $::DEBUG & DEBUG::fates;
($C->{'_fate'}, $tag, $try) = @$fate;
@try = ($try);
$x = 'ALT regex_declarator';
}
else {
$x = 'ALTLTM regex_declarator';
}
}
else {
$x = 'ALTLTM regex_declarator';
}
my $C = $C->cursor_xact($x);
my $xact = $C->xact;

my @gather = ();
for (;;) {
if (not @try) {
$relex //= $C->cursor_fate('STD', 'regex_declarator:*', $retree);
@try = $relex->($C, $trystate);
}
last unless @try;
$try = shift(@try) // next;

if (ref $try eq 'ARRAY') {
($C->{'_fate'}, $tag, $try) = @$try;	# next candidate fate
}

$C->deb("regex_declarator trying $tag $try") if $::DEBUG & DEBUG::try_processing;
push @gather, $C->$try(@_);
last if $xact->[-2];  # committed?
last if @gather;
}
$self->_MATCHIFYr($S, "regex_declarator", @gather);
};
@result;
}


## token category__S_025statement_prefix (:$*sym = 'statement_prefix')
##      token category:statement_prefix { <sym> }

sub category__S_025statement_prefix__PEEK { $_[0]->_AUTOLEXpeek('category__S_025statement_prefix',$retree) }
sub category__S_025statement_prefix {
no warnings 'recursion';
my $self = shift;
local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;
my %args = @_;
local $::sym = $args{sym} // 'statement_prefix';


my $C = $self->cursor_xact("RULE category__S_025statement_prefix");
my $xact = $C->xact;
my $S = $C->{'_pos'};
$C->{'sym'} = ref $sym ? join(' ', @$sym) : $sym;

$self->_MATCHIFYr($S, "category__S_025statement_prefix", 
$C->_PATTERN(qr/\Gstatement_prefix/)
);
}
#proto rule  statement_prefix () { <...> }
sub statement_prefix__PEEK { $_[0]->_AUTOLEXpeek('statement_prefix:*',$retree); }
sub statement_prefix {
my $self = shift;
my $subs;

local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;

my $C = $self->cursor_xact('RULE statement_prefix');
my $S = $C->{'_pos'};

my @result = do {
my $trystate;
my ($tag, $try);
my @try;
my $relex;
my $x;
if (my $fate = $C->{'_fate'}) {
if ($fate->[1] eq 'statement_prefix') {
$C->deb("Fate passed to statement_prefix: ", ::fatestr($fate)) if $::DEBUG & DEBUG::fates;
($C->{'_fate'}, $tag, $try) = @$fate;
@try = ($try);
$x = 'ALT statement_prefix';
}
else {
$x = 'ALTLTM statement_prefix';
}
}
else {
$x = 'ALTLTM statement_prefix';
}
my $C = $C->cursor_xact($x);
my $xact = $C->xact;

my @gather = ();
for (;;) {
if (not @try) {
$relex //= $C->cursor_fate('STD', 'statement_prefix:*', $retree);
@try = $relex->($C, $trystate);
}
last unless @try;
$try = shift(@try) // next;

if (ref $try eq 'ARRAY') {
($C->{'_fate'}, $tag, $try) = @$try;	# next candidate fate
}

$C->deb("statement_prefix trying $tag $try") if $::DEBUG & DEBUG::try_processing;
push @gather, $C->$try(@_);
last if $xact->[-2];  # committed?
last if @gather;
}
$self->_MATCHIFYr($S, "statement_prefix", @gather);
};
@result;
}


## token category__S_026statement_control (:$*sym = 'statement_control')
##      token category:statement_control { <sym> }

sub category__S_026statement_control__PEEK { $_[0]->_AUTOLEXpeek('category__S_026statement_control',$retree) }
sub category__S_026statement_control {
no warnings 'recursion';
my $self = shift;
local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;
my %args = @_;
local $::sym = $args{sym} // 'statement_control';


my $C = $self->cursor_xact("RULE category__S_026statement_control");
my $xact = $C->xact;
my $S = $C->{'_pos'};
$C->{'sym'} = ref $sym ? join(' ', @$sym) : $sym;

$self->_MATCHIFYr($S, "category__S_026statement_control", 
$C->_PATTERN(qr/\Gstatement_control/)
);
}
#proto rule  statement_control (:$*endsym = 'spacey') { <...> }
sub statement_control__PEEK { $_[0]->_AUTOLEXpeek('statement_control:*',$retree); }
sub statement_control {
my $self = shift;
my $subs;

local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;

my $C = $self->cursor_xact('RULE statement_control');
my $S = $C->{'_pos'};

my @result = do {
my $trystate;
my ($tag, $try);
my @try;
my $relex;
my $x;
if (my $fate = $C->{'_fate'}) {
if ($fate->[1] eq 'statement_control') {
$C->deb("Fate passed to statement_control: ", ::fatestr($fate)) if $::DEBUG & DEBUG::fates;
($C->{'_fate'}, $tag, $try) = @$fate;
@try = ($try);
$x = 'ALT statement_control';
}
else {
$x = 'ALTLTM statement_control';
}
}
else {
$x = 'ALTLTM statement_control';
}
my $C = $C->cursor_xact($x);
my $xact = $C->xact;

my @gather = ();
for (;;) {
if (not @try) {
$relex //= $C->cursor_fate('STD', 'statement_control:*', $retree);
@try = $relex->($C, $trystate);
}
last unless @try;
$try = shift(@try) // next;

if (ref $try eq 'ARRAY') {
($C->{'_fate'}, $tag, $try) = @$try;	# next candidate fate
}

$C->deb("statement_control trying $tag $try") if $::DEBUG & DEBUG::try_processing;
push @gather, $C->$try(@_);
last if $xact->[-2];  # committed?
last if @gather;
}
$self->_MATCHIFYr($S, "statement_control", @gather);
};
@result;
}


## token category__S_027statement_mod_cond (:$*sym = 'statement_mod_cond')
##      token category:statement_mod_cond { <sym> }

sub category__S_027statement_mod_cond__PEEK { $_[0]->_AUTOLEXpeek('category__S_027statement_mod_cond',$retree) }
sub category__S_027statement_mod_cond {
no warnings 'recursion';
my $self = shift;
local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;
my %args = @_;
local $::sym = $args{sym} // 'statement_mod_cond';


my $C = $self->cursor_xact("RULE category__S_027statement_mod_cond");
my $xact = $C->xact;
my $S = $C->{'_pos'};
$C->{'sym'} = ref $sym ? join(' ', @$sym) : $sym;

$self->_MATCHIFYr($S, "category__S_027statement_mod_cond", 
$C->_PATTERN(qr/\Gstatement_mod_cond/)
);
}
#proto rule  statement_mod_cond (:$*endsym = 'nofun') { <...> }
sub statement_mod_cond__PEEK { $_[0]->_AUTOLEXpeek('statement_mod_cond:*',$retree); }
sub statement_mod_cond {
my $self = shift;
my $subs;

local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;

my $C = $self->cursor_xact('RULE statement_mod_cond');
my $S = $C->{'_pos'};

my @result = do {
my $trystate;
my ($tag, $try);
my @try;
my $relex;
my $x;
if (my $fate = $C->{'_fate'}) {
if ($fate->[1] eq 'statement_mod_cond') {
$C->deb("Fate passed to statement_mod_cond: ", ::fatestr($fate)) if $::DEBUG & DEBUG::fates;
($C->{'_fate'}, $tag, $try) = @$fate;
@try = ($try);
$x = 'ALT statement_mod_cond';
}
else {
$x = 'ALTLTM statement_mod_cond';
}
}
else {
$x = 'ALTLTM statement_mod_cond';
}
my $C = $C->cursor_xact($x);
my $xact = $C->xact;

my @gather = ();
for (;;) {
if (not @try) {
$relex //= $C->cursor_fate('STD', 'statement_mod_cond:*', $retree);
@try = $relex->($C, $trystate);
}
last unless @try;
$try = shift(@try) // next;

if (ref $try eq 'ARRAY') {
($C->{'_fate'}, $tag, $try) = @$try;	# next candidate fate
}

$C->deb("statement_mod_cond trying $tag $try") if $::DEBUG & DEBUG::try_processing;
push @gather, $C->$try(@_);
last if $xact->[-2];  # committed?
last if @gather;
}
$self->_MATCHIFYr($S, "statement_mod_cond", @gather);
};
@result;
}


## token category__S_028statement_mod_loop (:$*sym = 'statement_mod_loop')
##      token category:statement_mod_loop { <sym> }

sub category__S_028statement_mod_loop__PEEK { $_[0]->_AUTOLEXpeek('category__S_028statement_mod_loop',$retree) }
sub category__S_028statement_mod_loop {
no warnings 'recursion';
my $self = shift;
local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;
my %args = @_;
local $::sym = $args{sym} // 'statement_mod_loop';


my $C = $self->cursor_xact("RULE category__S_028statement_mod_loop");
my $xact = $C->xact;
my $S = $C->{'_pos'};
$C->{'sym'} = ref $sym ? join(' ', @$sym) : $sym;

$self->_MATCHIFYr($S, "category__S_028statement_mod_loop", 
$C->_PATTERN(qr/\Gstatement_mod_loop/)
);
}
#proto rule  statement_mod_loop (:$*endsym = 'nofun') { <...> }
sub statement_mod_loop__PEEK { $_[0]->_AUTOLEXpeek('statement_mod_loop:*',$retree); }
sub statement_mod_loop {
my $self = shift;
my $subs;

local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;

my $C = $self->cursor_xact('RULE statement_mod_loop');
my $S = $C->{'_pos'};

my @result = do {
my $trystate;
my ($tag, $try);
my @try;
my $relex;
my $x;
if (my $fate = $C->{'_fate'}) {
if ($fate->[1] eq 'statement_mod_loop') {
$C->deb("Fate passed to statement_mod_loop: ", ::fatestr($fate)) if $::DEBUG & DEBUG::fates;
($C->{'_fate'}, $tag, $try) = @$fate;
@try = ($try);
$x = 'ALT statement_mod_loop';
}
else {
$x = 'ALTLTM statement_mod_loop';
}
}
else {
$x = 'ALTLTM statement_mod_loop';
}
my $C = $C->cursor_xact($x);
my $xact = $C->xact;

my @gather = ();
for (;;) {
if (not @try) {
$relex //= $C->cursor_fate('STD', 'statement_mod_loop:*', $retree);
@try = $relex->($C, $trystate);
}
last unless @try;
$try = shift(@try) // next;

if (ref $try eq 'ARRAY') {
($C->{'_fate'}, $tag, $try) = @$try;	# next candidate fate
}

$C->deb("statement_mod_loop trying $tag $try") if $::DEBUG & DEBUG::try_processing;
push @gather, $C->$try(@_);
last if $xact->[-2];  # committed?
last if @gather;
}
$self->_MATCHIFYr($S, "statement_mod_loop", @gather);
};
@result;
}


## token category__S_029infix_prefix_meta_operator (:$*sym = 'infix_prefix_meta_operator')
##      token category:infix_prefix_meta_operator { <sym> }

sub category__S_029infix_prefix_meta_operator__PEEK { $_[0]->_AUTOLEXpeek('category__S_029infix_prefix_meta_operator',$retree) }
sub category__S_029infix_prefix_meta_operator {
no warnings 'recursion';
my $self = shift;
local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;
my %args = @_;
local $::sym = $args{sym} // 'infix_prefix_meta_operator';


my $C = $self->cursor_xact("RULE category__S_029infix_prefix_meta_operator");
my $xact = $C->xact;
my $S = $C->{'_pos'};
$C->{'sym'} = ref $sym ? join(' ', @$sym) : $sym;

$self->_MATCHIFYr($S, "category__S_029infix_prefix_meta_operator", 
$C->_PATTERN(qr/\Ginfix_prefix_meta_operator/)
);
}
#proto token infix_prefix_meta_operator is binary { <...> }
sub infix_prefix_meta_operator__PEEK { $_[0]->_AUTOLEXpeek('infix_prefix_meta_operator:*',$retree); }
sub infix_prefix_meta_operator {
my $self = shift;
my $subs;

local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;

my $C = $self->cursor_xact('RULE infix_prefix_meta_operator');
my $S = $C->{'_pos'};

my @result = do {
my $trystate;
my ($tag, $try);
my @try;
my $relex;
my $x;
if (my $fate = $C->{'_fate'}) {
if ($fate->[1] eq 'infix_prefix_meta_operator') {
$C->deb("Fate passed to infix_prefix_meta_operator: ", ::fatestr($fate)) if $::DEBUG & DEBUG::fates;
($C->{'_fate'}, $tag, $try) = @$fate;
@try = ($try);
$x = 'ALT infix_prefix_meta_operator';
}
else {
$x = 'ALTLTM infix_prefix_meta_operator';
}
}
else {
$x = 'ALTLTM infix_prefix_meta_operator';
}
my $C = $C->cursor_xact($x);
my $xact = $C->xact;

my @gather = ();
for (;;) {
if (not @try) {
$relex //= $C->cursor_fate('STD', 'infix_prefix_meta_operator:*', $retree);
@try = $relex->($C, $trystate);
}
last unless @try;
$try = shift(@try) // next;

if (ref $try eq 'ARRAY') {
($C->{'_fate'}, $tag, $try) = @$try;	# next candidate fate
}

$C->deb("infix_prefix_meta_operator trying $tag $try") if $::DEBUG & DEBUG::try_processing;
push @gather, $C->$try(@_);
last if $xact->[-2];  # committed?
last if @gather;
}
$self->_MATCHIFYr($S, "infix_prefix_meta_operator", @gather);
};
@result;
}


## token category__S_030infix_postfix_meta_operator (:$*sym = 'infix_postfix_meta_operator')
##      token category:infix_postfix_meta_operator { <sym> }

sub category__S_030infix_postfix_meta_operator__PEEK { $_[0]->_AUTOLEXpeek('category__S_030infix_postfix_meta_operator',$retree) }
sub category__S_030infix_postfix_meta_operator {
no warnings 'recursion';
my $self = shift;
local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;
my %args = @_;
local $::sym = $args{sym} // 'infix_postfix_meta_operator';


my $C = $self->cursor_xact("RULE category__S_030infix_postfix_meta_operator");
my $xact = $C->xact;
my $S = $C->{'_pos'};
$C->{'sym'} = ref $sym ? join(' ', @$sym) : $sym;

$self->_MATCHIFYr($S, "category__S_030infix_postfix_meta_operator", 
$C->_PATTERN(qr/\Ginfix_postfix_meta_operator/)
);
}
#proto token infix_postfix_meta_operator ($op) is binary { <...> }
sub infix_postfix_meta_operator__PEEK { $_[0]->_AUTOLEXpeek('infix_postfix_meta_operator:*',$retree); }
sub infix_postfix_meta_operator {
my $self = shift;
my $subs;

local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;

my $C = $self->cursor_xact('RULE infix_postfix_meta_operator');
my $S = $C->{'_pos'};

my @result = do {
my $trystate;
my ($tag, $try);
my @try;
my $relex;
my $x;
if (my $fate = $C->{'_fate'}) {
if ($fate->[1] eq 'infix_postfix_meta_operator') {
$C->deb("Fate passed to infix_postfix_meta_operator: ", ::fatestr($fate)) if $::DEBUG & DEBUG::fates;
($C->{'_fate'}, $tag, $try) = @$fate;
@try = ($try);
$x = 'ALT infix_postfix_meta_operator';
}
else {
$x = 'ALTLTM infix_postfix_meta_operator';
}
}
else {
$x = 'ALTLTM infix_postfix_meta_operator';
}
my $C = $C->cursor_xact($x);
my $xact = $C->xact;

my @gather = ();
for (;;) {
if (not @try) {
$relex //= $C->cursor_fate('STD', 'infix_postfix_meta_operator:*', $retree);
@try = $relex->($C, $trystate);
}
last unless @try;
$try = shift(@try) // next;

if (ref $try eq 'ARRAY') {
($C->{'_fate'}, $tag, $try) = @$try;	# next candidate fate
}

$C->deb("infix_postfix_meta_operator trying $tag $try") if $::DEBUG & DEBUG::try_processing;
push @gather, $C->$try(@_);
last if $xact->[-2];  # committed?
last if @gather;
}
$self->_MATCHIFYr($S, "infix_postfix_meta_operator", @gather);
};
@result;
}


## token category__S_031infix_circumfix_meta_operator (:$*sym = 'infix_circumfix_meta_operator')
##      token category:infix_circumfix_meta_operator { <sym> }

sub category__S_031infix_circumfix_meta_operator__PEEK { $_[0]->_AUTOLEXpeek('category__S_031infix_circumfix_meta_operator',$retree) }
sub category__S_031infix_circumfix_meta_operator {
no warnings 'recursion';
my $self = shift;
local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;
my %args = @_;
local $::sym = $args{sym} // 'infix_circumfix_meta_operator';


my $C = $self->cursor_xact("RULE category__S_031infix_circumfix_meta_operator");
my $xact = $C->xact;
my $S = $C->{'_pos'};
$C->{'sym'} = ref $sym ? join(' ', @$sym) : $sym;

$self->_MATCHIFYr($S, "category__S_031infix_circumfix_meta_operator", 
$C->_PATTERN(qr/\Ginfix_circumfix_meta_operator/)
);
}
#proto token infix_circumfix_meta_operator is binary { <...> }
sub infix_circumfix_meta_operator__PEEK { $_[0]->_AUTOLEXpeek('infix_circumfix_meta_operator:*',$retree); }
sub infix_circumfix_meta_operator {
my $self = shift;
my $subs;

local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;

my $C = $self->cursor_xact('RULE infix_circumfix_meta_operator');
my $S = $C->{'_pos'};

my @result = do {
my $trystate;
my ($tag, $try);
my @try;
my $relex;
my $x;
if (my $fate = $C->{'_fate'}) {
if ($fate->[1] eq 'infix_circumfix_meta_operator') {
$C->deb("Fate passed to infix_circumfix_meta_operator: ", ::fatestr($fate)) if $::DEBUG & DEBUG::fates;
($C->{'_fate'}, $tag, $try) = @$fate;
@try = ($try);
$x = 'ALT infix_circumfix_meta_operator';
}
else {
$x = 'ALTLTM infix_circumfix_meta_operator';
}
}
else {
$x = 'ALTLTM infix_circumfix_meta_operator';
}
my $C = $C->cursor_xact($x);
my $xact = $C->xact;

my @gather = ();
for (;;) {
if (not @try) {
$relex //= $C->cursor_fate('STD', 'infix_circumfix_meta_operator:*', $retree);
@try = $relex->($C, $trystate);
}
last unless @try;
$try = shift(@try) // next;

if (ref $try eq 'ARRAY') {
($C->{'_fate'}, $tag, $try) = @$try;	# next candidate fate
}

$C->deb("infix_circumfix_meta_operator trying $tag $try") if $::DEBUG & DEBUG::try_processing;
push @gather, $C->$try(@_);
last if $xact->[-2];  # committed?
last if @gather;
}
$self->_MATCHIFYr($S, "infix_circumfix_meta_operator", @gather);
};
@result;
}


## token category__S_032postfix_prefix_meta_operator (:$*sym = 'postfix_prefix_meta_operator')
##      token category:postfix_prefix_meta_operator { <sym> }

sub category__S_032postfix_prefix_meta_operator__PEEK { $_[0]->_AUTOLEXpeek('category__S_032postfix_prefix_meta_operator',$retree) }
sub category__S_032postfix_prefix_meta_operator {
no warnings 'recursion';
my $self = shift;
local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;
my %args = @_;
local $::sym = $args{sym} // 'postfix_prefix_meta_operator';


my $C = $self->cursor_xact("RULE category__S_032postfix_prefix_meta_operator");
my $xact = $C->xact;
my $S = $C->{'_pos'};
$C->{'sym'} = ref $sym ? join(' ', @$sym) : $sym;

$self->_MATCHIFYr($S, "category__S_032postfix_prefix_meta_operator", 
$C->_PATTERN(qr/\Gpostfix_prefix_meta_operator/)
);
}
#proto token postfix_prefix_meta_operator is unary { <...> }
sub postfix_prefix_meta_operator__PEEK { $_[0]->_AUTOLEXpeek('postfix_prefix_meta_operator:*',$retree); }
sub postfix_prefix_meta_operator {
my $self = shift;
my $subs;

local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;

my $C = $self->cursor_xact('RULE postfix_prefix_meta_operator');
my $S = $C->{'_pos'};

my @result = do {
my $trystate;
my ($tag, $try);
my @try;
my $relex;
my $x;
if (my $fate = $C->{'_fate'}) {
if ($fate->[1] eq 'postfix_prefix_meta_operator') {
$C->deb("Fate passed to postfix_prefix_meta_operator: ", ::fatestr($fate)) if $::DEBUG & DEBUG::fates;
($C->{'_fate'}, $tag, $try) = @$fate;
@try = ($try);
$x = 'ALT postfix_prefix_meta_operator';
}
else {
$x = 'ALTLTM postfix_prefix_meta_operator';
}
}
else {
$x = 'ALTLTM postfix_prefix_meta_operator';
}
my $C = $C->cursor_xact($x);
my $xact = $C->xact;

my @gather = ();
for (;;) {
if (not @try) {
$relex //= $C->cursor_fate('STD', 'postfix_prefix_meta_operator:*', $retree);
@try = $relex->($C, $trystate);
}
last unless @try;
$try = shift(@try) // next;

if (ref $try eq 'ARRAY') {
($C->{'_fate'}, $tag, $try) = @$try;	# next candidate fate
}

$C->deb("postfix_prefix_meta_operator trying $tag $try") if $::DEBUG & DEBUG::try_processing;
push @gather, $C->$try(@_);
last if $xact->[-2];  # committed?
last if @gather;
}
$self->_MATCHIFYr($S, "postfix_prefix_meta_operator", @gather);
};
@result;
}


## token category__S_033prefix_postfix_meta_operator (:$*sym = 'prefix_postfix_meta_operator')
##      token category:prefix_postfix_meta_operator { <sym> }

sub category__S_033prefix_postfix_meta_operator__PEEK { $_[0]->_AUTOLEXpeek('category__S_033prefix_postfix_meta_operator',$retree) }
sub category__S_033prefix_postfix_meta_operator {
no warnings 'recursion';
my $self = shift;
local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;
my %args = @_;
local $::sym = $args{sym} // 'prefix_postfix_meta_operator';


my $C = $self->cursor_xact("RULE category__S_033prefix_postfix_meta_operator");
my $xact = $C->xact;
my $S = $C->{'_pos'};
$C->{'sym'} = ref $sym ? join(' ', @$sym) : $sym;

$self->_MATCHIFYr($S, "category__S_033prefix_postfix_meta_operator", 
$C->_PATTERN(qr/\Gprefix_postfix_meta_operator/)
);
}
#proto token prefix_postfix_meta_operator is unary { <...> }
sub prefix_postfix_meta_operator__PEEK { $_[0]->_AUTOLEXpeek('prefix_postfix_meta_operator:*',$retree); }
sub prefix_postfix_meta_operator {
my $self = shift;
my $subs;

local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;

my $C = $self->cursor_xact('RULE prefix_postfix_meta_operator');
my $S = $C->{'_pos'};

my @result = do {
my $trystate;
my ($tag, $try);
my @try;
my $relex;
my $x;
if (my $fate = $C->{'_fate'}) {
if ($fate->[1] eq 'prefix_postfix_meta_operator') {
$C->deb("Fate passed to prefix_postfix_meta_operator: ", ::fatestr($fate)) if $::DEBUG & DEBUG::fates;
($C->{'_fate'}, $tag, $try) = @$fate;
@try = ($try);
$x = 'ALT prefix_postfix_meta_operator';
}
else {
$x = 'ALTLTM prefix_postfix_meta_operator';
}
}
else {
$x = 'ALTLTM prefix_postfix_meta_operator';
}
my $C = $C->cursor_xact($x);
my $xact = $C->xact;

my @gather = ();
for (;;) {
if (not @try) {
$relex //= $C->cursor_fate('STD', 'prefix_postfix_meta_operator:*', $retree);
@try = $relex->($C, $trystate);
}
last unless @try;
$try = shift(@try) // next;

if (ref $try eq 'ARRAY') {
($C->{'_fate'}, $tag, $try) = @$try;	# next candidate fate
}

$C->deb("prefix_postfix_meta_operator trying $tag $try") if $::DEBUG & DEBUG::try_processing;
push @gather, $C->$try(@_);
last if $xact->[-2];  # committed?
last if @gather;
}
$self->_MATCHIFYr($S, "prefix_postfix_meta_operator", @gather);
};
@result;
}


## token category__S_034prefix_circumfix_meta_operator (:$*sym = 'prefix_circumfix_meta_operator')
##      token category:prefix_circumfix_meta_operator { <sym> }

sub category__S_034prefix_circumfix_meta_operator__PEEK { $_[0]->_AUTOLEXpeek('category__S_034prefix_circumfix_meta_operator',$retree) }
sub category__S_034prefix_circumfix_meta_operator {
no warnings 'recursion';
my $self = shift;
local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;
my %args = @_;
local $::sym = $args{sym} // 'prefix_circumfix_meta_operator';


my $C = $self->cursor_xact("RULE category__S_034prefix_circumfix_meta_operator");
my $xact = $C->xact;
my $S = $C->{'_pos'};
$C->{'sym'} = ref $sym ? join(' ', @$sym) : $sym;

$self->_MATCHIFYr($S, "category__S_034prefix_circumfix_meta_operator", 
$C->_PATTERN(qr/\Gprefix_circumfix_meta_operator/)
);
}
#proto token prefix_circumfix_meta_operator is unary { <...> }
sub prefix_circumfix_meta_operator__PEEK { $_[0]->_AUTOLEXpeek('prefix_circumfix_meta_operator:*',$retree); }
sub prefix_circumfix_meta_operator {
my $self = shift;
my $subs;

local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;

my $C = $self->cursor_xact('RULE prefix_circumfix_meta_operator');
my $S = $C->{'_pos'};

my @result = do {
my $trystate;
my ($tag, $try);
my @try;
my $relex;
my $x;
if (my $fate = $C->{'_fate'}) {
if ($fate->[1] eq 'prefix_circumfix_meta_operator') {
$C->deb("Fate passed to prefix_circumfix_meta_operator: ", ::fatestr($fate)) if $::DEBUG & DEBUG::fates;
($C->{'_fate'}, $tag, $try) = @$fate;
@try = ($try);
$x = 'ALT prefix_circumfix_meta_operator';
}
else {
$x = 'ALTLTM prefix_circumfix_meta_operator';
}
}
else {
$x = 'ALTLTM prefix_circumfix_meta_operator';
}
my $C = $C->cursor_xact($x);
my $xact = $C->xact;

my @gather = ();
for (;;) {
if (not @try) {
$relex //= $C->cursor_fate('STD', 'prefix_circumfix_meta_operator:*', $retree);
@try = $relex->($C, $trystate);
}
last unless @try;
$try = shift(@try) // next;

if (ref $try eq 'ARRAY') {
($C->{'_fate'}, $tag, $try) = @$try;	# next candidate fate
}

$C->deb("prefix_circumfix_meta_operator trying $tag $try") if $::DEBUG & DEBUG::try_processing;
push @gather, $C->$try(@_);
last if $xact->[-2];  # committed?
last if @gather;
}
$self->_MATCHIFYr($S, "prefix_circumfix_meta_operator", @gather);
};
@result;
}


## token category__S_035terminator (:$*sym = 'terminator')
##      token category:terminator { <sym> }

sub category__S_035terminator__PEEK { $_[0]->_AUTOLEXpeek('category__S_035terminator',$retree) }
sub category__S_035terminator {
no warnings 'recursion';
my $self = shift;
local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;
my %args = @_;
local $::sym = $args{sym} // 'terminator';


my $C = $self->cursor_xact("RULE category__S_035terminator");
my $xact = $C->xact;
my $S = $C->{'_pos'};
$C->{'sym'} = ref $sym ? join(' ', @$sym) : $sym;

$self->_MATCHIFYr($S, "category__S_035terminator", 
$C->_PATTERN(qr/\Gterminator/)
);
}
#proto token terminator { <...> }
sub terminator__PEEK { $_[0]->_AUTOLEXpeek('terminator:*',$retree); }
sub terminator {
my $self = shift;
my $subs;

local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;

my $C = $self->cursor_xact('RULE terminator');
my $S = $C->{'_pos'};

my @result = do {
my $trystate;
my ($tag, $try);
my @try;
my $relex;
my $x;
if (my $fate = $C->{'_fate'}) {
if ($fate->[1] eq 'terminator') {
$C->deb("Fate passed to terminator: ", ::fatestr($fate)) if $::DEBUG & DEBUG::fates;
($C->{'_fate'}, $tag, $try) = @$fate;
@try = ($try);
$x = 'ALT terminator';
}
else {
$x = 'ALTLTM terminator';
}
}
else {
$x = 'ALTLTM terminator';
}
my $C = $C->cursor_xact($x);
my $xact = $C->xact;

my @gather = ();
for (;;) {
if (not @try) {
$relex //= $C->cursor_fate('STD', 'terminator:*', $retree);
@try = $relex->($C, $trystate);
}
last unless @try;
$try = shift(@try) // next;

if (ref $try eq 'ARRAY') {
($C->{'_fate'}, $tag, $try) = @$try;	# next candidate fate
}

$C->deb("terminator trying $tag $try") if $::DEBUG & DEBUG::try_processing;
push @gather, $C->$try(@_);
last if $xact->[-2];  # committed?
last if @gather;
}
$self->_MATCHIFYr($S, "terminator", @gather);
};
@result;
}


## token unspacey
##      token unspacey { <.unsp>? }

sub unspacey__PEEK { $_[0]->_AUTOLEXpeek('unspacey',$retree) }
sub unspacey {
no warnings 'recursion';
my $self = shift;
local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;


my $C = $self->cursor_xact("RULE unspacey");
my $xact = $C->xact;
my $S = $C->{'_pos'};

$self->_MATCHIFYr($S, "unspacey", 
$C->_OPTr(sub { my $C=shift;
$C->unsp
})
);
}
## token begid
##      token begid { <?before \w> }

sub begid__PEEK { $_[0]->_AUTOLEXpeek('begid',$retree) }
sub begid {
no warnings 'recursion';
my $self = shift;
local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;


my $C = $self->cursor_xact("RULE begid");
my $xact = $C->xact;
my $S = $C->{'_pos'};

$self->_MATCHIFYr($S, "begid", 
$C->before(sub { my $C=shift;
$C->_PATTERN(qr/\G\w/)
})
);
}
## token endid
##      token endid { <?before <-[ \- \' \w ]> > }

sub endid__PEEK { $_[0]->_AUTOLEXpeek('endid',$retree) }
sub endid {
no warnings 'recursion';
my $self = shift;
local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;


my $C = $self->cursor_xact("RULE endid");
my $xact = $C->xact;
my $S = $C->{'_pos'};

$self->_MATCHIFYr($S, "endid", 
$C->before(sub { my $C=shift;
$C->_PATTERN(qr/\G[^\-\'\w]/)
})
);
}
## token spacey
##      token spacey { <?before <[ \s \# ]> > }

sub spacey__PEEK { $_[0]->_AUTOLEXpeek('spacey',$retree) }
sub spacey {
no warnings 'recursion';
my $self = shift;
local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;


my $C = $self->cursor_xact("RULE spacey");
my $xact = $C->xact;
my $S = $C->{'_pos'};

$self->_MATCHIFYr($S, "spacey", 
$C->before(sub { my $C=shift;
$C->_PATTERN(qr/\G[\s\#]/)
})
);
}
## token nofun
##      token nofun { <!before '(' | '.(' | '\\' | '\'' | '-' | "'" | \w > }

sub nofun__PEEK { $_[0]->_AUTOLEXpeek('nofun',$retree) }
sub nofun {
no warnings 'recursion';
my $self = shift;
local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;


my $C = $self->cursor_xact("RULE nofun");
my $xact = $C->xact;
my $S = $C->{'_pos'};

$self->_MATCHIFYr($S, "nofun", 
$C->_NOTBEFORE( sub { my $C=shift;
$C->before(sub { my $C=shift;
do {
my @result = do {
my $trystate;
my ($tag, $try);
my @try;
my $relex;

my $fate;
my $x;
if ($fate = $C->{'_fate'} and $fate->[1] eq 'nofun_01') {
$C->deb("Fate passed to nofun_01: ", ::fatestr($fate)) if $::DEBUG & DEBUG::fates;
($C->{'_fate'}, $tag, $try) = @$fate;
@try = ($try);
$x = 'ALT nofun_01';    # some outer ltm is controlling us
}
else {
$x = 'ALTLTM nofun_01'; # we are top level ltm
}
my $C = $C->cursor_xact($x);
my $xact = $C->xact;

my @gather = ();
for (;;) {
if (not @try) {
$relex //= $C->cursor_fate('STD', 'nofun_01', $retree);
@try = $relex->($C, $trystate);
}
last unless @try;
$try = shift(@try) // next;

if (ref $try eq 'ARRAY') {
($C->{'_fate'}, $tag, $try) = @$try;	# next candidate fate
}

$C->deb("nofun_01 trying $tag $try") if $::DEBUG & DEBUG::try_processing;
push @gather, ((
sub { my $C=shift;
$C->_EXACT('(')
},
sub { my $C=shift;
$C->_EXACT('.(')
},
sub { my $C=shift;
$C->_EXACT('\\')
},
sub { my $C=shift;
$C->_EXACT('\'')
},
sub { my $C=shift;
$C->_EXACT('-')
},
sub { my $C=shift;
$C->_PATTERN(qr/\G'/)
},
sub { my $C=shift;
$C->_PATTERN(qr/\G\w/)
},
)[$try])->($C);
last if $xact->[-2];  # committed?
last if @gather;
}
@gather;
};
@result;
}

})
})
);
}

# Note, don't reduce on a bare sigil unless you don't want a twigil or
# you otherwise don't care what the longest token is.

## token sigil__S_036Dollar (:$*sym = <$>)
##      token sigil:sym<$>  { <sym> }

sub sigil__S_036Dollar__PEEK { $_[0]->_AUTOLEXpeek('sigil__S_036Dollar',$retree) }
sub sigil__S_036Dollar {
no warnings 'recursion';
my $self = shift;
local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;
my %args = @_;
local $::sym = $args{sym} // q($);


my $C = $self->cursor_xact("RULE sigil__S_036Dollar");
my $xact = $C->xact;
my $S = $C->{'_pos'};
$C->{'sym'} = ref $sym ? join(' ', @$sym) : $sym;

$self->_MATCHIFYr($S, "sigil__S_036Dollar", 
$C->_PATTERN(qr/\G\$/)
);
}
## token sigil__S_037At (:$*sym = <@>)
##      token sigil:sym<@>  { <sym> }

sub sigil__S_037At__PEEK { $_[0]->_AUTOLEXpeek('sigil__S_037At',$retree) }
sub sigil__S_037At {
no warnings 'recursion';
my $self = shift;
local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;
my %args = @_;
local $::sym = $args{sym} // q(@);


my $C = $self->cursor_xact("RULE sigil__S_037At");
my $xact = $C->xact;
my $S = $C->{'_pos'};
$C->{'sym'} = ref $sym ? join(' ', @$sym) : $sym;

$self->_MATCHIFYr($S, "sigil__S_037At", 
$C->_PATTERN(qr/\G\@/)
);
}
## token sigil__S_038Percent (:$*sym = <%>)
##      token sigil:sym<%>  { <sym> }

sub sigil__S_038Percent__PEEK { $_[0]->_AUTOLEXpeek('sigil__S_038Percent',$retree) }
sub sigil__S_038Percent {
no warnings 'recursion';
my $self = shift;
local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;
my %args = @_;
local $::sym = $args{sym} // q(%);


my $C = $self->cursor_xact("RULE sigil__S_038Percent");
my $xact = $C->xact;
my $S = $C->{'_pos'};
$C->{'sym'} = ref $sym ? join(' ', @$sym) : $sym;

$self->_MATCHIFYr($S, "sigil__S_038Percent", 
$C->_PATTERN(qr/\G\%/)
);
}
## token sigil__S_039Amp (:$*sym = <&>)
##      token sigil:sym<&>  { <sym> }

sub sigil__S_039Amp__PEEK { $_[0]->_AUTOLEXpeek('sigil__S_039Amp',$retree) }
sub sigil__S_039Amp {
no warnings 'recursion';
my $self = shift;
local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;
my %args = @_;
local $::sym = $args{sym} // q(&);


my $C = $self->cursor_xact("RULE sigil__S_039Amp");
my $xact = $C->xact;
my $S = $C->{'_pos'};
$C->{'sym'} = ref $sym ? join(' ', @$sym) : $sym;

$self->_MATCHIFYr($S, "sigil__S_039Amp", 
$C->_PATTERN(qr/\G\&/)
);
}

## token twigil__S_040Dot (:$*endsym = 'begid', :$*sym = <.>)
##      token twigil:sym<.> { <sym> }

sub twigil__S_040Dot__PEEK { $_[0]->_AUTOLEXpeek('twigil__S_040Dot',$retree) }
sub twigil__S_040Dot {
no warnings 'recursion';
my $self = shift;
local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;
my %args = @_;
local $::endsym = $args{endsym} // 'begid';
local $::sym = $args{sym} // q(.);


my $C = $self->cursor_xact("RULE twigil__S_040Dot");
my $xact = $C->xact;
my $S = $C->{'_pos'};
$C->{'sym'} = ref $sym ? join(' ', @$sym) : $sym;

$self->_MATCHIFYr($S, "twigil__S_040Dot", 
do {
if (my ($C) = ($C->_PATTERN(qr/\G\./))) {
$C->begid;
}
else {
();
}
}
);
}
## token twigil__S_041Bang (:$*endsym = 'begid', :$*sym = <!>)
##      token twigil:sym<!> { <sym> }

sub twigil__S_041Bang__PEEK { $_[0]->_AUTOLEXpeek('twigil__S_041Bang',$retree) }
sub twigil__S_041Bang {
no warnings 'recursion';
my $self = shift;
local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;
my %args = @_;
local $::endsym = $args{endsym} // 'begid';
local $::sym = $args{sym} // q(!);


my $C = $self->cursor_xact("RULE twigil__S_041Bang");
my $xact = $C->xact;
my $S = $C->{'_pos'};
$C->{'sym'} = ref $sym ? join(' ', @$sym) : $sym;

$self->_MATCHIFYr($S, "twigil__S_041Bang", 
do {
if (my ($C) = ($C->_PATTERN(qr/\G\!/))) {
$C->begid;
}
else {
();
}
}
);
}
## token twigil__S_042Caret (:$*endsym = 'begid', :$*sym = <^>)
##      token twigil:sym<^> { <sym> }

sub twigil__S_042Caret__PEEK { $_[0]->_AUTOLEXpeek('twigil__S_042Caret',$retree) }
sub twigil__S_042Caret {
no warnings 'recursion';
my $self = shift;
local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;
my %args = @_;
local $::endsym = $args{endsym} // 'begid';
local $::sym = $args{sym} // q(^);


my $C = $self->cursor_xact("RULE twigil__S_042Caret");
my $xact = $C->xact;
my $S = $C->{'_pos'};
$C->{'sym'} = ref $sym ? join(' ', @$sym) : $sym;

$self->_MATCHIFYr($S, "twigil__S_042Caret", 
do {
if (my ($C) = ($C->_PATTERN(qr/\G\^/))) {
$C->begid;
}
else {
();
}
}
);
}
## token twigil__S_043Colon (:$*endsym = 'begid', :$*sym = <:>)
##      token twigil:sym<:> { <sym> }

sub twigil__S_043Colon__PEEK { $_[0]->_AUTOLEXpeek('twigil__S_043Colon',$retree) }
sub twigil__S_043Colon {
no warnings 'recursion';
my $self = shift;
local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;
my %args = @_;
local $::endsym = $args{endsym} // 'begid';
local $::sym = $args{sym} // q(:);


my $C = $self->cursor_xact("RULE twigil__S_043Colon");
my $xact = $C->xact;
my $S = $C->{'_pos'};
$C->{'sym'} = ref $sym ? join(' ', @$sym) : $sym;

$self->_MATCHIFYr($S, "twigil__S_043Colon", 
do {
if (my ($C) = ($C->_PATTERN(qr/\G\:/))) {
$C->begid;
}
else {
();
}
}
);
}
## token twigil__S_044Star (:$*endsym = 'begid', :$*sym = <*>)
##      token twigil:sym<*> { <sym> }

sub twigil__S_044Star__PEEK { $_[0]->_AUTOLEXpeek('twigil__S_044Star',$retree) }
sub twigil__S_044Star {
no warnings 'recursion';
my $self = shift;
local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;
my %args = @_;
local $::endsym = $args{endsym} // 'begid';
local $::sym = $args{sym} // q(*);


my $C = $self->cursor_xact("RULE twigil__S_044Star");
my $xact = $C->xact;
my $S = $C->{'_pos'};
$C->{'sym'} = ref $sym ? join(' ', @$sym) : $sym;

$self->_MATCHIFYr($S, "twigil__S_044Star", 
do {
if (my ($C) = ($C->_PATTERN(qr/\G\*/))) {
$C->begid;
}
else {
();
}
}
);
}
## token twigil__S_045Question (:$*endsym = 'begid', :$*sym = <?>)
##      token twigil:sym<?> { <sym> }

sub twigil__S_045Question__PEEK { $_[0]->_AUTOLEXpeek('twigil__S_045Question',$retree) }
sub twigil__S_045Question {
no warnings 'recursion';
my $self = shift;
local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;
my %args = @_;
local $::endsym = $args{endsym} // 'begid';
local $::sym = $args{sym} // q(?);


my $C = $self->cursor_xact("RULE twigil__S_045Question");
my $xact = $C->xact;
my $S = $C->{'_pos'};
$C->{'sym'} = ref $sym ? join(' ', @$sym) : $sym;

$self->_MATCHIFYr($S, "twigil__S_045Question", 
do {
if (my ($C) = ($C->_PATTERN(qr/\G\?/))) {
$C->begid;
}
else {
();
}
}
);
}
## token twigil__S_046Equal (:$*endsym = 'begid', :$*sym = <=>)
##      token twigil:sym<=> { <sym> }

sub twigil__S_046Equal__PEEK { $_[0]->_AUTOLEXpeek('twigil__S_046Equal',$retree) }
sub twigil__S_046Equal {
no warnings 'recursion';
my $self = shift;
local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;
my %args = @_;
local $::endsym = $args{endsym} // 'begid';
local $::sym = $args{sym} // q(=);


my $C = $self->cursor_xact("RULE twigil__S_046Equal");
my $xact = $C->xact;
my $S = $C->{'_pos'};
$C->{'sym'} = ref $sym ? join(' ', @$sym) : $sym;

$self->_MATCHIFYr($S, "twigil__S_046Equal", 
do {
if (my ($C) = ($C->_PATTERN(qr/\G\=/))) {
$C->begid;
}
else {
();
}
}
);
}
## token twigil__S_047Tilde (:$*endsym = 'begid', :$*sym = <~>)
##      token twigil:sym<~> { <sym> }

sub twigil__S_047Tilde__PEEK { $_[0]->_AUTOLEXpeek('twigil__S_047Tilde',$retree) }
sub twigil__S_047Tilde {
no warnings 'recursion';
my $self = shift;
local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;
my %args = @_;
local $::endsym = $args{endsym} // 'begid';
local $::sym = $args{sym} // q(~);


my $C = $self->cursor_xact("RULE twigil__S_047Tilde");
my $xact = $C->xact;
my $S = $C->{'_pos'};
$C->{'sym'} = ref $sym ? join(' ', @$sym) : $sym;

$self->_MATCHIFYr($S, "twigil__S_047Tilde", 
do {
if (my ($C) = ($C->_PATTERN(qr/\G\~/))) {
$C->begid;
}
else {
();
}
}
);
}

# overridden in subgrammars
## token stopper
##      token stopper { <!> }

sub stopper__PEEK { $_[0]->_AUTOLEXpeek('stopper',$retree) }
sub stopper {
no warnings 'recursion';
my $self = shift;
local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;


my $C = $self->cursor_xact("RULE stopper");
my $xact = $C->xact;
my $S = $C->{'_pos'};

$self->_MATCHIFYr($S, "stopper", 
$C->_NOTBEFORE( sub { my $C=shift;
$C
})
);
}

# hopefully we can include these tokens in any outer LTM matcher
## regex stdstopper
##      regex stdstopper {
##          :my @stub = return self if @*MEMOS[self.pos]<endstmt> :exists;
##          :dba('standard stopper')
##          [
##          | <?terminator>
##          | <?unitstopper>
##          | $                                 # unlikely, check last (normal LTM behavior)
##          ]
##          { @*MEMOS[$.pos]<endstmt> ||= 1; }
##      }

sub stdstopper__PEEK { $_[0]->_AUTOLEXpeek('stdstopper',$retree) }
sub stdstopper {
no warnings 'recursion';
my $self = shift;
local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;
my @stub = return $self if exists $::MEMOS[$self->{'_pos'}]{'endstmt'};


my $C = $self->cursor_xact("RULE stdstopper");
my $xact = $C->xact;
my $S = $C->{'_pos'};

$self->_MATCHIFY($S, "stdstopper", 
Cursor::lazymap(sub {
my $C=$_[0];
scalar(do {
$::MEMOS[$C->{'_pos'}]{'endstmt'} ||= 1; 
}, $C)
}, $C->_BRACKET(sub {
my $C=shift;
do {
my @result = do {
my $trystate;
my ($tag, $try);
my @try;
my $relex;

my $fate;
my $x;
if ($fate = $C->{'_fate'} and $fate->[1] eq 'stdstopper_01') {
$C->deb("Fate passed to stdstopper_01: ", ::fatestr($fate)) if $::DEBUG & DEBUG::fates;
($C->{'_fate'}, $tag, $try) = @$fate;
@try = ($try);
$x = 'ALT stdstopper_01';    # some outer ltm is controlling us
}
else {
$x = 'ALTLTM stdstopper_01'; # we are top level ltm
}
my $C = $C->cursor_xact($x);
my $xact = $C->xact;

my @gather = ();
for (;;) {
if (not @try) {
$relex //= $C->cursor_fate('STD', 'stdstopper_01', $retree);
@try = $relex->($C, $trystate);
}
last unless @try;
$try = shift(@try) // next;

if (ref $try eq 'ARRAY') {
($C->{'_fate'}, $tag, $try) = @$try;	# next candidate fate
}

$C->deb("stdstopper_01 trying $tag $try") if $::DEBUG & DEBUG::try_processing;
push @gather, ((
sub { my $C=shift;
$C->before( sub { my $C=shift;
$C->terminator
})
},
sub { my $C=shift;
$C->before( sub { my $C=shift;
$C->unitstopper
})
},
sub { my $C=shift;
$C->_PATTERN(qr/\G\z/)
},
)[$try])->($C);
last if $xact->[-2];  # committed?
last if @gather;
}
@gather;
};
@result;
}

}))
);
}

## token longname
##      token longname {
##          <name> <colonpair>*
##      }

sub longname__PEEK { $_[0]->_AUTOLEXpeek('longname',$retree) }
sub longname {
no warnings 'recursion';
my $self = shift;
local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;


my $C = $self->cursor_xact("RULE longname");
my $xact = $C->xact;
my $S = $C->{'_pos'};
$C->{'colonpair'} = [];

$self->_MATCHIFYr($S, "longname", 
do {
if (my ($C) = ($C->_SUBSUMEr(['name'], sub {
my $C = shift;
$C->name
}))) {
$C->_STARr(sub { my $C=shift;
$C->_SUBSUMEr(['colonpair'], sub {
my $C = shift;
$C->colonpair
})
});
}
else {
();
}
}
);
}

## token name
##      token name {
##          [
##          | <identifier> <morename>*
##          | <morename>+
##          ]
##      }

sub name__PEEK { $_[0]->_AUTOLEXpeek('name',$retree) }
sub name {
no warnings 'recursion';
my $self = shift;
local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;


my $C = $self->cursor_xact("RULE name");
my $xact = $C->xact;
my $S = $C->{'_pos'};
$C->{'morename'} = [];

$self->_MATCHIFYr($S, "name", 
$C->_BRACKETr(sub {
my $C=shift;
do {
my @result = do {
my $trystate;
my ($tag, $try);
my @try;
my $relex;

my $fate;
my $x;
if ($fate = $C->{'_fate'} and $fate->[1] eq 'name_01') {
$C->deb("Fate passed to name_01: ", ::fatestr($fate)) if $::DEBUG & DEBUG::fates;
($C->{'_fate'}, $tag, $try) = @$fate;
@try = ($try);
$x = 'ALT name_01';    # some outer ltm is controlling us
}
else {
$x = 'ALTLTM name_01'; # we are top level ltm
}
my $C = $C->cursor_xact($x);
my $xact = $C->xact;

my @gather = ();
for (;;) {
if (not @try) {
$relex //= $C->cursor_fate('STD', 'name_01', $retree);
@try = $relex->($C, $trystate);
}
last unless @try;
$try = shift(@try) // next;

if (ref $try eq 'ARRAY') {
($C->{'_fate'}, $tag, $try) = @$try;	# next candidate fate
}

$C->deb("name_01 trying $tag $try") if $::DEBUG & DEBUG::try_processing;
push @gather, ((
sub { my $C=shift;
do {
if (my ($C) = ($C->_SUBSUMEr(['identifier'], sub {
my $C = shift;
$C->identifier
}))) {
$C->_STARr(sub { my $C=shift;
$C->_SUBSUMEr(['morename'], sub {
my $C = shift;
$C->morename
})
});
}
else {
();
}
}
},
sub { my $C=shift;
$C->_PLUSr(sub { my $C=shift;
$C->_SUBSUMEr(['morename'], sub {
my $C = shift;
$C->morename
})
})
},
)[$try])->($C);
last if $xact->[-2];  # committed?
last if @gather;
}
@gather;
};
@result;
}

})
);
}

## token morename
##      token morename {
##          :my $*QSIGIL ::= '';
##          '::'
##          [
##          ||  <?before '(' | <alpha> >
##              [
##              | <identifier>
##              | :dba('indirect name') '(' ~ ')' <EXPR>
##              ]
##          || <?before '::'> <.panic: "Name component may not be null">
##          ]?
##      }

sub morename__PEEK { $_[0]->_AUTOLEXpeek('morename',$retree) }
sub morename {
no warnings 'recursion';
my $self = shift;
local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;
local $::QSIGIL = '';


my $C = $self->cursor_xact("RULE morename");
my $xact = $C->xact;
my $S = $C->{'_pos'};
$C->{'identifier'} = [];
$C->{'EXPR'} = [];

$self->_MATCHIFYr($S, "morename", 
do {
if (my ($C) = ($C->_EXACT('::'))) {
$C->_OPTr(sub { my $C=shift;
$C->_BRACKETr(sub {
my $C=shift;
do {
my $C = $C->cursor_xact('ALT ||');
my $xact = $C->xact;
my @gather;
do {
push @gather, do {
if (my ($C) = ($C->before(sub { my $C=shift;
do {
my @result = do {
my $trystate;
my ($tag, $try);
my @try;
my $relex;

my $fate;
my $x;
if ($fate = $C->{'_fate'} and $fate->[1] eq 'morename_02') {
$C->deb("Fate passed to morename_02: ", ::fatestr($fate)) if $::DEBUG & DEBUG::fates;
($C->{'_fate'}, $tag, $try) = @$fate;
@try = ($try);
$x = 'ALT morename_02';    # some outer ltm is controlling us
}
else {
$x = 'ALTLTM morename_02'; # we are top level ltm
}
my $C = $C->cursor_xact($x);
my $xact = $C->xact;

my @gather = ();
for (;;) {
if (not @try) {
$relex //= $C->cursor_fate('STD', 'morename_02', $retree);
@try = $relex->($C, $trystate);
}
last unless @try;
$try = shift(@try) // next;

if (ref $try eq 'ARRAY') {
($C->{'_fate'}, $tag, $try) = @$try;	# next candidate fate
}

$C->deb("morename_02 trying $tag $try") if $::DEBUG & DEBUG::try_processing;
push @gather, ((
sub { my $C=shift;
$C->_EXACT('(')
},
sub { my $C=shift;
$C->_PATTERN(qr/\G[_[:alpha:]]/)
},
)[$try])->($C);
last if $xact->[-2];  # committed?
last if @gather;
}
@gather;
};
@result;
}

}))) {
$C->_BRACKETr(sub {
my $C=shift;
do {
my @result = do {
my $trystate;
my ($tag, $try);
my @try;
my $relex;

my $fate;
my $x;
if ($fate = $C->{'_fate'} and $fate->[1] eq 'morename_03') {
$C->deb("Fate passed to morename_03: ", ::fatestr($fate)) if $::DEBUG & DEBUG::fates;
($C->{'_fate'}, $tag, $try) = @$fate;
@try = ($try);
$x = 'ALT morename_03';    # some outer ltm is controlling us
}
else {
$x = 'ALTLTM morename_03'; # we are top level ltm
}
my $C = $C->cursor_xact($x);
my $xact = $C->xact;

my @gather = ();
for (;;) {
if (not @try) {
$relex //= $C->cursor_fate('STD', 'morename_03', $retree);
@try = $relex->($C, $trystate);
}
last unless @try;
$try = shift(@try) // next;

if (ref $try eq 'ARRAY') {
($C->{'_fate'}, $tag, $try) = @$try;	# next candidate fate
}

$C->deb("morename_03 trying $tag $try") if $::DEBUG & DEBUG::try_processing;
push @gather, ((
sub { my $C=shift;
$C->_SUBSUMEr(['identifier'], sub {
my $C = shift;
$C->identifier
})
},
sub { my $C=shift;
do {
if (my ($C) = ($C->_EXACT('('))) {
do {
if (my ($C) = (((local $::GOAL = ')' ), $C)[-1])) {
do {
if (my ($C) = ($C->_SUBSUMEr(['EXPR'], sub {
my $C = shift;
$C->EXPR
}))) {
$C->_BRACKETr(sub {
my $C=shift;
do {
my $C = $C->cursor_xact('ALT ||');
my $xact = $C->xact;
my @gather;
do {
push @gather, $C->_EXACT(')')
}
or $xact->[-2] or
do {
push @gather, $C->FAILGOAL(')' , 'indirect name')};
@gather;
}
});
}
else {
();
}
};
}
else {
();
}
};
}
else {
();
}
}
},
)[$try])->($C);
last if $xact->[-2];  # committed?
last if @gather;
}
@gather;
};
@result;
}

});
}
else {
();
}
}
}
or $xact->[-2] or
do {
push @gather, do {
if (my ($C) = ($C->before(sub { my $C=shift;
$C->_EXACT('::')
}))) {
$C->panic("Name component may not be null");
}
else {
();
}
}};
@gather;
}
})
});
}
else {
();
}
}
);
}

##############################
# Quote primitives           #
##############################

# XXX should eventually be derived from current Unicode tables.
our %open2close = (
"\x{0028}" => "\x{0029}",
"\x{003C}" => "\x{003E}",
"\x{005B}" => "\x{005D}",
"\x{007B}" => "\x{007D}",
"\x{00AB}" => "\x{00BB}",
"\x{0F3A}" => "\x{0F3B}",
"\x{0F3C}" => "\x{0F3D}",
"\x{169B}" => "\x{169C}",
"\x{2018}" => "\x{2019}",
"\x{201A}" => "\x{2019}",
"\x{201B}" => "\x{2019}",
"\x{201C}" => "\x{201D}",
"\x{201E}" => "\x{201D}",
"\x{201F}" => "\x{201D}",
"\x{2039}" => "\x{203A}",
"\x{2045}" => "\x{2046}",
"\x{207D}" => "\x{207E}",
"\x{208D}" => "\x{208E}",
"\x{2208}" => "\x{220B}",
"\x{2209}" => "\x{220C}",
"\x{220A}" => "\x{220D}",
"\x{2215}" => "\x{29F5}",
"\x{223C}" => "\x{223D}",
"\x{2243}" => "\x{22CD}",
"\x{2252}" => "\x{2253}",
"\x{2254}" => "\x{2255}",
"\x{2264}" => "\x{2265}",
"\x{2266}" => "\x{2267}",
"\x{2268}" => "\x{2269}",
"\x{226A}" => "\x{226B}",
"\x{226E}" => "\x{226F}",
"\x{2270}" => "\x{2271}",
"\x{2272}" => "\x{2273}",
"\x{2274}" => "\x{2275}",
"\x{2276}" => "\x{2277}",
"\x{2278}" => "\x{2279}",
"\x{227A}" => "\x{227B}",
"\x{227C}" => "\x{227D}",
"\x{227E}" => "\x{227F}",
"\x{2280}" => "\x{2281}",
"\x{2282}" => "\x{2283}",
"\x{2284}" => "\x{2285}",
"\x{2286}" => "\x{2287}",
"\x{2288}" => "\x{2289}",
"\x{228A}" => "\x{228B}",
"\x{228F}" => "\x{2290}",
"\x{2291}" => "\x{2292}",
"\x{2298}" => "\x{29B8}",
"\x{22A2}" => "\x{22A3}",
"\x{22A6}" => "\x{2ADE}",
"\x{22A8}" => "\x{2AE4}",
"\x{22A9}" => "\x{2AE3}",
"\x{22AB}" => "\x{2AE5}",
"\x{22B0}" => "\x{22B1}",
"\x{22B2}" => "\x{22B3}",
"\x{22B4}" => "\x{22B5}",
"\x{22B6}" => "\x{22B7}",
"\x{22C9}" => "\x{22CA}",
"\x{22CB}" => "\x{22CC}",
"\x{22D0}" => "\x{22D1}",
"\x{22D6}" => "\x{22D7}",
"\x{22D8}" => "\x{22D9}",
"\x{22DA}" => "\x{22DB}",
"\x{22DC}" => "\x{22DD}",
"\x{22DE}" => "\x{22DF}",
"\x{22E0}" => "\x{22E1}",
"\x{22E2}" => "\x{22E3}",
"\x{22E4}" => "\x{22E5}",
"\x{22E6}" => "\x{22E7}",
"\x{22E8}" => "\x{22E9}",
"\x{22EA}" => "\x{22EB}",
"\x{22EC}" => "\x{22ED}",
"\x{22F0}" => "\x{22F1}",
"\x{22F2}" => "\x{22FA}",
"\x{22F3}" => "\x{22FB}",
"\x{22F4}" => "\x{22FC}",
"\x{22F6}" => "\x{22FD}",
"\x{22F7}" => "\x{22FE}",
"\x{2308}" => "\x{2309}",
"\x{230A}" => "\x{230B}",
"\x{2329}" => "\x{232A}",
"\x{23B4}" => "\x{23B5}",
"\x{2768}" => "\x{2769}",
"\x{276A}" => "\x{276B}",
"\x{276C}" => "\x{276D}",
"\x{276E}" => "\x{276F}",
"\x{2770}" => "\x{2771}",
"\x{2772}" => "\x{2773}",
"\x{2774}" => "\x{2775}",
"\x{27C3}" => "\x{27C4}",
"\x{27C5}" => "\x{27C6}",
"\x{27D5}" => "\x{27D6}",
"\x{27DD}" => "\x{27DE}",
"\x{27E2}" => "\x{27E3}",
"\x{27E4}" => "\x{27E5}",
"\x{27E6}" => "\x{27E7}",
"\x{27E8}" => "\x{27E9}",
"\x{27EA}" => "\x{27EB}",
"\x{2983}" => "\x{2984}",
"\x{2985}" => "\x{2986}",
"\x{2987}" => "\x{2988}",
"\x{2989}" => "\x{298A}",
"\x{298B}" => "\x{298C}",
"\x{298D}" => "\x{298E}",
"\x{298F}" => "\x{2990}",
"\x{2991}" => "\x{2992}",
"\x{2993}" => "\x{2994}",
"\x{2995}" => "\x{2996}",
"\x{2997}" => "\x{2998}",
"\x{29C0}" => "\x{29C1}",
"\x{29C4}" => "\x{29C5}",
"\x{29CF}" => "\x{29D0}",
"\x{29D1}" => "\x{29D2}",
"\x{29D4}" => "\x{29D5}",
"\x{29D8}" => "\x{29D9}",
"\x{29DA}" => "\x{29DB}",
"\x{29F8}" => "\x{29F9}",
"\x{29FC}" => "\x{29FD}",
"\x{2A2B}" => "\x{2A2C}",
"\x{2A2D}" => "\x{2A2E}",
"\x{2A34}" => "\x{2A35}",
"\x{2A3C}" => "\x{2A3D}",
"\x{2A64}" => "\x{2A65}",
"\x{2A79}" => "\x{2A7A}",
"\x{2A7D}" => "\x{2A7E}",
"\x{2A7F}" => "\x{2A80}",
"\x{2A81}" => "\x{2A82}",
"\x{2A83}" => "\x{2A84}",
"\x{2A8B}" => "\x{2A8C}",
"\x{2A91}" => "\x{2A92}",
"\x{2A93}" => "\x{2A94}",
"\x{2A95}" => "\x{2A96}",
"\x{2A97}" => "\x{2A98}",
"\x{2A99}" => "\x{2A9A}",
"\x{2A9B}" => "\x{2A9C}",
"\x{2AA1}" => "\x{2AA2}",
"\x{2AA6}" => "\x{2AA7}",
"\x{2AA8}" => "\x{2AA9}",
"\x{2AAA}" => "\x{2AAB}",
"\x{2AAC}" => "\x{2AAD}",
"\x{2AAF}" => "\x{2AB0}",
"\x{2AB3}" => "\x{2AB4}",
"\x{2ABB}" => "\x{2ABC}",
"\x{2ABD}" => "\x{2ABE}",
"\x{2ABF}" => "\x{2AC0}",
"\x{2AC1}" => "\x{2AC2}",
"\x{2AC3}" => "\x{2AC4}",
"\x{2AC5}" => "\x{2AC6}",
"\x{2ACD}" => "\x{2ACE}",
"\x{2ACF}" => "\x{2AD0}",
"\x{2AD1}" => "\x{2AD2}",
"\x{2AD3}" => "\x{2AD4}",
"\x{2AD5}" => "\x{2AD6}",
"\x{2AEC}" => "\x{2AED}",
"\x{2AF7}" => "\x{2AF8}",
"\x{2AF9}" => "\x{2AFA}",
"\x{2E02}" => "\x{2E03}",
"\x{2E04}" => "\x{2E05}",
"\x{2E09}" => "\x{2E0A}",
"\x{2E0C}" => "\x{2E0D}",
"\x{2E1C}" => "\x{2E1D}",
"\x{2E20}" => "\x{2E21}",
"\x{3008}" => "\x{3009}",
"\x{300A}" => "\x{300B}",
"\x{300C}" => "\x{300D}",
"\x{300E}" => "\x{300F}",
"\x{3010}" => "\x{3011}",
"\x{3014}" => "\x{3015}",
"\x{3016}" => "\x{3017}",
"\x{3018}" => "\x{3019}",
"\x{301A}" => "\x{301B}",
"\x{301D}" => "\x{301E}",
"\x{FD3E}" => "\x{FD3F}",
"\x{FE17}" => "\x{FE18}",
"\x{FE35}" => "\x{FE36}",
"\x{FE37}" => "\x{FE38}",
"\x{FE39}" => "\x{FE3A}",
"\x{FE3B}" => "\x{FE3C}",
"\x{FE3D}" => "\x{FE3E}",
"\x{FE3F}" => "\x{FE40}",
"\x{FE41}" => "\x{FE42}",
"\x{FE43}" => "\x{FE44}",
"\x{FE47}" => "\x{FE48}",
"\x{FE59}" => "\x{FE5A}",
"\x{FE5B}" => "\x{FE5C}",
"\x{FE5D}" => "\x{FE5E}",
"\x{FF08}" => "\x{FF09}",
"\x{FF1C}" => "\x{FF1E}",
"\x{FF3B}" => "\x{FF3D}",
"\x{FF5B}" => "\x{FF5D}",
"\x{FF5F}" => "\x{FF60}",
"\x{FF62}" => "\x{FF63}",
);

our %close2open = reverse %open2close;

## token opener
##      token opener {
##        <[
##      \x0028
##      \x003C
##      \x005B
##      \x007B
##      \x00AB
##      \x0F3A
##      \x0F3C
##      \x169B
##      \x2018
##      \x201A
##      \x201B
##      \x201C
##      \x201E
##      \x201F
##      \x2039
##      \x2045
##      \x207D
##      \x208D
##      \x2208
##      \x2209
##      \x220A
##      \x2215
##      \x223C
##      \x2243
##      \x2252
##      \x2254
##      \x2264
##      \x2266
##      \x2268
##      \x226A
##      \x226E
##      \x2270
##      \x2272
##      \x2274
##      \x2276
##      \x2278
##      \x227A
##      \x227C
##      \x227E
##      \x2280
##      \x2282
##      \x2284
##      \x2286
##      \x2288
##      \x228A
##      \x228F
##      \x2291
##      \x2298
##      \x22A2
##      \x22A6
##      \x22A8
##      \x22A9
##      \x22AB
##      \x22B0
##      \x22B2
##      \x22B4
##      \x22B6
##      \x22C9
##      \x22CB
##      \x22D0
##      \x22D6
##      \x22D8
##      \x22DA
##      \x22DC
##      \x22DE
##      \x22E0
##      \x22E2
##      \x22E4
##      \x22E6
##      \x22E8
##      \x22EA
##      \x22EC
##      \x22F0
##      \x22F2
##      \x22F3
##      \x22F4
##      \x22F6
##      \x22F7
##      \x2308
##      \x230A
##      \x2329
##      \x23B4
##      \x2768
##      \x276A
##      \x276C
##      \x276E
##      \x2770
##      \x2772
##      \x2774
##      \x27C3
##      \x27C5
##      \x27D5
##      \x27DD
##      \x27E2
##      \x27E4
##      \x27E6
##      \x27E8
##      \x27EA
##      \x2983
##      \x2985
##      \x2987
##      \x2989
##      \x298B
##      \x298D
##      \x298F
##      \x2991
##      \x2993
##      \x2995
##      \x2997
##      \x29C0
##      \x29C4
##      \x29CF
##      \x29D1
##      \x29D4
##      \x29D8
##      \x29DA
##      \x29F8
##      \x29FC
##      \x2A2B
##      \x2A2D
##      \x2A34
##      \x2A3C
##      \x2A64
##      \x2A79
##      \x2A7D
##      \x2A7F
##      \x2A81
##      \x2A83
##      \x2A8B
##      \x2A91
##      \x2A93
##      \x2A95
##      \x2A97
##      \x2A99
##      \x2A9B
##      \x2AA1
##      \x2AA6
##      \x2AA8
##      \x2AAA
##      \x2AAC
##      \x2AAF
##      \x2AB3
##      \x2ABB
##      \x2ABD
##      \x2ABF
##      \x2AC1
##      \x2AC3
##      \x2AC5
##      \x2ACD
##      \x2ACF
##      \x2AD1
##      \x2AD3
##      \x2AD5
##      \x2AEC
##      \x2AF7
##      \x2AF9
##      \x2E02
##      \x2E04
##      \x2E09
##      \x2E0C
##      \x2E1C
##      \x2E20
##      \x3008
##      \x300A
##      \x300C
##      \x300E
##      \x3010
##      \x3014
##      \x3016
##      \x3018
##      \x301A
##      \x301D
##      \xFD3E
##      \xFE17
##      \xFE35
##      \xFE37
##      \xFE39
##      \xFE3B
##      \xFE3D
##      \xFE3F
##      \xFE41
##      \xFE43
##      \xFE47
##      \xFE59
##      \xFE5B
##      \xFE5D
##      \xFF08
##      \xFF1C
##      \xFF3B
##      \xFF5B
##      \xFF5F
##      \xFF62
##        ]>
##      }

sub opener__PEEK { $_[0]->_AUTOLEXpeek('opener',$retree) }
sub opener {
no warnings 'recursion';
my $self = shift;
local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;


my $C = $self->cursor_xact("RULE opener");
my $xact = $C->xact;
my $S = $C->{'_pos'};

$self->_MATCHIFYr($S, "opener", 
$C->_PATTERN(qr/\G[\x{0028}\x{003C}\x{005B}\x{007B}\x{00AB}\x{0F3A}\x{0F3C}\x{169B}\x{2018}\x{201A}\x{201B}\x{201C}\x{201E}\x{201F}\x{2039}\x{2045}\x{207D}\x{208D}\x{2208}\x{2209}\x{220A}\x{2215}\x{223C}\x{2243}\x{2252}\x{2254}\x{2264}\x{2266}\x{2268}\x{226A}\x{226E}\x{2270}\x{2272}\x{2274}\x{2276}\x{2278}\x{227A}\x{227C}\x{227E}\x{2280}\x{2282}\x{2284}\x{2286}\x{2288}\x{228A}\x{228F}\x{2291}\x{2298}\x{22A2}\x{22A6}\x{22A8}\x{22A9}\x{22AB}\x{22B0}\x{22B2}\x{22B4}\x{22B6}\x{22C9}\x{22CB}\x{22D0}\x{22D6}\x{22D8}\x{22DA}\x{22DC}\x{22DE}\x{22E0}\x{22E2}\x{22E4}\x{22E6}\x{22E8}\x{22EA}\x{22EC}\x{22F0}\x{22F2}\x{22F3}\x{22F4}\x{22F6}\x{22F7}\x{2308}\x{230A}\x{2329}\x{23B4}\x{2768}\x{276A}\x{276C}\x{276E}\x{2770}\x{2772}\x{2774}\x{27C3}\x{27C5}\x{27D5}\x{27DD}\x{27E2}\x{27E4}\x{27E6}\x{27E8}\x{27EA}\x{2983}\x{2985}\x{2987}\x{2989}\x{298B}\x{298D}\x{298F}\x{2991}\x{2993}\x{2995}\x{2997}\x{29C0}\x{29C4}\x{29CF}\x{29D1}\x{29D4}\x{29D8}\x{29DA}\x{29F8}\x{29FC}\x{2A2B}\x{2A2D}\x{2A34}\x{2A3C}\x{2A64}\x{2A79}\x{2A7D}\x{2A7F}\x{2A81}\x{2A83}\x{2A8B}\x{2A91}\x{2A93}\x{2A95}\x{2A97}\x{2A99}\x{2A9B}\x{2AA1}\x{2AA6}\x{2AA8}\x{2AAA}\x{2AAC}\x{2AAF}\x{2AB3}\x{2ABB}\x{2ABD}\x{2ABF}\x{2AC1}\x{2AC3}\x{2AC5}\x{2ACD}\x{2ACF}\x{2AD1}\x{2AD3}\x{2AD5}\x{2AEC}\x{2AF7}\x{2AF9}\x{2E02}\x{2E04}\x{2E09}\x{2E0C}\x{2E1C}\x{2E20}\x{3008}\x{300A}\x{300C}\x{300E}\x{3010}\x{3014}\x{3016}\x{3018}\x{301A}\x{301D}\x{FD3E}\x{FE17}\x{FE35}\x{FE37}\x{FE39}\x{FE3B}\x{FE3D}\x{FE3F}\x{FE41}\x{FE43}\x{FE47}\x{FE59}\x{FE5B}\x{FE5D}\x{FF08}\x{FF1C}\x{FF3B}\x{FF5B}\x{FF5F}\x{FF62}]/)
);
}

# assumes whitespace is eaten already

## method peek_delimiters
sub peek_delimiters {
my $self = shift;


my $pos = $self->{'_pos'};
my $startpos = $pos;
my $char = substr($::ORIG,$pos++,1);
if ($char =~ qr/^\s$/) {
$self->panic("Whitespace character is not allowed as delimiter"); # "can't happen"
}
elsif ($char =~ qr/^\w$/) {
$self->panic("Alphanumeric character is not allowed as delimiter");
}
elsif ($close2open{$char}) {
$self->panic("Use of a closing delimiter for an opener is reserved");
}
elsif ($char eq ':') {
$self->panic("Colons may not be used to delimit quoting constructs");
}

my $rightbrack = $open2close{$char};
if (not defined $rightbrack) {
return $char, $char;
}
while (substr($::ORIG,$pos,1) eq $char) {
$pos++;
}
my $len = $pos - $startpos;
my $start = $char x $len;
my $stop = $rightbrack x $len;
return $start, $stop;
}

{ package STD::startstop;
sub __instantiate__ { my $self = shift;
my ($start,$stop) = @_;
my $mangle = ::mangle($start,$stop);
my $mixin = "STD::startstop::" . $mangle;
return $mixin if $INSTANTIATED{$mixin}++;
::deb("		instantiating $mixin") if $::DEBUG & DEBUG::mixins;
my $eval = "package $mixin" . q{;
use Moose::Role ':all' => { -prefix => "moose_" };
my $retree;
sub _PARAMS { { '$start' => $start,'$stop' => $stop } }
##     token starter
##          token starter { $start }

sub starter__PEEK { $_[0]->_AUTOLEXpeek('starter',$retree) }
sub starter {
no warnings 'recursion';
my $self = shift;
local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;


my $C = $self->cursor_xact("RULE starter");
my $xact = $C->xact;
my $S = $C->{'_pos'};

$self->_MATCHIFYr($S, "starter", 
$C->_EXACT($start)
);
}
##     token stopper
##          token stopper { $stop }

sub stopper__PEEK { $_[0]->_AUTOLEXpeek('stopper',$retree) }
sub stopper {
no warnings 'recursion';
my $self = shift;
local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;


my $C = $self->cursor_xact("RULE stopper");
my $xact = $C->xact;
my $S = $C->{'_pos'};

$self->_MATCHIFYr($S, "stopper", 
$C->_EXACT($stop)
);
}
BEGIN {
$retree = YAML::XS::Load(Encode::encode_utf8(<<'RETREE_END'));
---
starter: !!perl/hash:RE_ast
  decl: []
  kind: token
  min: 0
  pkg: ~
  re: !!perl/hash:RE_var
    a: 0
    dba: starter
    i: 0
    min: 0
    r: 1
    s: 0
    var: $start
stopper: !!perl/hash:RE_ast
  decl: []
  kind: token
  min: 0
  pkg: ~
  re: !!perl/hash:RE_var
    a: 0
    dba: stopper
    i: 0
    min: 0
    r: 1
    s: 0
    var: $stop
RETREE_END
}
};
eval $eval;
return $mixin;
}
}
## end role

{ package STD::stop;
sub __instantiate__ { my $self = shift;
my ($stop) = @_;
my $mangle = ::mangle($stop);
my $mixin = "STD::stop::" . $mangle;
return $mixin if $INSTANTIATED{$mixin}++;
::deb("		instantiating $mixin") if $::DEBUG & DEBUG::mixins;
my $eval = "package $mixin" . q{;
use Moose::Role ':all' => { -prefix => "moose_" };
my $retree;
sub _PARAMS { { '$stop' => $stop } }
##     token starter
##          token starter { <!> }

sub starter__PEEK { $_[0]->_AUTOLEXpeek('starter',$retree) }
sub starter {
no warnings 'recursion';
my $self = shift;
local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;


my $C = $self->cursor_xact("RULE starter");
my $xact = $C->xact;
my $S = $C->{'_pos'};

$self->_MATCHIFYr($S, "starter", 
$C->_NOTBEFORE( sub { my $C=shift;
$C
})
);
}
##     token stopper
##          token stopper { $stop }

sub stopper__PEEK { $_[0]->_AUTOLEXpeek('stopper',$retree) }
sub stopper {
no warnings 'recursion';
my $self = shift;
local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;


my $C = $self->cursor_xact("RULE stopper");
my $xact = $C->xact;
my $S = $C->{'_pos'};

$self->_MATCHIFYr($S, "stopper", 
$C->_EXACT($stop)
);
}
BEGIN {
$retree = YAML::XS::Load(Encode::encode_utf8(<<'RETREE_END'));
---
starter: !!perl/hash:RE_ast
  decl: []
  kind: token
  min: 0
  pkg: ~
  re: !!perl/hash:RE_assertion
    assert: '!'
    min: 0
    re: !!perl/hash:RE_noop
      a: 0
      dba: starter
      i: 0
      min: 0
      nobind: 1
      r: 1
      s: 0
stopper: !!perl/hash:RE_ast
  decl: []
  kind: token
  min: 0
  pkg: ~
  re: !!perl/hash:RE_var
    a: 0
    dba: stopper
    i: 0
    min: 0
    r: 1
    s: 0
    var: $stop
RETREE_END
}
};
eval $eval;
return $mixin;
}
}
## end role

{ package STD::unitstop;
sub __instantiate__ { my $self = shift;
my ($stop) = @_;
my $mangle = ::mangle($stop);
my $mixin = "STD::unitstop::" . $mangle;
return $mixin if $INSTANTIATED{$mixin}++;
::deb("		instantiating $mixin") if $::DEBUG & DEBUG::mixins;
my $eval = "package $mixin" . q{;
use Moose::Role ':all' => { -prefix => "moose_" };
my $retree;
sub _PARAMS { { '$stop' => $stop } }
##     token unitstopper
##          token unitstopper { $stop }

sub unitstopper__PEEK { $_[0]->_AUTOLEXpeek('unitstopper',$retree) }
sub unitstopper {
no warnings 'recursion';
my $self = shift;
local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;


my $C = $self->cursor_xact("RULE unitstopper");
my $xact = $C->xact;
my $S = $C->{'_pos'};

$self->_MATCHIFYr($S, "unitstopper", 
$C->_EXACT($stop)
);
}
BEGIN {
$retree = YAML::XS::Load(Encode::encode_utf8(<<'RETREE_END'));
---
unitstopper: !!perl/hash:RE_ast
  decl: []
  kind: token
  min: 0
  pkg: ~
  re: !!perl/hash:RE_var
    a: 0
    dba: unitstopper
    i: 0
    min: 0
    r: 1
    s: 0
    var: $stop
RETREE_END
}
};
eval $eval;
return $mixin;
}
}
## end role
## token unitstopper
##      } # end role
##      
##      token unitstopper { $ }

sub unitstopper__PEEK { $_[0]->_AUTOLEXpeek('unitstopper',$retree) }
sub unitstopper {
no warnings 'recursion';
my $self = shift;
local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;


my $C = $self->cursor_xact("RULE unitstopper");
my $xact = $C->xact;
my $S = $C->{'_pos'};

$self->_MATCHIFYr($S, "unitstopper", 
$C->_PATTERN(qr/\G\z/)
);
}

## method balanced ($start,$stop)
sub balanced {
my $self = shift;
my $start = shift;
my $stop = shift;

$self->mixin( 'STD::startstop'->__instantiate__($start,$stop) ); }
## method unbalanced ($stop)
sub unbalanced {
my $self = shift;
my $stop = shift;

$self->mixin( 'STD::stop'->__instantiate__($stop) ); }
## method unitstop ($stop)
sub unitstop {
my $self = shift;
my $stop = shift;

$self->mixin( 'STD::unitstop'->__instantiate__($stop) ); }

## method truly ($bool,$opt)
sub truly {
my $self = shift;
my $bool = shift;
my $opt = shift;


return $self if $bool;
$self->panic("Can't negate $opt adverb");
}

## token charname
##      token charname {
##          [
##          | <radint>
##          | <[a..z A..Z]><-[ \] , # ]>*?<[a..z A..Z ) ]> <?before \s*<[ \] , # ]>>
##          ] || <.panic: "Unrecognized character name">
##      }

sub charname__PEEK { $_[0]->_AUTOLEXpeek('charname',$retree) }
sub charname {
no warnings 'recursion';
my $self = shift;
local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;


my $C = $self->cursor_xact("RULE charname");
my $xact = $C->xact;
my $S = $C->{'_pos'};

$self->_MATCHIFY($S, "charname", 
do {
my $C = $C->cursor_xact('ALT ||');
my $xact = $C->xact;
my @gather;
do {
push @gather, $C->_BRACKET(sub {
my $C=shift;
do {
my @result = do {
my $trystate;
my ($tag, $try);
my @try;
my $relex;

my $fate;
my $x;
if ($fate = $C->{'_fate'} and $fate->[1] eq 'charname_01') {
$C->deb("Fate passed to charname_01: ", ::fatestr($fate)) if $::DEBUG & DEBUG::fates;
($C->{'_fate'}, $tag, $try) = @$fate;
@try = ($try);
$x = 'ALT charname_01';    # some outer ltm is controlling us
}
else {
$x = 'ALTLTM charname_01'; # we are top level ltm
}
my $C = $C->cursor_xact($x);
my $xact = $C->xact;

my @gather = ();
for (;;) {
if (not @try) {
$relex //= $C->cursor_fate('STD', 'charname_01', $retree);
@try = $relex->($C, $trystate);
}
last unless @try;
$try = shift(@try) // next;

if (ref $try eq 'ARRAY') {
($C->{'_fate'}, $tag, $try) = @$try;	# next candidate fate
}

$C->deb("charname_01 trying $tag $try") if $::DEBUG & DEBUG::try_processing;
push @gather, ((
sub { my $C=shift;
$C->_SUBSUME(['radint'], sub {
my $C = shift;
$C->radint
})
},
sub { my $C=shift;
Cursor::lazymap(sub {
my $C=$_[0];
Cursor::lazymap(sub {
my $C=$_[0];
Cursor::lazymap(sub {
my $C=$_[0];
$C->before(sub { my $C=shift;
Cursor::lazymap(sub {
my $C=$_[0];
$C->_PATTERN(qr/\G[\],#]/)
}, $C->_PATTERN(qr/\G((?:\s)*+)/))
})
}, $C->_PATTERN(qr/\G[a-zA-Z)]/))
}, $C->_STARf(sub { my $C=shift;
$C->_PATTERN(qr/\G[^\],#]/)
}))
}, $C->_PATTERN(qr/\G[a-zA-Z]/))
},
)[$try])->($C);
last if $xact->[-2];  # committed?
last if @gather;
}
@gather;
};
@result;
}

})
}
or $xact->[-2] or
do {
push @gather, $C->panic("Unrecognized character name")};
@gather;
}
);
}

## token charnames
##      token charnames { [<.ws><charname><.ws>] ** ',' }

sub charnames__PEEK { $_[0]->_AUTOLEXpeek('charnames',$retree) }
sub charnames {
no warnings 'recursion';
my $self = shift;
local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;


my $C = $self->cursor_xact("RULE charnames");
my $xact = $C->xact;
my $S = $C->{'_pos'};
$C->{'charname'} = [];

$self->_MATCHIFYr($S, "charnames", 
$C->_REPSEPr(  sub { my $C=shift;
$C->_EXACT(',')
}, sub { my $C=shift;
$C->_BRACKETr(sub {
my $C=shift;
do {
if (my ($C) = ($C->ws)) {
do {
if (my ($C) = ($C->_SUBSUMEr(['charname'], sub {
my $C = shift;
$C->charname
}))) {
$C->ws;
}
else {
();
}
};
}
else {
();
}
}
})
})
);
}

## token charspec
##      token charspec {
##          [
##          | :dba('character name') '[' ~ ']' <charnames>
##          | \d+
##          | <[ ?..Z \\.._ ]>
##          | <?> <.panic: "Unrecognized \\c character">
##          ]
##      }

sub charspec__PEEK { $_[0]->_AUTOLEXpeek('charspec',$retree) }
sub charspec {
no warnings 'recursion';
my $self = shift;
local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;


my $C = $self->cursor_xact("RULE charspec");
my $xact = $C->xact;
my $S = $C->{'_pos'};

$self->_MATCHIFYr($S, "charspec", 
$C->_BRACKETr(sub {
my $C=shift;
do {
my @result = do {
my $trystate;
my ($tag, $try);
my @try;
my $relex;

my $fate;
my $x;
if ($fate = $C->{'_fate'} and $fate->[1] eq 'charspec_01') {
$C->deb("Fate passed to charspec_01: ", ::fatestr($fate)) if $::DEBUG & DEBUG::fates;
($C->{'_fate'}, $tag, $try) = @$fate;
@try = ($try);
$x = 'ALT charspec_01';    # some outer ltm is controlling us
}
else {
$x = 'ALTLTM charspec_01'; # we are top level ltm
}
my $C = $C->cursor_xact($x);
my $xact = $C->xact;

my @gather = ();
for (;;) {
if (not @try) {
$relex //= $C->cursor_fate('STD', 'charspec_01', $retree);
@try = $relex->($C, $trystate);
}
last unless @try;
$try = shift(@try) // next;

if (ref $try eq 'ARRAY') {
($C->{'_fate'}, $tag, $try) = @$try;	# next candidate fate
}

$C->deb("charspec_01 trying $tag $try") if $::DEBUG & DEBUG::try_processing;
push @gather, ((
sub { my $C=shift;
do {
if (my ($C) = ($C->_EXACT('['))) {
do {
if (my ($C) = (((local $::GOAL = ']' ), $C)[-1])) {
do {
if (my ($C) = ($C->_SUBSUMEr(['charnames'], sub {
my $C = shift;
$C->charnames
}))) {
$C->_BRACKETr(sub {
my $C=shift;
do {
my $C = $C->cursor_xact('ALT ||');
my $xact = $C->xact;
my @gather;
do {
push @gather, $C->_EXACT(']')
}
or $xact->[-2] or
do {
push @gather, $C->FAILGOAL(']' , 'character name')};
@gather;
}
});
}
else {
();
}
};
}
else {
();
}
};
}
else {
();
}
}
},
sub { my $C=shift;
$C->_PATTERN(qr/\G((?:\d)++)/)
},
sub { my $C=shift;
$C->_PATTERN(qr/\G[?-Z\\-_]/)
},
sub { my $C=shift;
do {
if (my ($C) = ($C->before( sub { my $C=shift;
$C
}))) {
$C->panic("Unrecognized \\c character");
}
else {
();
}
}
},
)[$try])->($C);
last if $xact->[-2];  # committed?
last if @gather;
}
@gather;
};
@result;
}

})
);
}

#proto token backslash { <...> }
sub backslash__PEEK { $_[0]->_AUTOLEXpeek('backslash:*',$retree); }
sub backslash {
my $self = shift;
my $subs;

local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;

my $C = $self->cursor_xact('RULE backslash');
my $S = $C->{'_pos'};

my @result = do {
my $trystate;
my ($tag, $try);
my @try;
my $relex;
my $x;
if (my $fate = $C->{'_fate'}) {
if ($fate->[1] eq 'backslash') {
$C->deb("Fate passed to backslash: ", ::fatestr($fate)) if $::DEBUG & DEBUG::fates;
($C->{'_fate'}, $tag, $try) = @$fate;
@try = ($try);
$x = 'ALT backslash';
}
else {
$x = 'ALTLTM backslash';
}
}
else {
$x = 'ALTLTM backslash';
}
my $C = $C->cursor_xact($x);
my $xact = $C->xact;

my @gather = ();
for (;;) {
if (not @try) {
$relex //= $C->cursor_fate('STD', 'backslash:*', $retree);
@try = $relex->($C, $trystate);
}
last unless @try;
$try = shift(@try) // next;

if (ref $try eq 'ARRAY') {
($C->{'_fate'}, $tag, $try) = @$try;	# next candidate fate
}

$C->deb("backslash trying $tag $try") if $::DEBUG & DEBUG::try_processing;
push @gather, $C->$try(@_);
last if $xact->[-2];  # committed?
last if @gather;
}
$self->_MATCHIFYr($S, "backslash", @gather);
};
@result;
}

#proto token escape { <...> }
sub escape__PEEK { $_[0]->_AUTOLEXpeek('escape:*',$retree); }
sub escape {
my $self = shift;
my $subs;

local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;

my $C = $self->cursor_xact('RULE escape');
my $S = $C->{'_pos'};

my @result = do {
my $trystate;
my ($tag, $try);
my @try;
my $relex;
my $x;
if (my $fate = $C->{'_fate'}) {
if ($fate->[1] eq 'escape') {
$C->deb("Fate passed to escape: ", ::fatestr($fate)) if $::DEBUG & DEBUG::fates;
($C->{'_fate'}, $tag, $try) = @$fate;
@try = ($try);
$x = 'ALT escape';
}
else {
$x = 'ALTLTM escape';
}
}
else {
$x = 'ALTLTM escape';
}
my $C = $C->cursor_xact($x);
my $xact = $C->xact;

my @gather = ();
for (;;) {
if (not @try) {
$relex //= $C->cursor_fate('STD', 'escape:*', $retree);
@try = $relex->($C, $trystate);
}
last unless @try;
$try = shift(@try) // next;

if (ref $try eq 'ARRAY') {
($C->{'_fate'}, $tag, $try) = @$try;	# next candidate fate
}

$C->deb("escape trying $tag $try") if $::DEBUG & DEBUG::try_processing;
push @gather, $C->$try(@_);
last if $xact->[-2];  # committed?
last if @gather;
}
$self->_MATCHIFYr($S, "escape", @gather);
};
@result;
}

## token starter
##      token starter { <!> }

sub starter__PEEK { $_[0]->_AUTOLEXpeek('starter',$retree) }
sub starter {
no warnings 'recursion';
my $self = shift;
local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;


my $C = $self->cursor_xact("RULE starter");
my $xact = $C->xact;
my $S = $C->{'_pos'};

$self->_MATCHIFYr($S, "starter", 
$C->_NOTBEFORE( sub { my $C=shift;
$C
})
);
}
## token escape__S_048none (:$*sym = 'none')
##      token escape:none { <!> }

sub escape__S_048none__PEEK { $_[0]->_AUTOLEXpeek('escape__S_048none',$retree) }
sub escape__S_048none {
no warnings 'recursion';
my $self = shift;
local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;
my %args = @_;
local $::sym = $args{sym} // 'none';


my $C = $self->cursor_xact("RULE escape__S_048none");
my $xact = $C->xact;
my $S = $C->{'_pos'};
$C->{'sym'} = ref $sym ? join(' ', @$sym) : $sym;

$self->_MATCHIFYr($S, "escape__S_048none", 
$C->_NOTBEFORE( sub { my $C=shift;
$C
})
);
}

# and this is what makes nibbler polymorphic...
## method nibble ($lang)
sub nibble {
my $self = shift;
my $lang = shift;


$self->cursor_fresh($lang)->nibbler;
}

# note: polymorphic over many quote languages, we hope
## token nibbler
##      token nibbler {
##          :my $text = '';
##          :my $from = self.pos;
##          :my $to = $from;
##          :my @nibbles = ();
##          :my $multiline = 0;
##          :my $nibble;
##          { $<_from> = self.pos; }
##          [ <!before <stopper> >
##              [
##              || <starter> <nibbler> <stopper>
##                              {{
##                                  push @nibbles, $.makestr(TEXT => $text, _from => $from, _pos => $to ) if $from != $to;
##      
##                                  my $n = $<nibbler>[*-1]<nibbles>;
##                                  my @n = @$n;
##      
##                                  push @nibbles, $<starter>;
##                                  push @nibbles, @n;
##                                  push @nibbles, $<stopper>;
##      
##                                  $text = '';
##                                  $to = $from = $.pos;
##                              }}
##              || <escape>     {{
##                                  push @nibbles, $.makestr(TEXT => $text, _from => $from, _pos => $to ) if $from != $to;
##                                  push @nibbles, $<escape>[*-1];
##                                  $text = '';
##                                  $to = $from = $.pos;
##                              }}
##              || .
##                              {{
##                                  my $ch = substr($*ORIG, $.pos-1, 1);
##                                  $text ~= $ch;
##                                  $to = $.pos;
##                                  if $ch ~~ "\n" {
##                                      $multiline++;
##                                  }
##                              }}
##              ]
##          ]*
##          {{
##              push @nibbles, $.makestr(TEXT => $text, _from => $from, _pos => $to ) if $from != $to or !@nibbles;
##              $<nibbles> = \@nibbles;
##              $<_pos> = $.pos;
##              $<nibbler> :delete;
##              $<escape> :delete;
##              $<starter> :delete;
##              $<stopper> :delete;
##              $*LAST_NIBBLE = $;
##              $*LAST_NIBBLE_MULTILINE = $ if $multiline;
##          }}
##      }

sub nibbler__PEEK { $_[0]->_AUTOLEXpeek('nibbler',$retree) }
sub nibbler {
no warnings 'recursion';
my $self = shift;
local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;
my $text = '';
my $from = $self->{'_pos'};
my $to = $from;
my @nibbles = ();
my $multiline = 0;
my $nibble;


my $C = $self->cursor_xact("RULE nibbler");
my $xact = $C->xact;
my $S = $C->{'_pos'};
$C->{'nibbler'} = [];
$C->{'stopper'} = [];
$C->{'starter'} = [];
$C->{'escape'} = [];

$self->_MATCHIFYr($S, "nibbler", 
do {
if (my ($C) = (scalar(do {
my $M = $C;  $M->{'_from'} = $self->{'_pos'}; ;
}, $C))) {
do {
if (my ($C) = ($C->_STARr(sub { my $C=shift;
$C->_BRACKETr(sub {
my $C=shift;
do {
if (my ($C) = ($C->_NOTBEFORE( sub { my $C=shift;
$C->before(sub { my $C=shift;
$C->_SUBSUMEr(['stopper'], sub {
my $C = shift;
$C->stopper
})
})
}))) {
$C->_BRACKETr(sub {
my $C=shift;
do {
my $C = $C->cursor_xact('ALT ||');
my $xact = $C->xact;
my @gather;
do {
push @gather, do {
if (my ($C) = ($C->_SUBSUMEr(['starter'], sub {
my $C = shift;
$C->starter
}))) {
do {
if (my ($C) = ($C->_SUBSUMEr(['nibbler'], sub {
my $C = shift;
$C->nibbler
}))) {
do {
if (my ($C) = ($C->_SUBSUMEr(['stopper'], sub {
my $C = shift;
$C->stopper
}))) {
scalar(do {
my $M = $C; 
push @nibbles, $C->makestr(TEXT => $text, _from => $from, _pos => $to ) if $from != $to;

my $n = $M->{'nibbler'}[-1]{'nibbles'};
my @n = @$n;

push @nibbles, $M->{'starter'};
push @nibbles, @n;
push @nibbles, $M->{'stopper'};

$text = '';
$to = $from = $C->{'_pos'};
;
}, $C);
}
else {
();
}
};
}
else {
();
}
};
}
else {
();
}
}
}
or $xact->[-2] or
do {
push @gather, do {
if (my ($C) = ($C->_SUBSUMEr(['escape'], sub {
my $C = shift;
$C->escape
}))) {
scalar(do {
my $M = $C; 
push @nibbles, $C->makestr(TEXT => $text, _from => $from, _pos => $to ) if $from != $to;
push @nibbles, $M->{'escape'}[-1];
$text = '';
$to = $from = $C->{'_pos'};
;
}, $C);
}
else {
();
}
}
}
or $xact->[-2] or
do {
push @gather, do {
if (my ($C) = ($C->_PATTERN(qr/\G(?s:.)/))) {
scalar(do {

my $ch = substr($::ORIG, $C->{'_pos'}-1, 1);
$text .= $ch;
$to = $C->{'_pos'};
if ($ch =~ "\n") {
$multiline++;
}

}, $C);
}
else {
();
}
}};
@gather;
}
});
}
else {
();
}
}
})
}))) {
scalar(do {
my $M = $C; 
push @nibbles, $C->makestr(TEXT => $text, _from => $from, _pos => $to ) if $from != $to or !@nibbles;
$M->{'nibbles'} = \@nibbles;
$M->{'_pos'} = $C->{'_pos'};
delete $M->{'nibbler'};
delete $M->{'escape'};
delete $M->{'starter'};
delete $M->{'stopper'};
$::LAST_NIBBLE = $C;
$::LAST_NIBBLE_MULTILINE = $C if $multiline;
;
}, $C);
}
else {
();
}
};
}
else {
();
}
}
);
}

## token babble ($l)
##      token babble ($l) {
##          :my $lang = $l;
##          :my $start;
##          :my $stop;
##      
##          <.ws>
##          [ <quotepair> <.ws>
##              {
##                  my $kv = $<quotepair>[*-1];
##                  $lang = $lang.tweak($kv.<k>, $kv.<v>)
##                      or self.panic("Unrecognized adverb :" ~ $kv.<k> ~ '(' ~ $kv.<v> ~ ')');
##              }
##          ]*
##      
##          {
##              ($start,$stop) = $.peek_delimiters();
##              $lang = $start ne $stop ?? $lang.balanced($start,$stop)
##                                      !! $lang.unbalanced($stop);
##              $<B> = [$lang,$start,$stop];
##          }
##      }

sub babble__PEEK { $_[0]->_AUTOLEXpeek('babble',$retree) }
sub babble {
no warnings 'recursion';
my $self = shift;
local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;
my $l = shift;
my $lang = $l;
my $start;
my $stop;


my $C = $self->cursor_xact("RULE babble");
my $xact = $C->xact;
my $S = $C->{'_pos'};
$C->{'quotepair'} = [];

$self->_MATCHIFYr($S, "babble", 
do {
if (my ($C) = ($C->ws)) {
do {
if (my ($C) = ($C->_STARr(sub { my $C=shift;
$C->_BRACKETr(sub {
my $C=shift;
do {
if (my ($C) = ($C->_SUBSUMEr(['quotepair'], sub {
my $C = shift;
$C->quotepair
}))) {
do {
if (my ($C) = ($C->ws)) {
scalar(do {
my $M = $C; 
my $kv = $M->{'quotepair'}[-1];
$lang = $lang->tweak($kv->{'k'}, $kv->{'v'})
or $self->panic("Unrecognized adverb :" . $kv->{'k'} . '(' . $kv->{'v'} . ')');
;
}, $C);
}
else {
();
}
};
}
else {
();
}
}
})
}))) {
scalar(do {
my $M = $C; 
($start,$stop) = $C->peek_delimiters();
$lang = $start ne $stop ? $lang->balanced($start,$stop)
: $lang->unbalanced($stop);
$M->{'B'} = [$lang,$start,$stop];
;
}, $C);
}
else {
();
}
};
}
else {
();
}
}
);
}

our @herestub_queue;

{ package STD::Herestub;
use Moose ':all' => { -prefix => "moose_" };
my $retree;
moose_has 'delim' => (is => 'rw');    moose_has 'orignode' => (is => 'rw');    moose_has 'lang' => (is => 'rw');} ## end class

{ package STD::herestop;
use Moose::Role ':all' => { -prefix => "moose_" };
my $retree;
##     token stopper
##          token stopper { ^^ {} $<ws>=(\h*?) $*DELIM \h* <.unv>?? $$ \v? }

sub stopper__PEEK { $_[0]->_AUTOLEXpeek('stopper',$retree) }
sub stopper {
no warnings 'recursion';
my $self = shift;
local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;


my $C = $self->cursor_xact("RULE stopper");
my $xact = $C->xact;
my $S = $C->{'_pos'};

$self->_MATCHIFY($S, "stopper", 
Cursor::lazymap(sub {
my $C=$_[0];
Cursor::lazymap(sub {
my $C=$_[0];
Cursor::lazymap(sub {
my $C=$_[0];
Cursor::lazymap(sub {
my $C=$_[0];
Cursor::lazymap(sub {
my $C=$_[0];
Cursor::lazymap(sub {
my $C=$_[0];
Cursor::lazymap(sub {
my $C=$_[0];
$C->_PATTERN(qr/\G((?:[\n])?+)/)
}, $C->_PATTERN(qr/\G(?m:$)/))
}, $C->_OPTf(sub { my $C=shift;
$C->unv
}))
}, $C->_PATTERN(qr/\G((?:[\x20\t\r])*+)/))
}, $C->_EXACT($::DELIM))
},   $C->_SUBSUME(['ws'], sub {
my $C = shift;
do { $C->_PAREN( sub { my $C=shift;
$C->_STARf(sub { my $C=shift;
$C->_PATTERN(qr/\G[\x20\t\r]/)
})
})}
}))
}, scalar(do {

}, $C))
}, $C->_PATTERN(qr/\G(?m:^)/))
);
}
BEGIN {
$retree = YAML::XS::Load(Encode::encode_utf8(<<'RETREE_END'));
---
stopper: !!perl/hash:RE_ast
  decl: []
  kind: token
  min: 0
  pkg: ~
  re: !!perl/hash:RE_sequence
    a: 0
    dba: stopper
    i: 0
    min: 0
    r: 1
    s: 0
    zyg:
    - !!perl/hash:RE_meta
      a: 0
      dba: stopper
      i: 0
      min: 0
      r: 1
      s: 0
      text: ^^
    - !!perl/hash:RE_block
      a: 0
      context: void
      dba: stopper
      i: 0
      min: 0
      r: 1
      s: 0
      text: ''
    - !!perl/hash:RE_bindnamed
      a: 0
      atom: !!perl/hash:RE_paren
        decl: []
        min: 0
        re: !!perl/hash:RE_quantified_atom
          atom: !!perl/hash:RE_meta
            a: 0
            dba: stopper
            i: 0
            min: 1
            r: 1
            s: 0
            text: \h
          min: 0
          quant:
          - '*'
          - '?'
          - ''
          - 0
      dba: stopper
      i: 0
      min: 0
      r: 1
      s: 0
      var: ws
    - !!perl/hash:RE_var
      a: 0
      dba: stopper
      i: 0
      min: 0
      r: 1
      s: 0
      var: $*DELIM
    - !!perl/hash:RE_quantified_atom
      atom: !!perl/hash:RE_meta
        a: 0
        dba: stopper
        i: 0
        min: 1
        r: 1
        s: 0
        text: \h
      min: 0
      quant:
      - '*'
      - ':'
      - ''
      - 0
    - !!perl/hash:RE_quantified_atom
      atom: !!perl/hash:RE_method
        a: 0
        dba: stopper
        i: 0
        min: 12345
        name: unv
        nobind: 1
        r: 1
        rest: ''
        s: 0
      min: 0
      quant:
      - '?'
      - '?'
      - ''
      - 0
    - !!perl/hash:RE_meta
      a: 0
      dba: stopper
      i: 0
      min: 0
      r: 1
      s: 0
      text: $$
    - !!perl/hash:RE_quantified_atom
      atom: !!perl/hash:RE_meta
        a: 0
        dba: stopper
        i: 0
        min: 1
        r: 1
        s: 0
        text: \v
      min: 0
      quant:
      - '?'
      - ':'
      - ''
      - 0
RETREE_END
}
} ## end role

# XXX be sure to temporize @herestub_queue on reentry to new line of heredocs

## method heredoc ()
sub heredoc {
my $self = shift;


local $::CTX = $self->callm if $::DEBUG & DEBUG::trace_call;
return if $self->peek;
my $here = $self;
while (my $herestub = shift @herestub_queue) {
local $::DELIM = $herestub->delim;
my $lang = $herestub->lang->mixin( 'STD::herestop' );
my $doc;
if (($doc) = $here->nibble($lang)) {
$here = $doc->trim_heredoc();
$herestub->orignode->{'doc'} = $doc;
}
else {
$self->panic("Ending delimiter $::DELIM not found");
}
}
return $self->cursor($here->{'_pos'});  # return to initial type
}

## token quibble ($l)
##      token quibble ($l) {
##          :my ($lang, $start, $stop);
##          <babble($l)>
##          { my $B = $<babble><B>; ($lang,$start,$stop) = @$B; }
##      
##          $start <nibble($lang)> [ $stop || <.panic: "Couldn't find terminator $stop"> ]
##      
##          {{
##              if $lang<_herelang> {
##                  push @herestub_queue,
##                      ::Herestub.new(
##                          delim => $<nibble><nibbles>[0]<TEXT>,
##                          orignode => $,
##                          lang => $lang<_herelang>,
##                      );
##              }
##          }}
##      }

sub quibble__PEEK { $_[0]->_AUTOLEXpeek('quibble',$retree) }
sub quibble {
no warnings 'recursion';
my $self = shift;
local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;
my $l = shift;
my ($lang, $start, $stop);


my $C = $self->cursor_xact("RULE quibble");
my $xact = $C->xact;
my $S = $C->{'_pos'};

$self->_MATCHIFYr($S, "quibble", 
do {
if (my ($C) = ($C->_SUBSUMEr(['babble'], sub {
my $C = shift;
$C->babble($l)
}))) {
do {
if (my ($C) = (scalar(do {
my $M = $C;  my $B = $M->{'babble'}{'B'}; ($lang,$start,$stop) = @$B; ;
}, $C))) {
do {
if (my ($C) = ($C->_EXACT($start))) {
do {
if (my ($C) = ($C->_SUBSUMEr(['nibble'], sub {
my $C = shift;
$C->nibble($lang)
}))) {
do {
if (my ($C) = ($C->_BRACKETr(sub {
my $C=shift;
do {
my $C = $C->cursor_xact('ALT ||');
my $xact = $C->xact;
my @gather;
do {
push @gather, $C->_EXACT($stop)
}
or $xact->[-2] or
do {
push @gather, $C->panic("Couldn't find terminator $stop")};
@gather;
}
}))) {
scalar(do {
my $M = $C; 
if ($lang->{'_herelang'}) {
push @herestub_queue,
'STD::Herestub'->new(
delim => $M->{'nibble'}{'nibbles'}[0]{'TEXT'},
orignode => $C,
lang => $lang->{'_herelang'},
);
}
;
}, $C);
}
else {
();
}
};
}
else {
();
}
};
}
else {
();
}
};
}
else {
();
}
};
}
else {
();
}
}
);
}

## token quotepair
##      token quotepair {
##          :my $key;
##          :my $value;
##      
##          ':'
##          :dba('colon pair (restricted)')
##          [
##          | '!' <identifier> [ '(' <.panic: "Argument not allowed on negated pair"> ]?
##              { $key = $<identifier>.Str; $value = 0; }
##          | <identifier>
##              { $key = $<identifier>.Str; }
##              [
##              || <.unsp>? <?before '('> <circumfix> { $value = $<circumfix>; }
##              || { $value = 1; }
##              ]
##          | $<n>=(\d+) $<id>=(<[a..z]>+) [ '(' <.panic: "2nd argument not allowed on pair"> ]?
##              { $key = $<id>.Str; $value = $<n>.Str; }
##          ]
##          { $<k> = $key; $<v> = $value; }
##      }

sub quotepair__PEEK { $_[0]->_AUTOLEXpeek('quotepair',$retree) }
sub quotepair {
no warnings 'recursion';
my $self = shift;
local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;
my $key;
my $value;


my $C = $self->cursor_xact("RULE quotepair");
my $xact = $C->xact;
my $S = $C->{'_pos'};

$self->_MATCHIFYr($S, "quotepair", 
do {
if (my ($C) = ($C->_EXACT(':'))) {
do {
if (my ($C) = ($C->_BRACKETr(sub {
my $C=shift;
do {
my @result = do {
my $trystate;
my ($tag, $try);
my @try;
my $relex;

my $fate;
my $x;
if ($fate = $C->{'_fate'} and $fate->[1] eq 'quotepair_01') {
$C->deb("Fate passed to quotepair_01: ", ::fatestr($fate)) if $::DEBUG & DEBUG::fates;
($C->{'_fate'}, $tag, $try) = @$fate;
@try = ($try);
$x = 'ALT quotepair_01';    # some outer ltm is controlling us
}
else {
$x = 'ALTLTM quotepair_01'; # we are top level ltm
}
my $C = $C->cursor_xact($x);
my $xact = $C->xact;

my @gather = ();
for (;;) {
if (not @try) {
$relex //= $C->cursor_fate('STD', 'quotepair_01', $retree);
@try = $relex->($C, $trystate);
}
last unless @try;
$try = shift(@try) // next;

if (ref $try eq 'ARRAY') {
($C->{'_fate'}, $tag, $try) = @$try;	# next candidate fate
}

$C->deb("quotepair_01 trying $tag $try") if $::DEBUG & DEBUG::try_processing;
push @gather, ((
sub { my $C=shift;
do {
if (my ($C) = ($C->_EXACT('!'))) {
do {
if (my ($C) = ($C->_SUBSUMEr(['identifier'], sub {
my $C = shift;
$C->identifier
}))) {
do {
if (my ($C) = ($C->_OPTr(sub { my $C=shift;
$C->_BRACKETr(sub {
my $C=shift;
do {
if (my ($C) = ($C->_EXACT('('))) {
$C->panic("Argument not allowed on negated pair");
}
else {
();
}
}
})
}))) {
scalar(do {
my $M = $C;  $key = $M->{'identifier'}->Str; $value = 0; ;
}, $C);
}
else {
();
}
};
}
else {
();
}
};
}
else {
();
}
}
},
sub { my $C=shift;
do {
if (my ($C) = ($C->_SUBSUMEr(['identifier'], sub {
my $C = shift;
$C->identifier
}))) {
do {
if (my ($C) = (scalar(do {
my $M = $C;  $key = $M->{'identifier'}->Str; ;
}, $C))) {
$C->_BRACKETr(sub {
my $C=shift;
do {
my $C = $C->cursor_xact('ALT ||');
my $xact = $C->xact;
my @gather;
do {
push @gather, do {
if (my ($C) = ($C->_OPTr(sub { my $C=shift;
$C->unsp
}))) {
do {
if (my ($C) = ($C->before(sub { my $C=shift;
$C->_EXACT('(')
}))) {
do {
if (my ($C) = ($C->_SUBSUMEr(['circumfix'], sub {
my $C = shift;
$C->circumfix
}))) {
scalar(do {
my $M = $C;  $value = $M->{'circumfix'}; ;
}, $C);
}
else {
();
}
};
}
else {
();
}
};
}
else {
();
}
}
}
or $xact->[-2] or
do {
push @gather, scalar(do {
$value = 1; 
}, $C)};
@gather;
}
});
}
else {
();
}
};
}
else {
();
}
}
},
sub { my $C=shift;
do {
if (my ($C) = (  $C->_SUBSUMEr(['n'], sub {
my $C = shift;
do { $C->_PAREN( sub { my $C=shift;
$C->_PATTERN(qr/\G((?:\d)++)/)
})}
}))) {
do {
if (my ($C) = (  $C->_SUBSUMEr(['id'], sub {
my $C = shift;
do { $C->_PAREN( sub { my $C=shift;
$C->_PATTERN(qr/\G((?:[a-z])++)/)
})}
}))) {
do {
if (my ($C) = ($C->_OPTr(sub { my $C=shift;
$C->_BRACKETr(sub {
my $C=shift;
do {
if (my ($C) = ($C->_EXACT('('))) {
$C->panic("2nd argument not allowed on pair");
}
else {
();
}
}
})
}))) {
scalar(do {
my $M = $C;  $key = $M->{'id'}->Str; $value = $M->{'n'}->Str; ;
}, $C);
}
else {
();
}
};
}
else {
();
}
};
}
else {
();
}
}
},
)[$try])->($C);
last if $xact->[-2];  # committed?
last if @gather;
}
@gather;
};
@result;
}

}))) {
scalar(do {
my $M = $C;  $M->{'k'} = $key; $M->{'v'} = $value; ;
}, $C);
}
else {
();
}
};
}
else {
();
}
}
);
}

## token quote__S_049Single_Single (:$*sym = <' '>)
##      token quote:sym<' '>   { "'" <nibble($.cursor_fresh( %*LANG<Q> ).tweak(:q).unbalanced("'"))> "'" }

sub quote__S_049Single_Single__PEEK { $_[0]->_AUTOLEXpeek('quote__S_049Single_Single',$retree) }
sub quote__S_049Single_Single {
no warnings 'recursion';
my $self = shift;
local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;
my %args = @_;
local $::sym = $args{sym} // [qw(' ')];


my $C = $self->cursor_xact("RULE quote__S_049Single_Single");
my $xact = $C->xact;
my $S = $C->{'_pos'};
$C->{'sym'} = ref $sym ? join(' ', @$sym) : $sym;

$self->_MATCHIFYr($S, "quote__S_049Single_Single", 
do {
if (my ($C) = ($C->_PATTERN(qr/\G'/))) {
do {
if (my ($C) = ($C->_SUBSUMEr(['nibble'], sub {
my $C = shift;
$C->nibble($C->cursor_fresh( $::LANG{'Q'} )->tweak('q' => 1)->unbalanced("'"))
}))) {
$C->_PATTERN(qr/\G'/);
}
else {
();
}
};
}
else {
();
}
}
);
}
## token quote__S_050Double_Double (:$*sym = <" ">)
##      token quote:sym<" ">   { '"' <nibble($.cursor_fresh( %*LANG<Q> ).tweak(:qq).unbalanced('"'))> '"' }

sub quote__S_050Double_Double__PEEK { $_[0]->_AUTOLEXpeek('quote__S_050Double_Double',$retree) }
sub quote__S_050Double_Double {
no warnings 'recursion';
my $self = shift;
local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;
my %args = @_;
local $::sym = $args{sym} // [qw(" ")];


my $C = $self->cursor_xact("RULE quote__S_050Double_Double");
my $xact = $C->xact;
my $S = $C->{'_pos'};
$C->{'sym'} = ref $sym ? join(' ', @$sym) : $sym;

$self->_MATCHIFYr($S, "quote__S_050Double_Double", 
do {
if (my ($C) = ($C->_EXACT('"'))) {
do {
if (my ($C) = ($C->_SUBSUMEr(['nibble'], sub {
my $C = shift;
$C->nibble($C->cursor_fresh( $::LANG{'Q'} )->tweak('qq' => 1)->unbalanced('"'))
}))) {
$C->_EXACT('"');
}
else {
();
}
};
}
else {
();
}
}
);
}

## token circumfix__S_051Fre_Nch (:$*sym = < >)
##      token circumfix:sym< >   { '' <nibble($.cursor_fresh( %*LANG<Q> ).tweak(:qq).tweak(:ww).balanced('',''))> '' }

sub circumfix__S_051Fre_Nch__PEEK { $_[0]->_AUTOLEXpeek('circumfix__S_051Fre_Nch',$retree) }
sub circumfix__S_051Fre_Nch {
no warnings 'recursion';
my $self = shift;
local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;
my %args = @_;
local $::sym = $args{sym} // [qw( )];


my $C = $self->cursor_xact("RULE circumfix__S_051Fre_Nch");
my $xact = $C->xact;
my $S = $C->{'_pos'};
$C->{'sym'} = ref $sym ? join(' ', @$sym) : $sym;

$self->_MATCHIFYr($S, "circumfix__S_051Fre_Nch", 
do {
if (my ($C) = ($C->_EXACT(''))) {
do {
if (my ($C) = ($C->_SUBSUMEr(['nibble'], sub {
my $C = shift;
$C->nibble($C->cursor_fresh( $::LANG{'Q'} )->tweak('qq' => 1)->tweak('ww' => 1)->balanced('',''))
}))) {
$C->_EXACT('');
}
else {
();
}
};
}
else {
();
}
}
);
}
## token circumfix__S_052LtLt_GtGt (:$*sym = << >>)
##      token circumfix:sym<< >> { '<<' <nibble($.cursor_fresh( %*LANG<Q> ).tweak(:qq).tweak(:ww).balanced('<<','>>'))> '>>' }

sub circumfix__S_052LtLt_GtGt__PEEK { $_[0]->_AUTOLEXpeek('circumfix__S_052LtLt_GtGt',$retree) }
sub circumfix__S_052LtLt_GtGt {
no warnings 'recursion';
my $self = shift;
local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;
my %args = @_;
local $::sym = $args{sym} //['<<','>>'];


my $C = $self->cursor_xact("RULE circumfix__S_052LtLt_GtGt");
my $xact = $C->xact;
my $S = $C->{'_pos'};
$C->{'sym'} = ref $sym ? join(' ', @$sym) : $sym;

$self->_MATCHIFYr($S, "circumfix__S_052LtLt_GtGt", 
do {
if (my ($C) = ($C->_EXACT('<<'))) {
do {
if (my ($C) = ($C->_SUBSUMEr(['nibble'], sub {
my $C = shift;
$C->nibble($C->cursor_fresh( $::LANG{'Q'} )->tweak('qq' => 1)->tweak('ww' => 1)->balanced('<<','>>'))
}))) {
$C->_EXACT('>>');
}
else {
();
}
};
}
else {
();
}
}
);
}
## token circumfix__S_053Lt_Gt (:$*sym = < >)
##      token circumfix:sym< >   { '<'
##                                    [ <?before 'STDIN>' > <.obs('<STDIN>', '$' ~ '*IN.lines')> ]?  # XXX fake out gimme5
##                                    [ <?before '>' > <.obs('<>', 'lines() or ()')> ]?
##                                    <nibble($.cursor_fresh( %*LANG<Q> ).tweak(:q).tweak(:w).balanced('<','>'))> '>' }

sub circumfix__S_053Lt_Gt__PEEK { $_[0]->_AUTOLEXpeek('circumfix__S_053Lt_Gt',$retree) }
sub circumfix__S_053Lt_Gt {
no warnings 'recursion';
my $self = shift;
local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;
my %args = @_;
local $::sym = $args{sym} //['<','>'];


my $C = $self->cursor_xact("RULE circumfix__S_053Lt_Gt");
my $xact = $C->xact;
my $S = $C->{'_pos'};
$C->{'sym'} = ref $sym ? join(' ', @$sym) : $sym;

$self->_MATCHIFYr($S, "circumfix__S_053Lt_Gt", 
do {
if (my ($C) = ($C->_EXACT('<'))) {
do {
if (my ($C) = ($C->_OPTr(sub { my $C=shift;
$C->_BRACKETr(sub {
my $C=shift;
do {
if (my ($C) = ($C->before(sub { my $C=shift;
$C->_EXACT('STDIN>')
}))) {
$C->obs('<STDIN>', '$' . '*IN.lines');
}
else {
();
}
}
})
}))) {
do {
if (my ($C) = ($C->_OPTr(sub { my $C=shift;
$C->_BRACKETr(sub {
my $C=shift;
do {
if (my ($C) = ($C->before(sub { my $C=shift;
$C->_EXACT('>')
}))) {
$C->obs('<>', 'lines() or ()');
}
else {
();
}
}
})
}))) {
do {
if (my ($C) = ($C->_SUBSUMEr(['nibble'], sub {
my $C = shift;
$C->nibble($C->cursor_fresh( $::LANG{'Q'} )->tweak('q' => 1)->tweak('w' => 1)->balanced('<','>'))
}))) {
$C->_EXACT('>');
}
else {
();
}
};
}
else {
();
}
};
}
else {
();
}
};
}
else {
();
}
}
);
}

##################
# Lexer routines #
##################

## token ws
##      token ws {
##          :my @stub = return self if @*MEMOS[self.pos]<ws> :exists;
##          :my $startpos = self.pos;
##          :my $*HIGHEXPECT = {};
##      
##          :dba('whitespace')
##          [
##              | \h+ <![#\s\\]> { @*MEMOS[$.pos]<ws> = $startpos; }   # common case
##              | <?before \w> <?after \w> :::
##                  { @*MEMOS[$startpos]<ws>:delete; }
##                  <.panic: "Whitespace is required between alphanumeric tokens">        # must \s+ between words
##          ]
##          ||
##          [
##          | <.unsp>
##          | <.vws> <.heredoc>
##          | <.unv>
##          | $ { $.moreinput }
##          ]*
##      
##          {{
##              if ($.pos == $startpos) {
##                  @*MEMOS[$.pos]<ws>:delete;
##              }
##              else {
##                  @*MEMOS[$.pos]<ws> = $startpos;
##                  @*MEMOS[$.pos]<endstmt> = @*MEMOS[$startpos]<endstmt>
##                      if @*MEMOS[$startpos]<endstmt> :exists;
##              }
##          }}
##      }

sub ws__PEEK { '' }
sub ws {
no warnings 'recursion';
my $self = shift;
local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;
my @stub = return $self if exists $::MEMOS[$self->{'_pos'}]{'ws'};
my $startpos = $self->{'_pos'};
local $::HIGHEXPECT = {};


my $C = $self->cursor_xact("RULE ws");
my $xact = $C->xact;
my $S = $C->{'_pos'};

$self->_MATCHIFYr($S, "ws", 
do {
my $C = $C->cursor_xact('ALT ||');
my $xact = $C->xact;
my @gather;
do {
push @gather, $C->_BRACKETr(sub {
my $C=shift;
do {
my @result = do {
my $trystate;
my ($tag, $try);
my @try;
my $relex;

my $fate;
my $x;
if ($fate = $C->{'_fate'} and $fate->[1] eq 'ws_01') {
$C->deb("Fate passed to ws_01: ", ::fatestr($fate)) if $::DEBUG & DEBUG::fates;
($C->{'_fate'}, $tag, $try) = @$fate;
@try = ($try);
$x = 'ALT ws_01';    # some outer ltm is controlling us
}
else {
$x = 'ALTLTM ws_01'; # we are top level ltm
}
my $C = $C->cursor_xact($x);
my $xact = $C->xact;

my @gather = ();
for (;;) {
if (not @try) {
$relex //= $C->cursor_fate('STD', 'ws_01', $retree);
@try = $relex->($C, $trystate);
}
last unless @try;
$try = shift(@try) // next;

if (ref $try eq 'ARRAY') {
($C->{'_fate'}, $tag, $try) = @$try;	# next candidate fate
}

$C->deb("ws_01 trying $tag $try") if $::DEBUG & DEBUG::try_processing;
push @gather, ((
sub { my $C=shift;
do {
if (my ($C) = ($C->_PATTERN(qr/\G((?:[\x20\t\r])++)/))) {
do {
if (my ($C) = ($C->_NOTBEFORE( sub { my $C=shift;
$C->_PATTERN(qr/\G[#\s\\]/)
}))) {
scalar(do {
$::MEMOS[$C->{'_pos'}]{'ws'} = $startpos; 
}, $C);
}
else {
();
}
};
}
else {
();
}
}
},
sub { my $C=shift;
do {
if (my ($C) = ($C->before(sub { my $C=shift;
$C->_PATTERN(qr/\G\w/)
}))) {
do {
if (my ($C) = ($C->before( sub { my $C=shift;
$C->after(sub { my $C=shift;
$C->_PATTERN(qr/\G(?<=\w)/)
})
}))) {
do {
if (my ($C) = ($C->_COMMITRULE())) {
do {
if (my ($C) = (scalar(do {
delete $::MEMOS[$startpos]{'ws'}; 
}, $C))) {
$C->panic("Whitespace is required between alphanumeric tokens");
}
else {
();
}
};
}
else {
();
}
};
}
else {
();
}
};
}
else {
();
}
}
},
)[$try])->($C);
last if $xact->[-2];  # committed?
last if @gather;
}
@gather;
};
@result;
}

})
}
or $xact->[-2] or
do {
push @gather, do {
if (my ($C) = ($C->_STARr(sub { my $C=shift;
$C->_BRACKETr(sub {
my $C=shift;
do {
my @result = do {
my $trystate;
my ($tag, $try);
my @try;
my $relex;

my $fate;
my $x;
if ($fate = $C->{'_fate'} and $fate->[1] eq 'ws_05') {
$C->deb("Fate passed to ws_05: ", ::fatestr($fate)) if $::DEBUG & DEBUG::fates;
($C->{'_fate'}, $tag, $try) = @$fate;
@try = ($try);
$x = 'ALT ws_05';    # some outer ltm is controlling us
}
else {
$x = 'ALTLTM ws_05'; # we are top level ltm
}
my $C = $C->cursor_xact($x);
my $xact = $C->xact;

my @gather = ();
for (;;) {
if (not @try) {
$relex //= $C->cursor_fate('STD', 'ws_05', $retree);
@try = $relex->($C, $trystate);
}
last unless @try;
$try = shift(@try) // next;

if (ref $try eq 'ARRAY') {
($C->{'_fate'}, $tag, $try) = @$try;	# next candidate fate
}

$C->deb("ws_05 trying $tag $try") if $::DEBUG & DEBUG::try_processing;
push @gather, ((
sub { my $C=shift;
$C->unsp
},
sub { my $C=shift;
do {
if (my ($C) = ($C->vws)) {
$C->heredoc;
}
else {
();
}
}
},
sub { my $C=shift;
$C->unv
},
sub { my $C=shift;
do {
if (my ($C) = ($C->_PATTERN(qr/\G\z/))) {
scalar(do {
$C->moreinput 
}, $C);
}
else {
();
}
}
},
)[$try])->($C);
last if $xact->[-2];  # committed?
last if @gather;
}
@gather;
};
@result;
}

})
}))) {
scalar(do {

if (($C->{'_pos'} == $startpos)) {
delete $::MEMOS[$C->{'_pos'}]{'ws'};
}
else {
$::MEMOS[$C->{'_pos'}]{'ws'} = $startpos;
$::MEMOS[$C->{'_pos'}]{'endstmt'} = $::MEMOS[$startpos]{'endstmt'}
if exists $::MEMOS[$startpos]{'endstmt'};
}

}, $C);
}
else {
();
}
}};
@gather;
}
);
}

## token unsp
##      token unsp {
##          \\ <?before [\s|'#'] >
##          :dba('unspace')
##          [
##          | <.vws>
##          | <.unv>
##          | $ { $.moreinput }
##          ]*
##      }

sub unsp__PEEK { $_[0]->_AUTOLEXpeek('unsp',$retree) }
sub unsp {
no warnings 'recursion';
my $self = shift;
local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;


my $C = $self->cursor_xact("RULE unsp");
my $xact = $C->xact;
my $S = $C->{'_pos'};

$self->_MATCHIFYr($S, "unsp", 
do {
if (my ($C) = ($C->_EXACT('\\'))) {
do {
if (my ($C) = ($C->before(sub { my $C=shift;
$C->_BRACKETr(sub {
my $C=shift;
do {
my @result = do {
my $trystate;
my ($tag, $try);
my @try;
my $relex;

my $fate;
my $x;
if ($fate = $C->{'_fate'} and $fate->[1] eq 'unsp_02') {
$C->deb("Fate passed to unsp_02: ", ::fatestr($fate)) if $::DEBUG & DEBUG::fates;
($C->{'_fate'}, $tag, $try) = @$fate;
@try = ($try);
$x = 'ALT unsp_02';    # some outer ltm is controlling us
}
else {
$x = 'ALTLTM unsp_02'; # we are top level ltm
}
my $C = $C->cursor_xact($x);
my $xact = $C->xact;

my @gather = ();
for (;;) {
if (not @try) {
$relex //= $C->cursor_fate('STD', 'unsp_02', $retree);
@try = $relex->($C, $trystate);
}
last unless @try;
$try = shift(@try) // next;

if (ref $try eq 'ARRAY') {
($C->{'_fate'}, $tag, $try) = @$try;	# next candidate fate
}

$C->deb("unsp_02 trying $tag $try") if $::DEBUG & DEBUG::try_processing;
push @gather, ((
sub { my $C=shift;
$C->_PATTERN(qr/\G\s/)
},
sub { my $C=shift;
$C->_EXACT('#')
},
)[$try])->($C);
last if $xact->[-2];  # committed?
last if @gather;
}
@gather;
};
@result;
}

})
}))) {
$C->_STARr(sub { my $C=shift;
$C->_BRACKETr(sub {
my $C=shift;
do {
my @result = do {
my $trystate;
my ($tag, $try);
my @try;
my $relex;

my $fate;
my $x;
if ($fate = $C->{'_fate'} and $fate->[1] eq 'unsp_03') {
$C->deb("Fate passed to unsp_03: ", ::fatestr($fate)) if $::DEBUG & DEBUG::fates;
($C->{'_fate'}, $tag, $try) = @$fate;
@try = ($try);
$x = 'ALT unsp_03';    # some outer ltm is controlling us
}
else {
$x = 'ALTLTM unsp_03'; # we are top level ltm
}
my $C = $C->cursor_xact($x);
my $xact = $C->xact;

my @gather = ();
for (;;) {
if (not @try) {
$relex //= $C->cursor_fate('STD', 'unsp_03', $retree);
@try = $relex->($C, $trystate);
}
last unless @try;
$try = shift(@try) // next;

if (ref $try eq 'ARRAY') {
($C->{'_fate'}, $tag, $try) = @$try;	# next candidate fate
}

$C->deb("unsp_03 trying $tag $try") if $::DEBUG & DEBUG::try_processing;
push @gather, ((
sub { my $C=shift;
$C->vws
},
sub { my $C=shift;
$C->unv
},
sub { my $C=shift;
do {
if (my ($C) = ($C->_PATTERN(qr/\G\z/))) {
scalar(do {
$C->moreinput 
}, $C);
}
else {
();
}
}
},
)[$try])->($C);
last if $xact->[-2];  # committed?
last if @gather;
}
@gather;
};
@result;
}

})
});
}
else {
();
}
};
}
else {
();
}
}
);
}

## token vws
##      token vws {
##          :dba('vertical whitespace')
##          \v
##          [ '#DEBUG -1' { say "DEBUG"; $*DEBUG = -1; } ]?
##      }

sub vws__PEEK { $_[0]->_AUTOLEXpeek('vws',$retree) }
sub vws {
no warnings 'recursion';
my $self = shift;
local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;


my $C = $self->cursor_xact("RULE vws");
my $xact = $C->xact;
my $S = $C->{'_pos'};

$self->_MATCHIFYr($S, "vws", 
do {
if (my ($C) = ($C->_PATTERN(qr/\G[\n]/))) {
$C->_OPTr(sub { my $C=shift;
$C->_BRACKETr(sub {
my $C=shift;
do {
if (my ($C) = ($C->_EXACT('#DEBUG -1'))) {
scalar(do {
say "DEBUG"; $::DEBUG = -1; 
}, $C);
}
else {
();
}
}
})
});
}
else {
();
}
}
);
}

# We provide two mechanisms here:
# 1) define $*moreinput, or
# 2) override moreinput method
## method moreinput ()
sub moreinput {
my $self = shift;


$::moreinput->() if $::moreinput;
}

## token unv
##      token unv {
##         :dba('horizontal whitespace')
##         [
##         | \h+
##         | <?before \h* '=' [ \w | '\\'] > ^^ <.pod_comment>
##         | \h* <comment>
##         ]
##      }

sub unv__PEEK { $_[0]->_AUTOLEXpeek('unv',$retree) }
sub unv {
no warnings 'recursion';
my $self = shift;
local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;


my $C = $self->cursor_xact("RULE unv");
my $xact = $C->xact;
my $S = $C->{'_pos'};

$self->_MATCHIFYr($S, "unv", 
$C->_BRACKETr(sub {
my $C=shift;
do {
my @result = do {
my $trystate;
my ($tag, $try);
my @try;
my $relex;

my $fate;
my $x;
if ($fate = $C->{'_fate'} and $fate->[1] eq 'unv_01') {
$C->deb("Fate passed to unv_01: ", ::fatestr($fate)) if $::DEBUG & DEBUG::fates;
($C->{'_fate'}, $tag, $try) = @$fate;
@try = ($try);
$x = 'ALT unv_01';    # some outer ltm is controlling us
}
else {
$x = 'ALTLTM unv_01'; # we are top level ltm
}
my $C = $C->cursor_xact($x);
my $xact = $C->xact;

my @gather = ();
for (;;) {
if (not @try) {
$relex //= $C->cursor_fate('STD', 'unv_01', $retree);
@try = $relex->($C, $trystate);
}
last unless @try;
$try = shift(@try) // next;

if (ref $try eq 'ARRAY') {
($C->{'_fate'}, $tag, $try) = @$try;	# next candidate fate
}

$C->deb("unv_01 trying $tag $try") if $::DEBUG & DEBUG::try_processing;
push @gather, ((
sub { my $C=shift;
$C->_PATTERN(qr/\G((?:[\x20\t\r])++)/)
},
sub { my $C=shift;
do {
if (my ($C) = ($C->before(sub { my $C=shift;
do {
if (my ($C) = ($C->_PATTERN(qr/\G((?:[\x20\t\r])*+)/))) {
do {
if (my ($C) = ($C->_EXACT('='))) {
$C->_BRACKETr(sub {
my $C=shift;
do {
my @result = do {
my $trystate;
my ($tag, $try);
my @try;
my $relex;

my $fate;
my $x;
if ($fate = $C->{'_fate'} and $fate->[1] eq 'unv_03') {
$C->deb("Fate passed to unv_03: ", ::fatestr($fate)) if $::DEBUG & DEBUG::fates;
($C->{'_fate'}, $tag, $try) = @$fate;
@try = ($try);
$x = 'ALT unv_03';    # some outer ltm is controlling us
}
else {
$x = 'ALTLTM unv_03'; # we are top level ltm
}
my $C = $C->cursor_xact($x);
my $xact = $C->xact;

my @gather = ();
for (;;) {
if (not @try) {
$relex //= $C->cursor_fate('STD', 'unv_03', $retree);
@try = $relex->($C, $trystate);
}
last unless @try;
$try = shift(@try) // next;

if (ref $try eq 'ARRAY') {
($C->{'_fate'}, $tag, $try) = @$try;	# next candidate fate
}

$C->deb("unv_03 trying $tag $try") if $::DEBUG & DEBUG::try_processing;
push @gather, ((
sub { my $C=shift;
$C->_PATTERN(qr/\G\w/)
},
sub { my $C=shift;
$C->_EXACT('\\')
},
)[$try])->($C);
last if $xact->[-2];  # committed?
last if @gather;
}
@gather;
};
@result;
}

});
}
else {
();
}
};
}
else {
();
}
}
}))) {
do {
if (my ($C) = ($C->_PATTERN(qr/\G(?m:^)/))) {
$C->pod_comment;
}
else {
();
}
};
}
else {
();
}
}
},
sub { my $C=shift;
do {
if (my ($C) = ($C->_PATTERN(qr/\G((?:[\x20\t\r])*+)/))) {
$C->_SUBSUMEr(['comment'], sub {
my $C = shift;
$C->comment
});
}
else {
();
}
}
},
)[$try])->($C);
last if $xact->[-2];  # committed?
last if @gather;
}
@gather;
};
@result;
}

})
);
}

## token comment__S_054SharpGraveParenDotDotDotThesis (:$*sym = <#`(...)>)
##      token comment:sym<#`(...)> {
##          '#`' :: [ <?opener> || <.panic: "Opening bracket is required for #` comment"> ]
##          <.quibble($.cursor_fresh( %*LANG<Q> ))>
##      }

sub comment__S_054SharpGraveParenDotDotDotThesis__PEEK { $_[0]->_AUTOLEXpeek('comment__S_054SharpGraveParenDotDotDotThesis',$retree) }
sub comment__S_054SharpGraveParenDotDotDotThesis {
no warnings 'recursion';
my $self = shift;
local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;
my %args = @_;
local $::sym = $args{sym} // q[#`(...)];


my $C = $self->cursor_xact("RULE comment__S_054SharpGraveParenDotDotDotThesis");
my $xact = $C->xact;
my $S = $C->{'_pos'};
$C->{'sym'} = ref $sym ? join(' ', @$sym) : $sym;

$self->_MATCHIFYr($S, "comment__S_054SharpGraveParenDotDotDotThesis", 
do {
if (my ($C) = ($C->_EXACT('#`'))) {
do {
if (my ($C) = ($C->_COMMITLTM())) {
do {
if (my ($C) = ($C->_BRACKETr(sub {
my $C=shift;
do {
my $C = $C->cursor_xact('ALT ||');
my $xact = $C->xact;
my @gather;
do {
push @gather, $C->before( sub { my $C=shift;
$C->opener
})
}
or $xact->[-2] or
do {
push @gather, $C->panic("Opening bracket is required for #` comment")};
@gather;
}
}))) {
$C->quibble($C->cursor_fresh( $::LANG{'Q'} ));
}
else {
();
}
};
}
else {
();
}
};
}
else {
();
}
}
);
}

## token comment__S_055SharpParenDotDotDotThesis (:$*sym = <#(...)>)
##      token comment:sym<#(...)> {
##          '#' <?opener> <.worry: "Embedded comment without backtick is deprecated"> <!>
##          <.quibble($.cursor_fresh( %*LANG<Q> ))>
##      }

sub comment__S_055SharpParenDotDotDotThesis__PEEK { $_[0]->_AUTOLEXpeek('comment__S_055SharpParenDotDotDotThesis',$retree) }
sub comment__S_055SharpParenDotDotDotThesis {
no warnings 'recursion';
my $self = shift;
local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;
my %args = @_;
local $::sym = $args{sym} // q[#(...)];


my $C = $self->cursor_xact("RULE comment__S_055SharpParenDotDotDotThesis");
my $xact = $C->xact;
my $S = $C->{'_pos'};
$C->{'sym'} = ref $sym ? join(' ', @$sym) : $sym;

$self->_MATCHIFYr($S, "comment__S_055SharpParenDotDotDotThesis", 
do {
if (my ($C) = ($C->_EXACT('#'))) {
do {
if (my ($C) = ($C->before( sub { my $C=shift;
$C->opener
}))) {
do {
if (my ($C) = ($C->worry("Embedded comment without backtick is deprecated"))) {
do {
if (my ($C) = ($C->_NOTBEFORE( sub { my $C=shift;
$C
}))) {
$C->quibble($C->cursor_fresh( $::LANG{'Q'} ));
}
else {
();
}
};
}
else {
();
}
};
}
else {
();
}
};
}
else {
();
}
}
);
}

## token comment__S_056SharpEqualParenDotDotDotThesis (:$*sym = <#=(...)>)
##      token comment:sym<#=(...)> {
##          '#=' <?opener> ::
##          <quibble($.cursor_fresh( %*LANG<Q> ))>
##      }

sub comment__S_056SharpEqualParenDotDotDotThesis__PEEK { $_[0]->_AUTOLEXpeek('comment__S_056SharpEqualParenDotDotDotThesis',$retree) }
sub comment__S_056SharpEqualParenDotDotDotThesis {
no warnings 'recursion';
my $self = shift;
local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;
my %args = @_;
local $::sym = $args{sym} // q[#=(...)];


my $C = $self->cursor_xact("RULE comment__S_056SharpEqualParenDotDotDotThesis");
my $xact = $C->xact;
my $S = $C->{'_pos'};
$C->{'sym'} = ref $sym ? join(' ', @$sym) : $sym;

$self->_MATCHIFYr($S, "comment__S_056SharpEqualParenDotDotDotThesis", 
do {
if (my ($C) = ($C->_EXACT('#='))) {
do {
if (my ($C) = ($C->before( sub { my $C=shift;
$C->opener
}))) {
do {
if (my ($C) = ($C->_COMMITLTM())) {
$C->_SUBSUMEr(['quibble'], sub {
my $C = shift;
$C->quibble($C->cursor_fresh( $::LANG{'Q'} ))
});
}
else {
();
}
};
}
else {
();
}
};
}
else {
();
}
}
);
}

## token comment__S_057SharpEqual (:$*sym = <#=>)
##      token comment:sym<#=> {
##         '#=' :: $<attachment> = [\N*]
##      }

sub comment__S_057SharpEqual__PEEK { $_[0]->_AUTOLEXpeek('comment__S_057SharpEqual',$retree) }
sub comment__S_057SharpEqual {
no warnings 'recursion';
my $self = shift;
local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;
my %args = @_;
local $::sym = $args{sym} // q(#=);


my $C = $self->cursor_xact("RULE comment__S_057SharpEqual");
my $xact = $C->xact;
my $S = $C->{'_pos'};
$C->{'sym'} = ref $sym ? join(' ', @$sym) : $sym;

$self->_MATCHIFYr($S, "comment__S_057SharpEqual", 
do {
if (my ($C) = ($C->_EXACT('#='))) {
do {
if (my ($C) = ($C->_COMMITLTM())) {
$C->_SUBSUMEr(['attachment'], sub {
my $C = shift;
$C->_BRACKETr(sub {
my $C=shift;
$C->_STARr(sub { my $C=shift;
$C->_NOTCHAR( sub { my $C=shift;
$C->_EXACT("\n")
})
})
})
});
}
else {
();
}
};
}
else {
();
}
}
);
}

## token comment__S_058Sharp (:$*sym = <#>)
##      token comment:sym<#> {
##         '#' {} \N*
##      }

sub comment__S_058Sharp__PEEK { $_[0]->_AUTOLEXpeek('comment__S_058Sharp',$retree) }
sub comment__S_058Sharp {
no warnings 'recursion';
my $self = shift;
local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;
my %args = @_;
local $::sym = $args{sym} // q(#);


my $C = $self->cursor_xact("RULE comment__S_058Sharp");
my $xact = $C->xact;
my $S = $C->{'_pos'};
$C->{'sym'} = ref $sym ? join(' ', @$sym) : $sym;

$self->_MATCHIFYr($S, "comment__S_058Sharp", 
do {
if (my ($C) = ($C->_EXACT('#'))) {
do {
if (my ($C) = (scalar(do {

}, $C))) {
$C->_STARr(sub { my $C=shift;
$C->_NOTCHAR( sub { my $C=shift;
$C->_EXACT("\n")
})
});
}
else {
();
}
};
}
else {
();
}
}
);
}

## token ident
##      token ident {
##          <.alpha> \w*
##      }

sub ident__PEEK { $_[0]->_AUTOLEXpeek('ident',$retree) }
sub ident {
no warnings 'recursion';
my $self = shift;
local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;


my $C = $self->cursor_xact("RULE ident");
my $xact = $C->xact;
my $S = $C->{'_pos'};

$self->_MATCHIFYr($S, "ident", 
$C->_PATTERN(qr/\G[_[:alpha:]]((?:\w)*+)/)
);
}

## token apostrophe
##      token apostrophe {
##          <[ ' \- ]>
##      }

sub apostrophe__PEEK { $_[0]->_AUTOLEXpeek('apostrophe',$retree) }
sub apostrophe {
no warnings 'recursion';
my $self = shift;
local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;


my $C = $self->cursor_xact("RULE apostrophe");
my $xact = $C->xact;
my $S = $C->{'_pos'};

$self->_MATCHIFYr($S, "apostrophe", 
$C->_PATTERN(qr/\G['\-]/)
);
}

## token identifier
##      token identifier {
##          <.ident> [ <.apostrophe> <.ident> ]*
##      }

sub identifier__PEEK { $_[0]->_AUTOLEXpeek('identifier',$retree) }
sub identifier {
no warnings 'recursion';
my $self = shift;
local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;


my $C = $self->cursor_xact("RULE identifier");
my $xact = $C->xact;
my $S = $C->{'_pos'};

$self->_MATCHIFYr($S, "identifier", 
do {
if (my ($C) = ($C->ident)) {
$C->_STARr(sub { my $C=shift;
$C->_BRACKETr(sub {
my $C=shift;
do {
if (my ($C) = ($C->apostrophe)) {
$C->ident;
}
else {
();
}
}
})
});
}
else {
();
}
}
);
}

# XXX We need to parse the pod eventually to support $= variables.

## token pod_comment
##      token pod_comment {
##          ^^ \h* '=' <.unsp>?
##          [
##          | 'begin' \h+ <identifier> ::
##              [
##              || .*? "\n" [ :r \h* '=' <.unsp>? 'end' \h+ $<identifier>  \N* ]
##              || <?{ $<identifier>.Str eq 'END'}> .*
##              || { my $id = $<identifier>.Str; self.panic("=begin $id without matching =end $id"); }
##              ]
##          | 'begin'  :: \h* [ $$ || '#' || <.panic: "Unrecognized token after =begin"> ]
##              [ .*? "\n" \h* '=' <.unsp>? 'end'  \N* || { self.panic("=begin without matching =end"); } ]
##              
##          | 'for'  :: \h* [ <identifier> || $$ || '#' || <.panic: "Unrecognized token after =for"> ]
##              [.*?  ^^ \h* $$ || .*]
##          | :: 
##              [ <?before .*? ^^ '=cut'  > <.panic: "Obsolescent pod format, please use =begin/=end instead"> ]?
##              [<alpha>||\s||<.panic: "Illegal pod directive">]
##              \N*
##          ]
##      }

sub pod_comment__PEEK { $_[0]->_AUTOLEXpeek('pod_comment',$retree) }
sub pod_comment {
no warnings 'recursion';
my $self = shift;
local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;


my $C = $self->cursor_xact("RULE pod_comment");
my $xact = $C->xact;
my $S = $C->{'_pos'};

$self->_MATCHIFYr($S, "pod_comment", 
do {
if (my ($C) = ($C->_PATTERN(qr/\G(?m:^)/))) {
do {
if (my ($C) = ($C->_PATTERN(qr/\G((?:[\x20\t\r])*+)/))) {
do {
if (my ($C) = ($C->_EXACT('='))) {
do {
if (my ($C) = ($C->_OPTr(sub { my $C=shift;
$C->unsp
}))) {
$C->_BRACKETr(sub {
my $C=shift;
do {
my @result = do {
my $trystate;
my ($tag, $try);
my @try;
my $relex;

my $fate;
my $x;
if ($fate = $C->{'_fate'} and $fate->[1] eq 'pod_comment_01') {
$C->deb("Fate passed to pod_comment_01: ", ::fatestr($fate)) if $::DEBUG & DEBUG::fates;
($C->{'_fate'}, $tag, $try) = @$fate;
@try = ($try);
$x = 'ALT pod_comment_01';    # some outer ltm is controlling us
}
else {
$x = 'ALTLTM pod_comment_01'; # we are top level ltm
}
my $C = $C->cursor_xact($x);
my $xact = $C->xact;

my @gather = ();
for (;;) {
if (not @try) {
$relex //= $C->cursor_fate('STD', 'pod_comment_01', $retree);
@try = $relex->($C, $trystate);
}
last unless @try;
$try = shift(@try) // next;

if (ref $try eq 'ARRAY') {
($C->{'_fate'}, $tag, $try) = @$try;	# next candidate fate
}

$C->deb("pod_comment_01 trying $tag $try") if $::DEBUG & DEBUG::try_processing;
push @gather, ((
sub { my $C=shift;
do {
if (my ($C) = ($C->_EXACT('begin'))) {
do {
if (my ($C) = ($C->_PATTERN(qr/\G((?:[\x20\t\r])++)/))) {
do {
if (my ($C) = ($C->_SUBSUMEr(['identifier'], sub {
my $C = shift;
$C->identifier
}))) {
do {
if (my ($C) = ($C->_COMMITLTM())) {
$C->_BRACKETr(sub {
my $C=shift;
do {
my $C = $C->cursor_xact('ALT ||');
my $xact = $C->xact;
my @gather;
do {
push @gather, Cursor::lazymap(sub {
my $C=$_[0];
Cursor::lazymap(sub {
my $C=$_[0];
$C->_BRACKET(sub {
my $C=shift;
Cursor::lazymap(sub {
my $C=$_[0];
Cursor::lazymap(sub {
my $C=$_[0];
Cursor::lazymap(sub {
my $C=$_[0];
Cursor::lazymap(sub {
my $C=$_[0];
Cursor::lazymap(sub {
my $C=$_[0];
Cursor::lazymap(sub {
my $C=$_[0];
Cursor::lazymap(sub {
my $C=$_[0];
$C->_STARr(sub { my $C=shift;
$C->_NOTCHAR( sub { my $C=shift;
$C->_EXACT("\n")
})
})
}, $C->_PATTERN(qr/\G\b/))
}, $C->_BACKREFn('identifier'))
}, $C->_PATTERN(qr/\G((?:[\x20\t\r])++)/))
}, $C->_EXACT('end'))
}, $C->_OPTr(sub { my $C=shift;
$C->unsp
}))
}, $C->_EXACT('='))
}, $C->_PATTERN(qr/\G((?:[\x20\t\r])*+)/))
})
}, $C->_PATTERN(qr/\G\n/))
}, $C->_SCANf())
}
or $xact->[-2] or
do {
push @gather, Cursor::lazymap(sub {
my $C=$_[0];
$C->_SCANg()
}, $C->before( sub { my $C=shift;
(($C) x !!do {
my $M = $C;  $M->{'identifier'}->Str eq 'END';
})
}))
}
or $xact->[-2] or
do {
push @gather, scalar(do {
my $M = $C;  my $id = $M->{'identifier'}->Str; $self->panic("=begin $id without matching =end $id"); ;
}, $C)};
@gather;
}
});
}
else {
();
}
};
}
else {
();
}
};
}
else {
();
}
};
}
else {
();
}
}
},
sub { my $C=shift;
do {
if (my ($C) = ($C->_EXACT('begin'))) {
do {
if (my ($C) = ($C->_PATTERN(qr/\G\b/))) {
do {
if (my ($C) = ($C->_COMMITLTM())) {
do {
if (my ($C) = ($C->_PATTERN(qr/\G((?:[\x20\t\r])*+)/))) {
do {
if (my ($C) = ($C->_BRACKETr(sub {
my $C=shift;
do {
my $C = $C->cursor_xact('ALT ||');
my $xact = $C->xact;
my @gather;
do {
push @gather, $C->_PATTERN(qr/\G(?m:$)/)
}
or $xact->[-2] or
do {
push @gather, $C->_EXACT('#')
}
or $xact->[-2] or
do {
push @gather, $C->panic("Unrecognized token after =begin")};
@gather;
}
}))) {
$C->_BRACKETr(sub {
my $C=shift;
do {
my $C = $C->cursor_xact('ALT ||');
my $xact = $C->xact;
my @gather;
do {
push @gather, Cursor::lazymap(sub {
my $C=$_[0];
Cursor::lazymap(sub {
my $C=$_[0];
Cursor::lazymap(sub {
my $C=$_[0];
Cursor::lazymap(sub {
my $C=$_[0];
Cursor::lazymap(sub {
my $C=$_[0];
Cursor::lazymap(sub {
my $C=$_[0];
Cursor::lazymap(sub {
my $C=$_[0];
$C->_STARr(sub { my $C=shift;
$C->_NOTCHAR( sub { my $C=shift;
$C->_EXACT("\n")
})
})
}, $C->_PATTERN(qr/\G\b/))
}, $C->_EXACT('end'))
}, $C->_OPTr(sub { my $C=shift;
$C->unsp
}))
}, $C->_EXACT('='))
}, $C->_PATTERN(qr/\G((?:[\x20\t\r])*+)/))
}, $C->_PATTERN(qr/\G\n/))
}, $C->_SCANf())
}
or $xact->[-2] or
do {
push @gather, scalar(do {
$self->panic("=begin without matching =end"); 
}, $C)};
@gather;
}
});
}
else {
();
}
};
}
else {
();
}
};
}
else {
();
}
};
}
else {
();
}
};
}
else {
();
}
}
},
sub { my $C=shift;
do {
if (my ($C) = ($C->_EXACT('for'))) {
do {
if (my ($C) = ($C->_PATTERN(qr/\G\b/))) {
do {
if (my ($C) = ($C->_COMMITLTM())) {
do {
if (my ($C) = ($C->_PATTERN(qr/\G((?:[\x20\t\r])*+)/))) {
do {
if (my ($C) = ($C->_BRACKETr(sub {
my $C=shift;
do {
my $C = $C->cursor_xact('ALT ||');
my $xact = $C->xact;
my @gather;
do {
push @gather, $C->_SUBSUMEr(['identifier'], sub {
my $C = shift;
$C->identifier
})
}
or $xact->[-2] or
do {
push @gather, $C->_PATTERN(qr/\G(?m:$)/)
}
or $xact->[-2] or
do {
push @gather, $C->_EXACT('#')
}
or $xact->[-2] or
do {
push @gather, $C->panic("Unrecognized token after =for")};
@gather;
}
}))) {
$C->_BRACKETr(sub {
my $C=shift;
do {
my $C = $C->cursor_xact('ALT ||');
my $xact = $C->xact;
my @gather;
do {
push @gather, Cursor::lazymap(sub {
my $C=$_[0];
Cursor::lazymap(sub {
my $C=$_[0];
Cursor::lazymap(sub {
my $C=$_[0];
$C->_PATTERN(qr/\G(?m:$)/)
}, $C->_PATTERN(qr/\G((?:[\x20\t\r])*+)/))
}, $C->_PATTERN(qr/\G(?m:^)/))
}, $C->_SCANf())
}
or $xact->[-2] or
do {
push @gather, $C->_SCANg()};
@gather;
}
});
}
else {
();
}
};
}
else {
();
}
};
}
else {
();
}
};
}
else {
();
}
};
}
else {
();
}
}
},
sub { my $C=shift;
do {
if (my ($C) = ($C->_COMMITLTM())) {
do {
if (my ($C) = ($C->_OPTr(sub { my $C=shift;
$C->_BRACKETr(sub {
my $C=shift;
Cursor::lazymap(sub {
my $C=$_[0];
$C->panic("Obsolescent pod format, please use =begin/=end instead")
}, $C->before(sub { my $C=shift;
Cursor::lazymap(sub {
my $C=$_[0];
Cursor::lazymap(sub {
my $C=$_[0];
Cursor::lazymap(sub {
my $C=$_[0];
$C->_PATTERN(qr/\G\b/)
}, $C->_EXACT('=cut'))
}, $C->_PATTERN(qr/\G(?m:^)/))
}, $C->_SCANf())
}))
})
}))) {
do {
if (my ($C) = ($C->_BRACKETr(sub {
my $C=shift;
do {
my $C = $C->cursor_xact('ALT ||');
my $xact = $C->xact;
my @gather;
do {
push @gather, $C->_PATTERN(qr/\G[_[:alpha:]]/)
}
or $xact->[-2] or
do {
push @gather, $C->_PATTERN(qr/\G\s/)
}
or $xact->[-2] or
do {
push @gather, $C->panic("Illegal pod directive")};
@gather;
}
}))) {
$C->_STARr(sub { my $C=shift;
$C->_NOTCHAR( sub { my $C=shift;
$C->_EXACT("\n")
})
});
}
else {
();
}
};
}
else {
();
}
};
}
else {
();
}
}
},
)[$try])->($C);
last if $xact->[-2];  # committed?
last if @gather;
}
@gather;
};
@result;
}

});
}
else {
();
}
};
}
else {
();
}
};
}
else {
();
}
};
}
else {
();
}
}
);
}

# suppress fancy end-of-line checking
## token embeddedblock
##      token embeddedblock {
##          # encapsulate braided languages
##          :temp %*LANG;
##          :my $*SIGNUM;
##          :my $*GOAL ::= '}';
##          :temp $*CURPAD;
##      
##          :dba('embedded block')
##      
##          <.newpad>
##          <.finishpad>
##          '{' :: [ :lang($.cursor_fresh(%*LANG<MAIN>)) <statementlist> ]
##          [ '}' || <.panic: "Unable to parse statement list; couldn't find right brace"> ]
##      }

sub embeddedblock__PEEK { $_[0]->_AUTOLEXpeek('embeddedblock',$retree) }
sub embeddedblock {
no warnings 'recursion';
my $self = shift;
local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;
local %::LANG = %::LANG;
local $::SIGNUM;
local $::GOAL = '}';
local $::CURPAD = $::CURPAD;


my $C = $self->cursor_xact("RULE embeddedblock");
my $xact = $C->xact;
my $S = $C->{'_pos'};

$self->_MATCHIFYr($S, "embeddedblock", 
do {
if (my ($C) = ($C->newpad)) {
do {
if (my ($C) = ($C->finishpad)) {
do {
if (my ($C) = ($C->_EXACT('{'))) {
do {
if (my ($C) = ($C->_COMMITLTM())) {
do {
if (my ($C) = ($C->_BRACKETr(sub {
my $C=shift;
my $newlang = ($C->cursor_fresh($::LANG{'MAIN'}));  $C = $C->cursor_fresh($newlang); ;$C->_SUBSUMEr(['statementlist'], sub {
my $C = shift;
$C->statementlist
})
}))) {
$C->_BRACKETr(sub {
my $C=shift;
do {
my $C = $C->cursor_xact('ALT ||');
my $xact = $C->xact;
my @gather;
do {
push @gather, $C->_EXACT('}')
}
or $xact->[-2] or
do {
push @gather, $C->panic("Unable to parse statement list; couldn't find right brace")};
@gather;
}
});
}
else {
();
}
};
}
else {
();
}
};
}
else {
();
}
};
}
else {
();
}
};
}
else {
();
}
}
);
}

## token binints
##      token binints { [<.ws><binint><.ws>] ** ',' }

sub binints__PEEK { $_[0]->_AUTOLEXpeek('binints',$retree) }
sub binints {
no warnings 'recursion';
my $self = shift;
local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;


my $C = $self->cursor_xact("RULE binints");
my $xact = $C->xact;
my $S = $C->{'_pos'};
$C->{'binint'} = [];

$self->_MATCHIFYr($S, "binints", 
$C->_REPSEPr(  sub { my $C=shift;
$C->_EXACT(',')
}, sub { my $C=shift;
$C->_BRACKETr(sub {
my $C=shift;
do {
if (my ($C) = ($C->ws)) {
do {
if (my ($C) = ($C->_SUBSUMEr(['binint'], sub {
my $C = shift;
$C->binint
}))) {
$C->ws;
}
else {
();
}
};
}
else {
();
}
}
})
})
);
}

## token binint
##      token binint {
##          <[ 0..1 ]>+ [ _ <[ 0..1 ]>+ ]*
##      }

sub binint__PEEK { $_[0]->_AUTOLEXpeek('binint',$retree) }
sub binint {
no warnings 'recursion';
my $self = shift;
local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;


my $C = $self->cursor_xact("RULE binint");
my $xact = $C->xact;
my $S = $C->{'_pos'};

$self->_MATCHIFYr($S, "binint", 
do {
if (my ($C) = ($C->_PATTERN(qr/\G((?:[0-1])++)/))) {
$C->_STARr(sub { my $C=shift;
$C->_BRACKETr(sub {
my $C=shift;
do {
if (my ($C) = ($C->_EXACT('_'))) {
$C->_PATTERN(qr/\G((?:[0-1])++)/);
}
else {
();
}
}
})
});
}
else {
();
}
}
);
}

## token octints
##      token octints { [<.ws><octint><.ws>] ** ',' }

sub octints__PEEK { $_[0]->_AUTOLEXpeek('octints',$retree) }
sub octints {
no warnings 'recursion';
my $self = shift;
local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;


my $C = $self->cursor_xact("RULE octints");
my $xact = $C->xact;
my $S = $C->{'_pos'};
$C->{'octint'} = [];

$self->_MATCHIFYr($S, "octints", 
$C->_REPSEPr(  sub { my $C=shift;
$C->_EXACT(',')
}, sub { my $C=shift;
$C->_BRACKETr(sub {
my $C=shift;
do {
if (my ($C) = ($C->ws)) {
do {
if (my ($C) = ($C->_SUBSUMEr(['octint'], sub {
my $C = shift;
$C->octint
}))) {
$C->ws;
}
else {
();
}
};
}
else {
();
}
}
})
})
);
}

## token octint
##      token octint {
##          <[ 0..7 ]>+ [ _ <[ 0..7 ]>+ ]*
##      }

sub octint__PEEK { $_[0]->_AUTOLEXpeek('octint',$retree) }
sub octint {
no warnings 'recursion';
my $self = shift;
local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;


my $C = $self->cursor_xact("RULE octint");
my $xact = $C->xact;
my $S = $C->{'_pos'};

$self->_MATCHIFYr($S, "octint", 
do {
if (my ($C) = ($C->_PATTERN(qr/\G((?:[0-7])++)/))) {
$C->_STARr(sub { my $C=shift;
$C->_BRACKETr(sub {
my $C=shift;
do {
if (my ($C) = ($C->_EXACT('_'))) {
$C->_PATTERN(qr/\G((?:[0-7])++)/);
}
else {
();
}
}
})
});
}
else {
();
}
}
);
}

## token hexints
##      token hexints { [<.ws><hexint><.ws>] ** ',' }

sub hexints__PEEK { $_[0]->_AUTOLEXpeek('hexints',$retree) }
sub hexints {
no warnings 'recursion';
my $self = shift;
local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;


my $C = $self->cursor_xact("RULE hexints");
my $xact = $C->xact;
my $S = $C->{'_pos'};
$C->{'hexint'} = [];

$self->_MATCHIFYr($S, "hexints", 
$C->_REPSEPr(  sub { my $C=shift;
$C->_EXACT(',')
}, sub { my $C=shift;
$C->_BRACKETr(sub {
my $C=shift;
do {
if (my ($C) = ($C->ws)) {
do {
if (my ($C) = ($C->_SUBSUMEr(['hexint'], sub {
my $C = shift;
$C->hexint
}))) {
$C->ws;
}
else {
();
}
};
}
else {
();
}
}
})
})
);
}

## token hexint
##      token hexint {
##          <[ 0..9 a..f A..F ]>+ [ _ <[ 0..9 a..f A..F ]>+ ]*
##      }

sub hexint__PEEK { $_[0]->_AUTOLEXpeek('hexint',$retree) }
sub hexint {
no warnings 'recursion';
my $self = shift;
local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;


my $C = $self->cursor_xact("RULE hexint");
my $xact = $C->xact;
my $S = $C->{'_pos'};

$self->_MATCHIFYr($S, "hexint", 
do {
if (my ($C) = ($C->_PATTERN(qr/\G((?:[0-9a-fA-F])++)/))) {
$C->_STARr(sub { my $C=shift;
$C->_BRACKETr(sub {
my $C=shift;
do {
if (my ($C) = ($C->_EXACT('_'))) {
$C->_PATTERN(qr/\G((?:[0-9a-fA-F])++)/);
}
else {
();
}
}
})
});
}
else {
();
}
}
);
}

## token decints
##      token decints { [<.ws><decint><.ws>] ** ',' }

sub decints__PEEK { $_[0]->_AUTOLEXpeek('decints',$retree) }
sub decints {
no warnings 'recursion';
my $self = shift;
local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;


my $C = $self->cursor_xact("RULE decints");
my $xact = $C->xact;
my $S = $C->{'_pos'};
$C->{'decint'} = [];

$self->_MATCHIFYr($S, "decints", 
$C->_REPSEPr(  sub { my $C=shift;
$C->_EXACT(',')
}, sub { my $C=shift;
$C->_BRACKETr(sub {
my $C=shift;
do {
if (my ($C) = ($C->ws)) {
do {
if (my ($C) = ($C->_SUBSUMEr(['decint'], sub {
my $C = shift;
$C->decint
}))) {
$C->ws;
}
else {
();
}
};
}
else {
();
}
}
})
})
);
}

## token decint
##      token decint {
##          \d+ [ _ \d+ ]*
##      }

sub decint__PEEK { $_[0]->_AUTOLEXpeek('decint',$retree) }
sub decint {
no warnings 'recursion';
my $self = shift;
local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;


my $C = $self->cursor_xact("RULE decint");
my $xact = $C->xact;
my $S = $C->{'_pos'};

$self->_MATCHIFYr($S, "decint", 
do {
if (my ($C) = ($C->_PATTERN(qr/\G((?:\d)++)/))) {
$C->_STARr(sub { my $C=shift;
$C->_BRACKETr(sub {
my $C=shift;
do {
if (my ($C) = ($C->_EXACT('_'))) {
$C->_PATTERN(qr/\G((?:\d)++)/);
}
else {
();
}
}
})
});
}
else {
();
}
}
);
}

## token integer
##      token integer {
##          [
##          | 0 [ b <binint>
##              | o <octint>
##              | x <hexint>
##              | d <decint>
##              | <decint>
##                  <!!{ $.worry("Leading 0 does not indicate octal in Perl 6") }>
##              ]
##          | <decint>
##          ]
##          <!!before ['.' <?before \s | ',' | '=' | <terminator> > <.panic: "Decimal point must be followed by digit">]? >
##      }

sub integer__PEEK { $_[0]->_AUTOLEXpeek('integer',$retree) }
sub integer {
no warnings 'recursion';
my $self = shift;
local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;


my $C = $self->cursor_xact("RULE integer");
my $xact = $C->xact;
my $S = $C->{'_pos'};

$self->_MATCHIFYr($S, "integer", 
do {
if (my ($C) = ($C->_BRACKETr(sub {
my $C=shift;
do {
my @result = do {
my $trystate;
my ($tag, $try);
my @try;
my $relex;

my $fate;
my $x;
if ($fate = $C->{'_fate'} and $fate->[1] eq 'integer_01') {
$C->deb("Fate passed to integer_01: ", ::fatestr($fate)) if $::DEBUG & DEBUG::fates;
($C->{'_fate'}, $tag, $try) = @$fate;
@try = ($try);
$x = 'ALT integer_01';    # some outer ltm is controlling us
}
else {
$x = 'ALTLTM integer_01'; # we are top level ltm
}
my $C = $C->cursor_xact($x);
my $xact = $C->xact;

my @gather = ();
for (;;) {
if (not @try) {
$relex //= $C->cursor_fate('STD', 'integer_01', $retree);
@try = $relex->($C, $trystate);
}
last unless @try;
$try = shift(@try) // next;

if (ref $try eq 'ARRAY') {
($C->{'_fate'}, $tag, $try) = @$try;	# next candidate fate
}

$C->deb("integer_01 trying $tag $try") if $::DEBUG & DEBUG::try_processing;
push @gather, ((
sub { my $C=shift;
do {
if (my ($C) = ($C->_EXACT('0'))) {
$C->_BRACKETr(sub {
my $C=shift;
do {
my @result = do {
my $trystate;
my ($tag, $try);
my @try;
my $relex;

my $fate;
my $x;
if ($fate = $C->{'_fate'} and $fate->[1] eq 'integer_02') {
$C->deb("Fate passed to integer_02: ", ::fatestr($fate)) if $::DEBUG & DEBUG::fates;
($C->{'_fate'}, $tag, $try) = @$fate;
@try = ($try);
$x = 'ALT integer_02';    # some outer ltm is controlling us
}
else {
$x = 'ALTLTM integer_02'; # we are top level ltm
}
my $C = $C->cursor_xact($x);
my $xact = $C->xact;

my @gather = ();
for (;;) {
if (not @try) {
$relex //= $C->cursor_fate('STD', 'integer_02', $retree);
@try = $relex->($C, $trystate);
}
last unless @try;
$try = shift(@try) // next;

if (ref $try eq 'ARRAY') {
($C->{'_fate'}, $tag, $try) = @$try;	# next candidate fate
}

$C->deb("integer_02 trying $tag $try") if $::DEBUG & DEBUG::try_processing;
push @gather, ((
sub { my $C=shift;
do {
if (my ($C) = ($C->_EXACT('b'))) {
$C->_SUBSUMEr(['binint'], sub {
my $C = shift;
$C->binint
});
}
else {
();
}
}
},
sub { my $C=shift;
do {
if (my ($C) = ($C->_EXACT('o'))) {
$C->_SUBSUMEr(['octint'], sub {
my $C = shift;
$C->octint
});
}
else {
();
}
}
},
sub { my $C=shift;
do {
if (my ($C) = ($C->_EXACT('x'))) {
$C->_SUBSUMEr(['hexint'], sub {
my $C = shift;
$C->hexint
});
}
else {
();
}
}
},
sub { my $C=shift;
do {
if (my ($C) = ($C->_EXACT('d'))) {
$C->_SUBSUMEr(['decint'], sub {
my $C = shift;
$C->decint
});
}
else {
();
}
}
},
sub { my $C=shift;
do {
if (my ($C) = ($C->_SUBSUMEr(['decint'], sub {
my $C = shift;
$C->decint
}))) {
$C->_NOTBEFORE( sub { my $C=shift;
$C->_NOTBEFORE( sub { my $C=shift;
(($C) x !!do {
$C->worry("Leading 0 does not indicate octal in Perl 6") 
})
})
});
}
else {
();
}
}
},
)[$try])->($C);
last if $xact->[-2];  # committed?
last if @gather;
}
@gather;
};
@result;
}

});
}
else {
();
}
}
},
sub { my $C=shift;
$C->_SUBSUMEr(['decint'], sub {
my $C = shift;
$C->decint
})
},
)[$try])->($C);
last if $xact->[-2];  # committed?
last if @gather;
}
@gather;
};
@result;
}

}))) {
$C->_NOTBEFORE( sub { my $C=shift;
$C->_NOTBEFORE( sub { my $C=shift;
$C->before(sub { my $C=shift;
$C->_OPTr(sub { my $C=shift;
$C->_BRACKETr(sub {
my $C=shift;
do {
if (my ($C) = ($C->_EXACT('.'))) {
do {
if (my ($C) = ($C->before(sub { my $C=shift;
do {
my @result = do {
my $trystate;
my ($tag, $try);
my @try;
my $relex;

my $fate;
my $x;
if ($fate = $C->{'_fate'} and $fate->[1] eq 'integer_05') {
$C->deb("Fate passed to integer_05: ", ::fatestr($fate)) if $::DEBUG & DEBUG::fates;
($C->{'_fate'}, $tag, $try) = @$fate;
@try = ($try);
$x = 'ALT integer_05';    # some outer ltm is controlling us
}
else {
$x = 'ALTLTM integer_05'; # we are top level ltm
}
my $C = $C->cursor_xact($x);
my $xact = $C->xact;

my @gather = ();
for (;;) {
if (not @try) {
$relex //= $C->cursor_fate('STD', 'integer_05', $retree);
@try = $relex->($C, $trystate);
}
last unless @try;
$try = shift(@try) // next;

if (ref $try eq 'ARRAY') {
($C->{'_fate'}, $tag, $try) = @$try;	# next candidate fate
}

$C->deb("integer_05 trying $tag $try") if $::DEBUG & DEBUG::try_processing;
push @gather, ((
sub { my $C=shift;
$C->_PATTERN(qr/\G\s/)
},
sub { my $C=shift;
$C->_EXACT(',')
},
sub { my $C=shift;
$C->_EXACT('=')
},
sub { my $C=shift;
$C->_SUBSUMEr(['terminator'], sub {
my $C = shift;
$C->terminator
})
},
)[$try])->($C);
last if $xact->[-2];  # committed?
last if @gather;
}
@gather;
};
@result;
}

}))) {
$C->panic("Decimal point must be followed by digit");
}
else {
();
}
};
}
else {
();
}
}
})
})
})
})
});
}
else {
();
}
}
);
}

## token radint
##      token radint {
##          [
##          | <integer>
##          | <?before ':'\d> <rad_number> <?{
##                              defined $<rad_number><intpart>
##                              and
##                              not defined $<rad_number><fracpart>
##                          }>
##          ]
##      }

sub radint__PEEK { $_[0]->_AUTOLEXpeek('radint',$retree) }
sub radint {
no warnings 'recursion';
my $self = shift;
local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;


my $C = $self->cursor_xact("RULE radint");
my $xact = $C->xact;
my $S = $C->{'_pos'};

$self->_MATCHIFYr($S, "radint", 
$C->_BRACKETr(sub {
my $C=shift;
do {
my @result = do {
my $trystate;
my ($tag, $try);
my @try;
my $relex;

my $fate;
my $x;
if ($fate = $C->{'_fate'} and $fate->[1] eq 'radint_01') {
$C->deb("Fate passed to radint_01: ", ::fatestr($fate)) if $::DEBUG & DEBUG::fates;
($C->{'_fate'}, $tag, $try) = @$fate;
@try = ($try);
$x = 'ALT radint_01';    # some outer ltm is controlling us
}
else {
$x = 'ALTLTM radint_01'; # we are top level ltm
}
my $C = $C->cursor_xact($x);
my $xact = $C->xact;

my @gather = ();
for (;;) {
if (not @try) {
$relex //= $C->cursor_fate('STD', 'radint_01', $retree);
@try = $relex->($C, $trystate);
}
last unless @try;
$try = shift(@try) // next;

if (ref $try eq 'ARRAY') {
($C->{'_fate'}, $tag, $try) = @$try;	# next candidate fate
}

$C->deb("radint_01 trying $tag $try") if $::DEBUG & DEBUG::try_processing;
push @gather, ((
sub { my $C=shift;
$C->_SUBSUMEr(['integer'], sub {
my $C = shift;
$C->integer
})
},
sub { my $C=shift;
do {
if (my ($C) = ($C->before(sub { my $C=shift;
do {
if (my ($C) = ($C->_EXACT(':'))) {
$C->_PATTERN(qr/\G\d/);
}
else {
();
}
}
}))) {
do {
if (my ($C) = ($C->_SUBSUMEr(['rad_number'], sub {
my $C = shift;
$C->rad_number
}))) {
$C->before( sub { my $C=shift;
(($C) x !!do {
my $M = $C; 
defined $M->{'rad_number'}{'intpart'}
and
not defined $M->{'rad_number'}{'fracpart'}
;
})
});
}
else {
();
}
};
}
else {
();
}
}
},
)[$try])->($C);
last if $xact->[-2];  # committed?
last if @gather;
}
@gather;
};
@result;
}

})
);
}

## token escale
##      token escale {
##          <[Ee]> <[+\-]>? <decint>
##      }

sub escale__PEEK { $_[0]->_AUTOLEXpeek('escale',$retree) }
sub escale {
no warnings 'recursion';
my $self = shift;
local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;


my $C = $self->cursor_xact("RULE escale");
my $xact = $C->xact;
my $S = $C->{'_pos'};

$self->_MATCHIFYr($S, "escale", 
do {
if (my ($C) = ($C->_PATTERN(qr/\G[Ee]/))) {
do {
if (my ($C) = ($C->_PATTERN(qr/\G((?:[+\-])?+)/))) {
$C->_SUBSUMEr(['decint'], sub {
my $C = shift;
$C->decint
});
}
else {
();
}
};
}
else {
();
}
}
);
}

# careful to distinguish from both integer and 42.method
## token dec_number
##      token dec_number {
##          :dba('decimal number')
##          [
##          | $<coeff> = [              '.' <frac=.decint> ] <escale>?
##          | $<coeff> = [<int=.decint> '.' <frac=.decint> ] <escale>?
##          | $<coeff> = [<int=.decint>                    ] <escale>
##          ]
##          <!!before [ '.' <?before \d> <.panic: "Number contains two decimal points (missing 'v' for version number?)">]? >
##      }

sub dec_number__PEEK { $_[0]->_AUTOLEXpeek('dec_number',$retree) }
sub dec_number {
no warnings 'recursion';
my $self = shift;
local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;


my $C = $self->cursor_xact("RULE dec_number");
my $xact = $C->xact;
my $S = $C->{'_pos'};
$C->{'escale'} = [];

$self->_MATCHIFYr($S, "dec_number", 
do {
if (my ($C) = ($C->_BRACKETr(sub {
my $C=shift;
do {
my @result = do {
my $trystate;
my ($tag, $try);
my @try;
my $relex;

my $fate;
my $x;
if ($fate = $C->{'_fate'} and $fate->[1] eq 'dec_number_01') {
$C->deb("Fate passed to dec_number_01: ", ::fatestr($fate)) if $::DEBUG & DEBUG::fates;
($C->{'_fate'}, $tag, $try) = @$fate;
@try = ($try);
$x = 'ALT dec_number_01';    # some outer ltm is controlling us
}
else {
$x = 'ALTLTM dec_number_01'; # we are top level ltm
}
my $C = $C->cursor_xact($x);
my $xact = $C->xact;

my @gather = ();
for (;;) {
if (not @try) {
$relex //= $C->cursor_fate('STD', 'dec_number_01', $retree);
@try = $relex->($C, $trystate);
}
last unless @try;
$try = shift(@try) // next;

if (ref $try eq 'ARRAY') {
($C->{'_fate'}, $tag, $try) = @$try;	# next candidate fate
}

$C->deb("dec_number_01 trying $tag $try") if $::DEBUG & DEBUG::try_processing;
push @gather, ((
sub { my $C=shift;
do {
if (my ($C) = (  $C->_SUBSUMEr(['coeff'], sub {
my $C = shift;
$C->_BRACKETr(sub {
my $C=shift;
do {
if (my ($C) = ($C->_EXACT('.'))) {
$C->_SUBSUMEr(['frac'], sub {
my $C = shift;
$C->decint
});
}
else {
();
}
}
})
}))) {
$C->_OPTr(sub { my $C=shift;
$C->_SUBSUMEr(['escale'], sub {
my $C = shift;
$C->escale
})
});
}
else {
();
}
}
},
sub { my $C=shift;
do {
if (my ($C) = (  $C->_SUBSUMEr(['coeff'], sub {
my $C = shift;
$C->_BRACKETr(sub {
my $C=shift;
do {
if (my ($C) = (  $C->_SUBSUMEr(['int'], sub {
my $C = shift;
$C->decint
}))) {
do {
if (my ($C) = ($C->_EXACT('.'))) {
$C->_SUBSUMEr(['frac'], sub {
my $C = shift;
$C->decint
});
}
else {
();
}
};
}
else {
();
}
}
})
}))) {
$C->_OPTr(sub { my $C=shift;
$C->_SUBSUMEr(['escale'], sub {
my $C = shift;
$C->escale
})
});
}
else {
();
}
}
},
sub { my $C=shift;
do {
if (my ($C) = (  $C->_SUBSUMEr(['coeff'], sub {
my $C = shift;
$C->_BRACKETr(sub {
my $C=shift;
$C->_SUBSUMEr(['int'], sub {
my $C = shift;
$C->decint
})
})
}))) {
$C->_SUBSUMEr(['escale'], sub {
my $C = shift;
$C->escale
});
}
else {
();
}
}
},
)[$try])->($C);
last if $xact->[-2];  # committed?
last if @gather;
}
@gather;
};
@result;
}

}))) {
$C->_NOTBEFORE( sub { my $C=shift;
$C->_NOTBEFORE( sub { my $C=shift;
$C->before(sub { my $C=shift;
$C->_OPTr(sub { my $C=shift;
$C->_BRACKETr(sub {
my $C=shift;
do {
if (my ($C) = ($C->_EXACT('.'))) {
do {
if (my ($C) = ($C->before(sub { my $C=shift;
$C->_PATTERN(qr/\G\d/)
}))) {
$C->panic("Number contains two decimal points (missing 'v' for version number?)");
}
else {
();
}
};
}
else {
();
}
}
})
})
})
})
});
}
else {
();
}
}
);
}

## token alnumint
##      token alnumint {
##          [ <[ 0..9 a..z A..Z ]>+ [ _ <[ 0..9 a..z A..Z ]>+ ]* ]
##      }

sub alnumint__PEEK { $_[0]->_AUTOLEXpeek('alnumint',$retree) }
sub alnumint {
no warnings 'recursion';
my $self = shift;
local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;


my $C = $self->cursor_xact("RULE alnumint");
my $xact = $C->xact;
my $S = $C->{'_pos'};

$self->_MATCHIFYr($S, "alnumint", 
$C->_BRACKETr(sub {
my $C=shift;
do {
if (my ($C) = ($C->_PATTERN(qr/\G((?:[0-9a-zA-Z])++)/))) {
$C->_STARr(sub { my $C=shift;
$C->_BRACKETr(sub {
my $C=shift;
do {
if (my ($C) = ($C->_EXACT('_'))) {
$C->_PATTERN(qr/\G((?:[0-9a-zA-Z])++)/);
}
else {
();
}
}
})
});
}
else {
();
}
}
})
);
}

## token rad_number
##      token rad_number {
##          ':' $<radix> = [\d+] <.unsp>?      # XXX optional dot here?
##          {}           # don't recurse in lexer
##          :dba('number in radix notation')
##          [
##          || '<'
##                  [
##                  | $<coeff> = [                '.' <frac=.alnumint> ]
##                  | $<coeff> = [<int=.alnumint> '.' <frac=.alnumint> ]
##                  | $<coeff> = [<int=.alnumint>                    ]
##                  ]
##                  [
##                      '*'
##                      <base=.radint>
##                      [ '**' || <.panic: "Base is missing ** exponent part"> ]
##                      <exp=.radint> ]?
##             '>'
##      #      { make radcalc($<radix>, $<coeff>, $<base>, $<exp>) }
##          || <?before '['> <circumfix>
##          || <?before '('> <circumfix>
##          || <.panic: "Malformed radix number">
##          ]
##      }

sub rad_number__PEEK { $_[0]->_AUTOLEXpeek('rad_number',$retree) }
sub rad_number {
no warnings 'recursion';
my $self = shift;
local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;


my $C = $self->cursor_xact("RULE rad_number");
my $xact = $C->xact;
my $S = $C->{'_pos'};
$C->{'exp'} = [];
$C->{'base'} = [];

$self->_MATCHIFYr($S, "rad_number", 
do {
if (my ($C) = ($C->_EXACT(':'))) {
do {
if (my ($C) = (  $C->_SUBSUMEr(['radix'], sub {
my $C = shift;
$C->_BRACKETr(sub {
my $C=shift;
$C->_PATTERN(qr/\G((?:\d)++)/)
})
}))) {
do {
if (my ($C) = ($C->_OPTr(sub { my $C=shift;
$C->unsp
}))) {
do {
if (my ($C) = (scalar(do {

}, $C))) {
$C->_BRACKETr(sub {
my $C=shift;
do {
my $C = $C->cursor_xact('ALT ||');
my $xact = $C->xact;
my @gather;
do {
push @gather, do {
if (my ($C) = ($C->_EXACT('<'))) {
do {
if (my ($C) = ($C->_BRACKETr(sub {
my $C=shift;
do {
my @result = do {
my $trystate;
my ($tag, $try);
my @try;
my $relex;

my $fate;
my $x;
if ($fate = $C->{'_fate'} and $fate->[1] eq 'rad_number_03') {
$C->deb("Fate passed to rad_number_03: ", ::fatestr($fate)) if $::DEBUG & DEBUG::fates;
($C->{'_fate'}, $tag, $try) = @$fate;
@try = ($try);
$x = 'ALT rad_number_03';    # some outer ltm is controlling us
}
else {
$x = 'ALTLTM rad_number_03'; # we are top level ltm
}
my $C = $C->cursor_xact($x);
my $xact = $C->xact;

my @gather = ();
for (;;) {
if (not @try) {
$relex //= $C->cursor_fate('STD', 'rad_number_03', $retree);
@try = $relex->($C, $trystate);
}
last unless @try;
$try = shift(@try) // next;

if (ref $try eq 'ARRAY') {
($C->{'_fate'}, $tag, $try) = @$try;	# next candidate fate
}

$C->deb("rad_number_03 trying $tag $try") if $::DEBUG & DEBUG::try_processing;
push @gather, ((
sub { my $C=shift;
$C->_SUBSUMEr(['coeff'], sub {
my $C = shift;
$C->_BRACKETr(sub {
my $C=shift;
do {
if (my ($C) = ($C->_EXACT('.'))) {
$C->_SUBSUMEr(['frac'], sub {
my $C = shift;
$C->alnumint
});
}
else {
();
}
}
})
})
},
sub { my $C=shift;
$C->_SUBSUMEr(['coeff'], sub {
my $C = shift;
$C->_BRACKETr(sub {
my $C=shift;
do {
if (my ($C) = (  $C->_SUBSUMEr(['int'], sub {
my $C = shift;
$C->alnumint
}))) {
do {
if (my ($C) = ($C->_EXACT('.'))) {
$C->_SUBSUMEr(['frac'], sub {
my $C = shift;
$C->alnumint
});
}
else {
();
}
};
}
else {
();
}
}
})
})
},
sub { my $C=shift;
$C->_SUBSUMEr(['coeff'], sub {
my $C = shift;
$C->_BRACKETr(sub {
my $C=shift;
$C->_SUBSUMEr(['int'], sub {
my $C = shift;
$C->alnumint
})
})
})
},
)[$try])->($C);
last if $xact->[-2];  # committed?
last if @gather;
}
@gather;
};
@result;
}

}))) {
do {
if (my ($C) = ($C->_OPTr(sub { my $C=shift;
$C->_BRACKETr(sub {
my $C=shift;
do {
if (my ($C) = ($C->_EXACT('*'))) {
do {
if (my ($C) = (  $C->_SUBSUMEr(['base'], sub {
my $C = shift;
$C->radint
}))) {
do {
if (my ($C) = ($C->_BRACKETr(sub {
my $C=shift;
do {
my $C = $C->cursor_xact('ALT ||');
my $xact = $C->xact;
my @gather;
do {
push @gather, $C->_EXACT('**')
}
or $xact->[-2] or
do {
push @gather, $C->panic("Base is missing ** exponent part")};
@gather;
}
}))) {
$C->_SUBSUMEr(['exp'], sub {
my $C = shift;
$C->radint
});
}
else {
();
}
};
}
else {
();
}
};
}
else {
();
}
}
})
}))) {
$C->_EXACT('>');
}
else {
();
}
};
}
else {
();
}
};
}
else {
();
}
}
}
or $xact->[-2] or
do {
push @gather, do {
if (my ($C) = ($C->before(sub { my $C=shift;
$C->_EXACT('[')
}))) {
$C->_SUBSUMEr(['circumfix'], sub {
my $C = shift;
$C->circumfix
});
}
else {
();
}
}
}
or $xact->[-2] or
do {
push @gather, do {
if (my ($C) = ($C->before(sub { my $C=shift;
$C->_EXACT('(')
}))) {
$C->_SUBSUMEr(['circumfix'], sub {
my $C = shift;
$C->circumfix
});
}
else {
();
}
}
}
or $xact->[-2] or
do {
push @gather, $C->panic("Malformed radix number")};
@gather;
}
});
}
else {
();
}
};
}
else {
();
}
};
}
else {
();
}
};
}
else {
();
}
}
);
}

## token terminator__S_059Thesis (:$*sym = <)>)
##      token terminator:sym<)>
##          { <sym> <O(|%terminator)> }

sub terminator__S_059Thesis__PEEK { $_[0]->_AUTOLEXpeek('terminator__S_059Thesis',$retree) }
sub terminator__S_059Thesis {
no warnings 'recursion';
my $self = shift;
local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;
my %args = @_;
local $::sym = $args{sym} // q[)];


my $C = $self->cursor_xact("RULE terminator__S_059Thesis");
my $xact = $C->xact;
my $S = $C->{'_pos'};
$C->{'sym'} = ref $sym ? join(' ', @$sym) : $sym;

$self->_MATCHIFYr($S, "terminator__S_059Thesis", 
do {
if (my ($C) = ($C->_PATTERN(qr/\G\)/))) {
$C->_SUBSUMEr(['O'], sub {
my $C = shift;
$C->O(%terminator)
});
}
else {
();
}
}
);
}

## token terminator__S_060Ket (:$*sym = <]>)
##      token terminator:sym<]>
##          { ']' <O(|%terminator)> }

sub terminator__S_060Ket__PEEK { $_[0]->_AUTOLEXpeek('terminator__S_060Ket',$retree) }
sub terminator__S_060Ket {
no warnings 'recursion';
my $self = shift;
local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;
my %args = @_;
local $::sym = $args{sym} // q(]);


my $C = $self->cursor_xact("RULE terminator__S_060Ket");
my $xact = $C->xact;
my $S = $C->{'_pos'};
$C->{'sym'} = ref $sym ? join(' ', @$sym) : $sym;

$self->_MATCHIFYr($S, "terminator__S_060Ket", 
do {
if (my ($C) = ($C->_EXACT(']'))) {
$C->_SUBSUMEr(['O'], sub {
my $C = shift;
$C->O(%terminator)
});
}
else {
();
}
}
);
}

## token terminator__S_061Ly (:$*sym = <}>)
##      token terminator:sym<}>
##          { '}' <O(|%terminator)> }

sub terminator__S_061Ly__PEEK { $_[0]->_AUTOLEXpeek('terminator__S_061Ly',$retree) }
sub terminator__S_061Ly {
no warnings 'recursion';
my $self = shift;
local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;
my %args = @_;
local $::sym = $args{sym} // q(});


my $C = $self->cursor_xact("RULE terminator__S_061Ly");
my $xact = $C->xact;
my $S = $C->{'_pos'};
$C->{'sym'} = ref $sym ? join(' ', @$sym) : $sym;

$self->_MATCHIFYr($S, "terminator__S_061Ly", 
do {
if (my ($C) = ($C->_EXACT('}'))) {
$C->_SUBSUMEr(['O'], sub {
my $C = shift;
$C->O(%terminator)
});
}
else {
();
}
}
);
}

{ package STD::P6;
use Moose ':all' => { -prefix => "moose_" };
my $retree;
moose_extends(qw(STD));
###################
# Top-level rules #
###################

# Note: we only check for the stopper.  We don't check for ^ because
# we might be embedded in something else.
##     rule comp_unit
##          rule comp_unit {
##              :my $*begin_compunit = 1;
##              :my $*endargs = -1;
##              :my %*LANG;
##              :my $*PKGDECL ::= "";
##              :my $*IN_DECL = '';
##              :my $*DECLARAND;
##              :my $*NEWPKG;
##              :my $*NEWPAD;
##              :my $*QSIGIL ::= '';
##              :my $*IN_META = 0;
##              :my $*QUASIMODO;
##              :my $*SCOPE = "";
##              :my $*LEFTSIGIL;
##              :my $*PRECLIM;
##              :my %*MYSTERY = ();
##              :my $*INVOCANT_OK;
##              :my $*INVOCANT_IS;
##              :my $*CURPAD;
##              :my $*MULTINESS = '';
##              :my $*SIGNUM = 0;
##              :my $*MONKEY_TYPING = False;
##      
##              :my $*CURPKG;
##              {{
##      
##                  %*LANG<MAIN>    = ::STD::P6 ;
##                  %*LANG<Q>       = ::STD::Q ;
##                  %*LANG<Quasi>   = ::STD::Quasi ;
##                  %*LANG<Regex>   = ::STD::Regex ;
##                  %*LANG<Trans>   = ::STD::Trans ;
##                  %*LANG<P5>      = ::STD::P5 ;
##                  %*LANG<P5Regex> = ::STD::P5::Regex ;
##      
##                  @*WORRIES = ();
##                  self.load_setting($*SETTINGNAME);
##                  my $oid = $*SETTING.id;
##                  my $id = 'MY:file<' ~ $*FILE<name> ~ '>';
##                  $*CURPAD = Stash.new(
##                      'OUTER::' => [$oid],
##                      '!file' => $*FILE, '!line' => 0,
##                      '!id' => [$id],
##                  );
##                  $ALL.{$id} = $*CURPAD;
##                  $*UNIT = $*CURPAD;
##                  $ALL.<UNIT> = $*UNIT;
##                  self.finishpad;
##                  # $ = self.cursor_fresh($*CURPAD<$?LANGNAME>);
##              }}
##              <statementlist>
##              [ <?unitstopper> || <.panic: "Confused"> ]
##              # "CHECK" time...
##              {{
##                  if @*WORRIES {
##                      warn "Potential difficulties:\n  " ~ join( "\n  ", @*WORRIES) ~ "\n";
##                  }
##                  my $m = $.explain_mystery();
##                  warn $m if $m;
##              }}
##          }

sub comp_unit__PEEK { $_[0]->_AUTOLEXpeek('comp_unit',$retree) }
sub comp_unit {
no warnings 'recursion';
my $self = shift;
local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;
local $::begin_compunit = 1;
local $::endargs = -1;
local %::LANG;
local $::PKGDECL = "";
local $::IN_DECL = '';
local $::DECLARAND;
local $::NEWPKG;
local $::NEWPAD;
local $::QSIGIL = '';
local $::IN_META = 0;
local $::QUASIMODO;
local $::SCOPE = "";
local $::LEFTSIGIL;
local $::PRECLIM;
local %::MYSTERY = ();
local $::INVOCANT_OK;
local $::INVOCANT_IS;
local $::CURPAD;
local $::MULTINESS = '';
local $::SIGNUM = 0;
local $::MONKEY_TYPING = 0;
local $::CURPKG;


my $C = $self->cursor_xact("RULE comp_unit");
my $xact = $C->xact;
my $S = $C->{'_pos'};

$self->_MATCHIFYr($S, "comp_unit", 
do {
if (my ($C) = ($C->ws)) {
do {
if (my ($C) = (scalar(do {


$::LANG{'MAIN'}    = 'STD::P6' ;
$::LANG{'Q'}       = 'STD::Q' ;
$::LANG{'Quasi'}   = 'STD::Quasi' ;
$::LANG{'Regex'}   = 'STD::Regex' ;
$::LANG{'Trans'}   = 'STD::Trans' ;
$::LANG{'P5'}      = 'STD::P5' ;
$::LANG{'P5Regex'} = 'STD::P5::Regex' ;

@::WORRIES = ();
$self->load_setting($::SETTINGNAME);
my $oid = $::SETTING->id;
my $id = 'MY:file<' . $::FILE->{'name'} . '>';
$::CURPAD = Stash->new(
'OUTER::' => [$oid],
'!file' => $::FILE, '!line' => 0,
'!id' => [$id],
);
$ALL->{$id} = $::CURPAD;
$::UNIT = $::CURPAD;
$ALL->{'UNIT'} = $::UNIT;
$self->finishpad;
# $ = self.cursor_fresh($::CURPAD<$?LANGNAME>);

}, $C))) {
do {
if (my ($C) = ($C->ws)) {
do {
if (my ($C) = ($C->_SUBSUMEr(['statementlist'], sub {
my $C = shift;
$C->statementlist
}))) {
do {
if (my ($C) = ($C->ws)) {
do {
if (my ($C) = ($C->_BRACKETr(sub {
my $C=shift;
do {
my $C = $C->cursor_xact('ALT ||');
my $xact = $C->xact;
my @gather;
do {
push @gather, do {
if (my ($C) = ($C->before( sub { my $C=shift;
$C->unitstopper
}))) {
$C->ws;
}
else {
();
}
}
}
or $xact->[-2] or
do {
push @gather, do {
if (my ($C) = ($C->panic("Confused"))) {
$C->ws;
}
else {
();
}
}};
@gather;
}
}))) {
do {
if (my ($C) = ($C->ws)) {
do {
if (my ($C) = (scalar(do {

if (@::WORRIES) {
warn "Potential difficulties:\n  " . join( "\n  ", @::WORRIES) . "\n";
}
my $m = $C->explain_mystery();
warn $m if $m;

}, $C))) {
$C->ws;
}
else {
();
}
};
}
else {
();
}
};
}
else {
();
}
};
}
else {
();
}
};
}
else {
();
}
};
}
else {
();
}
};
}
else {
();
}
};
}
else {
();
}
}
);
}

# Note: because of the possibility of placeholders we can't determine arity of
# the block syntactically, so this must be determined via semantic analysis.
# Also, pblocks used in an if/unless statement do not treat $_ as a placeholder,
# while most other blocks treat $_ as equivalent to $^x.  Therefore the first
# possible place to check arity is not here but in the rule that calls this
# rule.  (Could also be done in a later pass.)

##     token pblock ()
##          token pblock () {
##              :temp $*CURPAD;
##              :dba('parameterized block')
##              [<?before <.lambda> | '{' > ||
##                  {{
##                      if $*BORG and $*BORG.<block> {
##                          if $*BORG.<name> {
##                              my $m = "Function '" ~ $*BORG.<name> ~ "' needs parens to avoid gobbling block" ~ $*BORG.<culprit>.locmess;
##                              $*BORG.<block>.panic($m ~ "\nMissing block (apparently gobbled by '" ~ $*BORG.<name> ~ "')");
##                          }
##                          else {
##                              my $m = "Expression needs parens to avoid gobbling block" ~ $*BORG.<culprit>.locmess;
##                              $*BORG.<block>.panic($m ~ "\nMissing block (apparently gobbled by expression)");
##                          }
##                      }
##                      elsif %*MYSTERY {
##                          $.panic("Missing block (apparently gobbled by undeclared routine?)");
##                      }
##                      else {
##                          $.panic("Missing block");
##                      }
##                  }}
##              ]
##              [
##              | <lambda>
##                  <.newpad(1)>
##                  <signature(1)>
##                  <blockoid>
##                  <.getsig>
##              | <?before '{'>
##                  <.newpad(1)>
##                  <blockoid>
##                  <.getsig>
##              ]
##          }

sub pblock__PEEK { $_[0]->_AUTOLEXpeek('pblock',$retree) }
sub pblock {
no warnings 'recursion';
my $self = shift;
local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;
local $::CURPAD = $::CURPAD;


my $C = $self->cursor_xact("RULE pblock");
my $xact = $C->xact;
my $S = $C->{'_pos'};

$self->_MATCHIFYr($S, "pblock", 
do {
if (my ($C) = ($C->_BRACKETr(sub {
my $C=shift;
do {
my $C = $C->cursor_xact('ALT ||');
my $xact = $C->xact;
my @gather;
do {
push @gather, $C->before(sub { my $C=shift;
do {
my @result = do {
my $trystate;
my ($tag, $try);
my @try;
my $relex;

my $fate;
my $x;
if ($fate = $C->{'_fate'} and $fate->[1] eq 'pblock_02') {
$C->deb("Fate passed to pblock_02: ", ::fatestr($fate)) if $::DEBUG & DEBUG::fates;
($C->{'_fate'}, $tag, $try) = @$fate;
@try = ($try);
$x = 'ALT pblock_02';    # some outer ltm is controlling us
}
else {
$x = 'ALTLTM pblock_02'; # we are top level ltm
}
my $C = $C->cursor_xact($x);
my $xact = $C->xact;

my @gather = ();
for (;;) {
if (not @try) {
$relex //= $C->cursor_fate('STD::P6', 'pblock_02', $retree);
@try = $relex->($C, $trystate);
}
last unless @try;
$try = shift(@try) // next;

if (ref $try eq 'ARRAY') {
($C->{'_fate'}, $tag, $try) = @$try;	# next candidate fate
}

$C->deb("pblock_02 trying $tag $try") if $::DEBUG & DEBUG::try_processing;
push @gather, ((
sub { my $C=shift;
$C->lambda
},
sub { my $C=shift;
$C->_EXACT('{')
},
)[$try])->($C);
last if $xact->[-2];  # committed?
last if @gather;
}
@gather;
};
@result;
}

})
}
or $xact->[-2] or
do {
push @gather, scalar(do {

if ($::BORG and $::BORG->{'block'}) {
if ($::BORG->{'name'}) {
my $m = "Function '" . $::BORG->{'name'} . "' needs parens to avoid gobbling block" . $::BORG->{'culprit'}->locmess;
$::BORG->{'block'}->panic($m . "\nMissing block (apparently gobbled by '" . $::BORG->{'name'} . "')");
}
else {
my $m = "Expression needs parens to avoid gobbling block" . $::BORG->{'culprit'}->locmess;
$::BORG->{'block'}->panic($m . "\nMissing block (apparently gobbled by expression)");
}
}
elsif (%::MYSTERY) {
$C->panic("Missing block (apparently gobbled by undeclared routine?)");
}
else {
$C->panic("Missing block");
}

}, $C)};
@gather;
}
}))) {
$C->_BRACKETr(sub {
my $C=shift;
do {
my @result = do {
my $trystate;
my ($tag, $try);
my @try;
my $relex;

my $fate;
my $x;
if ($fate = $C->{'_fate'} and $fate->[1] eq 'pblock_04') {
$C->deb("Fate passed to pblock_04: ", ::fatestr($fate)) if $::DEBUG & DEBUG::fates;
($C->{'_fate'}, $tag, $try) = @$fate;
@try = ($try);
$x = 'ALT pblock_04';    # some outer ltm is controlling us
}
else {
$x = 'ALTLTM pblock_04'; # we are top level ltm
}
my $C = $C->cursor_xact($x);
my $xact = $C->xact;

my @gather = ();
for (;;) {
if (not @try) {
$relex //= $C->cursor_fate('STD::P6', 'pblock_04', $retree);
@try = $relex->($C, $trystate);
}
last unless @try;
$try = shift(@try) // next;

if (ref $try eq 'ARRAY') {
($C->{'_fate'}, $tag, $try) = @$try;	# next candidate fate
}

$C->deb("pblock_04 trying $tag $try") if $::DEBUG & DEBUG::try_processing;
push @gather, ((
sub { my $C=shift;
do {
if (my ($C) = ($C->_SUBSUMEr(['lambda'], sub {
my $C = shift;
$C->lambda
}))) {
do {
if (my ($C) = ($C->newpad(1))) {
do {
if (my ($C) = ($C->_SUBSUMEr(['signature'], sub {
my $C = shift;
$C->signature(1)
}))) {
do {
if (my ($C) = ($C->_SUBSUMEr(['blockoid'], sub {
my $C = shift;
$C->blockoid
}))) {
$C->getsig;
}
else {
();
}
};
}
else {
();
}
};
}
else {
();
}
};
}
else {
();
}
}
},
sub { my $C=shift;
do {
if (my ($C) = ($C->before(sub { my $C=shift;
$C->_EXACT('{')
}))) {
do {
if (my ($C) = ($C->newpad(1))) {
do {
if (my ($C) = ($C->_SUBSUMEr(['blockoid'], sub {
my $C = shift;
$C->blockoid
}))) {
$C->getsig;
}
else {
();
}
};
}
else {
();
}
};
}
else {
();
}
}
},
)[$try])->($C);
last if $xact->[-2];  # committed?
last if @gather;
}
@gather;
};
@result;
}

});
}
else {
();
}
}
);
}

##     token lambda
##          token lambda { '->' | '<->' }

sub lambda__PEEK { $_[0]->_AUTOLEXpeek('lambda',$retree) }
sub lambda {
no warnings 'recursion';
my $self = shift;
local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;


my $C = $self->cursor_xact("RULE lambda");
my $xact = $C->xact;
my $S = $C->{'_pos'};

$self->_MATCHIFYr($S, "lambda", 
do {
my @result = do {
my $trystate;
my ($tag, $try);
my @try;
my $relex;

my $fate;
my $x;
if ($fate = $C->{'_fate'} and $fate->[1] eq 'lambda_00') {
$C->deb("Fate passed to lambda_00: ", ::fatestr($fate)) if $::DEBUG & DEBUG::fates;
($C->{'_fate'}, $tag, $try) = @$fate;
@try = ($try);
$x = 'ALT lambda_00';    # some outer ltm is controlling us
}
else {
$x = 'ALTLTM lambda_00'; # we are top level ltm
}
my $C = $C->cursor_xact($x);
my $xact = $C->xact;

my @gather = ();
for (;;) {
if (not @try) {
$relex //= $C->cursor_fate('STD::P6', 'lambda_00', $retree);
@try = $relex->($C, $trystate);
}
last unless @try;
$try = shift(@try) // next;

if (ref $try eq 'ARRAY') {
($C->{'_fate'}, $tag, $try) = @$try;	# next candidate fate
}

$C->deb("lambda_00 trying $tag $try") if $::DEBUG & DEBUG::try_processing;
push @gather, ((
sub { my $C=shift;
$C->_EXACT('->')
},
sub { my $C=shift;
$C->_EXACT('<->')
},
)[$try])->($C);
last if $xact->[-2];  # committed?
last if @gather;
}
@gather;
};
@result;
}

);
}

# Look for an expression followed by a required lambda.
##     token xblock
##          token xblock {
##              :my $*GOAL ::= '{';
##              :my $*BORG = {};
##              <EXPR>
##              { $*BORG.<culprit> //= $<EXPR>.cursor(self.pos) }
##              <.ws>
##              <pblock>
##          }

sub xblock__PEEK { $_[0]->_AUTOLEXpeek('xblock',$retree) }
sub xblock {
no warnings 'recursion';
my $self = shift;
local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;
local $::GOAL = '{';
local $::BORG = {};


my $C = $self->cursor_xact("RULE xblock");
my $xact = $C->xact;
my $S = $C->{'_pos'};

$self->_MATCHIFYr($S, "xblock", 
do {
if (my ($C) = ($C->_SUBSUMEr(['EXPR'], sub {
my $C = shift;
$C->EXPR
}))) {
do {
if (my ($C) = (scalar(do {
my $M = $C;  $::BORG->{'culprit'} //= $M->{'EXPR'}->cursor($self->{'_pos'}) ;
}, $C))) {
do {
if (my ($C) = ($C->ws)) {
$C->_SUBSUMEr(['pblock'], sub {
my $C = shift;
$C->pblock
});
}
else {
();
}
};
}
else {
();
}
};
}
else {
();
}
}
);
}

##     token block ()
##          token block () {
##              :temp $*CURPAD;
##              :dba('scoped block')
##              [ <?before '{' > || <.panic: "Missing block"> ]
##              <.newpad>
##              <blockoid>
##              <.checkyada>
##          }

sub block__PEEK { $_[0]->_AUTOLEXpeek('block',$retree) }
sub block {
no warnings 'recursion';
my $self = shift;
local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;
local $::CURPAD = $::CURPAD;


my $C = $self->cursor_xact("RULE block");
my $xact = $C->xact;
my $S = $C->{'_pos'};

$self->_MATCHIFYr($S, "block", 
do {
if (my ($C) = ($C->_BRACKETr(sub {
my $C=shift;
do {
my $C = $C->cursor_xact('ALT ||');
my $xact = $C->xact;
my @gather;
do {
push @gather, $C->before(sub { my $C=shift;
$C->_EXACT('{')
})
}
or $xact->[-2] or
do {
push @gather, $C->panic("Missing block")};
@gather;
}
}))) {
do {
if (my ($C) = ($C->newpad)) {
do {
if (my ($C) = ($C->_SUBSUMEr(['blockoid'], sub {
my $C = shift;
$C->blockoid
}))) {
$C->checkyada;
}
else {
();
}
};
}
else {
();
}
};
}
else {
();
}
}
);
}

##     token blockoid
##          token blockoid {
##              # encapsulate braided languages
##              :temp %*LANG;
##              :my $*SIGNUM;
##      
##              <.finishpad>
##              [
##              | :dba('block') '{' ~ '}' <statementlist> :: <.curlycheck>
##              | <?terminator> <.panic: 'Missing block'>
##              | <?> <.panic: "Malformed block">
##              ]
##          }

sub blockoid__PEEK { $_[0]->_AUTOLEXpeek('blockoid',$retree) }
sub blockoid {
no warnings 'recursion';
my $self = shift;
local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;
local %::LANG = %::LANG;
local $::SIGNUM;


my $C = $self->cursor_xact("RULE blockoid");
my $xact = $C->xact;
my $S = $C->{'_pos'};

$self->_MATCHIFYr($S, "blockoid", 
do {
if (my ($C) = ($C->finishpad)) {
$C->_BRACKETr(sub {
my $C=shift;
do {
my @result = do {
my $trystate;
my ($tag, $try);
my @try;
my $relex;

my $fate;
my $x;
if ($fate = $C->{'_fate'} and $fate->[1] eq 'blockoid_01') {
$C->deb("Fate passed to blockoid_01: ", ::fatestr($fate)) if $::DEBUG & DEBUG::fates;
($C->{'_fate'}, $tag, $try) = @$fate;
@try = ($try);
$x = 'ALT blockoid_01';    # some outer ltm is controlling us
}
else {
$x = 'ALTLTM blockoid_01'; # we are top level ltm
}
my $C = $C->cursor_xact($x);
my $xact = $C->xact;

my @gather = ();
for (;;) {
if (not @try) {
$relex //= $C->cursor_fate('STD::P6', 'blockoid_01', $retree);
@try = $relex->($C, $trystate);
}
last unless @try;
$try = shift(@try) // next;

if (ref $try eq 'ARRAY') {
($C->{'_fate'}, $tag, $try) = @$try;	# next candidate fate
}

$C->deb("blockoid_01 trying $tag $try") if $::DEBUG & DEBUG::try_processing;
push @gather, ((
sub { my $C=shift;
do {
if (my ($C) = ($C->_EXACT('{'))) {
do {
if (my ($C) = (((local $::GOAL = '}' ), $C)[-1])) {
do {
if (my ($C) = ($C->_SUBSUMEr(['statementlist'], sub {
my $C = shift;
$C->statementlist
}))) {
do {
if (my ($C) = ($C->_BRACKETr(sub {
my $C=shift;
do {
my $C = $C->cursor_xact('ALT ||');
my $xact = $C->xact;
my @gather;
do {
push @gather, $C->_EXACT('}')
}
or $xact->[-2] or
do {
push @gather, $C->FAILGOAL('}' , 'block')};
@gather;
}
}))) {
do {
if (my ($C) = ($C->_COMMITLTM())) {
$C->curlycheck;
}
else {
();
}
};
}
else {
();
}
};
}
else {
();
}
};
}
else {
();
}
};
}
else {
();
}
}
},
sub { my $C=shift;
do {
if (my ($C) = ($C->before( sub { my $C=shift;
$C->terminator
}))) {
$C->panic('Missing block');
}
else {
();
}
}
},
sub { my $C=shift;
do {
if (my ($C) = ($C->before( sub { my $C=shift;
$C
}))) {
$C->panic("Malformed block");
}
else {
();
}
}
},
)[$try])->($C);
last if $xact->[-2];  # committed?
last if @gather;
}
@gather;
};
@result;
}

});
}
else {
();
}
}
);
}

##     token curlycheck
##          token curlycheck {
##              [
##              || <?before \h* $$>  # (usual case without comments)
##                  { @*MEMOS[$.pos]<endstmt> = 2; }
##              || <?before \h* <[\\,:]>>
##              || <.unv> $$
##                  { @*MEMOS[$.pos]<endstmt> = 2; }
##              || <.unsp>? { @*MEMOS[$.pos]<endargs> = 1; }
##              ]
##          }

sub curlycheck__PEEK { $_[0]->_AUTOLEXpeek('curlycheck',$retree) }
sub curlycheck {
no warnings 'recursion';
my $self = shift;
local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;


my $C = $self->cursor_xact("RULE curlycheck");
my $xact = $C->xact;
my $S = $C->{'_pos'};

$self->_MATCHIFYr($S, "curlycheck", 
$C->_BRACKETr(sub {
my $C=shift;
do {
my $C = $C->cursor_xact('ALT ||');
my $xact = $C->xact;
my @gather;
do {
push @gather, do {
if (my ($C) = ($C->before(sub { my $C=shift;
$C->_PATTERN(qr/\G((?:[\x20\t\r])*+)(?m:$)/)
}))) {
scalar(do {
$::MEMOS[$C->{'_pos'}]{'endstmt'} = 2; 
}, $C);
}
else {
();
}
}
}
or $xact->[-2] or
do {
push @gather, $C->before(sub { my $C=shift;
$C->_PATTERN(qr/\G((?:[\x20\t\r])*+)[\\,:]/)
})
}
or $xact->[-2] or
do {
push @gather, do {
if (my ($C) = ($C->unv)) {
do {
if (my ($C) = ($C->_PATTERN(qr/\G(?m:$)/))) {
scalar(do {
$::MEMOS[$C->{'_pos'}]{'endstmt'} = 2; 
}, $C);
}
else {
();
}
};
}
else {
();
}
}
}
or $xact->[-2] or
do {
push @gather, do {
if (my ($C) = ($C->_OPTr(sub { my $C=shift;
$C->unsp
}))) {
scalar(do {
$::MEMOS[$C->{'_pos'}]{'endargs'} = 1; 
}, $C);
}
else {
();
}
}};
@gather;
}
})
);
}

##     token regex_block
##          token regex_block {
##              # encapsulate braided languages
##              :temp %*LANG;
##      
##              :my $lang = %*LANG<Regex>;
##              :my $*GOAL ::= '}';
##      
##              [ <quotepair> <.ws>
##                  {
##                      my $kv = $<quotepair>[*-1];
##                      $lang = $lang.tweak($kv.<k>, $kv.<v>)
##                          or self.panic("Unrecognized adverb :" ~ $kv.<k> ~ '(' ~ $kv.<v> ~ ')');
##                  }
##              ]*
##      
##              '{'
##              <nibble( $.cursor_fresh($lang).unbalanced('}') )>
##              [ '}' || <.panic: "Unable to parse regex; couldn't find right brace"> ]
##      
##              <.curlycheck>
##          }

sub regex_block__PEEK { $_[0]->_AUTOLEXpeek('regex_block',$retree) }
sub regex_block {
no warnings 'recursion';
my $self = shift;
local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;
local %::LANG = %::LANG;
my $lang = $::LANG{'Regex'};
local $::GOAL = '}';


my $C = $self->cursor_xact("RULE regex_block");
my $xact = $C->xact;
my $S = $C->{'_pos'};
$C->{'quotepair'} = [];

$self->_MATCHIFYr($S, "regex_block", 
do {
if (my ($C) = ($C->_STARr(sub { my $C=shift;
$C->_BRACKETr(sub {
my $C=shift;
do {
if (my ($C) = ($C->_SUBSUMEr(['quotepair'], sub {
my $C = shift;
$C->quotepair
}))) {
do {
if (my ($C) = ($C->ws)) {
scalar(do {
my $M = $C; 
my $kv = $M->{'quotepair'}[-1];
$lang = $lang->tweak($kv->{'k'}, $kv->{'v'})
or $self->panic("Unrecognized adverb :" . $kv->{'k'} . '(' . $kv->{'v'} . ')');
;
}, $C);
}
else {
();
}
};
}
else {
();
}
}
})
}))) {
do {
if (my ($C) = ($C->_EXACT('{'))) {
do {
if (my ($C) = ($C->_SUBSUMEr(['nibble'], sub {
my $C = shift;
$C->nibble( $C->cursor_fresh($lang)->unbalanced('}') )
}))) {
do {
if (my ($C) = ($C->_BRACKETr(sub {
my $C=shift;
do {
my $C = $C->cursor_xact('ALT ||');
my $xact = $C->xact;
my @gather;
do {
push @gather, $C->_EXACT('}')
}
or $xact->[-2] or
do {
push @gather, $C->panic("Unable to parse regex; couldn't find right brace")};
@gather;
}
}))) {
$C->curlycheck;
}
else {
();
}
};
}
else {
();
}
};
}
else {
();
}
};
}
else {
();
}
}
);
}

# statement semantics
##     rule statementlist
##          rule statementlist {
##              :my $*INVOCANT_OK = 0;
##              :temp $*MONKEY_TYPING;
##              :dba('statement list')
##      
##              [
##              | $
##              | <?before <[\)\]\}]>>
##              | [<statement><eat_terminator> ]*
##              ]
##          }

sub statementlist__PEEK { $_[0]->_AUTOLEXpeek('statementlist',$retree) }
sub statementlist {
no warnings 'recursion';
my $self = shift;
local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;
local $::INVOCANT_OK = 0;
local $::MONKEY_TYPING = $::MONKEY_TYPING;


my $C = $self->cursor_xact("RULE statementlist");
my $xact = $C->xact;
my $S = $C->{'_pos'};
$C->{'statement'} = [];
$C->{'eat_terminator'} = [];

$self->_MATCHIFYr($S, "statementlist", 
do {
if (my ($C) = ($C->ws)) {
do {
if (my ($C) = ($C->ws)) {
do {
if (my ($C) = ($C->_BRACKETr(sub {
my $C=shift;
do {
my @result = do {
my $trystate;
my ($tag, $try);
my @try;
my $relex;

my $fate;
my $x;
if ($fate = $C->{'_fate'} and $fate->[1] eq 'statementlist_01') {
$C->deb("Fate passed to statementlist_01: ", ::fatestr($fate)) if $::DEBUG & DEBUG::fates;
($C->{'_fate'}, $tag, $try) = @$fate;
@try = ($try);
$x = 'ALT statementlist_01';    # some outer ltm is controlling us
}
else {
$x = 'ALTLTM statementlist_01'; # we are top level ltm
}
my $C = $C->cursor_xact($x);
my $xact = $C->xact;

my @gather = ();
for (;;) {
if (not @try) {
$relex //= $C->cursor_fate('STD::P6', 'statementlist_01', $retree);
@try = $relex->($C, $trystate);
}
last unless @try;
$try = shift(@try) // next;

if (ref $try eq 'ARRAY') {
($C->{'_fate'}, $tag, $try) = @$try;	# next candidate fate
}

$C->deb("statementlist_01 trying $tag $try") if $::DEBUG & DEBUG::try_processing;
push @gather, ((
sub { my $C=shift;
do {
if (my ($C) = ($C->_PATTERN(qr/\G\z/))) {
$C->ws;
}
else {
();
}
}
},
sub { my $C=shift;
do {
if (my ($C) = ($C->before(sub { my $C=shift;
$C->_PATTERN(qr/\G[\)\]\}]/)
}))) {
$C->ws;
}
else {
();
}
}
},
sub { my $C=shift;
do {
if (my ($C) = ($C->_STARr(sub { my $C=shift;
$C->_BRACKETr(sub {
my $C=shift;
do {
if (my ($C) = ($C->_SUBSUMEr(['statement'], sub {
my $C = shift;
$C->statement
}))) {
do {
if (my ($C) = ($C->_SUBSUMEr(['eat_terminator'], sub {
my $C = shift;
$C->eat_terminator
}))) {
$C->ws;
}
else {
();
}
};
}
else {
();
}
}
})
}))) {
$C->ws;
}
else {
();
}
}
},
)[$try])->($C);
last if $xact->[-2];  # committed?
last if @gather;
}
@gather;
};
@result;
}

}))) {
$C->ws;
}
else {
();
}
};
}
else {
();
}
};
}
else {
();
}
}
);
}

# embedded semis, context-dependent semantics
##     rule semilist
##          rule semilist {
##              :my $*INVOCANT_OK = 0;
##              :dba('semicolon list')
##              [
##              | <?before <[\)\]\}]>>
##              | [<statement><eat_terminator> ]*
##              ]
##          }

sub semilist__PEEK { $_[0]->_AUTOLEXpeek('semilist',$retree) }
sub semilist {
no warnings 'recursion';
my $self = shift;
local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;
local $::INVOCANT_OK = 0;


my $C = $self->cursor_xact("RULE semilist");
my $xact = $C->xact;
my $S = $C->{'_pos'};
$C->{'statement'} = [];
$C->{'eat_terminator'} = [];

$self->_MATCHIFYr($S, "semilist", 
do {
if (my ($C) = ($C->ws)) {
do {
if (my ($C) = ($C->ws)) {
do {
if (my ($C) = ($C->_BRACKETr(sub {
my $C=shift;
do {
my @result = do {
my $trystate;
my ($tag, $try);
my @try;
my $relex;

my $fate;
my $x;
if ($fate = $C->{'_fate'} and $fate->[1] eq 'semilist_01') {
$C->deb("Fate passed to semilist_01: ", ::fatestr($fate)) if $::DEBUG & DEBUG::fates;
($C->{'_fate'}, $tag, $try) = @$fate;
@try = ($try);
$x = 'ALT semilist_01';    # some outer ltm is controlling us
}
else {
$x = 'ALTLTM semilist_01'; # we are top level ltm
}
my $C = $C->cursor_xact($x);
my $xact = $C->xact;

my @gather = ();
for (;;) {
if (not @try) {
$relex //= $C->cursor_fate('STD::P6', 'semilist_01', $retree);
@try = $relex->($C, $trystate);
}
last unless @try;
$try = shift(@try) // next;

if (ref $try eq 'ARRAY') {
($C->{'_fate'}, $tag, $try) = @$try;	# next candidate fate
}

$C->deb("semilist_01 trying $tag $try") if $::DEBUG & DEBUG::try_processing;
push @gather, ((
sub { my $C=shift;
do {
if (my ($C) = ($C->before(sub { my $C=shift;
$C->_PATTERN(qr/\G[\)\]\}]/)
}))) {
$C->ws;
}
else {
();
}
}
},
sub { my $C=shift;
do {
if (my ($C) = ($C->_STARr(sub { my $C=shift;
$C->_BRACKETr(sub {
my $C=shift;
do {
if (my ($C) = ($C->_SUBSUMEr(['statement'], sub {
my $C = shift;
$C->statement
}))) {
do {
if (my ($C) = ($C->_SUBSUMEr(['eat_terminator'], sub {
my $C = shift;
$C->eat_terminator
}))) {
$C->ws;
}
else {
();
}
};
}
else {
();
}
}
})
}))) {
$C->ws;
}
else {
();
}
}
},
)[$try])->($C);
last if $xact->[-2];  # committed?
last if @gather;
}
@gather;
};
@result;
}

}))) {
$C->ws;
}
else {
();
}
};
}
else {
();
}
};
}
else {
();
}
}
);
}


##     token label
##          token label {
##              :my $label;
##              <identifier> ':' <?before \s> <.ws>
##      
##              [ <?{ $.is_name($label = $<identifier>.Str) }>
##                <.panic("Illegal redeclaration of '$label'")>
##              ]?
##      
##              # add label as a pseudo type
##              {{ my $*IN_DECL = 'label'; $.add_my_name($label); }}
##      
##          }

sub label__PEEK { $_[0]->_AUTOLEXpeek('label',$retree) }
sub label {
no warnings 'recursion';
my $self = shift;
local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;
my $label;


my $C = $self->cursor_xact("RULE label");
my $xact = $C->xact;
my $S = $C->{'_pos'};

$self->_MATCHIFYr($S, "label", 
do {
if (my ($C) = ($C->_SUBSUMEr(['identifier'], sub {
my $C = shift;
$C->identifier
}))) {
do {
if (my ($C) = ($C->_EXACT(':'))) {
do {
if (my ($C) = ($C->before(sub { my $C=shift;
$C->_PATTERN(qr/\G\s/)
}))) {
do {
if (my ($C) = ($C->ws)) {
do {
if (my ($C) = ($C->_OPTr(sub { my $C=shift;
$C->_BRACKETr(sub {
my $C=shift;
do {
if (my ($C) = ($C->before( sub { my $C=shift;
(($C) x !!do {
my $M = $C;  $C->is_name($label = $M->{'identifier'}->Str) ;
})
}))) {
$C->panic("Illegal redeclaration of '$label'");
}
else {
();
}
}
})
}))) {
scalar(do {
local $::IN_DECL = 'label'; $C->add_my_name($label); 
}, $C);
}
else {
();
}
};
}
else {
();
}
};
}
else {
();
}
};
}
else {
();
}
};
}
else {
();
}
}
);
}

##     token statement
##          token statement {
##              :my $*endargs = -1;
##              :my $*QSIGIL ::= 0;
##              <!before <[\)\]\}]> >
##      
##              # this could either be a statement that follows a declaration
##              # or a statement that is within the block of a code declaration
##              <!!{ $*LASTSTATE = $.pos; $ = %*LANG<MAIN>.bless($); }>
##      
##              [
##              | <label> <statement>
##              | <statement_control>
##              | <EXPR>
##                  :dba('statement end')
##                  [
##                  || <?{ (@*MEMOS[$.pos]<endstmt> // 0) == 2 }>   # no mod after end-line curly
##                  ||
##                      :dba('statement modifier')
##                      <.ws>
##                      [
##                      | <statement_mod_loop>
##                          {{
##                              my $sp = $<EXPR><statement_prefix>;
##                              if $sp and $sp<sym> eq 'do' {
##                                 my $s = $<statement_mod_loop>[0]<sym>;
##                                 $.obs("do...$s" ,"repeat...$s");
##                              }
##                          }}
##                      | <statement_mod_cond>
##                          :dba('statement modifier loop')
##                          [
##                          || <?{ (@*MEMOS[$.pos]<endstmt> // 0) == 2 }>
##                          || <.ws> <statement_mod_loop>?
##                          ]
##                      ]?
##                  ]
##              | <?before ';'>
##              | {} <.panic: "Bogus statement">
##              ]
##      
##              # Is there more on same line after a block?
##              [ <?{ (@*MEMOS[@*MEMOS[$.pos]<ws>//$.pos]<endargs>//0) == 1 }>
##                  \h*
##                  <!before ';' | ')' | ']' | '}' >
##                  <!infixstopper>
##                  { $*HIGHWATER = $.pos = @*MEMOS[$.pos]<ws>//$.pos; }
##                  <.panic: "Missing punctuation (semicolon or comma?) after block">
##              ]?
##          }

sub statement__PEEK { $_[0]->_AUTOLEXpeek('statement',$retree) }
sub statement {
no warnings 'recursion';
my $self = shift;
local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;
local $::endargs = -1;
local $::QSIGIL = 0;


my $C = $self->cursor_xact("RULE statement");
my $xact = $C->xact;
my $S = $C->{'_pos'};
$C->{'statement_mod_loop'} = [];
$C->{'statement_mod_cond'} = [];

$self->_MATCHIFYr($S, "statement", 
do {
if (my ($C) = ($C->_NOTBEFORE( sub { my $C=shift;
$C->before(sub { my $C=shift;
$C->_PATTERN(qr/\G[\)\]\}]/)
})
}))) {
do {
if (my ($C) = ($C->_NOTBEFORE( sub { my $C=shift;
$C->_NOTBEFORE( sub { my $C=shift;
(($C) x !!do {
$::LASTSTATE = $C->{'_pos'}; $C = $::LANG{'MAIN'}->bless($C); 
})
})
}))) {
do {
if (my ($C) = ($C->_BRACKETr(sub {
my $C=shift;
do {
my @result = do {
my $trystate;
my ($tag, $try);
my @try;
my $relex;

my $fate;
my $x;
if ($fate = $C->{'_fate'} and $fate->[1] eq 'statement_02') {
$C->deb("Fate passed to statement_02: ", ::fatestr($fate)) if $::DEBUG & DEBUG::fates;
($C->{'_fate'}, $tag, $try) = @$fate;
@try = ($try);
$x = 'ALT statement_02';    # some outer ltm is controlling us
}
else {
$x = 'ALTLTM statement_02'; # we are top level ltm
}
my $C = $C->cursor_xact($x);
my $xact = $C->xact;

my @gather = ();
for (;;) {
if (not @try) {
$relex //= $C->cursor_fate('STD::P6', 'statement_02', $retree);
@try = $relex->($C, $trystate);
}
last unless @try;
$try = shift(@try) // next;

if (ref $try eq 'ARRAY') {
($C->{'_fate'}, $tag, $try) = @$try;	# next candidate fate
}

$C->deb("statement_02 trying $tag $try") if $::DEBUG & DEBUG::try_processing;
push @gather, ((
sub { my $C=shift;
do {
if (my ($C) = ($C->_SUBSUMEr(['label'], sub {
my $C = shift;
$C->label
}))) {
$C->_SUBSUMEr(['statement'], sub {
my $C = shift;
$C->statement
});
}
else {
();
}
}
},
sub { my $C=shift;
$C->_SUBSUMEr(['statement_control'], sub {
my $C = shift;
$C->statement_control
})
},
sub { my $C=shift;
do {
if (my ($C) = ($C->_SUBSUMEr(['EXPR'], sub {
my $C = shift;
$C->EXPR
}))) {
$C->_BRACKETr(sub {
my $C=shift;
do {
my $C = $C->cursor_xact('ALT ||');
my $xact = $C->xact;
my @gather;
do {
push @gather, $C->before( sub { my $C=shift;
(($C) x !!do {
($::MEMOS[$C->{'_pos'}]{'endstmt'} // 0) == 2 
})
})
}
or $xact->[-2] or
do {
push @gather, do {
if (my ($C) = ($C->ws)) {
$C->_OPTr(sub { my $C=shift;
$C->_BRACKETr(sub {
my $C=shift;
do {
my @result = do {
my $trystate;
my ($tag, $try);
my @try;
my $relex;

my $fate;
my $x;
if ($fate = $C->{'_fate'} and $fate->[1] eq 'statement_05') {
$C->deb("Fate passed to statement_05: ", ::fatestr($fate)) if $::DEBUG & DEBUG::fates;
($C->{'_fate'}, $tag, $try) = @$fate;
@try = ($try);
$x = 'ALT statement_05';    # some outer ltm is controlling us
}
else {
$x = 'ALTLTM statement_05'; # we are top level ltm
}
my $C = $C->cursor_xact($x);
my $xact = $C->xact;

my @gather = ();
for (;;) {
if (not @try) {
$relex //= $C->cursor_fate('STD::P6', 'statement_05', $retree);
@try = $relex->($C, $trystate);
}
last unless @try;
$try = shift(@try) // next;

if (ref $try eq 'ARRAY') {
($C->{'_fate'}, $tag, $try) = @$try;	# next candidate fate
}

$C->deb("statement_05 trying $tag $try") if $::DEBUG & DEBUG::try_processing;
push @gather, ((
sub { my $C=shift;
do {
if (my ($C) = ($C->_SUBSUMEr(['statement_mod_loop'], sub {
my $C = shift;
$C->statement_mod_loop
}))) {
scalar(do {
my $M = $C; 
my $sp = $M->{'EXPR'}{'statement_prefix'};
if ($sp and $sp->{'sym'} eq 'do') {
my $s = $M->{'statement_mod_loop'}[0]{'sym'};
$C->obs("do...$s" ,"repeat...$s");
}
;
}, $C);
}
else {
();
}
}
},
sub { my $C=shift;
do {
if (my ($C) = ($C->_SUBSUMEr(['statement_mod_cond'], sub {
my $C = shift;
$C->statement_mod_cond
}))) {
$C->_BRACKETr(sub {
my $C=shift;
do {
my $C = $C->cursor_xact('ALT ||');
my $xact = $C->xact;
my @gather;
do {
push @gather, $C->before( sub { my $C=shift;
(($C) x !!do {
($::MEMOS[$C->{'_pos'}]{'endstmt'} // 0) == 2 
})
})
}
or $xact->[-2] or
do {
push @gather, do {
if (my ($C) = ($C->ws)) {
$C->_OPTr(sub { my $C=shift;
$C->_SUBSUMEr(['statement_mod_loop'], sub {
my $C = shift;
$C->statement_mod_loop
})
});
}
else {
();
}
}};
@gather;
}
});
}
else {
();
}
}
},
)[$try])->($C);
last if $xact->[-2];  # committed?
last if @gather;
}
@gather;
};
@result;
}

})
});
}
else {
();
}
}};
@gather;
}
});
}
else {
();
}
}
},
sub { my $C=shift;
$C->before(sub { my $C=shift;
$C->_EXACT(';')
})
},
sub { my $C=shift;
do {
if (my ($C) = (scalar(do {

}, $C))) {
$C->panic("Bogus statement");
}
else {
();
}
}
},
)[$try])->($C);
last if $xact->[-2];  # committed?
last if @gather;
}
@gather;
};
@result;
}

}))) {
$C->_OPTr(sub { my $C=shift;
$C->_BRACKETr(sub {
my $C=shift;
do {
if (my ($C) = ($C->before( sub { my $C=shift;
(($C) x !!do {
($::MEMOS[$::MEMOS[$C->{'_pos'}]{'ws'}//$C->{'_pos'}]{'endargs'}//0) == 1 
})
}))) {
do {
if (my ($C) = ($C->_PATTERN(qr/\G((?:[\x20\t\r])*+)/))) {
do {
if (my ($C) = ($C->_NOTBEFORE( sub { my $C=shift;
$C->before(sub { my $C=shift;
do {
my @result = do {
my $trystate;
my ($tag, $try);
my @try;
my $relex;

my $fate;
my $x;
if ($fate = $C->{'_fate'} and $fate->[1] eq 'statement_10') {
$C->deb("Fate passed to statement_10: ", ::fatestr($fate)) if $::DEBUG & DEBUG::fates;
($C->{'_fate'}, $tag, $try) = @$fate;
@try = ($try);
$x = 'ALT statement_10';    # some outer ltm is controlling us
}
else {
$x = 'ALTLTM statement_10'; # we are top level ltm
}
my $C = $C->cursor_xact($x);
my $xact = $C->xact;

my @gather = ();
for (;;) {
if (not @try) {
$relex //= $C->cursor_fate('STD::P6', 'statement_10', $retree);
@try = $relex->($C, $trystate);
}
last unless @try;
$try = shift(@try) // next;

if (ref $try eq 'ARRAY') {
($C->{'_fate'}, $tag, $try) = @$try;	# next candidate fate
}

$C->deb("statement_10 trying $tag $try") if $::DEBUG & DEBUG::try_processing;
push @gather, ((
sub { my $C=shift;
$C->_EXACT(';')
},
sub { my $C=shift;
$C->_EXACT(')')
},
sub { my $C=shift;
$C->_EXACT(']')
},
sub { my $C=shift;
$C->_EXACT('}')
},
)[$try])->($C);
last if $xact->[-2];  # committed?
last if @gather;
}
@gather;
};
@result;
}

})
}))) {
do {
if (my ($C) = ($C->_NOTBEFORE( sub { my $C=shift;
$C->infixstopper
}))) {
do {
if (my ($C) = (scalar(do {
$::HIGHWATER = $C->{'_pos'} = $::MEMOS[$C->{'_pos'}]{'ws'}//$C->{'_pos'}; 
}, $C))) {
$C->panic("Missing punctuation (semicolon or comma?) after block");
}
else {
();
}
};
}
else {
();
}
};
}
else {
();
}
};
}
else {
();
}
};
}
else {
();
}
}
})
});
}
else {
();
}
};
}
else {
();
}
};
}
else {
();
}
}
);
}

##     token eat_terminator
##          token eat_terminator {
##              [
##              || ';' [ <?before $> { $*ORIG ~~ s/\;$/ /; } ]?
##              || <?{ @*MEMOS[$.pos]<endstmt> }> <.ws>
##              || <?terminator>
##              || $
##              || <?stopper>
##              || {{ if @*MEMOS[$.pos]<ws> { $.pos = @*MEMOS[$.pos]<ws>; } }}   # undo any line transition
##                  <.panic: "Confused">
##              ]
##          }

sub eat_terminator__PEEK { $_[0]->_AUTOLEXpeek('eat_terminator',$retree) }
sub eat_terminator {
no warnings 'recursion';
my $self = shift;
local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;


my $C = $self->cursor_xact("RULE eat_terminator");
my $xact = $C->xact;
my $S = $C->{'_pos'};

$self->_MATCHIFYr($S, "eat_terminator", 
$C->_BRACKETr(sub {
my $C=shift;
do {
my $C = $C->cursor_xact('ALT ||');
my $xact = $C->xact;
my @gather;
do {
push @gather, do {
if (my ($C) = ($C->_EXACT(';'))) {
$C->_OPTr(sub { my $C=shift;
$C->_BRACKETr(sub {
my $C=shift;
do {
if (my ($C) = ($C->before(sub { my $C=shift;
$C->_PATTERN(qr/\G\z/)
}))) {
scalar(do {
$::ORIG =~ s/\;$/ /; 
}, $C);
}
else {
();
}
}
})
});
}
else {
();
}
}
}
or $xact->[-2] or
do {
push @gather, do {
if (my ($C) = ($C->before( sub { my $C=shift;
(($C) x !!do {
$::MEMOS[$C->{'_pos'}]{'endstmt'} 
})
}))) {
$C->ws;
}
else {
();
}
}
}
or $xact->[-2] or
do {
push @gather, $C->before( sub { my $C=shift;
$C->terminator
})
}
or $xact->[-2] or
do {
push @gather, $C->_PATTERN(qr/\G\z/)
}
or $xact->[-2] or
do {
push @gather, $C->before( sub { my $C=shift;
$C->stopper
})
}
or $xact->[-2] or
do {
push @gather, do {
if (my ($C) = (scalar(do {
if ($::MEMOS[$C->{'_pos'}]{'ws'}) { $C->{'_pos'} = $::MEMOS[$C->{'_pos'}]{'ws'}; } 
}, $C))) {
$C->panic("Confused");
}
else {
();
}
}};
@gather;
}
})
);
}

#####################
# statement control #
#####################

##     token statement_control__S_062need (:$*endsym = 'spacey', :$*sym = 'need')
##          token statement_control:need {
##              :my $longname;
##              <sym>:s
##              [
##              |<version>
##              |<module_name>
##                  {{
##                      my $*IN_DECL = 'use';
##                      my $*SCOPE = 'use';
##                      $longname = $<module_name>[*-1]<longname>;
##                      $.do_need($longname);
##                  }}
##              ] ** ','
##          }

sub statement_control__S_062need__PEEK { $_[0]->_AUTOLEXpeek('statement_control__S_062need',$retree) }
sub statement_control__S_062need {
no warnings 'recursion';
my $self = shift;
local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;
my %args = @_;
local $::endsym = $args{endsym} // 'spacey';
local $::sym = $args{sym} // 'need';
my $longname;


my $C = $self->cursor_xact("RULE statement_control__S_062need");
my $xact = $C->xact;
my $S = $C->{'_pos'};
$C->{'version'} = [];
$C->{'module_name'} = [];
$C->{'sym'} = ref $sym ? join(' ', @$sym) : $sym;

$self->_MATCHIFYr($S, "statement_control__S_062need", 
do {
if (my ($C) = ($C->_PATTERN(qr/\Gneed/))) {
do {
if (my ($C) = ($C->spacey)) {
do {
if (my ($C) = ($C->ws)) {
do {
if (my ($C) = ($C->_REPSEPr(  sub { my $C=shift;
$C->_EXACT(',')
}, sub { my $C=shift;
$C->_BRACKETr(sub {
my $C=shift;
do {
my @result = do {
my $trystate;
my ($tag, $try);
my @try;
my $relex;

my $fate;
my $x;
if ($fate = $C->{'_fate'} and $fate->[1] eq 'statement_control__S_062need_01') {
$C->deb("Fate passed to statement_control__S_062need_01: ", ::fatestr($fate)) if $::DEBUG & DEBUG::fates;
($C->{'_fate'}, $tag, $try) = @$fate;
@try = ($try);
$x = 'ALT statement_control__S_062need_01';    # some outer ltm is controlling us
}
else {
$x = 'ALTLTM statement_control__S_062need_01'; # we are top level ltm
}
my $C = $C->cursor_xact($x);
my $xact = $C->xact;

my @gather = ();
for (;;) {
if (not @try) {
$relex //= $C->cursor_fate('STD::P6', 'statement_control__S_062need_01', $retree);
@try = $relex->($C, $trystate);
}
last unless @try;
$try = shift(@try) // next;

if (ref $try eq 'ARRAY') {
($C->{'_fate'}, $tag, $try) = @$try;	# next candidate fate
}

$C->deb("statement_control__S_062need_01 trying $tag $try") if $::DEBUG & DEBUG::try_processing;
push @gather, ((
sub { my $C=shift;
do {
if (my ($C) = ($C->_SUBSUMEr(['version'], sub {
my $C = shift;
$C->version
}))) {
$C->ws;
}
else {
();
}
}
},
sub { my $C=shift;
do {
if (my ($C) = ($C->_SUBSUMEr(['module_name'], sub {
my $C = shift;
$C->module_name
}))) {
do {
if (my ($C) = ($C->ws)) {
do {
if (my ($C) = (scalar(do {
my $M = $C; 
local $::IN_DECL = 'use';
local $::SCOPE = 'use';
$longname = $M->{'module_name'}[-1]{'longname'};
$C->do_need($longname);
;
}, $C))) {
$C->ws;
}
else {
();
}
};
}
else {
();
}
};
}
else {
();
}
}
},
)[$try])->($C);
last if $xact->[-2];  # committed?
last if @gather;
}
@gather;
};
@result;
}

})
}))) {
$C->ws;
}
else {
();
}
};
}
else {
();
}
};
}
else {
();
}
};
}
else {
();
}
}
);
}

##     token statement_control__S_063import (:$*endsym = 'spacey', :$*sym = 'import')
##          token statement_control:import {
##              :my $longname;
##              :my $*IN_DECL = 'use';
##              :my $*SCOPE = 'use';
##              <sym> <.ws>
##              <term>
##              [
##              || <.spacey> <arglist>
##                  {{
##                      $.do_import($<term>, $<arglist>);
##                  }}
##              || {{ $.do_import($<term>, ''); }}
##              ]
##              <.ws>
##          }

sub statement_control__S_063import__PEEK { $_[0]->_AUTOLEXpeek('statement_control__S_063import',$retree) }
sub statement_control__S_063import {
no warnings 'recursion';
my $self = shift;
local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;
my %args = @_;
local $::endsym = $args{endsym} // 'spacey';
local $::sym = $args{sym} // 'import';
my $longname;
local $::IN_DECL = 'use';
local $::SCOPE = 'use';


my $C = $self->cursor_xact("RULE statement_control__S_063import");
my $xact = $C->xact;
my $S = $C->{'_pos'};
$C->{'sym'} = ref $sym ? join(' ', @$sym) : $sym;

$self->_MATCHIFYr($S, "statement_control__S_063import", 
do {
if (my ($C) = ($C->_PATTERN(qr/\Gimport/))) {
do {
if (my ($C) = ($C->spacey)) {
do {
if (my ($C) = ($C->ws)) {
do {
if (my ($C) = ($C->_SUBSUMEr(['term'], sub {
my $C = shift;
$C->term
}))) {
do {
if (my ($C) = ($C->_BRACKETr(sub {
my $C=shift;
do {
my $C = $C->cursor_xact('ALT ||');
my $xact = $C->xact;
my @gather;
do {
push @gather, do {
if (my ($C) = ($C->spacey)) {
do {
if (my ($C) = ($C->_SUBSUMEr(['arglist'], sub {
my $C = shift;
$C->arglist
}))) {
scalar(do {
my $M = $C; 
$C->do_import($M->{'term'}, $M->{'arglist'});
;
}, $C);
}
else {
();
}
};
}
else {
();
}
}
}
or $xact->[-2] or
do {
push @gather, scalar(do {
my $M = $C;  $C->do_import($M->{'term'}, ''); ;
}, $C)};
@gather;
}
}))) {
$C->ws;
}
else {
();
}
};
}
else {
();
}
};
}
else {
();
}
};
}
else {
();
}
};
}
else {
();
}
}
);
}

##     token statement_control__S_064use (:$*endsym = 'spacey', :$*sym = 'use')
##          token statement_control:use {
##              :my $longname;
##              :my $*IN_DECL = 'use';
##              :my $*SCOPE = 'use';
##              <sym> <.ws>
##              [
##              | <version>
##              | <module_name>
##                  {{
##                      $longname = $<module_name><longname>;
##                      if $longname.Str eq 'MONKEY_TYPING' {
##                          $*MONKEY_TYPING = True;
##                      }
##                  }}
##                  [
##                  || <.spacey> <arglist>
##                      {{
##                          $.do_use($longname, $<arglist>);
##                      }}
##                  || {{ $.do_use($longname, ''); }}
##                  ]
##              ]
##              <.ws>
##          }

sub statement_control__S_064use__PEEK { $_[0]->_AUTOLEXpeek('statement_control__S_064use',$retree) }
sub statement_control__S_064use {
no warnings 'recursion';
my $self = shift;
local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;
my %args = @_;
local $::endsym = $args{endsym} // 'spacey';
local $::sym = $args{sym} // 'use';
my $longname;
local $::IN_DECL = 'use';
local $::SCOPE = 'use';


my $C = $self->cursor_xact("RULE statement_control__S_064use");
my $xact = $C->xact;
my $S = $C->{'_pos'};
$C->{'sym'} = ref $sym ? join(' ', @$sym) : $sym;

$self->_MATCHIFYr($S, "statement_control__S_064use", 
do {
if (my ($C) = ($C->_PATTERN(qr/\Guse/))) {
do {
if (my ($C) = ($C->spacey)) {
do {
if (my ($C) = ($C->ws)) {
do {
if (my ($C) = ($C->_BRACKETr(sub {
my $C=shift;
do {
my @result = do {
my $trystate;
my ($tag, $try);
my @try;
my $relex;

my $fate;
my $x;
if ($fate = $C->{'_fate'} and $fate->[1] eq 'statement_control__S_064use_01') {
$C->deb("Fate passed to statement_control__S_064use_01: ", ::fatestr($fate)) if $::DEBUG & DEBUG::fates;
($C->{'_fate'}, $tag, $try) = @$fate;
@try = ($try);
$x = 'ALT statement_control__S_064use_01';    # some outer ltm is controlling us
}
else {
$x = 'ALTLTM statement_control__S_064use_01'; # we are top level ltm
}
my $C = $C->cursor_xact($x);
my $xact = $C->xact;

my @gather = ();
for (;;) {
if (not @try) {
$relex //= $C->cursor_fate('STD::P6', 'statement_control__S_064use_01', $retree);
@try = $relex->($C, $trystate);
}
last unless @try;
$try = shift(@try) // next;

if (ref $try eq 'ARRAY') {
($C->{'_fate'}, $tag, $try) = @$try;	# next candidate fate
}

$C->deb("statement_control__S_064use_01 trying $tag $try") if $::DEBUG & DEBUG::try_processing;
push @gather, ((
sub { my $C=shift;
$C->_SUBSUMEr(['version'], sub {
my $C = shift;
$C->version
})
},
sub { my $C=shift;
do {
if (my ($C) = ($C->_SUBSUMEr(['module_name'], sub {
my $C = shift;
$C->module_name
}))) {
do {
if (my ($C) = (scalar(do {
my $M = $C; 
$longname = $M->{'module_name'}{'longname'};
if ($longname->Str eq 'MONKEY_TYPING') {
$::MONKEY_TYPING = 1;
}
;
}, $C))) {
$C->_BRACKETr(sub {
my $C=shift;
do {
my $C = $C->cursor_xact('ALT ||');
my $xact = $C->xact;
my @gather;
do {
push @gather, do {
if (my ($C) = ($C->spacey)) {
do {
if (my ($C) = ($C->_SUBSUMEr(['arglist'], sub {
my $C = shift;
$C->arglist
}))) {
scalar(do {
my $M = $C; 
$C->do_use($longname, $M->{'arglist'});
;
}, $C);
}
else {
();
}
};
}
else {
();
}
}
}
or $xact->[-2] or
do {
push @gather, scalar(do {
$C->do_use($longname, ''); 
}, $C)};
@gather;
}
});
}
else {
();
}
};
}
else {
();
}
}
},
)[$try])->($C);
last if $xact->[-2];  # committed?
last if @gather;
}
@gather;
};
@result;
}

}))) {
$C->ws;
}
else {
();
}
};
}
else {
();
}
};
}
else {
();
}
};
}
else {
();
}
}
);
}


##     token statement_control__S_065no (:$*endsym = 'spacey', :$*sym = 'no')
##          token statement_control:no {
##              <sym> <.ws>
##              <module_name>[<.spacey><arglist>]?
##              <.ws>
##          }

sub statement_control__S_065no__PEEK { $_[0]->_AUTOLEXpeek('statement_control__S_065no',$retree) }
sub statement_control__S_065no {
no warnings 'recursion';
my $self = shift;
local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;
my %args = @_;
local $::endsym = $args{endsym} // 'spacey';
local $::sym = $args{sym} // 'no';


my $C = $self->cursor_xact("RULE statement_control__S_065no");
my $xact = $C->xact;
my $S = $C->{'_pos'};
$C->{'arglist'} = [];
$C->{'sym'} = ref $sym ? join(' ', @$sym) : $sym;

$self->_MATCHIFYr($S, "statement_control__S_065no", 
do {
if (my ($C) = ($C->_PATTERN(qr/\Gno/))) {
do {
if (my ($C) = ($C->spacey)) {
do {
if (my ($C) = ($C->ws)) {
do {
if (my ($C) = ($C->_SUBSUMEr(['module_name'], sub {
my $C = shift;
$C->module_name
}))) {
do {
if (my ($C) = ($C->_OPTr(sub { my $C=shift;
$C->_BRACKETr(sub {
my $C=shift;
do {
if (my ($C) = ($C->spacey)) {
$C->_SUBSUMEr(['arglist'], sub {
my $C = shift;
$C->arglist
});
}
else {
();
}
}
})
}))) {
$C->ws;
}
else {
();
}
};
}
else {
();
}
};
}
else {
();
}
};
}
else {
();
}
};
}
else {
();
}
}
);
}


##     token statement_control__S_066if (:$*endsym = 'spacey', :$*sym = 'if')
##          token statement_control:if {
##              <sym> :s
##              <xblock>
##              [
##                  [ <!before 'else'\s*'if'> || <.panic: "Please use 'elsif'"> ]
##                  'elsif'<?spacey> <elsif=.xblock>
##              ]*
##              [
##                  'else'<?spacey> <else=.pblock>
##              ]?
##          }

sub statement_control__S_066if__PEEK { $_[0]->_AUTOLEXpeek('statement_control__S_066if',$retree) }
sub statement_control__S_066if {
no warnings 'recursion';
my $self = shift;
local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;
my %args = @_;
local $::endsym = $args{endsym} // 'spacey';
local $::sym = $args{sym} // 'if';


my $C = $self->cursor_xact("RULE statement_control__S_066if");
my $xact = $C->xact;
my $S = $C->{'_pos'};
$C->{'else'} = [];
$C->{'elsif'} = [];
$C->{'sym'} = ref $sym ? join(' ', @$sym) : $sym;

$self->_MATCHIFYr($S, "statement_control__S_066if", 
do {
if (my ($C) = ($C->_PATTERN(qr/\Gif/))) {
do {
if (my ($C) = ($C->spacey)) {
do {
if (my ($C) = ($C->ws)) {
do {
if (my ($C) = ($C->_SUBSUMEr(['xblock'], sub {
my $C = shift;
$C->xblock
}))) {
do {
if (my ($C) = ($C->ws)) {
do {
if (my ($C) = ($C->_STARr(sub { my $C=shift;
$C->_BRACKETr(sub {
my $C=shift;
do {
if (my ($C) = ($C->ws)) {
do {
if (my ($C) = ($C->_BRACKETr(sub {
my $C=shift;
do {
my $C = $C->cursor_xact('ALT ||');
my $xact = $C->xact;
my @gather;
do {
push @gather, do {
if (my ($C) = ($C->_NOTBEFORE( sub { my $C=shift;
$C->before(sub { my $C=shift;
do {
if (my ($C) = ($C->_EXACT('else'))) {
do {
if (my ($C) = ($C->_PATTERN(qr/\G((?:\s)*+)/))) {
$C->_EXACT('if');
}
else {
();
}
};
}
else {
();
}
}
})
}))) {
$C->ws;
}
else {
();
}
}
}
or $xact->[-2] or
do {
push @gather, do {
if (my ($C) = ($C->panic("Please use 'elsif'"))) {
$C->ws;
}
else {
();
}
}};
@gather;
}
}))) {
do {
if (my ($C) = ($C->ws)) {
do {
if (my ($C) = ($C->_EXACT('elsif'))) {
do {
if (my ($C) = ($C->before( sub { my $C=shift;
$C->spacey
}))) {
do {
if (my ($C) = ($C->ws)) {
do {
if (my ($C) = (  $C->_SUBSUMEr(['elsif'], sub {
my $C = shift;
$C->xblock
}))) {
$C->ws;
}
else {
();
}
};
}
else {
();
}
};
}
else {
();
}
};
}
else {
();
}
};
}
else {
();
}
};
}
else {
();
}
};
}
else {
();
}
}
})
}))) {
do {
if (my ($C) = ($C->ws)) {
do {
if (my ($C) = ($C->_OPTr(sub { my $C=shift;
$C->_BRACKETr(sub {
my $C=shift;
do {
if (my ($C) = ($C->ws)) {
do {
if (my ($C) = ($C->_EXACT('else'))) {
do {
if (my ($C) = ($C->before( sub { my $C=shift;
$C->spacey
}))) {
do {
if (my ($C) = ($C->ws)) {
do {
if (my ($C) = (  $C->_SUBSUMEr(['else'], sub {
my $C = shift;
$C->pblock
}))) {
$C->ws;
}
else {
();
}
};
}
else {
();
}
};
}
else {
();
}
};
}
else {
();
}
};
}
else {
();
}
}
})
}))) {
$C->ws;
}
else {
();
}
};
}
else {
();
}
};
}
else {
();
}
};
}
else {
();
}
};
}
else {
();
}
};
}
else {
();
}
};
}
else {
();
}
};
}
else {
();
}
}
);
}


##     token statement_control__S_067unless (:$*endsym = 'spacey', :$*sym = 'unless')
##          token statement_control:unless {
##              <sym> :s
##              <xblock>
##              [ <!before 'else'> || <.panic: "unless does not take \"else\" in Perl 6; please rewrite using \"if\""> ]
##          }

sub statement_control__S_067unless__PEEK { $_[0]->_AUTOLEXpeek('statement_control__S_067unless',$retree) }
sub statement_control__S_067unless {
no warnings 'recursion';
my $self = shift;
local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;
my %args = @_;
local $::endsym = $args{endsym} // 'spacey';
local $::sym = $args{sym} // 'unless';


my $C = $self->cursor_xact("RULE statement_control__S_067unless");
my $xact = $C->xact;
my $S = $C->{'_pos'};
$C->{'sym'} = ref $sym ? join(' ', @$sym) : $sym;

$self->_MATCHIFYr($S, "statement_control__S_067unless", 
do {
if (my ($C) = ($C->_PATTERN(qr/\Gunless/))) {
do {
if (my ($C) = ($C->spacey)) {
do {
if (my ($C) = ($C->ws)) {
do {
if (my ($C) = ($C->_SUBSUMEr(['xblock'], sub {
my $C = shift;
$C->xblock
}))) {
do {
if (my ($C) = ($C->ws)) {
do {
if (my ($C) = ($C->_BRACKETr(sub {
my $C=shift;
do {
my $C = $C->cursor_xact('ALT ||');
my $xact = $C->xact;
my @gather;
do {
push @gather, do {
if (my ($C) = ($C->_NOTBEFORE( sub { my $C=shift;
$C->before(sub { my $C=shift;
$C->_EXACT('else')
})
}))) {
$C->ws;
}
else {
();
}
}
}
or $xact->[-2] or
do {
push @gather, do {
if (my ($C) = ($C->panic("unless does not take \"else\" in Perl 6; please rewrite using \"if\""))) {
$C->ws;
}
else {
();
}
}};
@gather;
}
}))) {
$C->ws;
}
else {
();
}
};
}
else {
();
}
};
}
else {
();
}
};
}
else {
();
}
};
}
else {
();
}
};
}
else {
();
}
}
);
}


##     token statement_control__S_068while (:$*endsym = 'spacey', :$*sym = 'while')
##          token statement_control:while {
##              <sym> :s
##              [ <?before '(' ['my'? '$'\w+ '=']? '<' '$'?\w+ '>' ')'>   #'
##                  <.panic: "This appears to be Perl 5 code"> ]?
##              <xblock>
##          }

sub statement_control__S_068while__PEEK { $_[0]->_AUTOLEXpeek('statement_control__S_068while',$retree) }
sub statement_control__S_068while {
no warnings 'recursion';
my $self = shift;
local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;
my %args = @_;
local $::endsym = $args{endsym} // 'spacey';
local $::sym = $args{sym} // 'while';


my $C = $self->cursor_xact("RULE statement_control__S_068while");
my $xact = $C->xact;
my $S = $C->{'_pos'};
$C->{'sym'} = ref $sym ? join(' ', @$sym) : $sym;

$self->_MATCHIFYr($S, "statement_control__S_068while", 
do {
if (my ($C) = ($C->_PATTERN(qr/\Gwhile/))) {
do {
if (my ($C) = ($C->spacey)) {
do {
if (my ($C) = ($C->ws)) {
do {
if (my ($C) = ($C->_OPTr(sub { my $C=shift;
$C->_BRACKETr(sub {
my $C=shift;
do {
if (my ($C) = ($C->ws)) {
do {
if (my ($C) = ($C->before(sub { my $C=shift;
do {
if (my ($C) = ($C->_EXACT('('))) {
do {
if (my ($C) = ($C->ws)) {
do {
if (my ($C) = ($C->_OPTr(sub { my $C=shift;
$C->_BRACKETr(sub {
my $C=shift;
do {
if (my ($C) = ($C->_OPTr(sub { my $C=shift;
$C->_EXACT('my')
}))) {
do {
if (my ($C) = ($C->ws)) {
do {
if (my ($C) = ($C->_EXACT('$'))) {
do {
if (my ($C) = ($C->_PATTERN(qr/\G((?:\w)++)/))) {
do {
if (my ($C) = ($C->ws)) {
$C->_EXACT('=');
}
else {
();
}
};
}
else {
();
}
};
}
else {
();
}
};
}
else {
();
}
};
}
else {
();
}
}
})
}))) {
do {
if (my ($C) = ($C->ws)) {
do {
if (my ($C) = ($C->_EXACT('<'))) {
do {
if (my ($C) = ($C->ws)) {
do {
if (my ($C) = ($C->_OPTr(sub { my $C=shift;
$C->_EXACT('$')
}))) {
do {
if (my ($C) = ($C->_PATTERN(qr/\G((?:\w)++)/))) {
do {
if (my ($C) = ($C->ws)) {
do {
if (my ($C) = ($C->_EXACT('>'))) {
do {
if (my ($C) = ($C->ws)) {
$C->_EXACT(')');
}
else {
();
}
};
}
else {
();
}
};
}
else {
();
}
};
}
else {
();
}
};
}
else {
();
}
};
}
else {
();
}
};
}
else {
();
}
};
}
else {
();
}
};
}
else {
();
}
};
}
else {
();
}
};
}
else {
();
}
}
}))) {
do {
if (my ($C) = ($C->ws)) {
do {
if (my ($C) = ($C->panic("This appears to be Perl 5 code"))) {
$C->ws;
}
else {
();
}
};
}
else {
();
}
};
}
else {
();
}
};
}
else {
();
}
}
})
}))) {
do {
if (my ($C) = ($C->ws)) {
do {
if (my ($C) = ($C->_SUBSUMEr(['xblock'], sub {
my $C = shift;
$C->xblock
}))) {
$C->ws;
}
else {
();
}
};
}
else {
();
}
};
}
else {
();
}
};
}
else {
();
}
};
}
else {
();
}
};
}
else {
();
}
}
);
}


##     token statement_control__S_069until (:$*endsym = 'spacey', :$*sym = 'until')
##          token statement_control:until {
##              <sym> :s
##              <xblock>
##          }

sub statement_control__S_069until__PEEK { $_[0]->_AUTOLEXpeek('statement_control__S_069until',$retree) }
sub statement_control__S_069until {
no warnings 'recursion';
my $self = shift;
local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;
my %args = @_;
local $::endsym = $args{endsym} // 'spacey';
local $::sym = $args{sym} // 'until';


my $C = $self->cursor_xact("RULE statement_control__S_069until");
my $xact = $C->xact;
my $S = $C->{'_pos'};
$C->{'sym'} = ref $sym ? join(' ', @$sym) : $sym;

$self->_MATCHIFYr($S, "statement_control__S_069until", 
do {
if (my ($C) = ($C->_PATTERN(qr/\Guntil/))) {
do {
if (my ($C) = ($C->spacey)) {
do {
if (my ($C) = ($C->ws)) {
do {
if (my ($C) = ($C->_SUBSUMEr(['xblock'], sub {
my $C = shift;
$C->xblock
}))) {
$C->ws;
}
else {
();
}
};
}
else {
();
}
};
}
else {
();
}
};
}
else {
();
}
}
);
}


##     token statement_control__S_070repeat (:$*endsym = 'spacey', :$*sym = 'repeat')
##          token statement_control:repeat {
##              <sym> :s
##              [
##                  | $<wu>=['while'|'until']<.spacey>
##                    <xblock>
##                  | <pblock>
##                    $<wu>=['while'|'until'][<.spacey>||<.panic: "Whitespace required after keyword">] <EXPR>
##              ]
##          }

sub statement_control__S_070repeat__PEEK { $_[0]->_AUTOLEXpeek('statement_control__S_070repeat',$retree) }
sub statement_control__S_070repeat {
no warnings 'recursion';
my $self = shift;
local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;
my %args = @_;
local $::endsym = $args{endsym} // 'spacey';
local $::sym = $args{sym} // 'repeat';


my $C = $self->cursor_xact("RULE statement_control__S_070repeat");
my $xact = $C->xact;
my $S = $C->{'_pos'};
$C->{'sym'} = ref $sym ? join(' ', @$sym) : $sym;

$self->_MATCHIFYr($S, "statement_control__S_070repeat", 
do {
if (my ($C) = ($C->_PATTERN(qr/\Grepeat/))) {
do {
if (my ($C) = ($C->spacey)) {
do {
if (my ($C) = ($C->ws)) {
do {
if (my ($C) = ($C->_BRACKETr(sub {
my $C=shift;
do {
my @result = do {
my $trystate;
my ($tag, $try);
my @try;
my $relex;

my $fate;
my $x;
if ($fate = $C->{'_fate'} and $fate->[1] eq 'statement_control__S_070repeat_01') {
$C->deb("Fate passed to statement_control__S_070repeat_01: ", ::fatestr($fate)) if $::DEBUG & DEBUG::fates;
($C->{'_fate'}, $tag, $try) = @$fate;
@try = ($try);
$x = 'ALT statement_control__S_070repeat_01';    # some outer ltm is controlling us
}
else {
$x = 'ALTLTM statement_control__S_070repeat_01'; # we are top level ltm
}
my $C = $C->cursor_xact($x);
my $xact = $C->xact;

my @gather = ();
for (;;) {
if (not @try) {
$relex //= $C->cursor_fate('STD::P6', 'statement_control__S_070repeat_01', $retree);
@try = $relex->($C, $trystate);
}
last unless @try;
$try = shift(@try) // next;

if (ref $try eq 'ARRAY') {
($C->{'_fate'}, $tag, $try) = @$try;	# next candidate fate
}

$C->deb("statement_control__S_070repeat_01 trying $tag $try") if $::DEBUG & DEBUG::try_processing;
push @gather, ((
sub { my $C=shift;
do {
if (my ($C) = (  $C->_SUBSUMEr(['wu'], sub {
my $C = shift;
$C->_BRACKETr(sub {
my $C=shift;
do {
my @result = do {
my $trystate;
my ($tag, $try);
my @try;
my $relex;

my $fate;
my $x;
if ($fate = $C->{'_fate'} and $fate->[1] eq 'statement_control__S_070repeat_02') {
$C->deb("Fate passed to statement_control__S_070repeat_02: ", ::fatestr($fate)) if $::DEBUG & DEBUG::fates;
($C->{'_fate'}, $tag, $try) = @$fate;
@try = ($try);
$x = 'ALT statement_control__S_070repeat_02';    # some outer ltm is controlling us
}
else {
$x = 'ALTLTM statement_control__S_070repeat_02'; # we are top level ltm
}
my $C = $C->cursor_xact($x);
my $xact = $C->xact;

my @gather = ();
for (;;) {
if (not @try) {
$relex //= $C->cursor_fate('STD::P6', 'statement_control__S_070repeat_02', $retree);
@try = $relex->($C, $trystate);
}
last unless @try;
$try = shift(@try) // next;

if (ref $try eq 'ARRAY') {
($C->{'_fate'}, $tag, $try) = @$try;	# next candidate fate
}

$C->deb("statement_control__S_070repeat_02 trying $tag $try") if $::DEBUG & DEBUG::try_processing;
push @gather, ((
sub { my $C=shift;
$C->_EXACT('while')
},
sub { my $C=shift;
$C->_EXACT('until')
},
)[$try])->($C);
last if $xact->[-2];  # committed?
last if @gather;
}
@gather;
};
@result;
}

})
}))) {
do {
if (my ($C) = ($C->spacey)) {
do {
if (my ($C) = ($C->ws)) {
do {
if (my ($C) = ($C->_SUBSUMEr(['xblock'], sub {
my $C = shift;
$C->xblock
}))) {
$C->ws;
}
else {
();
}
};
}
else {
();
}
};
}
else {
();
}
};
}
else {
();
}
}
},
sub { my $C=shift;
do {
if (my ($C) = ($C->_SUBSUMEr(['pblock'], sub {
my $C = shift;
$C->pblock
}))) {
do {
if (my ($C) = ($C->ws)) {
do {
if (my ($C) = (  $C->_SUBSUMEr(['wu'], sub {
my $C = shift;
$C->_BRACKETr(sub {
my $C=shift;
do {
my @result = do {
my $trystate;
my ($tag, $try);
my @try;
my $relex;

my $fate;
my $x;
if ($fate = $C->{'_fate'} and $fate->[1] eq 'statement_control__S_070repeat_03') {
$C->deb("Fate passed to statement_control__S_070repeat_03: ", ::fatestr($fate)) if $::DEBUG & DEBUG::fates;
($C->{'_fate'}, $tag, $try) = @$fate;
@try = ($try);
$x = 'ALT statement_control__S_070repeat_03';    # some outer ltm is controlling us
}
else {
$x = 'ALTLTM statement_control__S_070repeat_03'; # we are top level ltm
}
my $C = $C->cursor_xact($x);
my $xact = $C->xact;

my @gather = ();
for (;;) {
if (not @try) {
$relex //= $C->cursor_fate('STD::P6', 'statement_control__S_070repeat_03', $retree);
@try = $relex->($C, $trystate);
}
last unless @try;
$try = shift(@try) // next;

if (ref $try eq 'ARRAY') {
($C->{'_fate'}, $tag, $try) = @$try;	# next candidate fate
}

$C->deb("statement_control__S_070repeat_03 trying $tag $try") if $::DEBUG & DEBUG::try_processing;
push @gather, ((
sub { my $C=shift;
$C->_EXACT('while')
},
sub { my $C=shift;
$C->_EXACT('until')
},
)[$try])->($C);
last if $xact->[-2];  # committed?
last if @gather;
}
@gather;
};
@result;
}

})
}))) {
do {
if (my ($C) = ($C->_BRACKETr(sub {
my $C=shift;
do {
my $C = $C->cursor_xact('ALT ||');
my $xact = $C->xact;
my @gather;
do {
push @gather, $C->spacey
}
or $xact->[-2] or
do {
push @gather, $C->panic("Whitespace required after keyword")};
@gather;
}
}))) {
do {
if (my ($C) = ($C->ws)) {
do {
if (my ($C) = ($C->_SUBSUMEr(['EXPR'], sub {
my $C = shift;
$C->EXPR
}))) {
$C->ws;
}
else {
();
}
};
}
else {
();
}
};
}
else {
();
}
};
}
else {
();
}
};
}
else {
();
}
};
}
else {
();
}
}
},
)[$try])->($C);
last if $xact->[-2];  # committed?
last if @gather;
}
@gather;
};
@result;
}

}))) {
$C->ws;
}
else {
();
}
};
}
else {
();
}
};
}
else {
();
}
};
}
else {
();
}
}
);
}

##     token statement_control__S_071loop (:$*endsym = 'spacey', :$*sym = 'loop')
##          token statement_control:loop {
##              <sym> <.ws>
##              $<eee> = (
##                  '(' [ :s
##                      <e1=.EXPR>? ';'
##                      <e2=.EXPR>? ';'
##                      <e3=.EXPR>?
##                  ')'||<.panic: "Malformed loop spec">]
##                  [ <?before '{' > <.panic: "Whitespace required before block"> ]?
##              )? <.ws>
##              <block>
##          }

sub statement_control__S_071loop__PEEK { $_[0]->_AUTOLEXpeek('statement_control__S_071loop',$retree) }
sub statement_control__S_071loop {
no warnings 'recursion';
my $self = shift;
local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;
my %args = @_;
local $::endsym = $args{endsym} // 'spacey';
local $::sym = $args{sym} // 'loop';


my $C = $self->cursor_xact("RULE statement_control__S_071loop");
my $xact = $C->xact;
my $S = $C->{'_pos'};
$C->{'sym'} = ref $sym ? join(' ', @$sym) : $sym;

$self->_MATCHIFYr($S, "statement_control__S_071loop", 
do {
if (my ($C) = ($C->_PATTERN(qr/\Gloop/))) {
do {
if (my ($C) = ($C->spacey)) {
do {
if (my ($C) = ($C->ws)) {
do {
if (my ($C) = (  $C->_OPTr(sub { my $C=shift;
$C->_SUBSUMEr(['eee'], sub {
my $C = shift;
do { $C->_PAREN( sub { my $C=shift;
do {
if (my ($C) = ($C->_EXACT('('))) {
do {
if (my ($C) = ($C->_BRACKETr(sub {
my $C=shift;
do {
my $C = $C->cursor_xact('ALT ||');
my $xact = $C->xact;
my @gather;
do {
push @gather, do {
if (my ($C) = ($C->ws)) {
do {
if (my ($C) = (  $C->_OPTr(sub { my $C=shift;
$C->_SUBSUMEr(['e1'], sub {
my $C = shift;
$C->EXPR
})
}))) {
do {
if (my ($C) = ($C->ws)) {
do {
if (my ($C) = ($C->_EXACT(';'))) {
do {
if (my ($C) = ($C->ws)) {
do {
if (my ($C) = (  $C->_OPTr(sub { my $C=shift;
$C->_SUBSUMEr(['e2'], sub {
my $C = shift;
$C->EXPR
})
}))) {
do {
if (my ($C) = ($C->ws)) {
do {
if (my ($C) = ($C->_EXACT(';'))) {
do {
if (my ($C) = ($C->ws)) {
do {
if (my ($C) = (  $C->_OPTr(sub { my $C=shift;
$C->_SUBSUMEr(['e3'], sub {
my $C = shift;
$C->EXPR
})
}))) {
do {
if (my ($C) = ($C->ws)) {
$C->_EXACT(')');
}
else {
();
}
};
}
else {
();
}
};
}
else {
();
}
};
}
else {
();
}
};
}
else {
();
}
};
}
else {
();
}
};
}
else {
();
}
};
}
else {
();
}
};
}
else {
();
}
};
}
else {
();
}
};
}
else {
();
}
}
}
or $xact->[-2] or
do {
push @gather, $C->panic("Malformed loop spec")};
@gather;
}
}))) {
$C->_OPTr(sub { my $C=shift;
$C->_BRACKETr(sub {
my $C=shift;
do {
if (my ($C) = ($C->before(sub { my $C=shift;
$C->_EXACT('{')
}))) {
$C->panic("Whitespace required before block");
}
else {
();
}
}
})
});
}
else {
();
}
};
}
else {
();
}
}
})}
})
}))) {
do {
if (my ($C) = ($C->ws)) {
$C->_SUBSUMEr(['block'], sub {
my $C = shift;
$C->block
});
}
else {
();
}
};
}
else {
();
}
};
}
else {
();
}
};
}
else {
();
}
};
}
else {
();
}
}
);
}


##     token statement_control__S_072for (:$*endsym = 'spacey', :$*sym = 'for')
##          token statement_control:for {
##              <sym> :s
##              [ <?before 'my'? '$'\w+ '(' >
##                  <.panic: "This appears to be Perl 5 code"> ]?
##              [ <?before '(' <.EXPR>? ';' <.EXPR>? ';' <.EXPR>? ')' >
##                  <.obs('C-style "for (;;)" loop', '"loop (;;)"')> ]?
##              <xblock>
##          }

sub statement_control__S_072for__PEEK { $_[0]->_AUTOLEXpeek('statement_control__S_072for',$retree) }
sub statement_control__S_072for {
no warnings 'recursion';
my $self = shift;
local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;
my %args = @_;
local $::endsym = $args{endsym} // 'spacey';
local $::sym = $args{sym} // 'for';


my $C = $self->cursor_xact("RULE statement_control__S_072for");
my $xact = $C->xact;
my $S = $C->{'_pos'};
$C->{'sym'} = ref $sym ? join(' ', @$sym) : $sym;

$self->_MATCHIFYr($S, "statement_control__S_072for", 
do {
if (my ($C) = ($C->_PATTERN(qr/\Gfor/))) {
do {
if (my ($C) = ($C->spacey)) {
do {
if (my ($C) = ($C->ws)) {
do {
if (my ($C) = ($C->_OPTr(sub { my $C=shift;
$C->_BRACKETr(sub {
my $C=shift;
do {
if (my ($C) = ($C->ws)) {
do {
if (my ($C) = ($C->before(sub { my $C=shift;
do {
if (my ($C) = ($C->_OPTr(sub { my $C=shift;
$C->_EXACT('my')
}))) {
do {
if (my ($C) = ($C->ws)) {
do {
if (my ($C) = ($C->_EXACT('$'))) {
do {
if (my ($C) = ($C->_PATTERN(qr/\G((?:\w)++)/))) {
do {
if (my ($C) = ($C->ws)) {
do {
if (my ($C) = ($C->_EXACT('('))) {
$C->ws;
}
else {
();
}
};
}
else {
();
}
};
}
else {
();
}
};
}
else {
();
}
};
}
else {
();
}
};
}
else {
();
}
}
}))) {
do {
if (my ($C) = ($C->ws)) {
do {
if (my ($C) = ($C->panic("This appears to be Perl 5 code"))) {
$C->ws;
}
else {
();
}
};
}
else {
();
}
};
}
else {
();
}
};
}
else {
();
}
}
})
}))) {
do {
if (my ($C) = ($C->ws)) {
do {
if (my ($C) = ($C->_OPTr(sub { my $C=shift;
$C->_BRACKETr(sub {
my $C=shift;
do {
if (my ($C) = ($C->ws)) {
do {
if (my ($C) = ($C->before(sub { my $C=shift;
do {
if (my ($C) = ($C->_EXACT('('))) {
do {
if (my ($C) = ($C->ws)) {
do {
if (my ($C) = ($C->_OPTr(sub { my $C=shift;
$C->EXPR
}))) {
do {
if (my ($C) = ($C->ws)) {
do {
if (my ($C) = ($C->_EXACT(';'))) {
do {
if (my ($C) = ($C->ws)) {
do {
if (my ($C) = ($C->_OPTr(sub { my $C=shift;
$C->EXPR
}))) {
do {
if (my ($C) = ($C->ws)) {
do {
if (my ($C) = ($C->_EXACT(';'))) {
do {
if (my ($C) = ($C->ws)) {
do {
if (my ($C) = ($C->_OPTr(sub { my $C=shift;
$C->EXPR
}))) {
do {
if (my ($C) = ($C->ws)) {
do {
if (my ($C) = ($C->_EXACT(')'))) {
$C->ws;
}
else {
();
}
};
}
else {
();
}
};
}
else {
();
}
};
}
else {
();
}
};
}
else {
();
}
};
}
else {
();
}
};
}
else {
();
}
};
}
else {
();
}
};
}
else {
();
}
};
}
else {
();
}
};
}
else {
();
}
};
}
else {
();
}
};
}
else {
();
}
}
}))) {
do {
if (my ($C) = ($C->ws)) {
do {
if (my ($C) = ($C->obs('C-style "for (;;)" loop', '"loop (;;)"'))) {
$C->ws;
}
else {
();
}
};
}
else {
();
}
};
}
else {
();
}
};
}
else {
();
}
}
})
}))) {
do {
if (my ($C) = ($C->ws)) {
do {
if (my ($C) = ($C->_SUBSUMEr(['xblock'], sub {
my $C = shift;
$C->xblock
}))) {
$C->ws;
}
else {
();
}
};
}
else {
();
}
};
}
else {
();
}
};
}
else {
();
}
};
}
else {
();
}
};
}
else {
();
}
};
}
else {
();
}
};
}
else {
();
}
}
);
}

##     token statement_control__S_073given (:$*endsym = 'spacey', :$*sym = 'given')
##          token statement_control:given {
##              <sym> :s
##              <xblock>
##          }

sub statement_control__S_073given__PEEK { $_[0]->_AUTOLEXpeek('statement_control__S_073given',$retree) }
sub statement_control__S_073given {
no warnings 'recursion';
my $self = shift;
local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;
my %args = @_;
local $::endsym = $args{endsym} // 'spacey';
local $::sym = $args{sym} // 'given';


my $C = $self->cursor_xact("RULE statement_control__S_073given");
my $xact = $C->xact;
my $S = $C->{'_pos'};
$C->{'sym'} = ref $sym ? join(' ', @$sym) : $sym;

$self->_MATCHIFYr($S, "statement_control__S_073given", 
do {
if (my ($C) = ($C->_PATTERN(qr/\Ggiven/))) {
do {
if (my ($C) = ($C->spacey)) {
do {
if (my ($C) = ($C->ws)) {
do {
if (my ($C) = ($C->_SUBSUMEr(['xblock'], sub {
my $C = shift;
$C->xblock
}))) {
$C->ws;
}
else {
();
}
};
}
else {
();
}
};
}
else {
();
}
};
}
else {
();
}
}
);
}
##     token statement_control__S_074when (:$*endsym = 'spacey', :$*sym = 'when')
##          token statement_control:when {
##              <sym> :s
##              <xblock>
##          }

sub statement_control__S_074when__PEEK { $_[0]->_AUTOLEXpeek('statement_control__S_074when',$retree) }
sub statement_control__S_074when {
no warnings 'recursion';
my $self = shift;
local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;
my %args = @_;
local $::endsym = $args{endsym} // 'spacey';
local $::sym = $args{sym} // 'when';


my $C = $self->cursor_xact("RULE statement_control__S_074when");
my $xact = $C->xact;
my $S = $C->{'_pos'};
$C->{'sym'} = ref $sym ? join(' ', @$sym) : $sym;

$self->_MATCHIFYr($S, "statement_control__S_074when", 
do {
if (my ($C) = ($C->_PATTERN(qr/\Gwhen/))) {
do {
if (my ($C) = ($C->spacey)) {
do {
if (my ($C) = ($C->ws)) {
do {
if (my ($C) = ($C->_SUBSUMEr(['xblock'], sub {
my $C = shift;
$C->xblock
}))) {
$C->ws;
}
else {
();
}
};
}
else {
();
}
};
}
else {
();
}
};
}
else {
();
}
}
);
}
##     rule statement_control__S_075default (:$*endsym = 'spacey', :$*sym = 'default')
##          rule statement_control:default {<sym> <block> }

sub statement_control__S_075default__PEEK { $_[0]->_AUTOLEXpeek('statement_control__S_075default',$retree) }
sub statement_control__S_075default {
no warnings 'recursion';
my $self = shift;
local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;
my %args = @_;
local $::endsym = $args{endsym} // 'spacey';
local $::sym = $args{sym} // 'default';


my $C = $self->cursor_xact("RULE statement_control__S_075default");
my $xact = $C->xact;
my $S = $C->{'_pos'};
$C->{'sym'} = ref $sym ? join(' ', @$sym) : $sym;

$self->_MATCHIFYr($S, "statement_control__S_075default", 
do {
if (my ($C) = ($C->_PATTERN(qr/\Gdefault/))) {
do {
if (my ($C) = ($C->spacey)) {
do {
if (my ($C) = ($C->ws)) {
do {
if (my ($C) = ($C->_SUBSUMEr(['block'], sub {
my $C = shift;
$C->block
}))) {
$C->ws;
}
else {
();
}
};
}
else {
();
}
};
}
else {
();
}
};
}
else {
();
}
}
);
}

##     token statement_prefix__S_076BEGIN (:$*sym = 'BEGIN')
##          token statement_prefix:BEGIN   { <sym> <blast> }

sub statement_prefix__S_076BEGIN__PEEK { $_[0]->_AUTOLEXpeek('statement_prefix__S_076BEGIN',$retree) }
sub statement_prefix__S_076BEGIN {
no warnings 'recursion';
my $self = shift;
local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;
my %args = @_;
local $::sym = $args{sym} // 'BEGIN';


my $C = $self->cursor_xact("RULE statement_prefix__S_076BEGIN");
my $xact = $C->xact;
my $S = $C->{'_pos'};
$C->{'sym'} = ref $sym ? join(' ', @$sym) : $sym;

$self->_MATCHIFYr($S, "statement_prefix__S_076BEGIN", 
do {
if (my ($C) = ($C->_PATTERN(qr/\GBEGIN/))) {
$C->_SUBSUMEr(['blast'], sub {
my $C = shift;
$C->blast
});
}
else {
();
}
}
);
}
##     token statement_prefix__S_077CHECK (:$*sym = 'CHECK')
##          token statement_prefix:CHECK   { <sym> <blast> }

sub statement_prefix__S_077CHECK__PEEK { $_[0]->_AUTOLEXpeek('statement_prefix__S_077CHECK',$retree) }
sub statement_prefix__S_077CHECK {
no warnings 'recursion';
my $self = shift;
local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;
my %args = @_;
local $::sym = $args{sym} // 'CHECK';


my $C = $self->cursor_xact("RULE statement_prefix__S_077CHECK");
my $xact = $C->xact;
my $S = $C->{'_pos'};
$C->{'sym'} = ref $sym ? join(' ', @$sym) : $sym;

$self->_MATCHIFYr($S, "statement_prefix__S_077CHECK", 
do {
if (my ($C) = ($C->_PATTERN(qr/\GCHECK/))) {
$C->_SUBSUMEr(['blast'], sub {
my $C = shift;
$C->blast
});
}
else {
();
}
}
);
}
##     token statement_prefix__S_078INIT (:$*sym = 'INIT')
##          token statement_prefix:INIT    { <sym> <blast> }

sub statement_prefix__S_078INIT__PEEK { $_[0]->_AUTOLEXpeek('statement_prefix__S_078INIT',$retree) }
sub statement_prefix__S_078INIT {
no warnings 'recursion';
my $self = shift;
local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;
my %args = @_;
local $::sym = $args{sym} // 'INIT';


my $C = $self->cursor_xact("RULE statement_prefix__S_078INIT");
my $xact = $C->xact;
my $S = $C->{'_pos'};
$C->{'sym'} = ref $sym ? join(' ', @$sym) : $sym;

$self->_MATCHIFYr($S, "statement_prefix__S_078INIT", 
do {
if (my ($C) = ($C->_PATTERN(qr/\GINIT/))) {
$C->_SUBSUMEr(['blast'], sub {
my $C = shift;
$C->blast
});
}
else {
();
}
}
);
}
##     token statement_prefix__S_079START (:$*sym = 'START')
##          token statement_prefix:START   { <sym> <blast> }

sub statement_prefix__S_079START__PEEK { $_[0]->_AUTOLEXpeek('statement_prefix__S_079START',$retree) }
sub statement_prefix__S_079START {
no warnings 'recursion';
my $self = shift;
local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;
my %args = @_;
local $::sym = $args{sym} // 'START';


my $C = $self->cursor_xact("RULE statement_prefix__S_079START");
my $xact = $C->xact;
my $S = $C->{'_pos'};
$C->{'sym'} = ref $sym ? join(' ', @$sym) : $sym;

$self->_MATCHIFYr($S, "statement_prefix__S_079START", 
do {
if (my ($C) = ($C->_PATTERN(qr/\GSTART/))) {
$C->_SUBSUMEr(['blast'], sub {
my $C = shift;
$C->blast
});
}
else {
();
}
}
);
}
##     token statement_prefix__S_080ENTER (:$*sym = 'ENTER')
##          token statement_prefix:ENTER   { <sym> <blast> }

sub statement_prefix__S_080ENTER__PEEK { $_[0]->_AUTOLEXpeek('statement_prefix__S_080ENTER',$retree) }
sub statement_prefix__S_080ENTER {
no warnings 'recursion';
my $self = shift;
local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;
my %args = @_;
local $::sym = $args{sym} // 'ENTER';


my $C = $self->cursor_xact("RULE statement_prefix__S_080ENTER");
my $xact = $C->xact;
my $S = $C->{'_pos'};
$C->{'sym'} = ref $sym ? join(' ', @$sym) : $sym;

$self->_MATCHIFYr($S, "statement_prefix__S_080ENTER", 
do {
if (my ($C) = ($C->_PATTERN(qr/\GENTER/))) {
$C->_SUBSUMEr(['blast'], sub {
my $C = shift;
$C->blast
});
}
else {
();
}
}
);
}
##     token statement_prefix__S_081FIRST (:$*sym = 'FIRST')
##          token statement_prefix:FIRST   { <sym> <blast> }

sub statement_prefix__S_081FIRST__PEEK { $_[0]->_AUTOLEXpeek('statement_prefix__S_081FIRST',$retree) }
sub statement_prefix__S_081FIRST {
no warnings 'recursion';
my $self = shift;
local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;
my %args = @_;
local $::sym = $args{sym} // 'FIRST';


my $C = $self->cursor_xact("RULE statement_prefix__S_081FIRST");
my $xact = $C->xact;
my $S = $C->{'_pos'};
$C->{'sym'} = ref $sym ? join(' ', @$sym) : $sym;

$self->_MATCHIFYr($S, "statement_prefix__S_081FIRST", 
do {
if (my ($C) = ($C->_PATTERN(qr/\GFIRST/))) {
$C->_SUBSUMEr(['blast'], sub {
my $C = shift;
$C->blast
});
}
else {
();
}
}
);
}

##     token statement_prefix__S_082END (:$*sym = 'END')
##          token statement_prefix:END     { <sym> <blast> }

sub statement_prefix__S_082END__PEEK { $_[0]->_AUTOLEXpeek('statement_prefix__S_082END',$retree) }
sub statement_prefix__S_082END {
no warnings 'recursion';
my $self = shift;
local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;
my %args = @_;
local $::sym = $args{sym} // 'END';


my $C = $self->cursor_xact("RULE statement_prefix__S_082END");
my $xact = $C->xact;
my $S = $C->{'_pos'};
$C->{'sym'} = ref $sym ? join(' ', @$sym) : $sym;

$self->_MATCHIFYr($S, "statement_prefix__S_082END", 
do {
if (my ($C) = ($C->_PATTERN(qr/\GEND/))) {
$C->_SUBSUMEr(['blast'], sub {
my $C = shift;
$C->blast
});
}
else {
();
}
}
);
}
##     token statement_prefix__S_083LEAVE (:$*sym = 'LEAVE')
##          token statement_prefix:LEAVE   { <sym> <blast> }

sub statement_prefix__S_083LEAVE__PEEK { $_[0]->_AUTOLEXpeek('statement_prefix__S_083LEAVE',$retree) }
sub statement_prefix__S_083LEAVE {
no warnings 'recursion';
my $self = shift;
local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;
my %args = @_;
local $::sym = $args{sym} // 'LEAVE';


my $C = $self->cursor_xact("RULE statement_prefix__S_083LEAVE");
my $xact = $C->xact;
my $S = $C->{'_pos'};
$C->{'sym'} = ref $sym ? join(' ', @$sym) : $sym;

$self->_MATCHIFYr($S, "statement_prefix__S_083LEAVE", 
do {
if (my ($C) = ($C->_PATTERN(qr/\GLEAVE/))) {
$C->_SUBSUMEr(['blast'], sub {
my $C = shift;
$C->blast
});
}
else {
();
}
}
);
}
##     token statement_prefix__S_084KEEP (:$*sym = 'KEEP')
##          token statement_prefix:KEEP    { <sym> <blast> }

sub statement_prefix__S_084KEEP__PEEK { $_[0]->_AUTOLEXpeek('statement_prefix__S_084KEEP',$retree) }
sub statement_prefix__S_084KEEP {
no warnings 'recursion';
my $self = shift;
local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;
my %args = @_;
local $::sym = $args{sym} // 'KEEP';


my $C = $self->cursor_xact("RULE statement_prefix__S_084KEEP");
my $xact = $C->xact;
my $S = $C->{'_pos'};
$C->{'sym'} = ref $sym ? join(' ', @$sym) : $sym;

$self->_MATCHIFYr($S, "statement_prefix__S_084KEEP", 
do {
if (my ($C) = ($C->_PATTERN(qr/\GKEEP/))) {
$C->_SUBSUMEr(['blast'], sub {
my $C = shift;
$C->blast
});
}
else {
();
}
}
);
}
##     token statement_prefix__S_085UNDO (:$*sym = 'UNDO')
##          token statement_prefix:UNDO    { <sym> <blast> }

sub statement_prefix__S_085UNDO__PEEK { $_[0]->_AUTOLEXpeek('statement_prefix__S_085UNDO',$retree) }
sub statement_prefix__S_085UNDO {
no warnings 'recursion';
my $self = shift;
local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;
my %args = @_;
local $::sym = $args{sym} // 'UNDO';


my $C = $self->cursor_xact("RULE statement_prefix__S_085UNDO");
my $xact = $C->xact;
my $S = $C->{'_pos'};
$C->{'sym'} = ref $sym ? join(' ', @$sym) : $sym;

$self->_MATCHIFYr($S, "statement_prefix__S_085UNDO", 
do {
if (my ($C) = ($C->_PATTERN(qr/\GUNDO/))) {
$C->_SUBSUMEr(['blast'], sub {
my $C = shift;
$C->blast
});
}
else {
();
}
}
);
}
##     token statement_prefix__S_086NEXT (:$*sym = 'NEXT')
##          token statement_prefix:NEXT    { <sym> <blast> }

sub statement_prefix__S_086NEXT__PEEK { $_[0]->_AUTOLEXpeek('statement_prefix__S_086NEXT',$retree) }
sub statement_prefix__S_086NEXT {
no warnings 'recursion';
my $self = shift;
local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;
my %args = @_;
local $::sym = $args{sym} // 'NEXT';


my $C = $self->cursor_xact("RULE statement_prefix__S_086NEXT");
my $xact = $C->xact;
my $S = $C->{'_pos'};
$C->{'sym'} = ref $sym ? join(' ', @$sym) : $sym;

$self->_MATCHIFYr($S, "statement_prefix__S_086NEXT", 
do {
if (my ($C) = ($C->_PATTERN(qr/\GNEXT/))) {
$C->_SUBSUMEr(['blast'], sub {
my $C = shift;
$C->blast
});
}
else {
();
}
}
);
}
##     token statement_prefix__S_087LAST (:$*sym = 'LAST')
##          token statement_prefix:LAST    { <sym> <blast> }

sub statement_prefix__S_087LAST__PEEK { $_[0]->_AUTOLEXpeek('statement_prefix__S_087LAST',$retree) }
sub statement_prefix__S_087LAST {
no warnings 'recursion';
my $self = shift;
local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;
my %args = @_;
local $::sym = $args{sym} // 'LAST';


my $C = $self->cursor_xact("RULE statement_prefix__S_087LAST");
my $xact = $C->xact;
my $S = $C->{'_pos'};
$C->{'sym'} = ref $sym ? join(' ', @$sym) : $sym;

$self->_MATCHIFYr($S, "statement_prefix__S_087LAST", 
do {
if (my ($C) = ($C->_PATTERN(qr/\GLAST/))) {
$C->_SUBSUMEr(['blast'], sub {
my $C = shift;
$C->blast
});
}
else {
();
}
}
);
}
##     token statement_prefix__S_088PRE (:$*sym = 'PRE')
##          token statement_prefix:PRE     { <sym> <blast> }

sub statement_prefix__S_088PRE__PEEK { $_[0]->_AUTOLEXpeek('statement_prefix__S_088PRE',$retree) }
sub statement_prefix__S_088PRE {
no warnings 'recursion';
my $self = shift;
local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;
my %args = @_;
local $::sym = $args{sym} // 'PRE';


my $C = $self->cursor_xact("RULE statement_prefix__S_088PRE");
my $xact = $C->xact;
my $S = $C->{'_pos'};
$C->{'sym'} = ref $sym ? join(' ', @$sym) : $sym;

$self->_MATCHIFYr($S, "statement_prefix__S_088PRE", 
do {
if (my ($C) = ($C->_PATTERN(qr/\GPRE/))) {
$C->_SUBSUMEr(['blast'], sub {
my $C = shift;
$C->blast
});
}
else {
();
}
}
);
}
##     token statement_prefix__S_089POST (:$*sym = 'POST')
##          token statement_prefix:POST    { <sym> <blast> }

sub statement_prefix__S_089POST__PEEK { $_[0]->_AUTOLEXpeek('statement_prefix__S_089POST',$retree) }
sub statement_prefix__S_089POST {
no warnings 'recursion';
my $self = shift;
local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;
my %args = @_;
local $::sym = $args{sym} // 'POST';


my $C = $self->cursor_xact("RULE statement_prefix__S_089POST");
my $xact = $C->xact;
my $S = $C->{'_pos'};
$C->{'sym'} = ref $sym ? join(' ', @$sym) : $sym;

$self->_MATCHIFYr($S, "statement_prefix__S_089POST", 
do {
if (my ($C) = ($C->_PATTERN(qr/\GPOST/))) {
$C->_SUBSUMEr(['blast'], sub {
my $C = shift;
$C->blast
});
}
else {
();
}
}
);
}

##     rule statement_control__S_090CATCH (:$*endsym = 'spacey', :$*sym = 'CATCH')
##          rule statement_control:CATCH   {<sym> <block> }

sub statement_control__S_090CATCH__PEEK { $_[0]->_AUTOLEXpeek('statement_control__S_090CATCH',$retree) }
sub statement_control__S_090CATCH {
no warnings 'recursion';
my $self = shift;
local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;
my %args = @_;
local $::endsym = $args{endsym} // 'spacey';
local $::sym = $args{sym} // 'CATCH';


my $C = $self->cursor_xact("RULE statement_control__S_090CATCH");
my $xact = $C->xact;
my $S = $C->{'_pos'};
$C->{'sym'} = ref $sym ? join(' ', @$sym) : $sym;

$self->_MATCHIFYr($S, "statement_control__S_090CATCH", 
do {
if (my ($C) = ($C->_PATTERN(qr/\GCATCH/))) {
do {
if (my ($C) = ($C->spacey)) {
do {
if (my ($C) = ($C->ws)) {
do {
if (my ($C) = ($C->_SUBSUMEr(['block'], sub {
my $C = shift;
$C->block
}))) {
$C->ws;
}
else {
();
}
};
}
else {
();
}
};
}
else {
();
}
};
}
else {
();
}
}
);
}
##     rule statement_control__S_091CONTROL (:$*endsym = 'spacey', :$*sym = 'CONTROL')
##          rule statement_control:CONTROL {<sym> <block> }

sub statement_control__S_091CONTROL__PEEK { $_[0]->_AUTOLEXpeek('statement_control__S_091CONTROL',$retree) }
sub statement_control__S_091CONTROL {
no warnings 'recursion';
my $self = shift;
local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;
my %args = @_;
local $::endsym = $args{endsym} // 'spacey';
local $::sym = $args{sym} // 'CONTROL';


my $C = $self->cursor_xact("RULE statement_control__S_091CONTROL");
my $xact = $C->xact;
my $S = $C->{'_pos'};
$C->{'sym'} = ref $sym ? join(' ', @$sym) : $sym;

$self->_MATCHIFYr($S, "statement_control__S_091CONTROL", 
do {
if (my ($C) = ($C->_PATTERN(qr/\GCONTROL/))) {
do {
if (my ($C) = ($C->spacey)) {
do {
if (my ($C) = ($C->ws)) {
do {
if (my ($C) = ($C->_SUBSUMEr(['block'], sub {
my $C = shift;
$C->block
}))) {
$C->ws;
}
else {
();
}
};
}
else {
();
}
};
}
else {
();
}
};
}
else {
();
}
}
);
}
##     rule statement_control__S_092TEMP (:$*endsym = 'spacey', :$*sym = 'TEMP')
##          rule statement_control:TEMP    {<sym> <block> }

sub statement_control__S_092TEMP__PEEK { $_[0]->_AUTOLEXpeek('statement_control__S_092TEMP',$retree) }
sub statement_control__S_092TEMP {
no warnings 'recursion';
my $self = shift;
local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;
my %args = @_;
local $::endsym = $args{endsym} // 'spacey';
local $::sym = $args{sym} // 'TEMP';


my $C = $self->cursor_xact("RULE statement_control__S_092TEMP");
my $xact = $C->xact;
my $S = $C->{'_pos'};
$C->{'sym'} = ref $sym ? join(' ', @$sym) : $sym;

$self->_MATCHIFYr($S, "statement_control__S_092TEMP", 
do {
if (my ($C) = ($C->_PATTERN(qr/\GTEMP/))) {
do {
if (my ($C) = ($C->spacey)) {
do {
if (my ($C) = ($C->ws)) {
do {
if (my ($C) = ($C->_SUBSUMEr(['block'], sub {
my $C = shift;
$C->block
}))) {
$C->ws;
}
else {
();
}
};
}
else {
();
}
};
}
else {
();
}
};
}
else {
();
}
}
);
}

#######################
# statement modifiers #
#######################

##     rule modifier_expr
##          rule modifier_expr { <EXPR> }

sub modifier_expr__PEEK { $_[0]->_AUTOLEXpeek('modifier_expr',$retree) }
sub modifier_expr {
no warnings 'recursion';
my $self = shift;
local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;


my $C = $self->cursor_xact("RULE modifier_expr");
my $xact = $C->xact;
my $S = $C->{'_pos'};

$self->_MATCHIFYr($S, "modifier_expr", 
do {
if (my ($C) = ($C->ws)) {
do {
if (my ($C) = ($C->_SUBSUMEr(['EXPR'], sub {
my $C = shift;
$C->EXPR
}))) {
$C->ws;
}
else {
();
}
};
}
else {
();
}
}
);
}

##     rule statement_mod_cond__S_093if (:$*endsym = 'nofun', :$*sym = 'if')
##          rule statement_mod_cond:if     {<sym> <modifier_expr> }

sub statement_mod_cond__S_093if__PEEK { $_[0]->_AUTOLEXpeek('statement_mod_cond__S_093if',$retree) }
sub statement_mod_cond__S_093if {
no warnings 'recursion';
my $self = shift;
local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;
my %args = @_;
local $::endsym = $args{endsym} // 'nofun';
local $::sym = $args{sym} // 'if';


my $C = $self->cursor_xact("RULE statement_mod_cond__S_093if");
my $xact = $C->xact;
my $S = $C->{'_pos'};
$C->{'sym'} = ref $sym ? join(' ', @$sym) : $sym;

$self->_MATCHIFYr($S, "statement_mod_cond__S_093if", 
do {
if (my ($C) = ($C->_PATTERN(qr/\Gif/))) {
do {
if (my ($C) = ($C->nofun)) {
do {
if (my ($C) = ($C->ws)) {
do {
if (my ($C) = ($C->_SUBSUMEr(['modifier_expr'], sub {
my $C = shift;
$C->modifier_expr
}))) {
$C->ws;
}
else {
();
}
};
}
else {
();
}
};
}
else {
();
}
};
}
else {
();
}
}
);
}
##     rule statement_mod_cond__S_094unless (:$*endsym = 'nofun', :$*sym = 'unless')
##          rule statement_mod_cond:unless {<sym> <modifier_expr> }

sub statement_mod_cond__S_094unless__PEEK { $_[0]->_AUTOLEXpeek('statement_mod_cond__S_094unless',$retree) }
sub statement_mod_cond__S_094unless {
no warnings 'recursion';
my $self = shift;
local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;
my %args = @_;
local $::endsym = $args{endsym} // 'nofun';
local $::sym = $args{sym} // 'unless';


my $C = $self->cursor_xact("RULE statement_mod_cond__S_094unless");
my $xact = $C->xact;
my $S = $C->{'_pos'};
$C->{'sym'} = ref $sym ? join(' ', @$sym) : $sym;

$self->_MATCHIFYr($S, "statement_mod_cond__S_094unless", 
do {
if (my ($C) = ($C->_PATTERN(qr/\Gunless/))) {
do {
if (my ($C) = ($C->nofun)) {
do {
if (my ($C) = ($C->ws)) {
do {
if (my ($C) = ($C->_SUBSUMEr(['modifier_expr'], sub {
my $C = shift;
$C->modifier_expr
}))) {
$C->ws;
}
else {
();
}
};
}
else {
();
}
};
}
else {
();
}
};
}
else {
();
}
}
);
}
##     rule statement_mod_cond__S_095when (:$*endsym = 'nofun', :$*sym = 'when')
##          rule statement_mod_cond:when   {<sym> <modifier_expr> }

sub statement_mod_cond__S_095when__PEEK { $_[0]->_AUTOLEXpeek('statement_mod_cond__S_095when',$retree) }
sub statement_mod_cond__S_095when {
no warnings 'recursion';
my $self = shift;
local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;
my %args = @_;
local $::endsym = $args{endsym} // 'nofun';
local $::sym = $args{sym} // 'when';


my $C = $self->cursor_xact("RULE statement_mod_cond__S_095when");
my $xact = $C->xact;
my $S = $C->{'_pos'};
$C->{'sym'} = ref $sym ? join(' ', @$sym) : $sym;

$self->_MATCHIFYr($S, "statement_mod_cond__S_095when", 
do {
if (my ($C) = ($C->_PATTERN(qr/\Gwhen/))) {
do {
if (my ($C) = ($C->nofun)) {
do {
if (my ($C) = ($C->ws)) {
do {
if (my ($C) = ($C->_SUBSUMEr(['modifier_expr'], sub {
my $C = shift;
$C->modifier_expr
}))) {
$C->ws;
}
else {
();
}
};
}
else {
();
}
};
}
else {
();
}
};
}
else {
();
}
}
);
}

##     rule statement_mod_loop__S_096while (:$*endsym = 'nofun', :$*sym = 'while')
##          rule statement_mod_loop:while {<sym> <modifier_expr> }

sub statement_mod_loop__S_096while__PEEK { $_[0]->_AUTOLEXpeek('statement_mod_loop__S_096while',$retree) }
sub statement_mod_loop__S_096while {
no warnings 'recursion';
my $self = shift;
local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;
my %args = @_;
local $::endsym = $args{endsym} // 'nofun';
local $::sym = $args{sym} // 'while';


my $C = $self->cursor_xact("RULE statement_mod_loop__S_096while");
my $xact = $C->xact;
my $S = $C->{'_pos'};
$C->{'sym'} = ref $sym ? join(' ', @$sym) : $sym;

$self->_MATCHIFYr($S, "statement_mod_loop__S_096while", 
do {
if (my ($C) = ($C->_PATTERN(qr/\Gwhile/))) {
do {
if (my ($C) = ($C->nofun)) {
do {
if (my ($C) = ($C->ws)) {
do {
if (my ($C) = ($C->_SUBSUMEr(['modifier_expr'], sub {
my $C = shift;
$C->modifier_expr
}))) {
$C->ws;
}
else {
();
}
};
}
else {
();
}
};
}
else {
();
}
};
}
else {
();
}
}
);
}
##     rule statement_mod_loop__S_097until (:$*endsym = 'nofun', :$*sym = 'until')
##          rule statement_mod_loop:until {<sym> <modifier_expr> }

sub statement_mod_loop__S_097until__PEEK { $_[0]->_AUTOLEXpeek('statement_mod_loop__S_097until',$retree) }
sub statement_mod_loop__S_097until {
no warnings 'recursion';
my $self = shift;
local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;
my %args = @_;
local $::endsym = $args{endsym} // 'nofun';
local $::sym = $args{sym} // 'until';


my $C = $self->cursor_xact("RULE statement_mod_loop__S_097until");
my $xact = $C->xact;
my $S = $C->{'_pos'};
$C->{'sym'} = ref $sym ? join(' ', @$sym) : $sym;

$self->_MATCHIFYr($S, "statement_mod_loop__S_097until", 
do {
if (my ($C) = ($C->_PATTERN(qr/\Guntil/))) {
do {
if (my ($C) = ($C->nofun)) {
do {
if (my ($C) = ($C->ws)) {
do {
if (my ($C) = ($C->_SUBSUMEr(['modifier_expr'], sub {
my $C = shift;
$C->modifier_expr
}))) {
$C->ws;
}
else {
();
}
};
}
else {
();
}
};
}
else {
();
}
};
}
else {
();
}
}
);
}

##     rule statement_mod_loop__S_098for (:$*endsym = 'nofun', :$*sym = 'for')
##          rule statement_mod_loop:for   {<sym> <modifier_expr> }

sub statement_mod_loop__S_098for__PEEK { $_[0]->_AUTOLEXpeek('statement_mod_loop__S_098for',$retree) }
sub statement_mod_loop__S_098for {
no warnings 'recursion';
my $self = shift;
local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;
my %args = @_;
local $::endsym = $args{endsym} // 'nofun';
local $::sym = $args{sym} // 'for';


my $C = $self->cursor_xact("RULE statement_mod_loop__S_098for");
my $xact = $C->xact;
my $S = $C->{'_pos'};
$C->{'sym'} = ref $sym ? join(' ', @$sym) : $sym;

$self->_MATCHIFYr($S, "statement_mod_loop__S_098for", 
do {
if (my ($C) = ($C->_PATTERN(qr/\Gfor/))) {
do {
if (my ($C) = ($C->nofun)) {
do {
if (my ($C) = ($C->ws)) {
do {
if (my ($C) = ($C->_SUBSUMEr(['modifier_expr'], sub {
my $C = shift;
$C->modifier_expr
}))) {
$C->ws;
}
else {
();
}
};
}
else {
();
}
};
}
else {
();
}
};
}
else {
();
}
}
);
}
##     rule statement_mod_loop__S_099given (:$*endsym = 'nofun', :$*sym = 'given')
##          rule statement_mod_loop:given {<sym> <modifier_expr> }

sub statement_mod_loop__S_099given__PEEK { $_[0]->_AUTOLEXpeek('statement_mod_loop__S_099given',$retree) }
sub statement_mod_loop__S_099given {
no warnings 'recursion';
my $self = shift;
local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;
my %args = @_;
local $::endsym = $args{endsym} // 'nofun';
local $::sym = $args{sym} // 'given';


my $C = $self->cursor_xact("RULE statement_mod_loop__S_099given");
my $xact = $C->xact;
my $S = $C->{'_pos'};
$C->{'sym'} = ref $sym ? join(' ', @$sym) : $sym;

$self->_MATCHIFYr($S, "statement_mod_loop__S_099given", 
do {
if (my ($C) = ($C->_PATTERN(qr/\Ggiven/))) {
do {
if (my ($C) = ($C->nofun)) {
do {
if (my ($C) = ($C->ws)) {
do {
if (my ($C) = ($C->_SUBSUMEr(['modifier_expr'], sub {
my $C = shift;
$C->modifier_expr
}))) {
$C->ws;
}
else {
();
}
};
}
else {
();
}
};
}
else {
();
}
};
}
else {
();
}
}
);
}

################
# module names #
################

##     token def_module_name
##          token def_module_name {
##              <longname>
##              [ :dba('generic role')
##                  <?before '['>
##                  <?{ ($*PKGDECL//'') eq 'role' }>
##                  <.newpad>
##                  '[' ~ ']' <signature>
##                  { $*IN_DECL = ''; }
##                  <.finishpad>
##              ]?
##          }

sub def_module_name__PEEK { $_[0]->_AUTOLEXpeek('def_module_name',$retree) }
sub def_module_name {
no warnings 'recursion';
my $self = shift;
local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;


my $C = $self->cursor_xact("RULE def_module_name");
my $xact = $C->xact;
my $S = $C->{'_pos'};
$C->{'signature'} = [];

$self->_MATCHIFYr($S, "def_module_name", 
do {
if (my ($C) = ($C->_SUBSUMEr(['longname'], sub {
my $C = shift;
$C->longname
}))) {
$C->_OPTr(sub { my $C=shift;
$C->_BRACKETr(sub {
my $C=shift;
do {
if (my ($C) = ($C->before(sub { my $C=shift;
$C->_EXACT('[')
}))) {
do {
if (my ($C) = ($C->before( sub { my $C=shift;
(($C) x !!do {
($::PKGDECL//'') eq 'role' 
})
}))) {
do {
if (my ($C) = ($C->newpad)) {
do {
if (my ($C) = ($C->_EXACT('['))) {
do {
if (my ($C) = (((local $::GOAL = ']' ), $C)[-1])) {
do {
if (my ($C) = ($C->_SUBSUMEr(['signature'], sub {
my $C = shift;
$C->signature
}))) {
do {
if (my ($C) = ($C->_BRACKETr(sub {
my $C=shift;
do {
my $C = $C->cursor_xact('ALT ||');
my $xact = $C->xact;
my @gather;
do {
push @gather, $C->_EXACT(']')
}
or $xact->[-2] or
do {
push @gather, $C->FAILGOAL(']' , 'generic role')};
@gather;
}
}))) {
do {
if (my ($C) = (scalar(do {
$::IN_DECL = ''; 
}, $C))) {
$C->finishpad;
}
else {
();
}
};
}
else {
();
}
};
}
else {
();
}
};
}
else {
();
}
};
}
else {
();
}
};
}
else {
();
}
};
}
else {
();
}
};
}
else {
();
}
}
})
});
}
else {
();
}
}
);
}

##     token module_name__S_100normal (:$*sym = 'normal')
##          token module_name:normal {
##              <longname>
##              [ <?before '['> :dba('generic role') '[' ~ ']' <arglist> ]?
##          }

sub module_name__S_100normal__PEEK { $_[0]->_AUTOLEXpeek('module_name__S_100normal',$retree) }
sub module_name__S_100normal {
no warnings 'recursion';
my $self = shift;
local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;
my %args = @_;
local $::sym = $args{sym} // 'normal';


my $C = $self->cursor_xact("RULE module_name__S_100normal");
my $xact = $C->xact;
my $S = $C->{'_pos'};
$C->{'arglist'} = [];
$C->{'sym'} = ref $sym ? join(' ', @$sym) : $sym;

$self->_MATCHIFYr($S, "module_name__S_100normal", 
do {
if (my ($C) = ($C->_SUBSUMEr(['longname'], sub {
my $C = shift;
$C->longname
}))) {
$C->_OPTr(sub { my $C=shift;
$C->_BRACKETr(sub {
my $C=shift;
do {
if (my ($C) = ($C->before(sub { my $C=shift;
$C->_EXACT('[')
}))) {
do {
if (my ($C) = ($C->_EXACT('['))) {
do {
if (my ($C) = (((local $::GOAL = ']' ), $C)[-1])) {
do {
if (my ($C) = ($C->_SUBSUMEr(['arglist'], sub {
my $C = shift;
$C->arglist
}))) {
$C->_BRACKETr(sub {
my $C=shift;
do {
my $C = $C->cursor_xact('ALT ||');
my $xact = $C->xact;
my @gather;
do {
push @gather, $C->_EXACT(']')
}
or $xact->[-2] or
do {
push @gather, $C->FAILGOAL(']' , 'generic role')};
@gather;
}
});
}
else {
();
}
};
}
else {
();
}
};
}
else {
();
}
};
}
else {
();
}
}
})
});
}
else {
();
}
}
);
}

##     token module_name__S_101deprecated (:$*sym = 'deprecated')
##          token module_name:deprecated { 'v6-alpha' }

sub module_name__S_101deprecated__PEEK { $_[0]->_AUTOLEXpeek('module_name__S_101deprecated',$retree) }
sub module_name__S_101deprecated {
no warnings 'recursion';
my $self = shift;
local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;
my %args = @_;
local $::sym = $args{sym} // 'deprecated';


my $C = $self->cursor_xact("RULE module_name__S_101deprecated");
my $xact = $C->xact;
my $S = $C->{'_pos'};
$C->{'sym'} = ref $sym ? join(' ', @$sym) : $sym;

$self->_MATCHIFYr($S, "module_name__S_101deprecated", 
$C->_EXACT('v6-alpha')
);
}

##     token vnum
##          token vnum {
##              \d+ | '*'
##          }

sub vnum__PEEK { $_[0]->_AUTOLEXpeek('vnum',$retree) }
sub vnum {
no warnings 'recursion';
my $self = shift;
local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;


my $C = $self->cursor_xact("RULE vnum");
my $xact = $C->xact;
my $S = $C->{'_pos'};

$self->_MATCHIFYr($S, "vnum", 
do {
my @result = do {
my $trystate;
my ($tag, $try);
my @try;
my $relex;

my $fate;
my $x;
if ($fate = $C->{'_fate'} and $fate->[1] eq 'vnum_00') {
$C->deb("Fate passed to vnum_00: ", ::fatestr($fate)) if $::DEBUG & DEBUG::fates;
($C->{'_fate'}, $tag, $try) = @$fate;
@try = ($try);
$x = 'ALT vnum_00';    # some outer ltm is controlling us
}
else {
$x = 'ALTLTM vnum_00'; # we are top level ltm
}
my $C = $C->cursor_xact($x);
my $xact = $C->xact;

my @gather = ();
for (;;) {
if (not @try) {
$relex //= $C->cursor_fate('STD::P6', 'vnum_00', $retree);
@try = $relex->($C, $trystate);
}
last unless @try;
$try = shift(@try) // next;

if (ref $try eq 'ARRAY') {
($C->{'_fate'}, $tag, $try) = @$try;	# next candidate fate
}

$C->deb("vnum_00 trying $tag $try") if $::DEBUG & DEBUG::try_processing;
push @gather, ((
sub { my $C=shift;
$C->_PATTERN(qr/\G((?:\d)++)/)
},
sub { my $C=shift;
$C->_EXACT('*')
},
)[$try])->($C);
last if $xact->[-2];  # committed?
last if @gather;
}
@gather;
};
@result;
}

);
}

##     token version__S_102v (:$*sym = <v>)
##          token version:sym<v> {
##              'v' <?before \d+> :: <vnum> ** '.' '+'?
##          }

sub version__S_102v__PEEK { $_[0]->_AUTOLEXpeek('version__S_102v',$retree) }
sub version__S_102v {
no warnings 'recursion';
my $self = shift;
local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;
my %args = @_;
local $::sym = $args{sym} // q(v);


my $C = $self->cursor_xact("RULE version__S_102v");
my $xact = $C->xact;
my $S = $C->{'_pos'};
$C->{'vnum'} = [];
$C->{'sym'} = ref $sym ? join(' ', @$sym) : $sym;

$self->_MATCHIFYr($S, "version__S_102v", 
do {
if (my ($C) = ($C->_EXACT('v'))) {
do {
if (my ($C) = ($C->before(sub { my $C=shift;
$C->_PATTERN(qr/\G((?:\d)++)/)
}))) {
do {
if (my ($C) = ($C->_COMMITLTM())) {
do {
if (my ($C) = ($C->_REPSEPr(  sub { my $C=shift;
$C->_EXACT('.')
}, sub { my $C=shift;
$C->_SUBSUMEr(['vnum'], sub {
my $C = shift;
$C->vnum
})
}))) {
$C->_OPTr(sub { my $C=shift;
$C->_EXACT('+')
});
}
else {
();
}
};
}
else {
();
}
};
}
else {
();
}
};
}
else {
();
}
}
);
}

###############
# Declarators #
###############

##     token variable_declarator
##          token variable_declarator {
##              :my $*IN_DECL = 'variable';
##              :my $*DECLARAND;
##              :my $var;
##              <variable>
##              {
##                  $var = $<variable>.Str;
##                  $.add_variable($var);
##                  $*IN_DECL = '';
##              }
##              [   # Is it a shaped array or hash declaration?
##                #  <?{ $<sigil> eq '@' | '%' }>
##                  <.unsp>?
##                  $<shape> = [
##                  | '(' ~ ')' <signature>
##                      {{
##                          given substr($var,0,1) {
##                              when '&' {
##                                  $.panic("The () shape syntax in routine declarations is reserved (maybe use :() to declare a longname?)");
##                              }
##                              when '@' {
##                                  $.panic("The () shape syntax in array declarations is reserved");
##                              }
##                              when '%' {
##                                  $.panic("The () shape syntax in hash declarations is reserved");
##                              }
##                              $.panic("The () shape syntax in variable declarations is reserved");
##                          }
##                      }}
##                  | :dba('shape definition') '[' ~ ']' <semilist>
##                  | :dba('shape definition') '{' ~ '}' <semilist> <.curlycheck>
##                  | <?before '<'> <postcircumfix>
##                  ]*
##              ]?
##              <.ws>
##      
##              <trait>*
##              <.getdecl>
##          }

sub variable_declarator__PEEK { $_[0]->_AUTOLEXpeek('variable_declarator',$retree) }
sub variable_declarator {
no warnings 'recursion';
my $self = shift;
local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;
local $::IN_DECL = 'variable';
local $::DECLARAND;
my $var;


my $C = $self->cursor_xact("RULE variable_declarator");
my $xact = $C->xact;
my $S = $C->{'_pos'};
$C->{'trait'} = [];
$C->{'signature'} = [];
$C->{'shape'} = [];
$C->{'postcircumfix'} = [];
$C->{'semilist'} = [];

$self->_MATCHIFYr($S, "variable_declarator", 
do {
if (my ($C) = ($C->_SUBSUMEr(['variable'], sub {
my $C = shift;
$C->variable
}))) {
do {
if (my ($C) = (scalar(do {
my $M = $C; 
$var = $M->{'variable'}->Str;
$C->add_variable($var);
$::IN_DECL = '';
;
}, $C))) {
do {
if (my ($C) = ($C->_OPTr(sub { my $C=shift;
$C->_BRACKETr(sub {
my $C=shift;
do {
if (my ($C) = ($C->_OPTr(sub { my $C=shift;
$C->unsp
}))) {
$C->_STARr(sub { my $C=shift;
$C->_SUBSUMEr(['shape'], sub {
my $C = shift;
$C->_BRACKETr(sub {
my $C=shift;
do {
my @result = do {
my $trystate;
my ($tag, $try);
my @try;
my $relex;

my $fate;
my $x;
if ($fate = $C->{'_fate'} and $fate->[1] eq 'variable_declarator_02') {
$C->deb("Fate passed to variable_declarator_02: ", ::fatestr($fate)) if $::DEBUG & DEBUG::fates;
($C->{'_fate'}, $tag, $try) = @$fate;
@try = ($try);
$x = 'ALT variable_declarator_02';    # some outer ltm is controlling us
}
else {
$x = 'ALTLTM variable_declarator_02'; # we are top level ltm
}
my $C = $C->cursor_xact($x);
my $xact = $C->xact;

my @gather = ();
for (;;) {
if (not @try) {
$relex //= $C->cursor_fate('STD::P6', 'variable_declarator_02', $retree);
@try = $relex->($C, $trystate);
}
last unless @try;
$try = shift(@try) // next;

if (ref $try eq 'ARRAY') {
($C->{'_fate'}, $tag, $try) = @$try;	# next candidate fate
}

$C->deb("variable_declarator_02 trying $tag $try") if $::DEBUG & DEBUG::try_processing;
push @gather, ((
sub { my $C=shift;
do {
if (my ($C) = ($C->_EXACT('('))) {
do {
if (my ($C) = (((local $::GOAL = ')' ), $C)[-1])) {
do {
if (my ($C) = ($C->_SUBSUMEr(['signature'], sub {
my $C = shift;
$C->signature
}))) {
do {
if (my ($C) = ($C->_BRACKETr(sub {
my $C=shift;
do {
my $C = $C->cursor_xact('ALT ||');
my $xact = $C->xact;
my @gather;
do {
push @gather, $C->_EXACT(')')
}
or $xact->[-2] or
do {
push @gather, $C->FAILGOAL(')' , 'variable_declarator')};
@gather;
}
}))) {
scalar(do {

given (substr($var,0,1)) {
when ('&') {
$C->panic("The () shape syntax in routine declarations is reserved (maybe use :() to declare a longname?)");
}
when ('@') {
$C->panic("The () shape syntax in array declarations is reserved");
}
when ('%') {
$C->panic("The () shape syntax in hash declarations is reserved");
}
$C->panic("The () shape syntax in variable declarations is reserved");
};

}, $C);
}
else {
();
}
};
}
else {
();
}
};
}
else {
();
}
};
}
else {
();
}
}
},
sub { my $C=shift;
do {
if (my ($C) = ($C->_EXACT('['))) {
do {
if (my ($C) = (((local $::GOAL = ']' ), $C)[-1])) {
do {
if (my ($C) = ($C->_SUBSUMEr(['semilist'], sub {
my $C = shift;
$C->semilist
}))) {
$C->_BRACKETr(sub {
my $C=shift;
do {
my $C = $C->cursor_xact('ALT ||');
my $xact = $C->xact;
my @gather;
do {
push @gather, $C->_EXACT(']')
}
or $xact->[-2] or
do {
push @gather, $C->FAILGOAL(']' , 'shape definition')};
@gather;
}
});
}
else {
();
}
};
}
else {
();
}
};
}
else {
();
}
}
},
sub { my $C=shift;
do {
if (my ($C) = ($C->_EXACT('{'))) {
do {
if (my ($C) = (((local $::GOAL = '}' ), $C)[-1])) {
do {
if (my ($C) = ($C->_SUBSUMEr(['semilist'], sub {
my $C = shift;
$C->semilist
}))) {
do {
if (my ($C) = ($C->_BRACKETr(sub {
my $C=shift;
do {
my $C = $C->cursor_xact('ALT ||');
my $xact = $C->xact;
my @gather;
do {
push @gather, $C->_EXACT('}')
}
or $xact->[-2] or
do {
push @gather, $C->FAILGOAL('}' , 'shape definition')};
@gather;
}
}))) {
$C->curlycheck;
}
else {
();
}
};
}
else {
();
}
};
}
else {
();
}
};
}
else {
();
}
}
},
sub { my $C=shift;
do {
if (my ($C) = ($C->before(sub { my $C=shift;
$C->_EXACT('<')
}))) {
$C->_SUBSUMEr(['postcircumfix'], sub {
my $C = shift;
$C->postcircumfix
});
}
else {
();
}
}
},
)[$try])->($C);
last if $xact->[-2];  # committed?
last if @gather;
}
@gather;
};
@result;
}

})
})
});
}
else {
();
}
}
})
}))) {
do {
if (my ($C) = ($C->ws)) {
do {
if (my ($C) = ($C->_STARr(sub { my $C=shift;
$C->_SUBSUMEr(['trait'], sub {
my $C = shift;
$C->trait
})
}))) {
$C->getdecl;
}
else {
();
}
};
}
else {
();
}
};
}
else {
();
}
};
}
else {
();
}
};
}
else {
();
}
}
);
}

##     rule scoped ($*SCOPE)
##          rule scoped ($*SCOPE) {
##              :dba('scoped declarator')
##              [
##              | <declarator>
##              | <regex_declarator>
##              | <package_declarator>
##              | [<typename> ]+
##                  {
##                      my $t = $<typename>;
##                      @$t > 1 and $.panic("Multiple prefix constraints not yet supported");
##                      $*OFTYPE = $t[0];
##                  }
##                  <multi_declarator>
##              | <multi_declarator>
##              ]
##              || <?before <[A..Z]>><longname>{{
##                      my $t = $<longname>.Str;
##                      if not $.is_known($t) {
##                          $.panic("In $*SCOPE declaration, typename '$t' must be predeclared (or marked as declarative with :: prefix)");
##                      }
##                  }}
##                  <!> # drop through
##              || <.panic: "Malformed $*SCOPE">
##          }

sub scoped__PEEK { $_[0]->_AUTOLEXpeek('scoped',$retree) }
sub scoped {
no warnings 'recursion';
my $self = shift;
local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;
local $::SCOPE = shift;


my $C = $self->cursor_xact("RULE scoped");
my $xact = $C->xact;
my $S = $C->{'_pos'};
$C->{'typename'} = [];

$self->_MATCHIFYr($S, "scoped", 
do {
my $C = $C->cursor_xact('ALT ||');
my $xact = $C->xact;
my @gather;
do {
push @gather, do {
if (my ($C) = ($C->ws)) {
do {
if (my ($C) = ($C->ws)) {
do {
if (my ($C) = ($C->_BRACKETr(sub {
my $C=shift;
do {
my @result = do {
my $trystate;
my ($tag, $try);
my @try;
my $relex;

my $fate;
my $x;
if ($fate = $C->{'_fate'} and $fate->[1] eq 'scoped_01') {
$C->deb("Fate passed to scoped_01: ", ::fatestr($fate)) if $::DEBUG & DEBUG::fates;
($C->{'_fate'}, $tag, $try) = @$fate;
@try = ($try);
$x = 'ALT scoped_01';    # some outer ltm is controlling us
}
else {
$x = 'ALTLTM scoped_01'; # we are top level ltm
}
my $C = $C->cursor_xact($x);
my $xact = $C->xact;

my @gather = ();
for (;;) {
if (not @try) {
$relex //= $C->cursor_fate('STD::P6', 'scoped_01', $retree);
@try = $relex->($C, $trystate);
}
last unless @try;
$try = shift(@try) // next;

if (ref $try eq 'ARRAY') {
($C->{'_fate'}, $tag, $try) = @$try;	# next candidate fate
}

$C->deb("scoped_01 trying $tag $try") if $::DEBUG & DEBUG::try_processing;
push @gather, ((
sub { my $C=shift;
do {
if (my ($C) = ($C->_SUBSUMEr(['declarator'], sub {
my $C = shift;
$C->declarator
}))) {
$C->ws;
}
else {
();
}
}
},
sub { my $C=shift;
do {
if (my ($C) = ($C->_SUBSUMEr(['regex_declarator'], sub {
my $C = shift;
$C->regex_declarator
}))) {
$C->ws;
}
else {
();
}
}
},
sub { my $C=shift;
do {
if (my ($C) = ($C->_SUBSUMEr(['package_declarator'], sub {
my $C = shift;
$C->package_declarator
}))) {
$C->ws;
}
else {
();
}
}
},
sub { my $C=shift;
do {
if (my ($C) = ($C->_PLUSr(sub { my $C=shift;
$C->_BRACKETr(sub {
my $C=shift;
do {
if (my ($C) = ($C->_SUBSUMEr(['typename'], sub {
my $C = shift;
$C->typename
}))) {
$C->ws;
}
else {
();
}
}
})
}))) {
do {
if (my ($C) = ($C->ws)) {
do {
if (my ($C) = (scalar(do {
my $M = $C; 
my $t = $M->{'typename'};
@$t > 1 and $C->panic("Multiple prefix constraints not yet supported");
$::OFTYPE = $t->[0];
;
}, $C))) {
do {
if (my ($C) = ($C->ws)) {
do {
if (my ($C) = ($C->_SUBSUMEr(['multi_declarator'], sub {
my $C = shift;
$C->multi_declarator
}))) {
$C->ws;
}
else {
();
}
};
}
else {
();
}
};
}
else {
();
}
};
}
else {
();
}
};
}
else {
();
}
}
},
sub { my $C=shift;
do {
if (my ($C) = ($C->_SUBSUMEr(['multi_declarator'], sub {
my $C = shift;
$C->multi_declarator
}))) {
$C->ws;
}
else {
();
}
}
},
)[$try])->($C);
last if $xact->[-2];  # committed?
last if @gather;
}
@gather;
};
@result;
}

}))) {
$C->ws;
}
else {
();
}
};
}
else {
();
}
};
}
else {
();
}
}
}
or $xact->[-2] or
do {
push @gather, do {
if (my ($C) = ($C->ws)) {
do {
if (my ($C) = ($C->before(sub { my $C=shift;
$C->_PATTERN(qr/\G[A-Z]/)
}))) {
do {
if (my ($C) = ($C->_SUBSUMEr(['longname'], sub {
my $C = shift;
$C->longname
}))) {
do {
if (my ($C) = (scalar(do {
my $M = $C; 
my $t = $M->{'longname'}->Str;
if (not $C->is_known($t)) {
$C->panic("In $::SCOPE declaration, typename '$t' must be predeclared (or marked as declarative with :: prefix)");
}
;
}, $C))) {
do {
if (my ($C) = ($C->ws)) {
do {
if (my ($C) = ($C->_NOTBEFORE( sub { my $C=shift;
$C
}))) {
$C->ws;
}
else {
();
}
};
}
else {
();
}
};
}
else {
();
}
};
}
else {
();
}
};
}
else {
();
}
};
}
else {
();
}
}
}
or $xact->[-2] or
do {
push @gather, do {
if (my ($C) = ($C->ws)) {
do {
if (my ($C) = ($C->panic("Malformed $::SCOPE"))) {
$C->ws;
}
else {
();
}
};
}
else {
();
}
}};
@gather;
}
);
}

##     token scope_declarator__S_103my (:$*endsym = 'nofun', :$*sym = 'my')
##          token scope_declarator:my        { <sym> <scoped('my')> }

sub scope_declarator__S_103my__PEEK { $_[0]->_AUTOLEXpeek('scope_declarator__S_103my',$retree) }
sub scope_declarator__S_103my {
no warnings 'recursion';
my $self = shift;
local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;
my %args = @_;
local $::endsym = $args{endsym} // 'nofun';
local $::sym = $args{sym} // 'my';


my $C = $self->cursor_xact("RULE scope_declarator__S_103my");
my $xact = $C->xact;
my $S = $C->{'_pos'};
$C->{'sym'} = ref $sym ? join(' ', @$sym) : $sym;

$self->_MATCHIFYr($S, "scope_declarator__S_103my", 
do {
if (my ($C) = ($C->_PATTERN(qr/\Gmy/))) {
do {
if (my ($C) = ($C->nofun)) {
$C->_SUBSUMEr(['scoped'], sub {
my $C = shift;
$C->scoped('my')
});
}
else {
();
}
};
}
else {
();
}
}
);
}
##     token scope_declarator__S_104our (:$*endsym = 'nofun', :$*sym = 'our')
##          token scope_declarator:our       { <sym> <scoped('our')> }

sub scope_declarator__S_104our__PEEK { $_[0]->_AUTOLEXpeek('scope_declarator__S_104our',$retree) }
sub scope_declarator__S_104our {
no warnings 'recursion';
my $self = shift;
local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;
my %args = @_;
local $::endsym = $args{endsym} // 'nofun';
local $::sym = $args{sym} // 'our';


my $C = $self->cursor_xact("RULE scope_declarator__S_104our");
my $xact = $C->xact;
my $S = $C->{'_pos'};
$C->{'sym'} = ref $sym ? join(' ', @$sym) : $sym;

$self->_MATCHIFYr($S, "scope_declarator__S_104our", 
do {
if (my ($C) = ($C->_PATTERN(qr/\Gour/))) {
do {
if (my ($C) = ($C->nofun)) {
$C->_SUBSUMEr(['scoped'], sub {
my $C = shift;
$C->scoped('our')
});
}
else {
();
}
};
}
else {
();
}
}
);
}
##     token scope_declarator__S_105anon (:$*endsym = 'nofun', :$*sym = 'anon')
##          token scope_declarator:anon      { <sym> <scoped('anon')> }

sub scope_declarator__S_105anon__PEEK { $_[0]->_AUTOLEXpeek('scope_declarator__S_105anon',$retree) }
sub scope_declarator__S_105anon {
no warnings 'recursion';
my $self = shift;
local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;
my %args = @_;
local $::endsym = $args{endsym} // 'nofun';
local $::sym = $args{sym} // 'anon';


my $C = $self->cursor_xact("RULE scope_declarator__S_105anon");
my $xact = $C->xact;
my $S = $C->{'_pos'};
$C->{'sym'} = ref $sym ? join(' ', @$sym) : $sym;

$self->_MATCHIFYr($S, "scope_declarator__S_105anon", 
do {
if (my ($C) = ($C->_PATTERN(qr/\Ganon/))) {
do {
if (my ($C) = ($C->nofun)) {
$C->_SUBSUMEr(['scoped'], sub {
my $C = shift;
$C->scoped('anon')
});
}
else {
();
}
};
}
else {
();
}
}
);
}
##     token scope_declarator__S_106state (:$*endsym = 'nofun', :$*sym = 'state')
##          token scope_declarator:state     { <sym> <scoped('state')> }

sub scope_declarator__S_106state__PEEK { $_[0]->_AUTOLEXpeek('scope_declarator__S_106state',$retree) }
sub scope_declarator__S_106state {
no warnings 'recursion';
my $self = shift;
local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;
my %args = @_;
local $::endsym = $args{endsym} // 'nofun';
local $::sym = $args{sym} // 'state';


my $C = $self->cursor_xact("RULE scope_declarator__S_106state");
my $xact = $C->xact;
my $S = $C->{'_pos'};
$C->{'sym'} = ref $sym ? join(' ', @$sym) : $sym;

$self->_MATCHIFYr($S, "scope_declarator__S_106state", 
do {
if (my ($C) = ($C->_PATTERN(qr/\Gstate/))) {
do {
if (my ($C) = ($C->nofun)) {
$C->_SUBSUMEr(['scoped'], sub {
my $C = shift;
$C->scoped('state')
});
}
else {
();
}
};
}
else {
();
}
}
);
}
##     token scope_declarator__S_107has (:$*endsym = 'nofun', :$*sym = 'has')
##          token scope_declarator:has       { <sym> <scoped('has')> }

sub scope_declarator__S_107has__PEEK { $_[0]->_AUTOLEXpeek('scope_declarator__S_107has',$retree) }
sub scope_declarator__S_107has {
no warnings 'recursion';
my $self = shift;
local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;
my %args = @_;
local $::endsym = $args{endsym} // 'nofun';
local $::sym = $args{sym} // 'has';


my $C = $self->cursor_xact("RULE scope_declarator__S_107has");
my $xact = $C->xact;
my $S = $C->{'_pos'};
$C->{'sym'} = ref $sym ? join(' ', @$sym) : $sym;

$self->_MATCHIFYr($S, "scope_declarator__S_107has", 
do {
if (my ($C) = ($C->_PATTERN(qr/\Ghas/))) {
do {
if (my ($C) = ($C->nofun)) {
$C->_SUBSUMEr(['scoped'], sub {
my $C = shift;
$C->scoped('has')
});
}
else {
();
}
};
}
else {
();
}
}
);
}
##     token scope_declarator__S_108augment (:$*endsym = 'nofun', :$*sym = 'augment')
##          token scope_declarator:augment   { <sym> <scoped('augment')> }

sub scope_declarator__S_108augment__PEEK { $_[0]->_AUTOLEXpeek('scope_declarator__S_108augment',$retree) }
sub scope_declarator__S_108augment {
no warnings 'recursion';
my $self = shift;
local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;
my %args = @_;
local $::endsym = $args{endsym} // 'nofun';
local $::sym = $args{sym} // 'augment';


my $C = $self->cursor_xact("RULE scope_declarator__S_108augment");
my $xact = $C->xact;
my $S = $C->{'_pos'};
$C->{'sym'} = ref $sym ? join(' ', @$sym) : $sym;

$self->_MATCHIFYr($S, "scope_declarator__S_108augment", 
do {
if (my ($C) = ($C->_PATTERN(qr/\Gaugment/))) {
do {
if (my ($C) = ($C->nofun)) {
$C->_SUBSUMEr(['scoped'], sub {
my $C = shift;
$C->scoped('augment')
});
}
else {
();
}
};
}
else {
();
}
}
);
}
##     token scope_declarator__S_109supersede (:$*endsym = 'nofun', :$*sym = 'supersede')
##          token scope_declarator:supersede { <sym> <scoped('supersede')> }

sub scope_declarator__S_109supersede__PEEK { $_[0]->_AUTOLEXpeek('scope_declarator__S_109supersede',$retree) }
sub scope_declarator__S_109supersede {
no warnings 'recursion';
my $self = shift;
local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;
my %args = @_;
local $::endsym = $args{endsym} // 'nofun';
local $::sym = $args{sym} // 'supersede';


my $C = $self->cursor_xact("RULE scope_declarator__S_109supersede");
my $xact = $C->xact;
my $S = $C->{'_pos'};
$C->{'sym'} = ref $sym ? join(' ', @$sym) : $sym;

$self->_MATCHIFYr($S, "scope_declarator__S_109supersede", 
do {
if (my ($C) = ($C->_PATTERN(qr/\Gsupersede/))) {
do {
if (my ($C) = ($C->nofun)) {
$C->_SUBSUMEr(['scoped'], sub {
my $C = shift;
$C->scoped('supersede')
});
}
else {
();
}
};
}
else {
();
}
}
);
}


##     token package_declarator__S_110class (:$*endsym = 'spacey', :$*sym = 'class')
##          token package_declarator:class {
##              :my $*PKGDECL ::= 'class';
##              <sym> <package_def>
##          }

sub package_declarator__S_110class__PEEK { $_[0]->_AUTOLEXpeek('package_declarator__S_110class',$retree) }
sub package_declarator__S_110class {
no warnings 'recursion';
my $self = shift;
local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;
my %args = @_;
local $::endsym = $args{endsym} // 'spacey';
local $::sym = $args{sym} // 'class';
local $::PKGDECL = 'class';


my $C = $self->cursor_xact("RULE package_declarator__S_110class");
my $xact = $C->xact;
my $S = $C->{'_pos'};
$C->{'sym'} = ref $sym ? join(' ', @$sym) : $sym;

$self->_MATCHIFYr($S, "package_declarator__S_110class", 
do {
if (my ($C) = ($C->_PATTERN(qr/\Gclass/))) {
do {
if (my ($C) = ($C->spacey)) {
$C->_SUBSUMEr(['package_def'], sub {
my $C = shift;
$C->package_def
});
}
else {
();
}
};
}
else {
();
}
}
);
}

##     token package_declarator__S_111grammar (:$*endsym = 'spacey', :$*sym = 'grammar')
##          token package_declarator:grammar {
##              :my $*PKGDECL ::= 'grammar';
##              <sym> <package_def>
##          }

sub package_declarator__S_111grammar__PEEK { $_[0]->_AUTOLEXpeek('package_declarator__S_111grammar',$retree) }
sub package_declarator__S_111grammar {
no warnings 'recursion';
my $self = shift;
local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;
my %args = @_;
local $::endsym = $args{endsym} // 'spacey';
local $::sym = $args{sym} // 'grammar';
local $::PKGDECL = 'grammar';


my $C = $self->cursor_xact("RULE package_declarator__S_111grammar");
my $xact = $C->xact;
my $S = $C->{'_pos'};
$C->{'sym'} = ref $sym ? join(' ', @$sym) : $sym;

$self->_MATCHIFYr($S, "package_declarator__S_111grammar", 
do {
if (my ($C) = ($C->_PATTERN(qr/\Ggrammar/))) {
do {
if (my ($C) = ($C->spacey)) {
$C->_SUBSUMEr(['package_def'], sub {
my $C = shift;
$C->package_def
});
}
else {
();
}
};
}
else {
();
}
}
);
}

##     token package_declarator__S_112module (:$*endsym = 'spacey', :$*sym = 'module')
##          token package_declarator:module {
##              :my $*PKGDECL ::= 'module';
##              <sym> <package_def>
##          }

sub package_declarator__S_112module__PEEK { $_[0]->_AUTOLEXpeek('package_declarator__S_112module',$retree) }
sub package_declarator__S_112module {
no warnings 'recursion';
my $self = shift;
local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;
my %args = @_;
local $::endsym = $args{endsym} // 'spacey';
local $::sym = $args{sym} // 'module';
local $::PKGDECL = 'module';


my $C = $self->cursor_xact("RULE package_declarator__S_112module");
my $xact = $C->xact;
my $S = $C->{'_pos'};
$C->{'sym'} = ref $sym ? join(' ', @$sym) : $sym;

$self->_MATCHIFYr($S, "package_declarator__S_112module", 
do {
if (my ($C) = ($C->_PATTERN(qr/\Gmodule/))) {
do {
if (my ($C) = ($C->spacey)) {
$C->_SUBSUMEr(['package_def'], sub {
my $C = shift;
$C->package_def
});
}
else {
();
}
};
}
else {
();
}
}
);
}

##     token package_declarator__S_113package (:$*endsym = 'spacey', :$*sym = 'package')
##          token package_declarator:package {
##              :my $*PKGDECL ::= 'package';
##              <sym> <package_def>
##          }

sub package_declarator__S_113package__PEEK { $_[0]->_AUTOLEXpeek('package_declarator__S_113package',$retree) }
sub package_declarator__S_113package {
no warnings 'recursion';
my $self = shift;
local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;
my %args = @_;
local $::endsym = $args{endsym} // 'spacey';
local $::sym = $args{sym} // 'package';
local $::PKGDECL = 'package';


my $C = $self->cursor_xact("RULE package_declarator__S_113package");
my $xact = $C->xact;
my $S = $C->{'_pos'};
$C->{'sym'} = ref $sym ? join(' ', @$sym) : $sym;

$self->_MATCHIFYr($S, "package_declarator__S_113package", 
do {
if (my ($C) = ($C->_PATTERN(qr/\Gpackage/))) {
do {
if (my ($C) = ($C->spacey)) {
$C->_SUBSUMEr(['package_def'], sub {
my $C = shift;
$C->package_def
});
}
else {
();
}
};
}
else {
();
}
}
);
}

##     token package_declarator__S_114role (:$*endsym = 'spacey', :$*sym = 'role')
##          token package_declarator:role {
##              :my $*PKGDECL ::= 'role';
##              <sym> <package_def>
##          }

sub package_declarator__S_114role__PEEK { $_[0]->_AUTOLEXpeek('package_declarator__S_114role',$retree) }
sub package_declarator__S_114role {
no warnings 'recursion';
my $self = shift;
local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;
my %args = @_;
local $::endsym = $args{endsym} // 'spacey';
local $::sym = $args{sym} // 'role';
local $::PKGDECL = 'role';


my $C = $self->cursor_xact("RULE package_declarator__S_114role");
my $xact = $C->xact;
my $S = $C->{'_pos'};
$C->{'sym'} = ref $sym ? join(' ', @$sym) : $sym;

$self->_MATCHIFYr($S, "package_declarator__S_114role", 
do {
if (my ($C) = ($C->_PATTERN(qr/\Grole/))) {
do {
if (my ($C) = ($C->spacey)) {
$C->_SUBSUMEr(['package_def'], sub {
my $C = shift;
$C->package_def
});
}
else {
();
}
};
}
else {
();
}
}
);
}

##     token package_declarator__S_115knowhow (:$*endsym = 'spacey', :$*sym = 'knowhow')
##          token package_declarator:knowhow {
##              :my $*PKGDECL ::= 'knowhow';
##              <sym> <package_def>
##          }

sub package_declarator__S_115knowhow__PEEK { $_[0]->_AUTOLEXpeek('package_declarator__S_115knowhow',$retree) }
sub package_declarator__S_115knowhow {
no warnings 'recursion';
my $self = shift;
local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;
my %args = @_;
local $::endsym = $args{endsym} // 'spacey';
local $::sym = $args{sym} // 'knowhow';
local $::PKGDECL = 'knowhow';


my $C = $self->cursor_xact("RULE package_declarator__S_115knowhow");
my $xact = $C->xact;
my $S = $C->{'_pos'};
$C->{'sym'} = ref $sym ? join(' ', @$sym) : $sym;

$self->_MATCHIFYr($S, "package_declarator__S_115knowhow", 
do {
if (my ($C) = ($C->_PATTERN(qr/\Gknowhow/))) {
do {
if (my ($C) = ($C->spacey)) {
$C->_SUBSUMEr(['package_def'], sub {
my $C = shift;
$C->package_def
});
}
else {
();
}
};
}
else {
();
}
}
);
}

##     token package_declarator__S_116slang (:$*endsym = 'spacey', :$*sym = 'slang')
##          token package_declarator:slang {
##              :my $*PKGDECL ::= 'slang';
##              <sym> <package_def>
##          }

sub package_declarator__S_116slang__PEEK { $_[0]->_AUTOLEXpeek('package_declarator__S_116slang',$retree) }
sub package_declarator__S_116slang {
no warnings 'recursion';
my $self = shift;
local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;
my %args = @_;
local $::endsym = $args{endsym} // 'spacey';
local $::sym = $args{sym} // 'slang';
local $::PKGDECL = 'slang';


my $C = $self->cursor_xact("RULE package_declarator__S_116slang");
my $xact = $C->xact;
my $S = $C->{'_pos'};
$C->{'sym'} = ref $sym ? join(' ', @$sym) : $sym;

$self->_MATCHIFYr($S, "package_declarator__S_116slang", 
do {
if (my ($C) = ($C->_PATTERN(qr/\Gslang/))) {
do {
if (my ($C) = ($C->spacey)) {
$C->_SUBSUMEr(['package_def'], sub {
my $C = shift;
$C->package_def
});
}
else {
();
}
};
}
else {
();
}
}
);
}

##     token package_declarator__S_117require (:$*endsym = 'spacey', :$*sym = 'require')
##          token package_declarator:require {   # here because of declarational aspects
##              <sym> <.ws>
##              [
##              || <module_name> <EXPR>?
##              || <EXPR>
##              ]
##          }

sub package_declarator__S_117require__PEEK { $_[0]->_AUTOLEXpeek('package_declarator__S_117require',$retree) }
sub package_declarator__S_117require {
no warnings 'recursion';
my $self = shift;
local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;
my %args = @_;
local $::endsym = $args{endsym} // 'spacey';
local $::sym = $args{sym} // 'require';


my $C = $self->cursor_xact("RULE package_declarator__S_117require");
my $xact = $C->xact;
my $S = $C->{'_pos'};
$C->{'EXPR'} = [];
$C->{'sym'} = ref $sym ? join(' ', @$sym) : $sym;

$self->_MATCHIFYr($S, "package_declarator__S_117require", 
do {
if (my ($C) = ($C->_PATTERN(qr/\Grequire/))) {
do {
if (my ($C) = ($C->spacey)) {
do {
if (my ($C) = ($C->ws)) {
$C->_BRACKETr(sub {
my $C=shift;
do {
my $C = $C->cursor_xact('ALT ||');
my $xact = $C->xact;
my @gather;
do {
push @gather, do {
if (my ($C) = ($C->_SUBSUMEr(['module_name'], sub {
my $C = shift;
$C->module_name
}))) {
$C->_OPTr(sub { my $C=shift;
$C->_SUBSUMEr(['EXPR'], sub {
my $C = shift;
$C->EXPR
})
});
}
else {
();
}
}
}
or $xact->[-2] or
do {
push @gather, $C->_SUBSUMEr(['EXPR'], sub {
my $C = shift;
$C->EXPR
})};
@gather;
}
});
}
else {
();
}
};
}
else {
();
}
};
}
else {
();
}
}
);
}

##     token package_declarator__S_118trusts (:$*endsym = 'spacey', :$*sym = 'trusts')
##          token package_declarator:trusts {
##              <sym> <.ws>
##              <module_name>
##          }

sub package_declarator__S_118trusts__PEEK { $_[0]->_AUTOLEXpeek('package_declarator__S_118trusts',$retree) }
sub package_declarator__S_118trusts {
no warnings 'recursion';
my $self = shift;
local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;
my %args = @_;
local $::endsym = $args{endsym} // 'spacey';
local $::sym = $args{sym} // 'trusts';


my $C = $self->cursor_xact("RULE package_declarator__S_118trusts");
my $xact = $C->xact;
my $S = $C->{'_pos'};
$C->{'sym'} = ref $sym ? join(' ', @$sym) : $sym;

$self->_MATCHIFYr($S, "package_declarator__S_118trusts", 
do {
if (my ($C) = ($C->_PATTERN(qr/\Gtrusts/))) {
do {
if (my ($C) = ($C->spacey)) {
do {
if (my ($C) = ($C->ws)) {
$C->_SUBSUMEr(['module_name'], sub {
my $C = shift;
$C->module_name
});
}
else {
();
}
};
}
else {
();
}
};
}
else {
();
}
}
);
}

##     token package_declarator__S_119does (:$*endsym = 'spacey', :$*sym = 'does')
##          token package_declarator:does {
##              <sym>:s
##              <typename>
##          }

sub package_declarator__S_119does__PEEK { $_[0]->_AUTOLEXpeek('package_declarator__S_119does',$retree) }
sub package_declarator__S_119does {
no warnings 'recursion';
my $self = shift;
local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;
my %args = @_;
local $::endsym = $args{endsym} // 'spacey';
local $::sym = $args{sym} // 'does';


my $C = $self->cursor_xact("RULE package_declarator__S_119does");
my $xact = $C->xact;
my $S = $C->{'_pos'};
$C->{'sym'} = ref $sym ? join(' ', @$sym) : $sym;

$self->_MATCHIFYr($S, "package_declarator__S_119does", 
do {
if (my ($C) = ($C->_PATTERN(qr/\Gdoes/))) {
do {
if (my ($C) = ($C->spacey)) {
do {
if (my ($C) = ($C->ws)) {
do {
if (my ($C) = ($C->_SUBSUMEr(['typename'], sub {
my $C = shift;
$C->typename
}))) {
$C->ws;
}
else {
();
}
};
}
else {
();
}
};
}
else {
();
}
};
}
else {
();
}
}
);
}

##     rule package_def
##          rule package_def {
##              :my $longname;
##              :my $*IN_DECL = 'package';
##              :my $*DECLARAND;
##              :my $*NEWPKG;
##              :my $*NEWPAD;
##              :temp $*CURPKG;
##              { $*SCOPE ||= 'our'; }
##              [
##                  [
##                      <def_module_name>{
##                          $longname = $<def_module_name>[0]<longname>;
##                          $.add_name($longname.Str);
##                      }
##                  ]?
##                  <trait>*
##                  <.getdecl>
##                  [
##                  || <?before '{'>
##                      [
##                      {{
##                          # figure out the actual full package name (nested in outer package)
##                          if $longname and $*NEWPKG {
##                              my $shortname = $longname.<name>.Str;
##                              if $*SCOPE eq 'our' {
##                                  $*CURPKG = $*NEWPKG // $*CURPKG.{$shortname ~ '::'};
##                                  self.deb("added our " ~ $*CURPKG.id) if $*DEBUG +& DEBUG::symtab;
##                              }
##                              else {
##                                  $*CURPKG = $*NEWPKG // $*CURPKG.{$shortname ~ '::'};
##                                  self.deb("added my " ~ $*CURPKG.id) if $*DEBUG +& DEBUG::symtab;
##                              }
##                          }
##                          $*begin_compunit = 0;
##                      }}
##                      <block>
##                      ]
##                  || <?before ';'>
##                      [
##                      || <?{ $*begin_compunit }>
##                          {{
##                              $longname orelse $.panic("Compilation unit cannot be anonymous");
##                              my $shortname = $longname.<name>.Str;
##                              $*CURPKG = $*NEWPKG // $*CURPKG.{$shortname ~ '::'};
##                              $*begin_compunit = 0;
##      
##                              # throw out null core when compiling the real CORE
##                              if $shortname eq 'CORE' and $*CORE.id ~~ /NULL/ {
##                                  $*UNIT<OUTER::> = [''];
##                                  $*CORE = $*UNIT;
##                                  $*SETTING = $*UNIT;
##                                  $ALL = {
##                                      CORE => $*UNIT,
##                                      SETTING => $*UNIT,
##                                      $*UNIT.id => $*UNIT,
##                                  };
##                              }
##                          }}
##                          <statementlist>     # whole rest of file, presumably
##                      || <.panic: "Too late for semicolon form of " ~ $*PKGDECL ~ " definition">
##                      ]
##                  || <.panic: "Unable to parse " ~ $*PKGDECL ~ " definition">
##                  ]
##              ] || <.panic: "Malformed $*PKGDECL">
##          }

sub package_def__PEEK { $_[0]->_AUTOLEXpeek('package_def',$retree) }
sub package_def {
no warnings 'recursion';
my $self = shift;
local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;
my $longname;
local $::IN_DECL = 'package';
local $::DECLARAND;
local $::NEWPKG;
local $::NEWPAD;
local $::CURPKG = $::CURPKG;


my $C = $self->cursor_xact("RULE package_def");
my $xact = $C->xact;
my $S = $C->{'_pos'};
$C->{'trait'} = [];
$C->{'def_module_name'} = [];

$self->_MATCHIFYr($S, "package_def", 
do {
my $C = $C->cursor_xact('ALT ||');
my $xact = $C->xact;
my @gather;
do {
push @gather, do {
if (my ($C) = ($C->ws)) {
do {
if (my ($C) = (scalar(do {
$::SCOPE ||= 'our'; 
}, $C))) {
do {
if (my ($C) = ($C->ws)) {
do {
if (my ($C) = ($C->_BRACKETr(sub {
my $C=shift;
do {
if (my ($C) = ($C->_OPTr(sub { my $C=shift;
$C->_BRACKETr(sub {
my $C=shift;
do {
if (my ($C) = ($C->ws)) {
do {
if (my ($C) = ($C->_SUBSUMEr(['def_module_name'], sub {
my $C = shift;
$C->def_module_name
}))) {
do {
if (my ($C) = (scalar(do {
my $M = $C; 
$longname = $M->{'def_module_name'}[0]{'longname'};
$C->add_name($longname->Str);
;
}, $C))) {
$C->ws;
}
else {
();
}
};
}
else {
();
}
};
}
else {
();
}
}
})
}))) {
do {
if (my ($C) = ($C->ws)) {
do {
if (my ($C) = ($C->_STARr(sub { my $C=shift;
$C->_SUBSUMEr(['trait'], sub {
my $C = shift;
$C->trait
})
}))) {
do {
if (my ($C) = ($C->ws)) {
do {
if (my ($C) = ($C->getdecl)) {
do {
if (my ($C) = ($C->ws)) {
do {
if (my ($C) = ($C->_BRACKETr(sub {
my $C=shift;
do {
my $C = $C->cursor_xact('ALT ||');
my $xact = $C->xact;
my @gather;
do {
push @gather, do {
if (my ($C) = ($C->before(sub { my $C=shift;
$C->_EXACT('{')
}))) {
do {
if (my ($C) = ($C->ws)) {
do {
if (my ($C) = ($C->_BRACKETr(sub {
my $C=shift;
do {
if (my ($C) = (scalar(do {

# figure out the actual full package name (nested in outer package)
if ($longname and $::NEWPKG) {
my $shortname = $longname->{'name'}->Str;
if ($::SCOPE eq 'our') {
$::CURPKG = $::NEWPKG // $::CURPKG->{$shortname . '::'};
$self->deb("added our " . $::CURPKG->id) if $::DEBUG & DEBUG::symtab;
}
else {
$::CURPKG = $::NEWPKG // $::CURPKG->{$shortname . '::'};
$self->deb("added my " . $::CURPKG->id) if $::DEBUG & DEBUG::symtab;
}
}
$::begin_compunit = 0;

}, $C))) {
do {
if (my ($C) = ($C->ws)) {
do {
if (my ($C) = ($C->_SUBSUMEr(['block'], sub {
my $C = shift;
$C->block
}))) {
$C->ws;
}
else {
();
}
};
}
else {
();
}
};
}
else {
();
}
}
}))) {
$C->ws;
}
else {
();
}
};
}
else {
();
}
};
}
else {
();
}
}
}
or $xact->[-2] or
do {
push @gather, do {
if (my ($C) = ($C->before(sub { my $C=shift;
$C->_EXACT(';')
}))) {
do {
if (my ($C) = ($C->ws)) {
do {
if (my ($C) = ($C->_BRACKETr(sub {
my $C=shift;
do {
my $C = $C->cursor_xact('ALT ||');
my $xact = $C->xact;
my @gather;
do {
push @gather, do {
if (my ($C) = ($C->before( sub { my $C=shift;
(($C) x !!do {
$::begin_compunit 
})
}))) {
do {
if (my ($C) = ($C->ws)) {
do {
if (my ($C) = (scalar(do {

$longname or $C->panic("Compilation unit cannot be anonymous");
my $shortname = $longname->{'name'}->Str;
$::CURPKG = $::NEWPKG // $::CURPKG->{$shortname . '::'};
$::begin_compunit = 0;

# throw out null core when compiling the real CORE
if ($shortname eq 'CORE' and $::CORE->id =~ qr/NULL/) {
$::UNIT->{'OUTER::'} = [''];
$::CORE = $::UNIT;
$::SETTING = $::UNIT;
$ALL = {
CORE => $::UNIT,
SETTING => $::UNIT,
$::UNIT->id => $::UNIT,
};
}

}, $C))) {
do {
if (my ($C) = ($C->ws)) {
do {
if (my ($C) = ($C->_SUBSUMEr(['statementlist'], sub {
my $C = shift;
$C->statementlist
}))) {
$C->ws;
}
else {
();
}
};
}
else {
();
}
};
}
else {
();
}
};
}
else {
();
}
};
}
else {
();
}
}
}
or $xact->[-2] or
do {
push @gather, do {
if (my ($C) = ($C->panic("Too late for semicolon form of " . $::PKGDECL . " definition"))) {
$C->ws;
}
else {
();
}
}};
@gather;
}
}))) {
$C->ws;
}
else {
();
}
};
}
else {
();
}
};
}
else {
();
}
}
}
or $xact->[-2] or
do {
push @gather, do {
if (my ($C) = ($C->panic("Unable to parse " . $::PKGDECL . " definition"))) {
$C->ws;
}
else {
();
}
}};
@gather;
}
}))) {
$C->ws;
}
else {
();
}
};
}
else {
();
}
};
}
else {
();
}
};
}
else {
();
}
};
}
else {
();
}
};
}
else {
();
}
};
}
else {
();
}
}
}))) {
$C->ws;
}
else {
();
}
};
}
else {
();
}
};
}
else {
();
}
};
}
else {
();
}
}
}
or $xact->[-2] or
do {
push @gather, do {
if (my ($C) = ($C->ws)) {
do {
if (my ($C) = ($C->panic("Malformed $::PKGDECL"))) {
$C->ws;
}
else {
();
}
};
}
else {
();
}
}};
@gather;
}
);
}

##     token declarator
##          token declarator {
##              [
##              | <variable_declarator>
##                  [ <?before <.ws>','<.ws> { @*MEMOS[$.pos]<declend> = $*SCOPE; }> ]?
##              | '(' ~ ')' <signature> <trait>*
##              | <routine_declarator>
##              | <regex_declarator>
##              | <type_declarator>
##              ]
##          }

sub declarator__PEEK { $_[0]->_AUTOLEXpeek('declarator',$retree) }
sub declarator {
no warnings 'recursion';
my $self = shift;
local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;


my $C = $self->cursor_xact("RULE declarator");
my $xact = $C->xact;
my $S = $C->{'_pos'};
$C->{'trait'} = [];

$self->_MATCHIFYr($S, "declarator", 
$C->_BRACKETr(sub {
my $C=shift;
do {
my @result = do {
my $trystate;
my ($tag, $try);
my @try;
my $relex;

my $fate;
my $x;
if ($fate = $C->{'_fate'} and $fate->[1] eq 'declarator_01') {
$C->deb("Fate passed to declarator_01: ", ::fatestr($fate)) if $::DEBUG & DEBUG::fates;
($C->{'_fate'}, $tag, $try) = @$fate;
@try = ($try);
$x = 'ALT declarator_01';    # some outer ltm is controlling us
}
else {
$x = 'ALTLTM declarator_01'; # we are top level ltm
}
my $C = $C->cursor_xact($x);
my $xact = $C->xact;

my @gather = ();
for (;;) {
if (not @try) {
$relex //= $C->cursor_fate('STD::P6', 'declarator_01', $retree);
@try = $relex->($C, $trystate);
}
last unless @try;
$try = shift(@try) // next;

if (ref $try eq 'ARRAY') {
($C->{'_fate'}, $tag, $try) = @$try;	# next candidate fate
}

$C->deb("declarator_01 trying $tag $try") if $::DEBUG & DEBUG::try_processing;
push @gather, ((
sub { my $C=shift;
do {
if (my ($C) = ($C->_SUBSUMEr(['variable_declarator'], sub {
my $C = shift;
$C->variable_declarator
}))) {
$C->_OPTr(sub { my $C=shift;
$C->_BRACKETr(sub {
my $C=shift;
$C->before(sub { my $C=shift;
do {
if (my ($C) = ($C->ws)) {
do {
if (my ($C) = ($C->_EXACT(','))) {
do {
if (my ($C) = ($C->ws)) {
scalar(do {
$::MEMOS[$C->{'_pos'}]{'declend'} = $::SCOPE; 
}, $C);
}
else {
();
}
};
}
else {
();
}
};
}
else {
();
}
}
})
})
});
}
else {
();
}
}
},
sub { my $C=shift;
do {
if (my ($C) = ($C->_EXACT('('))) {
do {
if (my ($C) = (((local $::GOAL = ')' ), $C)[-1])) {
do {
if (my ($C) = ($C->_SUBSUMEr(['signature'], sub {
my $C = shift;
$C->signature
}))) {
do {
if (my ($C) = ($C->_BRACKETr(sub {
my $C=shift;
do {
my $C = $C->cursor_xact('ALT ||');
my $xact = $C->xact;
my @gather;
do {
push @gather, $C->_EXACT(')')
}
or $xact->[-2] or
do {
push @gather, $C->FAILGOAL(')' , 'declarator')};
@gather;
}
}))) {
$C->_STARr(sub { my $C=shift;
$C->_SUBSUMEr(['trait'], sub {
my $C = shift;
$C->trait
})
});
}
else {
();
}
};
}
else {
();
}
};
}
else {
();
}
};
}
else {
();
}
}
},
sub { my $C=shift;
$C->_SUBSUMEr(['routine_declarator'], sub {
my $C = shift;
$C->routine_declarator
})
},
sub { my $C=shift;
$C->_SUBSUMEr(['regex_declarator'], sub {
my $C = shift;
$C->regex_declarator
})
},
sub { my $C=shift;
$C->_SUBSUMEr(['type_declarator'], sub {
my $C = shift;
$C->type_declarator
})
},
)[$try])->($C);
last if $xact->[-2];  # committed?
last if @gather;
}
@gather;
};
@result;
}

})
);
}

##     token multi_declarator__S_120multi (:$*endsym = 'spacey', :$*sym = 'multi')
##          token multi_declarator:multi {
##              :my $*MULTINESS = 'multi';
##              <sym> <.ws> [ <declarator> || <routine_def> || <.panic: 'Malformed multi'> ]
##          }

sub multi_declarator__S_120multi__PEEK { $_[0]->_AUTOLEXpeek('multi_declarator__S_120multi',$retree) }
sub multi_declarator__S_120multi {
no warnings 'recursion';
my $self = shift;
local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;
my %args = @_;
local $::endsym = $args{endsym} // 'spacey';
local $::sym = $args{sym} // 'multi';
local $::MULTINESS = 'multi';


my $C = $self->cursor_xact("RULE multi_declarator__S_120multi");
my $xact = $C->xact;
my $S = $C->{'_pos'};
$C->{'sym'} = ref $sym ? join(' ', @$sym) : $sym;

$self->_MATCHIFYr($S, "multi_declarator__S_120multi", 
do {
if (my ($C) = ($C->_PATTERN(qr/\Gmulti/))) {
do {
if (my ($C) = ($C->spacey)) {
do {
if (my ($C) = ($C->ws)) {
$C->_BRACKETr(sub {
my $C=shift;
do {
my $C = $C->cursor_xact('ALT ||');
my $xact = $C->xact;
my @gather;
do {
push @gather, $C->_SUBSUMEr(['declarator'], sub {
my $C = shift;
$C->declarator
})
}
or $xact->[-2] or
do {
push @gather, $C->_SUBSUMEr(['routine_def'], sub {
my $C = shift;
$C->routine_def
})
}
or $xact->[-2] or
do {
push @gather, $C->panic('Malformed multi')};
@gather;
}
});
}
else {
();
}
};
}
else {
();
}
};
}
else {
();
}
}
);
}
##     token multi_declarator__S_121proto (:$*endsym = 'spacey', :$*sym = 'proto')
##          token multi_declarator:proto {
##              :my $*MULTINESS = 'proto';
##              <sym> <.ws> [ <declarator> || <routine_def> || <.panic: 'Malformed proto'> ]
##          }

sub multi_declarator__S_121proto__PEEK { $_[0]->_AUTOLEXpeek('multi_declarator__S_121proto',$retree) }
sub multi_declarator__S_121proto {
no warnings 'recursion';
my $self = shift;
local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;
my %args = @_;
local $::endsym = $args{endsym} // 'spacey';
local $::sym = $args{sym} // 'proto';
local $::MULTINESS = 'proto';


my $C = $self->cursor_xact("RULE multi_declarator__S_121proto");
my $xact = $C->xact;
my $S = $C->{'_pos'};
$C->{'sym'} = ref $sym ? join(' ', @$sym) : $sym;

$self->_MATCHIFYr($S, "multi_declarator__S_121proto", 
do {
if (my ($C) = ($C->_PATTERN(qr/\Gproto/))) {
do {
if (my ($C) = ($C->spacey)) {
do {
if (my ($C) = ($C->ws)) {
$C->_BRACKETr(sub {
my $C=shift;
do {
my $C = $C->cursor_xact('ALT ||');
my $xact = $C->xact;
my @gather;
do {
push @gather, $C->_SUBSUMEr(['declarator'], sub {
my $C = shift;
$C->declarator
})
}
or $xact->[-2] or
do {
push @gather, $C->_SUBSUMEr(['routine_def'], sub {
my $C = shift;
$C->routine_def
})
}
or $xact->[-2] or
do {
push @gather, $C->panic('Malformed proto')};
@gather;
}
});
}
else {
();
}
};
}
else {
();
}
};
}
else {
();
}
}
);
}
##     token multi_declarator__S_122only (:$*endsym = 'spacey', :$*sym = 'only')
##          token multi_declarator:only {
##              :my $*MULTINESS = 'only';
##              <sym> <.ws> [ <declarator> || <routine_def> || <.panic: 'Malformed only'> ]
##          }

sub multi_declarator__S_122only__PEEK { $_[0]->_AUTOLEXpeek('multi_declarator__S_122only',$retree) }
sub multi_declarator__S_122only {
no warnings 'recursion';
my $self = shift;
local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;
my %args = @_;
local $::endsym = $args{endsym} // 'spacey';
local $::sym = $args{sym} // 'only';
local $::MULTINESS = 'only';


my $C = $self->cursor_xact("RULE multi_declarator__S_122only");
my $xact = $C->xact;
my $S = $C->{'_pos'};
$C->{'sym'} = ref $sym ? join(' ', @$sym) : $sym;

$self->_MATCHIFYr($S, "multi_declarator__S_122only", 
do {
if (my ($C) = ($C->_PATTERN(qr/\Gonly/))) {
do {
if (my ($C) = ($C->spacey)) {
do {
if (my ($C) = ($C->ws)) {
$C->_BRACKETr(sub {
my $C=shift;
do {
my $C = $C->cursor_xact('ALT ||');
my $xact = $C->xact;
my @gather;
do {
push @gather, $C->_SUBSUMEr(['declarator'], sub {
my $C = shift;
$C->declarator
})
}
or $xact->[-2] or
do {
push @gather, $C->_SUBSUMEr(['routine_def'], sub {
my $C = shift;
$C->routine_def
})
}
or $xact->[-2] or
do {
push @gather, $C->panic('Malformed only')};
@gather;
}
});
}
else {
();
}
};
}
else {
();
}
};
}
else {
();
}
}
);
}
##     token multi_declarator__S_123null (:$*endsym = 'spacey', :$*sym = 'null')
##          token multi_declarator:null {
##              :my $*MULTINESS = '';
##              <declarator>
##          }

sub multi_declarator__S_123null__PEEK { $_[0]->_AUTOLEXpeek('multi_declarator__S_123null',$retree) }
sub multi_declarator__S_123null {
no warnings 'recursion';
my $self = shift;
local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;
my %args = @_;
local $::endsym = $args{endsym} // 'spacey';
local $::sym = $args{sym} // 'null';
local $::MULTINESS = '';


my $C = $self->cursor_xact("RULE multi_declarator__S_123null");
my $xact = $C->xact;
my $S = $C->{'_pos'};
$C->{'sym'} = ref $sym ? join(' ', @$sym) : $sym;

$self->_MATCHIFYr($S, "multi_declarator__S_123null", 
$C->_SUBSUMEr(['declarator'], sub {
my $C = shift;
$C->declarator
})
);
}

##     token routine_declarator__S_124sub (:$*endsym = 'nofun', :$*sym = 'sub')
##          token routine_declarator:sub       { <sym> <routine_def> }

sub routine_declarator__S_124sub__PEEK { $_[0]->_AUTOLEXpeek('routine_declarator__S_124sub',$retree) }
sub routine_declarator__S_124sub {
no warnings 'recursion';
my $self = shift;
local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;
my %args = @_;
local $::endsym = $args{endsym} // 'nofun';
local $::sym = $args{sym} // 'sub';


my $C = $self->cursor_xact("RULE routine_declarator__S_124sub");
my $xact = $C->xact;
my $S = $C->{'_pos'};
$C->{'sym'} = ref $sym ? join(' ', @$sym) : $sym;

$self->_MATCHIFYr($S, "routine_declarator__S_124sub", 
do {
if (my ($C) = ($C->_PATTERN(qr/\Gsub/))) {
do {
if (my ($C) = ($C->nofun)) {
$C->_SUBSUMEr(['routine_def'], sub {
my $C = shift;
$C->routine_def
});
}
else {
();
}
};
}
else {
();
}
}
);
}
##     token routine_declarator__S_125method (:$*endsym = 'nofun', :$*sym = 'method')
##          token routine_declarator:method    { <sym> <method_def> }

sub routine_declarator__S_125method__PEEK { $_[0]->_AUTOLEXpeek('routine_declarator__S_125method',$retree) }
sub routine_declarator__S_125method {
no warnings 'recursion';
my $self = shift;
local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;
my %args = @_;
local $::endsym = $args{endsym} // 'nofun';
local $::sym = $args{sym} // 'method';


my $C = $self->cursor_xact("RULE routine_declarator__S_125method");
my $xact = $C->xact;
my $S = $C->{'_pos'};
$C->{'sym'} = ref $sym ? join(' ', @$sym) : $sym;

$self->_MATCHIFYr($S, "routine_declarator__S_125method", 
do {
if (my ($C) = ($C->_PATTERN(qr/\Gmethod/))) {
do {
if (my ($C) = ($C->nofun)) {
$C->_SUBSUMEr(['method_def'], sub {
my $C = shift;
$C->method_def
});
}
else {
();
}
};
}
else {
();
}
}
);
}
##     token routine_declarator__S_126submethod (:$*endsym = 'nofun', :$*sym = 'submethod')
##          token routine_declarator:submethod { <sym> <method_def> }

sub routine_declarator__S_126submethod__PEEK { $_[0]->_AUTOLEXpeek('routine_declarator__S_126submethod',$retree) }
sub routine_declarator__S_126submethod {
no warnings 'recursion';
my $self = shift;
local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;
my %args = @_;
local $::endsym = $args{endsym} // 'nofun';
local $::sym = $args{sym} // 'submethod';


my $C = $self->cursor_xact("RULE routine_declarator__S_126submethod");
my $xact = $C->xact;
my $S = $C->{'_pos'};
$C->{'sym'} = ref $sym ? join(' ', @$sym) : $sym;

$self->_MATCHIFYr($S, "routine_declarator__S_126submethod", 
do {
if (my ($C) = ($C->_PATTERN(qr/\Gsubmethod/))) {
do {
if (my ($C) = ($C->nofun)) {
$C->_SUBSUMEr(['method_def'], sub {
my $C = shift;
$C->method_def
});
}
else {
();
}
};
}
else {
();
}
}
);
}
##     token routine_declarator__S_127macro (:$*endsym = 'nofun', :$*sym = 'macro')
##          token routine_declarator:macro     { <sym> <macro_def> }

sub routine_declarator__S_127macro__PEEK { $_[0]->_AUTOLEXpeek('routine_declarator__S_127macro',$retree) }
sub routine_declarator__S_127macro {
no warnings 'recursion';
my $self = shift;
local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;
my %args = @_;
local $::endsym = $args{endsym} // 'nofun';
local $::sym = $args{sym} // 'macro';


my $C = $self->cursor_xact("RULE routine_declarator__S_127macro");
my $xact = $C->xact;
my $S = $C->{'_pos'};
$C->{'sym'} = ref $sym ? join(' ', @$sym) : $sym;

$self->_MATCHIFYr($S, "routine_declarator__S_127macro", 
do {
if (my ($C) = ($C->_PATTERN(qr/\Gmacro/))) {
do {
if (my ($C) = ($C->nofun)) {
$C->_SUBSUMEr(['macro_def'], sub {
my $C = shift;
$C->macro_def
});
}
else {
();
}
};
}
else {
();
}
}
);
}

##     token regex_declarator__S_128regex (:$*endsym = 'spacey', :$*sym = 'regex')
##          token regex_declarator:regex { <sym>       <regex_def> }

sub regex_declarator__S_128regex__PEEK { $_[0]->_AUTOLEXpeek('regex_declarator__S_128regex',$retree) }
sub regex_declarator__S_128regex {
no warnings 'recursion';
my $self = shift;
local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;
my %args = @_;
local $::endsym = $args{endsym} // 'spacey';
local $::sym = $args{sym} // 'regex';


my $C = $self->cursor_xact("RULE regex_declarator__S_128regex");
my $xact = $C->xact;
my $S = $C->{'_pos'};
$C->{'sym'} = ref $sym ? join(' ', @$sym) : $sym;

$self->_MATCHIFYr($S, "regex_declarator__S_128regex", 
do {
if (my ($C) = ($C->_PATTERN(qr/\Gregex/))) {
do {
if (my ($C) = ($C->spacey)) {
$C->_SUBSUMEr(['regex_def'], sub {
my $C = shift;
$C->regex_def
});
}
else {
();
}
};
}
else {
();
}
}
);
}
##     token regex_declarator__S_129token (:$*endsym = 'spacey', :$*sym = 'token')
##          token regex_declarator:token { <sym>       <regex_def> }

sub regex_declarator__S_129token__PEEK { $_[0]->_AUTOLEXpeek('regex_declarator__S_129token',$retree) }
sub regex_declarator__S_129token {
no warnings 'recursion';
my $self = shift;
local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;
my %args = @_;
local $::endsym = $args{endsym} // 'spacey';
local $::sym = $args{sym} // 'token';


my $C = $self->cursor_xact("RULE regex_declarator__S_129token");
my $xact = $C->xact;
my $S = $C->{'_pos'};
$C->{'sym'} = ref $sym ? join(' ', @$sym) : $sym;

$self->_MATCHIFYr($S, "regex_declarator__S_129token", 
do {
if (my ($C) = ($C->_PATTERN(qr/\Gtoken/))) {
do {
if (my ($C) = ($C->spacey)) {
$C->_SUBSUMEr(['regex_def'], sub {
my $C = shift;
$C->regex_def
});
}
else {
();
}
};
}
else {
();
}
}
);
}
##     token regex_declarator__S_130rule (:$*endsym = 'spacey', :$*sym = 'rule')
##          token regex_declarator:rule  { <sym>       <regex_def> }

sub regex_declarator__S_130rule__PEEK { $_[0]->_AUTOLEXpeek('regex_declarator__S_130rule',$retree) }
sub regex_declarator__S_130rule {
no warnings 'recursion';
my $self = shift;
local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;
my %args = @_;
local $::endsym = $args{endsym} // 'spacey';
local $::sym = $args{sym} // 'rule';


my $C = $self->cursor_xact("RULE regex_declarator__S_130rule");
my $xact = $C->xact;
my $S = $C->{'_pos'};
$C->{'sym'} = ref $sym ? join(' ', @$sym) : $sym;

$self->_MATCHIFYr($S, "regex_declarator__S_130rule", 
do {
if (my ($C) = ($C->_PATTERN(qr/\Grule/))) {
do {
if (my ($C) = ($C->spacey)) {
$C->_SUBSUMEr(['regex_def'], sub {
my $C = shift;
$C->regex_def
});
}
else {
();
}
};
}
else {
();
}
}
);
}

##     rule multisig
##          rule multisig {
##              :my $signum = 0;
##              :dba('signature')
##              [
##                  ':'?'(' ~ ')' <signature(++$signum)>
##              ]
##              ** '|'
##          }

sub multisig__PEEK { $_[0]->_AUTOLEXpeek('multisig',$retree) }
sub multisig {
no warnings 'recursion';
my $self = shift;
local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;
my $signum = 0;


my $C = $self->cursor_xact("RULE multisig");
my $xact = $C->xact;
my $S = $C->{'_pos'};
$C->{'signature'} = [];

$self->_MATCHIFYr($S, "multisig", 
do {
if (my ($C) = ($C->ws)) {
do {
if (my ($C) = ($C->ws)) {
do {
if (my ($C) = ($C->_REPSEPr(  sub { my $C=shift;
$C->_EXACT('|')
}, sub { my $C=shift;
$C->_BRACKETr(sub {
my $C=shift;
do {
if (my ($C) = ($C->ws)) {
do {
if (my ($C) = ($C->_OPTr(sub { my $C=shift;
$C->_EXACT(':')
}))) {
do {
if (my ($C) = ($C->_EXACT('('))) {
do {
if (my ($C) = ($C->ws)) {
do {
if (my ($C) = (((local $::GOAL = ')'), $C)[-1])) {
do {
if (my ($C) = ($C->_SUBSUMEr(['signature'], sub {
my $C = shift;
$C->signature(++$signum)
}))) {
do {
if (my ($C) = ($C->_BRACKETr(sub {
my $C=shift;
do {
my $C = $C->cursor_xact('ALT ||');
my $xact = $C->xact;
my @gather;
do {
push @gather, $C->_EXACT(')')
}
or $xact->[-2] or
do {
push @gather, $C->FAILGOAL(')', 'signature')};
@gather;
}
}))) {
$C->ws;
}
else {
();
}
};
}
else {
();
}
};
}
else {
();
}
};
}
else {
();
}
};
}
else {
();
}
};
}
else {
();
}
};
}
else {
();
}
}
})
}))) {
$C->ws;
}
else {
();
}
};
}
else {
();
}
};
}
else {
();
}
}
);
}

##     method checkyada
sub checkyada {
my $self = shift;


eval {
my $startsym = $self->{'blockoid'}{'statementlist'}{'statement'}[0]{'EXPR'}{'sym'} // '';
if ($startsym eq '...' or $startsym eq '!!!' or $startsym eq '???') {
$::DECLARAND->{'stub'} = 1;
}
};
return $self;
}

##     rule routine_def ()
##          rule routine_def () {
##              :temp $*CURPAD;
##              :my $*IN_DECL = 'routine';
##              :my $*DECLARAND;
##              [
##                  [ $<sigil>=['&''*'?] <deflongname>? | <deflongname> ]?
##                  <.newpad(1)>
##                  [ <multisig> | <trait> ]*
##                  <!{
##                      $*IN_DECL = '';
##                  }>
##                  <blockoid>:!s
##                  <.checkyada>
##                  <.getsig>
##                  <.getdecl>
##              ] || <.panic: "Malformed routine">
##          }

sub routine_def__PEEK { $_[0]->_AUTOLEXpeek('routine_def',$retree) }
sub routine_def {
no warnings 'recursion';
my $self = shift;
local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;
local $::CURPAD = $::CURPAD;
local $::IN_DECL = 'routine';
local $::DECLARAND;


my $C = $self->cursor_xact("RULE routine_def");
my $xact = $C->xact;
my $S = $C->{'_pos'};
$C->{'deflongname'} = [];
$C->{'multisig'} = [];
$C->{'trait'} = [];
$C->{'sigil'} = [];

$self->_MATCHIFYr($S, "routine_def", 
do {
my $C = $C->cursor_xact('ALT ||');
my $xact = $C->xact;
my @gather;
do {
push @gather, do {
if (my ($C) = ($C->ws)) {
do {
if (my ($C) = ($C->_BRACKETr(sub {
my $C=shift;
do {
if (my ($C) = ($C->_OPTr(sub { my $C=shift;
$C->_BRACKETr(sub {
my $C=shift;
do {
my @result = do {
my $trystate;
my ($tag, $try);
my @try;
my $relex;

my $fate;
my $x;
if ($fate = $C->{'_fate'} and $fate->[1] eq 'routine_def_02') {
$C->deb("Fate passed to routine_def_02: ", ::fatestr($fate)) if $::DEBUG & DEBUG::fates;
($C->{'_fate'}, $tag, $try) = @$fate;
@try = ($try);
$x = 'ALT routine_def_02';    # some outer ltm is controlling us
}
else {
$x = 'ALTLTM routine_def_02'; # we are top level ltm
}
my $C = $C->cursor_xact($x);
my $xact = $C->xact;

my @gather = ();
for (;;) {
if (not @try) {
$relex //= $C->cursor_fate('STD::P6', 'routine_def_02', $retree);
@try = $relex->($C, $trystate);
}
last unless @try;
$try = shift(@try) // next;

if (ref $try eq 'ARRAY') {
($C->{'_fate'}, $tag, $try) = @$try;	# next candidate fate
}

$C->deb("routine_def_02 trying $tag $try") if $::DEBUG & DEBUG::try_processing;
push @gather, ((
sub { my $C=shift;
do {
if (my ($C) = ($C->ws)) {
do {
if (my ($C) = (  $C->_SUBSUMEr(['sigil'], sub {
my $C = shift;
$C->_BRACKETr(sub {
my $C=shift;
do {
if (my ($C) = ($C->_EXACT('&'))) {
$C->_OPTr(sub { my $C=shift;
$C->_EXACT('*')
});
}
else {
();
}
}
})
}))) {
do {
if (my ($C) = ($C->ws)) {
do {
if (my ($C) = ($C->_OPTr(sub { my $C=shift;
$C->_SUBSUMEr(['deflongname'], sub {
my $C = shift;
$C->deflongname
})
}))) {
$C->ws;
}
else {
();
}
};
}
else {
();
}
};
}
else {
();
}
};
}
else {
();
}
}
},
sub { my $C=shift;
do {
if (my ($C) = ($C->ws)) {
do {
if (my ($C) = ($C->_SUBSUMEr(['deflongname'], sub {
my $C = shift;
$C->deflongname
}))) {
$C->ws;
}
else {
();
}
};
}
else {
();
}
}
},
)[$try])->($C);
last if $xact->[-2];  # committed?
last if @gather;
}
@gather;
};
@result;
}

})
}))) {
do {
if (my ($C) = ($C->ws)) {
do {
if (my ($C) = ($C->newpad(1))) {
do {
if (my ($C) = ($C->ws)) {
do {
if (my ($C) = ($C->_STARr(sub { my $C=shift;
$C->_BRACKETr(sub {
my $C=shift;
do {
my @result = do {
my $trystate;
my ($tag, $try);
my @try;
my $relex;

my $fate;
my $x;
if ($fate = $C->{'_fate'} and $fate->[1] eq 'routine_def_04') {
$C->deb("Fate passed to routine_def_04: ", ::fatestr($fate)) if $::DEBUG & DEBUG::fates;
($C->{'_fate'}, $tag, $try) = @$fate;
@try = ($try);
$x = 'ALT routine_def_04';    # some outer ltm is controlling us
}
else {
$x = 'ALTLTM routine_def_04'; # we are top level ltm
}
my $C = $C->cursor_xact($x);
my $xact = $C->xact;

my @gather = ();
for (;;) {
if (not @try) {
$relex //= $C->cursor_fate('STD::P6', 'routine_def_04', $retree);
@try = $relex->($C, $trystate);
}
last unless @try;
$try = shift(@try) // next;

if (ref $try eq 'ARRAY') {
($C->{'_fate'}, $tag, $try) = @$try;	# next candidate fate
}

$C->deb("routine_def_04 trying $tag $try") if $::DEBUG & DEBUG::try_processing;
push @gather, ((
sub { my $C=shift;
do {
if (my ($C) = ($C->ws)) {
do {
if (my ($C) = ($C->_SUBSUMEr(['multisig'], sub {
my $C = shift;
$C->multisig
}))) {
$C->ws;
}
else {
();
}
};
}
else {
();
}
}
},
sub { my $C=shift;
do {
if (my ($C) = ($C->ws)) {
do {
if (my ($C) = ($C->_SUBSUMEr(['trait'], sub {
my $C = shift;
$C->trait
}))) {
$C->ws;
}
else {
();
}
};
}
else {
();
}
}
},
)[$try])->($C);
last if $xact->[-2];  # committed?
last if @gather;
}
@gather;
};
@result;
}

})
}))) {
do {
if (my ($C) = ($C->ws)) {
do {
if (my ($C) = ($C->_NOTBEFORE( sub { my $C=shift;
(($C) x !!do {

$::IN_DECL = '';

})
}))) {
do {
if (my ($C) = ($C->ws)) {
do {
if (my ($C) = ($C->_SUBSUMEr(['blockoid'], sub {
my $C = shift;
$C->blockoid
}))) {
do {
if (my ($C) = ($C->checkyada)) {
do {
if (my ($C) = ($C->getsig)) {
$C->getdecl;
}
else {
();
}
};
}
else {
();
}
};
}
else {
();
}
};
}
else {
();
}
};
}
else {
();
}
};
}
else {
();
}
};
}
else {
();
}
};
}
else {
();
}
};
}
else {
();
}
};
}
else {
();
}
};
}
else {
();
}
}
}))) {
$C->ws;
}
else {
();
}
};
}
else {
();
}
}
}
or $xact->[-2] or
do {
push @gather, do {
if (my ($C) = ($C->ws)) {
do {
if (my ($C) = ($C->panic("Malformed routine"))) {
$C->ws;
}
else {
();
}
};
}
else {
();
}
}};
@gather;
}
);
}

##     rule method_def ()
##          rule method_def () {
##              :temp $*CURPAD;
##              :my $*IN_DECL = 'method';
##              :my $*DECLARAND;
##              <.newpad(1)>
##              [
##                  [
##                  | <[ ! ^ ]>?<longname> [ <multisig> | <trait> ]*
##                  | <multisig> <trait>*
##                  | <sigil> '.'
##                      :dba('subscript signature')
##                      [
##                      | '(' ~ ')' <signature>
##                      | '[' ~ ']' <signature>
##                      | '{' ~ '}' <signature> # don't need curlycheck here
##                      | <?before '<'> <postcircumfix>
##                      ]
##                      <trait>*
##                  | <?>
##                  ]
##                  { $*IN_DECL = ''; }
##                  <blockoid>:!s
##                  <.checkyada>
##                  <.getsig>
##                  <.getdecl>
##              ] || <.panic: "Malformed method">
##          }

sub method_def__PEEK { $_[0]->_AUTOLEXpeek('method_def',$retree) }
sub method_def {
no warnings 'recursion';
my $self = shift;
local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;
local $::CURPAD = $::CURPAD;
local $::IN_DECL = 'method';
local $::DECLARAND;


my $C = $self->cursor_xact("RULE method_def");
my $xact = $C->xact;
my $S = $C->{'_pos'};
$C->{'multisig'} = [];
$C->{'trait'} = [];

$self->_MATCHIFYr($S, "method_def", 
do {
my $C = $C->cursor_xact('ALT ||');
my $xact = $C->xact;
my @gather;
do {
push @gather, do {
if (my ($C) = ($C->ws)) {
do {
if (my ($C) = ($C->newpad(1))) {
do {
if (my ($C) = ($C->ws)) {
do {
if (my ($C) = ($C->_BRACKETr(sub {
my $C=shift;
do {
if (my ($C) = ($C->_BRACKETr(sub {
my $C=shift;
do {
my @result = do {
my $trystate;
my ($tag, $try);
my @try;
my $relex;

my $fate;
my $x;
if ($fate = $C->{'_fate'} and $fate->[1] eq 'method_def_02') {
$C->deb("Fate passed to method_def_02: ", ::fatestr($fate)) if $::DEBUG & DEBUG::fates;
($C->{'_fate'}, $tag, $try) = @$fate;
@try = ($try);
$x = 'ALT method_def_02';    # some outer ltm is controlling us
}
else {
$x = 'ALTLTM method_def_02'; # we are top level ltm
}
my $C = $C->cursor_xact($x);
my $xact = $C->xact;

my @gather = ();
for (;;) {
if (not @try) {
$relex //= $C->cursor_fate('STD::P6', 'method_def_02', $retree);
@try = $relex->($C, $trystate);
}
last unless @try;
$try = shift(@try) // next;

if (ref $try eq 'ARRAY') {
($C->{'_fate'}, $tag, $try) = @$try;	# next candidate fate
}

$C->deb("method_def_02 trying $tag $try") if $::DEBUG & DEBUG::try_processing;
push @gather, ((
sub { my $C=shift;
do {
if (my ($C) = ($C->_PATTERN(qr/\G((?:[!^])?+)/))) {
do {
if (my ($C) = ($C->_SUBSUMEr(['longname'], sub {
my $C = shift;
$C->longname
}))) {
do {
if (my ($C) = ($C->ws)) {
do {
if (my ($C) = ($C->_STARr(sub { my $C=shift;
$C->_BRACKETr(sub {
my $C=shift;
do {
my @result = do {
my $trystate;
my ($tag, $try);
my @try;
my $relex;

my $fate;
my $x;
if ($fate = $C->{'_fate'} and $fate->[1] eq 'method_def_03') {
$C->deb("Fate passed to method_def_03: ", ::fatestr($fate)) if $::DEBUG & DEBUG::fates;
($C->{'_fate'}, $tag, $try) = @$fate;
@try = ($try);
$x = 'ALT method_def_03';    # some outer ltm is controlling us
}
else {
$x = 'ALTLTM method_def_03'; # we are top level ltm
}
my $C = $C->cursor_xact($x);
my $xact = $C->xact;

my @gather = ();
for (;;) {
if (not @try) {
$relex //= $C->cursor_fate('STD::P6', 'method_def_03', $retree);
@try = $relex->($C, $trystate);
}
last unless @try;
$try = shift(@try) // next;

if (ref $try eq 'ARRAY') {
($C->{'_fate'}, $tag, $try) = @$try;	# next candidate fate
}

$C->deb("method_def_03 trying $tag $try") if $::DEBUG & DEBUG::try_processing;
push @gather, ((
sub { my $C=shift;
do {
if (my ($C) = ($C->ws)) {
do {
if (my ($C) = ($C->_SUBSUMEr(['multisig'], sub {
my $C = shift;
$C->multisig
}))) {
$C->ws;
}
else {
();
}
};
}
else {
();
}
}
},
sub { my $C=shift;
do {
if (my ($C) = ($C->ws)) {
do {
if (my ($C) = ($C->_SUBSUMEr(['trait'], sub {
my $C = shift;
$C->trait
}))) {
$C->ws;
}
else {
();
}
};
}
else {
();
}
}
},
)[$try])->($C);
last if $xact->[-2];  # committed?
last if @gather;
}
@gather;
};
@result;
}

})
}))) {
$C->ws;
}
else {
();
}
};
}
else {
();
}
};
}
else {
();
}
};
}
else {
();
}
}
},
sub { my $C=shift;
do {
if (my ($C) = ($C->_SUBSUMEr(['multisig'], sub {
my $C = shift;
$C->multisig
}))) {
do {
if (my ($C) = ($C->ws)) {
do {
if (my ($C) = ($C->_STARr(sub { my $C=shift;
$C->_SUBSUMEr(['trait'], sub {
my $C = shift;
$C->trait
})
}))) {
$C->ws;
}
else {
();
}
};
}
else {
();
}
};
}
else {
();
}
}
},
sub { my $C=shift;
do {
if (my ($C) = ($C->_SUBSUMEr(['sigil'], sub {
my $C = shift;
$C->sigil
}))) {
do {
if (my ($C) = ($C->ws)) {
do {
if (my ($C) = ($C->_EXACT('.'))) {
do {
if (my ($C) = ($C->ws)) {
do {
if (my ($C) = ($C->ws)) {
do {
if (my ($C) = ($C->_BRACKETr(sub {
my $C=shift;
do {
my @result = do {
my $trystate;
my ($tag, $try);
my @try;
my $relex;

my $fate;
my $x;
if ($fate = $C->{'_fate'} and $fate->[1] eq 'method_def_04') {
$C->deb("Fate passed to method_def_04: ", ::fatestr($fate)) if $::DEBUG & DEBUG::fates;
($C->{'_fate'}, $tag, $try) = @$fate;
@try = ($try);
$x = 'ALT method_def_04';    # some outer ltm is controlling us
}
else {
$x = 'ALTLTM method_def_04'; # we are top level ltm
}
my $C = $C->cursor_xact($x);
my $xact = $C->xact;

my @gather = ();
for (;;) {
if (not @try) {
$relex //= $C->cursor_fate('STD::P6', 'method_def_04', $retree);
@try = $relex->($C, $trystate);
}
last unless @try;
$try = shift(@try) // next;

if (ref $try eq 'ARRAY') {
($C->{'_fate'}, $tag, $try) = @$try;	# next candidate fate
}

$C->deb("method_def_04 trying $tag $try") if $::DEBUG & DEBUG::try_processing;
push @gather, ((
sub { my $C=shift;
do {
if (my ($C) = ($C->_EXACT('('))) {
do {
if (my ($C) = ($C->ws)) {
do {
if (my ($C) = (((local $::GOAL = ')'), $C)[-1])) {
do {
if (my ($C) = ($C->_SUBSUMEr(['signature'], sub {
my $C = shift;
$C->signature
}))) {
do {
if (my ($C) = ($C->_BRACKETr(sub {
my $C=shift;
do {
my $C = $C->cursor_xact('ALT ||');
my $xact = $C->xact;
my @gather;
do {
push @gather, $C->_EXACT(')')
}
or $xact->[-2] or
do {
push @gather, $C->FAILGOAL(')', 'subscript signature')};
@gather;
}
}))) {
$C->ws;
}
else {
();
}
};
}
else {
();
}
};
}
else {
();
}
};
}
else {
();
}
};
}
else {
();
}
}
},
sub { my $C=shift;
do {
if (my ($C) = ($C->_EXACT('['))) {
do {
if (my ($C) = ($C->ws)) {
do {
if (my ($C) = (((local $::GOAL = ']'), $C)[-1])) {
do {
if (my ($C) = ($C->_SUBSUMEr(['signature'], sub {
my $C = shift;
$C->signature
}))) {
do {
if (my ($C) = ($C->_BRACKETr(sub {
my $C=shift;
do {
my $C = $C->cursor_xact('ALT ||');
my $xact = $C->xact;
my @gather;
do {
push @gather, $C->_EXACT(']')
}
or $xact->[-2] or
do {
push @gather, $C->FAILGOAL(']', 'subscript signature')};
@gather;
}
}))) {
$C->ws;
}
else {
();
}
};
}
else {
();
}
};
}
else {
();
}
};
}
else {
();
}
};
}
else {
();
}
}
},
sub { my $C=shift;
do {
if (my ($C) = ($C->_EXACT('{'))) {
do {
if (my ($C) = ($C->ws)) {
do {
if (my ($C) = (((local $::GOAL = '}'), $C)[-1])) {
do {
if (my ($C) = ($C->_SUBSUMEr(['signature'], sub {
my $C = shift;
$C->signature
}))) {
do {
if (my ($C) = ($C->_BRACKETr(sub {
my $C=shift;
do {
my $C = $C->cursor_xact('ALT ||');
my $xact = $C->xact;
my @gather;
do {
push @gather, $C->_EXACT('}')
}
or $xact->[-2] or
do {
push @gather, $C->FAILGOAL('}', 'subscript signature')};
@gather;
}
}))) {
$C->ws;
}
else {
();
}
};
}
else {
();
}
};
}
else {
();
}
};
}
else {
();
}
};
}
else {
();
}
}
},
sub { my $C=shift;
do {
if (my ($C) = ($C->before(sub { my $C=shift;
$C->_EXACT('<')
}))) {
do {
if (my ($C) = ($C->ws)) {
do {
if (my ($C) = ($C->_SUBSUMEr(['postcircumfix'], sub {
my $C = shift;
$C->postcircumfix
}))) {
$C->ws;
}
else {
();
}
};
}
else {
();
}
};
}
else {
();
}
}
},
)[$try])->($C);
last if $xact->[-2];  # committed?
last if @gather;
}
@gather;
};
@result;
}

}))) {
do {
if (my ($C) = ($C->ws)) {
do {
if (my ($C) = ($C->_STARr(sub { my $C=shift;
$C->_SUBSUMEr(['trait'], sub {
my $C = shift;
$C->trait
})
}))) {
$C->ws;
}
else {
();
}
};
}
else {
();
}
};
}
else {
();
}
};
}
else {
();
}
};
}
else {
();
}
};
}
else {
();
}
};
}
else {
();
}
};
}
else {
();
}
}
},
sub { my $C=shift;
do {
if (my ($C) = ($C->before( sub { my $C=shift;
$C
}))) {
$C->ws;
}
else {
();
}
}
},
)[$try])->($C);
last if $xact->[-2];  # committed?
last if @gather;
}
@gather;
};
@result;
}

}))) {
do {
if (my ($C) = ($C->ws)) {
do {
if (my ($C) = (scalar(do {
$::IN_DECL = ''; 
}, $C))) {
do {
if (my ($C) = ($C->ws)) {
do {
if (my ($C) = ($C->_SUBSUMEr(['blockoid'], sub {
my $C = shift;
$C->blockoid
}))) {
do {
if (my ($C) = ($C->checkyada)) {
do {
if (my ($C) = ($C->getsig)) {
$C->getdecl;
}
else {
();
}
};
}
else {
();
}
};
}
else {
();
}
};
}
else {
();
}
};
}
else {
();
}
};
}
else {
();
}
};
}
else {
();
}
}
}))) {
$C->ws;
}
else {
();
}
};
}
else {
();
}
};
}
else {
();
}
};
}
else {
();
}
}
}
or $xact->[-2] or
do {
push @gather, do {
if (my ($C) = ($C->ws)) {
do {
if (my ($C) = ($C->panic("Malformed method"))) {
$C->ws;
}
else {
();
}
};
}
else {
();
}
}};
@gather;
}
);
}

##     rule regex_def ()
##          rule regex_def () {
##              :temp $*CURPAD;
##              :my $*IN_DECL = 'regex';
##              :my $*DECLARAND;
##              [
##                  [ '&'<deflongname>? | <deflongname> ]?
##                  <.newpad(1)>
##                  [ [ ':'?'(' <signature(1)> ')'] | <trait> ]*
##                  { $*IN_DECL = ''; }
##                  <.finishpad>
##                  <regex_block>:!s
##                  <.getsig>
##                  <.getdecl>
##              ] || <.panic: "Malformed regex">
##          }

sub regex_def__PEEK { $_[0]->_AUTOLEXpeek('regex_def',$retree) }
sub regex_def {
no warnings 'recursion';
my $self = shift;
local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;
local $::CURPAD = $::CURPAD;
local $::IN_DECL = 'regex';
local $::DECLARAND;


my $C = $self->cursor_xact("RULE regex_def");
my $xact = $C->xact;
my $S = $C->{'_pos'};
$C->{'deflongname'} = [];
$C->{'signature'} = [];
$C->{'trait'} = [];

$self->_MATCHIFYr($S, "regex_def", 
do {
my $C = $C->cursor_xact('ALT ||');
my $xact = $C->xact;
my @gather;
do {
push @gather, do {
if (my ($C) = ($C->ws)) {
do {
if (my ($C) = ($C->_BRACKETr(sub {
my $C=shift;
do {
if (my ($C) = ($C->_OPTr(sub { my $C=shift;
$C->_BRACKETr(sub {
my $C=shift;
do {
my @result = do {
my $trystate;
my ($tag, $try);
my @try;
my $relex;

my $fate;
my $x;
if ($fate = $C->{'_fate'} and $fate->[1] eq 'regex_def_02') {
$C->deb("Fate passed to regex_def_02: ", ::fatestr($fate)) if $::DEBUG & DEBUG::fates;
($C->{'_fate'}, $tag, $try) = @$fate;
@try = ($try);
$x = 'ALT regex_def_02';    # some outer ltm is controlling us
}
else {
$x = 'ALTLTM regex_def_02'; # we are top level ltm
}
my $C = $C->cursor_xact($x);
my $xact = $C->xact;

my @gather = ();
for (;;) {
if (not @try) {
$relex //= $C->cursor_fate('STD::P6', 'regex_def_02', $retree);
@try = $relex->($C, $trystate);
}
last unless @try;
$try = shift(@try) // next;

if (ref $try eq 'ARRAY') {
($C->{'_fate'}, $tag, $try) = @$try;	# next candidate fate
}

$C->deb("regex_def_02 trying $tag $try") if $::DEBUG & DEBUG::try_processing;
push @gather, ((
sub { my $C=shift;
do {
if (my ($C) = ($C->ws)) {
do {
if (my ($C) = ($C->_EXACT('&'))) {
do {
if (my ($C) = ($C->_OPTr(sub { my $C=shift;
$C->_SUBSUMEr(['deflongname'], sub {
my $C = shift;
$C->deflongname
})
}))) {
$C->ws;
}
else {
();
}
};
}
else {
();
}
};
}
else {
();
}
}
},
sub { my $C=shift;
do {
if (my ($C) = ($C->ws)) {
do {
if (my ($C) = ($C->_SUBSUMEr(['deflongname'], sub {
my $C = shift;
$C->deflongname
}))) {
$C->ws;
}
else {
();
}
};
}
else {
();
}
}
},
)[$try])->($C);
last if $xact->[-2];  # committed?
last if @gather;
}
@gather;
};
@result;
}

})
}))) {
do {
if (my ($C) = ($C->ws)) {
do {
if (my ($C) = ($C->newpad(1))) {
do {
if (my ($C) = ($C->ws)) {
do {
if (my ($C) = ($C->_STARr(sub { my $C=shift;
$C->_BRACKETr(sub {
my $C=shift;
do {
my @result = do {
my $trystate;
my ($tag, $try);
my @try;
my $relex;

my $fate;
my $x;
if ($fate = $C->{'_fate'} and $fate->[1] eq 'regex_def_03') {
$C->deb("Fate passed to regex_def_03: ", ::fatestr($fate)) if $::DEBUG & DEBUG::fates;
($C->{'_fate'}, $tag, $try) = @$fate;
@try = ($try);
$x = 'ALT regex_def_03';    # some outer ltm is controlling us
}
else {
$x = 'ALTLTM regex_def_03'; # we are top level ltm
}
my $C = $C->cursor_xact($x);
my $xact = $C->xact;

my @gather = ();
for (;;) {
if (not @try) {
$relex //= $C->cursor_fate('STD::P6', 'regex_def_03', $retree);
@try = $relex->($C, $trystate);
}
last unless @try;
$try = shift(@try) // next;

if (ref $try eq 'ARRAY') {
($C->{'_fate'}, $tag, $try) = @$try;	# next candidate fate
}

$C->deb("regex_def_03 trying $tag $try") if $::DEBUG & DEBUG::try_processing;
push @gather, ((
sub { my $C=shift;
do {
if (my ($C) = ($C->ws)) {
do {
if (my ($C) = ($C->_BRACKETr(sub {
my $C=shift;
do {
if (my ($C) = ($C->_OPTr(sub { my $C=shift;
$C->_EXACT(':')
}))) {
do {
if (my ($C) = ($C->_EXACT('('))) {
do {
if (my ($C) = ($C->ws)) {
do {
if (my ($C) = ($C->_SUBSUMEr(['signature'], sub {
my $C = shift;
$C->signature(1)
}))) {
do {
if (my ($C) = ($C->ws)) {
$C->_EXACT(')');
}
else {
();
}
};
}
else {
();
}
};
}
else {
();
}
};
}
else {
();
}
};
}
else {
();
}
}
}))) {
$C->ws;
}
else {
();
}
};
}
else {
();
}
}
},
sub { my $C=shift;
do {
if (my ($C) = ($C->ws)) {
do {
if (my ($C) = ($C->_SUBSUMEr(['trait'], sub {
my $C = shift;
$C->trait
}))) {
$C->ws;
}
else {
();
}
};
}
else {
();
}
}
},
)[$try])->($C);
last if $xact->[-2];  # committed?
last if @gather;
}
@gather;
};
@result;
}

})
}))) {
do {
if (my ($C) = ($C->ws)) {
do {
if (my ($C) = (scalar(do {
$::IN_DECL = ''; 
}, $C))) {
do {
if (my ($C) = ($C->ws)) {
do {
if (my ($C) = ($C->finishpad)) {
do {
if (my ($C) = ($C->ws)) {
do {
if (my ($C) = ($C->_SUBSUMEr(['regex_block'], sub {
my $C = shift;
$C->regex_block
}))) {
do {
if (my ($C) = ($C->getsig)) {
$C->getdecl;
}
else {
();
}
};
}
else {
();
}
};
}
else {
();
}
};
}
else {
();
}
};
}
else {
();
}
};
}
else {
();
}
};
}
else {
();
}
};
}
else {
();
}
};
}
else {
();
}
};
}
else {
();
}
};
}
else {
();
}
};
}
else {
();
}
}
}))) {
$C->ws;
}
else {
();
}
};
}
else {
();
}
}
}
or $xact->[-2] or
do {
push @gather, do {
if (my ($C) = ($C->ws)) {
do {
if (my ($C) = ($C->panic("Malformed regex"))) {
$C->ws;
}
else {
();
}
};
}
else {
();
}
}};
@gather;
}
);
}

##     rule macro_def ()
##          rule macro_def () {
##              :temp $*CURPAD;
##              :my $*IN_DECL = 'macro';
##              :my $*DECLARAND;
##              [
##                  [ '&'<deflongname>? | <deflongname> ]?
##                  <.newpad(1)>
##                  [ <multisig> | <trait> ]*
##                  <!{
##                      $*IN_DECL = '';
##                  }>
##                  { $*IN_DECL = ''; }
##                  <blockoid>:!s
##                  <.checkyada>
##                  <.getsig>
##                  <.getdecl>
##              ] || <.panic: "Malformed macro">
##          }

sub macro_def__PEEK { $_[0]->_AUTOLEXpeek('macro_def',$retree) }
sub macro_def {
no warnings 'recursion';
my $self = shift;
local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;
local $::CURPAD = $::CURPAD;
local $::IN_DECL = 'macro';
local $::DECLARAND;


my $C = $self->cursor_xact("RULE macro_def");
my $xact = $C->xact;
my $S = $C->{'_pos'};
$C->{'deflongname'} = [];
$C->{'multisig'} = [];
$C->{'trait'} = [];

$self->_MATCHIFYr($S, "macro_def", 
do {
my $C = $C->cursor_xact('ALT ||');
my $xact = $C->xact;
my @gather;
do {
push @gather, do {
if (my ($C) = ($C->ws)) {
do {
if (my ($C) = ($C->_BRACKETr(sub {
my $C=shift;
do {
if (my ($C) = ($C->_OPTr(sub { my $C=shift;
$C->_BRACKETr(sub {
my $C=shift;
do {
my @result = do {
my $trystate;
my ($tag, $try);
my @try;
my $relex;

my $fate;
my $x;
if ($fate = $C->{'_fate'} and $fate->[1] eq 'macro_def_02') {
$C->deb("Fate passed to macro_def_02: ", ::fatestr($fate)) if $::DEBUG & DEBUG::fates;
($C->{'_fate'}, $tag, $try) = @$fate;
@try = ($try);
$x = 'ALT macro_def_02';    # some outer ltm is controlling us
}
else {
$x = 'ALTLTM macro_def_02'; # we are top level ltm
}
my $C = $C->cursor_xact($x);
my $xact = $C->xact;

my @gather = ();
for (;;) {
if (not @try) {
$relex //= $C->cursor_fate('STD::P6', 'macro_def_02', $retree);
@try = $relex->($C, $trystate);
}
last unless @try;
$try = shift(@try) // next;

if (ref $try eq 'ARRAY') {
($C->{'_fate'}, $tag, $try) = @$try;	# next candidate fate
}

$C->deb("macro_def_02 trying $tag $try") if $::DEBUG & DEBUG::try_processing;
push @gather, ((
sub { my $C=shift;
do {
if (my ($C) = ($C->ws)) {
do {
if (my ($C) = ($C->_EXACT('&'))) {
do {
if (my ($C) = ($C->_OPTr(sub { my $C=shift;
$C->_SUBSUMEr(['deflongname'], sub {
my $C = shift;
$C->deflongname
})
}))) {
$C->ws;
}
else {
();
}
};
}
else {
();
}
};
}
else {
();
}
}
},
sub { my $C=shift;
do {
if (my ($C) = ($C->ws)) {
do {
if (my ($C) = ($C->_SUBSUMEr(['deflongname'], sub {
my $C = shift;
$C->deflongname
}))) {
$C->ws;
}
else {
();
}
};
}
else {
();
}
}
},
)[$try])->($C);
last if $xact->[-2];  # committed?
last if @gather;
}
@gather;
};
@result;
}

})
}))) {
do {
if (my ($C) = ($C->ws)) {
do {
if (my ($C) = ($C->newpad(1))) {
do {
if (my ($C) = ($C->ws)) {
do {
if (my ($C) = ($C->_STARr(sub { my $C=shift;
$C->_BRACKETr(sub {
my $C=shift;
do {
my @result = do {
my $trystate;
my ($tag, $try);
my @try;
my $relex;

my $fate;
my $x;
if ($fate = $C->{'_fate'} and $fate->[1] eq 'macro_def_03') {
$C->deb("Fate passed to macro_def_03: ", ::fatestr($fate)) if $::DEBUG & DEBUG::fates;
($C->{'_fate'}, $tag, $try) = @$fate;
@try = ($try);
$x = 'ALT macro_def_03';    # some outer ltm is controlling us
}
else {
$x = 'ALTLTM macro_def_03'; # we are top level ltm
}
my $C = $C->cursor_xact($x);
my $xact = $C->xact;

my @gather = ();
for (;;) {
if (not @try) {
$relex //= $C->cursor_fate('STD::P6', 'macro_def_03', $retree);
@try = $relex->($C, $trystate);
}
last unless @try;
$try = shift(@try) // next;

if (ref $try eq 'ARRAY') {
($C->{'_fate'}, $tag, $try) = @$try;	# next candidate fate
}

$C->deb("macro_def_03 trying $tag $try") if $::DEBUG & DEBUG::try_processing;
push @gather, ((
sub { my $C=shift;
do {
if (my ($C) = ($C->ws)) {
do {
if (my ($C) = ($C->_SUBSUMEr(['multisig'], sub {
my $C = shift;
$C->multisig
}))) {
$C->ws;
}
else {
();
}
};
}
else {
();
}
}
},
sub { my $C=shift;
do {
if (my ($C) = ($C->ws)) {
do {
if (my ($C) = ($C->_SUBSUMEr(['trait'], sub {
my $C = shift;
$C->trait
}))) {
$C->ws;
}
else {
();
}
};
}
else {
();
}
}
},
)[$try])->($C);
last if $xact->[-2];  # committed?
last if @gather;
}
@gather;
};
@result;
}

})
}))) {
do {
if (my ($C) = ($C->ws)) {
do {
if (my ($C) = ($C->_NOTBEFORE( sub { my $C=shift;
(($C) x !!do {

$::IN_DECL = '';

})
}))) {
do {
if (my ($C) = ($C->ws)) {
do {
if (my ($C) = (scalar(do {
$::IN_DECL = ''; 
}, $C))) {
do {
if (my ($C) = ($C->ws)) {
do {
if (my ($C) = ($C->_SUBSUMEr(['blockoid'], sub {
my $C = shift;
$C->blockoid
}))) {
do {
if (my ($C) = ($C->checkyada)) {
do {
if (my ($C) = ($C->getsig)) {
$C->getdecl;
}
else {
();
}
};
}
else {
();
}
};
}
else {
();
}
};
}
else {
();
}
};
}
else {
();
}
};
}
else {
();
}
};
}
else {
();
}
};
}
else {
();
}
};
}
else {
();
}
};
}
else {
();
}
};
}
else {
();
}
};
}
else {
();
}
};
}
else {
();
}
}
}))) {
$C->ws;
}
else {
();
}
};
}
else {
();
}
}
}
or $xact->[-2] or
do {
push @gather, do {
if (my ($C) = ($C->ws)) {
do {
if (my ($C) = ($C->panic("Malformed macro"))) {
$C->ws;
}
else {
();
}
};
}
else {
();
}
}};
@gather;
}
);
}

##     rule trait
##          rule trait {
##              :my $*IN_DECL = 0;
##              [
##              | <trait_mod>
##              | <colonpair>
##              ]
##          }

sub trait__PEEK { $_[0]->_AUTOLEXpeek('trait',$retree) }
sub trait {
no warnings 'recursion';
my $self = shift;
local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;
local $::IN_DECL = 0;


my $C = $self->cursor_xact("RULE trait");
my $xact = $C->xact;
my $S = $C->{'_pos'};

$self->_MATCHIFYr($S, "trait", 
do {
if (my ($C) = ($C->ws)) {
do {
if (my ($C) = ($C->_BRACKETr(sub {
my $C=shift;
do {
my @result = do {
my $trystate;
my ($tag, $try);
my @try;
my $relex;

my $fate;
my $x;
if ($fate = $C->{'_fate'} and $fate->[1] eq 'trait_01') {
$C->deb("Fate passed to trait_01: ", ::fatestr($fate)) if $::DEBUG & DEBUG::fates;
($C->{'_fate'}, $tag, $try) = @$fate;
@try = ($try);
$x = 'ALT trait_01';    # some outer ltm is controlling us
}
else {
$x = 'ALTLTM trait_01'; # we are top level ltm
}
my $C = $C->cursor_xact($x);
my $xact = $C->xact;

my @gather = ();
for (;;) {
if (not @try) {
$relex //= $C->cursor_fate('STD::P6', 'trait_01', $retree);
@try = $relex->($C, $trystate);
}
last unless @try;
$try = shift(@try) // next;

if (ref $try eq 'ARRAY') {
($C->{'_fate'}, $tag, $try) = @$try;	# next candidate fate
}

$C->deb("trait_01 trying $tag $try") if $::DEBUG & DEBUG::try_processing;
push @gather, ((
sub { my $C=shift;
do {
if (my ($C) = ($C->_SUBSUMEr(['trait_mod'], sub {
my $C = shift;
$C->trait_mod
}))) {
$C->ws;
}
else {
();
}
}
},
sub { my $C=shift;
do {
if (my ($C) = ($C->_SUBSUMEr(['colonpair'], sub {
my $C = shift;
$C->colonpair
}))) {
$C->ws;
}
else {
();
}
}
},
)[$try])->($C);
last if $xact->[-2];  # committed?
last if @gather;
}
@gather;
};
@result;
}

}))) {
$C->ws;
}
else {
();
}
};
}
else {
();
}
}
);
}

##     token trait_mod__S_131is (:$*endsym = 'spacey', :$*sym = 'is')
##          token trait_mod:is {
##              <sym>:s <longname><circumfix>?  # e.g. context<rw> and Array[Int]
##              {{
##                  if $*DECLARAND {
##                      my $traitname = $<longname>.Str;
##                      # XXX eventually will use multiple dispatch
##                      $*DECLARAND{$traitname} = self.gettrait($traitname, $<circumfix>);
##                  }
##              }}
##          }

sub trait_mod__S_131is__PEEK { $_[0]->_AUTOLEXpeek('trait_mod__S_131is',$retree) }
sub trait_mod__S_131is {
no warnings 'recursion';
my $self = shift;
local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;
my %args = @_;
local $::endsym = $args{endsym} // 'spacey';
local $::sym = $args{sym} // 'is';


my $C = $self->cursor_xact("RULE trait_mod__S_131is");
my $xact = $C->xact;
my $S = $C->{'_pos'};
$C->{'circumfix'} = [];
$C->{'sym'} = ref $sym ? join(' ', @$sym) : $sym;

$self->_MATCHIFYr($S, "trait_mod__S_131is", 
do {
if (my ($C) = ($C->_PATTERN(qr/\Gis/))) {
do {
if (my ($C) = ($C->spacey)) {
do {
if (my ($C) = ($C->ws)) {
do {
if (my ($C) = ($C->_SUBSUMEr(['longname'], sub {
my $C = shift;
$C->longname
}))) {
do {
if (my ($C) = ($C->_OPTr(sub { my $C=shift;
$C->_SUBSUMEr(['circumfix'], sub {
my $C = shift;
$C->circumfix
})
}))) {
do {
if (my ($C) = ($C->ws)) {
do {
if (my ($C) = (scalar(do {
my $M = $C; 
if ($::DECLARAND) {
my $traitname = $M->{'longname'}->Str;
# XXX eventually will use multiple dispatch
$::DECLARAND->{$traitname} = $self->gettrait($traitname, $M->{'circumfix'});
}
;
}, $C))) {
$C->ws;
}
else {
();
}
};
}
else {
();
}
};
}
else {
();
}
};
}
else {
();
}
};
}
else {
();
}
};
}
else {
();
}
};
}
else {
();
}
}
);
}
##     token trait_mod__S_132hides (:$*endsym = 'spacey', :$*sym = 'hides')
##          token trait_mod:hides {
##              <sym>:s <module_name>
##          }

sub trait_mod__S_132hides__PEEK { $_[0]->_AUTOLEXpeek('trait_mod__S_132hides',$retree) }
sub trait_mod__S_132hides {
no warnings 'recursion';
my $self = shift;
local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;
my %args = @_;
local $::endsym = $args{endsym} // 'spacey';
local $::sym = $args{sym} // 'hides';


my $C = $self->cursor_xact("RULE trait_mod__S_132hides");
my $xact = $C->xact;
my $S = $C->{'_pos'};
$C->{'sym'} = ref $sym ? join(' ', @$sym) : $sym;

$self->_MATCHIFYr($S, "trait_mod__S_132hides", 
do {
if (my ($C) = ($C->_PATTERN(qr/\Ghides/))) {
do {
if (my ($C) = ($C->spacey)) {
do {
if (my ($C) = ($C->ws)) {
do {
if (my ($C) = ($C->_SUBSUMEr(['module_name'], sub {
my $C = shift;
$C->module_name
}))) {
$C->ws;
}
else {
();
}
};
}
else {
();
}
};
}
else {
();
}
};
}
else {
();
}
}
);
}
##     token trait_mod__S_133does (:$*endsym = 'spacey', :$*sym = 'does')
##          token trait_mod:does {
##              :my $*PKGDECL ::= 'role';
##              <sym>:s <module_name>
##          }

sub trait_mod__S_133does__PEEK { $_[0]->_AUTOLEXpeek('trait_mod__S_133does',$retree) }
sub trait_mod__S_133does {
no warnings 'recursion';
my $self = shift;
local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;
my %args = @_;
local $::endsym = $args{endsym} // 'spacey';
local $::sym = $args{sym} // 'does';
local $::PKGDECL = 'role';


my $C = $self->cursor_xact("RULE trait_mod__S_133does");
my $xact = $C->xact;
my $S = $C->{'_pos'};
$C->{'sym'} = ref $sym ? join(' ', @$sym) : $sym;

$self->_MATCHIFYr($S, "trait_mod__S_133does", 
do {
if (my ($C) = ($C->_PATTERN(qr/\Gdoes/))) {
do {
if (my ($C) = ($C->spacey)) {
do {
if (my ($C) = ($C->ws)) {
do {
if (my ($C) = ($C->_SUBSUMEr(['module_name'], sub {
my $C = shift;
$C->module_name
}))) {
$C->ws;
}
else {
();
}
};
}
else {
();
}
};
}
else {
();
}
};
}
else {
();
}
}
);
}
##     token trait_mod__S_134will (:$*endsym = 'spacey', :$*sym = 'will')
##          token trait_mod:will {
##              <sym>:s <identifier> <pblock>
##          }

sub trait_mod__S_134will__PEEK { $_[0]->_AUTOLEXpeek('trait_mod__S_134will',$retree) }
sub trait_mod__S_134will {
no warnings 'recursion';
my $self = shift;
local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;
my %args = @_;
local $::endsym = $args{endsym} // 'spacey';
local $::sym = $args{sym} // 'will';


my $C = $self->cursor_xact("RULE trait_mod__S_134will");
my $xact = $C->xact;
my $S = $C->{'_pos'};
$C->{'sym'} = ref $sym ? join(' ', @$sym) : $sym;

$self->_MATCHIFYr($S, "trait_mod__S_134will", 
do {
if (my ($C) = ($C->_PATTERN(qr/\Gwill/))) {
do {
if (my ($C) = ($C->spacey)) {
do {
if (my ($C) = ($C->ws)) {
do {
if (my ($C) = ($C->_SUBSUMEr(['identifier'], sub {
my $C = shift;
$C->identifier
}))) {
do {
if (my ($C) = ($C->ws)) {
do {
if (my ($C) = ($C->_SUBSUMEr(['pblock'], sub {
my $C = shift;
$C->pblock
}))) {
$C->ws;
}
else {
();
}
};
}
else {
();
}
};
}
else {
();
}
};
}
else {
();
}
};
}
else {
();
}
};
}
else {
();
}
}
);
}

##     token trait_mod__S_135of (:$*endsym = 'spacey', :$*sym = 'of')
##          token trait_mod:of {
##              ['of'|'returns']:s <typename>
##              [ <?{ $*OFTYPE }> <.panic("Extra 'of' type; already declared as type " ~ $*OFTYPE.Str)> ]?
##              { $*OFTYPE = $<typename>; }
##          }

sub trait_mod__S_135of__PEEK { $_[0]->_AUTOLEXpeek('trait_mod__S_135of',$retree) }
sub trait_mod__S_135of {
no warnings 'recursion';
my $self = shift;
local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;
my %args = @_;
local $::endsym = $args{endsym} // 'spacey';
local $::sym = $args{sym} // 'of';


my $C = $self->cursor_xact("RULE trait_mod__S_135of");
my $xact = $C->xact;
my $S = $C->{'_pos'};
$C->{'sym'} = ref $sym ? join(' ', @$sym) : $sym;

$self->_MATCHIFYr($S, "trait_mod__S_135of", 
do {
if (my ($C) = ($C->_BRACKETr(sub {
my $C=shift;
do {
my @result = do {
my $trystate;
my ($tag, $try);
my @try;
my $relex;

my $fate;
my $x;
if ($fate = $C->{'_fate'} and $fate->[1] eq 'trait_mod__S_135of_01') {
$C->deb("Fate passed to trait_mod__S_135of_01: ", ::fatestr($fate)) if $::DEBUG & DEBUG::fates;
($C->{'_fate'}, $tag, $try) = @$fate;
@try = ($try);
$x = 'ALT trait_mod__S_135of_01';    # some outer ltm is controlling us
}
else {
$x = 'ALTLTM trait_mod__S_135of_01'; # we are top level ltm
}
my $C = $C->cursor_xact($x);
my $xact = $C->xact;

my @gather = ();
for (;;) {
if (not @try) {
$relex //= $C->cursor_fate('STD::P6', 'trait_mod__S_135of_01', $retree);
@try = $relex->($C, $trystate);
}
last unless @try;
$try = shift(@try) // next;

if (ref $try eq 'ARRAY') {
($C->{'_fate'}, $tag, $try) = @$try;	# next candidate fate
}

$C->deb("trait_mod__S_135of_01 trying $tag $try") if $::DEBUG & DEBUG::try_processing;
push @gather, ((
sub { my $C=shift;
$C->_EXACT('of')
},
sub { my $C=shift;
$C->_EXACT('returns')
},
)[$try])->($C);
last if $xact->[-2];  # committed?
last if @gather;
}
@gather;
};
@result;
}

}))) {
do {
if (my ($C) = ($C->ws)) {
do {
if (my ($C) = ($C->_SUBSUMEr(['typename'], sub {
my $C = shift;
$C->typename
}))) {
do {
if (my ($C) = ($C->ws)) {
do {
if (my ($C) = ($C->_OPTr(sub { my $C=shift;
$C->_BRACKETr(sub {
my $C=shift;
do {
if (my ($C) = ($C->ws)) {
do {
if (my ($C) = ($C->before( sub { my $C=shift;
(($C) x !!do {
$::OFTYPE 
})
}))) {
do {
if (my ($C) = ($C->ws)) {
do {
if (my ($C) = ($C->panic("Extra 'of' type; already declared as type " . $::OFTYPE->Str))) {
$C->ws;
}
else {
();
}
};
}
else {
();
}
};
}
else {
();
}
};
}
else {
();
}
}
})
}))) {
do {
if (my ($C) = ($C->ws)) {
do {
if (my ($C) = (scalar(do {
my $M = $C;  $::OFTYPE = $M->{'typename'}; ;
}, $C))) {
$C->ws;
}
else {
();
}
};
}
else {
();
}
};
}
else {
();
}
};
}
else {
();
}
};
}
else {
();
}
};
}
else {
();
}
};
}
else {
();
}
}
);
}
##     token trait_mod__S_136as (:$*endsym = 'spacey', :$*sym = 'as')
##          token trait_mod:as      { <sym>:s <typename> }

sub trait_mod__S_136as__PEEK { $_[0]->_AUTOLEXpeek('trait_mod__S_136as',$retree) }
sub trait_mod__S_136as {
no warnings 'recursion';
my $self = shift;
local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;
my %args = @_;
local $::endsym = $args{endsym} // 'spacey';
local $::sym = $args{sym} // 'as';


my $C = $self->cursor_xact("RULE trait_mod__S_136as");
my $xact = $C->xact;
my $S = $C->{'_pos'};
$C->{'sym'} = ref $sym ? join(' ', @$sym) : $sym;

$self->_MATCHIFYr($S, "trait_mod__S_136as", 
do {
if (my ($C) = ($C->_PATTERN(qr/\Gas/))) {
do {
if (my ($C) = ($C->spacey)) {
do {
if (my ($C) = ($C->ws)) {
do {
if (my ($C) = ($C->_SUBSUMEr(['typename'], sub {
my $C = shift;
$C->typename
}))) {
$C->ws;
}
else {
();
}
};
}
else {
();
}
};
}
else {
();
}
};
}
else {
();
}
}
);
}
##     token trait_mod__S_137handles (:$*endsym = 'spacey', :$*sym = 'handles')
##          token trait_mod:handles { <sym>:s <term> }

sub trait_mod__S_137handles__PEEK { $_[0]->_AUTOLEXpeek('trait_mod__S_137handles',$retree) }
sub trait_mod__S_137handles {
no warnings 'recursion';
my $self = shift;
local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;
my %args = @_;
local $::endsym = $args{endsym} // 'spacey';
local $::sym = $args{sym} // 'handles';


my $C = $self->cursor_xact("RULE trait_mod__S_137handles");
my $xact = $C->xact;
my $S = $C->{'_pos'};
$C->{'sym'} = ref $sym ? join(' ', @$sym) : $sym;

$self->_MATCHIFYr($S, "trait_mod__S_137handles", 
do {
if (my ($C) = ($C->_PATTERN(qr/\Ghandles/))) {
do {
if (my ($C) = ($C->spacey)) {
do {
if (my ($C) = ($C->ws)) {
do {
if (my ($C) = ($C->_SUBSUMEr(['term'], sub {
my $C = shift;
$C->term
}))) {
$C->ws;
}
else {
();
}
};
}
else {
();
}
};
}
else {
();
}
};
}
else {
();
}
}
);
}

#########
# Nouns #
#########

# (for when you want to tell EXPR that infix already parsed the term)
##     token nullterm
##          token nullterm {
##              <?>
##          }

sub nullterm__PEEK { $_[0]->_AUTOLEXpeek('nullterm',$retree) }
sub nullterm {
no warnings 'recursion';
my $self = shift;
local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;


my $C = $self->cursor_xact("RULE nullterm");
my $xact = $C->xact;
my $S = $C->{'_pos'};

$self->_MATCHIFYr($S, "nullterm", 
$C->before( sub { my $C=shift;
$C
})
);
}

##     token nulltermish
##          token nulltermish {
##              :dba('null term')
##              [
##              | <?stdstopper>
##              | <term=.termish>
##                  {
##                      $.<PRE>  = $<term><PRE>:delete;
##                      $.<POST> = $<term><POST>:delete;
##                      $.<~CAPS> = $<term><~CAPS>;
##                  }
##              | <?>
##              ]
##          }

sub nulltermish__PEEK { $_[0]->_AUTOLEXpeek('nulltermish',$retree) }
sub nulltermish {
no warnings 'recursion';
my $self = shift;
local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;


my $C = $self->cursor_xact("RULE nulltermish");
my $xact = $C->xact;
my $S = $C->{'_pos'};

$self->_MATCHIFYr($S, "nulltermish", 
$C->_BRACKETr(sub {
my $C=shift;
do {
my @result = do {
my $trystate;
my ($tag, $try);
my @try;
my $relex;

my $fate;
my $x;
if ($fate = $C->{'_fate'} and $fate->[1] eq 'nulltermish_01') {
$C->deb("Fate passed to nulltermish_01: ", ::fatestr($fate)) if $::DEBUG & DEBUG::fates;
($C->{'_fate'}, $tag, $try) = @$fate;
@try = ($try);
$x = 'ALT nulltermish_01';    # some outer ltm is controlling us
}
else {
$x = 'ALTLTM nulltermish_01'; # we are top level ltm
}
my $C = $C->cursor_xact($x);
my $xact = $C->xact;

my @gather = ();
for (;;) {
if (not @try) {
$relex //= $C->cursor_fate('STD::P6', 'nulltermish_01', $retree);
@try = $relex->($C, $trystate);
}
last unless @try;
$try = shift(@try) // next;

if (ref $try eq 'ARRAY') {
($C->{'_fate'}, $tag, $try) = @$try;	# next candidate fate
}

$C->deb("nulltermish_01 trying $tag $try") if $::DEBUG & DEBUG::try_processing;
push @gather, ((
sub { my $C=shift;
$C->before( sub { my $C=shift;
$C->stdstopper
})
},
sub { my $C=shift;
do {
if (my ($C) = (  $C->_SUBSUMEr(['term'], sub {
my $C = shift;
$C->termish
}))) {
scalar(do {
my $M = $C; 
$C->{'PRE'}  = delete $M->{'term'}{'PRE'};
$C->{'POST'} = delete $M->{'term'}{'POST'};
$C->{'~CAPS'} = $M->{'term'}{'~CAPS'};
;
}, $C);
}
else {
();
}
}
},
sub { my $C=shift;
$C->before( sub { my $C=shift;
$C
})
},
)[$try])->($C);
last if $xact->[-2];  # committed?
last if @gather;
}
@gather;
};
@result;
}

})
);
}

##     token termish
##          token termish {
##              :my $*SCOPE = "";
##              :my $*OFTYPE;
##              :my $*VAR;
##              :dba('prefix or term')
##              [
##              | <PRE> [ <!{ my $p = $<PRE>; my @p = @$p; @p[*-1]<O><term> and $<term> = pop @$p }> <PRE> ]*
##                  [ <?{ $<term> }> || <term> || <.panic("Prefix requires an argument")> ]
##              | <term>
##              ]
##      
##              # also queue up any postfixes
##              :dba('postfix')
##              [
##              || <?{ $*QSIGIL }>
##                  [
##                  || <?{ $*QSIGIL eq '$' }> [ <POST>+! <?after <[ \] } > ) ]> > ]?
##                  ||                          <POST>+! <?after <[ \] } > ) ]> > 
##                  || { $*VAR = 0; }
##                  ]
##              || <!{ $*QSIGIL }>
##                  <POST>*
##              ]
##              {
##                  self.check_variable($*VAR) if $*VAR;
##                  $.<~CAPS> = $<term><~CAPS>;
##              }
##          }

sub termish__PEEK { $_[0]->_AUTOLEXpeek('termish',$retree) }
sub termish {
no warnings 'recursion';
my $self = shift;
local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;
local $::SCOPE = "";
local $::OFTYPE;
local $::VAR;


my $C = $self->cursor_xact("RULE termish");
my $xact = $C->xact;
my $S = $C->{'_pos'};
$C->{'PRE'} = [];
$C->{'POST'} = [];

$self->_MATCHIFY($S, "termish", 
Cursor::lazymap(sub {
my $C=$_[0];
Cursor::lazymap(sub {
my $C=$_[0];
scalar(do {
my $M = $C; 
$self->check_variable($::VAR) if $::VAR;
$C->{'~CAPS'} = $M->{'term'}{'~CAPS'};
;
}, $C)
}, $C->_BRACKET(sub {
my $C=shift;
do {
my $C = $C->cursor_xact('ALT ||');
my $xact = $C->xact;
my @gather;
do {
push @gather, Cursor::lazymap(sub {
my $C=$_[0];
$C->_BRACKET(sub {
my $C=shift;
do {
my $C = $C->cursor_xact('ALT ||');
my $xact = $C->xact;
my @gather;
do {
push @gather, Cursor::lazymap(sub {
my $C=$_[0];
$C->_OPTr(sub { my $C=shift;
$C->_BRACKET(sub {
my $C=shift;
Cursor::lazymap(sub {
my $C=$_[0];
$C->before( sub { my $C=shift;
$C->after(sub { my $C=shift;
$C->_PATTERN(qr/\G(?<=[\]}>)])/)
})
})
}, $C->_PLUSg(sub { my $C=shift;
$C->_SUBSUME(['POST'], sub {
my $C = shift;
$C->POST
})
}))
})
})
}, $C->before( sub { my $C=shift;
(($C) x !!do {
$::QSIGIL eq '$' 
})
}))
}
or $xact->[-2] or
do {
push @gather, Cursor::lazymap(sub {
my $C=$_[0];
$C->before( sub { my $C=shift;
$C->after(sub { my $C=shift;
$C->_PATTERN(qr/\G(?<=[\]}>)])/)
})
})
}, $C->_PLUSg(sub { my $C=shift;
$C->_SUBSUME(['POST'], sub {
my $C = shift;
$C->POST
})
}))
}
or $xact->[-2] or
do {
push @gather, scalar(do {
$::VAR = 0; 
}, $C)};
@gather;
}
})
}, $C->before( sub { my $C=shift;
(($C) x !!do {
$::QSIGIL 
})
}))
}
or $xact->[-2] or
do {
push @gather, Cursor::lazymap(sub {
my $C=$_[0];
$C->_STARr(sub { my $C=shift;
$C->_SUBSUME(['POST'], sub {
my $C = shift;
$C->POST
})
})
}, $C->_NOTBEFORE( sub { my $C=shift;
(($C) x !!do {
$::QSIGIL 
})
}))};
@gather;
}
}))
}, $C->_BRACKET(sub {
my $C=shift;
do {
my @result = do {
my $trystate;
my ($tag, $try);
my @try;
my $relex;

my $fate;
my $x;
if ($fate = $C->{'_fate'} and $fate->[1] eq 'termish_01') {
$C->deb("Fate passed to termish_01: ", ::fatestr($fate)) if $::DEBUG & DEBUG::fates;
($C->{'_fate'}, $tag, $try) = @$fate;
@try = ($try);
$x = 'ALT termish_01';    # some outer ltm is controlling us
}
else {
$x = 'ALTLTM termish_01'; # we are top level ltm
}
my $C = $C->cursor_xact($x);
my $xact = $C->xact;

my @gather = ();
for (;;) {
if (not @try) {
$relex //= $C->cursor_fate('STD::P6', 'termish_01', $retree);
@try = $relex->($C, $trystate);
}
last unless @try;
$try = shift(@try) // next;

if (ref $try eq 'ARRAY') {
($C->{'_fate'}, $tag, $try) = @$try;	# next candidate fate
}

$C->deb("termish_01 trying $tag $try") if $::DEBUG & DEBUG::try_processing;
push @gather, ((
sub { my $C=shift;
Cursor::lazymap(sub {
my $C=$_[0];
Cursor::lazymap(sub {
my $C=$_[0];
$C->_BRACKET(sub {
my $C=shift;
do {
my $C = $C->cursor_xact('ALT ||');
my $xact = $C->xact;
my @gather;
do {
push @gather, $C->before( sub { my $C=shift;
(($C) x !!do {
my $M = $C;  $M->{'term'} ;
})
})
}
or $xact->[-2] or
do {
push @gather, $C->_SUBSUME(['term'], sub {
my $C = shift;
$C->term
})
}
or $xact->[-2] or
do {
push @gather, $C->panic("Prefix requires an argument")};
@gather;
}
})
}, $C->_STARr(sub { my $C=shift;
$C->_BRACKET(sub {
my $C=shift;
Cursor::lazymap(sub {
my $C=$_[0];
$C->_SUBSUME(['PRE'], sub {
my $C = shift;
$C->PRE
})
}, $C->_NOTBEFORE( sub { my $C=shift;
(($C) x !!do {
my $M = $C;  my $p = $M->{'PRE'}; my @p = @$p; $p[-1]{'O'}{'term'} and $M->{'term'} = pop @$p ;
})
}))
})
}))
}, $C->_SUBSUME(['PRE'], sub {
my $C = shift;
$C->PRE
}))
},
sub { my $C=shift;
$C->_SUBSUME(['term'], sub {
my $C = shift;
$C->term
})
},
)[$try])->($C);
last if $xact->[-2];  # committed?
last if @gather;
}
@gather;
};
@result;
}

}))
);
}

##     token term__S_138fatarrow (:$*sym = 'fatarrow')
##          token term:fatarrow           { <fatarrow> }

sub term__S_138fatarrow__PEEK { $_[0]->_AUTOLEXpeek('term__S_138fatarrow',$retree) }
sub term__S_138fatarrow {
no warnings 'recursion';
my $self = shift;
local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;
my %args = @_;
local $::sym = $args{sym} // 'fatarrow';


my $C = $self->cursor_xact("RULE term__S_138fatarrow");
my $xact = $C->xact;
my $S = $C->{'_pos'};
$C->{'sym'} = ref $sym ? join(' ', @$sym) : $sym;

$self->_MATCHIFYr($S, "term__S_138fatarrow", 
$C->_SUBSUMEr(['fatarrow'], sub {
my $C = shift;
$C->fatarrow
})
);
}
##     token term__S_139variable (:$*sym = 'variable')
##          token term:variable           { <variable> { $*VAR = $<variable> } }

sub term__S_139variable__PEEK { $_[0]->_AUTOLEXpeek('term__S_139variable',$retree) }
sub term__S_139variable {
no warnings 'recursion';
my $self = shift;
local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;
my %args = @_;
local $::sym = $args{sym} // 'variable';


my $C = $self->cursor_xact("RULE term__S_139variable");
my $xact = $C->xact;
my $S = $C->{'_pos'};
$C->{'sym'} = ref $sym ? join(' ', @$sym) : $sym;

$self->_MATCHIFYr($S, "term__S_139variable", 
do {
if (my ($C) = ($C->_SUBSUMEr(['variable'], sub {
my $C = shift;
$C->variable
}))) {
scalar(do {
my $M = $C;  $::VAR = $M->{'variable'} ;
}, $C);
}
else {
();
}
}
);
}
##     token term__S_140package_declarator (:$*sym = 'package_declarator')
##          token term:package_declarator { <package_declarator> }

sub term__S_140package_declarator__PEEK { $_[0]->_AUTOLEXpeek('term__S_140package_declarator',$retree) }
sub term__S_140package_declarator {
no warnings 'recursion';
my $self = shift;
local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;
my %args = @_;
local $::sym = $args{sym} // 'package_declarator';


my $C = $self->cursor_xact("RULE term__S_140package_declarator");
my $xact = $C->xact;
my $S = $C->{'_pos'};
$C->{'sym'} = ref $sym ? join(' ', @$sym) : $sym;

$self->_MATCHIFYr($S, "term__S_140package_declarator", 
$C->_SUBSUMEr(['package_declarator'], sub {
my $C = shift;
$C->package_declarator
})
);
}
##     token term__S_141scope_declarator (:$*sym = 'scope_declarator')
##          token term:scope_declarator   { <scope_declarator> }

sub term__S_141scope_declarator__PEEK { $_[0]->_AUTOLEXpeek('term__S_141scope_declarator',$retree) }
sub term__S_141scope_declarator {
no warnings 'recursion';
my $self = shift;
local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;
my %args = @_;
local $::sym = $args{sym} // 'scope_declarator';


my $C = $self->cursor_xact("RULE term__S_141scope_declarator");
my $xact = $C->xact;
my $S = $C->{'_pos'};
$C->{'sym'} = ref $sym ? join(' ', @$sym) : $sym;

$self->_MATCHIFYr($S, "term__S_141scope_declarator", 
$C->_SUBSUMEr(['scope_declarator'], sub {
my $C = shift;
$C->scope_declarator
})
);
}
##     token term__S_142multi_declarator (:$*sym = 'multi_declarator')
##          token term:multi_declarator   { <?before 'multi'|'proto'|'only'> <multi_declarator> }

sub term__S_142multi_declarator__PEEK { $_[0]->_AUTOLEXpeek('term__S_142multi_declarator',$retree) }
sub term__S_142multi_declarator {
no warnings 'recursion';
my $self = shift;
local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;
my %args = @_;
local $::sym = $args{sym} // 'multi_declarator';


my $C = $self->cursor_xact("RULE term__S_142multi_declarator");
my $xact = $C->xact;
my $S = $C->{'_pos'};
$C->{'sym'} = ref $sym ? join(' ', @$sym) : $sym;

$self->_MATCHIFYr($S, "term__S_142multi_declarator", 
do {
if (my ($C) = ($C->before(sub { my $C=shift;
do {
my @result = do {
my $trystate;
my ($tag, $try);
my @try;
my $relex;

my $fate;
my $x;
if ($fate = $C->{'_fate'} and $fate->[1] eq 'term__S_142multi_declarator_01') {
$C->deb("Fate passed to term__S_142multi_declarator_01: ", ::fatestr($fate)) if $::DEBUG & DEBUG::fates;
($C->{'_fate'}, $tag, $try) = @$fate;
@try = ($try);
$x = 'ALT term__S_142multi_declarator_01';    # some outer ltm is controlling us
}
else {
$x = 'ALTLTM term__S_142multi_declarator_01'; # we are top level ltm
}
my $C = $C->cursor_xact($x);
my $xact = $C->xact;

my @gather = ();
for (;;) {
if (not @try) {
$relex //= $C->cursor_fate('STD::P6', 'term__S_142multi_declarator_01', $retree);
@try = $relex->($C, $trystate);
}
last unless @try;
$try = shift(@try) // next;

if (ref $try eq 'ARRAY') {
($C->{'_fate'}, $tag, $try) = @$try;	# next candidate fate
}

$C->deb("term__S_142multi_declarator_01 trying $tag $try") if $::DEBUG & DEBUG::try_processing;
push @gather, ((
sub { my $C=shift;
$C->_EXACT('multi')
},
sub { my $C=shift;
$C->_EXACT('proto')
},
sub { my $C=shift;
$C->_EXACT('only')
},
)[$try])->($C);
last if $xact->[-2];  # committed?
last if @gather;
}
@gather;
};
@result;
}

}))) {
$C->_SUBSUMEr(['multi_declarator'], sub {
my $C = shift;
$C->multi_declarator
});
}
else {
();
}
}
);
}
##     token term__S_143routine_declarator (:$*sym = 'routine_declarator')
##          token term:routine_declarator { <routine_declarator> }

sub term__S_143routine_declarator__PEEK { $_[0]->_AUTOLEXpeek('term__S_143routine_declarator',$retree) }
sub term__S_143routine_declarator {
no warnings 'recursion';
my $self = shift;
local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;
my %args = @_;
local $::sym = $args{sym} // 'routine_declarator';


my $C = $self->cursor_xact("RULE term__S_143routine_declarator");
my $xact = $C->xact;
my $S = $C->{'_pos'};
$C->{'sym'} = ref $sym ? join(' ', @$sym) : $sym;

$self->_MATCHIFYr($S, "term__S_143routine_declarator", 
$C->_SUBSUMEr(['routine_declarator'], sub {
my $C = shift;
$C->routine_declarator
})
);
}
##     token term__S_144regex_declarator (:$*sym = 'regex_declarator')
##          token term:regex_declarator   { <regex_declarator> }

sub term__S_144regex_declarator__PEEK { $_[0]->_AUTOLEXpeek('term__S_144regex_declarator',$retree) }
sub term__S_144regex_declarator {
no warnings 'recursion';
my $self = shift;
local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;
my %args = @_;
local $::sym = $args{sym} // 'regex_declarator';


my $C = $self->cursor_xact("RULE term__S_144regex_declarator");
my $xact = $C->xact;
my $S = $C->{'_pos'};
$C->{'sym'} = ref $sym ? join(' ', @$sym) : $sym;

$self->_MATCHIFYr($S, "term__S_144regex_declarator", 
$C->_SUBSUMEr(['regex_declarator'], sub {
my $C = shift;
$C->regex_declarator
})
);
}
##     token term__S_145type_declarator (:$*sym = 'type_declarator')
##          token term:type_declarator    { <type_declarator> }

sub term__S_145type_declarator__PEEK { $_[0]->_AUTOLEXpeek('term__S_145type_declarator',$retree) }
sub term__S_145type_declarator {
no warnings 'recursion';
my $self = shift;
local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;
my %args = @_;
local $::sym = $args{sym} // 'type_declarator';


my $C = $self->cursor_xact("RULE term__S_145type_declarator");
my $xact = $C->xact;
my $S = $C->{'_pos'};
$C->{'sym'} = ref $sym ? join(' ', @$sym) : $sym;

$self->_MATCHIFYr($S, "term__S_145type_declarator", 
$C->_SUBSUMEr(['type_declarator'], sub {
my $C = shift;
$C->type_declarator
})
);
}
##     token term__S_146circumfix (:$*sym = 'circumfix')
##          token term:circumfix          { <circumfix> }

sub term__S_146circumfix__PEEK { $_[0]->_AUTOLEXpeek('term__S_146circumfix',$retree) }
sub term__S_146circumfix {
no warnings 'recursion';
my $self = shift;
local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;
my %args = @_;
local $::sym = $args{sym} // 'circumfix';


my $C = $self->cursor_xact("RULE term__S_146circumfix");
my $xact = $C->xact;
my $S = $C->{'_pos'};
$C->{'sym'} = ref $sym ? join(' ', @$sym) : $sym;

$self->_MATCHIFYr($S, "term__S_146circumfix", 
$C->_SUBSUMEr(['circumfix'], sub {
my $C = shift;
$C->circumfix
})
);
}
##     token term__S_147dotty (:$*sym = 'dotty')
##          token term:dotty              { <dotty> }

sub term__S_147dotty__PEEK { $_[0]->_AUTOLEXpeek('term__S_147dotty',$retree) }
sub term__S_147dotty {
no warnings 'recursion';
my $self = shift;
local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;
my %args = @_;
local $::sym = $args{sym} // 'dotty';


my $C = $self->cursor_xact("RULE term__S_147dotty");
my $xact = $C->xact;
my $S = $C->{'_pos'};
$C->{'sym'} = ref $sym ? join(' ', @$sym) : $sym;

$self->_MATCHIFYr($S, "term__S_147dotty", 
$C->_SUBSUMEr(['dotty'], sub {
my $C = shift;
$C->dotty
})
);
}
##     token term__S_148value (:$*sym = 'value')
##          token term:value              { <value> }

sub term__S_148value__PEEK { $_[0]->_AUTOLEXpeek('term__S_148value',$retree) }
sub term__S_148value {
no warnings 'recursion';
my $self = shift;
local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;
my %args = @_;
local $::sym = $args{sym} // 'value';


my $C = $self->cursor_xact("RULE term__S_148value");
my $xact = $C->xact;
my $S = $C->{'_pos'};
$C->{'sym'} = ref $sym ? join(' ', @$sym) : $sym;

$self->_MATCHIFYr($S, "term__S_148value", 
$C->_SUBSUMEr(['value'], sub {
my $C = shift;
$C->value
})
);
}
##     token term__S_149capterm (:$*sym = 'capterm')
##          token term:capterm            { <capterm> }

sub term__S_149capterm__PEEK { $_[0]->_AUTOLEXpeek('term__S_149capterm',$retree) }
sub term__S_149capterm {
no warnings 'recursion';
my $self = shift;
local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;
my %args = @_;
local $::sym = $args{sym} // 'capterm';


my $C = $self->cursor_xact("RULE term__S_149capterm");
my $xact = $C->xact;
my $S = $C->{'_pos'};
$C->{'sym'} = ref $sym ? join(' ', @$sym) : $sym;

$self->_MATCHIFYr($S, "term__S_149capterm", 
$C->_SUBSUMEr(['capterm'], sub {
my $C = shift;
$C->capterm
})
);
}
##     token term__S_150sigterm (:$*sym = 'sigterm')
##          token term:sigterm            { <sigterm> }

sub term__S_150sigterm__PEEK { $_[0]->_AUTOLEXpeek('term__S_150sigterm',$retree) }
sub term__S_150sigterm {
no warnings 'recursion';
my $self = shift;
local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;
my %args = @_;
local $::sym = $args{sym} // 'sigterm';


my $C = $self->cursor_xact("RULE term__S_150sigterm");
my $xact = $C->xact;
my $S = $C->{'_pos'};
$C->{'sym'} = ref $sym ? join(' ', @$sym) : $sym;

$self->_MATCHIFYr($S, "term__S_150sigterm", 
$C->_SUBSUMEr(['sigterm'], sub {
my $C = shift;
$C->sigterm
})
);
}
##     token term__S_151statement_prefix (:$*sym = 'statement_prefix')
##          token term:statement_prefix   { <statement_prefix> }

sub term__S_151statement_prefix__PEEK { $_[0]->_AUTOLEXpeek('term__S_151statement_prefix',$retree) }
sub term__S_151statement_prefix {
no warnings 'recursion';
my $self = shift;
local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;
my %args = @_;
local $::sym = $args{sym} // 'statement_prefix';


my $C = $self->cursor_xact("RULE term__S_151statement_prefix");
my $xact = $C->xact;
my $S = $C->{'_pos'};
$C->{'sym'} = ref $sym ? join(' ', @$sym) : $sym;

$self->_MATCHIFYr($S, "term__S_151statement_prefix", 
$C->_SUBSUMEr(['statement_prefix'], sub {
my $C = shift;
$C->statement_prefix
})
);
}
##     token term__S_152colonpair (:$*sym = 'colonpair')
##          token term:colonpair          { [ <colonpair> <.ws> ]+ }

sub term__S_152colonpair__PEEK { $_[0]->_AUTOLEXpeek('term__S_152colonpair',$retree) }
sub term__S_152colonpair {
no warnings 'recursion';
my $self = shift;
local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;
my %args = @_;
local $::sym = $args{sym} // 'colonpair';


my $C = $self->cursor_xact("RULE term__S_152colonpair");
my $xact = $C->xact;
my $S = $C->{'_pos'};
$C->{'colonpair'} = [];
$C->{'sym'} = ref $sym ? join(' ', @$sym) : $sym;

$self->_MATCHIFYr($S, "term__S_152colonpair", 
$C->_PLUSr(sub { my $C=shift;
$C->_BRACKETr(sub {
my $C=shift;
do {
if (my ($C) = ($C->_SUBSUMEr(['colonpair'], sub {
my $C = shift;
$C->colonpair
}))) {
$C->ws;
}
else {
();
}
}
})
})
);
}

##     token fatarrow
##          token fatarrow {
##              <key=.identifier> \h* '=>' <.ws> <val=.EXPR(item %item_assignment)>
##          }

sub fatarrow__PEEK { $_[0]->_AUTOLEXpeek('fatarrow',$retree) }
sub fatarrow {
no warnings 'recursion';
my $self = shift;
local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;


my $C = $self->cursor_xact("RULE fatarrow");
my $xact = $C->xact;
my $S = $C->{'_pos'};

$self->_MATCHIFYr($S, "fatarrow", 
do {
if (my ($C) = (  $C->_SUBSUMEr(['key'], sub {
my $C = shift;
$C->identifier
}))) {
do {
if (my ($C) = ($C->_PATTERN(qr/\G((?:[\x20\t\r])*+)/))) {
do {
if (my ($C) = ($C->_EXACT('=>'))) {
do {
if (my ($C) = ($C->ws)) {
$C->_SUBSUMEr(['val'], sub {
my $C = shift;
$C->EXPR(\%item_assignment)
});
}
else {
();
}
};
}
else {
();
}
};
}
else {
();
}
};
}
else {
();
}
}
);
}

##     token colonpair
##          token colonpair {
##              :my $key;
##              :my $value;
##      
##              ':'
##              :dba('colon pair')
##              [
##              | '!' <identifier> [ <[ \[ \( \< \{ ]> <.panic: "Argument not allowed on negated pair"> ]?
##                  { $key = $<identifier>.Str; $value = 0; }
##              | $<num> = [\d+] <identifier> [ <[ \[ \( \< \{ ]> <.panic: "2nd argument not allowed on pair"> ]?
##              | <identifier>
##                  { $key = $<identifier>.Str; }
##                  [
##                  || <.unsp>? :dba('pair value') <circumfix> { $value = $<circumfix>; }
##                  || { $value = 1; }
##                  ]
##              | :dba('signature') '(' ~ ')' <fakesignature>
##              | <circumfix>
##                  { $key = ""; $value = $<circumfix>; }
##              | $<var> = (<sigil> {} <twigil>? <desigilname>)
##                  { $key = $<var><desigilname>.Str; $value = $<var>; }
##              ]
##              { $<k> = $key; $<v> = $value; }
##          }

sub colonpair__PEEK { $_[0]->_AUTOLEXpeek('colonpair',$retree) }
sub colonpair {
no warnings 'recursion';
my $self = shift;
local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;
my $key;
my $value;


my $C = $self->cursor_xact("RULE colonpair");
my $xact = $C->xact;
my $S = $C->{'_pos'};

$self->_MATCHIFYr($S, "colonpair", 
do {
if (my ($C) = ($C->_EXACT(':'))) {
do {
if (my ($C) = ($C->_BRACKETr(sub {
my $C=shift;
do {
my @result = do {
my $trystate;
my ($tag, $try);
my @try;
my $relex;

my $fate;
my $x;
if ($fate = $C->{'_fate'} and $fate->[1] eq 'colonpair_01') {
$C->deb("Fate passed to colonpair_01: ", ::fatestr($fate)) if $::DEBUG & DEBUG::fates;
($C->{'_fate'}, $tag, $try) = @$fate;
@try = ($try);
$x = 'ALT colonpair_01';    # some outer ltm is controlling us
}
else {
$x = 'ALTLTM colonpair_01'; # we are top level ltm
}
my $C = $C->cursor_xact($x);
my $xact = $C->xact;

my @gather = ();
for (;;) {
if (not @try) {
$relex //= $C->cursor_fate('STD::P6', 'colonpair_01', $retree);
@try = $relex->($C, $trystate);
}
last unless @try;
$try = shift(@try) // next;

if (ref $try eq 'ARRAY') {
($C->{'_fate'}, $tag, $try) = @$try;	# next candidate fate
}

$C->deb("colonpair_01 trying $tag $try") if $::DEBUG & DEBUG::try_processing;
push @gather, ((
sub { my $C=shift;
do {
if (my ($C) = ($C->_EXACT('!'))) {
do {
if (my ($C) = ($C->_SUBSUMEr(['identifier'], sub {
my $C = shift;
$C->identifier
}))) {
do {
if (my ($C) = ($C->_OPTr(sub { my $C=shift;
$C->_BRACKETr(sub {
my $C=shift;
do {
if (my ($C) = ($C->_PATTERN(qr/\G[\[\(\<\{]/))) {
$C->panic("Argument not allowed on negated pair");
}
else {
();
}
}
})
}))) {
scalar(do {
my $M = $C;  $key = $M->{'identifier'}->Str; $value = 0; ;
}, $C);
}
else {
();
}
};
}
else {
();
}
};
}
else {
();
}
}
},
sub { my $C=shift;
do {
if (my ($C) = (  $C->_SUBSUMEr(['num'], sub {
my $C = shift;
$C->_BRACKETr(sub {
my $C=shift;
$C->_PATTERN(qr/\G((?:\d)++)/)
})
}))) {
do {
if (my ($C) = ($C->_SUBSUMEr(['identifier'], sub {
my $C = shift;
$C->identifier
}))) {
$C->_OPTr(sub { my $C=shift;
$C->_BRACKETr(sub {
my $C=shift;
do {
if (my ($C) = ($C->_PATTERN(qr/\G[\[\(\<\{]/))) {
$C->panic("2nd argument not allowed on pair");
}
else {
();
}
}
})
});
}
else {
();
}
};
}
else {
();
}
}
},
sub { my $C=shift;
do {
if (my ($C) = ($C->_SUBSUMEr(['identifier'], sub {
my $C = shift;
$C->identifier
}))) {
do {
if (my ($C) = (scalar(do {
my $M = $C;  $key = $M->{'identifier'}->Str; ;
}, $C))) {
$C->_BRACKETr(sub {
my $C=shift;
do {
my $C = $C->cursor_xact('ALT ||');
my $xact = $C->xact;
my @gather;
do {
push @gather, do {
if (my ($C) = ($C->_OPTr(sub { my $C=shift;
$C->unsp
}))) {
do {
if (my ($C) = ($C->_SUBSUMEr(['circumfix'], sub {
my $C = shift;
$C->circumfix
}))) {
scalar(do {
my $M = $C;  $value = $M->{'circumfix'}; ;
}, $C);
}
else {
();
}
};
}
else {
();
}
}
}
or $xact->[-2] or
do {
push @gather, scalar(do {
$value = 1; 
}, $C)};
@gather;
}
});
}
else {
();
}
};
}
else {
();
}
}
},
sub { my $C=shift;
do {
if (my ($C) = ($C->_EXACT('('))) {
do {
if (my ($C) = (((local $::GOAL = ')' ), $C)[-1])) {
do {
if (my ($C) = ($C->_SUBSUMEr(['fakesignature'], sub {
my $C = shift;
$C->fakesignature
}))) {
$C->_BRACKETr(sub {
my $C=shift;
do {
my $C = $C->cursor_xact('ALT ||');
my $xact = $C->xact;
my @gather;
do {
push @gather, $C->_EXACT(')')
}
or $xact->[-2] or
do {
push @gather, $C->FAILGOAL(')' , 'signature')};
@gather;
}
});
}
else {
();
}
};
}
else {
();
}
};
}
else {
();
}
}
},
sub { my $C=shift;
do {
if (my ($C) = ($C->_SUBSUMEr(['circumfix'], sub {
my $C = shift;
$C->circumfix
}))) {
scalar(do {
my $M = $C;  $key = ""; $value = $M->{'circumfix'}; ;
}, $C);
}
else {
();
}
}
},
sub { my $C=shift;
do {
if (my ($C) = (  $C->_SUBSUMEr(['var'], sub {
my $C = shift;
do { $C->_PAREN( sub { my $C=shift;
do {
if (my ($C) = ($C->_SUBSUMEr(['sigil'], sub {
my $C = shift;
$C->sigil
}))) {
do {
if (my ($C) = (scalar(do {

}, $C))) {
do {
if (my ($C) = ($C->_OPTr(sub { my $C=shift;
$C->_SUBSUMEr(['twigil'], sub {
my $C = shift;
$C->twigil
})
}))) {
$C->_SUBSUMEr(['desigilname'], sub {
my $C = shift;
$C->desigilname
});
}
else {
();
}
};
}
else {
();
}
};
}
else {
();
}
}
})}
}))) {
scalar(do {
my $M = $C;  $key = $M->{'var'}{'desigilname'}->Str; $value = $M->{'var'}; ;
}, $C);
}
else {
();
}
}
},
)[$try])->($C);
last if $xact->[-2];  # committed?
last if @gather;
}
@gather;
};
@result;
}

}))) {
scalar(do {
my $M = $C;  $M->{'k'} = $key; $M->{'v'} = $value; ;
}, $C);
}
else {
();
}
};
}
else {
();
}
}
);
}

# Most of these special variable rules are there simply to catch old p5 brainos

##     token special_variable__S_153Dollar_a2_ (:$*sym = <$>)
##          token special_variable:sym<$> { <sym> }

sub special_variable__S_153Dollar_a2___PEEK { $_[0]->_AUTOLEXpeek('special_variable__S_153Dollar_a2_',$retree) }
sub special_variable__S_153Dollar_a2_ {
no warnings 'recursion';
my $self = shift;
local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;
my %args = @_;
local $::sym = $args{sym} // q($);


my $C = $self->cursor_xact("RULE special_variable__S_153Dollar_a2_");
my $xact = $C->xact;
my $S = $C->{'_pos'};
$C->{'sym'} = ref $sym ? join(' ', @$sym) : $sym;

$self->_MATCHIFYr($S, "special_variable__S_153Dollar_a2_", 
$C->_PATTERN(qr/\G\$/)
);
}

##     token special_variable__S_154DollarBang (:$*sym = <$!>)
##          token special_variable:sym<$!> { <sym> <!before \w> }

sub special_variable__S_154DollarBang__PEEK { $_[0]->_AUTOLEXpeek('special_variable__S_154DollarBang',$retree) }
sub special_variable__S_154DollarBang {
no warnings 'recursion';
my $self = shift;
local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;
my %args = @_;
local $::sym = $args{sym} // q($!);


my $C = $self->cursor_xact("RULE special_variable__S_154DollarBang");
my $xact = $C->xact;
my $S = $C->{'_pos'};
$C->{'sym'} = ref $sym ? join(' ', @$sym) : $sym;

$self->_MATCHIFYr($S, "special_variable__S_154DollarBang", 
do {
if (my ($C) = ($C->_PATTERN(qr/\G\$\!/))) {
$C->_NOTBEFORE( sub { my $C=shift;
$C->before(sub { my $C=shift;
$C->_PATTERN(qr/\G\w/)
})
});
}
else {
();
}
}
);
}

##     token special_variable__S_155DollarBangCur_Ly (:$*sym = <$!{ }>)
##          token special_variable:sym<$!{ }> {
##              ( '$!{' :: (.*?) '}' )
##              <.obs($0.Str ~ " variable", 'smart match against $!')>
##          }

sub special_variable__S_155DollarBangCur_Ly__PEEK { $_[0]->_AUTOLEXpeek('special_variable__S_155DollarBangCur_Ly',$retree) }
sub special_variable__S_155DollarBangCur_Ly {
no warnings 'recursion';
my $self = shift;
local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;
my %args = @_;
local $::sym = $args{sym} // [qw($!{ })];


my $C = $self->cursor_xact("RULE special_variable__S_155DollarBangCur_Ly");
my $xact = $C->xact;
my $S = $C->{'_pos'};
$C->{'sym'} = ref $sym ? join(' ', @$sym) : $sym;

$self->_MATCHIFY($S, "special_variable__S_155DollarBangCur_Ly", 
Cursor::lazymap(sub {
my $C=$_[0];
$C->obs($C->{'0'}->Str . " variable", 'smart match against $!')
},   $C->_SUBSUME(['0'], sub {
my $C = shift;
do { $C->_PAREN( sub { my $C=shift;
Cursor::lazymap(sub {
my $C=$_[0];
Cursor::lazymap(sub {
my $C=$_[0];
Cursor::lazymap(sub {
my $C=$_[0];
$C->_EXACT('}')
},   $C->_SUBSUME(['0'], sub {
my $C = shift;
do { $C->_PAREN( sub { my $C=shift;
$C->_SCANf()
})}
}))
}, $C->_COMMITLTM())
}, $C->_EXACT('$!{'))
})}
}))
);
}

##     token special_variable__S_156DollarSlash (:$*sym = <$/>)
##          token special_variable:sym<$/> {
##              <sym>
##              # XXX assuming nobody ever wants to assign $/ directly anymore...
##              [ <?before \h* '=' <![=]> >
##                  <.obs('$/ variable as input record separator',
##                       "the filehandle's :irs attribute")>
##              ]?
##          }

sub special_variable__S_156DollarSlash__PEEK { $_[0]->_AUTOLEXpeek('special_variable__S_156DollarSlash',$retree) }
sub special_variable__S_156DollarSlash {
no warnings 'recursion';
my $self = shift;
local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;
my %args = @_;
local $::sym = $args{sym} // q($/);


my $C = $self->cursor_xact("RULE special_variable__S_156DollarSlash");
my $xact = $C->xact;
my $S = $C->{'_pos'};
$C->{'sym'} = ref $sym ? join(' ', @$sym) : $sym;

$self->_MATCHIFYr($S, "special_variable__S_156DollarSlash", 
do {
if (my ($C) = ($C->_PATTERN(qr/\G\$\//))) {
$C->_OPTr(sub { my $C=shift;
$C->_BRACKETr(sub {
my $C=shift;
do {
if (my ($C) = ($C->before(sub { my $C=shift;
do {
if (my ($C) = ($C->_PATTERN(qr/\G((?:[\x20\t\r])*+)/))) {
do {
if (my ($C) = ($C->_EXACT('='))) {
$C->_NOTBEFORE( sub { my $C=shift;
$C->_PATTERN(qr/\G[=]/)
});
}
else {
();
}
};
}
else {
();
}
}
}))) {
$C->obs('$/ variable as input record separator',
"the filehandle's :irs attribute");
}
else {
();
}
}
})
});
}
else {
();
}
}
);
}

##     token special_variable__S_157DollarTilde (:$*sym = <$~>)
##          token special_variable:sym<$~> {
##              <sym> :: <?before \s | ',' | '=' | <terminator> >
##              <.obs('$~ variable', 'Form module')>
##          }

sub special_variable__S_157DollarTilde__PEEK { $_[0]->_AUTOLEXpeek('special_variable__S_157DollarTilde',$retree) }
sub special_variable__S_157DollarTilde {
no warnings 'recursion';
my $self = shift;
local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;
my %args = @_;
local $::sym = $args{sym} // q($~);


my $C = $self->cursor_xact("RULE special_variable__S_157DollarTilde");
my $xact = $C->xact;
my $S = $C->{'_pos'};
$C->{'sym'} = ref $sym ? join(' ', @$sym) : $sym;

$self->_MATCHIFYr($S, "special_variable__S_157DollarTilde", 
do {
if (my ($C) = ($C->_PATTERN(qr/\G\$\~/))) {
do {
if (my ($C) = ($C->_COMMITLTM())) {
do {
if (my ($C) = ($C->before(sub { my $C=shift;
do {
my @result = do {
my $trystate;
my ($tag, $try);
my @try;
my $relex;

my $fate;
my $x;
if ($fate = $C->{'_fate'} and $fate->[1] eq 'special_variable__S_157DollarTilde_01') {
$C->deb("Fate passed to special_variable__S_157DollarTilde_01: ", ::fatestr($fate)) if $::DEBUG & DEBUG::fates;
($C->{'_fate'}, $tag, $try) = @$fate;
@try = ($try);
$x = 'ALT special_variable__S_157DollarTilde_01';    # some outer ltm is controlling us
}
else {
$x = 'ALTLTM special_variable__S_157DollarTilde_01'; # we are top level ltm
}
my $C = $C->cursor_xact($x);
my $xact = $C->xact;

my @gather = ();
for (;;) {
if (not @try) {
$relex //= $C->cursor_fate('STD::P6', 'special_variable__S_157DollarTilde_01', $retree);
@try = $relex->($C, $trystate);
}
last unless @try;
$try = shift(@try) // next;

if (ref $try eq 'ARRAY') {
($C->{'_fate'}, $tag, $try) = @$try;	# next candidate fate
}

$C->deb("special_variable__S_157DollarTilde_01 trying $tag $try") if $::DEBUG & DEBUG::try_processing;
push @gather, ((
sub { my $C=shift;
$C->_PATTERN(qr/\G\s/)
},
sub { my $C=shift;
$C->_EXACT(',')
},
sub { my $C=shift;
$C->_EXACT('=')
},
sub { my $C=shift;
$C->_SUBSUMEr(['terminator'], sub {
my $C = shift;
$C->terminator
})
},
)[$try])->($C);
last if $xact->[-2];  # committed?
last if @gather;
}
@gather;
};
@result;
}

}))) {
$C->obs('$~ variable', 'Form module');
}
else {
();
}
};
}
else {
();
}
};
}
else {
();
}
}
);
}

##     token special_variable__S_158DollarGrave (:$*sym = <$`>)
##          token special_variable:sym<$`> {
##              <sym> :: <?before \s | ',' | <terminator> >
##              <.obs('$` variable', 'explicit pattern before <(')>
##          }

sub special_variable__S_158DollarGrave__PEEK { $_[0]->_AUTOLEXpeek('special_variable__S_158DollarGrave',$retree) }
sub special_variable__S_158DollarGrave {
no warnings 'recursion';
my $self = shift;
local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;
my %args = @_;
local $::sym = $args{sym} // q($`);


my $C = $self->cursor_xact("RULE special_variable__S_158DollarGrave");
my $xact = $C->xact;
my $S = $C->{'_pos'};
$C->{'sym'} = ref $sym ? join(' ', @$sym) : $sym;

$self->_MATCHIFYr($S, "special_variable__S_158DollarGrave", 
do {
if (my ($C) = ($C->_PATTERN(qr/\G\$\`/))) {
do {
if (my ($C) = ($C->_COMMITLTM())) {
do {
if (my ($C) = ($C->before(sub { my $C=shift;
do {
my @result = do {
my $trystate;
my ($tag, $try);
my @try;
my $relex;

my $fate;
my $x;
if ($fate = $C->{'_fate'} and $fate->[1] eq 'special_variable__S_158DollarGrave_01') {
$C->deb("Fate passed to special_variable__S_158DollarGrave_01: ", ::fatestr($fate)) if $::DEBUG & DEBUG::fates;
($C->{'_fate'}, $tag, $try) = @$fate;
@try = ($try);
$x = 'ALT special_variable__S_158DollarGrave_01';    # some outer ltm is controlling us
}
else {
$x = 'ALTLTM special_variable__S_158DollarGrave_01'; # we are top level ltm
}
my $C = $C->cursor_xact($x);
my $xact = $C->xact;

my @gather = ();
for (;;) {
if (not @try) {
$relex //= $C->cursor_fate('STD::P6', 'special_variable__S_158DollarGrave_01', $retree);
@try = $relex->($C, $trystate);
}
last unless @try;
$try = shift(@try) // next;

if (ref $try eq 'ARRAY') {
($C->{'_fate'}, $tag, $try) = @$try;	# next candidate fate
}

$C->deb("special_variable__S_158DollarGrave_01 trying $tag $try") if $::DEBUG & DEBUG::try_processing;
push @gather, ((
sub { my $C=shift;
$C->_PATTERN(qr/\G\s/)
},
sub { my $C=shift;
$C->_EXACT(',')
},
sub { my $C=shift;
$C->_SUBSUMEr(['terminator'], sub {
my $C = shift;
$C->terminator
})
},
)[$try])->($C);
last if $xact->[-2];  # committed?
last if @gather;
}
@gather;
};
@result;
}

}))) {
$C->obs('$` variable', 'explicit pattern before <(');
}
else {
();
}
};
}
else {
();
}
};
}
else {
();
}
}
);
}

##     token special_variable__S_159DollarAt (:$*sym = <$@>)
##          token special_variable:sym<$@> {
##              <sym> <?before \W> ::
##              <.obs('$@ variable as eval error', '$!')>
##          }

sub special_variable__S_159DollarAt__PEEK { $_[0]->_AUTOLEXpeek('special_variable__S_159DollarAt',$retree) }
sub special_variable__S_159DollarAt {
no warnings 'recursion';
my $self = shift;
local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;
my %args = @_;
local $::sym = $args{sym} // q($@);


my $C = $self->cursor_xact("RULE special_variable__S_159DollarAt");
my $xact = $C->xact;
my $S = $C->{'_pos'};
$C->{'sym'} = ref $sym ? join(' ', @$sym) : $sym;

$self->_MATCHIFYr($S, "special_variable__S_159DollarAt", 
do {
if (my ($C) = ($C->_PATTERN(qr/\G\$\@/))) {
do {
if (my ($C) = ($C->before(sub { my $C=shift;
$C->_NOTCHAR( sub { my $C=shift;
$C->_PATTERN(qr/\G\w/)
})
}))) {
do {
if (my ($C) = ($C->_COMMITLTM())) {
$C->obs('$@ variable as eval error', '$!');
}
else {
();
}
};
}
else {
();
}
};
}
else {
();
}
}
);
}

##     token special_variable__S_160DollarSharp (:$*sym = <$#>)
##          token special_variable:sym<$#> {
##              <sym> ::
##              [
##              || (\w+) <.obs("\$#" ~ $0.Str ~ " variable", '@' ~ $0.Str ~ '.end')>
##              || <.obs('$# variable', '.fmt')>
##              ]
##          }

sub special_variable__S_160DollarSharp__PEEK { $_[0]->_AUTOLEXpeek('special_variable__S_160DollarSharp',$retree) }
sub special_variable__S_160DollarSharp {
no warnings 'recursion';
my $self = shift;
local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;
my %args = @_;
local $::sym = $args{sym} // q($#);


my $C = $self->cursor_xact("RULE special_variable__S_160DollarSharp");
my $xact = $C->xact;
my $S = $C->{'_pos'};
$C->{'sym'} = ref $sym ? join(' ', @$sym) : $sym;

$self->_MATCHIFYr($S, "special_variable__S_160DollarSharp", 
do {
if (my ($C) = ($C->_PATTERN(qr/\G\$\#/))) {
do {
if (my ($C) = ($C->_COMMITLTM())) {
$C->_BRACKETr(sub {
my $C=shift;
do {
my $C = $C->cursor_xact('ALT ||');
my $xact = $C->xact;
my @gather;
do {
push @gather, do {
if (my ($C) = (  $C->_SUBSUMEr(['0'], sub {
my $C = shift;
do { $C->_PAREN( sub { my $C=shift;
$C->_PATTERN(qr/\G((?:\w)++)/)
})}
}))) {
$C->obs("\$#" . $C->{'0'}->Str . " variable", '@' . $C->{'0'}->Str . '.end');
}
else {
();
}
}
}
or $xact->[-2] or
do {
push @gather, $C->obs('$# variable', '.fmt')};
@gather;
}
});
}
else {
();
}
};
}
else {
();
}
}
);
}
##     token special_variable__S_161DollarDollar (:$*sym = <$$>)
##          token special_variable:sym<$$> {
##              <sym> <!alpha> :: <?before \s | ',' | <terminator> >
##              <.obs('$$ variable', '$*PID')>
##          }

sub special_variable__S_161DollarDollar__PEEK { $_[0]->_AUTOLEXpeek('special_variable__S_161DollarDollar',$retree) }
sub special_variable__S_161DollarDollar {
no warnings 'recursion';
my $self = shift;
local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;
my %args = @_;
local $::sym = $args{sym} // q($$);


my $C = $self->cursor_xact("RULE special_variable__S_161DollarDollar");
my $xact = $C->xact;
my $S = $C->{'_pos'};
$C->{'sym'} = ref $sym ? join(' ', @$sym) : $sym;

$self->_MATCHIFYr($S, "special_variable__S_161DollarDollar", 
do {
if (my ($C) = ($C->_PATTERN(qr/\G\$\$/))) {
do {
if (my ($C) = ($C->_NOTBEFORE( sub { my $C=shift;
$C->_PATTERN(qr/\G[_[:alpha:]]/)
}))) {
do {
if (my ($C) = ($C->_COMMITLTM())) {
do {
if (my ($C) = ($C->before(sub { my $C=shift;
do {
my @result = do {
my $trystate;
my ($tag, $try);
my @try;
my $relex;

my $fate;
my $x;
if ($fate = $C->{'_fate'} and $fate->[1] eq 'special_variable__S_161DollarDollar_01') {
$C->deb("Fate passed to special_variable__S_161DollarDollar_01: ", ::fatestr($fate)) if $::DEBUG & DEBUG::fates;
($C->{'_fate'}, $tag, $try) = @$fate;
@try = ($try);
$x = 'ALT special_variable__S_161DollarDollar_01';    # some outer ltm is controlling us
}
else {
$x = 'ALTLTM special_variable__S_161DollarDollar_01'; # we are top level ltm
}
my $C = $C->cursor_xact($x);
my $xact = $C->xact;

my @gather = ();
for (;;) {
if (not @try) {
$relex //= $C->cursor_fate('STD::P6', 'special_variable__S_161DollarDollar_01', $retree);
@try = $relex->($C, $trystate);
}
last unless @try;
$try = shift(@try) // next;

if (ref $try eq 'ARRAY') {
($C->{'_fate'}, $tag, $try) = @$try;	# next candidate fate
}

$C->deb("special_variable__S_161DollarDollar_01 trying $tag $try") if $::DEBUG & DEBUG::try_processing;
push @gather, ((
sub { my $C=shift;
$C->_PATTERN(qr/\G\s/)
},
sub { my $C=shift;
$C->_EXACT(',')
},
sub { my $C=shift;
$C->_SUBSUMEr(['terminator'], sub {
my $C = shift;
$C->terminator
})
},
)[$try])->($C);
last if $xact->[-2];  # committed?
last if @gather;
}
@gather;
};
@result;
}

}))) {
$C->obs('$$ variable', '$::PID');
}
else {
();
}
};
}
else {
();
}
};
}
else {
();
}
};
}
else {
();
}
}
);
}
##     token special_variable__S_162DollarPercent (:$*sym = <$%>)
##          token special_variable:sym<$%> {
##              <sym> <!before \w> <!sigil> ::
##              <.obs('$% variable', 'Form module')>
##          }

sub special_variable__S_162DollarPercent__PEEK { $_[0]->_AUTOLEXpeek('special_variable__S_162DollarPercent',$retree) }
sub special_variable__S_162DollarPercent {
no warnings 'recursion';
my $self = shift;
local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;
my %args = @_;
local $::sym = $args{sym} // q($%);


my $C = $self->cursor_xact("RULE special_variable__S_162DollarPercent");
my $xact = $C->xact;
my $S = $C->{'_pos'};
$C->{'sym'} = ref $sym ? join(' ', @$sym) : $sym;

$self->_MATCHIFYr($S, "special_variable__S_162DollarPercent", 
do {
if (my ($C) = ($C->_PATTERN(qr/\G\$\%/))) {
do {
if (my ($C) = ($C->_NOTBEFORE( sub { my $C=shift;
$C->before(sub { my $C=shift;
$C->_PATTERN(qr/\G\w/)
})
}))) {
do {
if (my ($C) = ($C->_NOTBEFORE( sub { my $C=shift;
$C->sigil
}))) {
do {
if (my ($C) = ($C->_COMMITLTM())) {
$C->obs('$% variable', 'Form module');
}
else {
();
}
};
}
else {
();
}
};
}
else {
();
}
};
}
else {
();
}
}
);
}

# Note: this works because placeholders are restricted to lowercase
##     token special_variable__S_163DollarCaretX (:$*sym = <$^X>)
##          token special_variable:sym<$^X> {
##              <sigil> '^' $<letter> = [<[A..Z]>] \W
##              <.obscaret($<sigil>.Str ~ '^' ~ $<letter>.Str, $<sigil>.Str, $<letter>.Str)>
##          }

sub special_variable__S_163DollarCaretX__PEEK { $_[0]->_AUTOLEXpeek('special_variable__S_163DollarCaretX',$retree) }
sub special_variable__S_163DollarCaretX {
no warnings 'recursion';
my $self = shift;
local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;
my %args = @_;
local $::sym = $args{sym} // q($^X);


my $C = $self->cursor_xact("RULE special_variable__S_163DollarCaretX");
my $xact = $C->xact;
my $S = $C->{'_pos'};
$C->{'sym'} = ref $sym ? join(' ', @$sym) : $sym;

$self->_MATCHIFYr($S, "special_variable__S_163DollarCaretX", 
do {
if (my ($C) = ($C->_SUBSUMEr(['sigil'], sub {
my $C = shift;
$C->sigil
}))) {
do {
if (my ($C) = ($C->_EXACT('^'))) {
do {
if (my ($C) = (  $C->_SUBSUMEr(['letter'], sub {
my $C = shift;
$C->_BRACKETr(sub {
my $C=shift;
$C->_PATTERN(qr/\G[A-Z]/)
})
}))) {
do {
if (my ($C) = ($C->_NOTCHAR( sub { my $C=shift;
$C->_PATTERN(qr/\G\w/)
}))) {
do { my $M = $C;
$C->obscaret($M->{'sigil'}->Str . '^' . $M->{'letter'}->Str, $M->{'sigil'}->Str, $M->{'letter'}->Str)
; };
}
else {
();
}
};
}
else {
();
}
};
}
else {
();
}
};
}
else {
();
}
}
);
}

##     token special_variable__S_164DollarCaret (:$*sym = <$^>)
##          token special_variable:sym<$^> {
##              <sym> :: <?before \s | ',' | '=' | <terminator> >
##              <.obs('$^ variable', 'Form module')>
##          }

sub special_variable__S_164DollarCaret__PEEK { $_[0]->_AUTOLEXpeek('special_variable__S_164DollarCaret',$retree) }
sub special_variable__S_164DollarCaret {
no warnings 'recursion';
my $self = shift;
local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;
my %args = @_;
local $::sym = $args{sym} // q($^);


my $C = $self->cursor_xact("RULE special_variable__S_164DollarCaret");
my $xact = $C->xact;
my $S = $C->{'_pos'};
$C->{'sym'} = ref $sym ? join(' ', @$sym) : $sym;

$self->_MATCHIFYr($S, "special_variable__S_164DollarCaret", 
do {
if (my ($C) = ($C->_PATTERN(qr/\G\$\^/))) {
do {
if (my ($C) = ($C->_COMMITLTM())) {
do {
if (my ($C) = ($C->before(sub { my $C=shift;
do {
my @result = do {
my $trystate;
my ($tag, $try);
my @try;
my $relex;

my $fate;
my $x;
if ($fate = $C->{'_fate'} and $fate->[1] eq 'special_variable__S_164DollarCaret_01') {
$C->deb("Fate passed to special_variable__S_164DollarCaret_01: ", ::fatestr($fate)) if $::DEBUG & DEBUG::fates;
($C->{'_fate'}, $tag, $try) = @$fate;
@try = ($try);
$x = 'ALT special_variable__S_164DollarCaret_01';    # some outer ltm is controlling us
}
else {
$x = 'ALTLTM special_variable__S_164DollarCaret_01'; # we are top level ltm
}
my $C = $C->cursor_xact($x);
my $xact = $C->xact;

my @gather = ();
for (;;) {
if (not @try) {
$relex //= $C->cursor_fate('STD::P6', 'special_variable__S_164DollarCaret_01', $retree);
@try = $relex->($C, $trystate);
}
last unless @try;
$try = shift(@try) // next;

if (ref $try eq 'ARRAY') {
($C->{'_fate'}, $tag, $try) = @$try;	# next candidate fate
}

$C->deb("special_variable__S_164DollarCaret_01 trying $tag $try") if $::DEBUG & DEBUG::try_processing;
push @gather, ((
sub { my $C=shift;
$C->_PATTERN(qr/\G\s/)
},
sub { my $C=shift;
$C->_EXACT(',')
},
sub { my $C=shift;
$C->_EXACT('=')
},
sub { my $C=shift;
$C->_SUBSUMEr(['terminator'], sub {
my $C = shift;
$C->terminator
})
},
)[$try])->($C);
last if $xact->[-2];  # committed?
last if @gather;
}
@gather;
};
@result;
}

}))) {
$C->obs('$^ variable', 'Form module');
}
else {
();
}
};
}
else {
();
}
};
}
else {
();
}
}
);
}

##     token special_variable__S_165DollarAmp (:$*sym = <$&>)
##          token special_variable:sym<$&> {
##              <sym> :: <?before \s | ',' | <terminator> >
##              <.obs('$& variable', '$/ or $()')>
##          }

sub special_variable__S_165DollarAmp__PEEK { $_[0]->_AUTOLEXpeek('special_variable__S_165DollarAmp',$retree) }
sub special_variable__S_165DollarAmp {
no warnings 'recursion';
my $self = shift;
local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;
my %args = @_;
local $::sym = $args{sym} // q($&);


my $C = $self->cursor_xact("RULE special_variable__S_165DollarAmp");
my $xact = $C->xact;
my $S = $C->{'_pos'};
$C->{'sym'} = ref $sym ? join(' ', @$sym) : $sym;

$self->_MATCHIFYr($S, "special_variable__S_165DollarAmp", 
do {
if (my ($C) = ($C->_PATTERN(qr/\G\$\&/))) {
do {
if (my ($C) = ($C->_COMMITLTM())) {
do {
if (my ($C) = ($C->before(sub { my $C=shift;
do {
my @result = do {
my $trystate;
my ($tag, $try);
my @try;
my $relex;

my $fate;
my $x;
if ($fate = $C->{'_fate'} and $fate->[1] eq 'special_variable__S_165DollarAmp_01') {
$C->deb("Fate passed to special_variable__S_165DollarAmp_01: ", ::fatestr($fate)) if $::DEBUG & DEBUG::fates;
($C->{'_fate'}, $tag, $try) = @$fate;
@try = ($try);
$x = 'ALT special_variable__S_165DollarAmp_01';    # some outer ltm is controlling us
}
else {
$x = 'ALTLTM special_variable__S_165DollarAmp_01'; # we are top level ltm
}
my $C = $C->cursor_xact($x);
my $xact = $C->xact;

my @gather = ();
for (;;) {
if (not @try) {
$relex //= $C->cursor_fate('STD::P6', 'special_variable__S_165DollarAmp_01', $retree);
@try = $relex->($C, $trystate);
}
last unless @try;
$try = shift(@try) // next;

if (ref $try eq 'ARRAY') {
($C->{'_fate'}, $tag, $try) = @$try;	# next candidate fate
}

$C->deb("special_variable__S_165DollarAmp_01 trying $tag $try") if $::DEBUG & DEBUG::try_processing;
push @gather, ((
sub { my $C=shift;
$C->_PATTERN(qr/\G\s/)
},
sub { my $C=shift;
$C->_EXACT(',')
},
sub { my $C=shift;
$C->_SUBSUMEr(['terminator'], sub {
my $C = shift;
$C->terminator
})
},
)[$try])->($C);
last if $xact->[-2];  # committed?
last if @gather;
}
@gather;
};
@result;
}

}))) {
$C->obs('$& variable', '$/ or $()');
}
else {
();
}
};
}
else {
();
}
};
}
else {
();
}
}
);
}

##     token special_variable__S_166DollarStar (:$*sym = <$*>)
##          token special_variable:sym<$*> {
##              <sym> :: <?before \s | ',' | '=' | <terminator> >
##              <.obs('$* variable', '^^ and $$')>
##          }

sub special_variable__S_166DollarStar__PEEK { $_[0]->_AUTOLEXpeek('special_variable__S_166DollarStar',$retree) }
sub special_variable__S_166DollarStar {
no warnings 'recursion';
my $self = shift;
local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;
my %args = @_;
local $::sym = $args{sym} // q($*);


my $C = $self->cursor_xact("RULE special_variable__S_166DollarStar");
my $xact = $C->xact;
my $S = $C->{'_pos'};
$C->{'sym'} = ref $sym ? join(' ', @$sym) : $sym;

$self->_MATCHIFYr($S, "special_variable__S_166DollarStar", 
do {
if (my ($C) = ($C->_PATTERN(qr/\G\$\*/))) {
do {
if (my ($C) = ($C->_COMMITLTM())) {
do {
if (my ($C) = ($C->before(sub { my $C=shift;
do {
my @result = do {
my $trystate;
my ($tag, $try);
my @try;
my $relex;

my $fate;
my $x;
if ($fate = $C->{'_fate'} and $fate->[1] eq 'special_variable__S_166DollarStar_01') {
$C->deb("Fate passed to special_variable__S_166DollarStar_01: ", ::fatestr($fate)) if $::DEBUG & DEBUG::fates;
($C->{'_fate'}, $tag, $try) = @$fate;
@try = ($try);
$x = 'ALT special_variable__S_166DollarStar_01';    # some outer ltm is controlling us
}
else {
$x = 'ALTLTM special_variable__S_166DollarStar_01'; # we are top level ltm
}
my $C = $C->cursor_xact($x);
my $xact = $C->xact;

my @gather = ();
for (;;) {
if (not @try) {
$relex //= $C->cursor_fate('STD::P6', 'special_variable__S_166DollarStar_01', $retree);
@try = $relex->($C, $trystate);
}
last unless @try;
$try = shift(@try) // next;

if (ref $try eq 'ARRAY') {
($C->{'_fate'}, $tag, $try) = @$try;	# next candidate fate
}

$C->deb("special_variable__S_166DollarStar_01 trying $tag $try") if $::DEBUG & DEBUG::try_processing;
push @gather, ((
sub { my $C=shift;
$C->_PATTERN(qr/\G\s/)
},
sub { my $C=shift;
$C->_EXACT(',')
},
sub { my $C=shift;
$C->_EXACT('=')
},
sub { my $C=shift;
$C->_SUBSUMEr(['terminator'], sub {
my $C = shift;
$C->terminator
})
},
)[$try])->($C);
last if $xact->[-2];  # committed?
last if @gather;
}
@gather;
};
@result;
}

}))) {
$C->obs('$* variable', '^^ and $$');
}
else {
();
}
};
}
else {
();
}
};
}
else {
();
}
}
);
}

##     token special_variable__S_167DollarThesis (:$*sym = <$)>)
##          token special_variable:sym<$)> {
##              <sym> <?{ $*GOAL ne ')' }> <?before \s | ',' | <terminator> >
##              <.obs('$) variable', '$*EGID')>
##          }

sub special_variable__S_167DollarThesis__PEEK { $_[0]->_AUTOLEXpeek('special_variable__S_167DollarThesis',$retree) }
sub special_variable__S_167DollarThesis {
no warnings 'recursion';
my $self = shift;
local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;
my %args = @_;
local $::sym = $args{sym} // q[$)];


my $C = $self->cursor_xact("RULE special_variable__S_167DollarThesis");
my $xact = $C->xact;
my $S = $C->{'_pos'};
$C->{'sym'} = ref $sym ? join(' ', @$sym) : $sym;

$self->_MATCHIFYr($S, "special_variable__S_167DollarThesis", 
do {
if (my ($C) = ($C->_PATTERN(qr/\G\$\)/))) {
do {
if (my ($C) = ($C->before( sub { my $C=shift;
(($C) x !!do {
$::GOAL ne ')' 
})
}))) {
do {
if (my ($C) = ($C->before(sub { my $C=shift;
do {
my @result = do {
my $trystate;
my ($tag, $try);
my @try;
my $relex;

my $fate;
my $x;
if ($fate = $C->{'_fate'} and $fate->[1] eq 'special_variable__S_167DollarThesis_01') {
$C->deb("Fate passed to special_variable__S_167DollarThesis_01: ", ::fatestr($fate)) if $::DEBUG & DEBUG::fates;
($C->{'_fate'}, $tag, $try) = @$fate;
@try = ($try);
$x = 'ALT special_variable__S_167DollarThesis_01';    # some outer ltm is controlling us
}
else {
$x = 'ALTLTM special_variable__S_167DollarThesis_01'; # we are top level ltm
}
my $C = $C->cursor_xact($x);
my $xact = $C->xact;

my @gather = ();
for (;;) {
if (not @try) {
$relex //= $C->cursor_fate('STD::P6', 'special_variable__S_167DollarThesis_01', $retree);
@try = $relex->($C, $trystate);
}
last unless @try;
$try = shift(@try) // next;

if (ref $try eq 'ARRAY') {
($C->{'_fate'}, $tag, $try) = @$try;	# next candidate fate
}

$C->deb("special_variable__S_167DollarThesis_01 trying $tag $try") if $::DEBUG & DEBUG::try_processing;
push @gather, ((
sub { my $C=shift;
$C->_PATTERN(qr/\G\s/)
},
sub { my $C=shift;
$C->_EXACT(',')
},
sub { my $C=shift;
$C->_SUBSUMEr(['terminator'], sub {
my $C = shift;
$C->terminator
})
},
)[$try])->($C);
last if $xact->[-2];  # committed?
last if @gather;
}
@gather;
};
@result;
}

}))) {
$C->obs('$) variable', '$::EGID');
}
else {
();
}
};
}
else {
();
}
};
}
else {
();
}
}
);
}

##     token special_variable__S_168DollarMinus (:$*sym = <$->)
##          token special_variable:sym<$-> {
##              <sym> :: <?before \s | ',' | '=' | <terminator> >
##              <.obs('$- variable', 'Form module')>
##          }

sub special_variable__S_168DollarMinus__PEEK { $_[0]->_AUTOLEXpeek('special_variable__S_168DollarMinus',$retree) }
sub special_variable__S_168DollarMinus {
no warnings 'recursion';
my $self = shift;
local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;
my %args = @_;
local $::sym = $args{sym} // q($-);


my $C = $self->cursor_xact("RULE special_variable__S_168DollarMinus");
my $xact = $C->xact;
my $S = $C->{'_pos'};
$C->{'sym'} = ref $sym ? join(' ', @$sym) : $sym;

$self->_MATCHIFYr($S, "special_variable__S_168DollarMinus", 
do {
if (my ($C) = ($C->_PATTERN(qr/\G\$\-/))) {
do {
if (my ($C) = ($C->_COMMITLTM())) {
do {
if (my ($C) = ($C->before(sub { my $C=shift;
do {
my @result = do {
my $trystate;
my ($tag, $try);
my @try;
my $relex;

my $fate;
my $x;
if ($fate = $C->{'_fate'} and $fate->[1] eq 'special_variable__S_168DollarMinus_01') {
$C->deb("Fate passed to special_variable__S_168DollarMinus_01: ", ::fatestr($fate)) if $::DEBUG & DEBUG::fates;
($C->{'_fate'}, $tag, $try) = @$fate;
@try = ($try);
$x = 'ALT special_variable__S_168DollarMinus_01';    # some outer ltm is controlling us
}
else {
$x = 'ALTLTM special_variable__S_168DollarMinus_01'; # we are top level ltm
}
my $C = $C->cursor_xact($x);
my $xact = $C->xact;

my @gather = ();
for (;;) {
if (not @try) {
$relex //= $C->cursor_fate('STD::P6', 'special_variable__S_168DollarMinus_01', $retree);
@try = $relex->($C, $trystate);
}
last unless @try;
$try = shift(@try) // next;

if (ref $try eq 'ARRAY') {
($C->{'_fate'}, $tag, $try) = @$try;	# next candidate fate
}

$C->deb("special_variable__S_168DollarMinus_01 trying $tag $try") if $::DEBUG & DEBUG::try_processing;
push @gather, ((
sub { my $C=shift;
$C->_PATTERN(qr/\G\s/)
},
sub { my $C=shift;
$C->_EXACT(',')
},
sub { my $C=shift;
$C->_EXACT('=')
},
sub { my $C=shift;
$C->_SUBSUMEr(['terminator'], sub {
my $C = shift;
$C->terminator
})
},
)[$try])->($C);
last if $xact->[-2];  # committed?
last if @gather;
}
@gather;
};
@result;
}

}))) {
$C->obs('$- variable', 'Form module');
}
else {
();
}
};
}
else {
();
}
};
}
else {
();
}
}
);
}

##     token special_variable__S_169DollarEqual (:$*sym = <$=>)
##          token special_variable:sym<$=> {
##              <sym> :: <?before \s | ',' | '=' | <terminator> >
##              <.obs('$= variable', 'Form module')>
##          }

sub special_variable__S_169DollarEqual__PEEK { $_[0]->_AUTOLEXpeek('special_variable__S_169DollarEqual',$retree) }
sub special_variable__S_169DollarEqual {
no warnings 'recursion';
my $self = shift;
local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;
my %args = @_;
local $::sym = $args{sym} // q($=);


my $C = $self->cursor_xact("RULE special_variable__S_169DollarEqual");
my $xact = $C->xact;
my $S = $C->{'_pos'};
$C->{'sym'} = ref $sym ? join(' ', @$sym) : $sym;

$self->_MATCHIFYr($S, "special_variable__S_169DollarEqual", 
do {
if (my ($C) = ($C->_PATTERN(qr/\G\$\=/))) {
do {
if (my ($C) = ($C->_COMMITLTM())) {
do {
if (my ($C) = ($C->before(sub { my $C=shift;
do {
my @result = do {
my $trystate;
my ($tag, $try);
my @try;
my $relex;

my $fate;
my $x;
if ($fate = $C->{'_fate'} and $fate->[1] eq 'special_variable__S_169DollarEqual_01') {
$C->deb("Fate passed to special_variable__S_169DollarEqual_01: ", ::fatestr($fate)) if $::DEBUG & DEBUG::fates;
($C->{'_fate'}, $tag, $try) = @$fate;
@try = ($try);
$x = 'ALT special_variable__S_169DollarEqual_01';    # some outer ltm is controlling us
}
else {
$x = 'ALTLTM special_variable__S_169DollarEqual_01'; # we are top level ltm
}
my $C = $C->cursor_xact($x);
my $xact = $C->xact;

my @gather = ();
for (;;) {
if (not @try) {
$relex //= $C->cursor_fate('STD::P6', 'special_variable__S_169DollarEqual_01', $retree);
@try = $relex->($C, $trystate);
}
last unless @try;
$try = shift(@try) // next;

if (ref $try eq 'ARRAY') {
($C->{'_fate'}, $tag, $try) = @$try;	# next candidate fate
}

$C->deb("special_variable__S_169DollarEqual_01 trying $tag $try") if $::DEBUG & DEBUG::try_processing;
push @gather, ((
sub { my $C=shift;
$C->_PATTERN(qr/\G\s/)
},
sub { my $C=shift;
$C->_EXACT(',')
},
sub { my $C=shift;
$C->_EXACT('=')
},
sub { my $C=shift;
$C->_SUBSUMEr(['terminator'], sub {
my $C = shift;
$C->terminator
})
},
)[$try])->($C);
last if $xact->[-2];  # committed?
last if @gather;
}
@gather;
};
@result;
}

}))) {
$C->obs('$= variable', 'Form module');
}
else {
();
}
};
}
else {
();
}
};
}
else {
();
}
}
);
}

##     token special_variable__S_170AtPlus (:$*sym = <@+>)
##          token special_variable:sym<@+> {
##              <sym> :: <?before \s | ',' | <terminator> >
##              <.obs('@+ variable', '.to method')>
##          }

sub special_variable__S_170AtPlus__PEEK { $_[0]->_AUTOLEXpeek('special_variable__S_170AtPlus',$retree) }
sub special_variable__S_170AtPlus {
no warnings 'recursion';
my $self = shift;
local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;
my %args = @_;
local $::sym = $args{sym} // q(@+);


my $C = $self->cursor_xact("RULE special_variable__S_170AtPlus");
my $xact = $C->xact;
my $S = $C->{'_pos'};
$C->{'sym'} = ref $sym ? join(' ', @$sym) : $sym;

$self->_MATCHIFYr($S, "special_variable__S_170AtPlus", 
do {
if (my ($C) = ($C->_PATTERN(qr/\G\@\+/))) {
do {
if (my ($C) = ($C->_COMMITLTM())) {
do {
if (my ($C) = ($C->before(sub { my $C=shift;
do {
my @result = do {
my $trystate;
my ($tag, $try);
my @try;
my $relex;

my $fate;
my $x;
if ($fate = $C->{'_fate'} and $fate->[1] eq 'special_variable__S_170AtPlus_01') {
$C->deb("Fate passed to special_variable__S_170AtPlus_01: ", ::fatestr($fate)) if $::DEBUG & DEBUG::fates;
($C->{'_fate'}, $tag, $try) = @$fate;
@try = ($try);
$x = 'ALT special_variable__S_170AtPlus_01';    # some outer ltm is controlling us
}
else {
$x = 'ALTLTM special_variable__S_170AtPlus_01'; # we are top level ltm
}
my $C = $C->cursor_xact($x);
my $xact = $C->xact;

my @gather = ();
for (;;) {
if (not @try) {
$relex //= $C->cursor_fate('STD::P6', 'special_variable__S_170AtPlus_01', $retree);
@try = $relex->($C, $trystate);
}
last unless @try;
$try = shift(@try) // next;

if (ref $try eq 'ARRAY') {
($C->{'_fate'}, $tag, $try) = @$try;	# next candidate fate
}

$C->deb("special_variable__S_170AtPlus_01 trying $tag $try") if $::DEBUG & DEBUG::try_processing;
push @gather, ((
sub { my $C=shift;
$C->_PATTERN(qr/\G\s/)
},
sub { my $C=shift;
$C->_EXACT(',')
},
sub { my $C=shift;
$C->_SUBSUMEr(['terminator'], sub {
my $C = shift;
$C->terminator
})
},
)[$try])->($C);
last if $xact->[-2];  # committed?
last if @gather;
}
@gather;
};
@result;
}

}))) {
$C->obs('@+ variable', '.to method');
}
else {
();
}
};
}
else {
();
}
};
}
else {
();
}
}
);
}

##     token special_variable__S_171PercentPlus (:$*sym = <%+>)
##          token special_variable:sym<%+> {
##              <sym> :: <?before \s | ',' | <terminator> >
##              <.obs('%+ variable', '.to method')>
##          }

sub special_variable__S_171PercentPlus__PEEK { $_[0]->_AUTOLEXpeek('special_variable__S_171PercentPlus',$retree) }
sub special_variable__S_171PercentPlus {
no warnings 'recursion';
my $self = shift;
local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;
my %args = @_;
local $::sym = $args{sym} // q(%+);


my $C = $self->cursor_xact("RULE special_variable__S_171PercentPlus");
my $xact = $C->xact;
my $S = $C->{'_pos'};
$C->{'sym'} = ref $sym ? join(' ', @$sym) : $sym;

$self->_MATCHIFYr($S, "special_variable__S_171PercentPlus", 
do {
if (my ($C) = ($C->_PATTERN(qr/\G\%\+/))) {
do {
if (my ($C) = ($C->_COMMITLTM())) {
do {
if (my ($C) = ($C->before(sub { my $C=shift;
do {
my @result = do {
my $trystate;
my ($tag, $try);
my @try;
my $relex;

my $fate;
my $x;
if ($fate = $C->{'_fate'} and $fate->[1] eq 'special_variable__S_171PercentPlus_01') {
$C->deb("Fate passed to special_variable__S_171PercentPlus_01: ", ::fatestr($fate)) if $::DEBUG & DEBUG::fates;
($C->{'_fate'}, $tag, $try) = @$fate;
@try = ($try);
$x = 'ALT special_variable__S_171PercentPlus_01';    # some outer ltm is controlling us
}
else {
$x = 'ALTLTM special_variable__S_171PercentPlus_01'; # we are top level ltm
}
my $C = $C->cursor_xact($x);
my $xact = $C->xact;

my @gather = ();
for (;;) {
if (not @try) {
$relex //= $C->cursor_fate('STD::P6', 'special_variable__S_171PercentPlus_01', $retree);
@try = $relex->($C, $trystate);
}
last unless @try;
$try = shift(@try) // next;

if (ref $try eq 'ARRAY') {
($C->{'_fate'}, $tag, $try) = @$try;	# next candidate fate
}

$C->deb("special_variable__S_171PercentPlus_01 trying $tag $try") if $::DEBUG & DEBUG::try_processing;
push @gather, ((
sub { my $C=shift;
$C->_PATTERN(qr/\G\s/)
},
sub { my $C=shift;
$C->_EXACT(',')
},
sub { my $C=shift;
$C->_SUBSUMEr(['terminator'], sub {
my $C = shift;
$C->terminator
})
},
)[$try])->($C);
last if $xact->[-2];  # committed?
last if @gather;
}
@gather;
};
@result;
}

}))) {
$C->obs('%+ variable', '.to method');
}
else {
();
}
};
}
else {
();
}
};
}
else {
();
}
}
);
}

##     token special_variable__S_172DollarPlusBra_Ket (:$*sym = <$+[ ]>)
##          token special_variable:sym<$+[ ]> {
##              '$+['
##              <.obs('@+ variable', '.to method')>
##          }

sub special_variable__S_172DollarPlusBra_Ket__PEEK { $_[0]->_AUTOLEXpeek('special_variable__S_172DollarPlusBra_Ket',$retree) }
sub special_variable__S_172DollarPlusBra_Ket {
no warnings 'recursion';
my $self = shift;
local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;
my %args = @_;
local $::sym = $args{sym} // [qw($+[ ])];


my $C = $self->cursor_xact("RULE special_variable__S_172DollarPlusBra_Ket");
my $xact = $C->xact;
my $S = $C->{'_pos'};
$C->{'sym'} = ref $sym ? join(' ', @$sym) : $sym;

$self->_MATCHIFYr($S, "special_variable__S_172DollarPlusBra_Ket", 
do {
if (my ($C) = ($C->_EXACT('$+['))) {
$C->obs('@+ variable', '.to method');
}
else {
();
}
}
);
}

##     token special_variable__S_173AtPlusBra_Ket (:$*sym = <@+[ ]>)
##          token special_variable:sym<@+[ ]> {
##              '@+['
##              <.obs('@+ variable', '.to method')>
##          }

sub special_variable__S_173AtPlusBra_Ket__PEEK { $_[0]->_AUTOLEXpeek('special_variable__S_173AtPlusBra_Ket',$retree) }
sub special_variable__S_173AtPlusBra_Ket {
no warnings 'recursion';
my $self = shift;
local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;
my %args = @_;
local $::sym = $args{sym} // [qw(@+[ ])];


my $C = $self->cursor_xact("RULE special_variable__S_173AtPlusBra_Ket");
my $xact = $C->xact;
my $S = $C->{'_pos'};
$C->{'sym'} = ref $sym ? join(' ', @$sym) : $sym;

$self->_MATCHIFYr($S, "special_variable__S_173AtPlusBra_Ket", 
do {
if (my ($C) = ($C->_EXACT('@+['))) {
$C->obs('@+ variable', '.to method');
}
else {
();
}
}
);
}

##     token special_variable__S_174AtPlusCur_Ly (:$*sym = <@+{ }>)
##          token special_variable:sym<@+{ }> {
##              '@+{'
##              <.obs('%+ variable', '.to method')>
##          }

sub special_variable__S_174AtPlusCur_Ly__PEEK { $_[0]->_AUTOLEXpeek('special_variable__S_174AtPlusCur_Ly',$retree) }
sub special_variable__S_174AtPlusCur_Ly {
no warnings 'recursion';
my $self = shift;
local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;
my %args = @_;
local $::sym = $args{sym} // [qw(@+{ })];


my $C = $self->cursor_xact("RULE special_variable__S_174AtPlusCur_Ly");
my $xact = $C->xact;
my $S = $C->{'_pos'};
$C->{'sym'} = ref $sym ? join(' ', @$sym) : $sym;

$self->_MATCHIFYr($S, "special_variable__S_174AtPlusCur_Ly", 
do {
if (my ($C) = ($C->_EXACT('@+{'))) {
$C->obs('%+ variable', '.to method');
}
else {
();
}
}
);
}

##     token special_variable__S_175AtMinus (:$*sym = <@->)
##          token special_variable:sym<@-> {
##              <sym> :: <?before \s | ',' | <terminator> >
##              <.obs('@- variable', '.from method')>
##          }

sub special_variable__S_175AtMinus__PEEK { $_[0]->_AUTOLEXpeek('special_variable__S_175AtMinus',$retree) }
sub special_variable__S_175AtMinus {
no warnings 'recursion';
my $self = shift;
local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;
my %args = @_;
local $::sym = $args{sym} // q(@-);


my $C = $self->cursor_xact("RULE special_variable__S_175AtMinus");
my $xact = $C->xact;
my $S = $C->{'_pos'};
$C->{'sym'} = ref $sym ? join(' ', @$sym) : $sym;

$self->_MATCHIFYr($S, "special_variable__S_175AtMinus", 
do {
if (my ($C) = ($C->_PATTERN(qr/\G\@\-/))) {
do {
if (my ($C) = ($C->_COMMITLTM())) {
do {
if (my ($C) = ($C->before(sub { my $C=shift;
do {
my @result = do {
my $trystate;
my ($tag, $try);
my @try;
my $relex;

my $fate;
my $x;
if ($fate = $C->{'_fate'} and $fate->[1] eq 'special_variable__S_175AtMinus_01') {
$C->deb("Fate passed to special_variable__S_175AtMinus_01: ", ::fatestr($fate)) if $::DEBUG & DEBUG::fates;
($C->{'_fate'}, $tag, $try) = @$fate;
@try = ($try);
$x = 'ALT special_variable__S_175AtMinus_01';    # some outer ltm is controlling us
}
else {
$x = 'ALTLTM special_variable__S_175AtMinus_01'; # we are top level ltm
}
my $C = $C->cursor_xact($x);
my $xact = $C->xact;

my @gather = ();
for (;;) {
if (not @try) {
$relex //= $C->cursor_fate('STD::P6', 'special_variable__S_175AtMinus_01', $retree);
@try = $relex->($C, $trystate);
}
last unless @try;
$try = shift(@try) // next;

if (ref $try eq 'ARRAY') {
($C->{'_fate'}, $tag, $try) = @$try;	# next candidate fate
}

$C->deb("special_variable__S_175AtMinus_01 trying $tag $try") if $::DEBUG & DEBUG::try_processing;
push @gather, ((
sub { my $C=shift;
$C->_PATTERN(qr/\G\s/)
},
sub { my $C=shift;
$C->_EXACT(',')
},
sub { my $C=shift;
$C->_SUBSUMEr(['terminator'], sub {
my $C = shift;
$C->terminator
})
},
)[$try])->($C);
last if $xact->[-2];  # committed?
last if @gather;
}
@gather;
};
@result;
}

}))) {
$C->obs('@- variable', '.from method');
}
else {
();
}
};
}
else {
();
}
};
}
else {
();
}
}
);
}

##     token special_variable__S_176PercentMinus (:$*sym = <%->)
##          token special_variable:sym<%-> {
##              <sym> :: <?before \s | ',' | <terminator> >
##              <.obs('%- variable', '.from method')>
##          }

sub special_variable__S_176PercentMinus__PEEK { $_[0]->_AUTOLEXpeek('special_variable__S_176PercentMinus',$retree) }
sub special_variable__S_176PercentMinus {
no warnings 'recursion';
my $self = shift;
local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;
my %args = @_;
local $::sym = $args{sym} // q(%-);


my $C = $self->cursor_xact("RULE special_variable__S_176PercentMinus");
my $xact = $C->xact;
my $S = $C->{'_pos'};
$C->{'sym'} = ref $sym ? join(' ', @$sym) : $sym;

$self->_MATCHIFYr($S, "special_variable__S_176PercentMinus", 
do {
if (my ($C) = ($C->_PATTERN(qr/\G\%\-/))) {
do {
if (my ($C) = ($C->_COMMITLTM())) {
do {
if (my ($C) = ($C->before(sub { my $C=shift;
do {
my @result = do {
my $trystate;
my ($tag, $try);
my @try;
my $relex;

my $fate;
my $x;
if ($fate = $C->{'_fate'} and $fate->[1] eq 'special_variable__S_176PercentMinus_01') {
$C->deb("Fate passed to special_variable__S_176PercentMinus_01: ", ::fatestr($fate)) if $::DEBUG & DEBUG::fates;
($C->{'_fate'}, $tag, $try) = @$fate;
@try = ($try);
$x = 'ALT special_variable__S_176PercentMinus_01';    # some outer ltm is controlling us
}
else {
$x = 'ALTLTM special_variable__S_176PercentMinus_01'; # we are top level ltm
}
my $C = $C->cursor_xact($x);
my $xact = $C->xact;

my @gather = ();
for (;;) {
if (not @try) {
$relex //= $C->cursor_fate('STD::P6', 'special_variable__S_176PercentMinus_01', $retree);
@try = $relex->($C, $trystate);
}
last unless @try;
$try = shift(@try) // next;

if (ref $try eq 'ARRAY') {
($C->{'_fate'}, $tag, $try) = @$try;	# next candidate fate
}

$C->deb("special_variable__S_176PercentMinus_01 trying $tag $try") if $::DEBUG & DEBUG::try_processing;
push @gather, ((
sub { my $C=shift;
$C->_PATTERN(qr/\G\s/)
},
sub { my $C=shift;
$C->_EXACT(',')
},
sub { my $C=shift;
$C->_SUBSUMEr(['terminator'], sub {
my $C = shift;
$C->terminator
})
},
)[$try])->($C);
last if $xact->[-2];  # committed?
last if @gather;
}
@gather;
};
@result;
}

}))) {
$C->obs('%- variable', '.from method');
}
else {
();
}
};
}
else {
();
}
};
}
else {
();
}
}
);
}

##     token special_variable__S_177DollarMinusBra_Ket (:$*sym = <$-[ ]>)
##          token special_variable:sym<$-[ ]> {
##              '$-['
##              <.obs('@- variable', '.from method')>
##          }

sub special_variable__S_177DollarMinusBra_Ket__PEEK { $_[0]->_AUTOLEXpeek('special_variable__S_177DollarMinusBra_Ket',$retree) }
sub special_variable__S_177DollarMinusBra_Ket {
no warnings 'recursion';
my $self = shift;
local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;
my %args = @_;
local $::sym = $args{sym} // [qw($-[ ])];


my $C = $self->cursor_xact("RULE special_variable__S_177DollarMinusBra_Ket");
my $xact = $C->xact;
my $S = $C->{'_pos'};
$C->{'sym'} = ref $sym ? join(' ', @$sym) : $sym;

$self->_MATCHIFYr($S, "special_variable__S_177DollarMinusBra_Ket", 
do {
if (my ($C) = ($C->_EXACT('$-['))) {
$C->obs('@- variable', '.from method');
}
else {
();
}
}
);
}

##     token special_variable__S_178AtMinusBra_Ket (:$*sym = <@-[ ]>)
##          token special_variable:sym<@-[ ]> {
##              '@-['
##              <.obs('@- variable', '.from method')>
##          }

sub special_variable__S_178AtMinusBra_Ket__PEEK { $_[0]->_AUTOLEXpeek('special_variable__S_178AtMinusBra_Ket',$retree) }
sub special_variable__S_178AtMinusBra_Ket {
no warnings 'recursion';
my $self = shift;
local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;
my %args = @_;
local $::sym = $args{sym} // [qw(@-[ ])];


my $C = $self->cursor_xact("RULE special_variable__S_178AtMinusBra_Ket");
my $xact = $C->xact;
my $S = $C->{'_pos'};
$C->{'sym'} = ref $sym ? join(' ', @$sym) : $sym;

$self->_MATCHIFYr($S, "special_variable__S_178AtMinusBra_Ket", 
do {
if (my ($C) = ($C->_EXACT('@-['))) {
$C->obs('@- variable', '.from method');
}
else {
();
}
}
);
}

##     token special_variable__S_179PercentMinusCur_Ly (:$*sym = <%-{ }>)
##          token special_variable:sym<%-{ }> {
##              '@-{'
##              <.obs('%- variable', '.from method')>
##          }

sub special_variable__S_179PercentMinusCur_Ly__PEEK { $_[0]->_AUTOLEXpeek('special_variable__S_179PercentMinusCur_Ly',$retree) }
sub special_variable__S_179PercentMinusCur_Ly {
no warnings 'recursion';
my $self = shift;
local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;
my %args = @_;
local $::sym = $args{sym} // [qw(%-{ })];


my $C = $self->cursor_xact("RULE special_variable__S_179PercentMinusCur_Ly");
my $xact = $C->xact;
my $S = $C->{'_pos'};
$C->{'sym'} = ref $sym ? join(' ', @$sym) : $sym;

$self->_MATCHIFYr($S, "special_variable__S_179PercentMinusCur_Ly", 
do {
if (my ($C) = ($C->_EXACT('@-{'))) {
$C->obs('%- variable', '.from method');
}
else {
();
}
}
);
}

##     token special_variable__S_180DollarPlus (:$*sym = <$+>)
##          token special_variable:sym<$+> {
##              <sym> :: <?before \s | ',' | <terminator> >
##              <.obs('$+ variable', 'Form module')>
##          }

sub special_variable__S_180DollarPlus__PEEK { $_[0]->_AUTOLEXpeek('special_variable__S_180DollarPlus',$retree) }
sub special_variable__S_180DollarPlus {
no warnings 'recursion';
my $self = shift;
local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;
my %args = @_;
local $::sym = $args{sym} // q($+);


my $C = $self->cursor_xact("RULE special_variable__S_180DollarPlus");
my $xact = $C->xact;
my $S = $C->{'_pos'};
$C->{'sym'} = ref $sym ? join(' ', @$sym) : $sym;

$self->_MATCHIFYr($S, "special_variable__S_180DollarPlus", 
do {
if (my ($C) = ($C->_PATTERN(qr/\G\$\+/))) {
do {
if (my ($C) = ($C->_COMMITLTM())) {
do {
if (my ($C) = ($C->before(sub { my $C=shift;
do {
my @result = do {
my $trystate;
my ($tag, $try);
my @try;
my $relex;

my $fate;
my $x;
if ($fate = $C->{'_fate'} and $fate->[1] eq 'special_variable__S_180DollarPlus_01') {
$C->deb("Fate passed to special_variable__S_180DollarPlus_01: ", ::fatestr($fate)) if $::DEBUG & DEBUG::fates;
($C->{'_fate'}, $tag, $try) = @$fate;
@try = ($try);
$x = 'ALT special_variable__S_180DollarPlus_01';    # some outer ltm is controlling us
}
else {
$x = 'ALTLTM special_variable__S_180DollarPlus_01'; # we are top level ltm
}
my $C = $C->cursor_xact($x);
my $xact = $C->xact;

my @gather = ();
for (;;) {
if (not @try) {
$relex //= $C->cursor_fate('STD::P6', 'special_variable__S_180DollarPlus_01', $retree);
@try = $relex->($C, $trystate);
}
last unless @try;
$try = shift(@try) // next;

if (ref $try eq 'ARRAY') {
($C->{'_fate'}, $tag, $try) = @$try;	# next candidate fate
}

$C->deb("special_variable__S_180DollarPlus_01 trying $tag $try") if $::DEBUG & DEBUG::try_processing;
push @gather, ((
sub { my $C=shift;
$C->_PATTERN(qr/\G\s/)
},
sub { my $C=shift;
$C->_EXACT(',')
},
sub { my $C=shift;
$C->_SUBSUMEr(['terminator'], sub {
my $C = shift;
$C->terminator
})
},
)[$try])->($C);
last if $xact->[-2];  # committed?
last if @gather;
}
@gather;
};
@result;
}

}))) {
$C->obs('$+ variable', 'Form module');
}
else {
();
}
};
}
else {
();
}
};
}
else {
();
}
}
);
}

##     token special_variable__S_181DollarCurCaret_Ly (:$*sym = <${^ }>)
##          token special_variable:sym<${^ }> {
##              <sigil> '{^' :: $<text>=[.*?] '}'
##              <.obscaret($<sigil>.Str ~ '{^' ~ $<text>.Str ~ '}', $<sigil>.Str, $<text>.Str)>
##          }

sub special_variable__S_181DollarCurCaret_Ly__PEEK { $_[0]->_AUTOLEXpeek('special_variable__S_181DollarCurCaret_Ly',$retree) }
sub special_variable__S_181DollarCurCaret_Ly {
no warnings 'recursion';
my $self = shift;
local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;
my %args = @_;
local $::sym = $args{sym} // [qw(${^ })];


my $C = $self->cursor_xact("RULE special_variable__S_181DollarCurCaret_Ly");
my $xact = $C->xact;
my $S = $C->{'_pos'};
$C->{'sym'} = ref $sym ? join(' ', @$sym) : $sym;

$self->_MATCHIFYr($S, "special_variable__S_181DollarCurCaret_Ly", 
do {
if (my ($C) = ($C->_SUBSUMEr(['sigil'], sub {
my $C = shift;
$C->sigil
}))) {
do {
if (my ($C) = ($C->_EXACT('{^'))) {
do {
if (my ($C) = ($C->_COMMITLTM())) {
do {
if (my ($C) = (  $C->_SUBSUMEr(['text'], sub {
my $C = shift;
$C->_BRACKETr(sub {
my $C=shift;
$C->_SCANf()
})
}))) {
do {
if (my ($C) = ($C->_EXACT('}'))) {
do { my $M = $C;
$C->obscaret($M->{'sigil'}->Str . '{^' . $M->{'text'}->Str . '}', $M->{'sigil'}->Str, $M->{'text'}->Str)
; };
}
else {
();
}
};
}
else {
();
}
};
}
else {
();
}
};
}
else {
();
}
};
}
else {
();
}
}
);
}

# XXX should eventually rely on multi instead of nested cases here...
##     method obscaret (Str $var, Str $sigil, Str $name)
sub obscaret {
my $self = shift;
my $var = shift;
my $sigil = shift;
my $name = shift;


my $repl;
given ($sigil) {
when ('$') {
given ($name) {
when ('MATCH')         { $repl = '$/' }
when ('PREMATCH')      { $repl = 'an explicit pattern before <(' }
when ('POSTMATCH')     { $repl = 'an explicit pattern after )>' }
when ('ENCODING')      { $repl = '$?ENCODING' }
when ('UNICODE')       { $repl = '$?UNICODE' }  # XXX ???
when ('TAINT')         { $repl = '$::TAINT' }
when ('OPEN')          { $repl = 'filehandle introspection' }
when ('N')             { $repl = '$-1' } # XXX ???
when ('L')             { $repl = 'Form module' }
when ('A')             { $repl = 'Form module' }
when ('E')             { $repl = '$!.extended_os_error' }
when ('C')             { $repl = 'COMPILING namespace' }
when ('D')             { $repl = '$::DEBUGGING' }
when ('F')             { $repl = '$::SYSTEM_FD_MAX' }
when ('H')             { $repl = '$?FOO variables' }
when ('I')             { $repl = '$::INPLACE' } # XXX ???
when ('O')             { $repl = '$?OS or $::OS' }
when ('P')             { $repl = 'whatever debugger Perl 6 comes with' }
when ('R')             { $repl = 'an explicit result variable' }
when ('S')             { $repl = 'the context function' } # XXX ???
when ('T')             { $repl = '$::BASETIME' }
when ('V')             { $repl = '$::PERL_VERSION' }
when ('W')             { $repl = '$::WARNING' }
when ('X')             { $repl = '$::EXECUTABLE_NAME' }
default { $repl = "a global form such as $sigil*$name" }
}
}
when ('%') {
given ($name) {
when ('H')             { $repl = '$?FOO variables' }
default { $repl = "a global form such as $sigil*$name" }
}
}
default { $repl = "a global form such as $sigil*$name" }
};
return $self->obs("$var variable", $repl);
}

##     token special_variable__S_182ColonColonCur_Ly (:$*sym = <::{ }>)
##          token special_variable:sym<::{ }> {
##              '::' <?before '{'>
##          }

sub special_variable__S_182ColonColonCur_Ly__PEEK { $_[0]->_AUTOLEXpeek('special_variable__S_182ColonColonCur_Ly',$retree) }
sub special_variable__S_182ColonColonCur_Ly {
no warnings 'recursion';
my $self = shift;
local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;
my %args = @_;
local $::sym = $args{sym} // [qw(::{ })];


my $C = $self->cursor_xact("RULE special_variable__S_182ColonColonCur_Ly");
my $xact = $C->xact;
my $S = $C->{'_pos'};
$C->{'sym'} = ref $sym ? join(' ', @$sym) : $sym;

$self->_MATCHIFYr($S, "special_variable__S_182ColonColonCur_Ly", 
do {
if (my ($C) = ($C->_EXACT('::'))) {
$C->before(sub { my $C=shift;
$C->_EXACT('{')
});
}
else {
();
}
}
);
}

##     regex special_variable__S_183DollarCur_Ly (:$*sym = <${ }>)
##          regex special_variable:sym<${ }> {
##              <sigil> '{' {} $<text>=[.*?] '}'
##              {{
##                  my $sigil = $<sigil>.Str;
##                  my $text = $<text>.Str;
##                  my $bad = $sigil ~ '{' ~ $text ~ '}';
##                  $text = $text - 1 if $text ~~ /^\d+$/;
##                  if $text !~~ /^(\w|\:)+$/ {
##                      $.obs($bad, $sigil ~ '(' ~ $text ~ ')');
##                  }
##                  elsif $*QSIGIL {
##                      $.obs($bad, '{' ~ $sigil ~ $text ~ '}');
##                  }
##                  else {
##                      $.obs($bad, $sigil ~ $text);
##                  }
##              }} # always fails, don't need curlycheck here
##          }

sub special_variable__S_183DollarCur_Ly__PEEK { $_[0]->_AUTOLEXpeek('special_variable__S_183DollarCur_Ly',$retree) }
sub special_variable__S_183DollarCur_Ly {
no warnings 'recursion';
my $self = shift;
local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;
my %args = @_;
local $::sym = $args{sym} // [qw(${ })];


my $C = $self->cursor_xact("RULE special_variable__S_183DollarCur_Ly");
my $xact = $C->xact;
my $S = $C->{'_pos'};
$C->{'sym'} = ref $sym ? join(' ', @$sym) : $sym;

$self->_MATCHIFY($S, "special_variable__S_183DollarCur_Ly", 
Cursor::lazymap(sub {
my $C=$_[0];
Cursor::lazymap(sub {
my $C=$_[0];
Cursor::lazymap(sub {
my $C=$_[0];
Cursor::lazymap(sub {
my $C=$_[0];
Cursor::lazymap(sub {
my $C=$_[0];
scalar(do {
my $M = $C; 
my $sigil = $M->{'sigil'}->Str;
my $text = $M->{'text'}->Str;
my $bad = $sigil . '{' . $text . '}';
$text = $text - 1 if $text =~ qr/^\d+$/;
if ($text !~ qr/^(\w|\:)+$/) {
$C->obs($bad, $sigil . '(' . $text . ')');
}
elsif ($::QSIGIL) {
$C->obs($bad, '{' . $sigil . $text . '}');
}
else {
$C->obs($bad, $sigil . $text);
}
;
}, $C)
}, $C->_EXACT('}'))
},   $C->_SUBSUME(['text'], sub {
my $C = shift;
$C->_BRACKET(sub {
my $C=shift;
$C->_SCANf()
})
}))
}, scalar(do {

}, $C))
}, $C->_EXACT('{'))
}, $C->_SUBSUME(['sigil'], sub {
my $C = shift;
$C->sigil
}))
);
}

##     token special_variable__S_184DollarBra (:$*sym = <$[>)
##          token special_variable:sym<$[> {
##              <sym> :: <?before \s | ',' | '=' | <terminator> >
##              <.obs('$[ variable', 'user-defined array indices')>
##          }

sub special_variable__S_184DollarBra__PEEK { $_[0]->_AUTOLEXpeek('special_variable__S_184DollarBra',$retree) }
sub special_variable__S_184DollarBra {
no warnings 'recursion';
my $self = shift;
local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;
my %args = @_;
local $::sym = $args{sym} // q($[);


my $C = $self->cursor_xact("RULE special_variable__S_184DollarBra");
my $xact = $C->xact;
my $S = $C->{'_pos'};
$C->{'sym'} = ref $sym ? join(' ', @$sym) : $sym;

$self->_MATCHIFYr($S, "special_variable__S_184DollarBra", 
do {
if (my ($C) = ($C->_PATTERN(qr/\G\$\[/))) {
do {
if (my ($C) = ($C->_COMMITLTM())) {
do {
if (my ($C) = ($C->before(sub { my $C=shift;
do {
my @result = do {
my $trystate;
my ($tag, $try);
my @try;
my $relex;

my $fate;
my $x;
if ($fate = $C->{'_fate'} and $fate->[1] eq 'special_variable__S_184DollarBra_01') {
$C->deb("Fate passed to special_variable__S_184DollarBra_01: ", ::fatestr($fate)) if $::DEBUG & DEBUG::fates;
($C->{'_fate'}, $tag, $try) = @$fate;
@try = ($try);
$x = 'ALT special_variable__S_184DollarBra_01';    # some outer ltm is controlling us
}
else {
$x = 'ALTLTM special_variable__S_184DollarBra_01'; # we are top level ltm
}
my $C = $C->cursor_xact($x);
my $xact = $C->xact;

my @gather = ();
for (;;) {
if (not @try) {
$relex //= $C->cursor_fate('STD::P6', 'special_variable__S_184DollarBra_01', $retree);
@try = $relex->($C, $trystate);
}
last unless @try;
$try = shift(@try) // next;

if (ref $try eq 'ARRAY') {
($C->{'_fate'}, $tag, $try) = @$try;	# next candidate fate
}

$C->deb("special_variable__S_184DollarBra_01 trying $tag $try") if $::DEBUG & DEBUG::try_processing;
push @gather, ((
sub { my $C=shift;
$C->_PATTERN(qr/\G\s/)
},
sub { my $C=shift;
$C->_EXACT(',')
},
sub { my $C=shift;
$C->_EXACT('=')
},
sub { my $C=shift;
$C->_SUBSUMEr(['terminator'], sub {
my $C = shift;
$C->terminator
})
},
)[$try])->($C);
last if $xact->[-2];  # committed?
last if @gather;
}
@gather;
};
@result;
}

}))) {
$C->obs('$[ variable', 'user-defined array indices');
}
else {
();
}
};
}
else {
();
}
};
}
else {
();
}
}
);
}

##     token special_variable__S_185DollarKet (:$*sym = <$]>)
##          token special_variable:sym<$]> {
##              <sym> :: <?before \s | ',' | <terminator> >
##              <.obs('$] variable', '$*PERL_VERSION')>
##          }

sub special_variable__S_185DollarKet__PEEK { $_[0]->_AUTOLEXpeek('special_variable__S_185DollarKet',$retree) }
sub special_variable__S_185DollarKet {
no warnings 'recursion';
my $self = shift;
local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;
my %args = @_;
local $::sym = $args{sym} // q($]);


my $C = $self->cursor_xact("RULE special_variable__S_185DollarKet");
my $xact = $C->xact;
my $S = $C->{'_pos'};
$C->{'sym'} = ref $sym ? join(' ', @$sym) : $sym;

$self->_MATCHIFYr($S, "special_variable__S_185DollarKet", 
do {
if (my ($C) = ($C->_PATTERN(qr/\G\$\]/))) {
do {
if (my ($C) = ($C->_COMMITLTM())) {
do {
if (my ($C) = ($C->before(sub { my $C=shift;
do {
my @result = do {
my $trystate;
my ($tag, $try);
my @try;
my $relex;

my $fate;
my $x;
if ($fate = $C->{'_fate'} and $fate->[1] eq 'special_variable__S_185DollarKet_01') {
$C->deb("Fate passed to special_variable__S_185DollarKet_01: ", ::fatestr($fate)) if $::DEBUG & DEBUG::fates;
($C->{'_fate'}, $tag, $try) = @$fate;
@try = ($try);
$x = 'ALT special_variable__S_185DollarKet_01';    # some outer ltm is controlling us
}
else {
$x = 'ALTLTM special_variable__S_185DollarKet_01'; # we are top level ltm
}
my $C = $C->cursor_xact($x);
my $xact = $C->xact;

my @gather = ();
for (;;) {
if (not @try) {
$relex //= $C->cursor_fate('STD::P6', 'special_variable__S_185DollarKet_01', $retree);
@try = $relex->($C, $trystate);
}
last unless @try;
$try = shift(@try) // next;

if (ref $try eq 'ARRAY') {
($C->{'_fate'}, $tag, $try) = @$try;	# next candidate fate
}

$C->deb("special_variable__S_185DollarKet_01 trying $tag $try") if $::DEBUG & DEBUG::try_processing;
push @gather, ((
sub { my $C=shift;
$C->_PATTERN(qr/\G\s/)
},
sub { my $C=shift;
$C->_EXACT(',')
},
sub { my $C=shift;
$C->_SUBSUMEr(['terminator'], sub {
my $C = shift;
$C->terminator
})
},
)[$try])->($C);
last if $xact->[-2];  # committed?
last if @gather;
}
@gather;
};
@result;
}

}))) {
$C->obs('$] variable', '$::PERL_VERSION');
}
else {
();
}
};
}
else {
();
}
};
}
else {
();
}
}
);
}

##     token special_variable__S_186DollarBack (:$*sym = <$\\>)
##          token special_variable:sym<$\\> {
##              <sym> :: <?before \s | ',' | '=' | <terminator> >
##              <.obs('$\\ variable', "the filehandle's :ors attribute")>
##          }

sub special_variable__S_186DollarBack__PEEK { $_[0]->_AUTOLEXpeek('special_variable__S_186DollarBack',$retree) }
sub special_variable__S_186DollarBack {
no warnings 'recursion';
my $self = shift;
local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;
my %args = @_;
local $::sym = $args{sym} // q($\\);


my $C = $self->cursor_xact("RULE special_variable__S_186DollarBack");
my $xact = $C->xact;
my $S = $C->{'_pos'};
$C->{'sym'} = ref $sym ? join(' ', @$sym) : $sym;

$self->_MATCHIFYr($S, "special_variable__S_186DollarBack", 
do {
if (my ($C) = ($C->_PATTERN(qr/\G\$\\/))) {
do {
if (my ($C) = ($C->_COMMITLTM())) {
do {
if (my ($C) = ($C->before(sub { my $C=shift;
do {
my @result = do {
my $trystate;
my ($tag, $try);
my @try;
my $relex;

my $fate;
my $x;
if ($fate = $C->{'_fate'} and $fate->[1] eq 'special_variable__S_186DollarBack_01') {
$C->deb("Fate passed to special_variable__S_186DollarBack_01: ", ::fatestr($fate)) if $::DEBUG & DEBUG::fates;
($C->{'_fate'}, $tag, $try) = @$fate;
@try = ($try);
$x = 'ALT special_variable__S_186DollarBack_01';    # some outer ltm is controlling us
}
else {
$x = 'ALTLTM special_variable__S_186DollarBack_01'; # we are top level ltm
}
my $C = $C->cursor_xact($x);
my $xact = $C->xact;

my @gather = ();
for (;;) {
if (not @try) {
$relex //= $C->cursor_fate('STD::P6', 'special_variable__S_186DollarBack_01', $retree);
@try = $relex->($C, $trystate);
}
last unless @try;
$try = shift(@try) // next;

if (ref $try eq 'ARRAY') {
($C->{'_fate'}, $tag, $try) = @$try;	# next candidate fate
}

$C->deb("special_variable__S_186DollarBack_01 trying $tag $try") if $::DEBUG & DEBUG::try_processing;
push @gather, ((
sub { my $C=shift;
$C->_PATTERN(qr/\G\s/)
},
sub { my $C=shift;
$C->_EXACT(',')
},
sub { my $C=shift;
$C->_EXACT('=')
},
sub { my $C=shift;
$C->_SUBSUMEr(['terminator'], sub {
my $C = shift;
$C->terminator
})
},
)[$try])->($C);
last if $xact->[-2];  # committed?
last if @gather;
}
@gather;
};
@result;
}

}))) {
$C->obs('$\\ variable', "the filehandle's :ors attribute");
}
else {
();
}
};
}
else {
();
}
};
}
else {
();
}
}
);
}

##     token special_variable__S_187DollarVert (:$*sym = <$|>)
##          token special_variable:sym<$|> {
##              <sym> :: <?before \s | ',' | '=' | <terminator> >
##              <.obs('$| variable', ':autoflush on open')>
##          }

sub special_variable__S_187DollarVert__PEEK { $_[0]->_AUTOLEXpeek('special_variable__S_187DollarVert',$retree) }
sub special_variable__S_187DollarVert {
no warnings 'recursion';
my $self = shift;
local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;
my %args = @_;
local $::sym = $args{sym} // q($|);


my $C = $self->cursor_xact("RULE special_variable__S_187DollarVert");
my $xact = $C->xact;
my $S = $C->{'_pos'};
$C->{'sym'} = ref $sym ? join(' ', @$sym) : $sym;

$self->_MATCHIFYr($S, "special_variable__S_187DollarVert", 
do {
if (my ($C) = ($C->_PATTERN(qr/\G\$\|/))) {
do {
if (my ($C) = ($C->_COMMITLTM())) {
do {
if (my ($C) = ($C->before(sub { my $C=shift;
do {
my @result = do {
my $trystate;
my ($tag, $try);
my @try;
my $relex;

my $fate;
my $x;
if ($fate = $C->{'_fate'} and $fate->[1] eq 'special_variable__S_187DollarVert_01') {
$C->deb("Fate passed to special_variable__S_187DollarVert_01: ", ::fatestr($fate)) if $::DEBUG & DEBUG::fates;
($C->{'_fate'}, $tag, $try) = @$fate;
@try = ($try);
$x = 'ALT special_variable__S_187DollarVert_01';    # some outer ltm is controlling us
}
else {
$x = 'ALTLTM special_variable__S_187DollarVert_01'; # we are top level ltm
}
my $C = $C->cursor_xact($x);
my $xact = $C->xact;

my @gather = ();
for (;;) {
if (not @try) {
$relex //= $C->cursor_fate('STD::P6', 'special_variable__S_187DollarVert_01', $retree);
@try = $relex->($C, $trystate);
}
last unless @try;
$try = shift(@try) // next;

if (ref $try eq 'ARRAY') {
($C->{'_fate'}, $tag, $try) = @$try;	# next candidate fate
}

$C->deb("special_variable__S_187DollarVert_01 trying $tag $try") if $::DEBUG & DEBUG::try_processing;
push @gather, ((
sub { my $C=shift;
$C->_PATTERN(qr/\G\s/)
},
sub { my $C=shift;
$C->_EXACT(',')
},
sub { my $C=shift;
$C->_EXACT('=')
},
sub { my $C=shift;
$C->_SUBSUMEr(['terminator'], sub {
my $C = shift;
$C->terminator
})
},
)[$try])->($C);
last if $xact->[-2];  # committed?
last if @gather;
}
@gather;
};
@result;
}

}))) {
$C->obs('$| variable', ':autoflush on open');
}
else {
();
}
};
}
else {
();
}
};
}
else {
();
}
}
);
}

##     token special_variable__S_188DollarColon (:$*sym = <$:>)
##          token special_variable:sym<$:> {
##              <sym> <?before <[\x20\t\n\],=)}]> >
##              <.obs('$: variable', 'Form module')>
##          }

sub special_variable__S_188DollarColon__PEEK { $_[0]->_AUTOLEXpeek('special_variable__S_188DollarColon',$retree) }
sub special_variable__S_188DollarColon {
no warnings 'recursion';
my $self = shift;
local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;
my %args = @_;
local $::sym = $args{sym} // q($:);


my $C = $self->cursor_xact("RULE special_variable__S_188DollarColon");
my $xact = $C->xact;
my $S = $C->{'_pos'};
$C->{'sym'} = ref $sym ? join(' ', @$sym) : $sym;

$self->_MATCHIFYr($S, "special_variable__S_188DollarColon", 
do {
if (my ($C) = ($C->_PATTERN(qr/\G\$\:/))) {
do {
if (my ($C) = ($C->before(sub { my $C=shift;
$C->_PATTERN(qr/\G[\x20\t\n\],=)}]/)
}))) {
$C->obs('$: variable', 'Form module');
}
else {
();
}
};
}
else {
();
}
}
);
}

##     token special_variable__S_189DollarSemi (:$*sym = <$;>)
##          token special_variable:sym<$;> {
##              <sym> :: <?before \s | ',' | '=' | <terminator> >
##              <.obs('$; variable', 'real multidimensional hashes')>
##          }

sub special_variable__S_189DollarSemi__PEEK { $_[0]->_AUTOLEXpeek('special_variable__S_189DollarSemi',$retree) }
sub special_variable__S_189DollarSemi {
no warnings 'recursion';
my $self = shift;
local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;
my %args = @_;
local $::sym = $args{sym} // q($;);


my $C = $self->cursor_xact("RULE special_variable__S_189DollarSemi");
my $xact = $C->xact;
my $S = $C->{'_pos'};
$C->{'sym'} = ref $sym ? join(' ', @$sym) : $sym;

$self->_MATCHIFYr($S, "special_variable__S_189DollarSemi", 
do {
if (my ($C) = ($C->_PATTERN(qr/\G\$\;/))) {
do {
if (my ($C) = ($C->_COMMITLTM())) {
do {
if (my ($C) = ($C->before(sub { my $C=shift;
do {
my @result = do {
my $trystate;
my ($tag, $try);
my @try;
my $relex;

my $fate;
my $x;
if ($fate = $C->{'_fate'} and $fate->[1] eq 'special_variable__S_189DollarSemi_01') {
$C->deb("Fate passed to special_variable__S_189DollarSemi_01: ", ::fatestr($fate)) if $::DEBUG & DEBUG::fates;
($C->{'_fate'}, $tag, $try) = @$fate;
@try = ($try);
$x = 'ALT special_variable__S_189DollarSemi_01';    # some outer ltm is controlling us
}
else {
$x = 'ALTLTM special_variable__S_189DollarSemi_01'; # we are top level ltm
}
my $C = $C->cursor_xact($x);
my $xact = $C->xact;

my @gather = ();
for (;;) {
if (not @try) {
$relex //= $C->cursor_fate('STD::P6', 'special_variable__S_189DollarSemi_01', $retree);
@try = $relex->($C, $trystate);
}
last unless @try;
$try = shift(@try) // next;

if (ref $try eq 'ARRAY') {
($C->{'_fate'}, $tag, $try) = @$try;	# next candidate fate
}

$C->deb("special_variable__S_189DollarSemi_01 trying $tag $try") if $::DEBUG & DEBUG::try_processing;
push @gather, ((
sub { my $C=shift;
$C->_PATTERN(qr/\G\s/)
},
sub { my $C=shift;
$C->_EXACT(',')
},
sub { my $C=shift;
$C->_EXACT('=')
},
sub { my $C=shift;
$C->_SUBSUMEr(['terminator'], sub {
my $C = shift;
$C->terminator
})
},
)[$try])->($C);
last if $xact->[-2];  # committed?
last if @gather;
}
@gather;
};
@result;
}

}))) {
$C->obs('$; variable', 'real multidimensional hashes');
}
else {
();
}
};
}
else {
();
}
};
}
else {
();
}
}
);
}

##     token special_variable__S_190DollarSingle (:$*sym = <$'>)
##          token special_variable:sym<$'> { #'
##              <sym> :: <?before \s | ',' | <terminator> >
##              <.obs('$' ~ "'" ~ 'variable', "explicit pattern after )\x3E")>
##          }

sub special_variable__S_190DollarSingle__PEEK { $_[0]->_AUTOLEXpeek('special_variable__S_190DollarSingle',$retree) }
sub special_variable__S_190DollarSingle {
no warnings 'recursion';
my $self = shift;
local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;
my %args = @_;
local $::sym = $args{sym} // q($');


my $C = $self->cursor_xact("RULE special_variable__S_190DollarSingle");
my $xact = $C->xact;
my $S = $C->{'_pos'};
$C->{'sym'} = ref $sym ? join(' ', @$sym) : $sym;

$self->_MATCHIFYr($S, "special_variable__S_190DollarSingle", 
do {
if (my ($C) = ($C->_PATTERN(qr/\G\$\'/))) {
do {
if (my ($C) = ($C->_COMMITLTM())) {
do {
if (my ($C) = ($C->before(sub { my $C=shift;
do {
my @result = do {
my $trystate;
my ($tag, $try);
my @try;
my $relex;

my $fate;
my $x;
if ($fate = $C->{'_fate'} and $fate->[1] eq 'special_variable__S_190DollarSingle_01') {
$C->deb("Fate passed to special_variable__S_190DollarSingle_01: ", ::fatestr($fate)) if $::DEBUG & DEBUG::fates;
($C->{'_fate'}, $tag, $try) = @$fate;
@try = ($try);
$x = 'ALT special_variable__S_190DollarSingle_01';    # some outer ltm is controlling us
}
else {
$x = 'ALTLTM special_variable__S_190DollarSingle_01'; # we are top level ltm
}
my $C = $C->cursor_xact($x);
my $xact = $C->xact;

my @gather = ();
for (;;) {
if (not @try) {
$relex //= $C->cursor_fate('STD::P6', 'special_variable__S_190DollarSingle_01', $retree);
@try = $relex->($C, $trystate);
}
last unless @try;
$try = shift(@try) // next;

if (ref $try eq 'ARRAY') {
($C->{'_fate'}, $tag, $try) = @$try;	# next candidate fate
}

$C->deb("special_variable__S_190DollarSingle_01 trying $tag $try") if $::DEBUG & DEBUG::try_processing;
push @gather, ((
sub { my $C=shift;
$C->_PATTERN(qr/\G\s/)
},
sub { my $C=shift;
$C->_EXACT(',')
},
sub { my $C=shift;
$C->_SUBSUMEr(['terminator'], sub {
my $C = shift;
$C->terminator
})
},
)[$try])->($C);
last if $xact->[-2];  # committed?
last if @gather;
}
@gather;
};
@result;
}

}))) {
$C->obs('$' . "'" . 'variable', "explicit pattern after )\x3E");
}
else {
();
}
};
}
else {
();
}
};
}
else {
();
}
}
);
}

##     token special_variable__S_191DollarDouble (:$*sym = <$">)
##          token special_variable:sym<$"> {
##              <sym> <!{ $*QSIGIL }>
##              :: <?before \s | ',' | '=' | <terminator> >
##              <.obs('$" variable', '.join() method')>
##          }

sub special_variable__S_191DollarDouble__PEEK { $_[0]->_AUTOLEXpeek('special_variable__S_191DollarDouble',$retree) }
sub special_variable__S_191DollarDouble {
no warnings 'recursion';
my $self = shift;
local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;
my %args = @_;
local $::sym = $args{sym} // q($");


my $C = $self->cursor_xact("RULE special_variable__S_191DollarDouble");
my $xact = $C->xact;
my $S = $C->{'_pos'};
$C->{'sym'} = ref $sym ? join(' ', @$sym) : $sym;

$self->_MATCHIFYr($S, "special_variable__S_191DollarDouble", 
do {
if (my ($C) = ($C->_PATTERN(qr/\G\$\"/))) {
do {
if (my ($C) = ($C->_NOTBEFORE( sub { my $C=shift;
(($C) x !!do {
$::QSIGIL 
})
}))) {
do {
if (my ($C) = ($C->_COMMITLTM())) {
do {
if (my ($C) = ($C->before(sub { my $C=shift;
do {
my @result = do {
my $trystate;
my ($tag, $try);
my @try;
my $relex;

my $fate;
my $x;
if ($fate = $C->{'_fate'} and $fate->[1] eq 'special_variable__S_191DollarDouble_01') {
$C->deb("Fate passed to special_variable__S_191DollarDouble_01: ", ::fatestr($fate)) if $::DEBUG & DEBUG::fates;
($C->{'_fate'}, $tag, $try) = @$fate;
@try = ($try);
$x = 'ALT special_variable__S_191DollarDouble_01';    # some outer ltm is controlling us
}
else {
$x = 'ALTLTM special_variable__S_191DollarDouble_01'; # we are top level ltm
}
my $C = $C->cursor_xact($x);
my $xact = $C->xact;

my @gather = ();
for (;;) {
if (not @try) {
$relex //= $C->cursor_fate('STD::P6', 'special_variable__S_191DollarDouble_01', $retree);
@try = $relex->($C, $trystate);
}
last unless @try;
$try = shift(@try) // next;

if (ref $try eq 'ARRAY') {
($C->{'_fate'}, $tag, $try) = @$try;	# next candidate fate
}

$C->deb("special_variable__S_191DollarDouble_01 trying $tag $try") if $::DEBUG & DEBUG::try_processing;
push @gather, ((
sub { my $C=shift;
$C->_PATTERN(qr/\G\s/)
},
sub { my $C=shift;
$C->_EXACT(',')
},
sub { my $C=shift;
$C->_EXACT('=')
},
sub { my $C=shift;
$C->_SUBSUMEr(['terminator'], sub {
my $C = shift;
$C->terminator
})
},
)[$try])->($C);
last if $xact->[-2];  # committed?
last if @gather;
}
@gather;
};
@result;
}

}))) {
$C->obs('$" variable', '.join() method');
}
else {
();
}
};
}
else {
();
}
};
}
else {
();
}
};
}
else {
();
}
}
);
}

##     token special_variable__S_192DollarComma (:$*sym = <$,>)
##          token special_variable:sym<$,> {
##              <sym> :: <?before \s | ',' | <terminator> >
##              <.obs('$, variable', ".join() method")>
##          }

sub special_variable__S_192DollarComma__PEEK { $_[0]->_AUTOLEXpeek('special_variable__S_192DollarComma',$retree) }
sub special_variable__S_192DollarComma {
no warnings 'recursion';
my $self = shift;
local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;
my %args = @_;
local $::sym = $args{sym} // q[$,];


my $C = $self->cursor_xact("RULE special_variable__S_192DollarComma");
my $xact = $C->xact;
my $S = $C->{'_pos'};
$C->{'sym'} = ref $sym ? join(' ', @$sym) : $sym;

$self->_MATCHIFYr($S, "special_variable__S_192DollarComma", 
do {
if (my ($C) = ($C->_PATTERN(qr/\G\$\,/))) {
do {
if (my ($C) = ($C->_COMMITLTM())) {
do {
if (my ($C) = ($C->before(sub { my $C=shift;
do {
my @result = do {
my $trystate;
my ($tag, $try);
my @try;
my $relex;

my $fate;
my $x;
if ($fate = $C->{'_fate'} and $fate->[1] eq 'special_variable__S_192DollarComma_01') {
$C->deb("Fate passed to special_variable__S_192DollarComma_01: ", ::fatestr($fate)) if $::DEBUG & DEBUG::fates;
($C->{'_fate'}, $tag, $try) = @$fate;
@try = ($try);
$x = 'ALT special_variable__S_192DollarComma_01';    # some outer ltm is controlling us
}
else {
$x = 'ALTLTM special_variable__S_192DollarComma_01'; # we are top level ltm
}
my $C = $C->cursor_xact($x);
my $xact = $C->xact;

my @gather = ();
for (;;) {
if (not @try) {
$relex //= $C->cursor_fate('STD::P6', 'special_variable__S_192DollarComma_01', $retree);
@try = $relex->($C, $trystate);
}
last unless @try;
$try = shift(@try) // next;

if (ref $try eq 'ARRAY') {
($C->{'_fate'}, $tag, $try) = @$try;	# next candidate fate
}

$C->deb("special_variable__S_192DollarComma_01 trying $tag $try") if $::DEBUG & DEBUG::try_processing;
push @gather, ((
sub { my $C=shift;
$C->_PATTERN(qr/\G\s/)
},
sub { my $C=shift;
$C->_EXACT(',')
},
sub { my $C=shift;
$C->_SUBSUMEr(['terminator'], sub {
my $C = shift;
$C->terminator
})
},
)[$try])->($C);
last if $xact->[-2];  # committed?
last if @gather;
}
@gather;
};
@result;
}

}))) {
$C->obs('$, variable', ".join() method");
}
else {
();
}
};
}
else {
();
}
};
}
else {
();
}
}
);
}

##     token special_variable__S_193DollarLt (:$*sym = ['$<'])
##          token special_variable:sym['$<'] {
##              <sym> :: <!before \s* \w+ \s* '>' >
##              <.obs('$< variable', '$*UID')>
##          }

sub special_variable__S_193DollarLt__PEEK { $_[0]->_AUTOLEXpeek('special_variable__S_193DollarLt',$retree) }
sub special_variable__S_193DollarLt {
no warnings 'recursion';
my $self = shift;
local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;
my %args = @_;
local $::sym = $args{sym} // ['$<'];


my $C = $self->cursor_xact("RULE special_variable__S_193DollarLt");
my $xact = $C->xact;
my $S = $C->{'_pos'};
$C->{'sym'} = ref $sym ? join(' ', @$sym) : $sym;

$self->_MATCHIFYr($S, "special_variable__S_193DollarLt", 
do {
if (my ($C) = ($C->_PATTERN(qr/\G\[\'\$\<\'\]/))) {
do {
if (my ($C) = ($C->_COMMITLTM())) {
do {
if (my ($C) = ($C->_NOTBEFORE( sub { my $C=shift;
$C->before(sub { my $C=shift;
do {
if (my ($C) = ($C->_PATTERN(qr/\G((?:\s)*+)/))) {
do {
if (my ($C) = ($C->_PATTERN(qr/\G((?:\w)++)/))) {
do {
if (my ($C) = ($C->_PATTERN(qr/\G((?:\s)*+)/))) {
$C->_EXACT('>');
}
else {
();
}
};
}
else {
();
}
};
}
else {
();
}
}
})
}))) {
$C->obs('$< variable', '$::UID');
}
else {
();
}
};
}
else {
();
}
};
}
else {
();
}
}
);
}

##     token special_variable__S_194DollarGt (:$*sym = \$>)
##          token special_variable:sym\$> {
##              <sym> :: <?before \s | ',' | <terminator> >
##              <.obs('$> variable', '$*EUID')>
##          }

sub special_variable__S_194DollarGt__PEEK { $_[0]->_AUTOLEXpeek('special_variable__S_194DollarGt',$retree) }
sub special_variable__S_194DollarGt {
no warnings 'recursion';
my $self = shift;
local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;
my %args = @_;
local $::sym = $args{sym} //['\$>'];


my $C = $self->cursor_xact("RULE special_variable__S_194DollarGt");
my $xact = $C->xact;
my $S = $C->{'_pos'};
$C->{'sym'} = ref $sym ? join(' ', @$sym) : $sym;

$self->_MATCHIFYr($S, "special_variable__S_194DollarGt", 
do {
if (my ($C) = ($C->_PATTERN(qr/\G\$\>/))) {
do {
if (my ($C) = ($C->_COMMITLTM())) {
do {
if (my ($C) = ($C->before(sub { my $C=shift;
do {
my @result = do {
my $trystate;
my ($tag, $try);
my @try;
my $relex;

my $fate;
my $x;
if ($fate = $C->{'_fate'} and $fate->[1] eq 'special_variable__S_194DollarGt_01') {
$C->deb("Fate passed to special_variable__S_194DollarGt_01: ", ::fatestr($fate)) if $::DEBUG & DEBUG::fates;
($C->{'_fate'}, $tag, $try) = @$fate;
@try = ($try);
$x = 'ALT special_variable__S_194DollarGt_01';    # some outer ltm is controlling us
}
else {
$x = 'ALTLTM special_variable__S_194DollarGt_01'; # we are top level ltm
}
my $C = $C->cursor_xact($x);
my $xact = $C->xact;

my @gather = ();
for (;;) {
if (not @try) {
$relex //= $C->cursor_fate('STD::P6', 'special_variable__S_194DollarGt_01', $retree);
@try = $relex->($C, $trystate);
}
last unless @try;
$try = shift(@try) // next;

if (ref $try eq 'ARRAY') {
($C->{'_fate'}, $tag, $try) = @$try;	# next candidate fate
}

$C->deb("special_variable__S_194DollarGt_01 trying $tag $try") if $::DEBUG & DEBUG::try_processing;
push @gather, ((
sub { my $C=shift;
$C->_PATTERN(qr/\G\s/)
},
sub { my $C=shift;
$C->_EXACT(',')
},
sub { my $C=shift;
$C->_SUBSUMEr(['terminator'], sub {
my $C = shift;
$C->terminator
})
},
)[$try])->($C);
last if $xact->[-2];  # committed?
last if @gather;
}
@gather;
};
@result;
}

}))) {
$C->obs('$> variable', '$::EUID');
}
else {
();
}
};
}
else {
();
}
};
}
else {
();
}
}
);
}

##     token special_variable__S_195DollarDot (:$*sym = <$.>)
##          token special_variable:sym<$.> {
##              <sym> :: <?before \s | ',' | <terminator> >
##              <.obs('$. variable', "the filehandle's .line method")>
##          }

sub special_variable__S_195DollarDot__PEEK { $_[0]->_AUTOLEXpeek('special_variable__S_195DollarDot',$retree) }
sub special_variable__S_195DollarDot {
no warnings 'recursion';
my $self = shift;
local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;
my %args = @_;
local $::sym = $args{sym} // q($.);


my $C = $self->cursor_xact("RULE special_variable__S_195DollarDot");
my $xact = $C->xact;
my $S = $C->{'_pos'};
$C->{'sym'} = ref $sym ? join(' ', @$sym) : $sym;

$self->_MATCHIFYr($S, "special_variable__S_195DollarDot", 
do {
if (my ($C) = ($C->_PATTERN(qr/\G\$\./))) {
do {
if (my ($C) = ($C->_COMMITLTM())) {
do {
if (my ($C) = ($C->before(sub { my $C=shift;
do {
my @result = do {
my $trystate;
my ($tag, $try);
my @try;
my $relex;

my $fate;
my $x;
if ($fate = $C->{'_fate'} and $fate->[1] eq 'special_variable__S_195DollarDot_01') {
$C->deb("Fate passed to special_variable__S_195DollarDot_01: ", ::fatestr($fate)) if $::DEBUG & DEBUG::fates;
($C->{'_fate'}, $tag, $try) = @$fate;
@try = ($try);
$x = 'ALT special_variable__S_195DollarDot_01';    # some outer ltm is controlling us
}
else {
$x = 'ALTLTM special_variable__S_195DollarDot_01'; # we are top level ltm
}
my $C = $C->cursor_xact($x);
my $xact = $C->xact;

my @gather = ();
for (;;) {
if (not @try) {
$relex //= $C->cursor_fate('STD::P6', 'special_variable__S_195DollarDot_01', $retree);
@try = $relex->($C, $trystate);
}
last unless @try;
$try = shift(@try) // next;

if (ref $try eq 'ARRAY') {
($C->{'_fate'}, $tag, $try) = @$try;	# next candidate fate
}

$C->deb("special_variable__S_195DollarDot_01 trying $tag $try") if $::DEBUG & DEBUG::try_processing;
push @gather, ((
sub { my $C=shift;
$C->_PATTERN(qr/\G\s/)
},
sub { my $C=shift;
$C->_EXACT(',')
},
sub { my $C=shift;
$C->_SUBSUMEr(['terminator'], sub {
my $C = shift;
$C->terminator
})
},
)[$try])->($C);
last if $xact->[-2];  # committed?
last if @gather;
}
@gather;
};
@result;
}

}))) {
$C->obs('$. variable', "the filehandle's .line method");
}
else {
();
}
};
}
else {
();
}
};
}
else {
();
}
}
);
}

##     token special_variable__S_196DollarQuestion (:$*sym = <$?>)
##          token special_variable:sym<$?> {
##              <sym> :: <?before \s | ',' | <terminator> >
##              <.obs('$? variable as child error', '$!')>
##          }

sub special_variable__S_196DollarQuestion__PEEK { $_[0]->_AUTOLEXpeek('special_variable__S_196DollarQuestion',$retree) }
sub special_variable__S_196DollarQuestion {
no warnings 'recursion';
my $self = shift;
local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;
my %args = @_;
local $::sym = $args{sym} // q($?);


my $C = $self->cursor_xact("RULE special_variable__S_196DollarQuestion");
my $xact = $C->xact;
my $S = $C->{'_pos'};
$C->{'sym'} = ref $sym ? join(' ', @$sym) : $sym;

$self->_MATCHIFYr($S, "special_variable__S_196DollarQuestion", 
do {
if (my ($C) = ($C->_PATTERN(qr/\G\$\?/))) {
do {
if (my ($C) = ($C->_COMMITLTM())) {
do {
if (my ($C) = ($C->before(sub { my $C=shift;
do {
my @result = do {
my $trystate;
my ($tag, $try);
my @try;
my $relex;

my $fate;
my $x;
if ($fate = $C->{'_fate'} and $fate->[1] eq 'special_variable__S_196DollarQuestion_01') {
$C->deb("Fate passed to special_variable__S_196DollarQuestion_01: ", ::fatestr($fate)) if $::DEBUG & DEBUG::fates;
($C->{'_fate'}, $tag, $try) = @$fate;
@try = ($try);
$x = 'ALT special_variable__S_196DollarQuestion_01';    # some outer ltm is controlling us
}
else {
$x = 'ALTLTM special_variable__S_196DollarQuestion_01'; # we are top level ltm
}
my $C = $C->cursor_xact($x);
my $xact = $C->xact;

my @gather = ();
for (;;) {
if (not @try) {
$relex //= $C->cursor_fate('STD::P6', 'special_variable__S_196DollarQuestion_01', $retree);
@try = $relex->($C, $trystate);
}
last unless @try;
$try = shift(@try) // next;

if (ref $try eq 'ARRAY') {
($C->{'_fate'}, $tag, $try) = @$try;	# next candidate fate
}

$C->deb("special_variable__S_196DollarQuestion_01 trying $tag $try") if $::DEBUG & DEBUG::try_processing;
push @gather, ((
sub { my $C=shift;
$C->_PATTERN(qr/\G\s/)
},
sub { my $C=shift;
$C->_EXACT(',')
},
sub { my $C=shift;
$C->_SUBSUMEr(['terminator'], sub {
my $C = shift;
$C->terminator
})
},
)[$try])->($C);
last if $xact->[-2];  # committed?
last if @gather;
}
@gather;
};
@result;
}

}))) {
$C->obs('$? variable as child error', '$!');
}
else {
();
}
};
}
else {
();
}
};
}
else {
();
}
}
);
}

# desigilname should only follow a sigil/twigil

##     token desigilname
##          token desigilname {
##              [
##              | <?before '$' > <variable> { $*VAR = $<variable> }
##              | <?before <[\@\%\&]> <sigil>* \w > <.panic: "Invalid hard reference syntax">
##              | <longname>
##              ]
##          }

sub desigilname__PEEK { $_[0]->_AUTOLEXpeek('desigilname',$retree) }
sub desigilname {
no warnings 'recursion';
my $self = shift;
local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;


my $C = $self->cursor_xact("RULE desigilname");
my $xact = $C->xact;
my $S = $C->{'_pos'};

$self->_MATCHIFYr($S, "desigilname", 
$C->_BRACKETr(sub {
my $C=shift;
do {
my @result = do {
my $trystate;
my ($tag, $try);
my @try;
my $relex;

my $fate;
my $x;
if ($fate = $C->{'_fate'} and $fate->[1] eq 'desigilname_01') {
$C->deb("Fate passed to desigilname_01: ", ::fatestr($fate)) if $::DEBUG & DEBUG::fates;
($C->{'_fate'}, $tag, $try) = @$fate;
@try = ($try);
$x = 'ALT desigilname_01';    # some outer ltm is controlling us
}
else {
$x = 'ALTLTM desigilname_01'; # we are top level ltm
}
my $C = $C->cursor_xact($x);
my $xact = $C->xact;

my @gather = ();
for (;;) {
if (not @try) {
$relex //= $C->cursor_fate('STD::P6', 'desigilname_01', $retree);
@try = $relex->($C, $trystate);
}
last unless @try;
$try = shift(@try) // next;

if (ref $try eq 'ARRAY') {
($C->{'_fate'}, $tag, $try) = @$try;	# next candidate fate
}

$C->deb("desigilname_01 trying $tag $try") if $::DEBUG & DEBUG::try_processing;
push @gather, ((
sub { my $C=shift;
do {
if (my ($C) = ($C->before(sub { my $C=shift;
$C->_EXACT('$')
}))) {
do {
if (my ($C) = ($C->_SUBSUMEr(['variable'], sub {
my $C = shift;
$C->variable
}))) {
scalar(do {
my $M = $C;  $::VAR = $M->{'variable'} ;
}, $C);
}
else {
();
}
};
}
else {
();
}
}
},
sub { my $C=shift;
do {
if (my ($C) = ($C->before(sub { my $C=shift;
do {
if (my ($C) = ($C->_PATTERN(qr/\G[\@\%\&]/))) {
do {
if (my ($C) = ($C->_STARr(sub { my $C=shift;
$C->_SUBSUMEr(['sigil'], sub {
my $C = shift;
$C->sigil
})
}))) {
$C->_PATTERN(qr/\G\w/);
}
else {
();
}
};
}
else {
();
}
}
}))) {
$C->panic("Invalid hard reference syntax");
}
else {
();
}
}
},
sub { my $C=shift;
$C->_SUBSUMEr(['longname'], sub {
my $C = shift;
$C->longname
})
},
)[$try])->($C);
last if $xact->[-2];  # committed?
last if @gather;
}
@gather;
};
@result;
}

})
);
}

##     token variable
##          token variable {
##              :my $*IN_META = 0;
##              :my $sigil = '';
##              :my $twigil = '';
##              :my $name;
##              <?before <sigil> {
##                  $sigil = $<sigil>.Str;
##                  $*LEFTSIGIL ||= $sigil;
##              }> {}
##              [
##              || <sigil> <twigil>? <?before '::' [ '{' | '<' | '(' ]> <longname> # XXX
##              || '&'
##                  [
##                  | <twigil>? <sublongname> { $name = $<sublongname>.Str }
##                  | :dba('infix noun') '[' ~ ']' <infixish(1)>
##                  ]
##              || '$::' <name>? # XXX
##              || '$:' <name> # XXX
##              || [
##                  | <sigil> <twigil>? <desigilname> { $name = $<desigilname>.Str }
##                  | <special_variable>
##                  | <sigil> <index=.decint>
##                  # Note: $() can also parse as contextualizer in an expression; should have same effect
##                  | <sigil> <?before '<' | '('> <postcircumfix>
##                  | <sigil> <?{ $*IN_DECL }>
##                  | <?> {{
##                      if $*QSIGIL {
##                          return ();
##                      }
##                      else {
##                          $.panic("Non-declarative sigil is missing its name");
##                      }
##                    }}
##                  ]
##              ]
##      
##              { my $t = $<twigil>; $twigil = $t.[0].Str if @$t; }
##              [ <?{ $twigil eq '.' }>
##                  [<.unsp> | '\\' | <?> ] <?before '('> <postcircumfix>
##              ]?
##          }

sub variable__PEEK { $_[0]->_AUTOLEXpeek('variable',$retree) }
sub variable {
no warnings 'recursion';
my $self = shift;
local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;
local $::IN_META = 0;
my $sigil = '';
my $twigil = '';
my $name;


my $C = $self->cursor_xact("RULE variable");
my $xact = $C->xact;
my $S = $C->{'_pos'};
$C->{'name'} = [];
$C->{'postcircumfix'} = [];
$C->{'twigil'} = [];

$self->_MATCHIFYr($S, "variable", 
do {
if (my ($C) = ($C->before(sub { my $C=shift;
do {
if (my ($C) = ($C->_SUBSUMEr(['sigil'], sub {
my $C = shift;
$C->sigil
}))) {
scalar(do {
my $M = $C; 
$sigil = $M->{'sigil'}->Str;
$::LEFTSIGIL ||= $sigil;
;
}, $C);
}
else {
();
}
}
}))) {
do {
if (my ($C) = (scalar(do {

}, $C))) {
do {
if (my ($C) = ($C->_BRACKETr(sub {
my $C=shift;
do {
my $C = $C->cursor_xact('ALT ||');
my $xact = $C->xact;
my @gather;
do {
push @gather, do {
if (my ($C) = ($C->_SUBSUMEr(['sigil'], sub {
my $C = shift;
$C->sigil
}))) {
do {
if (my ($C) = ($C->_OPTr(sub { my $C=shift;
$C->_SUBSUMEr(['twigil'], sub {
my $C = shift;
$C->twigil
})
}))) {
do {
if (my ($C) = ($C->before(sub { my $C=shift;
do {
if (my ($C) = ($C->_EXACT('::'))) {
$C->_BRACKETr(sub {
my $C=shift;
do {
my @result = do {
my $trystate;
my ($tag, $try);
my @try;
my $relex;

my $fate;
my $x;
if ($fate = $C->{'_fate'} and $fate->[1] eq 'variable_04') {
$C->deb("Fate passed to variable_04: ", ::fatestr($fate)) if $::DEBUG & DEBUG::fates;
($C->{'_fate'}, $tag, $try) = @$fate;
@try = ($try);
$x = 'ALT variable_04';    # some outer ltm is controlling us
}
else {
$x = 'ALTLTM variable_04'; # we are top level ltm
}
my $C = $C->cursor_xact($x);
my $xact = $C->xact;

my @gather = ();
for (;;) {
if (not @try) {
$relex //= $C->cursor_fate('STD::P6', 'variable_04', $retree);
@try = $relex->($C, $trystate);
}
last unless @try;
$try = shift(@try) // next;

if (ref $try eq 'ARRAY') {
($C->{'_fate'}, $tag, $try) = @$try;	# next candidate fate
}

$C->deb("variable_04 trying $tag $try") if $::DEBUG & DEBUG::try_processing;
push @gather, ((
sub { my $C=shift;
$C->_EXACT('{')
},
sub { my $C=shift;
$C->_EXACT('<')
},
sub { my $C=shift;
$C->_EXACT('(')
},
)[$try])->($C);
last if $xact->[-2];  # committed?
last if @gather;
}
@gather;
};
@result;
}

});
}
else {
();
}
}
}))) {
$C->_SUBSUMEr(['longname'], sub {
my $C = shift;
$C->longname
});
}
else {
();
}
};
}
else {
();
}
};
}
else {
();
}
}
}
or $xact->[-2] or
do {
push @gather, do {
if (my ($C) = ($C->_EXACT('&'))) {
$C->_BRACKETr(sub {
my $C=shift;
do {
my @result = do {
my $trystate;
my ($tag, $try);
my @try;
my $relex;

my $fate;
my $x;
if ($fate = $C->{'_fate'} and $fate->[1] eq 'variable_06') {
$C->deb("Fate passed to variable_06: ", ::fatestr($fate)) if $::DEBUG & DEBUG::fates;
($C->{'_fate'}, $tag, $try) = @$fate;
@try = ($try);
$x = 'ALT variable_06';    # some outer ltm is controlling us
}
else {
$x = 'ALTLTM variable_06'; # we are top level ltm
}
my $C = $C->cursor_xact($x);
my $xact = $C->xact;

my @gather = ();
for (;;) {
if (not @try) {
$relex //= $C->cursor_fate('STD::P6', 'variable_06', $retree);
@try = $relex->($C, $trystate);
}
last unless @try;
$try = shift(@try) // next;

if (ref $try eq 'ARRAY') {
($C->{'_fate'}, $tag, $try) = @$try;	# next candidate fate
}

$C->deb("variable_06 trying $tag $try") if $::DEBUG & DEBUG::try_processing;
push @gather, ((
sub { my $C=shift;
do {
if (my ($C) = ($C->_OPTr(sub { my $C=shift;
$C->_SUBSUMEr(['twigil'], sub {
my $C = shift;
$C->twigil
})
}))) {
do {
if (my ($C) = ($C->_SUBSUMEr(['sublongname'], sub {
my $C = shift;
$C->sublongname
}))) {
scalar(do {
my $M = $C;  $name = $M->{'sublongname'}->Str ;
}, $C);
}
else {
();
}
};
}
else {
();
}
}
},
sub { my $C=shift;
do {
if (my ($C) = ($C->_EXACT('['))) {
do {
if (my ($C) = (((local $::GOAL = ']' ), $C)[-1])) {
do {
if (my ($C) = ($C->_SUBSUMEr(['infixish'], sub {
my $C = shift;
$C->infixish(1)
}))) {
$C->_BRACKETr(sub {
my $C=shift;
do {
my $C = $C->cursor_xact('ALT ||');
my $xact = $C->xact;
my @gather;
do {
push @gather, $C->_EXACT(']')
}
or $xact->[-2] or
do {
push @gather, $C->FAILGOAL(']' , 'infix noun')};
@gather;
}
});
}
else {
();
}
};
}
else {
();
}
};
}
else {
();
}
}
},
)[$try])->($C);
last if $xact->[-2];  # committed?
last if @gather;
}
@gather;
};
@result;
}

});
}
else {
();
}
}
}
or $xact->[-2] or
do {
push @gather, do {
if (my ($C) = ($C->_EXACT('$::'))) {
$C->_OPTr(sub { my $C=shift;
$C->_SUBSUMEr(['name'], sub {
my $C = shift;
$C->name
})
});
}
else {
();
}
}
}
or $xact->[-2] or
do {
push @gather, do {
if (my ($C) = ($C->_EXACT('$:'))) {
$C->_SUBSUMEr(['name'], sub {
my $C = shift;
$C->name
});
}
else {
();
}
}
}
or $xact->[-2] or
do {
push @gather, $C->_BRACKETr(sub {
my $C=shift;
do {
my @result = do {
my $trystate;
my ($tag, $try);
my @try;
my $relex;

my $fate;
my $x;
if ($fate = $C->{'_fate'} and $fate->[1] eq 'variable_10') {
$C->deb("Fate passed to variable_10: ", ::fatestr($fate)) if $::DEBUG & DEBUG::fates;
($C->{'_fate'}, $tag, $try) = @$fate;
@try = ($try);
$x = 'ALT variable_10';    # some outer ltm is controlling us
}
else {
$x = 'ALTLTM variable_10'; # we are top level ltm
}
my $C = $C->cursor_xact($x);
my $xact = $C->xact;

my @gather = ();
for (;;) {
if (not @try) {
$relex //= $C->cursor_fate('STD::P6', 'variable_10', $retree);
@try = $relex->($C, $trystate);
}
last unless @try;
$try = shift(@try) // next;

if (ref $try eq 'ARRAY') {
($C->{'_fate'}, $tag, $try) = @$try;	# next candidate fate
}

$C->deb("variable_10 trying $tag $try") if $::DEBUG & DEBUG::try_processing;
push @gather, ((
sub { my $C=shift;
do {
if (my ($C) = ($C->_SUBSUMEr(['sigil'], sub {
my $C = shift;
$C->sigil
}))) {
do {
if (my ($C) = ($C->_OPTr(sub { my $C=shift;
$C->_SUBSUMEr(['twigil'], sub {
my $C = shift;
$C->twigil
})
}))) {
do {
if (my ($C) = ($C->_SUBSUMEr(['desigilname'], sub {
my $C = shift;
$C->desigilname
}))) {
scalar(do {
my $M = $C;  $name = $M->{'desigilname'}->Str ;
}, $C);
}
else {
();
}
};
}
else {
();
}
};
}
else {
();
}
}
},
sub { my $C=shift;
$C->_SUBSUMEr(['special_variable'], sub {
my $C = shift;
$C->special_variable
})
},
sub { my $C=shift;
do {
if (my ($C) = ($C->_SUBSUMEr(['sigil'], sub {
my $C = shift;
$C->sigil
}))) {
$C->_SUBSUMEr(['index'], sub {
my $C = shift;
$C->decint
});
}
else {
();
}
}
},
sub { my $C=shift;
do {
if (my ($C) = ($C->_SUBSUMEr(['sigil'], sub {
my $C = shift;
$C->sigil
}))) {
do {
if (my ($C) = ($C->before(sub { my $C=shift;
do {
my @result = do {
my $trystate;
my ($tag, $try);
my @try;
my $relex;

my $fate;
my $x;
if ($fate = $C->{'_fate'} and $fate->[1] eq 'variable_11') {
$C->deb("Fate passed to variable_11: ", ::fatestr($fate)) if $::DEBUG & DEBUG::fates;
($C->{'_fate'}, $tag, $try) = @$fate;
@try = ($try);
$x = 'ALT variable_11';    # some outer ltm is controlling us
}
else {
$x = 'ALTLTM variable_11'; # we are top level ltm
}
my $C = $C->cursor_xact($x);
my $xact = $C->xact;

my @gather = ();
for (;;) {
if (not @try) {
$relex //= $C->cursor_fate('STD::P6', 'variable_11', $retree);
@try = $relex->($C, $trystate);
}
last unless @try;
$try = shift(@try) // next;

if (ref $try eq 'ARRAY') {
($C->{'_fate'}, $tag, $try) = @$try;	# next candidate fate
}

$C->deb("variable_11 trying $tag $try") if $::DEBUG & DEBUG::try_processing;
push @gather, ((
sub { my $C=shift;
$C->_EXACT('<')
},
sub { my $C=shift;
$C->_EXACT('(')
},
)[$try])->($C);
last if $xact->[-2];  # committed?
last if @gather;
}
@gather;
};
@result;
}

}))) {
$C->_SUBSUMEr(['postcircumfix'], sub {
my $C = shift;
$C->postcircumfix
});
}
else {
();
}
};
}
else {
();
}
}
},
sub { my $C=shift;
do {
if (my ($C) = ($C->_SUBSUMEr(['sigil'], sub {
my $C = shift;
$C->sigil
}))) {
$C->before( sub { my $C=shift;
(($C) x !!do {
$::IN_DECL 
})
});
}
else {
();
}
}
},
sub { my $C=shift;
do {
if (my ($C) = ($C->before( sub { my $C=shift;
$C
}))) {
scalar(do {

if ($::QSIGIL) {
return ();
}
else {
$C->panic("Non-declarative sigil is missing its name");
}

}, $C);
}
else {
();
}
}
},
)[$try])->($C);
last if $xact->[-2];  # committed?
last if @gather;
}
@gather;
};
@result;
}

})};
@gather;
}
}))) {
do {
if (my ($C) = (scalar(do {
my $M = $C;  my $t = $M->{'twigil'}; $twigil = $t->[0]->Str if @$t; ;
}, $C))) {
$C->_OPTr(sub { my $C=shift;
$C->_BRACKETr(sub {
my $C=shift;
do {
if (my ($C) = ($C->before( sub { my $C=shift;
(($C) x !!do {
$twigil eq '.' 
})
}))) {
do {
if (my ($C) = ($C->_BRACKETr(sub {
my $C=shift;
do {
my @result = do {
my $trystate;
my ($tag, $try);
my @try;
my $relex;

my $fate;
my $x;
if ($fate = $C->{'_fate'} and $fate->[1] eq 'variable_13') {
$C->deb("Fate passed to variable_13: ", ::fatestr($fate)) if $::DEBUG & DEBUG::fates;
($C->{'_fate'}, $tag, $try) = @$fate;
@try = ($try);
$x = 'ALT variable_13';    # some outer ltm is controlling us
}
else {
$x = 'ALTLTM variable_13'; # we are top level ltm
}
my $C = $C->cursor_xact($x);
my $xact = $C->xact;

my @gather = ();
for (;;) {
if (not @try) {
$relex //= $C->cursor_fate('STD::P6', 'variable_13', $retree);
@try = $relex->($C, $trystate);
}
last unless @try;
$try = shift(@try) // next;

if (ref $try eq 'ARRAY') {
($C->{'_fate'}, $tag, $try) = @$try;	# next candidate fate
}

$C->deb("variable_13 trying $tag $try") if $::DEBUG & DEBUG::try_processing;
push @gather, ((
sub { my $C=shift;
$C->unsp
},
sub { my $C=shift;
$C->_EXACT('\\')
},
sub { my $C=shift;
$C->before( sub { my $C=shift;
$C
})
},
)[$try])->($C);
last if $xact->[-2];  # committed?
last if @gather;
}
@gather;
};
@result;
}

}))) {
do {
if (my ($C) = ($C->before(sub { my $C=shift;
$C->_EXACT('(')
}))) {
$C->_SUBSUMEr(['postcircumfix'], sub {
my $C = shift;
$C->postcircumfix
});
}
else {
();
}
};
}
else {
();
}
};
}
else {
();
}
}
})
});
}
else {
();
}
};
}
else {
();
}
};
}
else {
();
}
};
}
else {
();
}
}
);
}



##     token deflongname
##          token deflongname {
##              :dba('new name to be defined')
##              <name>
##              [
##              | <colonpair>+ { $.add_macro($<name>) if $*IN_DECL; }
##              | { $.add_routine($<name>.Str) if $*IN_DECL; }
##              ]
##          }

sub deflongname__PEEK { $_[0]->_AUTOLEXpeek('deflongname',$retree) }
sub deflongname {
no warnings 'recursion';
my $self = shift;
local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;


my $C = $self->cursor_xact("RULE deflongname");
my $xact = $C->xact;
my $S = $C->{'_pos'};
$C->{'colonpair'} = [];

$self->_MATCHIFYr($S, "deflongname", 
do {
if (my ($C) = ($C->_SUBSUMEr(['name'], sub {
my $C = shift;
$C->name
}))) {
$C->_BRACKETr(sub {
my $C=shift;
do {
my @result = do {
my $trystate;
my ($tag, $try);
my @try;
my $relex;

my $fate;
my $x;
if ($fate = $C->{'_fate'} and $fate->[1] eq 'deflongname_01') {
$C->deb("Fate passed to deflongname_01: ", ::fatestr($fate)) if $::DEBUG & DEBUG::fates;
($C->{'_fate'}, $tag, $try) = @$fate;
@try = ($try);
$x = 'ALT deflongname_01';    # some outer ltm is controlling us
}
else {
$x = 'ALTLTM deflongname_01'; # we are top level ltm
}
my $C = $C->cursor_xact($x);
my $xact = $C->xact;

my @gather = ();
for (;;) {
if (not @try) {
$relex //= $C->cursor_fate('STD::P6', 'deflongname_01', $retree);
@try = $relex->($C, $trystate);
}
last unless @try;
$try = shift(@try) // next;

if (ref $try eq 'ARRAY') {
($C->{'_fate'}, $tag, $try) = @$try;	# next candidate fate
}

$C->deb("deflongname_01 trying $tag $try") if $::DEBUG & DEBUG::try_processing;
push @gather, ((
sub { my $C=shift;
do {
if (my ($C) = ($C->_PLUSr(sub { my $C=shift;
$C->_SUBSUMEr(['colonpair'], sub {
my $C = shift;
$C->colonpair
})
}))) {
scalar(do {
my $M = $C;  $C->add_macro($M->{'name'}) if $::IN_DECL; ;
}, $C);
}
else {
();
}
}
},
sub { my $C=shift;
scalar(do {
my $M = $C;  $C->add_routine($M->{'name'}->Str) if $::IN_DECL; ;
}, $C)
},
)[$try])->($C);
last if $xact->[-2];  # committed?
last if @gather;
}
@gather;
};
@result;
}

});
}
else {
();
}
}
);
}

##     token subshortname
##          token subshortname {
##              [
##              | <category>
##                  [ <colonpair>+ { $.add_macro($<category>) if $*IN_DECL; } ]?
##              | <desigilname>
##              ]
##          }

sub subshortname__PEEK { $_[0]->_AUTOLEXpeek('subshortname',$retree) }
sub subshortname {
no warnings 'recursion';
my $self = shift;
local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;


my $C = $self->cursor_xact("RULE subshortname");
my $xact = $C->xact;
my $S = $C->{'_pos'};
$C->{'colonpair'} = [];

$self->_MATCHIFYr($S, "subshortname", 
$C->_BRACKETr(sub {
my $C=shift;
do {
my @result = do {
my $trystate;
my ($tag, $try);
my @try;
my $relex;

my $fate;
my $x;
if ($fate = $C->{'_fate'} and $fate->[1] eq 'subshortname_01') {
$C->deb("Fate passed to subshortname_01: ", ::fatestr($fate)) if $::DEBUG & DEBUG::fates;
($C->{'_fate'}, $tag, $try) = @$fate;
@try = ($try);
$x = 'ALT subshortname_01';    # some outer ltm is controlling us
}
else {
$x = 'ALTLTM subshortname_01'; # we are top level ltm
}
my $C = $C->cursor_xact($x);
my $xact = $C->xact;

my @gather = ();
for (;;) {
if (not @try) {
$relex //= $C->cursor_fate('STD::P6', 'subshortname_01', $retree);
@try = $relex->($C, $trystate);
}
last unless @try;
$try = shift(@try) // next;

if (ref $try eq 'ARRAY') {
($C->{'_fate'}, $tag, $try) = @$try;	# next candidate fate
}

$C->deb("subshortname_01 trying $tag $try") if $::DEBUG & DEBUG::try_processing;
push @gather, ((
sub { my $C=shift;
do {
if (my ($C) = ($C->_SUBSUMEr(['category'], sub {
my $C = shift;
$C->category
}))) {
$C->_OPTr(sub { my $C=shift;
$C->_BRACKETr(sub {
my $C=shift;
do {
if (my ($C) = ($C->_PLUSr(sub { my $C=shift;
$C->_SUBSUMEr(['colonpair'], sub {
my $C = shift;
$C->colonpair
})
}))) {
scalar(do {
my $M = $C;  $C->add_macro($M->{'category'}) if $::IN_DECL; ;
}, $C);
}
else {
();
}
}
})
});
}
else {
();
}
}
},
sub { my $C=shift;
$C->_SUBSUMEr(['desigilname'], sub {
my $C = shift;
$C->desigilname
})
},
)[$try])->($C);
last if $xact->[-2];  # committed?
last if @gather;
}
@gather;
};
@result;
}

})
);
}

##     token sublongname
##          token sublongname {
##              <subshortname> <sigterm>?
##          }

sub sublongname__PEEK { $_[0]->_AUTOLEXpeek('sublongname',$retree) }
sub sublongname {
no warnings 'recursion';
my $self = shift;
local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;


my $C = $self->cursor_xact("RULE sublongname");
my $xact = $C->xact;
my $S = $C->{'_pos'};
$C->{'sigterm'} = [];

$self->_MATCHIFYr($S, "sublongname", 
do {
if (my ($C) = ($C->_SUBSUMEr(['subshortname'], sub {
my $C = shift;
$C->subshortname
}))) {
$C->_OPTr(sub { my $C=shift;
$C->_SUBSUMEr(['sigterm'], sub {
my $C = shift;
$C->sigterm
})
});
}
else {
();
}
}
);
}

##     token value__S_197quote (:$*sym = 'quote')
##          token value:quote   { <quote> }

sub value__S_197quote__PEEK { $_[0]->_AUTOLEXpeek('value__S_197quote',$retree) }
sub value__S_197quote {
no warnings 'recursion';
my $self = shift;
local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;
my %args = @_;
local $::sym = $args{sym} // 'quote';


my $C = $self->cursor_xact("RULE value__S_197quote");
my $xact = $C->xact;
my $S = $C->{'_pos'};
$C->{'sym'} = ref $sym ? join(' ', @$sym) : $sym;

$self->_MATCHIFYr($S, "value__S_197quote", 
$C->_SUBSUMEr(['quote'], sub {
my $C = shift;
$C->quote
})
);
}
##     token value__S_198number (:$*sym = 'number')
##          token value:number  { <number> }

sub value__S_198number__PEEK { $_[0]->_AUTOLEXpeek('value__S_198number',$retree) }
sub value__S_198number {
no warnings 'recursion';
my $self = shift;
local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;
my %args = @_;
local $::sym = $args{sym} // 'number';


my $C = $self->cursor_xact("RULE value__S_198number");
my $xact = $C->xact;
my $S = $C->{'_pos'};
$C->{'sym'} = ref $sym ? join(' ', @$sym) : $sym;

$self->_MATCHIFYr($S, "value__S_198number", 
$C->_SUBSUMEr(['number'], sub {
my $C = shift;
$C->number
})
);
}
##     token value__S_199version (:$*sym = 'version')
##          token value:version { <version> }

sub value__S_199version__PEEK { $_[0]->_AUTOLEXpeek('value__S_199version',$retree) }
sub value__S_199version {
no warnings 'recursion';
my $self = shift;
local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;
my %args = @_;
local $::sym = $args{sym} // 'version';


my $C = $self->cursor_xact("RULE value__S_199version");
my $xact = $C->xact;
my $S = $C->{'_pos'};
$C->{'sym'} = ref $sym ? join(' ', @$sym) : $sym;

$self->_MATCHIFYr($S, "value__S_199version", 
$C->_SUBSUMEr(['version'], sub {
my $C = shift;
$C->version
})
);
}

# Note: call this only to use existing type, not to declare type
##     token typename
##          token typename {
##              [
##              | '::?'<identifier>                 # parse ::?CLASS as special case
##              | <longname>
##                <?{{
##                  my $longname = $<longname>.Str;
##                  if substr($longname, 0, 2) eq '::' {
##                      $.add_my_name(substr($longname, 2));
##                  }
##                  else {
##                      $.is_name($longname)
##                  }
##                }}>
##              ]
##              # parametric type?
##              <.unsp>? [ <?before '['> <param=.postcircumfix> ]?
##              <.unsp>? [ <?before '{'> <whence=.postcircumfix> ]?
##              [<.ws> 'of' <.ws> <typename> ]?
##          }

sub typename__PEEK { $_[0]->_AUTOLEXpeek('typename',$retree) }
sub typename {
no warnings 'recursion';
my $self = shift;
local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;


my $C = $self->cursor_xact("RULE typename");
my $xact = $C->xact;
my $S = $C->{'_pos'};
$C->{'typename'} = [];
$C->{'whence'} = [];
$C->{'param'} = [];

$self->_MATCHIFYr($S, "typename", 
do {
if (my ($C) = ($C->_BRACKETr(sub {
my $C=shift;
do {
my @result = do {
my $trystate;
my ($tag, $try);
my @try;
my $relex;

my $fate;
my $x;
if ($fate = $C->{'_fate'} and $fate->[1] eq 'typename_01') {
$C->deb("Fate passed to typename_01: ", ::fatestr($fate)) if $::DEBUG & DEBUG::fates;
($C->{'_fate'}, $tag, $try) = @$fate;
@try = ($try);
$x = 'ALT typename_01';    # some outer ltm is controlling us
}
else {
$x = 'ALTLTM typename_01'; # we are top level ltm
}
my $C = $C->cursor_xact($x);
my $xact = $C->xact;

my @gather = ();
for (;;) {
if (not @try) {
$relex //= $C->cursor_fate('STD::P6', 'typename_01', $retree);
@try = $relex->($C, $trystate);
}
last unless @try;
$try = shift(@try) // next;

if (ref $try eq 'ARRAY') {
($C->{'_fate'}, $tag, $try) = @$try;	# next candidate fate
}

$C->deb("typename_01 trying $tag $try") if $::DEBUG & DEBUG::try_processing;
push @gather, ((
sub { my $C=shift;
do {
if (my ($C) = ($C->_EXACT('::?'))) {
$C->_SUBSUMEr(['identifier'], sub {
my $C = shift;
$C->identifier
});
}
else {
();
}
}
},
sub { my $C=shift;
do {
if (my ($C) = ($C->_SUBSUMEr(['longname'], sub {
my $C = shift;
$C->longname
}))) {
$C->before( sub { my $C=shift;
(($C) x !!do {
my $M = $C; 
my $longname = $M->{'longname'}->Str;
if (substr($longname, 0, 2) eq '::') {
$C->add_my_name(substr($longname, 2));
}
else {
$C->is_name($longname)
}
;
})
});
}
else {
();
}
}
},
)[$try])->($C);
last if $xact->[-2];  # committed?
last if @gather;
}
@gather;
};
@result;
}

}))) {
do {
if (my ($C) = ($C->_OPTr(sub { my $C=shift;
$C->unsp
}))) {
do {
if (my ($C) = ($C->_OPTr(sub { my $C=shift;
$C->_BRACKETr(sub {
my $C=shift;
do {
if (my ($C) = ($C->before(sub { my $C=shift;
$C->_EXACT('[')
}))) {
$C->_SUBSUMEr(['param'], sub {
my $C = shift;
$C->postcircumfix
});
}
else {
();
}
}
})
}))) {
do {
if (my ($C) = ($C->_OPTr(sub { my $C=shift;
$C->unsp
}))) {
do {
if (my ($C) = ($C->_OPTr(sub { my $C=shift;
$C->_BRACKETr(sub {
my $C=shift;
do {
if (my ($C) = ($C->before(sub { my $C=shift;
$C->_EXACT('{')
}))) {
$C->_SUBSUMEr(['whence'], sub {
my $C = shift;
$C->postcircumfix
});
}
else {
();
}
}
})
}))) {
$C->_OPTr(sub { my $C=shift;
$C->_BRACKETr(sub {
my $C=shift;
do {
if (my ($C) = ($C->ws)) {
do {
if (my ($C) = ($C->_EXACT('of'))) {
do {
if (my ($C) = ($C->ws)) {
$C->_SUBSUMEr(['typename'], sub {
my $C = shift;
$C->typename
});
}
else {
();
}
};
}
else {
();
}
};
}
else {
();
}
}
})
});
}
else {
();
}
};
}
else {
();
}
};
}
else {
();
}
};
}
else {
();
}
};
}
else {
();
}
}
);
}

# Note, does not include <1/2> forms, which are parsed as quotewords

##     token number
##          token number {
##              [
##              | 'NaN' 
##              | <integer>
##              | <dec_number>
##              | <rad_number>
##              | 'Inf' 
##              ]
##          }

sub number__PEEK { $_[0]->_AUTOLEXpeek('number',$retree) }
sub number {
no warnings 'recursion';
my $self = shift;
local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;


my $C = $self->cursor_xact("RULE number");
my $xact = $C->xact;
my $S = $C->{'_pos'};

$self->_MATCHIFYr($S, "number", 
$C->_BRACKETr(sub {
my $C=shift;
do {
my @result = do {
my $trystate;
my ($tag, $try);
my @try;
my $relex;

my $fate;
my $x;
if ($fate = $C->{'_fate'} and $fate->[1] eq 'number_01') {
$C->deb("Fate passed to number_01: ", ::fatestr($fate)) if $::DEBUG & DEBUG::fates;
($C->{'_fate'}, $tag, $try) = @$fate;
@try = ($try);
$x = 'ALT number_01';    # some outer ltm is controlling us
}
else {
$x = 'ALTLTM number_01'; # we are top level ltm
}
my $C = $C->cursor_xact($x);
my $xact = $C->xact;

my @gather = ();
for (;;) {
if (not @try) {
$relex //= $C->cursor_fate('STD::P6', 'number_01', $retree);
@try = $relex->($C, $trystate);
}
last unless @try;
$try = shift(@try) // next;

if (ref $try eq 'ARRAY') {
($C->{'_fate'}, $tag, $try) = @$try;	# next candidate fate
}

$C->deb("number_01 trying $tag $try") if $::DEBUG & DEBUG::try_processing;
push @gather, ((
sub { my $C=shift;
do {
if (my ($C) = ($C->_EXACT('NaN'))) {
$C->_PATTERN(qr/\G\b/);
}
else {
();
}
}
},
sub { my $C=shift;
$C->_SUBSUMEr(['integer'], sub {
my $C = shift;
$C->integer
})
},
sub { my $C=shift;
$C->_SUBSUMEr(['dec_number'], sub {
my $C = shift;
$C->dec_number
})
},
sub { my $C=shift;
$C->_SUBSUMEr(['rad_number'], sub {
my $C = shift;
$C->rad_number
})
},
sub { my $C=shift;
do {
if (my ($C) = ($C->_EXACT('Inf'))) {
$C->_PATTERN(qr/\G\b/);
}
else {
();
}
}
},
)[$try])->($C);
last if $xact->[-2];  # committed?
last if @gather;
}
@gather;
};
@result;
}

})
);
}

# <strtonum> is (we hope) used only by Str --> Num conversions
#  (such as those done dwimmily by quotewords)
##     token strtonum__S_200rational (:$*sym = 'rational')
##          token strtonum:rational { <[+\-]>?<nu=.integer>'/'<de=.integer> }

sub strtonum__S_200rational__PEEK { $_[0]->_AUTOLEXpeek('strtonum__S_200rational',$retree) }
sub strtonum__S_200rational {
no warnings 'recursion';
my $self = shift;
local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;
my %args = @_;
local $::sym = $args{sym} // 'rational';


my $C = $self->cursor_xact("RULE strtonum__S_200rational");
my $xact = $C->xact;
my $S = $C->{'_pos'};
$C->{'sym'} = ref $sym ? join(' ', @$sym) : $sym;

$self->_MATCHIFYr($S, "strtonum__S_200rational", 
do {
if (my ($C) = ($C->_PATTERN(qr/\G((?:[+\-])?+)/))) {
do {
if (my ($C) = (  $C->_SUBSUMEr(['nu'], sub {
my $C = shift;
$C->integer
}))) {
do {
if (my ($C) = ($C->_EXACT('/'))) {
$C->_SUBSUMEr(['de'], sub {
my $C = shift;
$C->integer
});
}
else {
();
}
};
}
else {
();
}
};
}
else {
();
}
}
);
}
##     token strtonum__S_201complex (:$*sym = 'complex')
##          token strtonum:complex { [<[+\-]>?<re=.number>]? <[+\-]><im=.number>'\\'?'i' }

sub strtonum__S_201complex__PEEK { $_[0]->_AUTOLEXpeek('strtonum__S_201complex',$retree) }
sub strtonum__S_201complex {
no warnings 'recursion';
my $self = shift;
local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;
my %args = @_;
local $::sym = $args{sym} // 'complex';


my $C = $self->cursor_xact("RULE strtonum__S_201complex");
my $xact = $C->xact;
my $S = $C->{'_pos'};
$C->{'re'} = [];
$C->{'sym'} = ref $sym ? join(' ', @$sym) : $sym;

$self->_MATCHIFYr($S, "strtonum__S_201complex", 
do {
if (my ($C) = ($C->_OPTr(sub { my $C=shift;
$C->_BRACKETr(sub {
my $C=shift;
do {
if (my ($C) = ($C->_PATTERN(qr/\G((?:[+\-])?+)/))) {
$C->_SUBSUMEr(['re'], sub {
my $C = shift;
$C->number
});
}
else {
();
}
}
})
}))) {
do {
if (my ($C) = ($C->_PATTERN(qr/\G[+\-]/))) {
do {
if (my ($C) = (  $C->_SUBSUMEr(['im'], sub {
my $C = shift;
$C->number
}))) {
do {
if (my ($C) = ($C->_OPTr(sub { my $C=shift;
$C->_EXACT('\\')
}))) {
$C->_EXACT('i');
}
else {
();
}
};
}
else {
();
}
};
}
else {
();
}
};
}
else {
();
}
}
);
}
##     token strtonum__S_202number (:$*sym = 'number')
##          token strtonum:number { <[+\-]>?<number> }

sub strtonum__S_202number__PEEK { $_[0]->_AUTOLEXpeek('strtonum__S_202number',$retree) }
sub strtonum__S_202number {
no warnings 'recursion';
my $self = shift;
local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;
my %args = @_;
local $::sym = $args{sym} // 'number';


my $C = $self->cursor_xact("RULE strtonum__S_202number");
my $xact = $C->xact;
my $S = $C->{'_pos'};
$C->{'sym'} = ref $sym ? join(' ', @$sym) : $sym;

$self->_MATCHIFYr($S, "strtonum__S_202number", 
do {
if (my ($C) = ($C->_PATTERN(qr/\G((?:[+\-])?+)/))) {
$C->_SUBSUMEr(['number'], sub {
my $C = shift;
$C->number
});
}
else {
();
}
}
);
}

##########
# Quotes #
##########

##     token sibble ($l, $lang2)
##          token sibble ($l, $lang2) {
##              :my ($lang, $start, $stop);
##              <babble($l)>
##              { my $B = $<babble><B>; ($lang,$start,$stop) = @$B; }
##      
##              $start <left=.nibble($lang)> [ $stop || <.panic: "Couldn't find terminator $stop"> ]
##              [ <?{ $start ne $stop }>
##                  <.ws>
##                  [ <infixish> || <panic: "Missing assignment operator"> ]
##                  [ <?{ $<infixish>.Str eq '=' || $<infixish>.<infix_postfix_meta_operator> }> || <.panic: "Malformed assignment operator"> ]
##                  <.ws>
##                  <right=EXPR(item %item_assignment)>
##              || 
##                  { $lang = $lang2.unbalanced($stop); }
##                  <right=.nibble($lang)> $stop
##              ]
##          }

sub sibble__PEEK { $_[0]->_AUTOLEXpeek('sibble',$retree) }
sub sibble {
no warnings 'recursion';
my $self = shift;
local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;
my $l = shift;
my $lang2 = shift;
my ($lang, $start, $stop);


my $C = $self->cursor_xact("RULE sibble");
my $xact = $C->xact;
my $S = $C->{'_pos'};

$self->_MATCHIFYr($S, "sibble", 
do {
if (my ($C) = ($C->_SUBSUMEr(['babble'], sub {
my $C = shift;
$C->babble($l)
}))) {
do {
if (my ($C) = (scalar(do {
my $M = $C;  my $B = $M->{'babble'}{'B'}; ($lang,$start,$stop) = @$B; ;
}, $C))) {
do {
if (my ($C) = ($C->_EXACT($start))) {
do {
if (my ($C) = (  $C->_SUBSUMEr(['left'], sub {
my $C = shift;
$C->nibble($lang)
}))) {
do {
if (my ($C) = ($C->_BRACKETr(sub {
my $C=shift;
do {
my $C = $C->cursor_xact('ALT ||');
my $xact = $C->xact;
my @gather;
do {
push @gather, $C->_EXACT($stop)
}
or $xact->[-2] or
do {
push @gather, $C->panic("Couldn't find terminator $stop")};
@gather;
}
}))) {
$C->_BRACKETr(sub {
my $C=shift;
do {
my $C = $C->cursor_xact('ALT ||');
my $xact = $C->xact;
my @gather;
do {
push @gather, do {
if (my ($C) = ($C->before( sub { my $C=shift;
(($C) x !!do {
$start ne $stop 
})
}))) {
do {
if (my ($C) = ($C->ws)) {
do {
if (my ($C) = ($C->_BRACKETr(sub {
my $C=shift;
do {
my $C = $C->cursor_xact('ALT ||');
my $xact = $C->xact;
my @gather;
do {
push @gather, $C->_SUBSUMEr(['infixish'], sub {
my $C = shift;
$C->infixish
})
}
or $xact->[-2] or
do {
push @gather, $C->_SUBSUMEr(['panic'], sub {
my $C = shift;
$C->panic("Missing assignment operator")
})};
@gather;
}
}))) {
do {
if (my ($C) = ($C->_BRACKETr(sub {
my $C=shift;
do {
my $C = $C->cursor_xact('ALT ||');
my $xact = $C->xact;
my @gather;
do {
push @gather, $C->before( sub { my $C=shift;
(($C) x !!do {
my $M = $C;  $M->{'infixish'}->Str eq '=' || $M->{'infixish'}->{'infix_postfix_meta_operator'} ;
})
})
}
or $xact->[-2] or
do {
push @gather, $C->panic("Malformed assignment operator")};
@gather;
}
}))) {
do {
if (my ($C) = ($C->ws)) {
$C->_SUBSUMEr(['right','EXPR'], sub {
my $C = shift;
$C->EXPR(\%item_assignment)
});
}
else {
();
}
};
}
else {
();
}
};
}
else {
();
}
};
}
else {
();
}
};
}
else {
();
}
}
}
or $xact->[-2] or
do {
push @gather, do {
if (my ($C) = (scalar(do {
$lang = $lang2->unbalanced($stop); 
}, $C))) {
do {
if (my ($C) = (  $C->_SUBSUMEr(['right'], sub {
my $C = shift;
$C->nibble($lang)
}))) {
$C->_EXACT($stop);
}
else {
();
}
};
}
else {
();
}
}};
@gather;
}
});
}
else {
();
}
};
}
else {
();
}
};
}
else {
();
}
};
}
else {
();
}
};
}
else {
();
}
}
);
}

##     token tribble ($l, $lang2 = $l)
##          token tribble ($l, $lang2 = $l) {
##              :my ($lang, $start, $stop);
##              <babble($l)>
##              { my $B = $<babble><B>; ($lang,$start,$stop) = @$B; }
##      
##              $start <left=.nibble($lang)> [ $stop || <.panic: "Couldn't find terminator $stop"> ]
##              [ <?{ $start ne $stop }>
##                  <.ws> <quibble($lang2)>
##              || 
##                  { $lang = $lang2.unbalanced($stop); }
##                  <right=.nibble($lang)> $stop
##              ]
##          }

sub tribble__PEEK { $_[0]->_AUTOLEXpeek('tribble',$retree) }
sub tribble {
no warnings 'recursion';
my $self = shift;
local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;
my $l = shift;
my $lang2 = shift() // $l;
my ($lang, $start, $stop);


my $C = $self->cursor_xact("RULE tribble");
my $xact = $C->xact;
my $S = $C->{'_pos'};

$self->_MATCHIFYr($S, "tribble", 
do {
if (my ($C) = ($C->_SUBSUMEr(['babble'], sub {
my $C = shift;
$C->babble($l)
}))) {
do {
if (my ($C) = (scalar(do {
my $M = $C;  my $B = $M->{'babble'}{'B'}; ($lang,$start,$stop) = @$B; ;
}, $C))) {
do {
if (my ($C) = ($C->_EXACT($start))) {
do {
if (my ($C) = (  $C->_SUBSUMEr(['left'], sub {
my $C = shift;
$C->nibble($lang)
}))) {
do {
if (my ($C) = ($C->_BRACKETr(sub {
my $C=shift;
do {
my $C = $C->cursor_xact('ALT ||');
my $xact = $C->xact;
my @gather;
do {
push @gather, $C->_EXACT($stop)
}
or $xact->[-2] or
do {
push @gather, $C->panic("Couldn't find terminator $stop")};
@gather;
}
}))) {
$C->_BRACKETr(sub {
my $C=shift;
do {
my $C = $C->cursor_xact('ALT ||');
my $xact = $C->xact;
my @gather;
do {
push @gather, do {
if (my ($C) = ($C->before( sub { my $C=shift;
(($C) x !!do {
$start ne $stop 
})
}))) {
do {
if (my ($C) = ($C->ws)) {
$C->_SUBSUMEr(['quibble'], sub {
my $C = shift;
$C->quibble($lang2)
});
}
else {
();
}
};
}
else {
();
}
}
}
or $xact->[-2] or
do {
push @gather, do {
if (my ($C) = (scalar(do {
$lang = $lang2->unbalanced($stop); 
}, $C))) {
do {
if (my ($C) = (  $C->_SUBSUMEr(['right'], sub {
my $C = shift;
$C->nibble($lang)
}))) {
$C->_EXACT($stop);
}
else {
();
}
};
}
else {
();
}
}};
@gather;
}
});
}
else {
();
}
};
}
else {
();
}
};
}
else {
();
}
};
}
else {
();
}
};
}
else {
();
}
}
);
}

##     token quasiquibble ($l)
##          token quasiquibble ($l) {
##              :temp %*LANG;
##              :my ($lang, $start, $stop);
##              :my $*QUASIMODO = 0; # :COMPILING sets true
##              <babble($l)>
##              {
##                  my $B = $<babble><B>;
##                  ($lang,$start,$stop) = @$B;
##                  %*LANG<MAIN> = $lang;
##              }
##      
##              [
##              || <?{ $start eq '{' }> [ :lang($lang) <block> ]
##              || [ :lang($lang) <starter> <statementlist> [ <stopper> || <.panic: "Couldn't find terminator $stop"> ] ]
##              ]
##          }

sub quasiquibble__PEEK { $_[0]->_AUTOLEXpeek('quasiquibble',$retree) }
sub quasiquibble {
no warnings 'recursion';
my $self = shift;
local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;
my $l = shift;
local %::LANG = %::LANG;
my ($lang, $start, $stop);
local $::QUASIMODO = 0;


my $C = $self->cursor_xact("RULE quasiquibble");
my $xact = $C->xact;
my $S = $C->{'_pos'};

$self->_MATCHIFYr($S, "quasiquibble", 
do {
if (my ($C) = ($C->_SUBSUMEr(['babble'], sub {
my $C = shift;
$C->babble($l)
}))) {
do {
if (my ($C) = (scalar(do {
my $M = $C; 
my $B = $M->{'babble'}{'B'};
($lang,$start,$stop) = @$B;
$::LANG{'MAIN'} = $lang;
;
}, $C))) {
$C->_BRACKETr(sub {
my $C=shift;
do {
my $C = $C->cursor_xact('ALT ||');
my $xact = $C->xact;
my @gather;
do {
push @gather, do {
if (my ($C) = ($C->before( sub { my $C=shift;
(($C) x !!do {
$start eq '{' 
})
}))) {
$C->_BRACKETr(sub {
my $C=shift;
my $newlang = ($lang);  $C = $C->cursor_fresh($newlang); ;$C->_SUBSUMEr(['block'], sub {
my $C = shift;
$C->block
})
});
}
else {
();
}
}
}
or $xact->[-2] or
do {
push @gather, $C->_BRACKETr(sub {
my $C=shift;
my $newlang = ($lang);  $C = $C->cursor_fresh($newlang); ;do {
if (my ($C) = ($C->_SUBSUMEr(['starter'], sub {
my $C = shift;
$C->starter
}))) {
do {
if (my ($C) = ($C->_SUBSUMEr(['statementlist'], sub {
my $C = shift;
$C->statementlist
}))) {
$C->_BRACKETr(sub {
my $C=shift;
do {
my $C = $C->cursor_xact('ALT ||');
my $xact = $C->xact;
my @gather;
do {
push @gather, $C->_SUBSUMEr(['stopper'], sub {
my $C = shift;
$C->stopper
})
}
or $xact->[-2] or
do {
push @gather, $C->panic("Couldn't find terminator $stop")};
@gather;
}
});
}
else {
();
}
};
}
else {
();
}
}
})};
@gather;
}
});
}
else {
();
}
};
}
else {
();
}
}
);
}

##     token quote__S_203SlashSlash (:$*sym = <//>)
##          token quote:sym<//>   {
##              '/'\s*'/' <.panic: "Null regex not allowed">
##          }

sub quote__S_203SlashSlash__PEEK { $_[0]->_AUTOLEXpeek('quote__S_203SlashSlash',$retree) }
sub quote__S_203SlashSlash {
no warnings 'recursion';
my $self = shift;
local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;
my %args = @_;
local $::sym = $args{sym} // q(//);


my $C = $self->cursor_xact("RULE quote__S_203SlashSlash");
my $xact = $C->xact;
my $S = $C->{'_pos'};
$C->{'sym'} = ref $sym ? join(' ', @$sym) : $sym;

$self->_MATCHIFYr($S, "quote__S_203SlashSlash", 
do {
if (my ($C) = ($C->_EXACT('/'))) {
do {
if (my ($C) = ($C->_PATTERN(qr/\G((?:\s)*+)/))) {
do {
if (my ($C) = ($C->_EXACT('/'))) {
$C->panic("Null regex not allowed");
}
else {
();
}
};
}
else {
();
}
};
}
else {
();
}
}
);
}

##     token quote__S_204Slash_Slash (:$*sym = </ />)
##          token quote:sym</ />   {
##              '/' <nibble( $.cursor_fresh( %*LANG<Regex> ).unbalanced("/") )> [ '/' || <.panic: "Unable to parse regex; couldn't find final '/'"> ]
##              <.old_rx_mods>?
##          }

sub quote__S_204Slash_Slash__PEEK { $_[0]->_AUTOLEXpeek('quote__S_204Slash_Slash',$retree) }
sub quote__S_204Slash_Slash {
no warnings 'recursion';
my $self = shift;
local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;
my %args = @_;
local $::sym = $args{sym} // [qw(/ /)];


my $C = $self->cursor_xact("RULE quote__S_204Slash_Slash");
my $xact = $C->xact;
my $S = $C->{'_pos'};
$C->{'sym'} = ref $sym ? join(' ', @$sym) : $sym;

$self->_MATCHIFYr($S, "quote__S_204Slash_Slash", 
do {
if (my ($C) = ($C->_EXACT('/'))) {
do {
if (my ($C) = ($C->_SUBSUMEr(['nibble'], sub {
my $C = shift;
$C->nibble( $C->cursor_fresh( $::LANG{'Regex'} )->unbalanced("/") )
}))) {
do {
if (my ($C) = ($C->_BRACKETr(sub {
my $C=shift;
do {
my $C = $C->cursor_xact('ALT ||');
my $xact = $C->xact;
my @gather;
do {
push @gather, $C->_EXACT('/')
}
or $xact->[-2] or
do {
push @gather, $C->panic("Unable to parse regex; couldn't find final '/'")};
@gather;
}
}))) {
$C->_OPTr(sub { my $C=shift;
$C->old_rx_mods
});
}
else {
();
}
};
}
else {
();
}
};
}
else {
();
}
}
);
}

# handle composite forms like qww
##     token quote__S_205qq (:$*sym = 'qq')
##          token quote:qq {
##              :my $qm;
##              'qq'
##              [
##              | <quote_mod>  <!before '('> { $qm = $<quote_mod>.Str } <.ws> <quibble($.cursor_fresh( %*LANG<Q> ).tweak(:qq).tweak($qm => 1))>
##              |  <!before '('> <.ws> <quibble($.cursor_fresh( %*LANG<Q> ).tweak(:qq))>
##              ]
##          }

sub quote__S_205qq__PEEK { $_[0]->_AUTOLEXpeek('quote__S_205qq',$retree) }
sub quote__S_205qq {
no warnings 'recursion';
my $self = shift;
local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;
my %args = @_;
local $::sym = $args{sym} // 'qq';
my $qm;


my $C = $self->cursor_xact("RULE quote__S_205qq");
my $xact = $C->xact;
my $S = $C->{'_pos'};
$C->{'sym'} = ref $sym ? join(' ', @$sym) : $sym;

$self->_MATCHIFYr($S, "quote__S_205qq", 
do {
if (my ($C) = ($C->_EXACT('qq'))) {
$C->_BRACKETr(sub {
my $C=shift;
do {
my @result = do {
my $trystate;
my ($tag, $try);
my @try;
my $relex;

my $fate;
my $x;
if ($fate = $C->{'_fate'} and $fate->[1] eq 'quote__S_205qq_01') {
$C->deb("Fate passed to quote__S_205qq_01: ", ::fatestr($fate)) if $::DEBUG & DEBUG::fates;
($C->{'_fate'}, $tag, $try) = @$fate;
@try = ($try);
$x = 'ALT quote__S_205qq_01';    # some outer ltm is controlling us
}
else {
$x = 'ALTLTM quote__S_205qq_01'; # we are top level ltm
}
my $C = $C->cursor_xact($x);
my $xact = $C->xact;

my @gather = ();
for (;;) {
if (not @try) {
$relex //= $C->cursor_fate('STD::P6', 'quote__S_205qq_01', $retree);
@try = $relex->($C, $trystate);
}
last unless @try;
$try = shift(@try) // next;

if (ref $try eq 'ARRAY') {
($C->{'_fate'}, $tag, $try) = @$try;	# next candidate fate
}

$C->deb("quote__S_205qq_01 trying $tag $try") if $::DEBUG & DEBUG::try_processing;
push @gather, ((
sub { my $C=shift;
do {
if (my ($C) = ($C->_SUBSUMEr(['quote_mod'], sub {
my $C = shift;
$C->quote_mod
}))) {
do {
if (my ($C) = ($C->_PATTERN(qr/\G\b/))) {
do {
if (my ($C) = ($C->_NOTBEFORE( sub { my $C=shift;
$C->before(sub { my $C=shift;
$C->_EXACT('(')
})
}))) {
do {
if (my ($C) = (scalar(do {
my $M = $C;  $qm = $M->{'quote_mod'}->Str ;
}, $C))) {
do {
if (my ($C) = ($C->ws)) {
$C->_SUBSUMEr(['quibble'], sub {
my $C = shift;
$C->quibble($C->cursor_fresh( $::LANG{'Q'} )->tweak('qq' => 1)->tweak($qm => 1))
});
}
else {
();
}
};
}
else {
();
}
};
}
else {
();
}
};
}
else {
();
}
};
}
else {
();
}
}
},
sub { my $C=shift;
do {
if (my ($C) = ($C->_PATTERN(qr/\G\b/))) {
do {
if (my ($C) = ($C->_NOTBEFORE( sub { my $C=shift;
$C->before(sub { my $C=shift;
$C->_EXACT('(')
})
}))) {
do {
if (my ($C) = ($C->ws)) {
$C->_SUBSUMEr(['quibble'], sub {
my $C = shift;
$C->quibble($C->cursor_fresh( $::LANG{'Q'} )->tweak('qq' => 1))
});
}
else {
();
}
};
}
else {
();
}
};
}
else {
();
}
}
},
)[$try])->($C);
last if $xact->[-2];  # committed?
last if @gather;
}
@gather;
};
@result;
}

});
}
else {
();
}
}
);
}
##     token quote__S_206q (:$*sym = 'q')
##          token quote:q {
##              :my $qm;
##              'q'
##              [
##              | <quote_mod>  <!before '('> { $qm = $<quote_mod>.Str } <quibble($.cursor_fresh( %*LANG<Q> ).tweak(:q).tweak($qm => 1))>
##              |  <!before '('> <.ws> <quibble($.cursor_fresh( %*LANG<Q> ).tweak(:q))>
##              ]
##          }

sub quote__S_206q__PEEK { $_[0]->_AUTOLEXpeek('quote__S_206q',$retree) }
sub quote__S_206q {
no warnings 'recursion';
my $self = shift;
local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;
my %args = @_;
local $::sym = $args{sym} // 'q';
my $qm;


my $C = $self->cursor_xact("RULE quote__S_206q");
my $xact = $C->xact;
my $S = $C->{'_pos'};
$C->{'sym'} = ref $sym ? join(' ', @$sym) : $sym;

$self->_MATCHIFYr($S, "quote__S_206q", 
do {
if (my ($C) = ($C->_EXACT('q'))) {
$C->_BRACKETr(sub {
my $C=shift;
do {
my @result = do {
my $trystate;
my ($tag, $try);
my @try;
my $relex;

my $fate;
my $x;
if ($fate = $C->{'_fate'} and $fate->[1] eq 'quote__S_206q_01') {
$C->deb("Fate passed to quote__S_206q_01: ", ::fatestr($fate)) if $::DEBUG & DEBUG::fates;
($C->{'_fate'}, $tag, $try) = @$fate;
@try = ($try);
$x = 'ALT quote__S_206q_01';    # some outer ltm is controlling us
}
else {
$x = 'ALTLTM quote__S_206q_01'; # we are top level ltm
}
my $C = $C->cursor_xact($x);
my $xact = $C->xact;

my @gather = ();
for (;;) {
if (not @try) {
$relex //= $C->cursor_fate('STD::P6', 'quote__S_206q_01', $retree);
@try = $relex->($C, $trystate);
}
last unless @try;
$try = shift(@try) // next;

if (ref $try eq 'ARRAY') {
($C->{'_fate'}, $tag, $try) = @$try;	# next candidate fate
}

$C->deb("quote__S_206q_01 trying $tag $try") if $::DEBUG & DEBUG::try_processing;
push @gather, ((
sub { my $C=shift;
do {
if (my ($C) = ($C->_SUBSUMEr(['quote_mod'], sub {
my $C = shift;
$C->quote_mod
}))) {
do {
if (my ($C) = ($C->_PATTERN(qr/\G\b/))) {
do {
if (my ($C) = ($C->_NOTBEFORE( sub { my $C=shift;
$C->before(sub { my $C=shift;
$C->_EXACT('(')
})
}))) {
do {
if (my ($C) = (scalar(do {
my $M = $C;  $qm = $M->{'quote_mod'}->Str ;
}, $C))) {
$C->_SUBSUMEr(['quibble'], sub {
my $C = shift;
$C->quibble($C->cursor_fresh( $::LANG{'Q'} )->tweak('q' => 1)->tweak($qm => 1))
});
}
else {
();
}
};
}
else {
();
}
};
}
else {
();
}
};
}
else {
();
}
}
},
sub { my $C=shift;
do {
if (my ($C) = ($C->_PATTERN(qr/\G\b/))) {
do {
if (my ($C) = ($C->_NOTBEFORE( sub { my $C=shift;
$C->before(sub { my $C=shift;
$C->_EXACT('(')
})
}))) {
do {
if (my ($C) = ($C->ws)) {
$C->_SUBSUMEr(['quibble'], sub {
my $C = shift;
$C->quibble($C->cursor_fresh( $::LANG{'Q'} )->tweak('q' => 1))
});
}
else {
();
}
};
}
else {
();
}
};
}
else {
();
}
}
},
)[$try])->($C);
last if $xact->[-2];  # committed?
last if @gather;
}
@gather;
};
@result;
}

});
}
else {
();
}
}
);
}

##     token quote__S_207Q (:$*sym = 'Q')
##          token quote:Q {
##              :my $qm;
##              'Q'
##              [
##              | <quote_mod>  <!before '('> { $qm = $<quote_mod>.Str } <quibble($.cursor_fresh( %*LANG<Q> ).tweak($qm => 1))>
##              |  <!before '('> <.ws> <quibble($.cursor_fresh( %*LANG<Q> ))>
##              ]
##          }

sub quote__S_207Q__PEEK { $_[0]->_AUTOLEXpeek('quote__S_207Q',$retree) }
sub quote__S_207Q {
no warnings 'recursion';
my $self = shift;
local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;
my %args = @_;
local $::sym = $args{sym} // 'Q';
my $qm;


my $C = $self->cursor_xact("RULE quote__S_207Q");
my $xact = $C->xact;
my $S = $C->{'_pos'};
$C->{'sym'} = ref $sym ? join(' ', @$sym) : $sym;

$self->_MATCHIFYr($S, "quote__S_207Q", 
do {
if (my ($C) = ($C->_EXACT('Q'))) {
$C->_BRACKETr(sub {
my $C=shift;
do {
my @result = do {
my $trystate;
my ($tag, $try);
my @try;
my $relex;

my $fate;
my $x;
if ($fate = $C->{'_fate'} and $fate->[1] eq 'quote__S_207Q_01') {
$C->deb("Fate passed to quote__S_207Q_01: ", ::fatestr($fate)) if $::DEBUG & DEBUG::fates;
($C->{'_fate'}, $tag, $try) = @$fate;
@try = ($try);
$x = 'ALT quote__S_207Q_01';    # some outer ltm is controlling us
}
else {
$x = 'ALTLTM quote__S_207Q_01'; # we are top level ltm
}
my $C = $C->cursor_xact($x);
my $xact = $C->xact;

my @gather = ();
for (;;) {
if (not @try) {
$relex //= $C->cursor_fate('STD::P6', 'quote__S_207Q_01', $retree);
@try = $relex->($C, $trystate);
}
last unless @try;
$try = shift(@try) // next;

if (ref $try eq 'ARRAY') {
($C->{'_fate'}, $tag, $try) = @$try;	# next candidate fate
}

$C->deb("quote__S_207Q_01 trying $tag $try") if $::DEBUG & DEBUG::try_processing;
push @gather, ((
sub { my $C=shift;
do {
if (my ($C) = ($C->_SUBSUMEr(['quote_mod'], sub {
my $C = shift;
$C->quote_mod
}))) {
do {
if (my ($C) = ($C->_PATTERN(qr/\G\b/))) {
do {
if (my ($C) = ($C->_NOTBEFORE( sub { my $C=shift;
$C->before(sub { my $C=shift;
$C->_EXACT('(')
})
}))) {
do {
if (my ($C) = (scalar(do {
my $M = $C;  $qm = $M->{'quote_mod'}->Str ;
}, $C))) {
$C->_SUBSUMEr(['quibble'], sub {
my $C = shift;
$C->quibble($C->cursor_fresh( $::LANG{'Q'} )->tweak($qm => 1))
});
}
else {
();
}
};
}
else {
();
}
};
}
else {
();
}
};
}
else {
();
}
}
},
sub { my $C=shift;
do {
if (my ($C) = ($C->_PATTERN(qr/\G\b/))) {
do {
if (my ($C) = ($C->_NOTBEFORE( sub { my $C=shift;
$C->before(sub { my $C=shift;
$C->_EXACT('(')
})
}))) {
do {
if (my ($C) = ($C->ws)) {
$C->_SUBSUMEr(['quibble'], sub {
my $C = shift;
$C->quibble($C->cursor_fresh( $::LANG{'Q'} ))
});
}
else {
();
}
};
}
else {
();
}
};
}
else {
();
}
}
},
)[$try])->($C);
last if $xact->[-2];  # committed?
last if @gather;
}
@gather;
};
@result;
}

});
}
else {
();
}
}
);
}

##     token quote_mod__S_208w (:$*sym = 'w')
##          token quote_mod:w  { <sym> }

sub quote_mod__S_208w__PEEK { $_[0]->_AUTOLEXpeek('quote_mod__S_208w',$retree) }
sub quote_mod__S_208w {
no warnings 'recursion';
my $self = shift;
local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;
my %args = @_;
local $::sym = $args{sym} // 'w';


my $C = $self->cursor_xact("RULE quote_mod__S_208w");
my $xact = $C->xact;
my $S = $C->{'_pos'};
$C->{'sym'} = ref $sym ? join(' ', @$sym) : $sym;

$self->_MATCHIFYr($S, "quote_mod__S_208w", 
$C->_PATTERN(qr/\Gw/)
);
}
##     token quote_mod__S_209ww (:$*sym = 'ww')
##          token quote_mod:ww { <sym> }

sub quote_mod__S_209ww__PEEK { $_[0]->_AUTOLEXpeek('quote_mod__S_209ww',$retree) }
sub quote_mod__S_209ww {
no warnings 'recursion';
my $self = shift;
local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;
my %args = @_;
local $::sym = $args{sym} // 'ww';


my $C = $self->cursor_xact("RULE quote_mod__S_209ww");
my $xact = $C->xact;
my $S = $C->{'_pos'};
$C->{'sym'} = ref $sym ? join(' ', @$sym) : $sym;

$self->_MATCHIFYr($S, "quote_mod__S_209ww", 
$C->_PATTERN(qr/\Gww/)
);
}
##     token quote_mod__S_210p (:$*sym = 'p')
##          token quote_mod:p  { <sym> }

sub quote_mod__S_210p__PEEK { $_[0]->_AUTOLEXpeek('quote_mod__S_210p',$retree) }
sub quote_mod__S_210p {
no warnings 'recursion';
my $self = shift;
local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;
my %args = @_;
local $::sym = $args{sym} // 'p';


my $C = $self->cursor_xact("RULE quote_mod__S_210p");
my $xact = $C->xact;
my $S = $C->{'_pos'};
$C->{'sym'} = ref $sym ? join(' ', @$sym) : $sym;

$self->_MATCHIFYr($S, "quote_mod__S_210p", 
$C->_PATTERN(qr/\Gp/)
);
}
##     token quote_mod__S_211x (:$*sym = 'x')
##          token quote_mod:x  { <sym> }

sub quote_mod__S_211x__PEEK { $_[0]->_AUTOLEXpeek('quote_mod__S_211x',$retree) }
sub quote_mod__S_211x {
no warnings 'recursion';
my $self = shift;
local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;
my %args = @_;
local $::sym = $args{sym} // 'x';


my $C = $self->cursor_xact("RULE quote_mod__S_211x");
my $xact = $C->xact;
my $S = $C->{'_pos'};
$C->{'sym'} = ref $sym ? join(' ', @$sym) : $sym;

$self->_MATCHIFYr($S, "quote_mod__S_211x", 
$C->_PATTERN(qr/\Gx/)
);
}
##     token quote_mod__S_212to (:$*sym = 'to')
##          token quote_mod:to { <sym> }

sub quote_mod__S_212to__PEEK { $_[0]->_AUTOLEXpeek('quote_mod__S_212to',$retree) }
sub quote_mod__S_212to {
no warnings 'recursion';
my $self = shift;
local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;
my %args = @_;
local $::sym = $args{sym} // 'to';


my $C = $self->cursor_xact("RULE quote_mod__S_212to");
my $xact = $C->xact;
my $S = $C->{'_pos'};
$C->{'sym'} = ref $sym ? join(' ', @$sym) : $sym;

$self->_MATCHIFYr($S, "quote_mod__S_212to", 
$C->_PATTERN(qr/\Gto/)
);
}
##     token quote_mod__S_213s (:$*sym = 's')
##          token quote_mod:s  { <sym> }

sub quote_mod__S_213s__PEEK { $_[0]->_AUTOLEXpeek('quote_mod__S_213s',$retree) }
sub quote_mod__S_213s {
no warnings 'recursion';
my $self = shift;
local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;
my %args = @_;
local $::sym = $args{sym} // 's';


my $C = $self->cursor_xact("RULE quote_mod__S_213s");
my $xact = $C->xact;
my $S = $C->{'_pos'};
$C->{'sym'} = ref $sym ? join(' ', @$sym) : $sym;

$self->_MATCHIFYr($S, "quote_mod__S_213s", 
$C->_PATTERN(qr/\Gs/)
);
}
##     token quote_mod__S_214a (:$*sym = 'a')
##          token quote_mod:a  { <sym> }

sub quote_mod__S_214a__PEEK { $_[0]->_AUTOLEXpeek('quote_mod__S_214a',$retree) }
sub quote_mod__S_214a {
no warnings 'recursion';
my $self = shift;
local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;
my %args = @_;
local $::sym = $args{sym} // 'a';


my $C = $self->cursor_xact("RULE quote_mod__S_214a");
my $xact = $C->xact;
my $S = $C->{'_pos'};
$C->{'sym'} = ref $sym ? join(' ', @$sym) : $sym;

$self->_MATCHIFYr($S, "quote_mod__S_214a", 
$C->_PATTERN(qr/\Ga/)
);
}
##     token quote_mod__S_215h (:$*sym = 'h')
##          token quote_mod:h  { <sym> }

sub quote_mod__S_215h__PEEK { $_[0]->_AUTOLEXpeek('quote_mod__S_215h',$retree) }
sub quote_mod__S_215h {
no warnings 'recursion';
my $self = shift;
local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;
my %args = @_;
local $::sym = $args{sym} // 'h';


my $C = $self->cursor_xact("RULE quote_mod__S_215h");
my $xact = $C->xact;
my $S = $C->{'_pos'};
$C->{'sym'} = ref $sym ? join(' ', @$sym) : $sym;

$self->_MATCHIFYr($S, "quote_mod__S_215h", 
$C->_PATTERN(qr/\Gh/)
);
}
##     token quote_mod__S_216f (:$*sym = 'f')
##          token quote_mod:f  { <sym> }

sub quote_mod__S_216f__PEEK { $_[0]->_AUTOLEXpeek('quote_mod__S_216f',$retree) }
sub quote_mod__S_216f {
no warnings 'recursion';
my $self = shift;
local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;
my %args = @_;
local $::sym = $args{sym} // 'f';


my $C = $self->cursor_xact("RULE quote_mod__S_216f");
my $xact = $C->xact;
my $S = $C->{'_pos'};
$C->{'sym'} = ref $sym ? join(' ', @$sym) : $sym;

$self->_MATCHIFYr($S, "quote_mod__S_216f", 
$C->_PATTERN(qr/\Gf/)
);
}
##     token quote_mod__S_217c (:$*sym = 'c')
##          token quote_mod:c  { <sym> }

sub quote_mod__S_217c__PEEK { $_[0]->_AUTOLEXpeek('quote_mod__S_217c',$retree) }
sub quote_mod__S_217c {
no warnings 'recursion';
my $self = shift;
local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;
my %args = @_;
local $::sym = $args{sym} // 'c';


my $C = $self->cursor_xact("RULE quote_mod__S_217c");
my $xact = $C->xact;
my $S = $C->{'_pos'};
$C->{'sym'} = ref $sym ? join(' ', @$sym) : $sym;

$self->_MATCHIFYr($S, "quote_mod__S_217c", 
$C->_PATTERN(qr/\Gc/)
);
}
##     token quote_mod__S_218b (:$*sym = 'b')
##          token quote_mod:b  { <sym> }

sub quote_mod__S_218b__PEEK { $_[0]->_AUTOLEXpeek('quote_mod__S_218b',$retree) }
sub quote_mod__S_218b {
no warnings 'recursion';
my $self = shift;
local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;
my %args = @_;
local $::sym = $args{sym} // 'b';


my $C = $self->cursor_xact("RULE quote_mod__S_218b");
my $xact = $C->xact;
my $S = $C->{'_pos'};
$C->{'sym'} = ref $sym ? join(' ', @$sym) : $sym;

$self->_MATCHIFYr($S, "quote_mod__S_218b", 
$C->_PATTERN(qr/\Gb/)
);
}

##     token quote__S_219rx (:$*sym = 'rx')
##          token quote:rx {
##              <sym>  <!before '('>
##              <quibble( $.cursor_fresh( %*LANG<Regex> ) )>
##              <!old_rx_mods>
##          }

sub quote__S_219rx__PEEK { $_[0]->_AUTOLEXpeek('quote__S_219rx',$retree) }
sub quote__S_219rx {
no warnings 'recursion';
my $self = shift;
local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;
my %args = @_;
local $::sym = $args{sym} // 'rx';


my $C = $self->cursor_xact("RULE quote__S_219rx");
my $xact = $C->xact;
my $S = $C->{'_pos'};
$C->{'sym'} = ref $sym ? join(' ', @$sym) : $sym;

$self->_MATCHIFYr($S, "quote__S_219rx", 
do {
if (my ($C) = ($C->_PATTERN(qr/\Grx/))) {
do {
if (my ($C) = ($C->_PATTERN(qr/\G\b/))) {
do {
if (my ($C) = ($C->_NOTBEFORE( sub { my $C=shift;
$C->before(sub { my $C=shift;
$C->_EXACT('(')
})
}))) {
do {
if (my ($C) = ($C->_SUBSUMEr(['quibble'], sub {
my $C = shift;
$C->quibble( $C->cursor_fresh( $::LANG{'Regex'} ) )
}))) {
$C->_NOTBEFORE( sub { my $C=shift;
$C->old_rx_mods
});
}
else {
();
}
};
}
else {
();
}
};
}
else {
();
}
};
}
else {
();
}
}
);
}

##     token quote__S_220m (:$*sym = 'm')
##          token quote:m  {
##              <sym>  <!before '('>
##              <quibble( $.cursor_fresh( %*LANG<Regex> ) )>
##              <!old_rx_mods>
##          }

sub quote__S_220m__PEEK { $_[0]->_AUTOLEXpeek('quote__S_220m',$retree) }
sub quote__S_220m {
no warnings 'recursion';
my $self = shift;
local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;
my %args = @_;
local $::sym = $args{sym} // 'm';


my $C = $self->cursor_xact("RULE quote__S_220m");
my $xact = $C->xact;
my $S = $C->{'_pos'};
$C->{'sym'} = ref $sym ? join(' ', @$sym) : $sym;

$self->_MATCHIFYr($S, "quote__S_220m", 
do {
if (my ($C) = ($C->_PATTERN(qr/\Gm/))) {
do {
if (my ($C) = ($C->_PATTERN(qr/\G\b/))) {
do {
if (my ($C) = ($C->_NOTBEFORE( sub { my $C=shift;
$C->before(sub { my $C=shift;
$C->_EXACT('(')
})
}))) {
do {
if (my ($C) = ($C->_SUBSUMEr(['quibble'], sub {
my $C = shift;
$C->quibble( $C->cursor_fresh( $::LANG{'Regex'} ) )
}))) {
$C->_NOTBEFORE( sub { my $C=shift;
$C->old_rx_mods
});
}
else {
();
}
};
}
else {
();
}
};
}
else {
();
}
};
}
else {
();
}
}
);
}

##     token quote__S_221mm (:$*sym = 'mm')
##          token quote:mm {
##              <sym>  <!before '('>
##              <quibble( $.cursor_fresh( %*LANG<Regex> ).tweak(:s))>
##              <!old_rx_mods>
##          }

sub quote__S_221mm__PEEK { $_[0]->_AUTOLEXpeek('quote__S_221mm',$retree) }
sub quote__S_221mm {
no warnings 'recursion';
my $self = shift;
local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;
my %args = @_;
local $::sym = $args{sym} // 'mm';


my $C = $self->cursor_xact("RULE quote__S_221mm");
my $xact = $C->xact;
my $S = $C->{'_pos'};
$C->{'sym'} = ref $sym ? join(' ', @$sym) : $sym;

$self->_MATCHIFYr($S, "quote__S_221mm", 
do {
if (my ($C) = ($C->_PATTERN(qr/\Gmm/))) {
do {
if (my ($C) = ($C->_PATTERN(qr/\G\b/))) {
do {
if (my ($C) = ($C->_NOTBEFORE( sub { my $C=shift;
$C->before(sub { my $C=shift;
$C->_EXACT('(')
})
}))) {
do {
if (my ($C) = ($C->_SUBSUMEr(['quibble'], sub {
my $C = shift;
$C->quibble( $C->cursor_fresh( $::LANG{'Regex'} )->tweak('s' => 1))
}))) {
$C->_NOTBEFORE( sub { my $C=shift;
$C->old_rx_mods
});
}
else {
();
}
};
}
else {
();
}
};
}
else {
();
}
};
}
else {
();
}
}
);
}

##     token quote__S_222s (:$*sym = 's')
##          token quote:s {
##              <sym>  <!before '('>
##              <pat=.sibble( $.cursor_fresh( %*LANG<Regex> ), $.cursor_fresh( %*LANG<Q> ).tweak(:qq))>
##              <!old_rx_mods>
##          }

sub quote__S_222s__PEEK { $_[0]->_AUTOLEXpeek('quote__S_222s',$retree) }
sub quote__S_222s {
no warnings 'recursion';
my $self = shift;
local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;
my %args = @_;
local $::sym = $args{sym} // 's';


my $C = $self->cursor_xact("RULE quote__S_222s");
my $xact = $C->xact;
my $S = $C->{'_pos'};
$C->{'sym'} = ref $sym ? join(' ', @$sym) : $sym;

$self->_MATCHIFYr($S, "quote__S_222s", 
do {
if (my ($C) = ($C->_PATTERN(qr/\Gs/))) {
do {
if (my ($C) = ($C->_PATTERN(qr/\G\b/))) {
do {
if (my ($C) = ($C->_NOTBEFORE( sub { my $C=shift;
$C->before(sub { my $C=shift;
$C->_EXACT('(')
})
}))) {
do {
if (my ($C) = (  $C->_SUBSUMEr(['pat'], sub {
my $C = shift;
$C->sibble( $C->cursor_fresh( $::LANG{'Regex'} ), $C->cursor_fresh( $::LANG{'Q'} )->tweak('qq' => 1))
}))) {
$C->_NOTBEFORE( sub { my $C=shift;
$C->old_rx_mods
});
}
else {
();
}
};
}
else {
();
}
};
}
else {
();
}
};
}
else {
();
}
}
);
}

##     token quote__S_223ss (:$*sym = 'ss')
##          token quote:ss {
##              <sym>  <!before '('>
##              <pat=.sibble( $.cursor_fresh( %*LANG<Regex> ).tweak(:s), $.cursor_fresh( %*LANG<Q> ).tweak(:qq))>
##              <!old_rx_mods>
##          }

sub quote__S_223ss__PEEK { $_[0]->_AUTOLEXpeek('quote__S_223ss',$retree) }
sub quote__S_223ss {
no warnings 'recursion';
my $self = shift;
local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;
my %args = @_;
local $::sym = $args{sym} // 'ss';


my $C = $self->cursor_xact("RULE quote__S_223ss");
my $xact = $C->xact;
my $S = $C->{'_pos'};
$C->{'sym'} = ref $sym ? join(' ', @$sym) : $sym;

$self->_MATCHIFYr($S, "quote__S_223ss", 
do {
if (my ($C) = ($C->_PATTERN(qr/\Gss/))) {
do {
if (my ($C) = ($C->_PATTERN(qr/\G\b/))) {
do {
if (my ($C) = ($C->_NOTBEFORE( sub { my $C=shift;
$C->before(sub { my $C=shift;
$C->_EXACT('(')
})
}))) {
do {
if (my ($C) = (  $C->_SUBSUMEr(['pat'], sub {
my $C = shift;
$C->sibble( $C->cursor_fresh( $::LANG{'Regex'} )->tweak('s' => 1), $C->cursor_fresh( $::LANG{'Q'} )->tweak('qq' => 1))
}))) {
$C->_NOTBEFORE( sub { my $C=shift;
$C->old_rx_mods
});
}
else {
();
}
};
}
else {
();
}
};
}
else {
();
}
};
}
else {
();
}
}
);
}
##     token quote__S_224tr (:$*sym = 'tr')
##          token quote:tr {
##              <sym>  <!before '('> <pat=.tribble( $.cursor_fresh( %*LANG<Q> ).tweak(:tr))>
##              <!old_tr_mods>
##          }

sub quote__S_224tr__PEEK { $_[0]->_AUTOLEXpeek('quote__S_224tr',$retree) }
sub quote__S_224tr {
no warnings 'recursion';
my $self = shift;
local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;
my %args = @_;
local $::sym = $args{sym} // 'tr';


my $C = $self->cursor_xact("RULE quote__S_224tr");
my $xact = $C->xact;
my $S = $C->{'_pos'};
$C->{'sym'} = ref $sym ? join(' ', @$sym) : $sym;

$self->_MATCHIFYr($S, "quote__S_224tr", 
do {
if (my ($C) = ($C->_PATTERN(qr/\Gtr/))) {
do {
if (my ($C) = ($C->_PATTERN(qr/\G\b/))) {
do {
if (my ($C) = ($C->_NOTBEFORE( sub { my $C=shift;
$C->before(sub { my $C=shift;
$C->_EXACT('(')
})
}))) {
do {
if (my ($C) = (  $C->_SUBSUMEr(['pat'], sub {
my $C = shift;
$C->tribble( $C->cursor_fresh( $::LANG{'Q'} )->tweak('tr' => 1))
}))) {
$C->_NOTBEFORE( sub { my $C=shift;
$C->old_tr_mods
});
}
else {
();
}
};
}
else {
();
}
};
}
else {
();
}
};
}
else {
();
}
}
);
}

##     token quote__S_225y (:$*sym = 'y')
##          token quote:y {
##              <sym> 
##              # could be defined as a function or constant
##              <!{ self.is_known('&y') or self.is_known('y') }>
##              <!before '('> <?before \h*\W>
##              <.obs('y///','tr///')>
##          }

sub quote__S_225y__PEEK { $_[0]->_AUTOLEXpeek('quote__S_225y',$retree) }
sub quote__S_225y {
no warnings 'recursion';
my $self = shift;
local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;
my %args = @_;
local $::sym = $args{sym} // 'y';


my $C = $self->cursor_xact("RULE quote__S_225y");
my $xact = $C->xact;
my $S = $C->{'_pos'};
$C->{'sym'} = ref $sym ? join(' ', @$sym) : $sym;

$self->_MATCHIFYr($S, "quote__S_225y", 
do {
if (my ($C) = ($C->_PATTERN(qr/\Gy/))) {
do {
if (my ($C) = ($C->_PATTERN(qr/\G\b/))) {
do {
if (my ($C) = ($C->_NOTBEFORE( sub { my $C=shift;
(($C) x !!do {
$self->is_known('&y') or $self->is_known('y') 
})
}))) {
do {
if (my ($C) = ($C->_NOTBEFORE( sub { my $C=shift;
$C->before(sub { my $C=shift;
$C->_EXACT('(')
})
}))) {
do {
if (my ($C) = ($C->before(sub { my $C=shift;
do {
if (my ($C) = ($C->_PATTERN(qr/\G((?:[\x20\t\r])*+)/))) {
$C->_NOTCHAR( sub { my $C=shift;
$C->_PATTERN(qr/\G\w/)
});
}
else {
();
}
}
}))) {
$C->obs('y///','tr///');
}
else {
();
}
};
}
else {
();
}
};
}
else {
();
}
};
}
else {
();
}
};
}
else {
();
}
}
);
}

##     token old_rx_mods
##          token old_rx_mods {
##              <!after \s>
##              (< i g s m x c e >+) 
##              {{
##                  given $0.Str {
##                      $_ ~~ /i/ and $.worryobs('/i',':i');
##                      $_ ~~ /g/ and $.worryobs('/g',':g');
##                      $_ ~~ /s/ and $.worryobs('/s','^^ and $$ anchors');
##                      $_ ~~ /m/ and $.worryobs('/m','. or \N');
##                      $_ ~~ /x/ and $.worryobs('/x','normal default whitespace');
##                      $_ ~~ /c/ and $.worryobs('/c',':c or :p');
##                      $_ ~~ /e/ and $.worryobs('/e','interpolated {...} or s{} = ... form');
##                      $.obs('suffix regex modifiers','prefix adverbs');
##                  }
##              }}
##          }

sub old_rx_mods__PEEK { $_[0]->_AUTOLEXpeek('old_rx_mods',$retree) }
sub old_rx_mods {
no warnings 'recursion';
my $self = shift;
local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;


my $C = $self->cursor_xact("RULE old_rx_mods");
my $xact = $C->xact;
my $S = $C->{'_pos'};

$self->_MATCHIFYr($S, "old_rx_mods", 
do {
if (my ($C) = ($C->_NOTBEFORE( sub { my $C=shift;
$C->after(sub { my $C=shift;
$C->_PATTERN(qr/\G(?<=\s)/)
})
}))) {
do {
if (my ($C) = (  $C->_SUBSUMEr(['0'], sub {
my $C = shift;
do { $C->_PAREN( sub { my $C=shift;
$C->_PLUSr(sub { my $C=shift;
$C->_ARRAY( qw< i g s m x c e > )
})
})}
}))) {
scalar(do {

given ($C->{'0'}->Str) {
$_ =~ qr/i/ and $C->worryobs('/i',':i');
$_ =~ qr/g/ and $C->worryobs('/g',':g');
$_ =~ qr/s/ and $C->worryobs('/s','^^ and $$ anchors');
$_ =~ qr/m/ and $C->worryobs('/m','. or \N');
$_ =~ qr/x/ and $C->worryobs('/x','normal default whitespace');
$_ =~ qr/c/ and $C->worryobs('/c',':c or :p');
$_ =~ qr/e/ and $C->worryobs('/e','interpolated {...} or s{} = ... form');
$C->obs('suffix regex modifiers','prefix adverbs');
};

}, $C);
}
else {
();
}
};
}
else {
();
}
}
);
}

##     token old_tr_mods
##          token old_tr_mods {
##              (< c d s ] >+) 
##              {{
##                  given $0.Str {
##                      $_ ~~ /c/ and $.worryobs('/c',':c');
##                      $_ ~~ /d/ and $.worryobs('/g',':d');
##                      $_ ~~ /s/ and $.worryobs('/s',':s');
##                      $.obs('suffix transliteration modifiers','prefix adverbs');
##                  }
##              }}
##          }

sub old_tr_mods__PEEK { $_[0]->_AUTOLEXpeek('old_tr_mods',$retree) }
sub old_tr_mods {
no warnings 'recursion';
my $self = shift;
local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;


my $C = $self->cursor_xact("RULE old_tr_mods");
my $xact = $C->xact;
my $S = $C->{'_pos'};

$self->_MATCHIFYr($S, "old_tr_mods", 
do {
if (my ($C) = (  $C->_SUBSUMEr(['0'], sub {
my $C = shift;
do { $C->_PAREN( sub { my $C=shift;
$C->_PLUSr(sub { my $C=shift;
$C->_ARRAY( qw< c d s ] > )
})
})}
}))) {
scalar(do {

given ($C->{'0'}->Str) {
$_ =~ qr/c/ and $C->worryobs('/c',':c');
$_ =~ qr/d/ and $C->worryobs('/g',':d');
$_ =~ qr/s/ and $C->worryobs('/s',':s');
$C->obs('suffix transliteration modifiers','prefix adverbs');
};

}, $C);
}
else {
();
}
}
);
}

##     token quote__S_226quasi (:$*sym = 'quasi')
##          token quote:quasi {
##              <sym>  <!before '('> <quasiquibble($.cursor_fresh( %*LANG<Quasi> ))>
##          }

sub quote__S_226quasi__PEEK { $_[0]->_AUTOLEXpeek('quote__S_226quasi',$retree) }
sub quote__S_226quasi {
no warnings 'recursion';
my $self = shift;
local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;
my %args = @_;
local $::sym = $args{sym} // 'quasi';


my $C = $self->cursor_xact("RULE quote__S_226quasi");
my $xact = $C->xact;
my $S = $C->{'_pos'};
$C->{'sym'} = ref $sym ? join(' ', @$sym) : $sym;

$self->_MATCHIFYr($S, "quote__S_226quasi", 
do {
if (my ($C) = ($C->_PATTERN(qr/\Gquasi/))) {
do {
if (my ($C) = ($C->_PATTERN(qr/\G\b/))) {
do {
if (my ($C) = ($C->_NOTBEFORE( sub { my $C=shift;
$C->before(sub { my $C=shift;
$C->_EXACT('(')
})
}))) {
$C->_SUBSUMEr(['quasiquibble'], sub {
my $C = shift;
$C->quasiquibble($C->cursor_fresh( $::LANG{'Quasi'} ))
});
}
else {
();
}
};
}
else {
();
}
};
}
else {
();
}
}
);
}

###########################
# Captures and Signatures #
###########################

##     token capterm
##          token capterm {
##              '\\'
##              [
##              | '(' <capture>? ')'
##              | <?before \S> <termish>
##              | {} <.panic: "You can't backslash that">
##              ]
##          }

sub capterm__PEEK { $_[0]->_AUTOLEXpeek('capterm',$retree) }
sub capterm {
no warnings 'recursion';
my $self = shift;
local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;


my $C = $self->cursor_xact("RULE capterm");
my $xact = $C->xact;
my $S = $C->{'_pos'};
$C->{'capture'} = [];

$self->_MATCHIFYr($S, "capterm", 
do {
if (my ($C) = ($C->_EXACT('\\'))) {
$C->_BRACKETr(sub {
my $C=shift;
do {
my @result = do {
my $trystate;
my ($tag, $try);
my @try;
my $relex;

my $fate;
my $x;
if ($fate = $C->{'_fate'} and $fate->[1] eq 'capterm_01') {
$C->deb("Fate passed to capterm_01: ", ::fatestr($fate)) if $::DEBUG & DEBUG::fates;
($C->{'_fate'}, $tag, $try) = @$fate;
@try = ($try);
$x = 'ALT capterm_01';    # some outer ltm is controlling us
}
else {
$x = 'ALTLTM capterm_01'; # we are top level ltm
}
my $C = $C->cursor_xact($x);
my $xact = $C->xact;

my @gather = ();
for (;;) {
if (not @try) {
$relex //= $C->cursor_fate('STD::P6', 'capterm_01', $retree);
@try = $relex->($C, $trystate);
}
last unless @try;
$try = shift(@try) // next;

if (ref $try eq 'ARRAY') {
($C->{'_fate'}, $tag, $try) = @$try;	# next candidate fate
}

$C->deb("capterm_01 trying $tag $try") if $::DEBUG & DEBUG::try_processing;
push @gather, ((
sub { my $C=shift;
do {
if (my ($C) = ($C->_EXACT('('))) {
do {
if (my ($C) = ($C->_OPTr(sub { my $C=shift;
$C->_SUBSUMEr(['capture'], sub {
my $C = shift;
$C->capture
})
}))) {
$C->_EXACT(')');
}
else {
();
}
};
}
else {
();
}
}
},
sub { my $C=shift;
do {
if (my ($C) = ($C->before(sub { my $C=shift;
$C->_NOTCHAR( sub { my $C=shift;
$C->_PATTERN(qr/\G\s/)
})
}))) {
$C->_SUBSUMEr(['termish'], sub {
my $C = shift;
$C->termish
});
}
else {
();
}
}
},
sub { my $C=shift;
do {
if (my ($C) = (scalar(do {

}, $C))) {
$C->panic("You can't backslash that");
}
else {
();
}
}
},
)[$try])->($C);
last if $xact->[-2];  # committed?
last if @gather;
}
@gather;
};
@result;
}

});
}
else {
();
}
}
);
}

##     rule capture
##          rule capture {
##              :my $*INVOCANT_OK = 1;
##              <EXPR>
##          }

sub capture__PEEK { $_[0]->_AUTOLEXpeek('capture',$retree) }
sub capture {
no warnings 'recursion';
my $self = shift;
local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;
local $::INVOCANT_OK = 1;


my $C = $self->cursor_xact("RULE capture");
my $xact = $C->xact;
my $S = $C->{'_pos'};

$self->_MATCHIFYr($S, "capture", 
do {
if (my ($C) = ($C->ws)) {
do {
if (my ($C) = ($C->_SUBSUMEr(['EXPR'], sub {
my $C = shift;
$C->EXPR
}))) {
$C->ws;
}
else {
();
}
};
}
else {
();
}
}
);
}

##     token sigterm
##          token sigterm {
##              :dba('signature')
##              ':(' ~ ')' <fakesignature>
##          }

sub sigterm__PEEK { $_[0]->_AUTOLEXpeek('sigterm',$retree) }
sub sigterm {
no warnings 'recursion';
my $self = shift;
local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;


my $C = $self->cursor_xact("RULE sigterm");
my $xact = $C->xact;
my $S = $C->{'_pos'};

$self->_MATCHIFYr($S, "sigterm", 
do {
if (my ($C) = ($C->_EXACT(':('))) {
do {
if (my ($C) = (((local $::GOAL = ')' ), $C)[-1])) {
do {
if (my ($C) = ($C->_SUBSUMEr(['fakesignature'], sub {
my $C = shift;
$C->fakesignature
}))) {
$C->_BRACKETr(sub {
my $C=shift;
do {
my $C = $C->cursor_xact('ALT ||');
my $xact = $C->xact;
my @gather;
do {
push @gather, $C->_EXACT(')')
}
or $xact->[-2] or
do {
push @gather, $C->FAILGOAL(')' , 'signature')};
@gather;
}
});
}
else {
();
}
};
}
else {
();
}
};
}
else {
();
}
}
);
}

##     rule param_sep
##          rule param_sep { [','|':'|';'|';;'] }

sub param_sep__PEEK { $_[0]->_AUTOLEXpeek('param_sep',$retree) }
sub param_sep {
no warnings 'recursion';
my $self = shift;
local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;


my $C = $self->cursor_xact("RULE param_sep");
my $xact = $C->xact;
my $S = $C->{'_pos'};

$self->_MATCHIFYr($S, "param_sep", 
do {
if (my ($C) = ($C->ws)) {
do {
if (my ($C) = ($C->_BRACKETr(sub {
my $C=shift;
do {
my @result = do {
my $trystate;
my ($tag, $try);
my @try;
my $relex;

my $fate;
my $x;
if ($fate = $C->{'_fate'} and $fate->[1] eq 'param_sep_01') {
$C->deb("Fate passed to param_sep_01: ", ::fatestr($fate)) if $::DEBUG & DEBUG::fates;
($C->{'_fate'}, $tag, $try) = @$fate;
@try = ($try);
$x = 'ALT param_sep_01';    # some outer ltm is controlling us
}
else {
$x = 'ALTLTM param_sep_01'; # we are top level ltm
}
my $C = $C->cursor_xact($x);
my $xact = $C->xact;

my @gather = ();
for (;;) {
if (not @try) {
$relex //= $C->cursor_fate('STD::P6', 'param_sep_01', $retree);
@try = $relex->($C, $trystate);
}
last unless @try;
$try = shift(@try) // next;

if (ref $try eq 'ARRAY') {
($C->{'_fate'}, $tag, $try) = @$try;	# next candidate fate
}

$C->deb("param_sep_01 trying $tag $try") if $::DEBUG & DEBUG::try_processing;
push @gather, ((
sub { my $C=shift;
$C->_EXACT(',')
},
sub { my $C=shift;
$C->_EXACT(':')
},
sub { my $C=shift;
$C->_EXACT(';')
},
sub { my $C=shift;
$C->_EXACT(';;')
},
)[$try])->($C);
last if $xact->[-2];  # committed?
last if @gather;
}
@gather;
};
@result;
}

}))) {
$C->ws;
}
else {
();
}
};
}
else {
();
}
}
);
}

##     token fakesignature()
##          token fakesignature() {
##              :temp $*CURPAD;
##              <.newpad>
##              <signature>
##          }

sub fakesignature__PEEK { $_[0]->_AUTOLEXpeek('fakesignature',$retree) }
sub fakesignature {
no warnings 'recursion';
my $self = shift;
local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;
local $::CURPAD = $::CURPAD;


my $C = $self->cursor_xact("RULE fakesignature");
my $xact = $C->xact;
my $S = $C->{'_pos'};

$self->_MATCHIFYr($S, "fakesignature", 
do {
if (my ($C) = ($C->newpad)) {
$C->_SUBSUMEr(['signature'], sub {
my $C = shift;
$C->signature
});
}
else {
();
}
}
);
}

##     token signature ($padsig = 0)
##          token signature ($padsig = 0) {
##              :my $*IN_DECL = 'sig';
##              :my $*zone = 'posreq';
##              :my $startpos = self.pos;
##              :my $*MULTINESS = 'only';
##              :my $*SIGNUM = $padsig;
##              <.ws>
##              [
##              | <?before '-->' | ')' | ']' | '{' | ':'\s >
##              | [ <parameter> || <.panic: "Malformed parameter"> ]
##              ] ** <param_sep>
##              <.ws>
##              { $*IN_DECL = ''; }
##              [ '-->' <.ws> <typename> <.ws> ]?
##              {{
##                  $*LEFTSIGIL = '@';
##                  if $padsig {
##                      $*CURPAD.<$?SIGNATURE> ~= '|' if $padsig > 1;
##                      $*CURPAD.<$?SIGNATURE> ~= '(' ~ substr($*ORIG, $startpos, $.pos - $startpos) ~ ')';
##                      $*CURPAD.<!NEEDSIG>:delete;
##                  }
##              }}
##          }

sub signature__PEEK { $_[0]->_AUTOLEXpeek('signature',$retree) }
sub signature {
no warnings 'recursion';
my $self = shift;
local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;
my $padsig = shift() // 0;
local $::IN_DECL = 'sig';
local $::zone = 'posreq';
my $startpos = $self->{'_pos'};
local $::MULTINESS = 'only';
local $::SIGNUM = $padsig;


my $C = $self->cursor_xact("RULE signature");
my $xact = $C->xact;
my $S = $C->{'_pos'};
$C->{'typename'} = [];
$C->{'parameter'} = [];
$C->{'param_sep'} = [];

$self->_MATCHIFYr($S, "signature", 
do {
if (my ($C) = ($C->ws)) {
do {
if (my ($C) = ($C->_REPSEPr(  sub { my $C=shift;
$C->_SUBSUMEr(['param_sep'], sub {
my $C = shift;
$C->param_sep
})
}, sub { my $C=shift;
$C->_BRACKETr(sub {
my $C=shift;
do {
my @result = do {
my $trystate;
my ($tag, $try);
my @try;
my $relex;

my $fate;
my $x;
if ($fate = $C->{'_fate'} and $fate->[1] eq 'signature_01') {
$C->deb("Fate passed to signature_01: ", ::fatestr($fate)) if $::DEBUG & DEBUG::fates;
($C->{'_fate'}, $tag, $try) = @$fate;
@try = ($try);
$x = 'ALT signature_01';    # some outer ltm is controlling us
}
else {
$x = 'ALTLTM signature_01'; # we are top level ltm
}
my $C = $C->cursor_xact($x);
my $xact = $C->xact;

my @gather = ();
for (;;) {
if (not @try) {
$relex //= $C->cursor_fate('STD::P6', 'signature_01', $retree);
@try = $relex->($C, $trystate);
}
last unless @try;
$try = shift(@try) // next;

if (ref $try eq 'ARRAY') {
($C->{'_fate'}, $tag, $try) = @$try;	# next candidate fate
}

$C->deb("signature_01 trying $tag $try") if $::DEBUG & DEBUG::try_processing;
push @gather, ((
sub { my $C=shift;
$C->before(sub { my $C=shift;
do {
my @result = do {
my $trystate;
my ($tag, $try);
my @try;
my $relex;

my $fate;
my $x;
if ($fate = $C->{'_fate'} and $fate->[1] eq 'signature_02') {
$C->deb("Fate passed to signature_02: ", ::fatestr($fate)) if $::DEBUG & DEBUG::fates;
($C->{'_fate'}, $tag, $try) = @$fate;
@try = ($try);
$x = 'ALT signature_02';    # some outer ltm is controlling us
}
else {
$x = 'ALTLTM signature_02'; # we are top level ltm
}
my $C = $C->cursor_xact($x);
my $xact = $C->xact;

my @gather = ();
for (;;) {
if (not @try) {
$relex //= $C->cursor_fate('STD::P6', 'signature_02', $retree);
@try = $relex->($C, $trystate);
}
last unless @try;
$try = shift(@try) // next;

if (ref $try eq 'ARRAY') {
($C->{'_fate'}, $tag, $try) = @$try;	# next candidate fate
}

$C->deb("signature_02 trying $tag $try") if $::DEBUG & DEBUG::try_processing;
push @gather, ((
sub { my $C=shift;
$C->_EXACT('-->')
},
sub { my $C=shift;
$C->_EXACT(')')
},
sub { my $C=shift;
$C->_EXACT(']')
},
sub { my $C=shift;
$C->_EXACT('{')
},
sub { my $C=shift;
do {
if (my ($C) = ($C->_EXACT(':'))) {
$C->_PATTERN(qr/\G\s/);
}
else {
();
}
}
},
)[$try])->($C);
last if $xact->[-2];  # committed?
last if @gather;
}
@gather;
};
@result;
}

})
},
sub { my $C=shift;
$C->_BRACKETr(sub {
my $C=shift;
do {
my $C = $C->cursor_xact('ALT ||');
my $xact = $C->xact;
my @gather;
do {
push @gather, $C->_SUBSUMEr(['parameter'], sub {
my $C = shift;
$C->parameter
})
}
or $xact->[-2] or
do {
push @gather, $C->panic("Malformed parameter")};
@gather;
}
})
},
)[$try])->($C);
last if $xact->[-2];  # committed?
last if @gather;
}
@gather;
};
@result;
}

})
}))) {
do {
if (my ($C) = ($C->ws)) {
do {
if (my ($C) = (scalar(do {
$::IN_DECL = ''; 
}, $C))) {
do {
if (my ($C) = ($C->_OPTr(sub { my $C=shift;
$C->_BRACKETr(sub {
my $C=shift;
do {
if (my ($C) = ($C->_EXACT('-->'))) {
do {
if (my ($C) = ($C->ws)) {
do {
if (my ($C) = ($C->_SUBSUMEr(['typename'], sub {
my $C = shift;
$C->typename
}))) {
$C->ws;
}
else {
();
}
};
}
else {
();
}
};
}
else {
();
}
}
})
}))) {
scalar(do {

$::LEFTSIGIL = '@';
if ($padsig) {
$::CURPAD->{'$?SIGNATURE'} .= '|' if $padsig > 1;
$::CURPAD->{'$?SIGNATURE'} .= '(' . substr($::ORIG, $startpos, $C->{'_pos'} - $startpos) . ')';
delete $::CURPAD->{'!NEEDSIG'};
}

}, $C);
}
else {
();
}
};
}
else {
();
}
};
}
else {
();
}
};
}
else {
();
}
};
}
else {
();
}
}
);
}

##     token type_declarator__S_227subset (:$*endsym = 'spacey', :$*sym = 'subset')
##          token type_declarator:subset {
##              :my $*IN_DECL = 'subset';
##              :my $*DECLARAND;
##              <sym> :s
##              [
##                  [ <longname> { $.add_name($<longname>[0].Str); } ]?
##                  <trait>*
##                  [where <EXPR(item %chaining)> ]?    # (EXPR can parse multiple where clauses)
##              ] || <.panic: "Malformed subset">
##          }

sub type_declarator__S_227subset__PEEK { $_[0]->_AUTOLEXpeek('type_declarator__S_227subset',$retree) }
sub type_declarator__S_227subset {
no warnings 'recursion';
my $self = shift;
local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;
my %args = @_;
local $::endsym = $args{endsym} // 'spacey';
local $::sym = $args{sym} // 'subset';
local $::IN_DECL = 'subset';
local $::DECLARAND;


my $C = $self->cursor_xact("RULE type_declarator__S_227subset");
my $xact = $C->xact;
my $S = $C->{'_pos'};
$C->{'longname'} = [];
$C->{'trait'} = [];
$C->{'EXPR'} = [];
$C->{'sym'} = ref $sym ? join(' ', @$sym) : $sym;

$self->_MATCHIFYr($S, "type_declarator__S_227subset", 
do {
my $C = $C->cursor_xact('ALT ||');
my $xact = $C->xact;
my @gather;
do {
push @gather, do {
if (my ($C) = ($C->_PATTERN(qr/\Gsubset/))) {
do {
if (my ($C) = ($C->spacey)) {
do {
if (my ($C) = ($C->ws)) {
do {
if (my ($C) = ($C->_BRACKETr(sub {
my $C=shift;
do {
if (my ($C) = ($C->_OPTr(sub { my $C=shift;
$C->_BRACKETr(sub {
my $C=shift;
do {
if (my ($C) = ($C->ws)) {
do {
if (my ($C) = ($C->_SUBSUMEr(['longname'], sub {
my $C = shift;
$C->longname
}))) {
do {
if (my ($C) = ($C->ws)) {
do {
if (my ($C) = (scalar(do {
my $M = $C;  $C->add_name($M->{'longname'}[0]->Str); ;
}, $C))) {
$C->ws;
}
else {
();
}
};
}
else {
();
}
};
}
else {
();
}
};
}
else {
();
}
}
})
}))) {
do {
if (my ($C) = ($C->ws)) {
do {
if (my ($C) = ($C->_STARr(sub { my $C=shift;
$C->_SUBSUMEr(['trait'], sub {
my $C = shift;
$C->trait
})
}))) {
do {
if (my ($C) = ($C->ws)) {
do {
if (my ($C) = ($C->_OPTr(sub { my $C=shift;
$C->_BRACKETr(sub {
my $C=shift;
do {
if (my ($C) = ($C->_EXACT('where'))) {
do {
if (my ($C) = ($C->ws)) {
do {
if (my ($C) = ($C->_SUBSUMEr(['EXPR'], sub {
my $C = shift;
$C->EXPR(\%chaining)
}))) {
$C->ws;
}
else {
();
}
};
}
else {
();
}
};
}
else {
();
}
}
})
}))) {
$C->ws;
}
else {
();
}
};
}
else {
();
}
};
}
else {
();
}
};
}
else {
();
}
};
}
else {
();
}
}
}))) {
$C->ws;
}
else {
();
}
};
}
else {
();
}
};
}
else {
();
}
};
}
else {
();
}
}
}
or $xact->[-2] or
do {
push @gather, do {
if (my ($C) = ($C->ws)) {
do {
if (my ($C) = ($C->panic("Malformed subset"))) {
$C->ws;
}
else {
();
}
};
}
else {
();
}
}};
@gather;
}
);
}

##     token type_declarator__S_228enum (:$*endsym = 'spacey', :$*sym = 'enum')
##          token type_declarator:enum {
##              :my $*IN_DECL = 'enum';
##              :my $*DECLARAND;
##              <sym> <.ws>
##              [ <longname> { $.add_name($<longname>[0].Str); } <.ws> ]?
##              <trait>* <?before <[ < (  ]> > <term> <.ws>
##                  {$.add_enum($<longname>, $<term>.Str); }
##          }

sub type_declarator__S_228enum__PEEK { $_[0]->_AUTOLEXpeek('type_declarator__S_228enum',$retree) }
sub type_declarator__S_228enum {
no warnings 'recursion';
my $self = shift;
local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;
my %args = @_;
local $::endsym = $args{endsym} // 'spacey';
local $::sym = $args{sym} // 'enum';
local $::IN_DECL = 'enum';
local $::DECLARAND;


my $C = $self->cursor_xact("RULE type_declarator__S_228enum");
my $xact = $C->xact;
my $S = $C->{'_pos'};
$C->{'longname'} = [];
$C->{'trait'} = [];
$C->{'sym'} = ref $sym ? join(' ', @$sym) : $sym;

$self->_MATCHIFYr($S, "type_declarator__S_228enum", 
do {
if (my ($C) = ($C->_PATTERN(qr/\Genum/))) {
do {
if (my ($C) = ($C->spacey)) {
do {
if (my ($C) = ($C->ws)) {
do {
if (my ($C) = ($C->_OPTr(sub { my $C=shift;
$C->_BRACKETr(sub {
my $C=shift;
do {
if (my ($C) = ($C->_SUBSUMEr(['longname'], sub {
my $C = shift;
$C->longname
}))) {
do {
if (my ($C) = (scalar(do {
my $M = $C;  $C->add_name($M->{'longname'}[0]->Str); ;
}, $C))) {
$C->ws;
}
else {
();
}
};
}
else {
();
}
}
})
}))) {
do {
if (my ($C) = ($C->_STARr(sub { my $C=shift;
$C->_SUBSUMEr(['trait'], sub {
my $C = shift;
$C->trait
})
}))) {
do {
if (my ($C) = ($C->before(sub { my $C=shift;
$C->_PATTERN(qr/\G[<(]/)
}))) {
do {
if (my ($C) = ($C->_SUBSUMEr(['term'], sub {
my $C = shift;
$C->term
}))) {
do {
if (my ($C) = ($C->ws)) {
scalar(do {
my $M = $C; $C->add_enum($M->{'longname'}, $M->{'term'}->Str); ;
}, $C);
}
else {
();
}
};
}
else {
();
}
};
}
else {
();
}
};
}
else {
();
}
};
}
else {
();
}
};
}
else {
();
}
};
}
else {
();
}
};
}
else {
();
}
}
);
}

##     token type_declarator__S_229constant (:$*endsym = 'spacey', :$*sym = 'constant')
##          token type_declarator:constant {
##              :my $*IN_DECL = 'constant';
##              :my $*DECLARAND;
##              <sym> <.ws>
##      
##              [
##              | <identifier> { $.add_name($<identifier>.Str); }
##              | <variable> { $.add_variable($<variable>.Str); }
##              | <?>
##              ]
##              { $*IN_DECL = ''; }
##              <.ws>
##      
##              <trait>*
##      
##              [
##              || <?before '='>
##              || <?before <-[\n=]>*'='> <.panic: "Malformed constant"> # probable initializer later
##              || <.panic: "Missing initializer on constant declaration">
##              ]
##      
##              <.getdecl>
##          }

sub type_declarator__S_229constant__PEEK { $_[0]->_AUTOLEXpeek('type_declarator__S_229constant',$retree) }
sub type_declarator__S_229constant {
no warnings 'recursion';
my $self = shift;
local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;
my %args = @_;
local $::endsym = $args{endsym} // 'spacey';
local $::sym = $args{sym} // 'constant';
local $::IN_DECL = 'constant';
local $::DECLARAND;


my $C = $self->cursor_xact("RULE type_declarator__S_229constant");
my $xact = $C->xact;
my $S = $C->{'_pos'};
$C->{'trait'} = [];
$C->{'sym'} = ref $sym ? join(' ', @$sym) : $sym;

$self->_MATCHIFYr($S, "type_declarator__S_229constant", 
do {
if (my ($C) = ($C->_PATTERN(qr/\Gconstant/))) {
do {
if (my ($C) = ($C->spacey)) {
do {
if (my ($C) = ($C->ws)) {
do {
if (my ($C) = ($C->_BRACKETr(sub {
my $C=shift;
do {
my @result = do {
my $trystate;
my ($tag, $try);
my @try;
my $relex;

my $fate;
my $x;
if ($fate = $C->{'_fate'} and $fate->[1] eq 'type_declarator__S_229constant_01') {
$C->deb("Fate passed to type_declarator__S_229constant_01: ", ::fatestr($fate)) if $::DEBUG & DEBUG::fates;
($C->{'_fate'}, $tag, $try) = @$fate;
@try = ($try);
$x = 'ALT type_declarator__S_229constant_01';    # some outer ltm is controlling us
}
else {
$x = 'ALTLTM type_declarator__S_229constant_01'; # we are top level ltm
}
my $C = $C->cursor_xact($x);
my $xact = $C->xact;

my @gather = ();
for (;;) {
if (not @try) {
$relex //= $C->cursor_fate('STD::P6', 'type_declarator__S_229constant_01', $retree);
@try = $relex->($C, $trystate);
}
last unless @try;
$try = shift(@try) // next;

if (ref $try eq 'ARRAY') {
($C->{'_fate'}, $tag, $try) = @$try;	# next candidate fate
}

$C->deb("type_declarator__S_229constant_01 trying $tag $try") if $::DEBUG & DEBUG::try_processing;
push @gather, ((
sub { my $C=shift;
do {
if (my ($C) = ($C->_SUBSUMEr(['identifier'], sub {
my $C = shift;
$C->identifier
}))) {
scalar(do {
my $M = $C;  $C->add_name($M->{'identifier'}->Str); ;
}, $C);
}
else {
();
}
}
},
sub { my $C=shift;
do {
if (my ($C) = ($C->_SUBSUMEr(['variable'], sub {
my $C = shift;
$C->variable
}))) {
scalar(do {
my $M = $C;  $C->add_variable($M->{'variable'}->Str); ;
}, $C);
}
else {
();
}
}
},
sub { my $C=shift;
$C->before( sub { my $C=shift;
$C
})
},
)[$try])->($C);
last if $xact->[-2];  # committed?
last if @gather;
}
@gather;
};
@result;
}

}))) {
do {
if (my ($C) = (scalar(do {
$::IN_DECL = ''; 
}, $C))) {
do {
if (my ($C) = ($C->ws)) {
do {
if (my ($C) = ($C->_STARr(sub { my $C=shift;
$C->_SUBSUMEr(['trait'], sub {
my $C = shift;
$C->trait
})
}))) {
do {
if (my ($C) = ($C->_BRACKETr(sub {
my $C=shift;
do {
my $C = $C->cursor_xact('ALT ||');
my $xact = $C->xact;
my @gather;
do {
push @gather, $C->before(sub { my $C=shift;
$C->_EXACT('=')
})
}
or $xact->[-2] or
do {
push @gather, do {
if (my ($C) = ($C->before(sub { my $C=shift;
do {
if (my ($C) = ($C->_PATTERN(qr/\G((?:[^\n=])*+)/))) {
$C->_EXACT('=');
}
else {
();
}
}
}))) {
$C->panic("Malformed constant");
}
else {
();
}
}
}
or $xact->[-2] or
do {
push @gather, $C->panic("Missing initializer on constant declaration")};
@gather;
}
}))) {
$C->getdecl;
}
else {
();
}
};
}
else {
();
}
};
}
else {
();
}
};
}
else {
();
}
};
}
else {
();
}
};
}
else {
();
}
};
}
else {
();
}
};
}
else {
();
}
}
);
}


##     token type_constraint
##          token type_constraint {
##              :my $*IN_DECL = '';
##              [
##              | <value>
##              | <typename>
##              | where <.ws> <EXPR(item %chaining)>
##              ]
##              <.ws>
##          }

sub type_constraint__PEEK { $_[0]->_AUTOLEXpeek('type_constraint',$retree) }
sub type_constraint {
no warnings 'recursion';
my $self = shift;
local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;
local $::IN_DECL = '';


my $C = $self->cursor_xact("RULE type_constraint");
my $xact = $C->xact;
my $S = $C->{'_pos'};

$self->_MATCHIFYr($S, "type_constraint", 
do {
if (my ($C) = ($C->_BRACKETr(sub {
my $C=shift;
do {
my @result = do {
my $trystate;
my ($tag, $try);
my @try;
my $relex;

my $fate;
my $x;
if ($fate = $C->{'_fate'} and $fate->[1] eq 'type_constraint_01') {
$C->deb("Fate passed to type_constraint_01: ", ::fatestr($fate)) if $::DEBUG & DEBUG::fates;
($C->{'_fate'}, $tag, $try) = @$fate;
@try = ($try);
$x = 'ALT type_constraint_01';    # some outer ltm is controlling us
}
else {
$x = 'ALTLTM type_constraint_01'; # we are top level ltm
}
my $C = $C->cursor_xact($x);
my $xact = $C->xact;

my @gather = ();
for (;;) {
if (not @try) {
$relex //= $C->cursor_fate('STD::P6', 'type_constraint_01', $retree);
@try = $relex->($C, $trystate);
}
last unless @try;
$try = shift(@try) // next;

if (ref $try eq 'ARRAY') {
($C->{'_fate'}, $tag, $try) = @$try;	# next candidate fate
}

$C->deb("type_constraint_01 trying $tag $try") if $::DEBUG & DEBUG::try_processing;
push @gather, ((
sub { my $C=shift;
$C->_SUBSUMEr(['value'], sub {
my $C = shift;
$C->value
})
},
sub { my $C=shift;
$C->_SUBSUMEr(['typename'], sub {
my $C = shift;
$C->typename
})
},
sub { my $C=shift;
do {
if (my ($C) = ($C->_EXACT('where'))) {
do {
if (my ($C) = ($C->ws)) {
$C->_SUBSUMEr(['EXPR'], sub {
my $C = shift;
$C->EXPR(\%chaining)
});
}
else {
();
}
};
}
else {
();
}
}
},
)[$try])->($C);
last if $xact->[-2];  # committed?
last if @gather;
}
@gather;
};
@result;
}

}))) {
$C->ws;
}
else {
();
}
}
);
}

##     rule post_constraint
##          rule post_constraint {
##              :my $*IN_DECL = '';
##              :dba('constraint')
##              [
##              | '[' ~ ']' <signature>
##              | '(' ~ ')' <signature>
##              | where <EXPR(item %chaining)>
##              ]
##          }

sub post_constraint__PEEK { $_[0]->_AUTOLEXpeek('post_constraint',$retree) }
sub post_constraint {
no warnings 'recursion';
my $self = shift;
local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;
local $::IN_DECL = '';


my $C = $self->cursor_xact("RULE post_constraint");
my $xact = $C->xact;
my $S = $C->{'_pos'};

$self->_MATCHIFYr($S, "post_constraint", 
do {
if (my ($C) = ($C->ws)) {
do {
if (my ($C) = ($C->ws)) {
do {
if (my ($C) = ($C->_BRACKETr(sub {
my $C=shift;
do {
my @result = do {
my $trystate;
my ($tag, $try);
my @try;
my $relex;

my $fate;
my $x;
if ($fate = $C->{'_fate'} and $fate->[1] eq 'post_constraint_01') {
$C->deb("Fate passed to post_constraint_01: ", ::fatestr($fate)) if $::DEBUG & DEBUG::fates;
($C->{'_fate'}, $tag, $try) = @$fate;
@try = ($try);
$x = 'ALT post_constraint_01';    # some outer ltm is controlling us
}
else {
$x = 'ALTLTM post_constraint_01'; # we are top level ltm
}
my $C = $C->cursor_xact($x);
my $xact = $C->xact;

my @gather = ();
for (;;) {
if (not @try) {
$relex //= $C->cursor_fate('STD::P6', 'post_constraint_01', $retree);
@try = $relex->($C, $trystate);
}
last unless @try;
$try = shift(@try) // next;

if (ref $try eq 'ARRAY') {
($C->{'_fate'}, $tag, $try) = @$try;	# next candidate fate
}

$C->deb("post_constraint_01 trying $tag $try") if $::DEBUG & DEBUG::try_processing;
push @gather, ((
sub { my $C=shift;
do {
if (my ($C) = ($C->_EXACT('['))) {
do {
if (my ($C) = ($C->ws)) {
do {
if (my ($C) = (((local $::GOAL = ']'), $C)[-1])) {
do {
if (my ($C) = ($C->_SUBSUMEr(['signature'], sub {
my $C = shift;
$C->signature
}))) {
do {
if (my ($C) = ($C->_BRACKETr(sub {
my $C=shift;
do {
my $C = $C->cursor_xact('ALT ||');
my $xact = $C->xact;
my @gather;
do {
push @gather, $C->_EXACT(']')
}
or $xact->[-2] or
do {
push @gather, $C->FAILGOAL(']', 'constraint')};
@gather;
}
}))) {
$C->ws;
}
else {
();
}
};
}
else {
();
}
};
}
else {
();
}
};
}
else {
();
}
};
}
else {
();
}
}
},
sub { my $C=shift;
do {
if (my ($C) = ($C->_EXACT('('))) {
do {
if (my ($C) = ($C->ws)) {
do {
if (my ($C) = (((local $::GOAL = ')'), $C)[-1])) {
do {
if (my ($C) = ($C->_SUBSUMEr(['signature'], sub {
my $C = shift;
$C->signature
}))) {
do {
if (my ($C) = ($C->_BRACKETr(sub {
my $C=shift;
do {
my $C = $C->cursor_xact('ALT ||');
my $xact = $C->xact;
my @gather;
do {
push @gather, $C->_EXACT(')')
}
or $xact->[-2] or
do {
push @gather, $C->FAILGOAL(')', 'constraint')};
@gather;
}
}))) {
$C->ws;
}
else {
();
}
};
}
else {
();
}
};
}
else {
();
}
};
}
else {
();
}
};
}
else {
();
}
}
},
sub { my $C=shift;
do {
if (my ($C) = ($C->_EXACT('where'))) {
do {
if (my ($C) = ($C->ws)) {
do {
if (my ($C) = ($C->_SUBSUMEr(['EXPR'], sub {
my $C = shift;
$C->EXPR(\%chaining)
}))) {
$C->ws;
}
else {
();
}
};
}
else {
();
}
};
}
else {
();
}
}
},
)[$try])->($C);
last if $xact->[-2];  # committed?
last if @gather;
}
@gather;
};
@result;
}

}))) {
$C->ws;
}
else {
();
}
};
}
else {
();
}
};
}
else {
();
}
}
);
}

##     token named_param
##          token named_param {
##              :my $*GOAL ::= ')';
##              ':'
##              [
##              | <name=.identifier> '(' <.ws>
##                  [ <named_param> | <param_var> <.ws> ]
##                  [ ')' || <.panic: "Unable to parse named parameter; couldn't find right parenthesis"> ]
##              | <param_var>
##              ]
##          }

sub named_param__PEEK { $_[0]->_AUTOLEXpeek('named_param',$retree) }
sub named_param {
no warnings 'recursion';
my $self = shift;
local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;
local $::GOAL = ')';


my $C = $self->cursor_xact("RULE named_param");
my $xact = $C->xact;
my $S = $C->{'_pos'};

$self->_MATCHIFYr($S, "named_param", 
do {
if (my ($C) = ($C->_EXACT(':'))) {
$C->_BRACKETr(sub {
my $C=shift;
do {
my @result = do {
my $trystate;
my ($tag, $try);
my @try;
my $relex;

my $fate;
my $x;
if ($fate = $C->{'_fate'} and $fate->[1] eq 'named_param_01') {
$C->deb("Fate passed to named_param_01: ", ::fatestr($fate)) if $::DEBUG & DEBUG::fates;
($C->{'_fate'}, $tag, $try) = @$fate;
@try = ($try);
$x = 'ALT named_param_01';    # some outer ltm is controlling us
}
else {
$x = 'ALTLTM named_param_01'; # we are top level ltm
}
my $C = $C->cursor_xact($x);
my $xact = $C->xact;

my @gather = ();
for (;;) {
if (not @try) {
$relex //= $C->cursor_fate('STD::P6', 'named_param_01', $retree);
@try = $relex->($C, $trystate);
}
last unless @try;
$try = shift(@try) // next;

if (ref $try eq 'ARRAY') {
($C->{'_fate'}, $tag, $try) = @$try;	# next candidate fate
}

$C->deb("named_param_01 trying $tag $try") if $::DEBUG & DEBUG::try_processing;
push @gather, ((
sub { my $C=shift;
do {
if (my ($C) = (  $C->_SUBSUMEr(['name'], sub {
my $C = shift;
$C->identifier
}))) {
do {
if (my ($C) = ($C->_EXACT('('))) {
do {
if (my ($C) = ($C->ws)) {
do {
if (my ($C) = ($C->_BRACKETr(sub {
my $C=shift;
do {
my @result = do {
my $trystate;
my ($tag, $try);
my @try;
my $relex;

my $fate;
my $x;
if ($fate = $C->{'_fate'} and $fate->[1] eq 'named_param_02') {
$C->deb("Fate passed to named_param_02: ", ::fatestr($fate)) if $::DEBUG & DEBUG::fates;
($C->{'_fate'}, $tag, $try) = @$fate;
@try = ($try);
$x = 'ALT named_param_02';    # some outer ltm is controlling us
}
else {
$x = 'ALTLTM named_param_02'; # we are top level ltm
}
my $C = $C->cursor_xact($x);
my $xact = $C->xact;

my @gather = ();
for (;;) {
if (not @try) {
$relex //= $C->cursor_fate('STD::P6', 'named_param_02', $retree);
@try = $relex->($C, $trystate);
}
last unless @try;
$try = shift(@try) // next;

if (ref $try eq 'ARRAY') {
($C->{'_fate'}, $tag, $try) = @$try;	# next candidate fate
}

$C->deb("named_param_02 trying $tag $try") if $::DEBUG & DEBUG::try_processing;
push @gather, ((
sub { my $C=shift;
$C->_SUBSUMEr(['named_param'], sub {
my $C = shift;
$C->named_param
})
},
sub { my $C=shift;
do {
if (my ($C) = ($C->_SUBSUMEr(['param_var'], sub {
my $C = shift;
$C->param_var
}))) {
$C->ws;
}
else {
();
}
}
},
)[$try])->($C);
last if $xact->[-2];  # committed?
last if @gather;
}
@gather;
};
@result;
}

}))) {
$C->_BRACKETr(sub {
my $C=shift;
do {
my $C = $C->cursor_xact('ALT ||');
my $xact = $C->xact;
my @gather;
do {
push @gather, $C->_EXACT(')')
}
or $xact->[-2] or
do {
push @gather, $C->panic("Unable to parse named parameter; couldn't find right parenthesis")};
@gather;
}
});
}
else {
();
}
};
}
else {
();
}
};
}
else {
();
}
};
}
else {
();
}
}
},
sub { my $C=shift;
$C->_SUBSUMEr(['param_var'], sub {
my $C = shift;
$C->param_var
})
},
)[$try])->($C);
last if $xact->[-2];  # committed?
last if @gather;
}
@gather;
};
@result;
}

});
}
else {
();
}
}
);
}

##     token param_var
##          token param_var {
##              :dba('formal parameter')
##              [
##              | '[' ~ ']' <signature>
##              | '(' ~ ')' <signature>
##              | <sigil> <twigil>?
##                  [
##                      # Is it a longname declaration?
##                  || <?{ $<sigil>.Str eq '&' }> <?ident> {}
##                      <name=.sublongname>
##      
##                  ||  # Is it a shaped array or hash declaration?
##                      <?{ $<sigil>.Str eq '@' || $<sigil>.Str eq '%' }>
##                      <name=.identifier>?
##                      <?before <[ \< \( \[ \{ ]> >
##                      <postcircumfix>
##      
##                      # ordinary parameter name
##                  || <name=.identifier>
##                  || $<name> = [<[/!]>]
##      
##                      # bare sigil?
##                  ]?
##                  {{
##                      my $vname = $<sigil>.Str;
##                      my $t = $<twigil>;
##                      my $twigil = '';
##                      $twigil = $t.[0].Str if @$t;
##                      $vname ~= $twigil;
##                      my $n = try { $<name>[0].Str } // '';
##                      $vname ~= $n;
##                      given $twigil {
##                          when '' {
##                              self.add_my_name($vname) if $n ne '';
##                          }
##                          when '.' {
##                          }
##                          when '!' {
##                          }
##                          when '*' {
##                          }
##                          default {
##                              self.worry("Illegal to use $twigil twigil in signature");
##                          }
##                      }
##                  }}
##              ]
##          }

sub param_var__PEEK { $_[0]->_AUTOLEXpeek('param_var',$retree) }
sub param_var {
no warnings 'recursion';
my $self = shift;
local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;


my $C = $self->cursor_xact("RULE param_var");
my $xact = $C->xact;
my $S = $C->{'_pos'};
$C->{'name'} = [];
$C->{'twigil'} = [];
$C->{'postcircumfix'} = [];

$self->_MATCHIFYr($S, "param_var", 
$C->_BRACKETr(sub {
my $C=shift;
do {
my @result = do {
my $trystate;
my ($tag, $try);
my @try;
my $relex;

my $fate;
my $x;
if ($fate = $C->{'_fate'} and $fate->[1] eq 'param_var_01') {
$C->deb("Fate passed to param_var_01: ", ::fatestr($fate)) if $::DEBUG & DEBUG::fates;
($C->{'_fate'}, $tag, $try) = @$fate;
@try = ($try);
$x = 'ALT param_var_01';    # some outer ltm is controlling us
}
else {
$x = 'ALTLTM param_var_01'; # we are top level ltm
}
my $C = $C->cursor_xact($x);
my $xact = $C->xact;

my @gather = ();
for (;;) {
if (not @try) {
$relex //= $C->cursor_fate('STD::P6', 'param_var_01', $retree);
@try = $relex->($C, $trystate);
}
last unless @try;
$try = shift(@try) // next;

if (ref $try eq 'ARRAY') {
($C->{'_fate'}, $tag, $try) = @$try;	# next candidate fate
}

$C->deb("param_var_01 trying $tag $try") if $::DEBUG & DEBUG::try_processing;
push @gather, ((
sub { my $C=shift;
do {
if (my ($C) = ($C->_EXACT('['))) {
do {
if (my ($C) = (((local $::GOAL = ']' ), $C)[-1])) {
do {
if (my ($C) = ($C->_SUBSUMEr(['signature'], sub {
my $C = shift;
$C->signature
}))) {
$C->_BRACKETr(sub {
my $C=shift;
do {
my $C = $C->cursor_xact('ALT ||');
my $xact = $C->xact;
my @gather;
do {
push @gather, $C->_EXACT(']')
}
or $xact->[-2] or
do {
push @gather, $C->FAILGOAL(']' , 'formal parameter')};
@gather;
}
});
}
else {
();
}
};
}
else {
();
}
};
}
else {
();
}
}
},
sub { my $C=shift;
do {
if (my ($C) = ($C->_EXACT('('))) {
do {
if (my ($C) = (((local $::GOAL = ')' ), $C)[-1])) {
do {
if (my ($C) = ($C->_SUBSUMEr(['signature'], sub {
my $C = shift;
$C->signature
}))) {
$C->_BRACKETr(sub {
my $C=shift;
do {
my $C = $C->cursor_xact('ALT ||');
my $xact = $C->xact;
my @gather;
do {
push @gather, $C->_EXACT(')')
}
or $xact->[-2] or
do {
push @gather, $C->FAILGOAL(')' , 'formal parameter')};
@gather;
}
});
}
else {
();
}
};
}
else {
();
}
};
}
else {
();
}
}
},
sub { my $C=shift;
do {
if (my ($C) = ($C->_SUBSUMEr(['sigil'], sub {
my $C = shift;
$C->sigil
}))) {
do {
if (my ($C) = ($C->_OPTr(sub { my $C=shift;
$C->_SUBSUMEr(['twigil'], sub {
my $C = shift;
$C->twigil
})
}))) {
do {
if (my ($C) = ($C->_OPTr(sub { my $C=shift;
$C->_BRACKETr(sub {
my $C=shift;
do {
my $C = $C->cursor_xact('ALT ||');
my $xact = $C->xact;
my @gather;
do {
push @gather, do {
if (my ($C) = ($C->before( sub { my $C=shift;
(($C) x !!do {
my $M = $C;  $M->{'sigil'}->Str eq '&' ;
})
}))) {
do {
if (my ($C) = ($C->before( sub { my $C=shift;
$C->ident
}))) {
do {
if (my ($C) = (scalar(do {

}, $C))) {
$C->_SUBSUMEr(['name'], sub {
my $C = shift;
$C->sublongname
});
}
else {
();
}
};
}
else {
();
}
};
}
else {
();
}
}
}
or $xact->[-2] or
do {
push @gather, do {
if (my ($C) = ($C->before( sub { my $C=shift;
(($C) x !!do {
my $M = $C;  $M->{'sigil'}->Str eq '@' || $M->{'sigil'}->Str eq '%' ;
})
}))) {
do {
if (my ($C) = (  $C->_OPTr(sub { my $C=shift;
$C->_SUBSUMEr(['name'], sub {
my $C = shift;
$C->identifier
})
}))) {
do {
if (my ($C) = ($C->before(sub { my $C=shift;
$C->_PATTERN(qr/\G[\<\(\[\{]/)
}))) {
$C->_SUBSUMEr(['postcircumfix'], sub {
my $C = shift;
$C->postcircumfix
});
}
else {
();
}
};
}
else {
();
}
};
}
else {
();
}
}
}
or $xact->[-2] or
do {
push @gather, $C->_SUBSUMEr(['name'], sub {
my $C = shift;
$C->identifier
})
}
or $xact->[-2] or
do {
push @gather, $C->_SUBSUMEr(['name'], sub {
my $C = shift;
$C->_BRACKETr(sub {
my $C=shift;
$C->_PATTERN(qr/\G[\/!]/)
})
})};
@gather;
}
})
}))) {
scalar(do {
my $M = $C; 
my $vname = $M->{'sigil'}->Str;
my $t = $M->{'twigil'};
my $twigil = '';
$twigil = $t->[0]->Str if @$t;
$vname .= $twigil;
my $n = eval { $M->{'name'}[0]->Str } // '';
$vname .= $n;
given ($twigil) {
when ('') {
$self->add_my_name($vname) if $n ne '';
}
when ('.') {
}
when ('!') {
}
when ('*') {
}
default {
$self->worry("Illegal to use $twigil twigil in signature");
}
};
;
}, $C);
}
else {
();
}
};
}
else {
();
}
};
}
else {
();
}
}
},
)[$try])->($C);
last if $xact->[-2];  # committed?
last if @gather;
}
@gather;
};
@result;
}

})
);
}

##     token parameter
##          token parameter {
##              :my $kind;
##              :my $quant = '';
##              :my $q;
##              :my $*DECLARAND;
##      
##              [
##              | <type_constraint>+
##                  {{
##                      my $t = $<type_constraint>;
##                      my @t = grep { substr($_.Str,0,2) ne '::' }, @$t;
##                      @t > 1 and $.panic("Multiple prefix constraints not yet supported")
##                  }}
##                  [
##                  | '**' <param_var>   { $quant = '**'; $kind = '*'; }
##                  | '*' <param_var>   { $quant = '*'; $kind = '*'; }
##                  | '|' <param_var>   { $quant = '|'; $kind = '*'; }
##                  | '\\' <param_var>  { $quant = '\\'; $kind = '!'; }
##                  |   [
##                      | <param_var>   { $quant = ''; $kind = '!'; }
##                      | <named_param> { $quant = ''; $kind = '*'; }
##                      ]
##                      [
##                      | '?'           { $quant = '?'; $kind = '?' }
##                      | '!'           { $quant = '!'; $kind //= '!' }
##                      | <?>
##                      ]
##                  | <?> { $quant = ''; $kind = '!' }
##                  ]
##      
##              | '**' <param_var>   { $quant = '**'; $kind = '*'; }
##              | '*' <param_var>   { $quant = '*'; $kind = '*'; }
##              | '|' <param_var>   { $quant = '|'; $kind = '*'; }
##              | '\\' <param_var>  { $quant = '\\'; $kind = '!'; }
##              |   [
##                  | <param_var>   { $quant = ''; $kind = '!'; }
##                  | <named_param> { $quant = ''; $kind = '*'; }
##                  ]
##                  [
##                  | '?'           { $quant = '?'; $kind = '?' }
##                  | '!'           { $quant = '!'; $kind //= '!' }
##                  | <?>
##                  ]
##              | {} <longname> <.panic("In parameter declaration, typename '" ~ $<longname>.Str ~ "' must be predeclared (or marked as declarative with :: prefix)")>
##              ]
##      
##              <trait>*
##      
##              <post_constraint>*
##      
##              <.getdecl>
##      
##              [
##                  <default_value> {{
##                      given $quant {
##                        when '!' { $.panic("Can't put a default on a required parameter") }
##                        when '*' { $.panic("Can't put a default on a slurpy parameter") }
##                        when '**' { $.panic("Can't put a default on a slice parameter") }
##                        when '|' { $.panic("Can't put a default on an slurpy capture parameter") }
##                        when '\\' { $.panic("Can't put a default on a capture parameter") }
##                      }
##                      $kind = '?' if $kind eq '!';
##                  }}
##                  [<?before ':' > <.panic: "Can't put a default on the invocant parameter">]?
##                  [<!before <[,;)\]\{\-]> > <.panic: "Default expression must come last">]?
##              ]?
##              [<?before ':'> <?{ $kind ne '!' }> <.panic: "Invocant is too exotic">]?
##      
##              {
##                  $<quant> = $quant;
##                  $<kind> = $kind;
##              }
##      
##              # enforce zone constraints
##              {{
##                  given $kind {
##                      when '!' {
##                          given $*zone {
##                              when 'posopt' {
##          $.panic("Can't put required parameter after optional parameters");
##                              }
##                              when 'var' {
##          $.panic("Can't put required parameter after variadic parameters");
##                              }
##                          }
##                      }
##                      when '?' {
##                          given $*zone {
##                              when 'posreq' { $*zone = 'posopt' }
##                              when 'var' {
##          $.panic("Can't put optional positional parameter after variadic parameters");
##                              }
##                          }
##                      }
##                      when '*' {
##                          $*zone = 'var';
##                      }
##                  }
##              }}
##          }

sub parameter__PEEK { $_[0]->_AUTOLEXpeek('parameter',$retree) }
sub parameter {
no warnings 'recursion';
my $self = shift;
local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;
my $kind;
my $quant = '';
my $q;
local $::DECLARAND;


my $C = $self->cursor_xact("RULE parameter");
my $xact = $C->xact;
my $S = $C->{'_pos'};
$C->{'trait'} = [];
$C->{'default_value'} = [];
$C->{'post_constraint'} = [];
$C->{'type_constraint'} = [];

$self->_MATCHIFYr($S, "parameter", 
do {
if (my ($C) = ($C->_BRACKETr(sub {
my $C=shift;
do {
my @result = do {
my $trystate;
my ($tag, $try);
my @try;
my $relex;

my $fate;
my $x;
if ($fate = $C->{'_fate'} and $fate->[1] eq 'parameter_01') {
$C->deb("Fate passed to parameter_01: ", ::fatestr($fate)) if $::DEBUG & DEBUG::fates;
($C->{'_fate'}, $tag, $try) = @$fate;
@try = ($try);
$x = 'ALT parameter_01';    # some outer ltm is controlling us
}
else {
$x = 'ALTLTM parameter_01'; # we are top level ltm
}
my $C = $C->cursor_xact($x);
my $xact = $C->xact;

my @gather = ();
for (;;) {
if (not @try) {
$relex //= $C->cursor_fate('STD::P6', 'parameter_01', $retree);
@try = $relex->($C, $trystate);
}
last unless @try;
$try = shift(@try) // next;

if (ref $try eq 'ARRAY') {
($C->{'_fate'}, $tag, $try) = @$try;	# next candidate fate
}

$C->deb("parameter_01 trying $tag $try") if $::DEBUG & DEBUG::try_processing;
push @gather, ((
sub { my $C=shift;
do {
if (my ($C) = ($C->_PLUSr(sub { my $C=shift;
$C->_SUBSUMEr(['type_constraint'], sub {
my $C = shift;
$C->type_constraint
})
}))) {
do {
if (my ($C) = (scalar(do {
my $M = $C; 
my $t = $M->{'type_constraint'};
my @t = grep { substr($_->Str,0,2) ne '::' } @$t;
@t > 1 and $C->panic("Multiple prefix constraints not yet supported")
;
}, $C))) {
$C->_BRACKETr(sub {
my $C=shift;
do {
my @result = do {
my $trystate;
my ($tag, $try);
my @try;
my $relex;

my $fate;
my $x;
if ($fate = $C->{'_fate'} and $fate->[1] eq 'parameter_02') {
$C->deb("Fate passed to parameter_02: ", ::fatestr($fate)) if $::DEBUG & DEBUG::fates;
($C->{'_fate'}, $tag, $try) = @$fate;
@try = ($try);
$x = 'ALT parameter_02';    # some outer ltm is controlling us
}
else {
$x = 'ALTLTM parameter_02'; # we are top level ltm
}
my $C = $C->cursor_xact($x);
my $xact = $C->xact;

my @gather = ();
for (;;) {
if (not @try) {
$relex //= $C->cursor_fate('STD::P6', 'parameter_02', $retree);
@try = $relex->($C, $trystate);
}
last unless @try;
$try = shift(@try) // next;

if (ref $try eq 'ARRAY') {
($C->{'_fate'}, $tag, $try) = @$try;	# next candidate fate
}

$C->deb("parameter_02 trying $tag $try") if $::DEBUG & DEBUG::try_processing;
push @gather, ((
sub { my $C=shift;
do {
if (my ($C) = ($C->_EXACT('**'))) {
do {
if (my ($C) = ($C->_SUBSUMEr(['param_var'], sub {
my $C = shift;
$C->param_var
}))) {
scalar(do {
$quant = '**'; $kind = '*'; 
}, $C);
}
else {
();
}
};
}
else {
();
}
}
},
sub { my $C=shift;
do {
if (my ($C) = ($C->_EXACT('*'))) {
do {
if (my ($C) = ($C->_SUBSUMEr(['param_var'], sub {
my $C = shift;
$C->param_var
}))) {
scalar(do {
$quant = '*'; $kind = '*'; 
}, $C);
}
else {
();
}
};
}
else {
();
}
}
},
sub { my $C=shift;
do {
if (my ($C) = ($C->_EXACT('|'))) {
do {
if (my ($C) = ($C->_SUBSUMEr(['param_var'], sub {
my $C = shift;
$C->param_var
}))) {
scalar(do {
$quant = '|'; $kind = '*'; 
}, $C);
}
else {
();
}
};
}
else {
();
}
}
},
sub { my $C=shift;
do {
if (my ($C) = ($C->_EXACT('\\'))) {
do {
if (my ($C) = ($C->_SUBSUMEr(['param_var'], sub {
my $C = shift;
$C->param_var
}))) {
scalar(do {
$quant = '\\'; $kind = '!'; 
}, $C);
}
else {
();
}
};
}
else {
();
}
}
},
sub { my $C=shift;
do {
if (my ($C) = ($C->_BRACKETr(sub {
my $C=shift;
do {
my @result = do {
my $trystate;
my ($tag, $try);
my @try;
my $relex;

my $fate;
my $x;
if ($fate = $C->{'_fate'} and $fate->[1] eq 'parameter_03') {
$C->deb("Fate passed to parameter_03: ", ::fatestr($fate)) if $::DEBUG & DEBUG::fates;
($C->{'_fate'}, $tag, $try) = @$fate;
@try = ($try);
$x = 'ALT parameter_03';    # some outer ltm is controlling us
}
else {
$x = 'ALTLTM parameter_03'; # we are top level ltm
}
my $C = $C->cursor_xact($x);
my $xact = $C->xact;

my @gather = ();
for (;;) {
if (not @try) {
$relex //= $C->cursor_fate('STD::P6', 'parameter_03', $retree);
@try = $relex->($C, $trystate);
}
last unless @try;
$try = shift(@try) // next;

if (ref $try eq 'ARRAY') {
($C->{'_fate'}, $tag, $try) = @$try;	# next candidate fate
}

$C->deb("parameter_03 trying $tag $try") if $::DEBUG & DEBUG::try_processing;
push @gather, ((
sub { my $C=shift;
do {
if (my ($C) = ($C->_SUBSUMEr(['param_var'], sub {
my $C = shift;
$C->param_var
}))) {
scalar(do {
$quant = ''; $kind = '!'; 
}, $C);
}
else {
();
}
}
},
sub { my $C=shift;
do {
if (my ($C) = ($C->_SUBSUMEr(['named_param'], sub {
my $C = shift;
$C->named_param
}))) {
scalar(do {
$quant = ''; $kind = '*'; 
}, $C);
}
else {
();
}
}
},
)[$try])->($C);
last if $xact->[-2];  # committed?
last if @gather;
}
@gather;
};
@result;
}

}))) {
$C->_BRACKETr(sub {
my $C=shift;
do {
my @result = do {
my $trystate;
my ($tag, $try);
my @try;
my $relex;

my $fate;
my $x;
if ($fate = $C->{'_fate'} and $fate->[1] eq 'parameter_04') {
$C->deb("Fate passed to parameter_04: ", ::fatestr($fate)) if $::DEBUG & DEBUG::fates;
($C->{'_fate'}, $tag, $try) = @$fate;
@try = ($try);
$x = 'ALT parameter_04';    # some outer ltm is controlling us
}
else {
$x = 'ALTLTM parameter_04'; # we are top level ltm
}
my $C = $C->cursor_xact($x);
my $xact = $C->xact;

my @gather = ();
for (;;) {
if (not @try) {
$relex //= $C->cursor_fate('STD::P6', 'parameter_04', $retree);
@try = $relex->($C, $trystate);
}
last unless @try;
$try = shift(@try) // next;

if (ref $try eq 'ARRAY') {
($C->{'_fate'}, $tag, $try) = @$try;	# next candidate fate
}

$C->deb("parameter_04 trying $tag $try") if $::DEBUG & DEBUG::try_processing;
push @gather, ((
sub { my $C=shift;
do {
if (my ($C) = ($C->_EXACT('?'))) {
scalar(do {
$quant = '?'; $kind = '?' 
}, $C);
}
else {
();
}
}
},
sub { my $C=shift;
do {
if (my ($C) = ($C->_EXACT('!'))) {
scalar(do {
$quant = '!'; $kind //= '!' 
}, $C);
}
else {
();
}
}
},
sub { my $C=shift;
$C->before( sub { my $C=shift;
$C
})
},
)[$try])->($C);
last if $xact->[-2];  # committed?
last if @gather;
}
@gather;
};
@result;
}

});
}
else {
();
}
}
},
sub { my $C=shift;
do {
if (my ($C) = ($C->before( sub { my $C=shift;
$C
}))) {
scalar(do {
$quant = ''; $kind = '!' 
}, $C);
}
else {
();
}
}
},
)[$try])->($C);
last if $xact->[-2];  # committed?
last if @gather;
}
@gather;
};
@result;
}

});
}
else {
();
}
};
}
else {
();
}
}
},
sub { my $C=shift;
do {
if (my ($C) = ($C->_EXACT('**'))) {
do {
if (my ($C) = ($C->_SUBSUMEr(['param_var'], sub {
my $C = shift;
$C->param_var
}))) {
scalar(do {
$quant = '**'; $kind = '*'; 
}, $C);
}
else {
();
}
};
}
else {
();
}
}
},
sub { my $C=shift;
do {
if (my ($C) = ($C->_EXACT('*'))) {
do {
if (my ($C) = ($C->_SUBSUMEr(['param_var'], sub {
my $C = shift;
$C->param_var
}))) {
scalar(do {
$quant = '*'; $kind = '*'; 
}, $C);
}
else {
();
}
};
}
else {
();
}
}
},
sub { my $C=shift;
do {
if (my ($C) = ($C->_EXACT('|'))) {
do {
if (my ($C) = ($C->_SUBSUMEr(['param_var'], sub {
my $C = shift;
$C->param_var
}))) {
scalar(do {
$quant = '|'; $kind = '*'; 
}, $C);
}
else {
();
}
};
}
else {
();
}
}
},
sub { my $C=shift;
do {
if (my ($C) = ($C->_EXACT('\\'))) {
do {
if (my ($C) = ($C->_SUBSUMEr(['param_var'], sub {
my $C = shift;
$C->param_var
}))) {
scalar(do {
$quant = '\\'; $kind = '!'; 
}, $C);
}
else {
();
}
};
}
else {
();
}
}
},
sub { my $C=shift;
do {
if (my ($C) = ($C->_BRACKETr(sub {
my $C=shift;
do {
my @result = do {
my $trystate;
my ($tag, $try);
my @try;
my $relex;

my $fate;
my $x;
if ($fate = $C->{'_fate'} and $fate->[1] eq 'parameter_05') {
$C->deb("Fate passed to parameter_05: ", ::fatestr($fate)) if $::DEBUG & DEBUG::fates;
($C->{'_fate'}, $tag, $try) = @$fate;
@try = ($try);
$x = 'ALT parameter_05';    # some outer ltm is controlling us
}
else {
$x = 'ALTLTM parameter_05'; # we are top level ltm
}
my $C = $C->cursor_xact($x);
my $xact = $C->xact;

my @gather = ();
for (;;) {
if (not @try) {
$relex //= $C->cursor_fate('STD::P6', 'parameter_05', $retree);
@try = $relex->($C, $trystate);
}
last unless @try;
$try = shift(@try) // next;

if (ref $try eq 'ARRAY') {
($C->{'_fate'}, $tag, $try) = @$try;	# next candidate fate
}

$C->deb("parameter_05 trying $tag $try") if $::DEBUG & DEBUG::try_processing;
push @gather, ((
sub { my $C=shift;
do {
if (my ($C) = ($C->_SUBSUMEr(['param_var'], sub {
my $C = shift;
$C->param_var
}))) {
scalar(do {
$quant = ''; $kind = '!'; 
}, $C);
}
else {
();
}
}
},
sub { my $C=shift;
do {
if (my ($C) = ($C->_SUBSUMEr(['named_param'], sub {
my $C = shift;
$C->named_param
}))) {
scalar(do {
$quant = ''; $kind = '*'; 
}, $C);
}
else {
();
}
}
},
)[$try])->($C);
last if $xact->[-2];  # committed?
last if @gather;
}
@gather;
};
@result;
}

}))) {
$C->_BRACKETr(sub {
my $C=shift;
do {
my @result = do {
my $trystate;
my ($tag, $try);
my @try;
my $relex;

my $fate;
my $x;
if ($fate = $C->{'_fate'} and $fate->[1] eq 'parameter_06') {
$C->deb("Fate passed to parameter_06: ", ::fatestr($fate)) if $::DEBUG & DEBUG::fates;
($C->{'_fate'}, $tag, $try) = @$fate;
@try = ($try);
$x = 'ALT parameter_06';    # some outer ltm is controlling us
}
else {
$x = 'ALTLTM parameter_06'; # we are top level ltm
}
my $C = $C->cursor_xact($x);
my $xact = $C->xact;

my @gather = ();
for (;;) {
if (not @try) {
$relex //= $C->cursor_fate('STD::P6', 'parameter_06', $retree);
@try = $relex->($C, $trystate);
}
last unless @try;
$try = shift(@try) // next;

if (ref $try eq 'ARRAY') {
($C->{'_fate'}, $tag, $try) = @$try;	# next candidate fate
}

$C->deb("parameter_06 trying $tag $try") if $::DEBUG & DEBUG::try_processing;
push @gather, ((
sub { my $C=shift;
do {
if (my ($C) = ($C->_EXACT('?'))) {
scalar(do {
$quant = '?'; $kind = '?' 
}, $C);
}
else {
();
}
}
},
sub { my $C=shift;
do {
if (my ($C) = ($C->_EXACT('!'))) {
scalar(do {
$quant = '!'; $kind //= '!' 
}, $C);
}
else {
();
}
}
},
sub { my $C=shift;
$C->before( sub { my $C=shift;
$C
})
},
)[$try])->($C);
last if $xact->[-2];  # committed?
last if @gather;
}
@gather;
};
@result;
}

});
}
else {
();
}
}
},
sub { my $C=shift;
do {
if (my ($C) = (scalar(do {

}, $C))) {
do {
if (my ($C) = ($C->_SUBSUMEr(['longname'], sub {
my $C = shift;
$C->longname
}))) {
do { my $M = $C;
$C->panic("In parameter declaration, typename '" . $M->{'longname'}->Str . "' must be predeclared (or marked as declarative with :: prefix)")
; };
}
else {
();
}
};
}
else {
();
}
}
},
)[$try])->($C);
last if $xact->[-2];  # committed?
last if @gather;
}
@gather;
};
@result;
}

}))) {
do {
if (my ($C) = ($C->_STARr(sub { my $C=shift;
$C->_SUBSUMEr(['trait'], sub {
my $C = shift;
$C->trait
})
}))) {
do {
if (my ($C) = ($C->_STARr(sub { my $C=shift;
$C->_SUBSUMEr(['post_constraint'], sub {
my $C = shift;
$C->post_constraint
})
}))) {
do {
if (my ($C) = ($C->getdecl)) {
do {
if (my ($C) = ($C->_OPTr(sub { my $C=shift;
$C->_BRACKETr(sub {
my $C=shift;
do {
if (my ($C) = ($C->_SUBSUMEr(['default_value'], sub {
my $C = shift;
$C->default_value
}))) {
do {
if (my ($C) = (scalar(do {

given ($quant) {
when ('!') { $C->panic("Can't put a default on a required parameter") }
when ('*') { $C->panic("Can't put a default on a slurpy parameter") }
when ('**') { $C->panic("Can't put a default on a slice parameter") }
when ('|') { $C->panic("Can't put a default on an slurpy capture parameter") }
when ('\\') { $C->panic("Can't put a default on a capture parameter") }
};
$kind = '?' if $kind eq '!';

}, $C))) {
do {
if (my ($C) = ($C->_OPTr(sub { my $C=shift;
$C->_BRACKETr(sub {
my $C=shift;
do {
if (my ($C) = ($C->before(sub { my $C=shift;
$C->_EXACT(':')
}))) {
$C->panic("Can't put a default on the invocant parameter");
}
else {
();
}
}
})
}))) {
$C->_OPTr(sub { my $C=shift;
$C->_BRACKETr(sub {
my $C=shift;
do {
if (my ($C) = ($C->_NOTBEFORE( sub { my $C=shift;
$C->before(sub { my $C=shift;
$C->_PATTERN(qr/\G[,;)\]\{\-]/)
})
}))) {
$C->panic("Default expression must come last");
}
else {
();
}
}
})
});
}
else {
();
}
};
}
else {
();
}
};
}
else {
();
}
}
})
}))) {
do {
if (my ($C) = ($C->_OPTr(sub { my $C=shift;
$C->_BRACKETr(sub {
my $C=shift;
do {
if (my ($C) = ($C->before(sub { my $C=shift;
$C->_EXACT(':')
}))) {
do {
if (my ($C) = ($C->before( sub { my $C=shift;
(($C) x !!do {
$kind ne '!' 
})
}))) {
$C->panic("Invocant is too exotic");
}
else {
();
}
};
}
else {
();
}
}
})
}))) {
do {
if (my ($C) = (scalar(do {
my $M = $C; 
$M->{'quant'} = $quant;
$M->{'kind'} = $kind;
;
}, $C))) {
scalar(do {

given ($kind) {
when ('!') {
given ($::zone) {
when ('posopt') {
$C->panic("Can't put required parameter after optional parameters");
}
when ('var') {
$C->panic("Can't put required parameter after variadic parameters");
}
};
}
when ('?') {
given ($::zone) {
when ('posreq') { $::zone = 'posopt' }
when ('var') {
$C->panic("Can't put optional positional parameter after variadic parameters");
}
};
}
when ('*') {
$::zone = 'var';
}
};

}, $C);
}
else {
();
}
};
}
else {
();
}
};
}
else {
();
}
};
}
else {
();
}
};
}
else {
();
}
};
}
else {
();
}
};
}
else {
();
}
}
);
}

##     rule default_value
##          rule default_value {
##              :my $*IN_DECL = '';
##              '=' <EXPR(item %item_assignment)>
##          }

sub default_value__PEEK { $_[0]->_AUTOLEXpeek('default_value',$retree) }
sub default_value {
no warnings 'recursion';
my $self = shift;
local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;
local $::IN_DECL = '';


my $C = $self->cursor_xact("RULE default_value");
my $xact = $C->xact;
my $S = $C->{'_pos'};

$self->_MATCHIFYr($S, "default_value", 
do {
if (my ($C) = ($C->ws)) {
do {
if (my ($C) = ($C->_EXACT('='))) {
do {
if (my ($C) = ($C->ws)) {
do {
if (my ($C) = ($C->_SUBSUMEr(['EXPR'], sub {
my $C = shift;
$C->EXPR(\%item_assignment)
}))) {
$C->ws;
}
else {
();
}
};
}
else {
();
}
};
}
else {
();
}
};
}
else {
();
}
}
);
}

##     token statement_prefix__S_230sink (:$*sym = 'sink')
##          token statement_prefix:sink    { <sym> <blast> }

sub statement_prefix__S_230sink__PEEK { $_[0]->_AUTOLEXpeek('statement_prefix__S_230sink',$retree) }
sub statement_prefix__S_230sink {
no warnings 'recursion';
my $self = shift;
local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;
my %args = @_;
local $::sym = $args{sym} // 'sink';


my $C = $self->cursor_xact("RULE statement_prefix__S_230sink");
my $xact = $C->xact;
my $S = $C->{'_pos'};
$C->{'sym'} = ref $sym ? join(' ', @$sym) : $sym;

$self->_MATCHIFYr($S, "statement_prefix__S_230sink", 
do {
if (my ($C) = ($C->_PATTERN(qr/\Gsink/))) {
$C->_SUBSUMEr(['blast'], sub {
my $C = shift;
$C->blast
});
}
else {
();
}
}
);
}
##     token statement_prefix__S_231try (:$*sym = 'try')
##          token statement_prefix:try     { <sym> <blast> }

sub statement_prefix__S_231try__PEEK { $_[0]->_AUTOLEXpeek('statement_prefix__S_231try',$retree) }
sub statement_prefix__S_231try {
no warnings 'recursion';
my $self = shift;
local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;
my %args = @_;
local $::sym = $args{sym} // 'try';


my $C = $self->cursor_xact("RULE statement_prefix__S_231try");
my $xact = $C->xact;
my $S = $C->{'_pos'};
$C->{'sym'} = ref $sym ? join(' ', @$sym) : $sym;

$self->_MATCHIFYr($S, "statement_prefix__S_231try", 
do {
if (my ($C) = ($C->_PATTERN(qr/\Gtry/))) {
$C->_SUBSUMEr(['blast'], sub {
my $C = shift;
$C->blast
});
}
else {
();
}
}
);
}
##     token statement_prefix__S_232quietly (:$*sym = 'quietly')
##          token statement_prefix:quietly { <sym> <blast> }

sub statement_prefix__S_232quietly__PEEK { $_[0]->_AUTOLEXpeek('statement_prefix__S_232quietly',$retree) }
sub statement_prefix__S_232quietly {
no warnings 'recursion';
my $self = shift;
local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;
my %args = @_;
local $::sym = $args{sym} // 'quietly';


my $C = $self->cursor_xact("RULE statement_prefix__S_232quietly");
my $xact = $C->xact;
my $S = $C->{'_pos'};
$C->{'sym'} = ref $sym ? join(' ', @$sym) : $sym;

$self->_MATCHIFYr($S, "statement_prefix__S_232quietly", 
do {
if (my ($C) = ($C->_PATTERN(qr/\Gquietly/))) {
$C->_SUBSUMEr(['blast'], sub {
my $C = shift;
$C->blast
});
}
else {
();
}
}
);
}
##     token statement_prefix__S_233gather (:$*sym = 'gather')
##          token statement_prefix:gather  { <sym> <blast> }

sub statement_prefix__S_233gather__PEEK { $_[0]->_AUTOLEXpeek('statement_prefix__S_233gather',$retree) }
sub statement_prefix__S_233gather {
no warnings 'recursion';
my $self = shift;
local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;
my %args = @_;
local $::sym = $args{sym} // 'gather';


my $C = $self->cursor_xact("RULE statement_prefix__S_233gather");
my $xact = $C->xact;
my $S = $C->{'_pos'};
$C->{'sym'} = ref $sym ? join(' ', @$sym) : $sym;

$self->_MATCHIFYr($S, "statement_prefix__S_233gather", 
do {
if (my ($C) = ($C->_PATTERN(qr/\Ggather/))) {
$C->_SUBSUMEr(['blast'], sub {
my $C = shift;
$C->blast
});
}
else {
();
}
}
);
}
##     token statement_prefix__S_234contend (:$*sym = 'contend')
##          token statement_prefix:contend { <sym> <blast> }

sub statement_prefix__S_234contend__PEEK { $_[0]->_AUTOLEXpeek('statement_prefix__S_234contend',$retree) }
sub statement_prefix__S_234contend {
no warnings 'recursion';
my $self = shift;
local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;
my %args = @_;
local $::sym = $args{sym} // 'contend';


my $C = $self->cursor_xact("RULE statement_prefix__S_234contend");
my $xact = $C->xact;
my $S = $C->{'_pos'};
$C->{'sym'} = ref $sym ? join(' ', @$sym) : $sym;

$self->_MATCHIFYr($S, "statement_prefix__S_234contend", 
do {
if (my ($C) = ($C->_PATTERN(qr/\Gcontend/))) {
$C->_SUBSUMEr(['blast'], sub {
my $C = shift;
$C->blast
});
}
else {
();
}
}
);
}
##     token statement_prefix__S_235async (:$*sym = 'async')
##          token statement_prefix:async   { <sym> <blast> }

sub statement_prefix__S_235async__PEEK { $_[0]->_AUTOLEXpeek('statement_prefix__S_235async',$retree) }
sub statement_prefix__S_235async {
no warnings 'recursion';
my $self = shift;
local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;
my %args = @_;
local $::sym = $args{sym} // 'async';


my $C = $self->cursor_xact("RULE statement_prefix__S_235async");
my $xact = $C->xact;
my $S = $C->{'_pos'};
$C->{'sym'} = ref $sym ? join(' ', @$sym) : $sym;

$self->_MATCHIFYr($S, "statement_prefix__S_235async", 
do {
if (my ($C) = ($C->_PATTERN(qr/\Gasync/))) {
$C->_SUBSUMEr(['blast'], sub {
my $C = shift;
$C->blast
});
}
else {
();
}
}
);
}
##     token statement_prefix__S_236maybe (:$*sym = 'maybe')
##          token statement_prefix:maybe   { <sym> <blast> }

sub statement_prefix__S_236maybe__PEEK { $_[0]->_AUTOLEXpeek('statement_prefix__S_236maybe',$retree) }
sub statement_prefix__S_236maybe {
no warnings 'recursion';
my $self = shift;
local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;
my %args = @_;
local $::sym = $args{sym} // 'maybe';


my $C = $self->cursor_xact("RULE statement_prefix__S_236maybe");
my $xact = $C->xact;
my $S = $C->{'_pos'};
$C->{'sym'} = ref $sym ? join(' ', @$sym) : $sym;

$self->_MATCHIFYr($S, "statement_prefix__S_236maybe", 
do {
if (my ($C) = ($C->_PATTERN(qr/\Gmaybe/))) {
$C->_SUBSUMEr(['blast'], sub {
my $C = shift;
$C->blast
});
}
else {
();
}
}
);
}
##     token statement_prefix__S_237lazy (:$*sym = 'lazy')
##          token statement_prefix:lazy    { <sym> <blast> }

sub statement_prefix__S_237lazy__PEEK { $_[0]->_AUTOLEXpeek('statement_prefix__S_237lazy',$retree) }
sub statement_prefix__S_237lazy {
no warnings 'recursion';
my $self = shift;
local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;
my %args = @_;
local $::sym = $args{sym} // 'lazy';


my $C = $self->cursor_xact("RULE statement_prefix__S_237lazy");
my $xact = $C->xact;
my $S = $C->{'_pos'};
$C->{'sym'} = ref $sym ? join(' ', @$sym) : $sym;

$self->_MATCHIFYr($S, "statement_prefix__S_237lazy", 
do {
if (my ($C) = ($C->_PATTERN(qr/\Glazy/))) {
$C->_SUBSUMEr(['blast'], sub {
my $C = shift;
$C->blast
});
}
else {
();
}
}
);
}
##     token statement_prefix__S_238do (:$*sym = 'do')
##          token statement_prefix:do      { <sym> <blast> }

sub statement_prefix__S_238do__PEEK { $_[0]->_AUTOLEXpeek('statement_prefix__S_238do',$retree) }
sub statement_prefix__S_238do {
no warnings 'recursion';
my $self = shift;
local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;
my %args = @_;
local $::sym = $args{sym} // 'do';


my $C = $self->cursor_xact("RULE statement_prefix__S_238do");
my $xact = $C->xact;
my $S = $C->{'_pos'};
$C->{'sym'} = ref $sym ? join(' ', @$sym) : $sym;

$self->_MATCHIFYr($S, "statement_prefix__S_238do", 
do {
if (my ($C) = ($C->_PATTERN(qr/\Gdo/))) {
$C->_SUBSUMEr(['blast'], sub {
my $C = shift;
$C->blast
});
}
else {
();
}
}
);
}

##     token statement_prefix__S_239lift (:$*sym = 'lift')
##          token statement_prefix:lift    {
##              :my $*QUASIMODO = 1;
##              <sym> <blast>
##          }

sub statement_prefix__S_239lift__PEEK { $_[0]->_AUTOLEXpeek('statement_prefix__S_239lift',$retree) }
sub statement_prefix__S_239lift {
no warnings 'recursion';
my $self = shift;
local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;
my %args = @_;
local $::sym = $args{sym} // 'lift';
local $::QUASIMODO = 1;


my $C = $self->cursor_xact("RULE statement_prefix__S_239lift");
my $xact = $C->xact;
my $S = $C->{'_pos'};
$C->{'sym'} = ref $sym ? join(' ', @$sym) : $sym;

$self->_MATCHIFYr($S, "statement_prefix__S_239lift", 
do {
if (my ($C) = ($C->_PATTERN(qr/\Glift/))) {
$C->_SUBSUMEr(['blast'], sub {
my $C = shift;
$C->blast
});
}
else {
();
}
}
);
}

# accepts blocks and statements
##     token blast
##          token blast {
##              <?before \s> <.ws>
##              [
##              | <block>
##              | <statement>  # creates a dynamic scope but not lexical scope
##              ]
##          }

sub blast__PEEK { $_[0]->_AUTOLEXpeek('blast',$retree) }
sub blast {
no warnings 'recursion';
my $self = shift;
local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;


my $C = $self->cursor_xact("RULE blast");
my $xact = $C->xact;
my $S = $C->{'_pos'};

$self->_MATCHIFYr($S, "blast", 
do {
if (my ($C) = ($C->before(sub { my $C=shift;
$C->_PATTERN(qr/\G\s/)
}))) {
do {
if (my ($C) = ($C->ws)) {
$C->_BRACKETr(sub {
my $C=shift;
do {
my @result = do {
my $trystate;
my ($tag, $try);
my @try;
my $relex;

my $fate;
my $x;
if ($fate = $C->{'_fate'} and $fate->[1] eq 'blast_02') {
$C->deb("Fate passed to blast_02: ", ::fatestr($fate)) if $::DEBUG & DEBUG::fates;
($C->{'_fate'}, $tag, $try) = @$fate;
@try = ($try);
$x = 'ALT blast_02';    # some outer ltm is controlling us
}
else {
$x = 'ALTLTM blast_02'; # we are top level ltm
}
my $C = $C->cursor_xact($x);
my $xact = $C->xact;

my @gather = ();
for (;;) {
if (not @try) {
$relex //= $C->cursor_fate('STD::P6', 'blast_02', $retree);
@try = $relex->($C, $trystate);
}
last unless @try;
$try = shift(@try) // next;

if (ref $try eq 'ARRAY') {
($C->{'_fate'}, $tag, $try) = @$try;	# next candidate fate
}

$C->deb("blast_02 trying $tag $try") if $::DEBUG & DEBUG::try_processing;
push @gather, ((
sub { my $C=shift;
$C->_SUBSUMEr(['block'], sub {
my $C = shift;
$C->block
})
},
sub { my $C=shift;
$C->_SUBSUMEr(['statement'], sub {
my $C = shift;
$C->statement
})
},
)[$try])->($C);
last if $xact->[-2];  # committed?
last if @gather;
}
@gather;
};
@result;
}

});
}
else {
();
}
};
}
else {
();
}
}
);
}

#########
# Terms #
#########

# start playing with the setting stubber
##     token term__S_240YOU_ARE_HERE (:$*sym = 'YOU_ARE_HERE')
##          token term:YOU_ARE_HERE {
##              <sym> <.you_are_here>
##              <O(|%term)>
##          }

sub term__S_240YOU_ARE_HERE__PEEK { $_[0]->_AUTOLEXpeek('term__S_240YOU_ARE_HERE',$retree) }
sub term__S_240YOU_ARE_HERE {
no warnings 'recursion';
my $self = shift;
local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;
my %args = @_;
local $::sym = $args{sym} // 'YOU_ARE_HERE';


my $C = $self->cursor_xact("RULE term__S_240YOU_ARE_HERE");
my $xact = $C->xact;
my $S = $C->{'_pos'};
$C->{'sym'} = ref $sym ? join(' ', @$sym) : $sym;

$self->_MATCHIFYr($S, "term__S_240YOU_ARE_HERE", 
do {
if (my ($C) = ($C->_PATTERN(qr/\GYOU_ARE_HERE/))) {
do {
if (my ($C) = ($C->you_are_here)) {
$C->_SUBSUMEr(['O'], sub {
my $C = shift;
$C->O(%term)
});
}
else {
();
}
};
}
else {
();
}
}
);
}

##     token term__S_241new (:$*sym = 'new')
##          token term:new {
##              'new' \h+ <longname> \h* <!before ':'> <.obs("C++ constructor syntax", "method call syntax")>
##          }

sub term__S_241new__PEEK { $_[0]->_AUTOLEXpeek('term__S_241new',$retree) }
sub term__S_241new {
no warnings 'recursion';
my $self = shift;
local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;
my %args = @_;
local $::sym = $args{sym} // 'new';


my $C = $self->cursor_xact("RULE term__S_241new");
my $xact = $C->xact;
my $S = $C->{'_pos'};
$C->{'sym'} = ref $sym ? join(' ', @$sym) : $sym;

$self->_MATCHIFYr($S, "term__S_241new", 
do {
if (my ($C) = ($C->_EXACT('new'))) {
do {
if (my ($C) = ($C->_PATTERN(qr/\G((?:[\x20\t\r])++)/))) {
do {
if (my ($C) = ($C->_SUBSUMEr(['longname'], sub {
my $C = shift;
$C->longname
}))) {
do {
if (my ($C) = ($C->_PATTERN(qr/\G((?:[\x20\t\r])*+)/))) {
do {
if (my ($C) = ($C->_NOTBEFORE( sub { my $C=shift;
$C->before(sub { my $C=shift;
$C->_EXACT(':')
})
}))) {
$C->obs("C++ constructor syntax", "method call syntax");
}
else {
();
}
};
}
else {
();
}
};
}
else {
();
}
};
}
else {
();
}
};
}
else {
();
}
}
);
}

##     token term__S_242ColonColonQuestionIDENT (:$*sym = <::?IDENT>)
##          token term:sym<::?IDENT> {
##              $<sym> = [ '::?' <identifier> ] 
##              <O(|%term)>
##          }

sub term__S_242ColonColonQuestionIDENT__PEEK { $_[0]->_AUTOLEXpeek('term__S_242ColonColonQuestionIDENT',$retree) }
sub term__S_242ColonColonQuestionIDENT {
no warnings 'recursion';
my $self = shift;
local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;
my %args = @_;
local $::sym = $args{sym} // q(::?IDENT);


my $C = $self->cursor_xact("RULE term__S_242ColonColonQuestionIDENT");
my $xact = $C->xact;
my $S = $C->{'_pos'};
$C->{'sym'} = ref $sym ? join(' ', @$sym) : $sym;

$self->_MATCHIFYr($S, "term__S_242ColonColonQuestionIDENT", 
do {
if (my ($C) = (  $C->_SUBSUMEr(['sym'], sub {
my $C = shift;
$C->_BRACKETr(sub {
my $C=shift;
do {
if (my ($C) = ($C->_EXACT('::?'))) {
$C->_SUBSUMEr(['identifier'], sub {
my $C = shift;
$C->identifier
});
}
else {
();
}
}
})
}))) {
do {
if (my ($C) = ($C->_PATTERN(qr/\G\b/))) {
$C->_SUBSUMEr(['O'], sub {
my $C = shift;
$C->O(%term)
});
}
else {
();
}
};
}
else {
();
}
}
);
}

##     token term__S_243Object (:$*sym = <Object>)
##          token term:sym<Object> {
##              <sym>  {}
##              <.obs('Object', 'Mu as the "most universal" object type')>
##          }

sub term__S_243Object__PEEK { $_[0]->_AUTOLEXpeek('term__S_243Object',$retree) }
sub term__S_243Object {
no warnings 'recursion';
my $self = shift;
local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;
my %args = @_;
local $::sym = $args{sym} // q(Object);


my $C = $self->cursor_xact("RULE term__S_243Object");
my $xact = $C->xact;
my $S = $C->{'_pos'};
$C->{'sym'} = ref $sym ? join(' ', @$sym) : $sym;

$self->_MATCHIFYr($S, "term__S_243Object", 
do {
if (my ($C) = ($C->_PATTERN(qr/\GObject/))) {
do {
if (my ($C) = ($C->_PATTERN(qr/\G\b/))) {
do {
if (my ($C) = (scalar(do {

}, $C))) {
$C->obs('Object', 'Mu as the "most universal" object type');
}
else {
();
}
};
}
else {
();
}
};
}
else {
();
}
}
);
}

##     token term__S_244undef (:$*sym = <undef>)
##          token term:sym<undef> {
##              <sym>  {}
##              [ <?before \h*'$/' >
##                  <.obs('$/ variable as input record separator',
##                       "the filehandle's .slurp method")>
##              ]?
##              [ <?before [ '(' || \h*<sigil><twigil>?\w ] >
##                  <.obs('undef as a verb', 'undefine function or assignment of Nil')>
##              ]?
##              <.obs('undef as a value', "something more specific:\n\tMu (the \"most undefined\" type object),\n\tan undefined type object such as Int,\n\tNil as an empty list,\n\t:!defined as a matcher,\n\tAny:U as a type constraint\n\tor fail() as a failure return\n\t   ")>
##          }

sub term__S_244undef__PEEK { $_[0]->_AUTOLEXpeek('term__S_244undef',$retree) }
sub term__S_244undef {
no warnings 'recursion';
my $self = shift;
local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;
my %args = @_;
local $::sym = $args{sym} // q(undef);


my $C = $self->cursor_xact("RULE term__S_244undef");
my $xact = $C->xact;
my $S = $C->{'_pos'};
$C->{'sym'} = ref $sym ? join(' ', @$sym) : $sym;

$self->_MATCHIFYr($S, "term__S_244undef", 
do {
if (my ($C) = ($C->_PATTERN(qr/\Gundef/))) {
do {
if (my ($C) = ($C->_PATTERN(qr/\G\b/))) {
do {
if (my ($C) = (scalar(do {

}, $C))) {
do {
if (my ($C) = ($C->_OPTr(sub { my $C=shift;
$C->_BRACKETr(sub {
my $C=shift;
do {
if (my ($C) = ($C->before(sub { my $C=shift;
do {
if (my ($C) = ($C->_PATTERN(qr/\G((?:[\x20\t\r])*+)/))) {
$C->_EXACT('$/');
}
else {
();
}
}
}))) {
$C->obs('$/ variable as input record separator',
"the filehandle's .slurp method");
}
else {
();
}
}
})
}))) {
do {
if (my ($C) = ($C->_OPTr(sub { my $C=shift;
$C->_BRACKETr(sub {
my $C=shift;
do {
if (my ($C) = ($C->before(sub { my $C=shift;
$C->_BRACKETr(sub {
my $C=shift;
do {
my $C = $C->cursor_xact('ALT ||');
my $xact = $C->xact;
my @gather;
do {
push @gather, $C->_EXACT('(')
}
or $xact->[-2] or
do {
push @gather, do {
if (my ($C) = ($C->_PATTERN(qr/\G((?:[\x20\t\r])*+)/))) {
do {
if (my ($C) = ($C->_SUBSUMEr(['sigil'], sub {
my $C = shift;
$C->sigil
}))) {
do {
if (my ($C) = ($C->_OPTr(sub { my $C=shift;
$C->_SUBSUMEr(['twigil'], sub {
my $C = shift;
$C->twigil
})
}))) {
$C->_PATTERN(qr/\G\w/);
}
else {
();
}
};
}
else {
();
}
};
}
else {
();
}
}};
@gather;
}
})
}))) {
$C->obs('undef as a verb', 'undefine function or assignment of Nil');
}
else {
();
}
}
})
}))) {
$C->obs('undef as a value', "something more specific:\n\tMu (the \"most undefined\" type object),\n\tan undefined type object such as Int,\n\tNil as an empty list,\n\t:!defined as a matcher,\n\tAny:U as a type constraint\n\tor fail() as a failure return\n\t   ");
}
else {
();
}
};
}
else {
();
}
};
}
else {
();
}
};
}
else {
();
}
};
}
else {
();
}
}
);
}

##     token term__S_245proceed (:$*sym = <proceed>)
##          token term:sym<proceed>
##              { <sym>  <O(|%term)> }

sub term__S_245proceed__PEEK { $_[0]->_AUTOLEXpeek('term__S_245proceed',$retree) }
sub term__S_245proceed {
no warnings 'recursion';
my $self = shift;
local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;
my %args = @_;
local $::sym = $args{sym} // q(proceed);


my $C = $self->cursor_xact("RULE term__S_245proceed");
my $xact = $C->xact;
my $S = $C->{'_pos'};
$C->{'sym'} = ref $sym ? join(' ', @$sym) : $sym;

$self->_MATCHIFYr($S, "term__S_245proceed", 
do {
if (my ($C) = ($C->_PATTERN(qr/\Gproceed/))) {
do {
if (my ($C) = ($C->_PATTERN(qr/\G\b/))) {
$C->_SUBSUMEr(['O'], sub {
my $C = shift;
$C->O(%term)
});
}
else {
();
}
};
}
else {
();
}
}
);
}

##     token term__S_246self (:$*sym = <self>)
##          token term:sym<self>
##              { <sym>  <O(|%term)> }

sub term__S_246self__PEEK { $_[0]->_AUTOLEXpeek('term__S_246self',$retree) }
sub term__S_246self {
no warnings 'recursion';
my $self = shift;
local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;
my %args = @_;
local $::sym = $args{sym} // q(self);


my $C = $self->cursor_xact("RULE term__S_246self");
my $xact = $C->xact;
my $S = $C->{'_pos'};
$C->{'sym'} = ref $sym ? join(' ', @$sym) : $sym;

$self->_MATCHIFYr($S, "term__S_246self", 
do {
if (my ($C) = ($C->_PATTERN(qr/\Gself/))) {
do {
if (my ($C) = ($C->_PATTERN(qr/\G\b/))) {
$C->_SUBSUMEr(['O'], sub {
my $C = shift;
$C->O(%term)
});
}
else {
();
}
};
}
else {
();
}
}
);
}

##     token term__S_247defer (:$*sym = <defer>)
##          token term:sym<defer>
##              { <sym>  <O(|%term)> }

sub term__S_247defer__PEEK { $_[0]->_AUTOLEXpeek('term__S_247defer',$retree) }
sub term__S_247defer {
no warnings 'recursion';
my $self = shift;
local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;
my %args = @_;
local $::sym = $args{sym} // q(defer);


my $C = $self->cursor_xact("RULE term__S_247defer");
my $xact = $C->xact;
my $S = $C->{'_pos'};
$C->{'sym'} = ref $sym ? join(' ', @$sym) : $sym;

$self->_MATCHIFYr($S, "term__S_247defer", 
do {
if (my ($C) = ($C->_PATTERN(qr/\Gdefer/))) {
do {
if (my ($C) = ($C->_PATTERN(qr/\G\b/))) {
$C->_SUBSUMEr(['O'], sub {
my $C = shift;
$C->O(%term)
});
}
else {
();
}
};
}
else {
();
}
}
);
}

##     token term__S_248rand (:$*sym = 'rand')
##          token term:rand {
##              <sym> 
##              [ <?before '('? \h* [\d|'$']> <.obs('rand(N)', 'N.rand or (1..N).pick')> ]?
##              [ <?before '()'> <.obs('rand()', 'rand')> ]?
##              <O(|%term)>
##          }

sub term__S_248rand__PEEK { $_[0]->_AUTOLEXpeek('term__S_248rand',$retree) }
sub term__S_248rand {
no warnings 'recursion';
my $self = shift;
local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;
my %args = @_;
local $::sym = $args{sym} // 'rand';


my $C = $self->cursor_xact("RULE term__S_248rand");
my $xact = $C->xact;
my $S = $C->{'_pos'};
$C->{'sym'} = ref $sym ? join(' ', @$sym) : $sym;

$self->_MATCHIFYr($S, "term__S_248rand", 
do {
if (my ($C) = ($C->_PATTERN(qr/\Grand/))) {
do {
if (my ($C) = ($C->_PATTERN(qr/\G\b/))) {
do {
if (my ($C) = ($C->_OPTr(sub { my $C=shift;
$C->_BRACKETr(sub {
my $C=shift;
do {
if (my ($C) = ($C->before(sub { my $C=shift;
do {
if (my ($C) = ($C->_OPTr(sub { my $C=shift;
$C->_EXACT('(')
}))) {
do {
if (my ($C) = ($C->_PATTERN(qr/\G((?:[\x20\t\r])*+)/))) {
$C->_BRACKETr(sub {
my $C=shift;
do {
my @result = do {
my $trystate;
my ($tag, $try);
my @try;
my $relex;

my $fate;
my $x;
if ($fate = $C->{'_fate'} and $fate->[1] eq 'term__S_248rand_03') {
$C->deb("Fate passed to term__S_248rand_03: ", ::fatestr($fate)) if $::DEBUG & DEBUG::fates;
($C->{'_fate'}, $tag, $try) = @$fate;
@try = ($try);
$x = 'ALT term__S_248rand_03';    # some outer ltm is controlling us
}
else {
$x = 'ALTLTM term__S_248rand_03'; # we are top level ltm
}
my $C = $C->cursor_xact($x);
my $xact = $C->xact;

my @gather = ();
for (;;) {
if (not @try) {
$relex //= $C->cursor_fate('STD::P6', 'term__S_248rand_03', $retree);
@try = $relex->($C, $trystate);
}
last unless @try;
$try = shift(@try) // next;

if (ref $try eq 'ARRAY') {
($C->{'_fate'}, $tag, $try) = @$try;	# next candidate fate
}

$C->deb("term__S_248rand_03 trying $tag $try") if $::DEBUG & DEBUG::try_processing;
push @gather, ((
sub { my $C=shift;
$C->_PATTERN(qr/\G\d/)
},
sub { my $C=shift;
$C->_EXACT('$')
},
)[$try])->($C);
last if $xact->[-2];  # committed?
last if @gather;
}
@gather;
};
@result;
}

});
}
else {
();
}
};
}
else {
();
}
}
}))) {
$C->obs('rand(N)', 'N.rand or (1..N).pick');
}
else {
();
}
}
})
}))) {
do {
if (my ($C) = ($C->_OPTr(sub { my $C=shift;
$C->_BRACKETr(sub {
my $C=shift;
do {
if (my ($C) = ($C->before(sub { my $C=shift;
$C->_EXACT('()')
}))) {
$C->obs('rand()', 'rand');
}
else {
();
}
}
})
}))) {
$C->_SUBSUMEr(['O'], sub {
my $C = shift;
$C->O(%term)
});
}
else {
();
}
};
}
else {
();
}
};
}
else {
();
}
};
}
else {
();
}
}
);
}

##     token term__S_249Star (:$*sym = <*>)
##          token term:sym<*>
##              { <sym> <O(|%term)> }

sub term__S_249Star__PEEK { $_[0]->_AUTOLEXpeek('term__S_249Star',$retree) }
sub term__S_249Star {
no warnings 'recursion';
my $self = shift;
local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;
my %args = @_;
local $::sym = $args{sym} // q(*);


my $C = $self->cursor_xact("RULE term__S_249Star");
my $xact = $C->xact;
my $S = $C->{'_pos'};
$C->{'sym'} = ref $sym ? join(' ', @$sym) : $sym;

$self->_MATCHIFYr($S, "term__S_249Star", 
do {
if (my ($C) = ($C->_PATTERN(qr/\G\*/))) {
$C->_SUBSUMEr(['O'], sub {
my $C = shift;
$C->O(%term)
});
}
else {
();
}
}
);
}

##     token term__S_250StarStar (:$*sym = <**>)
##          token term:sym<**>
##              { <sym> <O(|%term)> }

sub term__S_250StarStar__PEEK { $_[0]->_AUTOLEXpeek('term__S_250StarStar',$retree) }
sub term__S_250StarStar {
no warnings 'recursion';
my $self = shift;
local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;
my %args = @_;
local $::sym = $args{sym} // q(**);


my $C = $self->cursor_xact("RULE term__S_250StarStar");
my $xact = $C->xact;
my $S = $C->{'_pos'};
$C->{'sym'} = ref $sym ? join(' ', @$sym) : $sym;

$self->_MATCHIFYr($S, "term__S_250StarStar", 
do {
if (my ($C) = ($C->_PATTERN(qr/\G\*\*/))) {
$C->_SUBSUMEr(['O'], sub {
my $C = shift;
$C->O(%term)
});
}
else {
();
}
}
);
}

##     token infix__S_251lambda (:$*sym = 'lambda')
##          token infix:lambda {
##              <?before '{' | '->' > <!{ $*IN_META }> {{
##                  my $line = $.lineof($.pos);
##                  for 'if', 'unless', 'while', 'until', 'for', 'loop', 'given', 'when', 'sub' {
##                      my $m = %*MYSTERY{$_};
##                      next unless $m;
##                      if $line - ($m.<line>//-123) < 5 {
##                          if $m.<ctx> eq '(' {
##                              $.panic($_ ~ '() interpreted as function call at line ' ~ $m.<line> ~
##                              "; please use whitespace " ~
##                              ($_ eq 'loop' ?? 'around' !! 'instead of') ~
##                              " parens\nUnexpected block in infix position (two terms in a row)");
##                          }
##                          else {
##                              $.panic("'$_' interpreted as listop at line " ~ $m.<line> ~
##                              "; please use 'do' to introduce statement_control:<$_>.\nUnexpected block in infix position (two terms in a row)");
##                          }
##                      }
##                  }
##                  return () if $*IN_REDUCE;
##                  my $endpos = $.pos;
##                  my $startpos = @*MEMOS[$endpos]<ws> // $endpos;
##      
##                  if self.lineof($startpos) != self.lineof($endpos) {
##                      $.panic("Unexpected block in infix position (previous line missing its semicolon?)");
##                  }
##                  elsif @*MEMOS[$.pos-1]<baremeth> {
##                      $.panic("Unexpected block in infix position (method call needs colon or parens to take arguments)");
##                  }
##                  else {
##                      $.panic("Unexpected block in infix position (two terms in a row, or previous statement missing semicolon?)");
##                  }
##              }}
##              <O(|%term)>
##          }

sub infix__S_251lambda__PEEK { $_[0]->_AUTOLEXpeek('infix__S_251lambda',$retree) }
sub infix__S_251lambda {
no warnings 'recursion';
my $self = shift;
local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;
my %args = @_;
local $::sym = $args{sym} // 'lambda';


my $C = $self->cursor_xact("RULE infix__S_251lambda");
my $xact = $C->xact;
my $S = $C->{'_pos'};
$C->{'sym'} = ref $sym ? join(' ', @$sym) : $sym;

$self->_MATCHIFYr($S, "infix__S_251lambda", 
do {
if (my ($C) = ($C->before(sub { my $C=shift;
do {
my @result = do {
my $trystate;
my ($tag, $try);
my @try;
my $relex;

my $fate;
my $x;
if ($fate = $C->{'_fate'} and $fate->[1] eq 'infix__S_251lambda_01') {
$C->deb("Fate passed to infix__S_251lambda_01: ", ::fatestr($fate)) if $::DEBUG & DEBUG::fates;
($C->{'_fate'}, $tag, $try) = @$fate;
@try = ($try);
$x = 'ALT infix__S_251lambda_01';    # some outer ltm is controlling us
}
else {
$x = 'ALTLTM infix__S_251lambda_01'; # we are top level ltm
}
my $C = $C->cursor_xact($x);
my $xact = $C->xact;

my @gather = ();
for (;;) {
if (not @try) {
$relex //= $C->cursor_fate('STD::P6', 'infix__S_251lambda_01', $retree);
@try = $relex->($C, $trystate);
}
last unless @try;
$try = shift(@try) // next;

if (ref $try eq 'ARRAY') {
($C->{'_fate'}, $tag, $try) = @$try;	# next candidate fate
}

$C->deb("infix__S_251lambda_01 trying $tag $try") if $::DEBUG & DEBUG::try_processing;
push @gather, ((
sub { my $C=shift;
$C->_EXACT('{')
},
sub { my $C=shift;
$C->_EXACT('->')
},
)[$try])->($C);
last if $xact->[-2];  # committed?
last if @gather;
}
@gather;
};
@result;
}

}))) {
do {
if (my ($C) = ($C->_NOTBEFORE( sub { my $C=shift;
(($C) x !!do {
$::IN_META 
})
}))) {
do {
if (my ($C) = (scalar(do {

my $line = $C->lineof($C->{'_pos'});
for ('if', 'unless', 'while', 'until', 'for', 'loop', 'given', 'when', 'sub') {
my $m = $::MYSTERY{$_};
next unless $m;
if ($line - ($m->{'line'}//-123) < 5) {
if ($m->{'ctx'} eq '(') {
$C->panic($_ . '() interpreted as function call at line ' . $m->{'line'} .
"; please use whitespace " .
($_ eq 'loop' ? 'around' : 'instead of') .
" parens\nUnexpected block in infix position (two terms in a row)");
}
else {
$C->panic("'$_' interpreted as listop at line " . $m->{'line'} .
"; please use 'do' to introduce statement_control:<$_>.\nUnexpected block in infix position (two terms in a row)");
}
}
};
return () if $::IN_REDUCE;
my $endpos = $C->{'_pos'};
my $startpos = $::MEMOS[$endpos]{'ws'} // $endpos;

if ($self->lineof($startpos) != $self->lineof($endpos)) {
$C->panic("Unexpected block in infix position (previous line missing its semicolon?)");
}
elsif ($::MEMOS[$C->{'_pos'}-1]{'baremeth'}) {
$C->panic("Unexpected block in infix position (method call needs colon or parens to take arguments)");
}
else {
$C->panic("Unexpected block in infix position (two terms in a row, or previous statement missing semicolon?)");
}

}, $C))) {
$C->_SUBSUMEr(['O'], sub {
my $C = shift;
$C->O(%term)
});
}
else {
();
}
};
}
else {
();
}
};
}
else {
();
}
}
);
}

##     token circumfix__S_252sigil (:$*sym = 'sigil')
##          token circumfix:sigil
##              { :dba('contextualizer') <sigil> '(' ~ ')' <semilist> { $*LEFTSIGIL ||= $<sigil>.Str } <O(|%term)> }

sub circumfix__S_252sigil__PEEK { $_[0]->_AUTOLEXpeek('circumfix__S_252sigil',$retree) }
sub circumfix__S_252sigil {
no warnings 'recursion';
my $self = shift;
local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;
my %args = @_;
local $::sym = $args{sym} // 'sigil';


my $C = $self->cursor_xact("RULE circumfix__S_252sigil");
my $xact = $C->xact;
my $S = $C->{'_pos'};
$C->{'sym'} = ref $sym ? join(' ', @$sym) : $sym;

$self->_MATCHIFYr($S, "circumfix__S_252sigil", 
do {
if (my ($C) = ($C->_SUBSUMEr(['sigil'], sub {
my $C = shift;
$C->sigil
}))) {
do {
if (my ($C) = ($C->_EXACT('('))) {
do {
if (my ($C) = (((local $::GOAL = ')' ), $C)[-1])) {
do {
if (my ($C) = ($C->_SUBSUMEr(['semilist'], sub {
my $C = shift;
$C->semilist
}))) {
do {
if (my ($C) = ($C->_BRACKETr(sub {
my $C=shift;
do {
my $C = $C->cursor_xact('ALT ||');
my $xact = $C->xact;
my @gather;
do {
push @gather, $C->_EXACT(')')
}
or $xact->[-2] or
do {
push @gather, $C->FAILGOAL(')' , 'contextualizer')};
@gather;
}
}))) {
do {
if (my ($C) = (scalar(do {
my $M = $C;  $::LEFTSIGIL ||= $M->{'sigil'}->Str ;
}, $C))) {
$C->_SUBSUMEr(['O'], sub {
my $C = shift;
$C->O(%term)
});
}
else {
();
}
};
}
else {
();
}
};
}
else {
();
}
};
}
else {
();
}
};
}
else {
();
}
};
}
else {
();
}
}
);
}

##     token circumfix__S_253Paren_Thesis (:$*sym = <( )>)
##          token circumfix:sym<( )>
##              { :dba('parenthesized expression') '(' ~ ')' <semilist> <O(|%term)> }

sub circumfix__S_253Paren_Thesis__PEEK { $_[0]->_AUTOLEXpeek('circumfix__S_253Paren_Thesis',$retree) }
sub circumfix__S_253Paren_Thesis {
no warnings 'recursion';
my $self = shift;
local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;
my %args = @_;
local $::sym = $args{sym} // [qw[( )]];


my $C = $self->cursor_xact("RULE circumfix__S_253Paren_Thesis");
my $xact = $C->xact;
my $S = $C->{'_pos'};
$C->{'sym'} = ref $sym ? join(' ', @$sym) : $sym;

$self->_MATCHIFYr($S, "circumfix__S_253Paren_Thesis", 
do {
if (my ($C) = ($C->_EXACT('('))) {
do {
if (my ($C) = (((local $::GOAL = ')' ), $C)[-1])) {
do {
if (my ($C) = ($C->_SUBSUMEr(['semilist'], sub {
my $C = shift;
$C->semilist
}))) {
do {
if (my ($C) = ($C->_BRACKETr(sub {
my $C=shift;
do {
my $C = $C->cursor_xact('ALT ||');
my $xact = $C->xact;
my @gather;
do {
push @gather, $C->_EXACT(')')
}
or $xact->[-2] or
do {
push @gather, $C->FAILGOAL(')' , 'parenthesized expression')};
@gather;
}
}))) {
$C->_SUBSUMEr(['O'], sub {
my $C = shift;
$C->O(%term)
});
}
else {
();
}
};
}
else {
();
}
};
}
else {
();
}
};
}
else {
();
}
}
);
}

##     token circumfix__S_254Bra_Ket (:$*sym = <[ ]>)
##          token circumfix:sym<[ ]>
##              { :dba('array composer') '[' ~ ']' <semilist> <O(|%term)> { @*MEMOS[$.pos]<arraycomp> = 1; } }

sub circumfix__S_254Bra_Ket__PEEK { $_[0]->_AUTOLEXpeek('circumfix__S_254Bra_Ket',$retree) }
sub circumfix__S_254Bra_Ket {
no warnings 'recursion';
my $self = shift;
local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;
my %args = @_;
local $::sym = $args{sym} // [qw([ ])];


my $C = $self->cursor_xact("RULE circumfix__S_254Bra_Ket");
my $xact = $C->xact;
my $S = $C->{'_pos'};
$C->{'sym'} = ref $sym ? join(' ', @$sym) : $sym;

$self->_MATCHIFYr($S, "circumfix__S_254Bra_Ket", 
do {
if (my ($C) = ($C->_EXACT('['))) {
do {
if (my ($C) = (((local $::GOAL = ']' ), $C)[-1])) {
do {
if (my ($C) = ($C->_SUBSUMEr(['semilist'], sub {
my $C = shift;
$C->semilist
}))) {
do {
if (my ($C) = ($C->_BRACKETr(sub {
my $C=shift;
do {
my $C = $C->cursor_xact('ALT ||');
my $xact = $C->xact;
my @gather;
do {
push @gather, $C->_EXACT(']')
}
or $xact->[-2] or
do {
push @gather, $C->FAILGOAL(']' , 'array composer')};
@gather;
}
}))) {
do {
if (my ($C) = ($C->_SUBSUMEr(['O'], sub {
my $C = shift;
$C->O(%term)
}))) {
scalar(do {
$::MEMOS[$C->{'_pos'}]{'arraycomp'} = 1; 
}, $C);
}
else {
();
}
};
}
else {
();
}
};
}
else {
();
}
};
}
else {
();
}
};
}
else {
();
}
}
);
}

#############
# Operators #
#############

##     token PRE
##          token PRE {
##              :dba('prefix or meta-prefix')
##              [
##              | <prefix>
##                  { $<O> = $<prefix><O>; $<sym> = $<prefix><sym> }
##              | <prefix_circumfix_meta_operator>
##                  { $<O> = $<prefix_circumfix_meta_operator><O>; $<sym> = $<prefix_circumfix_meta_operator>.Str }
##              ]
##              # XXX assuming no precedence change
##              
##              <prefix_postfix_meta_operator>*
##              <.ws>
##          }

sub PRE__PEEK { $_[0]->_AUTOLEXpeek('PRE',$retree) }
sub PRE {
no warnings 'recursion';
my $self = shift;
local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;


my $C = $self->cursor_xact("RULE PRE");
my $xact = $C->xact;
my $S = $C->{'_pos'};
$C->{'prefix_postfix_meta_operator'} = [];

$self->_MATCHIFYr($S, "PRE", 
do {
if (my ($C) = ($C->_BRACKETr(sub {
my $C=shift;
do {
my @result = do {
my $trystate;
my ($tag, $try);
my @try;
my $relex;

my $fate;
my $x;
if ($fate = $C->{'_fate'} and $fate->[1] eq 'PRE_01') {
$C->deb("Fate passed to PRE_01: ", ::fatestr($fate)) if $::DEBUG & DEBUG::fates;
($C->{'_fate'}, $tag, $try) = @$fate;
@try = ($try);
$x = 'ALT PRE_01';    # some outer ltm is controlling us
}
else {
$x = 'ALTLTM PRE_01'; # we are top level ltm
}
my $C = $C->cursor_xact($x);
my $xact = $C->xact;

my @gather = ();
for (;;) {
if (not @try) {
$relex //= $C->cursor_fate('STD::P6', 'PRE_01', $retree);
@try = $relex->($C, $trystate);
}
last unless @try;
$try = shift(@try) // next;

if (ref $try eq 'ARRAY') {
($C->{'_fate'}, $tag, $try) = @$try;	# next candidate fate
}

$C->deb("PRE_01 trying $tag $try") if $::DEBUG & DEBUG::try_processing;
push @gather, ((
sub { my $C=shift;
do {
if (my ($C) = ($C->_SUBSUMEr(['prefix'], sub {
my $C = shift;
$C->prefix
}))) {
scalar(do {
my $M = $C;  $M->{'O'} = $M->{'prefix'}{'O'}; $M->{'sym'} = $M->{'prefix'}{'sym'} ;
}, $C);
}
else {
();
}
}
},
sub { my $C=shift;
do {
if (my ($C) = ($C->_SUBSUMEr(['prefix_circumfix_meta_operator'], sub {
my $C = shift;
$C->prefix_circumfix_meta_operator
}))) {
scalar(do {
my $M = $C;  $M->{'O'} = $M->{'prefix_circumfix_meta_operator'}{'O'}; $M->{'sym'} = $M->{'prefix_circumfix_meta_operator'}->Str ;
}, $C);
}
else {
();
}
}
},
)[$try])->($C);
last if $xact->[-2];  # committed?
last if @gather;
}
@gather;
};
@result;
}

}))) {
do {
if (my ($C) = ($C->_STARr(sub { my $C=shift;
$C->_SUBSUMEr(['prefix_postfix_meta_operator'], sub {
my $C = shift;
$C->prefix_postfix_meta_operator
})
}))) {
$C->ws;
}
else {
();
}
};
}
else {
();
}
}
);
}

##     token infixish ($in_meta = $*IN_META)
##          token infixish ($in_meta = $*IN_META) {
##              :my $infix;
##              :my $*IN_META = $in_meta;
##              <!stdstopper>
##              <!infixstopper>
##              :dba('infix or meta-infix')
##              [
##              | <colonpair> {
##                      $<fake> = 1;
##                      $<sym> = ':';
##                      %<O><prec> = %item_assignment<prec>;  # actual test is non-inclusive!
##                      %<O><assoc> = 'unary';
##                      %<O><dba> = 'adverb';
##                  }
##              |   [
##                  | :dba('bracketed infix') '[' ~ ']' <infix=.infixish(1)> { $<O> = $<infix><O>; $<sym> = $<infix><sym>; }
##                  | <infix=infix_circumfix_meta_operator> { $<O> = $<infix><O>; $<sym> = $<infix><sym>; }
##                  | <infix=infix_prefix_meta_operator>    { $<O> = $<infix><O>; $<sym> = $<infix><sym>; }
##                  | <infix>                               { $<O> = $<infix><O>; $<sym> = $<infix><sym>; }
##                  | {} <?dotty> <.panic: "Method call found where infix expected (omit whitespace?)">
##                  | {} <?postfix> <.panic: "Postfix found where infix expected (omit whitespace?)">
##                  ]
##                  [ <?before '='> <?{ $infix = $<infix>; }> <infix_postfix_meta_operator($infix)>
##                         { $<O> = $<infix_postfix_meta_operator>[0]<O>; $<sym> = $<infix_postfix_meta_operator>[0]<sym>; }
##                  ]?
##      
##              ]
##          }

sub infixish__PEEK { $_[0]->_AUTOLEXpeek('infixish',$retree) }
sub infixish {
no warnings 'recursion';
my $self = shift;
local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;
my $in_meta = shift() // $::IN_META;
my $infix;
local $::IN_META = $in_meta;


my $C = $self->cursor_xact("RULE infixish");
my $xact = $C->xact;
my $S = $C->{'_pos'};
$C->{'infix_postfix_meta_operator'} = [];

$self->_MATCHIFYr($S, "infixish", 
do {
if (my ($C) = ($C->_NOTBEFORE( sub { my $C=shift;
$C->stdstopper
}))) {
do {
if (my ($C) = ($C->_NOTBEFORE( sub { my $C=shift;
$C->infixstopper
}))) {
$C->_BRACKETr(sub {
my $C=shift;
do {
my @result = do {
my $trystate;
my ($tag, $try);
my @try;
my $relex;

my $fate;
my $x;
if ($fate = $C->{'_fate'} and $fate->[1] eq 'infixish_01') {
$C->deb("Fate passed to infixish_01: ", ::fatestr($fate)) if $::DEBUG & DEBUG::fates;
($C->{'_fate'}, $tag, $try) = @$fate;
@try = ($try);
$x = 'ALT infixish_01';    # some outer ltm is controlling us
}
else {
$x = 'ALTLTM infixish_01'; # we are top level ltm
}
my $C = $C->cursor_xact($x);
my $xact = $C->xact;

my @gather = ();
for (;;) {
if (not @try) {
$relex //= $C->cursor_fate('STD::P6', 'infixish_01', $retree);
@try = $relex->($C, $trystate);
}
last unless @try;
$try = shift(@try) // next;

if (ref $try eq 'ARRAY') {
($C->{'_fate'}, $tag, $try) = @$try;	# next candidate fate
}

$C->deb("infixish_01 trying $tag $try") if $::DEBUG & DEBUG::try_processing;
push @gather, ((
sub { my $C=shift;
do {
if (my ($C) = ($C->_SUBSUMEr(['colonpair'], sub {
my $C = shift;
$C->colonpair
}))) {
scalar(do {
my $M = $C; 
$M->{'fake'} = 1;
$M->{'sym'} = ':';
$M->{'O'}{'prec'} = $item_assignment{'prec'};  # actual test is non-inclusive!
$M->{'O'}{'assoc'} = 'unary';
$M->{'O'}{'dba'} = 'adverb';
;
}, $C);
}
else {
();
}
}
},
sub { my $C=shift;
do {
if (my ($C) = ($C->_BRACKETr(sub {
my $C=shift;
do {
my @result = do {
my $trystate;
my ($tag, $try);
my @try;
my $relex;

my $fate;
my $x;
if ($fate = $C->{'_fate'} and $fate->[1] eq 'infixish_02') {
$C->deb("Fate passed to infixish_02: ", ::fatestr($fate)) if $::DEBUG & DEBUG::fates;
($C->{'_fate'}, $tag, $try) = @$fate;
@try = ($try);
$x = 'ALT infixish_02';    # some outer ltm is controlling us
}
else {
$x = 'ALTLTM infixish_02'; # we are top level ltm
}
my $C = $C->cursor_xact($x);
my $xact = $C->xact;

my @gather = ();
for (;;) {
if (not @try) {
$relex //= $C->cursor_fate('STD::P6', 'infixish_02', $retree);
@try = $relex->($C, $trystate);
}
last unless @try;
$try = shift(@try) // next;

if (ref $try eq 'ARRAY') {
($C->{'_fate'}, $tag, $try) = @$try;	# next candidate fate
}

$C->deb("infixish_02 trying $tag $try") if $::DEBUG & DEBUG::try_processing;
push @gather, ((
sub { my $C=shift;
do {
if (my ($C) = ($C->_EXACT('['))) {
do {
if (my ($C) = (((local $::GOAL = ']' ), $C)[-1])) {
do {
if (my ($C) = (  $C->_SUBSUMEr(['infix'], sub {
my $C = shift;
$C->infixish(1)
}))) {
do {
if (my ($C) = ($C->_BRACKETr(sub {
my $C=shift;
do {
my $C = $C->cursor_xact('ALT ||');
my $xact = $C->xact;
my @gather;
do {
push @gather, $C->_EXACT(']')
}
or $xact->[-2] or
do {
push @gather, $C->FAILGOAL(']' , 'bracketed infix')};
@gather;
}
}))) {
scalar(do {
my $M = $C;  $M->{'O'} = $M->{'infix'}{'O'}; $M->{'sym'} = $M->{'infix'}{'sym'}; ;
}, $C);
}
else {
();
}
};
}
else {
();
}
};
}
else {
();
}
};
}
else {
();
}
}
},
sub { my $C=shift;
do {
if (my ($C) = (  $C->_SUBSUMEr(['infix','infix_circumfix_meta_operator'], sub {
my $C = shift;
$C->infix_circumfix_meta_operator
}))) {
scalar(do {
my $M = $C;  $M->{'O'} = $M->{'infix'}{'O'}; $M->{'sym'} = $M->{'infix'}{'sym'}; ;
}, $C);
}
else {
();
}
}
},
sub { my $C=shift;
do {
if (my ($C) = (  $C->_SUBSUMEr(['infix','infix_prefix_meta_operator'], sub {
my $C = shift;
$C->infix_prefix_meta_operator
}))) {
scalar(do {
my $M = $C;  $M->{'O'} = $M->{'infix'}{'O'}; $M->{'sym'} = $M->{'infix'}{'sym'}; ;
}, $C);
}
else {
();
}
}
},
sub { my $C=shift;
do {
if (my ($C) = ($C->_SUBSUMEr(['infix'], sub {
my $C = shift;
$C->infix
}))) {
scalar(do {
my $M = $C;  $M->{'O'} = $M->{'infix'}{'O'}; $M->{'sym'} = $M->{'infix'}{'sym'}; ;
}, $C);
}
else {
();
}
}
},
sub { my $C=shift;
do {
if (my ($C) = (scalar(do {

}, $C))) {
do {
if (my ($C) = ($C->before( sub { my $C=shift;
$C->dotty
}))) {
$C->panic("Method call found where infix expected (omit whitespace?)");
}
else {
();
}
};
}
else {
();
}
}
},
sub { my $C=shift;
do {
if (my ($C) = (scalar(do {

}, $C))) {
do {
if (my ($C) = ($C->before( sub { my $C=shift;
$C->postfix
}))) {
$C->panic("Postfix found where infix expected (omit whitespace?)");
}
else {
();
}
};
}
else {
();
}
}
},
)[$try])->($C);
last if $xact->[-2];  # committed?
last if @gather;
}
@gather;
};
@result;
}

}))) {
$C->_OPTr(sub { my $C=shift;
$C->_BRACKETr(sub {
my $C=shift;
do {
if (my ($C) = ($C->before(sub { my $C=shift;
$C->_EXACT('=')
}))) {
do {
if (my ($C) = ($C->before( sub { my $C=shift;
(($C) x !!do {
my $M = $C;  $infix = $M->{'infix'}; ;
})
}))) {
do {
if (my ($C) = ($C->_SUBSUMEr(['infix_postfix_meta_operator'], sub {
my $C = shift;
$C->infix_postfix_meta_operator($infix)
}))) {
scalar(do {
my $M = $C;  $M->{'O'} = $M->{'infix_postfix_meta_operator'}[0]{'O'}; $M->{'sym'} = $M->{'infix_postfix_meta_operator'}[0]{'sym'}; ;
}, $C);
}
else {
();
}
};
}
else {
();
}
};
}
else {
();
}
}
})
});
}
else {
();
}
}
},
)[$try])->($C);
last if $xact->[-2];  # committed?
last if @gather;
}
@gather;
};
@result;
}

});
}
else {
();
}
};
}
else {
();
}
}
);
}

# NOTE: Do not add dotty ops beginning with anything other than dot!
#   Dotty ops have to parse as .foo terms as well, and almost anything
#   other than dot will conflict with some other prefix.

# doing fancy as one rule simplifies LTM
##     token dotty__S_255DotStar (:$*endsym = 'unspacey', :$*sym = <.*>)
##          token dotty:sym<.*> {
##              ('.' [ <[+*?=]> | '^' '!'? ]) :: <.unspacey> <dottyop>
##              { $<sym> = $0.Str; }
##              <O(%methodcall)>
##          }

sub dotty__S_255DotStar__PEEK { $_[0]->_AUTOLEXpeek('dotty__S_255DotStar',$retree) }
sub dotty__S_255DotStar {
no warnings 'recursion';
my $self = shift;
local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;
my %args = @_;
local $::endsym = $args{endsym} // 'unspacey';
local $::sym = $args{sym} // q(.*);


my $C = $self->cursor_xact("RULE dotty__S_255DotStar");
my $xact = $C->xact;
my $S = $C->{'_pos'};
$C->{'sym'} = ref $sym ? join(' ', @$sym) : $sym;

$self->_MATCHIFYr($S, "dotty__S_255DotStar", 
do {
if (my ($C) = (  $C->_SUBSUMEr(['0'], sub {
my $C = shift;
do { $C->_PAREN( sub { my $C=shift;
do {
if (my ($C) = ($C->_EXACT('.'))) {
$C->_BRACKETr(sub {
my $C=shift;
do {
my @result = do {
my $trystate;
my ($tag, $try);
my @try;
my $relex;

my $fate;
my $x;
if ($fate = $C->{'_fate'} and $fate->[1] eq 'dotty__S_255DotStar_02') {
$C->deb("Fate passed to dotty__S_255DotStar_02: ", ::fatestr($fate)) if $::DEBUG & DEBUG::fates;
($C->{'_fate'}, $tag, $try) = @$fate;
@try = ($try);
$x = 'ALT dotty__S_255DotStar_02';    # some outer ltm is controlling us
}
else {
$x = 'ALTLTM dotty__S_255DotStar_02'; # we are top level ltm
}
my $C = $C->cursor_xact($x);
my $xact = $C->xact;

my @gather = ();
for (;;) {
if (not @try) {
$relex //= $C->cursor_fate('STD::P6', 'dotty__S_255DotStar_02', $retree);
@try = $relex->($C, $trystate);
}
last unless @try;
$try = shift(@try) // next;

if (ref $try eq 'ARRAY') {
($C->{'_fate'}, $tag, $try) = @$try;	# next candidate fate
}

$C->deb("dotty__S_255DotStar_02 trying $tag $try") if $::DEBUG & DEBUG::try_processing;
push @gather, ((
sub { my $C=shift;
$C->_PATTERN(qr/\G[+*?=]/)
},
sub { my $C=shift;
do {
if (my ($C) = ($C->_EXACT('^'))) {
$C->_OPTr(sub { my $C=shift;
$C->_EXACT('!')
});
}
else {
();
}
}
},
)[$try])->($C);
last if $xact->[-2];  # committed?
last if @gather;
}
@gather;
};
@result;
}

});
}
else {
();
}
}
})}
}))) {
do {
if (my ($C) = ($C->_COMMITLTM())) {
do {
if (my ($C) = ($C->unspacey)) {
do {
if (my ($C) = ($C->_SUBSUMEr(['dottyop'], sub {
my $C = shift;
$C->dottyop
}))) {
do {
if (my ($C) = (scalar(do {
my $M = $C;  $M->{'sym'} = $C->{'0'}->Str; ;
}, $C))) {
$C->_SUBSUMEr(['O'], sub {
my $C = shift;
$C->O(%methodcall)
});
}
else {
();
}
};
}
else {
();
}
};
}
else {
();
}
};
}
else {
();
}
};
}
else {
();
}
}
);
}

##     token dotty__S_256Dot (:$*endsym = 'unspacey', :$*sym = <.>)
##          token dotty:sym<.> {
##              <sym> <dottyop>
##              <O(%methodcall)>
##          }

sub dotty__S_256Dot__PEEK { $_[0]->_AUTOLEXpeek('dotty__S_256Dot',$retree) }
sub dotty__S_256Dot {
no warnings 'recursion';
my $self = shift;
local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;
my %args = @_;
local $::endsym = $args{endsym} // 'unspacey';
local $::sym = $args{sym} // q(.);


my $C = $self->cursor_xact("RULE dotty__S_256Dot");
my $xact = $C->xact;
my $S = $C->{'_pos'};
$C->{'sym'} = ref $sym ? join(' ', @$sym) : $sym;

$self->_MATCHIFYr($S, "dotty__S_256Dot", 
do {
if (my ($C) = ($C->_PATTERN(qr/\G\./))) {
do {
if (my ($C) = ($C->unspacey)) {
do {
if (my ($C) = ($C->_SUBSUMEr(['dottyop'], sub {
my $C = shift;
$C->dottyop
}))) {
$C->_SUBSUMEr(['O'], sub {
my $C = shift;
$C->O(%methodcall)
});
}
else {
();
}
};
}
else {
();
}
};
}
else {
();
}
}
);
}

##     token privop
##          token privop {
##              '!' <methodop>
##              <O(%methodcall)>
##          }

sub privop__PEEK { $_[0]->_AUTOLEXpeek('privop',$retree) }
sub privop {
no warnings 'recursion';
my $self = shift;
local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;


my $C = $self->cursor_xact("RULE privop");
my $xact = $C->xact;
my $S = $C->{'_pos'};

$self->_MATCHIFYr($S, "privop", 
do {
if (my ($C) = ($C->_EXACT('!'))) {
do {
if (my ($C) = ($C->_SUBSUMEr(['methodop'], sub {
my $C = shift;
$C->methodop
}))) {
$C->_SUBSUMEr(['O'], sub {
my $C = shift;
$C->O(%methodcall)
});
}
else {
();
}
};
}
else {
();
}
}
);
}

##     token dottyopish
##          token dottyopish {
##              <term=.dottyop>
##          }

sub dottyopish__PEEK { $_[0]->_AUTOLEXpeek('dottyopish',$retree) }
sub dottyopish {
no warnings 'recursion';
my $self = shift;
local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;


my $C = $self->cursor_xact("RULE dottyopish");
my $xact = $C->xact;
my $S = $C->{'_pos'};

$self->_MATCHIFYr($S, "dottyopish", 
$C->_SUBSUMEr(['term'], sub {
my $C = shift;
$C->dottyop
})
);
}

##     token dottyop
##          token dottyop {
##              :dba('dotty method or postfix')
##              [
##              | <methodop>
##              | <colonpair>
##              | <!alpha> <postop> { $<O> = $<postop><O>; $<sym> = $<postop><sym>; }  # only non-alpha postfixes have dotty form
##              ]
##          }

sub dottyop__PEEK { $_[0]->_AUTOLEXpeek('dottyop',$retree) }
sub dottyop {
no warnings 'recursion';
my $self = shift;
local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;


my $C = $self->cursor_xact("RULE dottyop");
my $xact = $C->xact;
my $S = $C->{'_pos'};

$self->_MATCHIFYr($S, "dottyop", 
$C->_BRACKETr(sub {
my $C=shift;
do {
my @result = do {
my $trystate;
my ($tag, $try);
my @try;
my $relex;

my $fate;
my $x;
if ($fate = $C->{'_fate'} and $fate->[1] eq 'dottyop_01') {
$C->deb("Fate passed to dottyop_01: ", ::fatestr($fate)) if $::DEBUG & DEBUG::fates;
($C->{'_fate'}, $tag, $try) = @$fate;
@try = ($try);
$x = 'ALT dottyop_01';    # some outer ltm is controlling us
}
else {
$x = 'ALTLTM dottyop_01'; # we are top level ltm
}
my $C = $C->cursor_xact($x);
my $xact = $C->xact;

my @gather = ();
for (;;) {
if (not @try) {
$relex //= $C->cursor_fate('STD::P6', 'dottyop_01', $retree);
@try = $relex->($C, $trystate);
}
last unless @try;
$try = shift(@try) // next;

if (ref $try eq 'ARRAY') {
($C->{'_fate'}, $tag, $try) = @$try;	# next candidate fate
}

$C->deb("dottyop_01 trying $tag $try") if $::DEBUG & DEBUG::try_processing;
push @gather, ((
sub { my $C=shift;
$C->_SUBSUMEr(['methodop'], sub {
my $C = shift;
$C->methodop
})
},
sub { my $C=shift;
$C->_SUBSUMEr(['colonpair'], sub {
my $C = shift;
$C->colonpair
})
},
sub { my $C=shift;
do {
if (my ($C) = ($C->_NOTBEFORE( sub { my $C=shift;
$C->_PATTERN(qr/\G[_[:alpha:]]/)
}))) {
do {
if (my ($C) = ($C->_SUBSUMEr(['postop'], sub {
my $C = shift;
$C->postop
}))) {
scalar(do {
my $M = $C;  $M->{'O'} = $M->{'postop'}{'O'}; $M->{'sym'} = $M->{'postop'}{'sym'}; ;
}, $C);
}
else {
();
}
};
}
else {
();
}
}
},
)[$try])->($C);
last if $xact->[-2];  # committed?
last if @gather;
}
@gather;
};
@result;
}

})
);
}

# Note, this rule mustn't do anything irreversible because it's used
# as a lookahead by the quote interpolator.

##     token POST
##          token POST {
##              <!stdstopper>
##      
##              # last whitespace didn't end here
##              <!{ @*MEMOS[$.pos]<ws> }>
##      
##              [ <.unsp> | '\\' ]?
##      
##              [ ['.' <.unsp>?]? <postfix_prefix_meta_operator> <.unsp>? ]*
##      
##              :dba('postfix')
##              [
##              | <dotty>  { $<O> = $<dotty><O>;  $<sym> = $<dotty><sym>;  $<~CAPS> = $<dotty><~CAPS>; }
##              | <privop> { $<O> = $<privop><O>; $<sym> = $<privop><sym>; $<~CAPS> = $<privop><~CAPS>; }
##              | <postop> { $<O> = $<postop><O>; $<sym> = $<postop><sym>; $<~CAPS> = $<postop><~CAPS>; }
##              ]
##              { $*LEFTSIGIL = '@'; }
##          }

sub POST__PEEK { $_[0]->_AUTOLEXpeek('POST',$retree) }
sub POST {
no warnings 'recursion';
my $self = shift;
local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;


my $C = $self->cursor_xact("RULE POST");
my $xact = $C->xact;
my $S = $C->{'_pos'};
$C->{'postfix_prefix_meta_operator'} = [];

$self->_MATCHIFYr($S, "POST", 
do {
if (my ($C) = ($C->_NOTBEFORE( sub { my $C=shift;
$C->stdstopper
}))) {
do {
if (my ($C) = ($C->_NOTBEFORE( sub { my $C=shift;
(($C) x !!do {
$::MEMOS[$C->{'_pos'}]{'ws'} 
})
}))) {
do {
if (my ($C) = ($C->_OPTr(sub { my $C=shift;
$C->_BRACKETr(sub {
my $C=shift;
do {
my @result = do {
my $trystate;
my ($tag, $try);
my @try;
my $relex;

my $fate;
my $x;
if ($fate = $C->{'_fate'} and $fate->[1] eq 'POST_01') {
$C->deb("Fate passed to POST_01: ", ::fatestr($fate)) if $::DEBUG & DEBUG::fates;
($C->{'_fate'}, $tag, $try) = @$fate;
@try = ($try);
$x = 'ALT POST_01';    # some outer ltm is controlling us
}
else {
$x = 'ALTLTM POST_01'; # we are top level ltm
}
my $C = $C->cursor_xact($x);
my $xact = $C->xact;

my @gather = ();
for (;;) {
if (not @try) {
$relex //= $C->cursor_fate('STD::P6', 'POST_01', $retree);
@try = $relex->($C, $trystate);
}
last unless @try;
$try = shift(@try) // next;

if (ref $try eq 'ARRAY') {
($C->{'_fate'}, $tag, $try) = @$try;	# next candidate fate
}

$C->deb("POST_01 trying $tag $try") if $::DEBUG & DEBUG::try_processing;
push @gather, ((
sub { my $C=shift;
$C->unsp
},
sub { my $C=shift;
$C->_EXACT('\\')
},
)[$try])->($C);
last if $xact->[-2];  # committed?
last if @gather;
}
@gather;
};
@result;
}

})
}))) {
do {
if (my ($C) = ($C->_STARr(sub { my $C=shift;
$C->_BRACKETr(sub {
my $C=shift;
do {
if (my ($C) = ($C->_OPTr(sub { my $C=shift;
$C->_BRACKETr(sub {
my $C=shift;
do {
if (my ($C) = ($C->_EXACT('.'))) {
$C->_OPTr(sub { my $C=shift;
$C->unsp
});
}
else {
();
}
}
})
}))) {
do {
if (my ($C) = ($C->_SUBSUMEr(['postfix_prefix_meta_operator'], sub {
my $C = shift;
$C->postfix_prefix_meta_operator
}))) {
$C->_OPTr(sub { my $C=shift;
$C->unsp
});
}
else {
();
}
};
}
else {
();
}
}
})
}))) {
do {
if (my ($C) = ($C->_BRACKETr(sub {
my $C=shift;
do {
my @result = do {
my $trystate;
my ($tag, $try);
my @try;
my $relex;

my $fate;
my $x;
if ($fate = $C->{'_fate'} and $fate->[1] eq 'POST_04') {
$C->deb("Fate passed to POST_04: ", ::fatestr($fate)) if $::DEBUG & DEBUG::fates;
($C->{'_fate'}, $tag, $try) = @$fate;
@try = ($try);
$x = 'ALT POST_04';    # some outer ltm is controlling us
}
else {
$x = 'ALTLTM POST_04'; # we are top level ltm
}
my $C = $C->cursor_xact($x);
my $xact = $C->xact;

my @gather = ();
for (;;) {
if (not @try) {
$relex //= $C->cursor_fate('STD::P6', 'POST_04', $retree);
@try = $relex->($C, $trystate);
}
last unless @try;
$try = shift(@try) // next;

if (ref $try eq 'ARRAY') {
($C->{'_fate'}, $tag, $try) = @$try;	# next candidate fate
}

$C->deb("POST_04 trying $tag $try") if $::DEBUG & DEBUG::try_processing;
push @gather, ((
sub { my $C=shift;
do {
if (my ($C) = ($C->_SUBSUMEr(['dotty'], sub {
my $C = shift;
$C->dotty
}))) {
scalar(do {
my $M = $C;  $M->{'O'} = $M->{'dotty'}{'O'};  $M->{'sym'} = $M->{'dotty'}{'sym'};  $M->{'~CAPS'} = $M->{'dotty'}{'~CAPS'}; ;
}, $C);
}
else {
();
}
}
},
sub { my $C=shift;
do {
if (my ($C) = ($C->_SUBSUMEr(['privop'], sub {
my $C = shift;
$C->privop
}))) {
scalar(do {
my $M = $C;  $M->{'O'} = $M->{'privop'}{'O'}; $M->{'sym'} = $M->{'privop'}{'sym'}; $M->{'~CAPS'} = $M->{'privop'}{'~CAPS'}; ;
}, $C);
}
else {
();
}
}
},
sub { my $C=shift;
do {
if (my ($C) = ($C->_SUBSUMEr(['postop'], sub {
my $C = shift;
$C->postop
}))) {
scalar(do {
my $M = $C;  $M->{'O'} = $M->{'postop'}{'O'}; $M->{'sym'} = $M->{'postop'}{'sym'}; $M->{'~CAPS'} = $M->{'postop'}{'~CAPS'}; ;
}, $C);
}
else {
();
}
}
},
)[$try])->($C);
last if $xact->[-2];  # committed?
last if @gather;
}
@gather;
};
@result;
}

}))) {
scalar(do {
$::LEFTSIGIL = '@'; 
}, $C);
}
else {
();
}
};
}
else {
();
}
};
}
else {
();
}
};
}
else {
();
}
};
}
else {
();
}
}
);
}

##     method can_meta ($op, $meta)
sub can_meta {
my $self = shift;
my $op = shift;
my $meta = shift;


!$op->{'O'}{'fiddly'} ||
$self->panic("Can't " . $meta . " " . $op->{'sym'} . " because " . $op->{'O'}{'dba'} . " operators are too fiddly");
$self;
}

##     regex prefix_circumfix_meta_operator__S_257reduce (:$*sym = 'reduce')
##          regex prefix_circumfix_meta_operator:reduce {
##              :my $*IN_REDUCE = 1;
##              :my $op;
##              <?before '['\S+']'>
##              $<s> = (
##                  '['
##                  [
##                  || <op=.infixish(1)> <?before ']'>
##                  || \\<op=.infixish(1)> <?before ']'>
##                  || <!>
##                  ]
##                  ']' [''|<?>]
##              )
##              { $op = $<s><op>; }
##      
##              <.can_meta($op, "reduce with")>
##      
##              [
##              || <!{ $op<O><diffy> }>
##              || <?{ $op<O><assoc> eq 'chain' }>
##              || <.panic("Can't reduce with " ~ $op<sym> ~ " because " ~ $op<O><dba> ~ " operators are diffy and not chaining")>
##              ]
##      
##              <O($op.Opairs, |%list_prefix, assoc => 'unary', uassoc => 'left')>
##              { $<sym> = $<s>.Str; }
##      
##              [ <?before '('> || <?before \s+ [ <?stdstopper> { $<O><term> = 1 } ]? > || { $<O><term> = 1 } ]
##          }

sub prefix_circumfix_meta_operator__S_257reduce__PEEK { $_[0]->_AUTOLEXpeek('prefix_circumfix_meta_operator__S_257reduce',$retree) }
sub prefix_circumfix_meta_operator__S_257reduce {
no warnings 'recursion';
my $self = shift;
local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;
my %args = @_;
local $::sym = $args{sym} // 'reduce';
local $::IN_REDUCE = 1;
my $op;


my $C = $self->cursor_xact("RULE prefix_circumfix_meta_operator__S_257reduce");
my $xact = $C->xact;
my $S = $C->{'_pos'};
$C->{'sym'} = ref $sym ? join(' ', @$sym) : $sym;

$self->_MATCHIFY($S, "prefix_circumfix_meta_operator__S_257reduce", 
Cursor::lazymap(sub {
my $C=$_[0];
Cursor::lazymap(sub {
my $C=$_[0];
Cursor::lazymap(sub {
my $C=$_[0];
Cursor::lazymap(sub {
my $C=$_[0];
Cursor::lazymap(sub {
my $C=$_[0];
Cursor::lazymap(sub {
my $C=$_[0];
Cursor::lazymap(sub {
my $C=$_[0];
$C->_BRACKET(sub {
my $C=shift;
do {
my $C = $C->cursor_xact('ALT ||');
my $xact = $C->xact;
my @gather;
do {
push @gather, $C->before(sub { my $C=shift;
$C->_EXACT('(')
})
}
or $xact->[-2] or
do {
push @gather, $C->before(sub { my $C=shift;
Cursor::lazymap(sub {
my $C=$_[0];
$C->_OPTg(sub { my $C=shift;
$C->_BRACKET(sub {
my $C=shift;
Cursor::lazymap(sub {
my $C=$_[0];
scalar(do {
my $M = $C;  $M->{'O'}{'term'} = 1 ;
}, $C)
}, $C->before( sub { my $C=shift;
$C->stdstopper
}))
})
})
}, $C->_PATTERN(qr/\G((?:\s)+)/))
})
}
or $xact->[-2] or
do {
push @gather, scalar(do {
my $M = $C;  $M->{'O'}{'term'} = 1 ;
}, $C)};
@gather;
}
})
}, scalar(do {
my $M = $C;  $M->{'sym'} = $M->{'s'}->Str; ;
}, $C))
}, $C->_SUBSUME(['O'], sub {
my $C = shift;
$C->O($op->Opairs, %list_prefix, assoc => 'unary', uassoc => 'left')
}))
}, $C->_BRACKET(sub {
my $C=shift;
do {
my $C = $C->cursor_xact('ALT ||');
my $xact = $C->xact;
my @gather;
do {
push @gather, $C->_NOTBEFORE( sub { my $C=shift;
(($C) x !!do {
$op->{'O'}{'diffy'} 
})
})
}
or $xact->[-2] or
do {
push @gather, $C->before( sub { my $C=shift;
(($C) x !!do {
$op->{'O'}{'assoc'} eq 'chain' 
})
})
}
or $xact->[-2] or
do {
push @gather, $C->panic("Can't reduce with " . $op->{'sym'} . " because " . $op->{'O'}{'dba'} . " operators are diffy and not chaining")};
@gather;
}
}))
}, $C->can_meta($op, "reduce with"))
}, scalar(do {
my $M = $C;  $op = $M->{'s'}{'op'}; ;
}, $C))
},   $C->_SUBSUME(['s'], sub {
my $C = shift;
do { $C->_PAREN( sub { my $C=shift;
Cursor::lazymap(sub {
my $C=$_[0];
Cursor::lazymap(sub {
my $C=$_[0];
Cursor::lazymap(sub {
my $C=$_[0];
$C->_BRACKET(sub {
my $C=shift;
do {
my @result = do {
my $trystate;
my ($tag, $try);
my @try;
my $relex;

my $fate;
my $x;
if ($fate = $C->{'_fate'} and $fate->[1] eq 'prefix_circumfix_meta_operator__S_257reduce_08') {
$C->deb("Fate passed to prefix_circumfix_meta_operator__S_257reduce_08: ", ::fatestr($fate)) if $::DEBUG & DEBUG::fates;
($C->{'_fate'}, $tag, $try) = @$fate;
@try = ($try);
$x = 'ALT prefix_circumfix_meta_operator__S_257reduce_08';    # some outer ltm is controlling us
}
else {
$x = 'ALTLTM prefix_circumfix_meta_operator__S_257reduce_08'; # we are top level ltm
}
my $C = $C->cursor_xact($x);
my $xact = $C->xact;

my @gather = ();
for (;;) {
if (not @try) {
$relex //= $C->cursor_fate('STD::P6', 'prefix_circumfix_meta_operator__S_257reduce_08', $retree);
@try = $relex->($C, $trystate);
}
last unless @try;
$try = shift(@try) // next;

if (ref $try eq 'ARRAY') {
($C->{'_fate'}, $tag, $try) = @$try;	# next candidate fate
}

$C->deb("prefix_circumfix_meta_operator__S_257reduce_08 trying $tag $try") if $::DEBUG & DEBUG::try_processing;
push @gather, ((
sub { my $C=shift;
$C->_EXACT('')
},
sub { my $C=shift;
$C->before( sub { my $C=shift;
$C
})
},
)[$try])->($C);
last if $xact->[-2];  # committed?
last if @gather;
}
@gather;
};
@result;
}

})
}, $C->_EXACT(']'))
}, $C->_BRACKET(sub {
my $C=shift;
do {
my $C = $C->cursor_xact('ALT ||');
my $xact = $C->xact;
my @gather;
do {
push @gather, Cursor::lazymap(sub {
my $C=$_[0];
$C->before(sub { my $C=shift;
$C->_EXACT(']')
})
},   $C->_SUBSUME(['op'], sub {
my $C = shift;
$C->infixish(1)
}))
}
or $xact->[-2] or
do {
push @gather, Cursor::lazymap(sub {
my $C=$_[0];
Cursor::lazymap(sub {
my $C=$_[0];
$C->before(sub { my $C=shift;
$C->_EXACT(']')
})
},   $C->_SUBSUME(['op'], sub {
my $C = shift;
$C->infixish(1)
}))
}, $C->_EXACT('\\'))
}
or $xact->[-2] or
do {
push @gather, $C->_NOTBEFORE( sub { my $C=shift;
$C
})};
@gather;
}
}))
}, $C->_EXACT('['))
})}
}))
}, $C->before(sub { my $C=shift;
Cursor::lazymap(sub {
my $C=$_[0];
Cursor::lazymap(sub {
my $C=$_[0];
$C->_EXACT(']')
}, $C->_PLUSg(sub { my $C=shift;
$C->_NOTCHAR( sub { my $C=shift;
$C->_PATTERN(qr/\G\s/)
})
}))
}, $C->_EXACT('['))
}))
);
}

##     token prefix_postfix_meta_operator__S_258Fre (:$*sym = <  >)
##          token prefix_postfix_meta_operator:sym<  >    { <sym> | '<<' }

sub prefix_postfix_meta_operator__S_258Fre__PEEK { $_[0]->_AUTOLEXpeek('prefix_postfix_meta_operator__S_258Fre',$retree) }
sub prefix_postfix_meta_operator__S_258Fre {
no warnings 'recursion';
my $self = shift;
local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;
my %args = @_;
local $::sym = $args{sym} // [qw(  )];


my $C = $self->cursor_xact("RULE prefix_postfix_meta_operator__S_258Fre");
my $xact = $C->xact;
my $S = $C->{'_pos'};
$C->{'sym'} = ref $sym ? join(' ', @$sym) : $sym;

$self->_MATCHIFYr($S, "prefix_postfix_meta_operator__S_258Fre", 
do {
my @result = do {
my $trystate;
my ($tag, $try);
my @try;
my $relex;

my $fate;
my $x;
if ($fate = $C->{'_fate'} and $fate->[1] eq 'prefix_postfix_meta_operator__S_258Fre_00') {
$C->deb("Fate passed to prefix_postfix_meta_operator__S_258Fre_00: ", ::fatestr($fate)) if $::DEBUG & DEBUG::fates;
($C->{'_fate'}, $tag, $try) = @$fate;
@try = ($try);
$x = 'ALT prefix_postfix_meta_operator__S_258Fre_00';    # some outer ltm is controlling us
}
else {
$x = 'ALTLTM prefix_postfix_meta_operator__S_258Fre_00'; # we are top level ltm
}
my $C = $C->cursor_xact($x);
my $xact = $C->xact;

my @gather = ();
for (;;) {
if (not @try) {
$relex //= $C->cursor_fate('STD::P6', 'prefix_postfix_meta_operator__S_258Fre_00', $retree);
@try = $relex->($C, $trystate);
}
last unless @try;
$try = shift(@try) // next;

if (ref $try eq 'ARRAY') {
($C->{'_fate'}, $tag, $try) = @$try;	# next candidate fate
}

$C->deb("prefix_postfix_meta_operator__S_258Fre_00 trying $tag $try") if $::DEBUG & DEBUG::try_processing;
push @gather, ((
sub { my $C=shift;
$C->_PATTERN(qr/\G/)
},
sub { my $C=shift;
$C->_EXACT('<<')
},
)[$try])->($C);
last if $xact->[-2];  # committed?
last if @gather;
}
@gather;
};
@result;
}

);
}

##     token postfix_prefix_meta_operator__S_259Nch (:$*sym = <  >)
##          token postfix_prefix_meta_operator:sym<  >    {
##              [ <sym> | '>>' ]
##              # require >>.( on interpolated hypercall so infix:$s($a,$b) {...} dwims
##              [<!{ $*QSIGIL }> || <!before '('> ]
##          }

sub postfix_prefix_meta_operator__S_259Nch__PEEK { $_[0]->_AUTOLEXpeek('postfix_prefix_meta_operator__S_259Nch',$retree) }
sub postfix_prefix_meta_operator__S_259Nch {
no warnings 'recursion';
my $self = shift;
local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;
my %args = @_;
local $::sym = $args{sym} // [qw(  )];


my $C = $self->cursor_xact("RULE postfix_prefix_meta_operator__S_259Nch");
my $xact = $C->xact;
my $S = $C->{'_pos'};
$C->{'sym'} = ref $sym ? join(' ', @$sym) : $sym;

$self->_MATCHIFYr($S, "postfix_prefix_meta_operator__S_259Nch", 
do {
if (my ($C) = ($C->_BRACKETr(sub {
my $C=shift;
do {
my @result = do {
my $trystate;
my ($tag, $try);
my @try;
my $relex;

my $fate;
my $x;
if ($fate = $C->{'_fate'} and $fate->[1] eq 'postfix_prefix_meta_operator__S_259Nch_01') {
$C->deb("Fate passed to postfix_prefix_meta_operator__S_259Nch_01: ", ::fatestr($fate)) if $::DEBUG & DEBUG::fates;
($C->{'_fate'}, $tag, $try) = @$fate;
@try = ($try);
$x = 'ALT postfix_prefix_meta_operator__S_259Nch_01';    # some outer ltm is controlling us
}
else {
$x = 'ALTLTM postfix_prefix_meta_operator__S_259Nch_01'; # we are top level ltm
}
my $C = $C->cursor_xact($x);
my $xact = $C->xact;

my @gather = ();
for (;;) {
if (not @try) {
$relex //= $C->cursor_fate('STD::P6', 'postfix_prefix_meta_operator__S_259Nch_01', $retree);
@try = $relex->($C, $trystate);
}
last unless @try;
$try = shift(@try) // next;

if (ref $try eq 'ARRAY') {
($C->{'_fate'}, $tag, $try) = @$try;	# next candidate fate
}

$C->deb("postfix_prefix_meta_operator__S_259Nch_01 trying $tag $try") if $::DEBUG & DEBUG::try_processing;
push @gather, ((
sub { my $C=shift;
$C->_PATTERN(qr/\G/)
},
sub { my $C=shift;
$C->_EXACT('>>')
},
)[$try])->($C);
last if $xact->[-2];  # committed?
last if @gather;
}
@gather;
};
@result;
}

}))) {
$C->_BRACKETr(sub {
my $C=shift;
do {
my $C = $C->cursor_xact('ALT ||');
my $xact = $C->xact;
my @gather;
do {
push @gather, $C->_NOTBEFORE( sub { my $C=shift;
(($C) x !!do {
$::QSIGIL 
})
})
}
or $xact->[-2] or
do {
push @gather, $C->_NOTBEFORE( sub { my $C=shift;
$C->before(sub { my $C=shift;
$C->_EXACT('(')
})
})};
@gather;
}
});
}
else {
();
}
}
);
}

##     token infix_prefix_meta_operator__S_260Bang (:$*sym = <!>)
##          token infix_prefix_meta_operator:sym<!> {
##              <sym> <!before '!'> {} [ <infixish(1)> || <.panic: "Negation metaoperator not followed by valid infix"> ]
##      
##              [
##              || <?{ $<infixish>.Str eq '=' }>
##                 <O(|%chaining)>
##                 
##              || <.can_meta($<infixish>, "negate")>    
##                 <?{ $<infixish><O><iffy> }>
##                 <?{ $<O> = $<infixish><O>; }>
##                  
##              || <.panic("Can't negate " ~ $<infixish>.Str ~ " because " ~ $<infixish><O><dba> ~ " operators are not iffy enough")>
##              ]
##          }

sub infix_prefix_meta_operator__S_260Bang__PEEK { $_[0]->_AUTOLEXpeek('infix_prefix_meta_operator__S_260Bang',$retree) }
sub infix_prefix_meta_operator__S_260Bang {
no warnings 'recursion';
my $self = shift;
local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;
my %args = @_;
local $::sym = $args{sym} // q(!);


my $C = $self->cursor_xact("RULE infix_prefix_meta_operator__S_260Bang");
my $xact = $C->xact;
my $S = $C->{'_pos'};
$C->{'sym'} = ref $sym ? join(' ', @$sym) : $sym;

$self->_MATCHIFYr($S, "infix_prefix_meta_operator__S_260Bang", 
do {
if (my ($C) = ($C->_PATTERN(qr/\G\!/))) {
do {
if (my ($C) = ($C->_NOTBEFORE( sub { my $C=shift;
$C->before(sub { my $C=shift;
$C->_EXACT('!')
})
}))) {
do {
if (my ($C) = (scalar(do {

}, $C))) {
do {
if (my ($C) = ($C->_BRACKETr(sub {
my $C=shift;
do {
my $C = $C->cursor_xact('ALT ||');
my $xact = $C->xact;
my @gather;
do {
push @gather, $C->_SUBSUMEr(['infixish'], sub {
my $C = shift;
$C->infixish(1)
})
}
or $xact->[-2] or
do {
push @gather, $C->panic("Negation metaoperator not followed by valid infix")};
@gather;
}
}))) {
$C->_BRACKETr(sub {
my $C=shift;
do {
my $C = $C->cursor_xact('ALT ||');
my $xact = $C->xact;
my @gather;
do {
push @gather, do {
if (my ($C) = ($C->before( sub { my $C=shift;
(($C) x !!do {
my $M = $C;  $M->{'infixish'}->Str eq '=' ;
})
}))) {
$C->_SUBSUMEr(['O'], sub {
my $C = shift;
$C->O(%chaining)
});
}
else {
();
}
}
}
or $xact->[-2] or
do {
push @gather, do {
if (my ($C) = (do { my $M = $C;
$C->can_meta($M->{'infixish'}, "negate")
; })) {
do {
if (my ($C) = ($C->before( sub { my $C=shift;
(($C) x !!do {
my $M = $C;  $M->{'infixish'}{'O'}{'iffy'} ;
})
}))) {
$C->before( sub { my $C=shift;
(($C) x !!do {
my $M = $C;  $M->{'O'} = $M->{'infixish'}{'O'}; ;
})
});
}
else {
();
}
};
}
else {
();
}
}
}
or $xact->[-2] or
do {
push @gather, do { my $M = $C;
$C->panic("Can't negate " . $M->{'infixish'}->Str . " because " . $M->{'infixish'}{'O'}{'dba'} . " operators are not iffy enough")
; }};
@gather;
}
});
}
else {
();
}
};
}
else {
();
}
};
}
else {
();
}
};
}
else {
();
}
}
);
}

##     token infix_prefix_meta_operator__S_261R (:$*sym = <R>)
##          token infix_prefix_meta_operator:sym<R> {
##              <sym> {} <infixish(1)>
##              <.can_meta($<infixish>, "reverse the args of")>
##              <?{ $<O> = $<infixish><O>; }>
##          }

sub infix_prefix_meta_operator__S_261R__PEEK { $_[0]->_AUTOLEXpeek('infix_prefix_meta_operator__S_261R',$retree) }
sub infix_prefix_meta_operator__S_261R {
no warnings 'recursion';
my $self = shift;
local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;
my %args = @_;
local $::sym = $args{sym} // q(R);


my $C = $self->cursor_xact("RULE infix_prefix_meta_operator__S_261R");
my $xact = $C->xact;
my $S = $C->{'_pos'};
$C->{'sym'} = ref $sym ? join(' ', @$sym) : $sym;

$self->_MATCHIFYr($S, "infix_prefix_meta_operator__S_261R", 
do {
if (my ($C) = ($C->_PATTERN(qr/\GR/))) {
do {
if (my ($C) = (scalar(do {

}, $C))) {
do {
if (my ($C) = ($C->_SUBSUMEr(['infixish'], sub {
my $C = shift;
$C->infixish(1)
}))) {
do {
if (my ($C) = (do { my $M = $C;
$C->can_meta($M->{'infixish'}, "reverse the args of")
; })) {
$C->before( sub { my $C=shift;
(($C) x !!do {
my $M = $C;  $M->{'O'} = $M->{'infixish'}{'O'}; ;
})
});
}
else {
();
}
};
}
else {
();
}
};
}
else {
();
}
};
}
else {
();
}
}
);
}

##     token infix_prefix_meta_operator__S_262S (:$*sym = <S>)
##          token infix_prefix_meta_operator:sym<S> {
##              <sym> {} <infixish(1)>
##              <.can_meta($<infixish>, "sequence the args of")>
##              <?{ $<O> = $<infixish><O>; }>
##          }

sub infix_prefix_meta_operator__S_262S__PEEK { $_[0]->_AUTOLEXpeek('infix_prefix_meta_operator__S_262S',$retree) }
sub infix_prefix_meta_operator__S_262S {
no warnings 'recursion';
my $self = shift;
local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;
my %args = @_;
local $::sym = $args{sym} // q(S);


my $C = $self->cursor_xact("RULE infix_prefix_meta_operator__S_262S");
my $xact = $C->xact;
my $S = $C->{'_pos'};
$C->{'sym'} = ref $sym ? join(' ', @$sym) : $sym;

$self->_MATCHIFYr($S, "infix_prefix_meta_operator__S_262S", 
do {
if (my ($C) = ($C->_PATTERN(qr/\GS/))) {
do {
if (my ($C) = (scalar(do {

}, $C))) {
do {
if (my ($C) = ($C->_SUBSUMEr(['infixish'], sub {
my $C = shift;
$C->infixish(1)
}))) {
do {
if (my ($C) = (do { my $M = $C;
$C->can_meta($M->{'infixish'}, "sequence the args of")
; })) {
$C->before( sub { my $C=shift;
(($C) x !!do {
my $M = $C;  $M->{'O'} = $M->{'infixish'}{'O'}; ;
})
});
}
else {
();
}
};
}
else {
();
}
};
}
else {
();
}
};
}
else {
();
}
}
);
}

##     token infix_prefix_meta_operator__S_263X (:$*sym = <X>)
##          token infix_prefix_meta_operator:sym<X> {
##              <sym> <?before \S> {}
##              [ <infixish(1)>
##                  <.can_meta($<infixish>[0], "cross with")>
##                  <?{ $<O> = $<infixish>[0]<O>; $<O><prec>:delete; $<sym> ~= $<infixish>[0].Str }>
##              ]?
##              <O(|%list_infix, self.Opairs)>
##          }

sub infix_prefix_meta_operator__S_263X__PEEK { $_[0]->_AUTOLEXpeek('infix_prefix_meta_operator__S_263X',$retree) }
sub infix_prefix_meta_operator__S_263X {
no warnings 'recursion';
my $self = shift;
local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;
my %args = @_;
local $::sym = $args{sym} // q(X);


my $C = $self->cursor_xact("RULE infix_prefix_meta_operator__S_263X");
my $xact = $C->xact;
my $S = $C->{'_pos'};
$C->{'infixish'} = [];
$C->{'sym'} = ref $sym ? join(' ', @$sym) : $sym;

$self->_MATCHIFYr($S, "infix_prefix_meta_operator__S_263X", 
do {
if (my ($C) = ($C->_PATTERN(qr/\GX/))) {
do {
if (my ($C) = ($C->before(sub { my $C=shift;
$C->_NOTCHAR( sub { my $C=shift;
$C->_PATTERN(qr/\G\s/)
})
}))) {
do {
if (my ($C) = (scalar(do {

}, $C))) {
do {
if (my ($C) = ($C->_OPTr(sub { my $C=shift;
$C->_BRACKETr(sub {
my $C=shift;
do {
if (my ($C) = ($C->_SUBSUMEr(['infixish'], sub {
my $C = shift;
$C->infixish(1)
}))) {
do {
if (my ($C) = (do { my $M = $C;
$C->can_meta($M->{'infixish'}[0], "cross with")
; })) {
$C->before( sub { my $C=shift;
(($C) x !!do {
my $M = $C;  $M->{'O'} = $M->{'infixish'}[0]{'O'}; delete $M->{'O'}{'prec'}; $M->{'sym'} .= $M->{'infixish'}[0]->Str ;
})
});
}
else {
();
}
};
}
else {
();
}
}
})
}))) {
$C->_SUBSUMEr(['O'], sub {
my $C = shift;
$C->O(%list_infix, $self->Opairs)
});
}
else {
();
}
};
}
else {
();
}
};
}
else {
();
}
};
}
else {
();
}
}
);
}

##     token infix_prefix_meta_operator__S_264Z (:$*sym = <Z>)
##          token infix_prefix_meta_operator:sym<Z> {
##              <sym> <?before \S> {}
##              [ <infixish(1)>
##                  <.can_meta($<infixish>[0], "zip with")>
##                  <?{ $<O> = $<infixish>[0]<O>; $<O><prec>:delete; $<sym> ~= $<infixish>[0].Str }>
##              ]?
##              <O(|%list_infix, self.Opairs)>
##          }

sub infix_prefix_meta_operator__S_264Z__PEEK { $_[0]->_AUTOLEXpeek('infix_prefix_meta_operator__S_264Z',$retree) }
sub infix_prefix_meta_operator__S_264Z {
no warnings 'recursion';
my $self = shift;
local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;
my %args = @_;
local $::sym = $args{sym} // q(Z);


my $C = $self->cursor_xact("RULE infix_prefix_meta_operator__S_264Z");
my $xact = $C->xact;
my $S = $C->{'_pos'};
$C->{'infixish'} = [];
$C->{'sym'} = ref $sym ? join(' ', @$sym) : $sym;

$self->_MATCHIFYr($S, "infix_prefix_meta_operator__S_264Z", 
do {
if (my ($C) = ($C->_PATTERN(qr/\GZ/))) {
do {
if (my ($C) = ($C->before(sub { my $C=shift;
$C->_NOTCHAR( sub { my $C=shift;
$C->_PATTERN(qr/\G\s/)
})
}))) {
do {
if (my ($C) = (scalar(do {

}, $C))) {
do {
if (my ($C) = ($C->_OPTr(sub { my $C=shift;
$C->_BRACKETr(sub {
my $C=shift;
do {
if (my ($C) = ($C->_SUBSUMEr(['infixish'], sub {
my $C = shift;
$C->infixish(1)
}))) {
do {
if (my ($C) = (do { my $M = $C;
$C->can_meta($M->{'infixish'}[0], "zip with")
; })) {
$C->before( sub { my $C=shift;
(($C) x !!do {
my $M = $C;  $M->{'O'} = $M->{'infixish'}[0]{'O'}; delete $M->{'O'}{'prec'}; $M->{'sym'} .= $M->{'infixish'}[0]->Str ;
})
});
}
else {
();
}
};
}
else {
();
}
}
})
}))) {
$C->_SUBSUMEr(['O'], sub {
my $C = shift;
$C->O(%list_infix, $self->Opairs)
});
}
else {
();
}
};
}
else {
();
}
};
}
else {
();
}
};
}
else {
();
}
}
);
}

##     token infix_circumfix_meta_operator__S_265Fre_Nch (:$*sym = < >)
##          token infix_circumfix_meta_operator:sym< > {
##              [
##              | ''
##              | ''
##              ]
##              {} <infixish(1)> [ '' | '' || <.panic: "Missing  or "> ]
##              <.can_meta($<infixish>, "hyper with")>
##              <?{ $<O> := $<infixish><O>; }>
##          }

sub infix_circumfix_meta_operator__S_265Fre_Nch__PEEK { $_[0]->_AUTOLEXpeek('infix_circumfix_meta_operator__S_265Fre_Nch',$retree) }
sub infix_circumfix_meta_operator__S_265Fre_Nch {
no warnings 'recursion';
my $self = shift;
local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;
my %args = @_;
local $::sym = $args{sym} // [qw( )];


my $C = $self->cursor_xact("RULE infix_circumfix_meta_operator__S_265Fre_Nch");
my $xact = $C->xact;
my $S = $C->{'_pos'};
$C->{'sym'} = ref $sym ? join(' ', @$sym) : $sym;

$self->_MATCHIFYr($S, "infix_circumfix_meta_operator__S_265Fre_Nch", 
do {
if (my ($C) = ($C->_BRACKETr(sub {
my $C=shift;
do {
my @result = do {
my $trystate;
my ($tag, $try);
my @try;
my $relex;

my $fate;
my $x;
if ($fate = $C->{'_fate'} and $fate->[1] eq 'infix_circumfix_meta_operator__S_265Fre_Nch_01') {
$C->deb("Fate passed to infix_circumfix_meta_operator__S_265Fre_Nch_01: ", ::fatestr($fate)) if $::DEBUG & DEBUG::fates;
($C->{'_fate'}, $tag, $try) = @$fate;
@try = ($try);
$x = 'ALT infix_circumfix_meta_operator__S_265Fre_Nch_01';    # some outer ltm is controlling us
}
else {
$x = 'ALTLTM infix_circumfix_meta_operator__S_265Fre_Nch_01'; # we are top level ltm
}
my $C = $C->cursor_xact($x);
my $xact = $C->xact;

my @gather = ();
for (;;) {
if (not @try) {
$relex //= $C->cursor_fate('STD::P6', 'infix_circumfix_meta_operator__S_265Fre_Nch_01', $retree);
@try = $relex->($C, $trystate);
}
last unless @try;
$try = shift(@try) // next;

if (ref $try eq 'ARRAY') {
($C->{'_fate'}, $tag, $try) = @$try;	# next candidate fate
}

$C->deb("infix_circumfix_meta_operator__S_265Fre_Nch_01 trying $tag $try") if $::DEBUG & DEBUG::try_processing;
push @gather, ((
sub { my $C=shift;
$C->_EXACT('')
},
sub { my $C=shift;
$C->_EXACT('')
},
)[$try])->($C);
last if $xact->[-2];  # committed?
last if @gather;
}
@gather;
};
@result;
}

}))) {
do {
if (my ($C) = (scalar(do {

}, $C))) {
do {
if (my ($C) = ($C->_SUBSUMEr(['infixish'], sub {
my $C = shift;
$C->infixish(1)
}))) {
do {
if (my ($C) = ($C->_BRACKETr(sub {
my $C=shift;
do {
my $C = $C->cursor_xact('ALT ||');
my $xact = $C->xact;
my @gather;
do {
push @gather, do {
my @result = do {
my $trystate;
my ($tag, $try);
my @try;
my $relex;

my $fate;
my $x;
if ($fate = $C->{'_fate'} and $fate->[1] eq 'infix_circumfix_meta_operator__S_265Fre_Nch_02') {
$C->deb("Fate passed to infix_circumfix_meta_operator__S_265Fre_Nch_02: ", ::fatestr($fate)) if $::DEBUG & DEBUG::fates;
($C->{'_fate'}, $tag, $try) = @$fate;
@try = ($try);
$x = 'ALT infix_circumfix_meta_operator__S_265Fre_Nch_02';    # some outer ltm is controlling us
}
else {
$x = 'ALTLTM infix_circumfix_meta_operator__S_265Fre_Nch_02'; # we are top level ltm
}
my $C = $C->cursor_xact($x);
my $xact = $C->xact;

my @gather = ();
for (;;) {
if (not @try) {
$relex //= $C->cursor_fate('STD::P6', 'infix_circumfix_meta_operator__S_265Fre_Nch_02', $retree);
@try = $relex->($C, $trystate);
}
last unless @try;
$try = shift(@try) // next;

if (ref $try eq 'ARRAY') {
($C->{'_fate'}, $tag, $try) = @$try;	# next candidate fate
}

$C->deb("infix_circumfix_meta_operator__S_265Fre_Nch_02 trying $tag $try") if $::DEBUG & DEBUG::try_processing;
push @gather, ((
sub { my $C=shift;
$C->_EXACT('')
},
sub { my $C=shift;
$C->_EXACT('')
},
)[$try])->($C);
last if $xact->[-2];  # committed?
last if @gather;
}
@gather;
};
@result;
}

}
or $xact->[-2] or
do {
push @gather, $C->panic("Missing  or ")};
@gather;
}
}))) {
do {
if (my ($C) = (do { my $M = $C;
$C->can_meta($M->{'infixish'}, "hyper with")
; })) {
$C->before( sub { my $C=shift;
(($C) x !!do {
my $M = $C;  $M->{'O'} = $M->{'infixish'}{'O'}; ;
})
});
}
else {
();
}
};
}
else {
();
}
};
}
else {
();
}
};
}
else {
();
}
};
}
else {
();
}
}
);
}

##     token infix_circumfix_meta_operator__S_266LtLt_GtGt (:$*sym = << >>)
##          token infix_circumfix_meta_operator:sym<< >> {
##              [
##              | '<<'
##              | '>>'
##              ]
##              {} <infixish(1)> [ '<<' | '>>' || <.panic("Missing << or >>")> ]
##              <.can_meta($<infixish>, "hyper with")>
##              <?{ $<O> := $<infixish><O>; }>
##          }

sub infix_circumfix_meta_operator__S_266LtLt_GtGt__PEEK { $_[0]->_AUTOLEXpeek('infix_circumfix_meta_operator__S_266LtLt_GtGt',$retree) }
sub infix_circumfix_meta_operator__S_266LtLt_GtGt {
no warnings 'recursion';
my $self = shift;
local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;
my %args = @_;
local $::sym = $args{sym} //['<<','>>'];


my $C = $self->cursor_xact("RULE infix_circumfix_meta_operator__S_266LtLt_GtGt");
my $xact = $C->xact;
my $S = $C->{'_pos'};
$C->{'sym'} = ref $sym ? join(' ', @$sym) : $sym;

$self->_MATCHIFYr($S, "infix_circumfix_meta_operator__S_266LtLt_GtGt", 
do {
if (my ($C) = ($C->_BRACKETr(sub {
my $C=shift;
do {
my @result = do {
my $trystate;
my ($tag, $try);
my @try;
my $relex;

my $fate;
my $x;
if ($fate = $C->{'_fate'} and $fate->[1] eq 'infix_circumfix_meta_operator__S_266LtLt_GtGt_01') {
$C->deb("Fate passed to infix_circumfix_meta_operator__S_266LtLt_GtGt_01: ", ::fatestr($fate)) if $::DEBUG & DEBUG::fates;
($C->{'_fate'}, $tag, $try) = @$fate;
@try = ($try);
$x = 'ALT infix_circumfix_meta_operator__S_266LtLt_GtGt_01';    # some outer ltm is controlling us
}
else {
$x = 'ALTLTM infix_circumfix_meta_operator__S_266LtLt_GtGt_01'; # we are top level ltm
}
my $C = $C->cursor_xact($x);
my $xact = $C->xact;

my @gather = ();
for (;;) {
if (not @try) {
$relex //= $C->cursor_fate('STD::P6', 'infix_circumfix_meta_operator__S_266LtLt_GtGt_01', $retree);
@try = $relex->($C, $trystate);
}
last unless @try;
$try = shift(@try) // next;

if (ref $try eq 'ARRAY') {
($C->{'_fate'}, $tag, $try) = @$try;	# next candidate fate
}

$C->deb("infix_circumfix_meta_operator__S_266LtLt_GtGt_01 trying $tag $try") if $::DEBUG & DEBUG::try_processing;
push @gather, ((
sub { my $C=shift;
$C->_EXACT('<<')
},
sub { my $C=shift;
$C->_EXACT('>>')
},
)[$try])->($C);
last if $xact->[-2];  # committed?
last if @gather;
}
@gather;
};
@result;
}

}))) {
do {
if (my ($C) = (scalar(do {

}, $C))) {
do {
if (my ($C) = ($C->_SUBSUMEr(['infixish'], sub {
my $C = shift;
$C->infixish(1)
}))) {
do {
if (my ($C) = ($C->_BRACKETr(sub {
my $C=shift;
do {
my $C = $C->cursor_xact('ALT ||');
my $xact = $C->xact;
my @gather;
do {
push @gather, do {
my @result = do {
my $trystate;
my ($tag, $try);
my @try;
my $relex;

my $fate;
my $x;
if ($fate = $C->{'_fate'} and $fate->[1] eq 'infix_circumfix_meta_operator__S_266LtLt_GtGt_02') {
$C->deb("Fate passed to infix_circumfix_meta_operator__S_266LtLt_GtGt_02: ", ::fatestr($fate)) if $::DEBUG & DEBUG::fates;
($C->{'_fate'}, $tag, $try) = @$fate;
@try = ($try);
$x = 'ALT infix_circumfix_meta_operator__S_266LtLt_GtGt_02';    # some outer ltm is controlling us
}
else {
$x = 'ALTLTM infix_circumfix_meta_operator__S_266LtLt_GtGt_02'; # we are top level ltm
}
my $C = $C->cursor_xact($x);
my $xact = $C->xact;

my @gather = ();
for (;;) {
if (not @try) {
$relex //= $C->cursor_fate('STD::P6', 'infix_circumfix_meta_operator__S_266LtLt_GtGt_02', $retree);
@try = $relex->($C, $trystate);
}
last unless @try;
$try = shift(@try) // next;

if (ref $try eq 'ARRAY') {
($C->{'_fate'}, $tag, $try) = @$try;	# next candidate fate
}

$C->deb("infix_circumfix_meta_operator__S_266LtLt_GtGt_02 trying $tag $try") if $::DEBUG & DEBUG::try_processing;
push @gather, ((
sub { my $C=shift;
$C->_EXACT('<<')
},
sub { my $C=shift;
$C->_EXACT('>>')
},
)[$try])->($C);
last if $xact->[-2];  # committed?
last if @gather;
}
@gather;
};
@result;
}

}
or $xact->[-2] or
do {
push @gather, $C->panic("Missing << or >>")};
@gather;
}
}))) {
do {
if (my ($C) = (do { my $M = $C;
$C->can_meta($M->{'infixish'}, "hyper with")
; })) {
$C->before( sub { my $C=shift;
(($C) x !!do {
my $M = $C;  $M->{'O'} = $M->{'infixish'}{'O'}; ;
})
});
}
else {
();
}
};
}
else {
();
}
};
}
else {
();
}
};
}
else {
();
}
};
}
else {
();
}
}
);
}

##     token infix_postfix_meta_operator__S_267Equal ($op, :$*sym = <=>)
##          token infix_postfix_meta_operator:sym<=> ($op) {
##              '='
##              <.can_meta($op, "make assignment out of")>
##              [ <!{ $op<O><diffy> }> || <.panic("Can't make assignment out of " ~ $op<sym> ~ " because " ~ $op<O><dba> ~ " operators are diffy")> ]
##              { $<sym> = $op<sym> ~ '='; }
##              <O(|%item_assignment, $op.Opairs, dba => 'item assignment', iffy => 0)>
##          }

sub infix_postfix_meta_operator__S_267Equal__PEEK { $_[0]->_AUTOLEXpeek('infix_postfix_meta_operator__S_267Equal',$retree) }
sub infix_postfix_meta_operator__S_267Equal {
no warnings 'recursion';
my $self = shift;
local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;
my $op = shift;
my %args = @_;
local $::sym = $args{sym} // q(=);


my $C = $self->cursor_xact("RULE infix_postfix_meta_operator__S_267Equal");
my $xact = $C->xact;
my $S = $C->{'_pos'};
$C->{'sym'} = ref $sym ? join(' ', @$sym) : $sym;

$self->_MATCHIFYr($S, "infix_postfix_meta_operator__S_267Equal", 
do {
if (my ($C) = ($C->_EXACT('='))) {
do {
if (my ($C) = ($C->can_meta($op, "make assignment out of"))) {
do {
if (my ($C) = ($C->_BRACKETr(sub {
my $C=shift;
do {
my $C = $C->cursor_xact('ALT ||');
my $xact = $C->xact;
my @gather;
do {
push @gather, $C->_NOTBEFORE( sub { my $C=shift;
(($C) x !!do {
$op->{'O'}{'diffy'} 
})
})
}
or $xact->[-2] or
do {
push @gather, $C->panic("Can't make assignment out of " . $op->{'sym'} . " because " . $op->{'O'}{'dba'} . " operators are diffy")};
@gather;
}
}))) {
do {
if (my ($C) = (scalar(do {
my $M = $C;  $M->{'sym'} = $op->{'sym'} . '='; ;
}, $C))) {
$C->_SUBSUMEr(['O'], sub {
my $C = shift;
$C->O(%item_assignment, $op->Opairs, dba => 'item assignment', iffy => 0)
});
}
else {
();
}
};
}
else {
();
}
};
}
else {
();
}
};
}
else {
();
}
}
);
}

##     token postcircumfix__S_268Paren_Thesis (:$*sym = <( )>)
##          token postcircumfix:sym<( )>
##              { :dba('argument list') '(' ~ ')' <semiarglist> <O(|%methodcall)> }

sub postcircumfix__S_268Paren_Thesis__PEEK { $_[0]->_AUTOLEXpeek('postcircumfix__S_268Paren_Thesis',$retree) }
sub postcircumfix__S_268Paren_Thesis {
no warnings 'recursion';
my $self = shift;
local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;
my %args = @_;
local $::sym = $args{sym} // [qw[( )]];


my $C = $self->cursor_xact("RULE postcircumfix__S_268Paren_Thesis");
my $xact = $C->xact;
my $S = $C->{'_pos'};
$C->{'sym'} = ref $sym ? join(' ', @$sym) : $sym;

$self->_MATCHIFYr($S, "postcircumfix__S_268Paren_Thesis", 
do {
if (my ($C) = ($C->_EXACT('('))) {
do {
if (my ($C) = (((local $::GOAL = ')' ), $C)[-1])) {
do {
if (my ($C) = ($C->_SUBSUMEr(['semiarglist'], sub {
my $C = shift;
$C->semiarglist
}))) {
do {
if (my ($C) = ($C->_BRACKETr(sub {
my $C=shift;
do {
my $C = $C->cursor_xact('ALT ||');
my $xact = $C->xact;
my @gather;
do {
push @gather, $C->_EXACT(')')
}
or $xact->[-2] or
do {
push @gather, $C->FAILGOAL(')' , 'argument list')};
@gather;
}
}))) {
$C->_SUBSUMEr(['O'], sub {
my $C = shift;
$C->O(%methodcall)
});
}
else {
();
}
};
}
else {
();
}
};
}
else {
();
}
};
}
else {
();
}
}
);
}

##     token postcircumfix__S_269Bra_Ket (:$*sym = <[ ]>)
##          token postcircumfix:sym<[ ]>
##              { :dba('subscript') '[' ~ ']' <semilist> { $<semilist>.Str ~~ /^\s*\-[1]\s*$/ and $.obs("[-1] subscript to access final element","[*-1]") } <O(|%methodcall)> }

sub postcircumfix__S_269Bra_Ket__PEEK { $_[0]->_AUTOLEXpeek('postcircumfix__S_269Bra_Ket',$retree) }
sub postcircumfix__S_269Bra_Ket {
no warnings 'recursion';
my $self = shift;
local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;
my %args = @_;
local $::sym = $args{sym} // [qw([ ])];


my $C = $self->cursor_xact("RULE postcircumfix__S_269Bra_Ket");
my $xact = $C->xact;
my $S = $C->{'_pos'};
$C->{'sym'} = ref $sym ? join(' ', @$sym) : $sym;

$self->_MATCHIFYr($S, "postcircumfix__S_269Bra_Ket", 
do {
if (my ($C) = ($C->_EXACT('['))) {
do {
if (my ($C) = (((local $::GOAL = ']' ), $C)[-1])) {
do {
if (my ($C) = ($C->_SUBSUMEr(['semilist'], sub {
my $C = shift;
$C->semilist
}))) {
do {
if (my ($C) = ($C->_BRACKETr(sub {
my $C=shift;
do {
my $C = $C->cursor_xact('ALT ||');
my $xact = $C->xact;
my @gather;
do {
push @gather, $C->_EXACT(']')
}
or $xact->[-2] or
do {
push @gather, $C->FAILGOAL(']' , 'subscript')};
@gather;
}
}))) {
do {
if (my ($C) = (scalar(do {
my $M = $C;  $M->{'semilist'}->Str =~ qr/^\s*\-[1]\s*$/ and $C->obs("[-1] subscript to access final element","[*-1]") ;
}, $C))) {
$C->_SUBSUMEr(['O'], sub {
my $C = shift;
$C->O(%methodcall)
});
}
else {
();
}
};
}
else {
();
}
};
}
else {
();
}
};
}
else {
();
}
};
}
else {
();
}
}
);
}

##     token postcircumfix__S_270Cur_Ly (:$*sym = <{ }>)
##          token postcircumfix:sym<{ }>
##              { :dba('subscript') '{' ~ '}' <semilist> <O(|%methodcall)> <.curlycheck> }

sub postcircumfix__S_270Cur_Ly__PEEK { $_[0]->_AUTOLEXpeek('postcircumfix__S_270Cur_Ly',$retree) }
sub postcircumfix__S_270Cur_Ly {
no warnings 'recursion';
my $self = shift;
local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;
my %args = @_;
local $::sym = $args{sym} // [qw({ })];


my $C = $self->cursor_xact("RULE postcircumfix__S_270Cur_Ly");
my $xact = $C->xact;
my $S = $C->{'_pos'};
$C->{'sym'} = ref $sym ? join(' ', @$sym) : $sym;

$self->_MATCHIFYr($S, "postcircumfix__S_270Cur_Ly", 
do {
if (my ($C) = ($C->_EXACT('{'))) {
do {
if (my ($C) = (((local $::GOAL = '}' ), $C)[-1])) {
do {
if (my ($C) = ($C->_SUBSUMEr(['semilist'], sub {
my $C = shift;
$C->semilist
}))) {
do {
if (my ($C) = ($C->_BRACKETr(sub {
my $C=shift;
do {
my $C = $C->cursor_xact('ALT ||');
my $xact = $C->xact;
my @gather;
do {
push @gather, $C->_EXACT('}')
}
or $xact->[-2] or
do {
push @gather, $C->FAILGOAL('}' , 'subscript')};
@gather;
}
}))) {
do {
if (my ($C) = ($C->_SUBSUMEr(['O'], sub {
my $C = shift;
$C->O(%methodcall)
}))) {
$C->curlycheck;
}
else {
();
}
};
}
else {
();
}
};
}
else {
();
}
};
}
else {
();
}
};
}
else {
();
}
}
);
}

##     token postcircumfix__S_271Lt_Gt (:$*sym = < >)
##          token postcircumfix:sym< > {
##              :my $pos;
##              '<'
##              { $pos = $.pos }
##              [
##              || <nibble($.cursor_fresh( %*LANG<Q> ).tweak(:q).tweak(:w).balanced('<','>'))> '>'
##              || <?before \h* [ \d | <sigil> | ':' ] >
##                 { $.cursor_force($pos).panic("Whitespace required before < operator") }
##              || { $.cursor_force($pos).panic("Unable to parse quote-words subscript; couldn't find right angle quote") }
##              ]
##              <O(|%methodcall)>
##          }

sub postcircumfix__S_271Lt_Gt__PEEK { $_[0]->_AUTOLEXpeek('postcircumfix__S_271Lt_Gt',$retree) }
sub postcircumfix__S_271Lt_Gt {
no warnings 'recursion';
my $self = shift;
local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;
my %args = @_;
local $::sym = $args{sym} //['<','>'];
my $pos;


my $C = $self->cursor_xact("RULE postcircumfix__S_271Lt_Gt");
my $xact = $C->xact;
my $S = $C->{'_pos'};
$C->{'sym'} = ref $sym ? join(' ', @$sym) : $sym;

$self->_MATCHIFYr($S, "postcircumfix__S_271Lt_Gt", 
do {
if (my ($C) = ($C->_EXACT('<'))) {
do {
if (my ($C) = (scalar(do {
$pos = $C->{'_pos'} 
}, $C))) {
do {
if (my ($C) = ($C->_BRACKETr(sub {
my $C=shift;
do {
my $C = $C->cursor_xact('ALT ||');
my $xact = $C->xact;
my @gather;
do {
push @gather, do {
if (my ($C) = ($C->_SUBSUMEr(['nibble'], sub {
my $C = shift;
$C->nibble($C->cursor_fresh( $::LANG{'Q'} )->tweak('q' => 1)->tweak('w' => 1)->balanced('<','>'))
}))) {
$C->_EXACT('>');
}
else {
();
}
}
}
or $xact->[-2] or
do {
push @gather, do {
if (my ($C) = ($C->before(sub { my $C=shift;
do {
if (my ($C) = ($C->_PATTERN(qr/\G((?:[\x20\t\r])*+)/))) {
$C->_BRACKETr(sub {
my $C=shift;
do {
my @result = do {
my $trystate;
my ($tag, $try);
my @try;
my $relex;

my $fate;
my $x;
if ($fate = $C->{'_fate'} and $fate->[1] eq 'postcircumfix__S_271Lt_Gt_04') {
$C->deb("Fate passed to postcircumfix__S_271Lt_Gt_04: ", ::fatestr($fate)) if $::DEBUG & DEBUG::fates;
($C->{'_fate'}, $tag, $try) = @$fate;
@try = ($try);
$x = 'ALT postcircumfix__S_271Lt_Gt_04';    # some outer ltm is controlling us
}
else {
$x = 'ALTLTM postcircumfix__S_271Lt_Gt_04'; # we are top level ltm
}
my $C = $C->cursor_xact($x);
my $xact = $C->xact;

my @gather = ();
for (;;) {
if (not @try) {
$relex //= $C->cursor_fate('STD::P6', 'postcircumfix__S_271Lt_Gt_04', $retree);
@try = $relex->($C, $trystate);
}
last unless @try;
$try = shift(@try) // next;

if (ref $try eq 'ARRAY') {
($C->{'_fate'}, $tag, $try) = @$try;	# next candidate fate
}

$C->deb("postcircumfix__S_271Lt_Gt_04 trying $tag $try") if $::DEBUG & DEBUG::try_processing;
push @gather, ((
sub { my $C=shift;
$C->_PATTERN(qr/\G\d/)
},
sub { my $C=shift;
$C->_SUBSUMEr(['sigil'], sub {
my $C = shift;
$C->sigil
})
},
sub { my $C=shift;
$C->_EXACT(':')
},
)[$try])->($C);
last if $xact->[-2];  # committed?
last if @gather;
}
@gather;
};
@result;
}

});
}
else {
();
}
}
}))) {
scalar(do {
$C->cursor_force($pos)->panic("Whitespace required before < operator") 
}, $C);
}
else {
();
}
}
}
or $xact->[-2] or
do {
push @gather, scalar(do {
$C->cursor_force($pos)->panic("Unable to parse quote-words subscript; couldn't find right angle quote") 
}, $C)};
@gather;
}
}))) {
$C->_SUBSUMEr(['O'], sub {
my $C = shift;
$C->O(%methodcall)
});
}
else {
();
}
};
}
else {
();
}
};
}
else {
();
}
}
);
}

##     token postcircumfix__S_272LtLt_GtGt (:$*sym = << >>)
##          token postcircumfix:sym<< >>
##              { '<<' <nibble($.cursor_fresh( %*LANG<Q> ).tweak(:qq).tweak(:ww).balanced('<<','>>'))> [ '>>' || <.panic: "Unable to parse quote-words subscript; couldn't find right double-angle quote"> ] <O(|%methodcall)> }

sub postcircumfix__S_272LtLt_GtGt__PEEK { $_[0]->_AUTOLEXpeek('postcircumfix__S_272LtLt_GtGt',$retree) }
sub postcircumfix__S_272LtLt_GtGt {
no warnings 'recursion';
my $self = shift;
local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;
my %args = @_;
local $::sym = $args{sym} //['<<','>>'];


my $C = $self->cursor_xact("RULE postcircumfix__S_272LtLt_GtGt");
my $xact = $C->xact;
my $S = $C->{'_pos'};
$C->{'sym'} = ref $sym ? join(' ', @$sym) : $sym;

$self->_MATCHIFYr($S, "postcircumfix__S_272LtLt_GtGt", 
do {
if (my ($C) = ($C->_EXACT('<<'))) {
do {
if (my ($C) = ($C->_SUBSUMEr(['nibble'], sub {
my $C = shift;
$C->nibble($C->cursor_fresh( $::LANG{'Q'} )->tweak('qq' => 1)->tweak('ww' => 1)->balanced('<<','>>'))
}))) {
do {
if (my ($C) = ($C->_BRACKETr(sub {
my $C=shift;
do {
my $C = $C->cursor_xact('ALT ||');
my $xact = $C->xact;
my @gather;
do {
push @gather, $C->_EXACT('>>')
}
or $xact->[-2] or
do {
push @gather, $C->panic("Unable to parse quote-words subscript; couldn't find right double-angle quote")};
@gather;
}
}))) {
$C->_SUBSUMEr(['O'], sub {
my $C = shift;
$C->O(%methodcall)
});
}
else {
();
}
};
}
else {
();
}
};
}
else {
();
}
}
);
}

##     token postcircumfix__S_273Fre_Nch (:$*sym = < >)
##          token postcircumfix:sym< >
##              { '' <nibble($.cursor_fresh( %*LANG<Q> ).tweak(:qq).tweak(:ww).balanced('',''))> [ '' || <.panic: "Unable to parse quote-words subscript; couldn't find right double-angle quote"> ] <O(|%methodcall)> }

sub postcircumfix__S_273Fre_Nch__PEEK { $_[0]->_AUTOLEXpeek('postcircumfix__S_273Fre_Nch',$retree) }
sub postcircumfix__S_273Fre_Nch {
no warnings 'recursion';
my $self = shift;
local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;
my %args = @_;
local $::sym = $args{sym} // [qw( )];


my $C = $self->cursor_xact("RULE postcircumfix__S_273Fre_Nch");
my $xact = $C->xact;
my $S = $C->{'_pos'};
$C->{'sym'} = ref $sym ? join(' ', @$sym) : $sym;

$self->_MATCHIFYr($S, "postcircumfix__S_273Fre_Nch", 
do {
if (my ($C) = ($C->_EXACT(''))) {
do {
if (my ($C) = ($C->_SUBSUMEr(['nibble'], sub {
my $C = shift;
$C->nibble($C->cursor_fresh( $::LANG{'Q'} )->tweak('qq' => 1)->tweak('ww' => 1)->balanced('',''))
}))) {
do {
if (my ($C) = ($C->_BRACKETr(sub {
my $C=shift;
do {
my $C = $C->cursor_xact('ALT ||');
my $xact = $C->xact;
my @gather;
do {
push @gather, $C->_EXACT('')
}
or $xact->[-2] or
do {
push @gather, $C->panic("Unable to parse quote-words subscript; couldn't find right double-angle quote")};
@gather;
}
}))) {
$C->_SUBSUMEr(['O'], sub {
my $C = shift;
$C->O(%methodcall)
});
}
else {
();
}
};
}
else {
();
}
};
}
else {
();
}
}
);
}

##     token postop
##          token postop {
##              | <postfix>         { $<O> := $<postfix><O>; $<sym> := $<postfix><sym>; }
##              | <postcircumfix>   { $<O> := $<postcircumfix><O>; $<sym> := $<postcircumfix><sym>; }
##          }

sub postop__PEEK { $_[0]->_AUTOLEXpeek('postop',$retree) }
sub postop {
no warnings 'recursion';
my $self = shift;
local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;


my $C = $self->cursor_xact("RULE postop");
my $xact = $C->xact;
my $S = $C->{'_pos'};

$self->_MATCHIFYr($S, "postop", 
do {
my @result = do {
my $trystate;
my ($tag, $try);
my @try;
my $relex;

my $fate;
my $x;
if ($fate = $C->{'_fate'} and $fate->[1] eq 'postop_00') {
$C->deb("Fate passed to postop_00: ", ::fatestr($fate)) if $::DEBUG & DEBUG::fates;
($C->{'_fate'}, $tag, $try) = @$fate;
@try = ($try);
$x = 'ALT postop_00';    # some outer ltm is controlling us
}
else {
$x = 'ALTLTM postop_00'; # we are top level ltm
}
my $C = $C->cursor_xact($x);
my $xact = $C->xact;

my @gather = ();
for (;;) {
if (not @try) {
$relex //= $C->cursor_fate('STD::P6', 'postop_00', $retree);
@try = $relex->($C, $trystate);
}
last unless @try;
$try = shift(@try) // next;

if (ref $try eq 'ARRAY') {
($C->{'_fate'}, $tag, $try) = @$try;	# next candidate fate
}

$C->deb("postop_00 trying $tag $try") if $::DEBUG & DEBUG::try_processing;
push @gather, ((
sub { my $C=shift;
do {
if (my ($C) = ($C->_SUBSUMEr(['postfix'], sub {
my $C = shift;
$C->postfix
}))) {
scalar(do {
my $M = $C;  $M->{'O'} = $M->{'postfix'}{'O'}; $M->{'sym'} = $M->{'postfix'}{'sym'}; ;
}, $C);
}
else {
();
}
}
},
sub { my $C=shift;
do {
if (my ($C) = ($C->_SUBSUMEr(['postcircumfix'], sub {
my $C = shift;
$C->postcircumfix
}))) {
scalar(do {
my $M = $C;  $M->{'O'} = $M->{'postcircumfix'}{'O'}; $M->{'sym'} = $M->{'postcircumfix'}{'sym'}; ;
}, $C);
}
else {
();
}
}
},
)[$try])->($C);
last if $xact->[-2];  # committed?
last if @gather;
}
@gather;
};
@result;
}

);
}

##     token methodop
##          token methodop {
##              [
##              | <longname>
##              | <?before '$' | '@' | '&' > <variable> { $*VAR = $<variable> }
##              | <?before <[ ' " ]> >
##                  [ <!{$*QSIGIL}> || <!before '"' <-["]>*? \s > ] # dwim on "$foo."
##                  <quote>
##                  [ <?before '(' | '.(' | '\\'> || <.obs('. to concatenate strings or to call a quoted method', '~ to concatenate, or if you meant to call a quoted method, please supply the required parentheses')> ]
##                  { my $t = $<quote><nibble>.Str; $t ~~ /\W/ or $t ~~ /^(WHO|WHAT|WHERE|WHEN|WHY|HOW)$/ or $.worry("Useless use of quotes") }
##              ] <.unsp>? 
##      
##              :dba('method arguments')
##              [
##              | ':' <?before \s> <!{ $*QSIGIL }> <arglist>
##              | <?[\\(]> <args>
##              | { @*MEMOS[$.pos]<baremeth> = 1 }
##              ]?
##          }

sub methodop__PEEK { $_[0]->_AUTOLEXpeek('methodop',$retree) }
sub methodop {
no warnings 'recursion';
my $self = shift;
local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;


my $C = $self->cursor_xact("RULE methodop");
my $xact = $C->xact;
my $S = $C->{'_pos'};
$C->{'arglist'} = [];
$C->{'args'} = [];

$self->_MATCHIFY($S, "methodop", 
Cursor::lazymap(sub {
my $C=$_[0];
Cursor::lazymap(sub {
my $C=$_[0];
$C->_OPTr(sub { my $C=shift;
$C->_BRACKET(sub {
my $C=shift;
do {
my @result = do {
my $trystate;
my ($tag, $try);
my @try;
my $relex;

my $fate;
my $x;
if ($fate = $C->{'_fate'} and $fate->[1] eq 'methodop_10') {
$C->deb("Fate passed to methodop_10: ", ::fatestr($fate)) if $::DEBUG & DEBUG::fates;
($C->{'_fate'}, $tag, $try) = @$fate;
@try = ($try);
$x = 'ALT methodop_10';    # some outer ltm is controlling us
}
else {
$x = 'ALTLTM methodop_10'; # we are top level ltm
}
my $C = $C->cursor_xact($x);
my $xact = $C->xact;

my @gather = ();
for (;;) {
if (not @try) {
$relex //= $C->cursor_fate('STD::P6', 'methodop_10', $retree);
@try = $relex->($C, $trystate);
}
last unless @try;
$try = shift(@try) // next;

if (ref $try eq 'ARRAY') {
($C->{'_fate'}, $tag, $try) = @$try;	# next candidate fate
}

$C->deb("methodop_10 trying $tag $try") if $::DEBUG & DEBUG::try_processing;
push @gather, ((
sub { my $C=shift;
Cursor::lazymap(sub {
my $C=$_[0];
Cursor::lazymap(sub {
my $C=$_[0];
Cursor::lazymap(sub {
my $C=$_[0];
$C->_SUBSUME(['arglist'], sub {
my $C = shift;
$C->arglist
})
}, $C->_NOTBEFORE( sub { my $C=shift;
(($C) x !!do {
$::QSIGIL 
})
}))
}, $C->before(sub { my $C=shift;
$C->_PATTERN(qr/\G\s/)
}))
}, $C->_EXACT(':'))
},
sub { my $C=shift;
Cursor::lazymap(sub {
my $C=$_[0];
$C->_SUBSUME(['args'], sub {
my $C = shift;
$C->args
})
}, $C->before( sub { my $C=shift;
$C->_PATTERN(qr/\G[\\(]/)
}))
},
sub { my $C=shift;
scalar(do {
$::MEMOS[$C->{'_pos'}]{'baremeth'} = 1 
}, $C)
},
)[$try])->($C);
last if $xact->[-2];  # committed?
last if @gather;
}
@gather;
};
@result;
}

})
})
}, $C->_OPTr(sub { my $C=shift;
$C->unsp
}))
}, $C->_BRACKET(sub {
my $C=shift;
do {
my @result = do {
my $trystate;
my ($tag, $try);
my @try;
my $relex;

my $fate;
my $x;
if ($fate = $C->{'_fate'} and $fate->[1] eq 'methodop_01') {
$C->deb("Fate passed to methodop_01: ", ::fatestr($fate)) if $::DEBUG & DEBUG::fates;
($C->{'_fate'}, $tag, $try) = @$fate;
@try = ($try);
$x = 'ALT methodop_01';    # some outer ltm is controlling us
}
else {
$x = 'ALTLTM methodop_01'; # we are top level ltm
}
my $C = $C->cursor_xact($x);
my $xact = $C->xact;

my @gather = ();
for (;;) {
if (not @try) {
$relex //= $C->cursor_fate('STD::P6', 'methodop_01', $retree);
@try = $relex->($C, $trystate);
}
last unless @try;
$try = shift(@try) // next;

if (ref $try eq 'ARRAY') {
($C->{'_fate'}, $tag, $try) = @$try;	# next candidate fate
}

$C->deb("methodop_01 trying $tag $try") if $::DEBUG & DEBUG::try_processing;
push @gather, ((
sub { my $C=shift;
$C->_SUBSUME(['longname'], sub {
my $C = shift;
$C->longname
})
},
sub { my $C=shift;
Cursor::lazymap(sub {
my $C=$_[0];
Cursor::lazymap(sub {
my $C=$_[0];
scalar(do {
my $M = $C;  $::VAR = $M->{'variable'} ;
}, $C)
}, $C->_SUBSUME(['variable'], sub {
my $C = shift;
$C->variable
}))
}, $C->before(sub { my $C=shift;
do {
my @result = do {
my $trystate;
my ($tag, $try);
my @try;
my $relex;

my $fate;
my $x;
if ($fate = $C->{'_fate'} and $fate->[1] eq 'methodop_02') {
$C->deb("Fate passed to methodop_02: ", ::fatestr($fate)) if $::DEBUG & DEBUG::fates;
($C->{'_fate'}, $tag, $try) = @$fate;
@try = ($try);
$x = 'ALT methodop_02';    # some outer ltm is controlling us
}
else {
$x = 'ALTLTM methodop_02'; # we are top level ltm
}
my $C = $C->cursor_xact($x);
my $xact = $C->xact;

my @gather = ();
for (;;) {
if (not @try) {
$relex //= $C->cursor_fate('STD::P6', 'methodop_02', $retree);
@try = $relex->($C, $trystate);
}
last unless @try;
$try = shift(@try) // next;

if (ref $try eq 'ARRAY') {
($C->{'_fate'}, $tag, $try) = @$try;	# next candidate fate
}

$C->deb("methodop_02 trying $tag $try") if $::DEBUG & DEBUG::try_processing;
push @gather, ((
sub { my $C=shift;
$C->_EXACT('$')
},
sub { my $C=shift;
$C->_EXACT('@')
},
sub { my $C=shift;
$C->_EXACT('&')
},
)[$try])->($C);
last if $xact->[-2];  # committed?
last if @gather;
}
@gather;
};
@result;
}

}))
},
sub { my $C=shift;
Cursor::lazymap(sub {
my $C=$_[0];
Cursor::lazymap(sub {
my $C=$_[0];
Cursor::lazymap(sub {
my $C=$_[0];
Cursor::lazymap(sub {
my $C=$_[0];
scalar(do {
my $M = $C;  my $t = $M->{'quote'}{'nibble'}->Str; $t =~ qr/\W/ or $t =~ qr/^(WHO|WHAT|WHERE|WHEN|WHY|HOW)$/ or $C->worry("Useless use of quotes") ;
}, $C)
}, $C->_BRACKET(sub {
my $C=shift;
do {
my $C = $C->cursor_xact('ALT ||');
my $xact = $C->xact;
my @gather;
do {
push @gather, $C->before(sub { my $C=shift;
do {
my @result = do {
my $trystate;
my ($tag, $try);
my @try;
my $relex;

my $fate;
my $x;
if ($fate = $C->{'_fate'} and $fate->[1] eq 'methodop_08') {
$C->deb("Fate passed to methodop_08: ", ::fatestr($fate)) if $::DEBUG & DEBUG::fates;
($C->{'_fate'}, $tag, $try) = @$fate;
@try = ($try);
$x = 'ALT methodop_08';    # some outer ltm is controlling us
}
else {
$x = 'ALTLTM methodop_08'; # we are top level ltm
}
my $C = $C->cursor_xact($x);
my $xact = $C->xact;

my @gather = ();
for (;;) {
if (not @try) {
$relex //= $C->cursor_fate('STD::P6', 'methodop_08', $retree);
@try = $relex->($C, $trystate);
}
last unless @try;
$try = shift(@try) // next;

if (ref $try eq 'ARRAY') {
($C->{'_fate'}, $tag, $try) = @$try;	# next candidate fate
}

$C->deb("methodop_08 trying $tag $try") if $::DEBUG & DEBUG::try_processing;
push @gather, ((
sub { my $C=shift;
$C->_EXACT('(')
},
sub { my $C=shift;
$C->_EXACT('.(')
},
sub { my $C=shift;
$C->_EXACT('\\')
},
)[$try])->($C);
last if $xact->[-2];  # committed?
last if @gather;
}
@gather;
};
@result;
}

})
}
or $xact->[-2] or
do {
push @gather, $C->obs('. to concatenate strings or to call a quoted method', '~ to concatenate, or if you meant to call a quoted method, please supply the required parentheses')};
@gather;
}
}))
}, $C->_SUBSUME(['quote'], sub {
my $C = shift;
$C->quote
}))
}, $C->_BRACKET(sub {
my $C=shift;
do {
my $C = $C->cursor_xact('ALT ||');
my $xact = $C->xact;
my @gather;
do {
push @gather, $C->_NOTBEFORE( sub { my $C=shift;
(($C) x !!do {
$::QSIGIL
})
})
}
or $xact->[-2] or
do {
push @gather, $C->_NOTBEFORE( sub { my $C=shift;
$C->before(sub { my $C=shift;
Cursor::lazymap(sub {
my $C=$_[0];
Cursor::lazymap(sub {
my $C=$_[0];
$C->_PATTERN(qr/\G\s/)
}, $C->_STARf(sub { my $C=shift;
$C->_PATTERN(qr/\G[^"]/)
}))
}, $C->_EXACT('"'))
})
})};
@gather;
}
}))
}, $C->before(sub { my $C=shift;
$C->_PATTERN(qr/\G['"]/)
}))
},
)[$try])->($C);
last if $xact->[-2];  # committed?
last if @gather;
}
@gather;
};
@result;
}

}))
);
}

##     token semiarglist
##          token semiarglist {
##              <arglist> ** ';'
##              <.ws>
##          }

sub semiarglist__PEEK { $_[0]->_AUTOLEXpeek('semiarglist',$retree) }
sub semiarglist {
no warnings 'recursion';
my $self = shift;
local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;


my $C = $self->cursor_xact("RULE semiarglist");
my $xact = $C->xact;
my $S = $C->{'_pos'};
$C->{'arglist'} = [];

$self->_MATCHIFYr($S, "semiarglist", 
do {
if (my ($C) = ($C->_REPSEPr(  sub { my $C=shift;
$C->_EXACT(';')
}, sub { my $C=shift;
$C->_SUBSUMEr(['arglist'], sub {
my $C = shift;
$C->arglist
})
}))) {
$C->ws;
}
else {
();
}
}
);
}

##     token arglist
##          token arglist {
##              :my $inv_ok = $*INVOCANT_OK;
##              :my StrPos $*endargs = 0;
##              :my $*GOAL ::= 'endargs';
##              :my $*QSIGIL ::= '';
##              <.ws>
##              :dba('argument list')
##              [
##              | <?stdstopper>
##              | <EXPR(item %list_prefix)> {{
##                      my $delims = $<EXPR><delims>;
##                      for @$delims {
##                          if $_.<infix><wascolon> // '' {
##                              if $inv_ok {
##                                  $*INVOCANT_IS = $<EXPR><list>[0];
##                              }
##                          }
##                      }
##                  }}
##              ]
##          }

sub arglist__PEEK { $_[0]->_AUTOLEXpeek('arglist',$retree) }
sub arglist {
no warnings 'recursion';
my $self = shift;
local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;
my $inv_ok = $::INVOCANT_OK;
local $::endargs = 0;
local $::GOAL = 'endargs';
local $::QSIGIL = '';


my $C = $self->cursor_xact("RULE arglist");
my $xact = $C->xact;
my $S = $C->{'_pos'};

$self->_MATCHIFYr($S, "arglist", 
do {
if (my ($C) = ($C->ws)) {
$C->_BRACKETr(sub {
my $C=shift;
do {
my @result = do {
my $trystate;
my ($tag, $try);
my @try;
my $relex;

my $fate;
my $x;
if ($fate = $C->{'_fate'} and $fate->[1] eq 'arglist_01') {
$C->deb("Fate passed to arglist_01: ", ::fatestr($fate)) if $::DEBUG & DEBUG::fates;
($C->{'_fate'}, $tag, $try) = @$fate;
@try = ($try);
$x = 'ALT arglist_01';    # some outer ltm is controlling us
}
else {
$x = 'ALTLTM arglist_01'; # we are top level ltm
}
my $C = $C->cursor_xact($x);
my $xact = $C->xact;

my @gather = ();
for (;;) {
if (not @try) {
$relex //= $C->cursor_fate('STD::P6', 'arglist_01', $retree);
@try = $relex->($C, $trystate);
}
last unless @try;
$try = shift(@try) // next;

if (ref $try eq 'ARRAY') {
($C->{'_fate'}, $tag, $try) = @$try;	# next candidate fate
}

$C->deb("arglist_01 trying $tag $try") if $::DEBUG & DEBUG::try_processing;
push @gather, ((
sub { my $C=shift;
$C->before( sub { my $C=shift;
$C->stdstopper
})
},
sub { my $C=shift;
do {
if (my ($C) = ($C->_SUBSUMEr(['EXPR'], sub {
my $C = shift;
$C->EXPR(\%list_prefix)
}))) {
scalar(do {
my $M = $C; 
my $delims = $M->{'EXPR'}{'delims'};
for (@$delims) {
if ($_->{'infix'}{'wascolon'} // '') {
if ($inv_ok) {
$::INVOCANT_IS = $M->{'EXPR'}{'list'}[0];
}
}
}
;
}, $C);
}
else {
();
}
}
},
)[$try])->($C);
last if $xact->[-2];  # committed?
last if @gather;
}
@gather;
};
@result;
}

});
}
else {
();
}
}
);
}

##     token term__S_274lambda (:$*sym = 'lambda')
##          token term:lambda {
##              <?before <.lambda> >
##              <pblock>
##              {{
##                  if $*BORG {
##                      $*BORG.<block> = $<pblock>;
##                  }
##              }}
##              <O(|%term)>
##          }

sub term__S_274lambda__PEEK { $_[0]->_AUTOLEXpeek('term__S_274lambda',$retree) }
sub term__S_274lambda {
no warnings 'recursion';
my $self = shift;
local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;
my %args = @_;
local $::sym = $args{sym} // 'lambda';


my $C = $self->cursor_xact("RULE term__S_274lambda");
my $xact = $C->xact;
my $S = $C->{'_pos'};
$C->{'sym'} = ref $sym ? join(' ', @$sym) : $sym;

$self->_MATCHIFYr($S, "term__S_274lambda", 
do {
if (my ($C) = ($C->before(sub { my $C=shift;
$C->lambda
}))) {
do {
if (my ($C) = ($C->_SUBSUMEr(['pblock'], sub {
my $C = shift;
$C->pblock
}))) {
do {
if (my ($C) = (scalar(do {
my $M = $C; 
if ($::BORG) {
$::BORG->{'block'} = $M->{'pblock'};
}
;
}, $C))) {
$C->_SUBSUMEr(['O'], sub {
my $C = shift;
$C->O(%term)
});
}
else {
();
}
};
}
else {
();
}
};
}
else {
();
}
}
);
}

##     token circumfix__S_275Cur_Ly (:$*sym = <{ }>)
##          token circumfix:sym<{ }> {
##              <?before '{' >
##              <pblock>
##              {{
##                  if $*BORG {
##                      $*BORG.<block> = $<pblock>;
##                  }
##              }}
##              <O(|%term)>
##          }

sub circumfix__S_275Cur_Ly__PEEK { $_[0]->_AUTOLEXpeek('circumfix__S_275Cur_Ly',$retree) }
sub circumfix__S_275Cur_Ly {
no warnings 'recursion';
my $self = shift;
local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;
my %args = @_;
local $::sym = $args{sym} // [qw({ })];


my $C = $self->cursor_xact("RULE circumfix__S_275Cur_Ly");
my $xact = $C->xact;
my $S = $C->{'_pos'};
$C->{'sym'} = ref $sym ? join(' ', @$sym) : $sym;

$self->_MATCHIFYr($S, "circumfix__S_275Cur_Ly", 
do {
if (my ($C) = ($C->before(sub { my $C=shift;
$C->_EXACT('{')
}))) {
do {
if (my ($C) = ($C->_SUBSUMEr(['pblock'], sub {
my $C = shift;
$C->pblock
}))) {
do {
if (my ($C) = (scalar(do {
my $M = $C; 
if ($::BORG) {
$::BORG->{'block'} = $M->{'pblock'};
}
;
}, $C))) {
$C->_SUBSUMEr(['O'], sub {
my $C = shift;
$C->O(%term)
});
}
else {
();
}
};
}
else {
();
}
};
}
else {
();
}
}
);
}

## methodcall

##     token postfix__S_276i (:$*sym = <i>)
##          token postfix:sym<i>
##              { <sym>  <O(|%methodcall)> }

sub postfix__S_276i__PEEK { $_[0]->_AUTOLEXpeek('postfix__S_276i',$retree) }
sub postfix__S_276i {
no warnings 'recursion';
my $self = shift;
local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;
my %args = @_;
local $::sym = $args{sym} // q(i);


my $C = $self->cursor_xact("RULE postfix__S_276i");
my $xact = $C->xact;
my $S = $C->{'_pos'};
$C->{'sym'} = ref $sym ? join(' ', @$sym) : $sym;

$self->_MATCHIFYr($S, "postfix__S_276i", 
do {
if (my ($C) = ($C->_PATTERN(qr/\Gi/))) {
do {
if (my ($C) = ($C->_PATTERN(qr/\G\b/))) {
$C->_SUBSUMEr(['O'], sub {
my $C = shift;
$C->O(%methodcall)
});
}
else {
();
}
};
}
else {
();
}
}
);
}

##     token infix__S_277Dot (:$*sym = <.>)
##          token infix:sym<.> ()
##              { '.' <[\]\)\},:\s\$"']> <.obs('. to concatenate strings', '~')> }

sub infix__S_277Dot__PEEK { $_[0]->_AUTOLEXpeek('infix__S_277Dot',$retree) }
sub infix__S_277Dot {
no warnings 'recursion';
my $self = shift;
local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;
my %args = @_;
local $::sym = $args{sym} // q(.);


my $C = $self->cursor_xact("RULE infix__S_277Dot");
my $xact = $C->xact;
my $S = $C->{'_pos'};
$C->{'sym'} = ref $sym ? join(' ', @$sym) : $sym;

$self->_MATCHIFYr($S, "infix__S_277Dot", 
do {
if (my ($C) = ($C->_EXACT('.'))) {
do {
if (my ($C) = ($C->_PATTERN(qr/\G[\]\)\},:\s\$"']/))) {
$C->obs('. to concatenate strings', '~');
}
else {
();
}
};
}
else {
();
}
}
);
}

##     token postfix__S_278MinusGt (:$*sym = ['->'])
##          token postfix:sym['->'] () {
##              '->'
##              [
##              | <brack=[ \[ \{ \( ]> <.obs("'->" ~ $<brack>.Str ~ "' as postfix dereferencer", "'." ~ $<brack>.Str ~ "' or just '" ~ $<brack>.Str ~ "' to deref, or whitespace to delimit a pointy block")>
##              | <.obs('-> as postfix', 'either . to call a method, or whitespace to delimit a pointy block')>
##              ]
##          }

sub postfix__S_278MinusGt__PEEK { $_[0]->_AUTOLEXpeek('postfix__S_278MinusGt',$retree) }
sub postfix__S_278MinusGt {
no warnings 'recursion';
my $self = shift;
local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;
my %args = @_;
local $::sym = $args{sym} // ['->'];


my $C = $self->cursor_xact("RULE postfix__S_278MinusGt");
my $xact = $C->xact;
my $S = $C->{'_pos'};
$C->{'sym'} = ref $sym ? join(' ', @$sym) : $sym;

$self->_MATCHIFYr($S, "postfix__S_278MinusGt", 
do {
if (my ($C) = ($C->_EXACT('->'))) {
$C->_BRACKETr(sub {
my $C=shift;
do {
my @result = do {
my $trystate;
my ($tag, $try);
my @try;
my $relex;

my $fate;
my $x;
if ($fate = $C->{'_fate'} and $fate->[1] eq 'postfix__S_278MinusGt_01') {
$C->deb("Fate passed to postfix__S_278MinusGt_01: ", ::fatestr($fate)) if $::DEBUG & DEBUG::fates;
($C->{'_fate'}, $tag, $try) = @$fate;
@try = ($try);
$x = 'ALT postfix__S_278MinusGt_01';    # some outer ltm is controlling us
}
else {
$x = 'ALTLTM postfix__S_278MinusGt_01'; # we are top level ltm
}
my $C = $C->cursor_xact($x);
my $xact = $C->xact;

my @gather = ();
for (;;) {
if (not @try) {
$relex //= $C->cursor_fate('STD::P6', 'postfix__S_278MinusGt_01', $retree);
@try = $relex->($C, $trystate);
}
last unless @try;
$try = shift(@try) // next;

if (ref $try eq 'ARRAY') {
($C->{'_fate'}, $tag, $try) = @$try;	# next candidate fate
}

$C->deb("postfix__S_278MinusGt_01 trying $tag $try") if $::DEBUG & DEBUG::try_processing;
push @gather, ((
sub { my $C=shift;
do {
if (my ($C) = (  $C->_SUBSUMEr(['brack'], sub {
my $C = shift;
$C->_PATTERN(qr/\G[\[\{\(]/)
}))) {
do { my $M = $C;
$C->obs("'->" . $M->{'brack'}->Str . "' as postfix dereferencer", "'." . $M->{'brack'}->Str . "' or just '" . $M->{'brack'}->Str . "' to deref, or whitespace to delimit a pointy block")
; };
}
else {
();
}
}
},
sub { my $C=shift;
$C->obs('-> as postfix', 'either . to call a method, or whitespace to delimit a pointy block')
},
)[$try])->($C);
last if $xact->[-2];  # committed?
last if @gather;
}
@gather;
};
@result;
}

});
}
else {
();
}
}
);
}

## autoincrement
##     token postfix__S_279PlusPlus (:$*sym = <++>)
##          token postfix:sym<++>
##              { <sym> <O(|%autoincrement)> }

sub postfix__S_279PlusPlus__PEEK { $_[0]->_AUTOLEXpeek('postfix__S_279PlusPlus',$retree) }
sub postfix__S_279PlusPlus {
no warnings 'recursion';
my $self = shift;
local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;
my %args = @_;
local $::sym = $args{sym} // q(++);


my $C = $self->cursor_xact("RULE postfix__S_279PlusPlus");
my $xact = $C->xact;
my $S = $C->{'_pos'};
$C->{'sym'} = ref $sym ? join(' ', @$sym) : $sym;

$self->_MATCHIFYr($S, "postfix__S_279PlusPlus", 
do {
if (my ($C) = ($C->_PATTERN(qr/\G\+\+/))) {
$C->_SUBSUMEr(['O'], sub {
my $C = shift;
$C->O(%autoincrement)
});
}
else {
();
}
}
);
}

##     token postfix__S_280MinusMinus (:$*sym = --)
##          token postfix:sym-- ()
##              { <sym> <O(|%autoincrement)> }

sub postfix__S_280MinusMinus__PEEK { $_[0]->_AUTOLEXpeek('postfix__S_280MinusMinus',$retree) }
sub postfix__S_280MinusMinus {
no warnings 'recursion';
my $self = shift;
local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;
my %args = @_;
local $::sym = $args{sym} //['--'];


my $C = $self->cursor_xact("RULE postfix__S_280MinusMinus");
my $xact = $C->xact;
my $S = $C->{'_pos'};
$C->{'sym'} = ref $sym ? join(' ', @$sym) : $sym;

$self->_MATCHIFYr($S, "postfix__S_280MinusMinus", 
do {
if (my ($C) = ($C->_PATTERN(qr/\G\-\-/))) {
$C->_SUBSUMEr(['O'], sub {
my $C = shift;
$C->O(%autoincrement)
});
}
else {
();
}
}
);
}

##     token prefix__S_281PlusPlus (:$*sym = <++>)
##          token prefix:sym<++>
##              { <sym> <O(|%autoincrement)> }

sub prefix__S_281PlusPlus__PEEK { $_[0]->_AUTOLEXpeek('prefix__S_281PlusPlus',$retree) }
sub prefix__S_281PlusPlus {
no warnings 'recursion';
my $self = shift;
local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;
my %args = @_;
local $::sym = $args{sym} // q(++);


my $C = $self->cursor_xact("RULE prefix__S_281PlusPlus");
my $xact = $C->xact;
my $S = $C->{'_pos'};
$C->{'sym'} = ref $sym ? join(' ', @$sym) : $sym;

$self->_MATCHIFYr($S, "prefix__S_281PlusPlus", 
do {
if (my ($C) = ($C->_PATTERN(qr/\G\+\+/))) {
$C->_SUBSUMEr(['O'], sub {
my $C = shift;
$C->O(%autoincrement)
});
}
else {
();
}
}
);
}

##     token prefix__S_282MinusMinus (:$*sym = --)
##          token prefix:sym-- ()
##              { <sym> <O(|%autoincrement)> }

sub prefix__S_282MinusMinus__PEEK { $_[0]->_AUTOLEXpeek('prefix__S_282MinusMinus',$retree) }
sub prefix__S_282MinusMinus {
no warnings 'recursion';
my $self = shift;
local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;
my %args = @_;
local $::sym = $args{sym} //['--'];


my $C = $self->cursor_xact("RULE prefix__S_282MinusMinus");
my $xact = $C->xact;
my $S = $C->{'_pos'};
$C->{'sym'} = ref $sym ? join(' ', @$sym) : $sym;

$self->_MATCHIFYr($S, "prefix__S_282MinusMinus", 
do {
if (my ($C) = ($C->_PATTERN(qr/\G\-\-/))) {
$C->_SUBSUMEr(['O'], sub {
my $C = shift;
$C->O(%autoincrement)
});
}
else {
();
}
}
);
}

## exponentiation
##     token infix__S_283StarStar (:$*sym = <**>)
##          token infix:sym<**>
##              { <sym> <O(|%exponentiation)> }

sub infix__S_283StarStar__PEEK { $_[0]->_AUTOLEXpeek('infix__S_283StarStar',$retree) }
sub infix__S_283StarStar {
no warnings 'recursion';
my $self = shift;
local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;
my %args = @_;
local $::sym = $args{sym} // q(**);


my $C = $self->cursor_xact("RULE infix__S_283StarStar");
my $xact = $C->xact;
my $S = $C->{'_pos'};
$C->{'sym'} = ref $sym ? join(' ', @$sym) : $sym;

$self->_MATCHIFYr($S, "infix__S_283StarStar", 
do {
if (my ($C) = ($C->_PATTERN(qr/\G\*\*/))) {
$C->_SUBSUMEr(['O'], sub {
my $C = shift;
$C->O(%exponentiation)
});
}
else {
();
}
}
);
}

## symbolic unary
##     token prefix__S_284Bang (:$*sym = <!>)
##          token prefix:sym<!>
##              { <sym> <O(|%symbolic_unary)> }

sub prefix__S_284Bang__PEEK { $_[0]->_AUTOLEXpeek('prefix__S_284Bang',$retree) }
sub prefix__S_284Bang {
no warnings 'recursion';
my $self = shift;
local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;
my %args = @_;
local $::sym = $args{sym} // q(!);


my $C = $self->cursor_xact("RULE prefix__S_284Bang");
my $xact = $C->xact;
my $S = $C->{'_pos'};
$C->{'sym'} = ref $sym ? join(' ', @$sym) : $sym;

$self->_MATCHIFYr($S, "prefix__S_284Bang", 
do {
if (my ($C) = ($C->_PATTERN(qr/\G\!/))) {
$C->_SUBSUMEr(['O'], sub {
my $C = shift;
$C->O(%symbolic_unary)
});
}
else {
();
}
}
);
}

##     token prefix__S_285Plus (:$*sym = <+>)
##          token prefix:sym<+>
##              { <sym> <O(|%symbolic_unary)> }

sub prefix__S_285Plus__PEEK { $_[0]->_AUTOLEXpeek('prefix__S_285Plus',$retree) }
sub prefix__S_285Plus {
no warnings 'recursion';
my $self = shift;
local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;
my %args = @_;
local $::sym = $args{sym} // q(+);


my $C = $self->cursor_xact("RULE prefix__S_285Plus");
my $xact = $C->xact;
my $S = $C->{'_pos'};
$C->{'sym'} = ref $sym ? join(' ', @$sym) : $sym;

$self->_MATCHIFYr($S, "prefix__S_285Plus", 
do {
if (my ($C) = ($C->_PATTERN(qr/\G\+/))) {
$C->_SUBSUMEr(['O'], sub {
my $C = shift;
$C->O(%symbolic_unary)
});
}
else {
();
}
}
);
}

##     token prefix__S_286Minus (:$*sym = <->)
##          token prefix:sym<->
##              { <sym> <O(|%symbolic_unary)> }

sub prefix__S_286Minus__PEEK { $_[0]->_AUTOLEXpeek('prefix__S_286Minus',$retree) }
sub prefix__S_286Minus {
no warnings 'recursion';
my $self = shift;
local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;
my %args = @_;
local $::sym = $args{sym} // q(-);


my $C = $self->cursor_xact("RULE prefix__S_286Minus");
my $xact = $C->xact;
my $S = $C->{'_pos'};
$C->{'sym'} = ref $sym ? join(' ', @$sym) : $sym;

$self->_MATCHIFYr($S, "prefix__S_286Minus", 
do {
if (my ($C) = ($C->_PATTERN(qr/\G\-/))) {
$C->_SUBSUMEr(['O'], sub {
my $C = shift;
$C->O(%symbolic_unary)
});
}
else {
();
}
}
);
}

##     token prefix__S_287TildeTilde (:$*sym = <~~>)
##          token prefix:sym<~~>
##              { <sym> <.badinfix> <O(|%symbolic_unary)> }

sub prefix__S_287TildeTilde__PEEK { $_[0]->_AUTOLEXpeek('prefix__S_287TildeTilde',$retree) }
sub prefix__S_287TildeTilde {
no warnings 'recursion';
my $self = shift;
local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;
my %args = @_;
local $::sym = $args{sym} // q(~~);


my $C = $self->cursor_xact("RULE prefix__S_287TildeTilde");
my $xact = $C->xact;
my $S = $C->{'_pos'};
$C->{'sym'} = ref $sym ? join(' ', @$sym) : $sym;

$self->_MATCHIFYr($S, "prefix__S_287TildeTilde", 
do {
if (my ($C) = ($C->_PATTERN(qr/\G\~\~/))) {
do {
if (my ($C) = ($C->badinfix)) {
$C->_SUBSUMEr(['O'], sub {
my $C = shift;
$C->O(%symbolic_unary)
});
}
else {
();
}
};
}
else {
();
}
}
);
}

##     token prefix__S_288Tilde (:$*sym = <~>)
##          token prefix:sym<~>
##              { <sym> <O(|%symbolic_unary)> }

sub prefix__S_288Tilde__PEEK { $_[0]->_AUTOLEXpeek('prefix__S_288Tilde',$retree) }
sub prefix__S_288Tilde {
no warnings 'recursion';
my $self = shift;
local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;
my %args = @_;
local $::sym = $args{sym} // q(~);


my $C = $self->cursor_xact("RULE prefix__S_288Tilde");
my $xact = $C->xact;
my $S = $C->{'_pos'};
$C->{'sym'} = ref $sym ? join(' ', @$sym) : $sym;

$self->_MATCHIFYr($S, "prefix__S_288Tilde", 
do {
if (my ($C) = ($C->_PATTERN(qr/\G\~/))) {
$C->_SUBSUMEr(['O'], sub {
my $C = shift;
$C->O(%symbolic_unary)
});
}
else {
();
}
}
);
}

##     token prefix__S_289QuestionQuestion (:$*sym = <??>)
##          token prefix:sym<??>
##              { <sym> <.badinfix> <O(|%symbolic_unary)> }

sub prefix__S_289QuestionQuestion__PEEK { $_[0]->_AUTOLEXpeek('prefix__S_289QuestionQuestion',$retree) }
sub prefix__S_289QuestionQuestion {
no warnings 'recursion';
my $self = shift;
local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;
my %args = @_;
local $::sym = $args{sym} // q(??);


my $C = $self->cursor_xact("RULE prefix__S_289QuestionQuestion");
my $xact = $C->xact;
my $S = $C->{'_pos'};
$C->{'sym'} = ref $sym ? join(' ', @$sym) : $sym;

$self->_MATCHIFYr($S, "prefix__S_289QuestionQuestion", 
do {
if (my ($C) = ($C->_PATTERN(qr/\G\?\?/))) {
do {
if (my ($C) = ($C->badinfix)) {
$C->_SUBSUMEr(['O'], sub {
my $C = shift;
$C->O(%symbolic_unary)
});
}
else {
();
}
};
}
else {
();
}
}
);
}

##     token prefix__S_290Question (:$*sym = <?>)
##          token prefix:sym<?>
##              { <sym> <O(|%symbolic_unary)> }

sub prefix__S_290Question__PEEK { $_[0]->_AUTOLEXpeek('prefix__S_290Question',$retree) }
sub prefix__S_290Question {
no warnings 'recursion';
my $self = shift;
local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;
my %args = @_;
local $::sym = $args{sym} // q(?);


my $C = $self->cursor_xact("RULE prefix__S_290Question");
my $xact = $C->xact;
my $S = $C->{'_pos'};
$C->{'sym'} = ref $sym ? join(' ', @$sym) : $sym;

$self->_MATCHIFYr($S, "prefix__S_290Question", 
do {
if (my ($C) = ($C->_PATTERN(qr/\G\?/))) {
$C->_SUBSUMEr(['O'], sub {
my $C = shift;
$C->O(%symbolic_unary)
});
}
else {
();
}
}
);
}

##     token prefix__S_291TildeCaret (:$*sym = <~^>)
##          token prefix:sym<~^>
##              { <sym> <O(|%symbolic_unary)> }

sub prefix__S_291TildeCaret__PEEK { $_[0]->_AUTOLEXpeek('prefix__S_291TildeCaret',$retree) }
sub prefix__S_291TildeCaret {
no warnings 'recursion';
my $self = shift;
local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;
my %args = @_;
local $::sym = $args{sym} // q(~^);


my $C = $self->cursor_xact("RULE prefix__S_291TildeCaret");
my $xact = $C->xact;
my $S = $C->{'_pos'};
$C->{'sym'} = ref $sym ? join(' ', @$sym) : $sym;

$self->_MATCHIFYr($S, "prefix__S_291TildeCaret", 
do {
if (my ($C) = ($C->_PATTERN(qr/\G\~\^/))) {
$C->_SUBSUMEr(['O'], sub {
my $C = shift;
$C->O(%symbolic_unary)
});
}
else {
();
}
}
);
}

##     token prefix__S_292PlusCaret (:$*sym = <+^>)
##          token prefix:sym<+^>
##              { <sym> <O(|%symbolic_unary)> }

sub prefix__S_292PlusCaret__PEEK { $_[0]->_AUTOLEXpeek('prefix__S_292PlusCaret',$retree) }
sub prefix__S_292PlusCaret {
no warnings 'recursion';
my $self = shift;
local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;
my %args = @_;
local $::sym = $args{sym} // q(+^);


my $C = $self->cursor_xact("RULE prefix__S_292PlusCaret");
my $xact = $C->xact;
my $S = $C->{'_pos'};
$C->{'sym'} = ref $sym ? join(' ', @$sym) : $sym;

$self->_MATCHIFYr($S, "prefix__S_292PlusCaret", 
do {
if (my ($C) = ($C->_PATTERN(qr/\G\+\^/))) {
$C->_SUBSUMEr(['O'], sub {
my $C = shift;
$C->O(%symbolic_unary)
});
}
else {
();
}
}
);
}

##     token prefix__S_293QuestionCaret (:$*sym = <?^>)
##          token prefix:sym<?^>
##              { <sym> <O(|%symbolic_unary)> }

sub prefix__S_293QuestionCaret__PEEK { $_[0]->_AUTOLEXpeek('prefix__S_293QuestionCaret',$retree) }
sub prefix__S_293QuestionCaret {
no warnings 'recursion';
my $self = shift;
local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;
my %args = @_;
local $::sym = $args{sym} // q(?^);


my $C = $self->cursor_xact("RULE prefix__S_293QuestionCaret");
my $xact = $C->xact;
my $S = $C->{'_pos'};
$C->{'sym'} = ref $sym ? join(' ', @$sym) : $sym;

$self->_MATCHIFYr($S, "prefix__S_293QuestionCaret", 
do {
if (my ($C) = ($C->_PATTERN(qr/\G\?\^/))) {
$C->_SUBSUMEr(['O'], sub {
my $C = shift;
$C->O(%symbolic_unary)
});
}
else {
();
}
}
);
}

##     token prefix__S_294CaretCaret (:$*sym = <^^>)
##          token prefix:sym<^^>
##              { <sym> <.badinfix> <O(|%symbolic_unary)> }

sub prefix__S_294CaretCaret__PEEK { $_[0]->_AUTOLEXpeek('prefix__S_294CaretCaret',$retree) }
sub prefix__S_294CaretCaret {
no warnings 'recursion';
my $self = shift;
local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;
my %args = @_;
local $::sym = $args{sym} // q(^^);


my $C = $self->cursor_xact("RULE prefix__S_294CaretCaret");
my $xact = $C->xact;
my $S = $C->{'_pos'};
$C->{'sym'} = ref $sym ? join(' ', @$sym) : $sym;

$self->_MATCHIFYr($S, "prefix__S_294CaretCaret", 
do {
if (my ($C) = ($C->_PATTERN(qr/\G\^\^/))) {
do {
if (my ($C) = ($C->badinfix)) {
$C->_SUBSUMEr(['O'], sub {
my $C = shift;
$C->O(%symbolic_unary)
});
}
else {
();
}
};
}
else {
();
}
}
);
}

##     token prefix__S_295Caret (:$*sym = <^>)
##          token prefix:sym<^>
##              { <sym> <O(|%symbolic_unary)> }

sub prefix__S_295Caret__PEEK { $_[0]->_AUTOLEXpeek('prefix__S_295Caret',$retree) }
sub prefix__S_295Caret {
no warnings 'recursion';
my $self = shift;
local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;
my %args = @_;
local $::sym = $args{sym} // q(^);


my $C = $self->cursor_xact("RULE prefix__S_295Caret");
my $xact = $C->xact;
my $S = $C->{'_pos'};
$C->{'sym'} = ref $sym ? join(' ', @$sym) : $sym;

$self->_MATCHIFYr($S, "prefix__S_295Caret", 
do {
if (my ($C) = ($C->_PATTERN(qr/\G\^/))) {
$C->_SUBSUMEr(['O'], sub {
my $C = shift;
$C->O(%symbolic_unary)
});
}
else {
();
}
}
);
}

##     token prefix__S_296VertVert (:$*sym = <||>)
##          token prefix:sym<||>
##              { <sym> <O(|%symbolic_unary)> }

sub prefix__S_296VertVert__PEEK { $_[0]->_AUTOLEXpeek('prefix__S_296VertVert',$retree) }
sub prefix__S_296VertVert {
no warnings 'recursion';
my $self = shift;
local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;
my %args = @_;
local $::sym = $args{sym} // q(||);


my $C = $self->cursor_xact("RULE prefix__S_296VertVert");
my $xact = $C->xact;
my $S = $C->{'_pos'};
$C->{'sym'} = ref $sym ? join(' ', @$sym) : $sym;

$self->_MATCHIFYr($S, "prefix__S_296VertVert", 
do {
if (my ($C) = ($C->_PATTERN(qr/\G\|\|/))) {
$C->_SUBSUMEr(['O'], sub {
my $C = shift;
$C->O(%symbolic_unary)
});
}
else {
();
}
}
);
}

##     token prefix__S_297Vert (:$*sym = <|>)
##          token prefix:sym<|>
##              { <sym> <O(|%symbolic_unary)> }

sub prefix__S_297Vert__PEEK { $_[0]->_AUTOLEXpeek('prefix__S_297Vert',$retree) }
sub prefix__S_297Vert {
no warnings 'recursion';
my $self = shift;
local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;
my %args = @_;
local $::sym = $args{sym} // q(|);


my $C = $self->cursor_xact("RULE prefix__S_297Vert");
my $xact = $C->xact;
my $S = $C->{'_pos'};
$C->{'sym'} = ref $sym ? join(' ', @$sym) : $sym;

$self->_MATCHIFYr($S, "prefix__S_297Vert", 
do {
if (my ($C) = ($C->_PATTERN(qr/\G\|/))) {
$C->_SUBSUMEr(['O'], sub {
my $C = shift;
$C->O(%symbolic_unary)
});
}
else {
();
}
}
);
}


## multiplicative
##     token infix__S_298Star (:$*sym = <*>)
##          token infix:sym<*>
##              { <sym> <O(|%multiplicative)> }

sub infix__S_298Star__PEEK { $_[0]->_AUTOLEXpeek('infix__S_298Star',$retree) }
sub infix__S_298Star {
no warnings 'recursion';
my $self = shift;
local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;
my %args = @_;
local $::sym = $args{sym} // q(*);


my $C = $self->cursor_xact("RULE infix__S_298Star");
my $xact = $C->xact;
my $S = $C->{'_pos'};
$C->{'sym'} = ref $sym ? join(' ', @$sym) : $sym;

$self->_MATCHIFYr($S, "infix__S_298Star", 
do {
if (my ($C) = ($C->_PATTERN(qr/\G\*/))) {
$C->_SUBSUMEr(['O'], sub {
my $C = shift;
$C->O(%multiplicative)
});
}
else {
();
}
}
);
}

##     token infix__S_299Slash (:$*sym = </>)
##          token infix:sym</>
##              { <sym> <O(|%multiplicative)> }

sub infix__S_299Slash__PEEK { $_[0]->_AUTOLEXpeek('infix__S_299Slash',$retree) }
sub infix__S_299Slash {
no warnings 'recursion';
my $self = shift;
local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;
my %args = @_;
local $::sym = $args{sym} // q(/);


my $C = $self->cursor_xact("RULE infix__S_299Slash");
my $xact = $C->xact;
my $S = $C->{'_pos'};
$C->{'sym'} = ref $sym ? join(' ', @$sym) : $sym;

$self->_MATCHIFYr($S, "infix__S_299Slash", 
do {
if (my ($C) = ($C->_PATTERN(qr/\G\//))) {
$C->_SUBSUMEr(['O'], sub {
my $C = shift;
$C->O(%multiplicative)
});
}
else {
();
}
}
);
}

##     token infix__S_300div (:$*sym = <div>)
##          token infix:sym<div>
##              { <sym> <O(|%multiplicative)> }

sub infix__S_300div__PEEK { $_[0]->_AUTOLEXpeek('infix__S_300div',$retree) }
sub infix__S_300div {
no warnings 'recursion';
my $self = shift;
local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;
my %args = @_;
local $::sym = $args{sym} // q(div);


my $C = $self->cursor_xact("RULE infix__S_300div");
my $xact = $C->xact;
my $S = $C->{'_pos'};
$C->{'sym'} = ref $sym ? join(' ', @$sym) : $sym;

$self->_MATCHIFYr($S, "infix__S_300div", 
do {
if (my ($C) = ($C->_PATTERN(qr/\Gdiv/))) {
$C->_SUBSUMEr(['O'], sub {
my $C = shift;
$C->O(%multiplicative)
});
}
else {
();
}
}
);
}

##     token infix__S_301Percent (:$*sym = <%>)
##          token infix:sym<%>
##              { <sym> <O(|%multiplicative, iffy => 1)> }

sub infix__S_301Percent__PEEK { $_[0]->_AUTOLEXpeek('infix__S_301Percent',$retree) }
sub infix__S_301Percent {
no warnings 'recursion';
my $self = shift;
local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;
my %args = @_;
local $::sym = $args{sym} // q(%);


my $C = $self->cursor_xact("RULE infix__S_301Percent");
my $xact = $C->xact;
my $S = $C->{'_pos'};
$C->{'sym'} = ref $sym ? join(' ', @$sym) : $sym;

$self->_MATCHIFYr($S, "infix__S_301Percent", 
do {
if (my ($C) = ($C->_PATTERN(qr/\G\%/))) {
$C->_SUBSUMEr(['O'], sub {
my $C = shift;
$C->O(%multiplicative, iffy => 1)
});
}
else {
();
}
}
);
}   # Allow !% operator

##     token infix__S_302mod (:$*sym = <mod>)
##          token infix:sym<mod>
##              { <sym> <O(|%multiplicative)> }

sub infix__S_302mod__PEEK { $_[0]->_AUTOLEXpeek('infix__S_302mod',$retree) }
sub infix__S_302mod {
no warnings 'recursion';
my $self = shift;
local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;
my %args = @_;
local $::sym = $args{sym} // q(mod);


my $C = $self->cursor_xact("RULE infix__S_302mod");
my $xact = $C->xact;
my $S = $C->{'_pos'};
$C->{'sym'} = ref $sym ? join(' ', @$sym) : $sym;

$self->_MATCHIFYr($S, "infix__S_302mod", 
do {
if (my ($C) = ($C->_PATTERN(qr/\Gmod/))) {
$C->_SUBSUMEr(['O'], sub {
my $C = shift;
$C->O(%multiplicative)
});
}
else {
();
}
}
);
}

##     token infix__S_303PlusAmp (:$*sym = <+&>)
##          token infix:sym<+&>
##              { <sym> <O(|%multiplicative)> }

sub infix__S_303PlusAmp__PEEK { $_[0]->_AUTOLEXpeek('infix__S_303PlusAmp',$retree) }
sub infix__S_303PlusAmp {
no warnings 'recursion';
my $self = shift;
local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;
my %args = @_;
local $::sym = $args{sym} // q(+&);


my $C = $self->cursor_xact("RULE infix__S_303PlusAmp");
my $xact = $C->xact;
my $S = $C->{'_pos'};
$C->{'sym'} = ref $sym ? join(' ', @$sym) : $sym;

$self->_MATCHIFYr($S, "infix__S_303PlusAmp", 
do {
if (my ($C) = ($C->_PATTERN(qr/\G\+\&/))) {
$C->_SUBSUMEr(['O'], sub {
my $C = shift;
$C->O(%multiplicative)
});
}
else {
();
}
}
);
}

##     token infix__S_304PlusLt (:$*sym =  +< )
##          token infix:sym +< 
##              { <sym> <!before '<'> <O(|%multiplicative)> }

sub infix__S_304PlusLt__PEEK { $_[0]->_AUTOLEXpeek('infix__S_304PlusLt',$retree) }
sub infix__S_304PlusLt {
no warnings 'recursion';
my $self = shift;
local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;
my %args = @_;
local $::sym = $args{sym} //['+<'];


my $C = $self->cursor_xact("RULE infix__S_304PlusLt");
my $xact = $C->xact;
my $S = $C->{'_pos'};
$C->{'sym'} = ref $sym ? join(' ', @$sym) : $sym;

$self->_MATCHIFYr($S, "infix__S_304PlusLt", 
do {
if (my ($C) = ($C->_PATTERN(qr/\G\+\</))) {
do {
if (my ($C) = ($C->_NOTBEFORE( sub { my $C=shift;
$C->before(sub { my $C=shift;
$C->_EXACT('<')
})
}))) {
$C->_SUBSUMEr(['O'], sub {
my $C = shift;
$C->O(%multiplicative)
});
}
else {
();
}
};
}
else {
();
}
}
);
}

##     token infix__S_305LtLt (:$*sym =  << )
##          token infix:sym << 
##              { <sym> \s <.obs('<< to do left shift', '+< or ~<')> <O(|%multiplicative)> }

sub infix__S_305LtLt__PEEK { $_[0]->_AUTOLEXpeek('infix__S_305LtLt',$retree) }
sub infix__S_305LtLt {
no warnings 'recursion';
my $self = shift;
local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;
my %args = @_;
local $::sym = $args{sym} //['<<'];


my $C = $self->cursor_xact("RULE infix__S_305LtLt");
my $xact = $C->xact;
my $S = $C->{'_pos'};
$C->{'sym'} = ref $sym ? join(' ', @$sym) : $sym;

$self->_MATCHIFYr($S, "infix__S_305LtLt", 
do {
if (my ($C) = ($C->_PATTERN(qr/\G\<\</))) {
do {
if (my ($C) = ($C->_PATTERN(qr/\G\s/))) {
do {
if (my ($C) = ($C->obs('<< to do left shift', '+< or ~<'))) {
$C->_SUBSUMEr(['O'], sub {
my $C = shift;
$C->O(%multiplicative)
});
}
else {
();
}
};
}
else {
();
}
};
}
else {
();
}
}
);
}

##     token infix__S_306GtGt (:$*sym =  >> )
##          token infix:sym >> 
##              { <sym> \s <.obs('>> to do right shift', '+> or ~>')> <O(|%multiplicative)> }

sub infix__S_306GtGt__PEEK { $_[0]->_AUTOLEXpeek('infix__S_306GtGt',$retree) }
sub infix__S_306GtGt {
no warnings 'recursion';
my $self = shift;
local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;
my %args = @_;
local $::sym = $args{sym} //['>>'];


my $C = $self->cursor_xact("RULE infix__S_306GtGt");
my $xact = $C->xact;
my $S = $C->{'_pos'};
$C->{'sym'} = ref $sym ? join(' ', @$sym) : $sym;

$self->_MATCHIFYr($S, "infix__S_306GtGt", 
do {
if (my ($C) = ($C->_PATTERN(qr/\G\>\>/))) {
do {
if (my ($C) = ($C->_PATTERN(qr/\G\s/))) {
do {
if (my ($C) = ($C->obs('>> to do right shift', '+> or ~>'))) {
$C->_SUBSUMEr(['O'], sub {
my $C = shift;
$C->O(%multiplicative)
});
}
else {
();
}
};
}
else {
();
}
};
}
else {
();
}
}
);
}

##     token infix__S_307PlusGt (:$*sym =  +> )
##          token infix:sym +> 
##              { <sym> <!before '>'> <O(|%multiplicative)> }

sub infix__S_307PlusGt__PEEK { $_[0]->_AUTOLEXpeek('infix__S_307PlusGt',$retree) }
sub infix__S_307PlusGt {
no warnings 'recursion';
my $self = shift;
local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;
my %args = @_;
local $::sym = $args{sym} //['+>'];


my $C = $self->cursor_xact("RULE infix__S_307PlusGt");
my $xact = $C->xact;
my $S = $C->{'_pos'};
$C->{'sym'} = ref $sym ? join(' ', @$sym) : $sym;

$self->_MATCHIFYr($S, "infix__S_307PlusGt", 
do {
if (my ($C) = ($C->_PATTERN(qr/\G\+\>/))) {
do {
if (my ($C) = ($C->_NOTBEFORE( sub { my $C=shift;
$C->before(sub { my $C=shift;
$C->_EXACT('>')
})
}))) {
$C->_SUBSUMEr(['O'], sub {
my $C = shift;
$C->O(%multiplicative)
});
}
else {
();
}
};
}
else {
();
}
}
);
}

##     token infix__S_308TildeAmp (:$*sym = <~&>)
##          token infix:sym<~&>
##              { <sym> <O(|%multiplicative)> }

sub infix__S_308TildeAmp__PEEK { $_[0]->_AUTOLEXpeek('infix__S_308TildeAmp',$retree) }
sub infix__S_308TildeAmp {
no warnings 'recursion';
my $self = shift;
local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;
my %args = @_;
local $::sym = $args{sym} // q(~&);


my $C = $self->cursor_xact("RULE infix__S_308TildeAmp");
my $xact = $C->xact;
my $S = $C->{'_pos'};
$C->{'sym'} = ref $sym ? join(' ', @$sym) : $sym;

$self->_MATCHIFYr($S, "infix__S_308TildeAmp", 
do {
if (my ($C) = ($C->_PATTERN(qr/\G\~\&/))) {
$C->_SUBSUMEr(['O'], sub {
my $C = shift;
$C->O(%multiplicative)
});
}
else {
();
}
}
);
}

##     token infix__S_309QuestionAmp (:$*sym = <?&>)
##          token infix:sym<?&>
##              { <sym> <O(|%multiplicative, iffy => 1)> }

sub infix__S_309QuestionAmp__PEEK { $_[0]->_AUTOLEXpeek('infix__S_309QuestionAmp',$retree) }
sub infix__S_309QuestionAmp {
no warnings 'recursion';
my $self = shift;
local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;
my %args = @_;
local $::sym = $args{sym} // q(?&);


my $C = $self->cursor_xact("RULE infix__S_309QuestionAmp");
my $xact = $C->xact;
my $S = $C->{'_pos'};
$C->{'sym'} = ref $sym ? join(' ', @$sym) : $sym;

$self->_MATCHIFYr($S, "infix__S_309QuestionAmp", 
do {
if (my ($C) = ($C->_PATTERN(qr/\G\?\&/))) {
$C->_SUBSUMEr(['O'], sub {
my $C = shift;
$C->O(%multiplicative, iffy => 1)
});
}
else {
();
}
}
);
}

##     token infix__S_310TildeLt (:$*sym =  ~< )
##          token infix:sym ~< 
##              { <sym> <!before '<'> <O(|%multiplicative)> }

sub infix__S_310TildeLt__PEEK { $_[0]->_AUTOLEXpeek('infix__S_310TildeLt',$retree) }
sub infix__S_310TildeLt {
no warnings 'recursion';
my $self = shift;
local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;
my %args = @_;
local $::sym = $args{sym} //['~<'];


my $C = $self->cursor_xact("RULE infix__S_310TildeLt");
my $xact = $C->xact;
my $S = $C->{'_pos'};
$C->{'sym'} = ref $sym ? join(' ', @$sym) : $sym;

$self->_MATCHIFYr($S, "infix__S_310TildeLt", 
do {
if (my ($C) = ($C->_PATTERN(qr/\G\~\</))) {
do {
if (my ($C) = ($C->_NOTBEFORE( sub { my $C=shift;
$C->before(sub { my $C=shift;
$C->_EXACT('<')
})
}))) {
$C->_SUBSUMEr(['O'], sub {
my $C = shift;
$C->O(%multiplicative)
});
}
else {
();
}
};
}
else {
();
}
}
);
}

##     token infix__S_311TildeGt (:$*sym =  ~> )
##          token infix:sym ~> 
##              { <sym> <!before '>'> <O(|%multiplicative)> }

sub infix__S_311TildeGt__PEEK { $_[0]->_AUTOLEXpeek('infix__S_311TildeGt',$retree) }
sub infix__S_311TildeGt {
no warnings 'recursion';
my $self = shift;
local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;
my %args = @_;
local $::sym = $args{sym} //['~>'];


my $C = $self->cursor_xact("RULE infix__S_311TildeGt");
my $xact = $C->xact;
my $S = $C->{'_pos'};
$C->{'sym'} = ref $sym ? join(' ', @$sym) : $sym;

$self->_MATCHIFYr($S, "infix__S_311TildeGt", 
do {
if (my ($C) = ($C->_PATTERN(qr/\G\~\>/))) {
do {
if (my ($C) = ($C->_NOTBEFORE( sub { my $C=shift;
$C->before(sub { my $C=shift;
$C->_EXACT('>')
})
}))) {
$C->_SUBSUMEr(['O'], sub {
my $C = shift;
$C->O(%multiplicative)
});
}
else {
();
}
};
}
else {
();
}
}
);
}


## additive
##     token infix__S_312Plus (:$*sym = <+>)
##          token infix:sym<+>
##              { <sym> <!before '+'> <O(|%additive)> }

sub infix__S_312Plus__PEEK { $_[0]->_AUTOLEXpeek('infix__S_312Plus',$retree) }
sub infix__S_312Plus {
no warnings 'recursion';
my $self = shift;
local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;
my %args = @_;
local $::sym = $args{sym} // q(+);


my $C = $self->cursor_xact("RULE infix__S_312Plus");
my $xact = $C->xact;
my $S = $C->{'_pos'};
$C->{'sym'} = ref $sym ? join(' ', @$sym) : $sym;

$self->_MATCHIFYr($S, "infix__S_312Plus", 
do {
if (my ($C) = ($C->_PATTERN(qr/\G\+/))) {
do {
if (my ($C) = ($C->_NOTBEFORE( sub { my $C=shift;
$C->before(sub { my $C=shift;
$C->_EXACT('+')
})
}))) {
$C->_SUBSUMEr(['O'], sub {
my $C = shift;
$C->O(%additive)
});
}
else {
();
}
};
}
else {
();
}
}
);
}

##     token infix__S_313Minus (:$*sym = <->)
##          token infix:sym<->
##              { <sym> <!before '-'> <O(|%additive)> }

sub infix__S_313Minus__PEEK { $_[0]->_AUTOLEXpeek('infix__S_313Minus',$retree) }
sub infix__S_313Minus {
no warnings 'recursion';
my $self = shift;
local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;
my %args = @_;
local $::sym = $args{sym} // q(-);


my $C = $self->cursor_xact("RULE infix__S_313Minus");
my $xact = $C->xact;
my $S = $C->{'_pos'};
$C->{'sym'} = ref $sym ? join(' ', @$sym) : $sym;

$self->_MATCHIFYr($S, "infix__S_313Minus", 
do {
if (my ($C) = ($C->_PATTERN(qr/\G\-/))) {
do {
if (my ($C) = ($C->_NOTBEFORE( sub { my $C=shift;
$C->before(sub { my $C=shift;
$C->_EXACT('-')
})
}))) {
$C->_SUBSUMEr(['O'], sub {
my $C = shift;
$C->O(%additive)
});
}
else {
();
}
};
}
else {
();
}
}
);
}

##     token infix__S_314PlusVert (:$*sym = <+|>)
##          token infix:sym<+|>
##              { <sym> <O(|%additive)> }

sub infix__S_314PlusVert__PEEK { $_[0]->_AUTOLEXpeek('infix__S_314PlusVert',$retree) }
sub infix__S_314PlusVert {
no warnings 'recursion';
my $self = shift;
local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;
my %args = @_;
local $::sym = $args{sym} // q(+|);


my $C = $self->cursor_xact("RULE infix__S_314PlusVert");
my $xact = $C->xact;
my $S = $C->{'_pos'};
$C->{'sym'} = ref $sym ? join(' ', @$sym) : $sym;

$self->_MATCHIFYr($S, "infix__S_314PlusVert", 
do {
if (my ($C) = ($C->_PATTERN(qr/\G\+\|/))) {
$C->_SUBSUMEr(['O'], sub {
my $C = shift;
$C->O(%additive)
});
}
else {
();
}
}
);
}

##     token infix__S_315PlusCaret (:$*sym = <+^>)
##          token infix:sym<+^>
##              { <sym> <O(|%additive)> }

sub infix__S_315PlusCaret__PEEK { $_[0]->_AUTOLEXpeek('infix__S_315PlusCaret',$retree) }
sub infix__S_315PlusCaret {
no warnings 'recursion';
my $self = shift;
local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;
my %args = @_;
local $::sym = $args{sym} // q(+^);


my $C = $self->cursor_xact("RULE infix__S_315PlusCaret");
my $xact = $C->xact;
my $S = $C->{'_pos'};
$C->{'sym'} = ref $sym ? join(' ', @$sym) : $sym;

$self->_MATCHIFYr($S, "infix__S_315PlusCaret", 
do {
if (my ($C) = ($C->_PATTERN(qr/\G\+\^/))) {
$C->_SUBSUMEr(['O'], sub {
my $C = shift;
$C->O(%additive)
});
}
else {
();
}
}
);
}

##     token infix__S_316TildeVert (:$*sym = <~|>)
##          token infix:sym<~|>
##              { <sym> <O(|%additive)> }

sub infix__S_316TildeVert__PEEK { $_[0]->_AUTOLEXpeek('infix__S_316TildeVert',$retree) }
sub infix__S_316TildeVert {
no warnings 'recursion';
my $self = shift;
local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;
my %args = @_;
local $::sym = $args{sym} // q(~|);


my $C = $self->cursor_xact("RULE infix__S_316TildeVert");
my $xact = $C->xact;
my $S = $C->{'_pos'};
$C->{'sym'} = ref $sym ? join(' ', @$sym) : $sym;

$self->_MATCHIFYr($S, "infix__S_316TildeVert", 
do {
if (my ($C) = ($C->_PATTERN(qr/\G\~\|/))) {
$C->_SUBSUMEr(['O'], sub {
my $C = shift;
$C->O(%additive)
});
}
else {
();
}
}
);
}

##     token infix__S_317TildeCaret (:$*sym = <~^>)
##          token infix:sym<~^>
##              { <sym> <O(|%additive)> }

sub infix__S_317TildeCaret__PEEK { $_[0]->_AUTOLEXpeek('infix__S_317TildeCaret',$retree) }
sub infix__S_317TildeCaret {
no warnings 'recursion';
my $self = shift;
local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;
my %args = @_;
local $::sym = $args{sym} // q(~^);


my $C = $self->cursor_xact("RULE infix__S_317TildeCaret");
my $xact = $C->xact;
my $S = $C->{'_pos'};
$C->{'sym'} = ref $sym ? join(' ', @$sym) : $sym;

$self->_MATCHIFYr($S, "infix__S_317TildeCaret", 
do {
if (my ($C) = ($C->_PATTERN(qr/\G\~\^/))) {
$C->_SUBSUMEr(['O'], sub {
my $C = shift;
$C->O(%additive)
});
}
else {
();
}
}
);
}

##     token infix__S_318QuestionVert (:$*sym = <?|>)
##          token infix:sym<?|>
##              { <sym> <O(|%additive, iffy => 1)> }

sub infix__S_318QuestionVert__PEEK { $_[0]->_AUTOLEXpeek('infix__S_318QuestionVert',$retree) }
sub infix__S_318QuestionVert {
no warnings 'recursion';
my $self = shift;
local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;
my %args = @_;
local $::sym = $args{sym} // q(?|);


my $C = $self->cursor_xact("RULE infix__S_318QuestionVert");
my $xact = $C->xact;
my $S = $C->{'_pos'};
$C->{'sym'} = ref $sym ? join(' ', @$sym) : $sym;

$self->_MATCHIFYr($S, "infix__S_318QuestionVert", 
do {
if (my ($C) = ($C->_PATTERN(qr/\G\?\|/))) {
$C->_SUBSUMEr(['O'], sub {
my $C = shift;
$C->O(%additive, iffy => 1)
});
}
else {
();
}
}
);
}

##     token infix__S_319QuestionCaret (:$*sym = <?^>)
##          token infix:sym<?^>
##              { <sym> <O(|%additive)> }

sub infix__S_319QuestionCaret__PEEK { $_[0]->_AUTOLEXpeek('infix__S_319QuestionCaret',$retree) }
sub infix__S_319QuestionCaret {
no warnings 'recursion';
my $self = shift;
local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;
my %args = @_;
local $::sym = $args{sym} // q(?^);


my $C = $self->cursor_xact("RULE infix__S_319QuestionCaret");
my $xact = $C->xact;
my $S = $C->{'_pos'};
$C->{'sym'} = ref $sym ? join(' ', @$sym) : $sym;

$self->_MATCHIFYr($S, "infix__S_319QuestionCaret", 
do {
if (my ($C) = ($C->_PATTERN(qr/\G\?\^/))) {
$C->_SUBSUMEr(['O'], sub {
my $C = shift;
$C->O(%additive)
});
}
else {
();
}
}
);
}

## replication
# Note: no word boundary check after x, relies on longest token for x2 xx2 etc
##     token infix__S_320x (:$*sym = <x>)
##          token infix:sym<x>
##              { <sym> <O(|%replication)> }

sub infix__S_320x__PEEK { $_[0]->_AUTOLEXpeek('infix__S_320x',$retree) }
sub infix__S_320x {
no warnings 'recursion';
my $self = shift;
local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;
my %args = @_;
local $::sym = $args{sym} // q(x);


my $C = $self->cursor_xact("RULE infix__S_320x");
my $xact = $C->xact;
my $S = $C->{'_pos'};
$C->{'sym'} = ref $sym ? join(' ', @$sym) : $sym;

$self->_MATCHIFYr($S, "infix__S_320x", 
do {
if (my ($C) = ($C->_PATTERN(qr/\Gx/))) {
$C->_SUBSUMEr(['O'], sub {
my $C = shift;
$C->O(%replication)
});
}
else {
();
}
}
);
}

##     token infix__S_321xx (:$*sym = <xx>)
##          token infix:sym<xx>
##              { <sym> <O(|%replication)> }

sub infix__S_321xx__PEEK { $_[0]->_AUTOLEXpeek('infix__S_321xx',$retree) }
sub infix__S_321xx {
no warnings 'recursion';
my $self = shift;
local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;
my %args = @_;
local $::sym = $args{sym} // q(xx);


my $C = $self->cursor_xact("RULE infix__S_321xx");
my $xact = $C->xact;
my $S = $C->{'_pos'};
$C->{'sym'} = ref $sym ? join(' ', @$sym) : $sym;

$self->_MATCHIFYr($S, "infix__S_321xx", 
do {
if (my ($C) = ($C->_PATTERN(qr/\Gxx/))) {
$C->_SUBSUMEr(['O'], sub {
my $C = shift;
$C->O(%replication)
});
}
else {
();
}
}
);
}

## concatenation
##     token infix__S_322Tilde (:$*sym = <~>)
##          token infix:sym<~>
##              { <sym> <O(|%concatenation)> }

sub infix__S_322Tilde__PEEK { $_[0]->_AUTOLEXpeek('infix__S_322Tilde',$retree) }
sub infix__S_322Tilde {
no warnings 'recursion';
my $self = shift;
local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;
my %args = @_;
local $::sym = $args{sym} // q(~);


my $C = $self->cursor_xact("RULE infix__S_322Tilde");
my $xact = $C->xact;
my $S = $C->{'_pos'};
$C->{'sym'} = ref $sym ? join(' ', @$sym) : $sym;

$self->_MATCHIFYr($S, "infix__S_322Tilde", 
do {
if (my ($C) = ($C->_PATTERN(qr/\G\~/))) {
$C->_SUBSUMEr(['O'], sub {
my $C = shift;
$C->O(%concatenation)
});
}
else {
();
}
}
);
}


## junctive and (all)
##     token infix__S_323Amp (:$*sym = <&>)
##          token infix:sym<&>
##              { <sym> <O(|%junctive_and, iffy => 1)> }

sub infix__S_323Amp__PEEK { $_[0]->_AUTOLEXpeek('infix__S_323Amp',$retree) }
sub infix__S_323Amp {
no warnings 'recursion';
my $self = shift;
local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;
my %args = @_;
local $::sym = $args{sym} // q(&);


my $C = $self->cursor_xact("RULE infix__S_323Amp");
my $xact = $C->xact;
my $S = $C->{'_pos'};
$C->{'sym'} = ref $sym ? join(' ', @$sym) : $sym;

$self->_MATCHIFYr($S, "infix__S_323Amp", 
do {
if (my ($C) = ($C->_PATTERN(qr/\G\&/))) {
$C->_SUBSUMEr(['O'], sub {
my $C = shift;
$C->O(%junctive_and, iffy => 1)
});
}
else {
();
}
}
);
}


## junctive or (any)
##     token infix__S_324Vert (:$*sym = <|>)
##          token infix:sym<|>
##              { <sym> <O(|%junctive_or, iffy => 1)> }

sub infix__S_324Vert__PEEK { $_[0]->_AUTOLEXpeek('infix__S_324Vert',$retree) }
sub infix__S_324Vert {
no warnings 'recursion';
my $self = shift;
local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;
my %args = @_;
local $::sym = $args{sym} // q(|);


my $C = $self->cursor_xact("RULE infix__S_324Vert");
my $xact = $C->xact;
my $S = $C->{'_pos'};
$C->{'sym'} = ref $sym ? join(' ', @$sym) : $sym;

$self->_MATCHIFYr($S, "infix__S_324Vert", 
do {
if (my ($C) = ($C->_PATTERN(qr/\G\|/))) {
$C->_SUBSUMEr(['O'], sub {
my $C = shift;
$C->O(%junctive_or, iffy => 1)
});
}
else {
();
}
}
);
}

##     token infix__S_325Caret (:$*sym = <^>)
##          token infix:sym<^>
##              { <sym> <O(|%junctive_or, iffy => 1)> }

sub infix__S_325Caret__PEEK { $_[0]->_AUTOLEXpeek('infix__S_325Caret',$retree) }
sub infix__S_325Caret {
no warnings 'recursion';
my $self = shift;
local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;
my %args = @_;
local $::sym = $args{sym} // q(^);


my $C = $self->cursor_xact("RULE infix__S_325Caret");
my $xact = $C->xact;
my $S = $C->{'_pos'};
$C->{'sym'} = ref $sym ? join(' ', @$sym) : $sym;

$self->_MATCHIFYr($S, "infix__S_325Caret", 
do {
if (my ($C) = ($C->_PATTERN(qr/\G\^/))) {
$C->_SUBSUMEr(['O'], sub {
my $C = shift;
$C->O(%junctive_or, iffy => 1)
});
}
else {
();
}
}
);
}


## named unary examples
# (need \s* to win LTM battle with listops)
##     token prefix__S_326sleep (:$*sym = 'sleep')
##          token prefix:sleep
##              { <sym>  <?before \s*> <O(|%named_unary)> }

sub prefix__S_326sleep__PEEK { $_[0]->_AUTOLEXpeek('prefix__S_326sleep',$retree) }
sub prefix__S_326sleep {
no warnings 'recursion';
my $self = shift;
local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;
my %args = @_;
local $::sym = $args{sym} // 'sleep';


my $C = $self->cursor_xact("RULE prefix__S_326sleep");
my $xact = $C->xact;
my $S = $C->{'_pos'};
$C->{'sym'} = ref $sym ? join(' ', @$sym) : $sym;

$self->_MATCHIFYr($S, "prefix__S_326sleep", 
do {
if (my ($C) = ($C->_PATTERN(qr/\Gsleep/))) {
do {
if (my ($C) = ($C->_PATTERN(qr/\G\b/))) {
do {
if (my ($C) = ($C->before(sub { my $C=shift;
$C->_PATTERN(qr/\G((?:\s)*+)/)
}))) {
$C->_SUBSUMEr(['O'], sub {
my $C = shift;
$C->O(%named_unary)
});
}
else {
();
}
};
}
else {
();
}
};
}
else {
();
}
}
);
}

##     token prefix__S_327abs (:$*sym = 'abs')
##          token prefix:abs
##              { <sym>  <?before \s*> <O(|%named_unary)> }

sub prefix__S_327abs__PEEK { $_[0]->_AUTOLEXpeek('prefix__S_327abs',$retree) }
sub prefix__S_327abs {
no warnings 'recursion';
my $self = shift;
local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;
my %args = @_;
local $::sym = $args{sym} // 'abs';


my $C = $self->cursor_xact("RULE prefix__S_327abs");
my $xact = $C->xact;
my $S = $C->{'_pos'};
$C->{'sym'} = ref $sym ? join(' ', @$sym) : $sym;

$self->_MATCHIFYr($S, "prefix__S_327abs", 
do {
if (my ($C) = ($C->_PATTERN(qr/\Gabs/))) {
do {
if (my ($C) = ($C->_PATTERN(qr/\G\b/))) {
do {
if (my ($C) = ($C->before(sub { my $C=shift;
$C->_PATTERN(qr/\G((?:\s)*+)/)
}))) {
$C->_SUBSUMEr(['O'], sub {
my $C = shift;
$C->O(%named_unary)
});
}
else {
();
}
};
}
else {
();
}
};
}
else {
();
}
}
);
}

##     token prefix__S_328let (:$*sym = 'let')
##          token prefix:let
##              { <sym>  <?before \s*> <O(|%named_unary)> }

sub prefix__S_328let__PEEK { $_[0]->_AUTOLEXpeek('prefix__S_328let',$retree) }
sub prefix__S_328let {
no warnings 'recursion';
my $self = shift;
local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;
my %args = @_;
local $::sym = $args{sym} // 'let';


my $C = $self->cursor_xact("RULE prefix__S_328let");
my $xact = $C->xact;
my $S = $C->{'_pos'};
$C->{'sym'} = ref $sym ? join(' ', @$sym) : $sym;

$self->_MATCHIFYr($S, "prefix__S_328let", 
do {
if (my ($C) = ($C->_PATTERN(qr/\Glet/))) {
do {
if (my ($C) = ($C->_PATTERN(qr/\G\b/))) {
do {
if (my ($C) = ($C->before(sub { my $C=shift;
$C->_PATTERN(qr/\G((?:\s)*+)/)
}))) {
$C->_SUBSUMEr(['O'], sub {
my $C = shift;
$C->O(%named_unary)
});
}
else {
();
}
};
}
else {
();
}
};
}
else {
();
}
}
);
}

##     token prefix__S_329temp (:$*sym = 'temp')
##          token prefix:temp
##              { <sym>  <?before \s*> <O(|%named_unary)> }

sub prefix__S_329temp__PEEK { $_[0]->_AUTOLEXpeek('prefix__S_329temp',$retree) }
sub prefix__S_329temp {
no warnings 'recursion';
my $self = shift;
local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;
my %args = @_;
local $::sym = $args{sym} // 'temp';


my $C = $self->cursor_xact("RULE prefix__S_329temp");
my $xact = $C->xact;
my $S = $C->{'_pos'};
$C->{'sym'} = ref $sym ? join(' ', @$sym) : $sym;

$self->_MATCHIFYr($S, "prefix__S_329temp", 
do {
if (my ($C) = ($C->_PATTERN(qr/\Gtemp/))) {
do {
if (my ($C) = ($C->_PATTERN(qr/\G\b/))) {
do {
if (my ($C) = ($C->before(sub { my $C=shift;
$C->_PATTERN(qr/\G((?:\s)*+)/)
}))) {
$C->_SUBSUMEr(['O'], sub {
my $C = shift;
$C->O(%named_unary)
});
}
else {
();
}
};
}
else {
();
}
};
}
else {
();
}
}
);
}


## structural infix
##     token infix__S_330LtEqualGt (:$*sym =  <=> )
##          token infix:sym <=> 
##              { <sym> <O(|%structural, returns => 'Order')> }

sub infix__S_330LtEqualGt__PEEK { $_[0]->_AUTOLEXpeek('infix__S_330LtEqualGt',$retree) }
sub infix__S_330LtEqualGt {
no warnings 'recursion';
my $self = shift;
local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;
my %args = @_;
local $::sym = $args{sym} //['<=>'];


my $C = $self->cursor_xact("RULE infix__S_330LtEqualGt");
my $xact = $C->xact;
my $S = $C->{'_pos'};
$C->{'sym'} = ref $sym ? join(' ', @$sym) : $sym;

$self->_MATCHIFYr($S, "infix__S_330LtEqualGt", 
do {
if (my ($C) = ($C->_PATTERN(qr/\G\<\=\>/))) {
$C->_SUBSUMEr(['O'], sub {
my $C = shift;
$C->O(%structural, returns => 'Order')
});
}
else {
();
}
}
);
}

##     token infix__S_331cmp (:$*sym = 'cmp')
##          token infix:cmp
##              { <sym> <O(|%structural, returns => 'Order')> }

sub infix__S_331cmp__PEEK { $_[0]->_AUTOLEXpeek('infix__S_331cmp',$retree) }
sub infix__S_331cmp {
no warnings 'recursion';
my $self = shift;
local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;
my %args = @_;
local $::sym = $args{sym} // 'cmp';


my $C = $self->cursor_xact("RULE infix__S_331cmp");
my $xact = $C->xact;
my $S = $C->{'_pos'};
$C->{'sym'} = ref $sym ? join(' ', @$sym) : $sym;

$self->_MATCHIFYr($S, "infix__S_331cmp", 
do {
if (my ($C) = ($C->_PATTERN(qr/\Gcmp/))) {
$C->_SUBSUMEr(['O'], sub {
my $C = shift;
$C->O(%structural, returns => 'Order')
});
}
else {
();
}
}
);
}

##     token infix__S_332leg (:$*sym = 'leg')
##          token infix:leg
##              { <sym> <O(|%structural, returns => 'Order')> }

sub infix__S_332leg__PEEK { $_[0]->_AUTOLEXpeek('infix__S_332leg',$retree) }
sub infix__S_332leg {
no warnings 'recursion';
my $self = shift;
local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;
my %args = @_;
local $::sym = $args{sym} // 'leg';


my $C = $self->cursor_xact("RULE infix__S_332leg");
my $xact = $C->xact;
my $S = $C->{'_pos'};
$C->{'sym'} = ref $sym ? join(' ', @$sym) : $sym;

$self->_MATCHIFYr($S, "infix__S_332leg", 
do {
if (my ($C) = ($C->_PATTERN(qr/\Gleg/))) {
$C->_SUBSUMEr(['O'], sub {
my $C = shift;
$C->O(%structural, returns => 'Order')
});
}
else {
();
}
}
);
}

##     token infix__S_333but (:$*sym = 'but')
##          token infix:but
##              { <sym> <O(|%structural)> }

sub infix__S_333but__PEEK { $_[0]->_AUTOLEXpeek('infix__S_333but',$retree) }
sub infix__S_333but {
no warnings 'recursion';
my $self = shift;
local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;
my %args = @_;
local $::sym = $args{sym} // 'but';


my $C = $self->cursor_xact("RULE infix__S_333but");
my $xact = $C->xact;
my $S = $C->{'_pos'};
$C->{'sym'} = ref $sym ? join(' ', @$sym) : $sym;

$self->_MATCHIFYr($S, "infix__S_333but", 
do {
if (my ($C) = ($C->_PATTERN(qr/\Gbut/))) {
$C->_SUBSUMEr(['O'], sub {
my $C = shift;
$C->O(%structural)
});
}
else {
();
}
}
);
}

##     token infix__S_334does (:$*sym = 'does')
##          token infix:does
##              { <sym> <O(|%structural)> }

sub infix__S_334does__PEEK { $_[0]->_AUTOLEXpeek('infix__S_334does',$retree) }
sub infix__S_334does {
no warnings 'recursion';
my $self = shift;
local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;
my %args = @_;
local $::sym = $args{sym} // 'does';


my $C = $self->cursor_xact("RULE infix__S_334does");
my $xact = $C->xact;
my $S = $C->{'_pos'};
$C->{'sym'} = ref $sym ? join(' ', @$sym) : $sym;

$self->_MATCHIFYr($S, "infix__S_334does", 
do {
if (my ($C) = ($C->_PATTERN(qr/\Gdoes/))) {
$C->_SUBSUMEr(['O'], sub {
my $C = shift;
$C->O(%structural)
});
}
else {
();
}
}
);
}

##     token infix__S_335DotDot (:$*sym = <..>)
##          token infix:sym<..>
##              { <sym> [<!{ $*IN_META }> <?before ')' | ']'> <.panic: "Please use ..* for indefinite range">]? <O(|%structural)> }

sub infix__S_335DotDot__PEEK { $_[0]->_AUTOLEXpeek('infix__S_335DotDot',$retree) }
sub infix__S_335DotDot {
no warnings 'recursion';
my $self = shift;
local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;
my %args = @_;
local $::sym = $args{sym} // q(..);


my $C = $self->cursor_xact("RULE infix__S_335DotDot");
my $xact = $C->xact;
my $S = $C->{'_pos'};
$C->{'sym'} = ref $sym ? join(' ', @$sym) : $sym;

$self->_MATCHIFYr($S, "infix__S_335DotDot", 
do {
if (my ($C) = ($C->_PATTERN(qr/\G\.\./))) {
do {
if (my ($C) = ($C->_OPTr(sub { my $C=shift;
$C->_BRACKETr(sub {
my $C=shift;
do {
if (my ($C) = ($C->_NOTBEFORE( sub { my $C=shift;
(($C) x !!do {
$::IN_META 
})
}))) {
do {
if (my ($C) = ($C->before(sub { my $C=shift;
do {
my @result = do {
my $trystate;
my ($tag, $try);
my @try;
my $relex;

my $fate;
my $x;
if ($fate = $C->{'_fate'} and $fate->[1] eq 'infix__S_335DotDot_02') {
$C->deb("Fate passed to infix__S_335DotDot_02: ", ::fatestr($fate)) if $::DEBUG & DEBUG::fates;
($C->{'_fate'}, $tag, $try) = @$fate;
@try = ($try);
$x = 'ALT infix__S_335DotDot_02';    # some outer ltm is controlling us
}
else {
$x = 'ALTLTM infix__S_335DotDot_02'; # we are top level ltm
}
my $C = $C->cursor_xact($x);
my $xact = $C->xact;

my @gather = ();
for (;;) {
if (not @try) {
$relex //= $C->cursor_fate('STD::P6', 'infix__S_335DotDot_02', $retree);
@try = $relex->($C, $trystate);
}
last unless @try;
$try = shift(@try) // next;

if (ref $try eq 'ARRAY') {
($C->{'_fate'}, $tag, $try) = @$try;	# next candidate fate
}

$C->deb("infix__S_335DotDot_02 trying $tag $try") if $::DEBUG & DEBUG::try_processing;
push @gather, ((
sub { my $C=shift;
$C->_EXACT(')')
},
sub { my $C=shift;
$C->_EXACT(']')
},
)[$try])->($C);
last if $xact->[-2];  # committed?
last if @gather;
}
@gather;
};
@result;
}

}))) {
$C->panic("Please use ..* for indefinite range");
}
else {
();
}
};
}
else {
();
}
}
})
}))) {
$C->_SUBSUMEr(['O'], sub {
my $C = shift;
$C->O(%structural)
});
}
else {
();
}
};
}
else {
();
}
}
);
}

##     token infix__S_336CaretDotDot (:$*sym = <^..>)
##          token infix:sym<^..>
##              { <sym> <O(|%structural)> }

sub infix__S_336CaretDotDot__PEEK { $_[0]->_AUTOLEXpeek('infix__S_336CaretDotDot',$retree) }
sub infix__S_336CaretDotDot {
no warnings 'recursion';
my $self = shift;
local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;
my %args = @_;
local $::sym = $args{sym} // q(^..);


my $C = $self->cursor_xact("RULE infix__S_336CaretDotDot");
my $xact = $C->xact;
my $S = $C->{'_pos'};
$C->{'sym'} = ref $sym ? join(' ', @$sym) : $sym;

$self->_MATCHIFYr($S, "infix__S_336CaretDotDot", 
do {
if (my ($C) = ($C->_PATTERN(qr/\G\^\.\./))) {
$C->_SUBSUMEr(['O'], sub {
my $C = shift;
$C->O(%structural)
});
}
else {
();
}
}
);
}

##     token infix__S_337DotDotCaret (:$*sym = <..^>)
##          token infix:sym<..^>
##              { <sym> <O(|%structural)> }

sub infix__S_337DotDotCaret__PEEK { $_[0]->_AUTOLEXpeek('infix__S_337DotDotCaret',$retree) }
sub infix__S_337DotDotCaret {
no warnings 'recursion';
my $self = shift;
local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;
my %args = @_;
local $::sym = $args{sym} // q(..^);


my $C = $self->cursor_xact("RULE infix__S_337DotDotCaret");
my $xact = $C->xact;
my $S = $C->{'_pos'};
$C->{'sym'} = ref $sym ? join(' ', @$sym) : $sym;

$self->_MATCHIFYr($S, "infix__S_337DotDotCaret", 
do {
if (my ($C) = ($C->_PATTERN(qr/\G\.\.\^/))) {
$C->_SUBSUMEr(['O'], sub {
my $C = shift;
$C->O(%structural)
});
}
else {
();
}
}
);
}

##     token infix__S_338CaretDotDotCaret (:$*sym = <^..^>)
##          token infix:sym<^..^>
##              { <sym> <O(|%structural)> }

sub infix__S_338CaretDotDotCaret__PEEK { $_[0]->_AUTOLEXpeek('infix__S_338CaretDotDotCaret',$retree) }
sub infix__S_338CaretDotDotCaret {
no warnings 'recursion';
my $self = shift;
local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;
my %args = @_;
local $::sym = $args{sym} // q(^..^);


my $C = $self->cursor_xact("RULE infix__S_338CaretDotDotCaret");
my $xact = $C->xact;
my $S = $C->{'_pos'};
$C->{'sym'} = ref $sym ? join(' ', @$sym) : $sym;

$self->_MATCHIFYr($S, "infix__S_338CaretDotDotCaret", 
do {
if (my ($C) = ($C->_PATTERN(qr/\G\^\.\.\^/))) {
$C->_SUBSUMEr(['O'], sub {
my $C = shift;
$C->O(%structural)
});
}
else {
();
}
}
);
}


## chaining binary
##     token infix__S_339EqualEqual (:$*sym = <==>)
##          token infix:sym<==>
##              { <sym> <!before '=' > <O(|%chaining)> }

sub infix__S_339EqualEqual__PEEK { $_[0]->_AUTOLEXpeek('infix__S_339EqualEqual',$retree) }
sub infix__S_339EqualEqual {
no warnings 'recursion';
my $self = shift;
local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;
my %args = @_;
local $::sym = $args{sym} // q(==);


my $C = $self->cursor_xact("RULE infix__S_339EqualEqual");
my $xact = $C->xact;
my $S = $C->{'_pos'};
$C->{'sym'} = ref $sym ? join(' ', @$sym) : $sym;

$self->_MATCHIFYr($S, "infix__S_339EqualEqual", 
do {
if (my ($C) = ($C->_PATTERN(qr/\G\=\=/))) {
do {
if (my ($C) = ($C->_NOTBEFORE( sub { my $C=shift;
$C->before(sub { my $C=shift;
$C->_EXACT('=')
})
}))) {
$C->_SUBSUMEr(['O'], sub {
my $C = shift;
$C->O(%chaining)
});
}
else {
();
}
};
}
else {
();
}
}
);
}

##     token infix__S_340BangEqual (:$*sym = <!=>)
##          token infix:sym<!=>
##              { <sym> <?before \s> <O(|%chaining)> }

sub infix__S_340BangEqual__PEEK { $_[0]->_AUTOLEXpeek('infix__S_340BangEqual',$retree) }
sub infix__S_340BangEqual {
no warnings 'recursion';
my $self = shift;
local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;
my %args = @_;
local $::sym = $args{sym} // q(!=);


my $C = $self->cursor_xact("RULE infix__S_340BangEqual");
my $xact = $C->xact;
my $S = $C->{'_pos'};
$C->{'sym'} = ref $sym ? join(' ', @$sym) : $sym;

$self->_MATCHIFYr($S, "infix__S_340BangEqual", 
do {
if (my ($C) = ($C->_PATTERN(qr/\G\!\=/))) {
do {
if (my ($C) = ($C->before(sub { my $C=shift;
$C->_PATTERN(qr/\G\s/)
}))) {
$C->_SUBSUMEr(['O'], sub {
my $C = shift;
$C->O(%chaining)
});
}
else {
();
}
};
}
else {
();
}
}
);
}

##     token infix__S_341Lt (:$*sym =  < )
##          token infix:sym < 
##              { <sym> <O(|%chaining)> }

sub infix__S_341Lt__PEEK { $_[0]->_AUTOLEXpeek('infix__S_341Lt',$retree) }
sub infix__S_341Lt {
no warnings 'recursion';
my $self = shift;
local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;
my %args = @_;
local $::sym = $args{sym} //['<'];


my $C = $self->cursor_xact("RULE infix__S_341Lt");
my $xact = $C->xact;
my $S = $C->{'_pos'};
$C->{'sym'} = ref $sym ? join(' ', @$sym) : $sym;

$self->_MATCHIFYr($S, "infix__S_341Lt", 
do {
if (my ($C) = ($C->_PATTERN(qr/\G\</))) {
$C->_SUBSUMEr(['O'], sub {
my $C = shift;
$C->O(%chaining)
});
}
else {
();
}
}
);
}

##     token infix__S_342LtEqual (:$*sym =  <= )
##          token infix:sym <= 
##              { <sym> <O(|%chaining)> }

sub infix__S_342LtEqual__PEEK { $_[0]->_AUTOLEXpeek('infix__S_342LtEqual',$retree) }
sub infix__S_342LtEqual {
no warnings 'recursion';
my $self = shift;
local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;
my %args = @_;
local $::sym = $args{sym} //['<='];


my $C = $self->cursor_xact("RULE infix__S_342LtEqual");
my $xact = $C->xact;
my $S = $C->{'_pos'};
$C->{'sym'} = ref $sym ? join(' ', @$sym) : $sym;

$self->_MATCHIFYr($S, "infix__S_342LtEqual", 
do {
if (my ($C) = ($C->_PATTERN(qr/\G\<\=/))) {
$C->_SUBSUMEr(['O'], sub {
my $C = shift;
$C->O(%chaining)
});
}
else {
();
}
}
);
}

##     token infix__S_343Gt (:$*sym =  > )
##          token infix:sym > 
##              { <sym> <O(|%chaining)> }

sub infix__S_343Gt__PEEK { $_[0]->_AUTOLEXpeek('infix__S_343Gt',$retree) }
sub infix__S_343Gt {
no warnings 'recursion';
my $self = shift;
local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;
my %args = @_;
local $::sym = $args{sym} //['>'];


my $C = $self->cursor_xact("RULE infix__S_343Gt");
my $xact = $C->xact;
my $S = $C->{'_pos'};
$C->{'sym'} = ref $sym ? join(' ', @$sym) : $sym;

$self->_MATCHIFYr($S, "infix__S_343Gt", 
do {
if (my ($C) = ($C->_PATTERN(qr/\G\>/))) {
$C->_SUBSUMEr(['O'], sub {
my $C = shift;
$C->O(%chaining)
});
}
else {
();
}
}
);
}

##     token infix__S_344GtEqual (:$*sym =  >= )
##          token infix:sym >= 
##              { <sym> <O(|%chaining)> }

sub infix__S_344GtEqual__PEEK { $_[0]->_AUTOLEXpeek('infix__S_344GtEqual',$retree) }
sub infix__S_344GtEqual {
no warnings 'recursion';
my $self = shift;
local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;
my %args = @_;
local $::sym = $args{sym} //['>='];


my $C = $self->cursor_xact("RULE infix__S_344GtEqual");
my $xact = $C->xact;
my $S = $C->{'_pos'};
$C->{'sym'} = ref $sym ? join(' ', @$sym) : $sym;

$self->_MATCHIFYr($S, "infix__S_344GtEqual", 
do {
if (my ($C) = ($C->_PATTERN(qr/\G\>\=/))) {
$C->_SUBSUMEr(['O'], sub {
my $C = shift;
$C->O(%chaining)
});
}
else {
();
}
}
);
}

##     token infix__S_345TildeTilde (:$*sym = <~~>)
##          token infix:sym<~~>
##              { <sym> <O(|%chaining)> }

sub infix__S_345TildeTilde__PEEK { $_[0]->_AUTOLEXpeek('infix__S_345TildeTilde',$retree) }
sub infix__S_345TildeTilde {
no warnings 'recursion';
my $self = shift;
local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;
my %args = @_;
local $::sym = $args{sym} // q(~~);


my $C = $self->cursor_xact("RULE infix__S_345TildeTilde");
my $xact = $C->xact;
my $S = $C->{'_pos'};
$C->{'sym'} = ref $sym ? join(' ', @$sym) : $sym;

$self->_MATCHIFYr($S, "infix__S_345TildeTilde", 
do {
if (my ($C) = ($C->_PATTERN(qr/\G\~\~/))) {
$C->_SUBSUMEr(['O'], sub {
my $C = shift;
$C->O(%chaining)
});
}
else {
();
}
}
);
}

# XXX should move to inside meta !
##     token infix__S_346BangTilde (:$*sym = <!~>)
##          token infix:sym<!~>
##              { <sym> \s <.obs('!~ to do negated pattern matching', '!~~')> <O(|%chaining)> }

sub infix__S_346BangTilde__PEEK { $_[0]->_AUTOLEXpeek('infix__S_346BangTilde',$retree) }
sub infix__S_346BangTilde {
no warnings 'recursion';
my $self = shift;
local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;
my %args = @_;
local $::sym = $args{sym} // q(!~);


my $C = $self->cursor_xact("RULE infix__S_346BangTilde");
my $xact = $C->xact;
my $S = $C->{'_pos'};
$C->{'sym'} = ref $sym ? join(' ', @$sym) : $sym;

$self->_MATCHIFYr($S, "infix__S_346BangTilde", 
do {
if (my ($C) = ($C->_PATTERN(qr/\G\!\~/))) {
do {
if (my ($C) = ($C->_PATTERN(qr/\G\s/))) {
do {
if (my ($C) = ($C->obs('!~ to do negated pattern matching', '!~~'))) {
$C->_SUBSUMEr(['O'], sub {
my $C = shift;
$C->O(%chaining)
});
}
else {
();
}
};
}
else {
();
}
};
}
else {
();
}
}
);
}

##     token infix__S_347EqualTilde (:$*sym = <=~>)
##          token infix:sym<=~>
##              { <sym> <.obs('=~ to do pattern matching', '~~')> <O(|%chaining)> }

sub infix__S_347EqualTilde__PEEK { $_[0]->_AUTOLEXpeek('infix__S_347EqualTilde',$retree) }
sub infix__S_347EqualTilde {
no warnings 'recursion';
my $self = shift;
local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;
my %args = @_;
local $::sym = $args{sym} // q(=~);


my $C = $self->cursor_xact("RULE infix__S_347EqualTilde");
my $xact = $C->xact;
my $S = $C->{'_pos'};
$C->{'sym'} = ref $sym ? join(' ', @$sym) : $sym;

$self->_MATCHIFYr($S, "infix__S_347EqualTilde", 
do {
if (my ($C) = ($C->_PATTERN(qr/\G\=\~/))) {
do {
if (my ($C) = ($C->obs('=~ to do pattern matching', '~~'))) {
$C->_SUBSUMEr(['O'], sub {
my $C = shift;
$C->O(%chaining)
});
}
else {
();
}
};
}
else {
();
}
}
);
}

##     token infix__S_348eq (:$*sym = <eq>)
##          token infix:sym<eq>
##              { <sym> <O(|%chaining)> }

sub infix__S_348eq__PEEK { $_[0]->_AUTOLEXpeek('infix__S_348eq',$retree) }
sub infix__S_348eq {
no warnings 'recursion';
my $self = shift;
local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;
my %args = @_;
local $::sym = $args{sym} // q(eq);


my $C = $self->cursor_xact("RULE infix__S_348eq");
my $xact = $C->xact;
my $S = $C->{'_pos'};
$C->{'sym'} = ref $sym ? join(' ', @$sym) : $sym;

$self->_MATCHIFYr($S, "infix__S_348eq", 
do {
if (my ($C) = ($C->_PATTERN(qr/\Geq/))) {
$C->_SUBSUMEr(['O'], sub {
my $C = shift;
$C->O(%chaining)
});
}
else {
();
}
}
);
}

##     token infix__S_349ne (:$*sym = <ne>)
##          token infix:sym<ne>
##              { <sym> <O(|%chaining)> }

sub infix__S_349ne__PEEK { $_[0]->_AUTOLEXpeek('infix__S_349ne',$retree) }
sub infix__S_349ne {
no warnings 'recursion';
my $self = shift;
local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;
my %args = @_;
local $::sym = $args{sym} // q(ne);


my $C = $self->cursor_xact("RULE infix__S_349ne");
my $xact = $C->xact;
my $S = $C->{'_pos'};
$C->{'sym'} = ref $sym ? join(' ', @$sym) : $sym;

$self->_MATCHIFYr($S, "infix__S_349ne", 
do {
if (my ($C) = ($C->_PATTERN(qr/\Gne/))) {
$C->_SUBSUMEr(['O'], sub {
my $C = shift;
$C->O(%chaining)
});
}
else {
();
}
}
);
}

##     token infix__S_350lt (:$*sym = <lt>)
##          token infix:sym<lt>
##              { <sym> <O(|%chaining)> }

sub infix__S_350lt__PEEK { $_[0]->_AUTOLEXpeek('infix__S_350lt',$retree) }
sub infix__S_350lt {
no warnings 'recursion';
my $self = shift;
local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;
my %args = @_;
local $::sym = $args{sym} // q(lt);


my $C = $self->cursor_xact("RULE infix__S_350lt");
my $xact = $C->xact;
my $S = $C->{'_pos'};
$C->{'sym'} = ref $sym ? join(' ', @$sym) : $sym;

$self->_MATCHIFYr($S, "infix__S_350lt", 
do {
if (my ($C) = ($C->_PATTERN(qr/\Glt/))) {
$C->_SUBSUMEr(['O'], sub {
my $C = shift;
$C->O(%chaining)
});
}
else {
();
}
}
);
}

##     token infix__S_351le (:$*sym = <le>)
##          token infix:sym<le>
##              { <sym> <O(|%chaining)> }

sub infix__S_351le__PEEK { $_[0]->_AUTOLEXpeek('infix__S_351le',$retree) }
sub infix__S_351le {
no warnings 'recursion';
my $self = shift;
local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;
my %args = @_;
local $::sym = $args{sym} // q(le);


my $C = $self->cursor_xact("RULE infix__S_351le");
my $xact = $C->xact;
my $S = $C->{'_pos'};
$C->{'sym'} = ref $sym ? join(' ', @$sym) : $sym;

$self->_MATCHIFYr($S, "infix__S_351le", 
do {
if (my ($C) = ($C->_PATTERN(qr/\Gle/))) {
$C->_SUBSUMEr(['O'], sub {
my $C = shift;
$C->O(%chaining)
});
}
else {
();
}
}
);
}

##     token infix__S_352gt (:$*sym = <gt>)
##          token infix:sym<gt>
##              { <sym> <O(|%chaining)> }

sub infix__S_352gt__PEEK { $_[0]->_AUTOLEXpeek('infix__S_352gt',$retree) }
sub infix__S_352gt {
no warnings 'recursion';
my $self = shift;
local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;
my %args = @_;
local $::sym = $args{sym} // q(gt);


my $C = $self->cursor_xact("RULE infix__S_352gt");
my $xact = $C->xact;
my $S = $C->{'_pos'};
$C->{'sym'} = ref $sym ? join(' ', @$sym) : $sym;

$self->_MATCHIFYr($S, "infix__S_352gt", 
do {
if (my ($C) = ($C->_PATTERN(qr/\Ggt/))) {
$C->_SUBSUMEr(['O'], sub {
my $C = shift;
$C->O(%chaining)
});
}
else {
();
}
}
);
}

##     token infix__S_353ge (:$*sym = <ge>)
##          token infix:sym<ge>
##              { <sym> <O(|%chaining)> }

sub infix__S_353ge__PEEK { $_[0]->_AUTOLEXpeek('infix__S_353ge',$retree) }
sub infix__S_353ge {
no warnings 'recursion';
my $self = shift;
local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;
my %args = @_;
local $::sym = $args{sym} // q(ge);


my $C = $self->cursor_xact("RULE infix__S_353ge");
my $xact = $C->xact;
my $S = $C->{'_pos'};
$C->{'sym'} = ref $sym ? join(' ', @$sym) : $sym;

$self->_MATCHIFYr($S, "infix__S_353ge", 
do {
if (my ($C) = ($C->_PATTERN(qr/\Gge/))) {
$C->_SUBSUMEr(['O'], sub {
my $C = shift;
$C->O(%chaining)
});
}
else {
();
}
}
);
}

##     token infix__S_354EqualColonEqual (:$*sym = <=:=>)
##          token infix:sym<=:=>
##              { <sym> <O(|%chaining)> }

sub infix__S_354EqualColonEqual__PEEK { $_[0]->_AUTOLEXpeek('infix__S_354EqualColonEqual',$retree) }
sub infix__S_354EqualColonEqual {
no warnings 'recursion';
my $self = shift;
local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;
my %args = @_;
local $::sym = $args{sym} // q(=:=);


my $C = $self->cursor_xact("RULE infix__S_354EqualColonEqual");
my $xact = $C->xact;
my $S = $C->{'_pos'};
$C->{'sym'} = ref $sym ? join(' ', @$sym) : $sym;

$self->_MATCHIFYr($S, "infix__S_354EqualColonEqual", 
do {
if (my ($C) = ($C->_PATTERN(qr/\G\=\:\=/))) {
$C->_SUBSUMEr(['O'], sub {
my $C = shift;
$C->O(%chaining)
});
}
else {
();
}
}
);
}

##     token infix__S_355EqualEqualEqual (:$*sym = <===>)
##          token infix:sym<===>
##              { <sym> <O(|%chaining)> }

sub infix__S_355EqualEqualEqual__PEEK { $_[0]->_AUTOLEXpeek('infix__S_355EqualEqualEqual',$retree) }
sub infix__S_355EqualEqualEqual {
no warnings 'recursion';
my $self = shift;
local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;
my %args = @_;
local $::sym = $args{sym} // q(===);


my $C = $self->cursor_xact("RULE infix__S_355EqualEqualEqual");
my $xact = $C->xact;
my $S = $C->{'_pos'};
$C->{'sym'} = ref $sym ? join(' ', @$sym) : $sym;

$self->_MATCHIFYr($S, "infix__S_355EqualEqualEqual", 
do {
if (my ($C) = ($C->_PATTERN(qr/\G\=\=\=/))) {
$C->_SUBSUMEr(['O'], sub {
my $C = shift;
$C->O(%chaining)
});
}
else {
();
}
}
);
}

##     token infix__S_356eqv (:$*sym = <eqv>)
##          token infix:sym<eqv>
##              { <sym> <O(|%chaining)> }

sub infix__S_356eqv__PEEK { $_[0]->_AUTOLEXpeek('infix__S_356eqv',$retree) }
sub infix__S_356eqv {
no warnings 'recursion';
my $self = shift;
local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;
my %args = @_;
local $::sym = $args{sym} // q(eqv);


my $C = $self->cursor_xact("RULE infix__S_356eqv");
my $xact = $C->xact;
my $S = $C->{'_pos'};
$C->{'sym'} = ref $sym ? join(' ', @$sym) : $sym;

$self->_MATCHIFYr($S, "infix__S_356eqv", 
do {
if (my ($C) = ($C->_PATTERN(qr/\Geqv/))) {
$C->_SUBSUMEr(['O'], sub {
my $C = shift;
$C->O(%chaining)
});
}
else {
();
}
}
);
}

##     token infix__S_357before (:$*sym = <before>)
##          token infix:sym<before>
##              { <sym> <O(|%chaining)> }

sub infix__S_357before__PEEK { $_[0]->_AUTOLEXpeek('infix__S_357before',$retree) }
sub infix__S_357before {
no warnings 'recursion';
my $self = shift;
local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;
my %args = @_;
local $::sym = $args{sym} // q(before);


my $C = $self->cursor_xact("RULE infix__S_357before");
my $xact = $C->xact;
my $S = $C->{'_pos'};
$C->{'sym'} = ref $sym ? join(' ', @$sym) : $sym;

$self->_MATCHIFYr($S, "infix__S_357before", 
do {
if (my ($C) = ($C->_PATTERN(qr/\Gbefore/))) {
$C->_SUBSUMEr(['O'], sub {
my $C = shift;
$C->O(%chaining)
});
}
else {
();
}
}
);
}

##     token infix__S_358after (:$*sym = <after>)
##          token infix:sym<after>
##              { <sym> <O(|%chaining)> }

sub infix__S_358after__PEEK { $_[0]->_AUTOLEXpeek('infix__S_358after',$retree) }
sub infix__S_358after {
no warnings 'recursion';
my $self = shift;
local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;
my %args = @_;
local $::sym = $args{sym} // q(after);


my $C = $self->cursor_xact("RULE infix__S_358after");
my $xact = $C->xact;
my $S = $C->{'_pos'};
$C->{'sym'} = ref $sym ? join(' ', @$sym) : $sym;

$self->_MATCHIFYr($S, "infix__S_358after", 
do {
if (my ($C) = ($C->_PATTERN(qr/\Gafter/))) {
$C->_SUBSUMEr(['O'], sub {
my $C = shift;
$C->O(%chaining)
});
}
else {
();
}
}
);
}


## tight and
##     token infix__S_359AmpAmp (:$*sym = <&&>)
##          token infix:sym<&&>
##              { <sym> <O(|%tight_and, iffy => 1)> }

sub infix__S_359AmpAmp__PEEK { $_[0]->_AUTOLEXpeek('infix__S_359AmpAmp',$retree) }
sub infix__S_359AmpAmp {
no warnings 'recursion';
my $self = shift;
local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;
my %args = @_;
local $::sym = $args{sym} // q(&&);


my $C = $self->cursor_xact("RULE infix__S_359AmpAmp");
my $xact = $C->xact;
my $S = $C->{'_pos'};
$C->{'sym'} = ref $sym ? join(' ', @$sym) : $sym;

$self->_MATCHIFYr($S, "infix__S_359AmpAmp", 
do {
if (my ($C) = ($C->_PATTERN(qr/\G\&\&/))) {
$C->_SUBSUMEr(['O'], sub {
my $C = shift;
$C->O(%tight_and, iffy => 1)
});
}
else {
();
}
}
);
}


## tight or
##     token infix__S_360VertVert (:$*sym = <||>)
##          token infix:sym<||>
##              { <sym> <O(|%tight_or, iffy => 1)> }

sub infix__S_360VertVert__PEEK { $_[0]->_AUTOLEXpeek('infix__S_360VertVert',$retree) }
sub infix__S_360VertVert {
no warnings 'recursion';
my $self = shift;
local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;
my %args = @_;
local $::sym = $args{sym} // q(||);


my $C = $self->cursor_xact("RULE infix__S_360VertVert");
my $xact = $C->xact;
my $S = $C->{'_pos'};
$C->{'sym'} = ref $sym ? join(' ', @$sym) : $sym;

$self->_MATCHIFYr($S, "infix__S_360VertVert", 
do {
if (my ($C) = ($C->_PATTERN(qr/\G\|\|/))) {
$C->_SUBSUMEr(['O'], sub {
my $C = shift;
$C->O(%tight_or, iffy => 1)
});
}
else {
();
}
}
);
}

##     token infix__S_361CaretCaret (:$*sym = <^^>)
##          token infix:sym<^^>
##              { <sym> <O(|%tight_or, iffy => 1)> }

sub infix__S_361CaretCaret__PEEK { $_[0]->_AUTOLEXpeek('infix__S_361CaretCaret',$retree) }
sub infix__S_361CaretCaret {
no warnings 'recursion';
my $self = shift;
local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;
my %args = @_;
local $::sym = $args{sym} // q(^^);


my $C = $self->cursor_xact("RULE infix__S_361CaretCaret");
my $xact = $C->xact;
my $S = $C->{'_pos'};
$C->{'sym'} = ref $sym ? join(' ', @$sym) : $sym;

$self->_MATCHIFYr($S, "infix__S_361CaretCaret", 
do {
if (my ($C) = ($C->_PATTERN(qr/\G\^\^/))) {
$C->_SUBSUMEr(['O'], sub {
my $C = shift;
$C->O(%tight_or, iffy => 1)
});
}
else {
();
}
}
);
}

##     token infix__S_362SlashSlash (:$*sym = <//>)
##          token infix:sym<//>
##              { <sym> <O(|%tight_or)> }

sub infix__S_362SlashSlash__PEEK { $_[0]->_AUTOLEXpeek('infix__S_362SlashSlash',$retree) }
sub infix__S_362SlashSlash {
no warnings 'recursion';
my $self = shift;
local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;
my %args = @_;
local $::sym = $args{sym} // q(//);


my $C = $self->cursor_xact("RULE infix__S_362SlashSlash");
my $xact = $C->xact;
my $S = $C->{'_pos'};
$C->{'sym'} = ref $sym ? join(' ', @$sym) : $sym;

$self->_MATCHIFYr($S, "infix__S_362SlashSlash", 
do {
if (my ($C) = ($C->_PATTERN(qr/\G\/\//))) {
$C->_SUBSUMEr(['O'], sub {
my $C = shift;
$C->O(%tight_or)
});
}
else {
();
}
}
);
}

##     token infix__S_363min (:$*sym = <min>)
##          token infix:sym<min>
##              { <sym> <O(|%tight_or)> }

sub infix__S_363min__PEEK { $_[0]->_AUTOLEXpeek('infix__S_363min',$retree) }
sub infix__S_363min {
no warnings 'recursion';
my $self = shift;
local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;
my %args = @_;
local $::sym = $args{sym} // q(min);


my $C = $self->cursor_xact("RULE infix__S_363min");
my $xact = $C->xact;
my $S = $C->{'_pos'};
$C->{'sym'} = ref $sym ? join(' ', @$sym) : $sym;

$self->_MATCHIFYr($S, "infix__S_363min", 
do {
if (my ($C) = ($C->_PATTERN(qr/\Gmin/))) {
$C->_SUBSUMEr(['O'], sub {
my $C = shift;
$C->O(%tight_or)
});
}
else {
();
}
}
);
}

##     token infix__S_364max (:$*sym = <max>)
##          token infix:sym<max>
##              { <sym> <O(|%tight_or)> }

sub infix__S_364max__PEEK { $_[0]->_AUTOLEXpeek('infix__S_364max',$retree) }
sub infix__S_364max {
no warnings 'recursion';
my $self = shift;
local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;
my %args = @_;
local $::sym = $args{sym} // q(max);


my $C = $self->cursor_xact("RULE infix__S_364max");
my $xact = $C->xact;
my $S = $C->{'_pos'};
$C->{'sym'} = ref $sym ? join(' ', @$sym) : $sym;

$self->_MATCHIFYr($S, "infix__S_364max", 
do {
if (my ($C) = ($C->_PATTERN(qr/\Gmax/))) {
$C->_SUBSUMEr(['O'], sub {
my $C = shift;
$C->O(%tight_or)
});
}
else {
();
}
}
);
}


## conditional
##     token infix__S_365QuestionQuestion_BangBang (:$*sym = <?? !!>)
##          token infix:sym<?? !!> {
##              :my $*GOAL ::= '!!';
##              '??'
##              <.ws>
##              <EXPR(item %item_assignment)>
##              [ '!!' ||
##                  [
##                  || <?before '='> <.panic: "Assignment not allowed within ??!!">
##                  || <?before '::'> <.panic: "Please use !! rather than ::">
##                  || <?before <infixish>>    # Note: a tight infix would have parsed right
##                      <.panic: "Precedence too loose within ??!!; use ??()!! instead ">
##                  || <.panic: "Found ?? but no !!; possible precedence problem">
##                  ]
##              ]
##              <O(|%conditional, _reducecheck => 'raise_middle')>
##          }

sub infix__S_365QuestionQuestion_BangBang__PEEK { $_[0]->_AUTOLEXpeek('infix__S_365QuestionQuestion_BangBang',$retree) }
sub infix__S_365QuestionQuestion_BangBang {
no warnings 'recursion';
my $self = shift;
local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;
my %args = @_;
local $::sym = $args{sym} // [qw(?? !!)];
local $::GOAL = '!!';


my $C = $self->cursor_xact("RULE infix__S_365QuestionQuestion_BangBang");
my $xact = $C->xact;
my $S = $C->{'_pos'};
$C->{'sym'} = ref $sym ? join(' ', @$sym) : $sym;

$self->_MATCHIFYr($S, "infix__S_365QuestionQuestion_BangBang", 
do {
if (my ($C) = ($C->_EXACT('??'))) {
do {
if (my ($C) = ($C->ws)) {
do {
if (my ($C) = ($C->_SUBSUMEr(['EXPR'], sub {
my $C = shift;
$C->EXPR(\%item_assignment)
}))) {
do {
if (my ($C) = ($C->_BRACKETr(sub {
my $C=shift;
do {
my $C = $C->cursor_xact('ALT ||');
my $xact = $C->xact;
my @gather;
do {
push @gather, $C->_EXACT('!!')
}
or $xact->[-2] or
do {
push @gather, $C->_BRACKETr(sub {
my $C=shift;
do {
my $C = $C->cursor_xact('ALT ||');
my $xact = $C->xact;
my @gather;
do {
push @gather, do {
if (my ($C) = ($C->before(sub { my $C=shift;
$C->_EXACT('=')
}))) {
$C->panic("Assignment not allowed within ??!!");
}
else {
();
}
}
}
or $xact->[-2] or
do {
push @gather, do {
if (my ($C) = ($C->before(sub { my $C=shift;
$C->_EXACT('::')
}))) {
$C->panic("Please use !! rather than ::");
}
else {
();
}
}
}
or $xact->[-2] or
do {
push @gather, do {
if (my ($C) = ($C->before(sub { my $C=shift;
$C->_SUBSUMEr(['infixish'], sub {
my $C = shift;
$C->infixish
})
}))) {
$C->panic("Precedence too loose within ??!!; use ??()!! instead ");
}
else {
();
}
}
}
or $xact->[-2] or
do {
push @gather, $C->panic("Found ?? but no !!; possible precedence problem")};
@gather;
}
})};
@gather;
}
}))) {
$C->_SUBSUMEr(['O'], sub {
my $C = shift;
$C->O(%conditional, _reducecheck => 'raise_middle')
});
}
else {
();
}
};
}
else {
();
}
};
}
else {
();
}
};
}
else {
();
}
}
);
}

##     token infix__S_366BangBang (:$*sym = <!!>)
##          token infix:sym<!!> {
##              <sym> <.panic: "Ternary !! seems to be missing its ??">
##          }

sub infix__S_366BangBang__PEEK { $_[0]->_AUTOLEXpeek('infix__S_366BangBang',$retree) }
sub infix__S_366BangBang {
no warnings 'recursion';
my $self = shift;
local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;
my %args = @_;
local $::sym = $args{sym} // q(!!);


my $C = $self->cursor_xact("RULE infix__S_366BangBang");
my $xact = $C->xact;
my $S = $C->{'_pos'};
$C->{'sym'} = ref $sym ? join(' ', @$sym) : $sym;

$self->_MATCHIFYr($S, "infix__S_366BangBang", 
do {
if (my ($C) = ($C->_PATTERN(qr/\G\!\!/))) {
$C->panic("Ternary !! seems to be missing its ??");
}
else {
();
}
}
);
}

##     method raise_middle
sub raise_middle {
my $self = shift;


$self->{'middle'} = $self->{'infix'}{'EXPR'};
$self;
}

##     token infix__S_367Question (:$*sym = <?>)
##          token infix:sym<?>
##              { <sym> {} <!before '?'> <?before <-[;]>*?':'> <.obs('?: for the conditional operator', '??!!')> <O(|%conditional)> }

sub infix__S_367Question__PEEK { $_[0]->_AUTOLEXpeek('infix__S_367Question',$retree) }
sub infix__S_367Question {
no warnings 'recursion';
my $self = shift;
local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;
my %args = @_;
local $::sym = $args{sym} // q(?);


my $C = $self->cursor_xact("RULE infix__S_367Question");
my $xact = $C->xact;
my $S = $C->{'_pos'};
$C->{'sym'} = ref $sym ? join(' ', @$sym) : $sym;

$self->_MATCHIFY($S, "infix__S_367Question", 
Cursor::lazymap(sub {
my $C=$_[0];
Cursor::lazymap(sub {
my $C=$_[0];
Cursor::lazymap(sub {
my $C=$_[0];
Cursor::lazymap(sub {
my $C=$_[0];
Cursor::lazymap(sub {
my $C=$_[0];
$C->_SUBSUME(['O'], sub {
my $C = shift;
$C->O(%conditional)
})
}, $C->obs('?: for the conditional operator', '??!!'))
}, $C->before(sub { my $C=shift;
Cursor::lazymap(sub {
my $C=$_[0];
$C->_EXACT(':')
}, $C->_STARf(sub { my $C=shift;
$C->_PATTERN(qr/\G[^;]/)
}))
}))
}, $C->_NOTBEFORE( sub { my $C=shift;
$C->before(sub { my $C=shift;
$C->_EXACT('?')
})
}))
}, scalar(do {

}, $C))
}, $C->_PATTERN(qr/\G\?/))
);
}

##     token infix__S_368ff (:$*sym = <ff>)
##          token infix:sym<ff>
##              { <sym> <O(|%conditional)> }

sub infix__S_368ff__PEEK { $_[0]->_AUTOLEXpeek('infix__S_368ff',$retree) }
sub infix__S_368ff {
no warnings 'recursion';
my $self = shift;
local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;
my %args = @_;
local $::sym = $args{sym} // q(ff);


my $C = $self->cursor_xact("RULE infix__S_368ff");
my $xact = $C->xact;
my $S = $C->{'_pos'};
$C->{'sym'} = ref $sym ? join(' ', @$sym) : $sym;

$self->_MATCHIFYr($S, "infix__S_368ff", 
do {
if (my ($C) = ($C->_PATTERN(qr/\Gff/))) {
$C->_SUBSUMEr(['O'], sub {
my $C = shift;
$C->O(%conditional)
});
}
else {
();
}
}
);
}

##     token infix__S_369Caretff (:$*sym = <^ff>)
##          token infix:sym<^ff>
##              { <sym> <O(|%conditional)> }

sub infix__S_369Caretff__PEEK { $_[0]->_AUTOLEXpeek('infix__S_369Caretff',$retree) }
sub infix__S_369Caretff {
no warnings 'recursion';
my $self = shift;
local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;
my %args = @_;
local $::sym = $args{sym} // q(^ff);


my $C = $self->cursor_xact("RULE infix__S_369Caretff");
my $xact = $C->xact;
my $S = $C->{'_pos'};
$C->{'sym'} = ref $sym ? join(' ', @$sym) : $sym;

$self->_MATCHIFYr($S, "infix__S_369Caretff", 
do {
if (my ($C) = ($C->_PATTERN(qr/\G\^ff/))) {
$C->_SUBSUMEr(['O'], sub {
my $C = shift;
$C->O(%conditional)
});
}
else {
();
}
}
);
}

##     token infix__S_370ffCaret (:$*sym = <ff^>)
##          token infix:sym<ff^>
##              { <sym> <O(|%conditional)> }

sub infix__S_370ffCaret__PEEK { $_[0]->_AUTOLEXpeek('infix__S_370ffCaret',$retree) }
sub infix__S_370ffCaret {
no warnings 'recursion';
my $self = shift;
local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;
my %args = @_;
local $::sym = $args{sym} // q(ff^);


my $C = $self->cursor_xact("RULE infix__S_370ffCaret");
my $xact = $C->xact;
my $S = $C->{'_pos'};
$C->{'sym'} = ref $sym ? join(' ', @$sym) : $sym;

$self->_MATCHIFYr($S, "infix__S_370ffCaret", 
do {
if (my ($C) = ($C->_PATTERN(qr/\Gff\^/))) {
$C->_SUBSUMEr(['O'], sub {
my $C = shift;
$C->O(%conditional)
});
}
else {
();
}
}
);
}

##     token infix__S_371CaretffCaret (:$*sym = <^ff^>)
##          token infix:sym<^ff^>
##              { <sym> <O(|%conditional)> }

sub infix__S_371CaretffCaret__PEEK { $_[0]->_AUTOLEXpeek('infix__S_371CaretffCaret',$retree) }
sub infix__S_371CaretffCaret {
no warnings 'recursion';
my $self = shift;
local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;
my %args = @_;
local $::sym = $args{sym} // q(^ff^);


my $C = $self->cursor_xact("RULE infix__S_371CaretffCaret");
my $xact = $C->xact;
my $S = $C->{'_pos'};
$C->{'sym'} = ref $sym ? join(' ', @$sym) : $sym;

$self->_MATCHIFYr($S, "infix__S_371CaretffCaret", 
do {
if (my ($C) = ($C->_PATTERN(qr/\G\^ff\^/))) {
$C->_SUBSUMEr(['O'], sub {
my $C = shift;
$C->O(%conditional)
});
}
else {
();
}
}
);
}

##     token infix__S_372fff (:$*sym = <fff>)
##          token infix:sym<fff>
##              { <sym> <O(|%conditional)> }

sub infix__S_372fff__PEEK { $_[0]->_AUTOLEXpeek('infix__S_372fff',$retree) }
sub infix__S_372fff {
no warnings 'recursion';
my $self = shift;
local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;
my %args = @_;
local $::sym = $args{sym} // q(fff);


my $C = $self->cursor_xact("RULE infix__S_372fff");
my $xact = $C->xact;
my $S = $C->{'_pos'};
$C->{'sym'} = ref $sym ? join(' ', @$sym) : $sym;

$self->_MATCHIFYr($S, "infix__S_372fff", 
do {
if (my ($C) = ($C->_PATTERN(qr/\Gfff/))) {
$C->_SUBSUMEr(['O'], sub {
my $C = shift;
$C->O(%conditional)
});
}
else {
();
}
}
);
}

##     token infix__S_373Caretfff (:$*sym = <^fff>)
##          token infix:sym<^fff>
##              { <sym> <O(|%conditional)> }

sub infix__S_373Caretfff__PEEK { $_[0]->_AUTOLEXpeek('infix__S_373Caretfff',$retree) }
sub infix__S_373Caretfff {
no warnings 'recursion';
my $self = shift;
local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;
my %args = @_;
local $::sym = $args{sym} // q(^fff);


my $C = $self->cursor_xact("RULE infix__S_373Caretfff");
my $xact = $C->xact;
my $S = $C->{'_pos'};
$C->{'sym'} = ref $sym ? join(' ', @$sym) : $sym;

$self->_MATCHIFYr($S, "infix__S_373Caretfff", 
do {
if (my ($C) = ($C->_PATTERN(qr/\G\^fff/))) {
$C->_SUBSUMEr(['O'], sub {
my $C = shift;
$C->O(%conditional)
});
}
else {
();
}
}
);
}

##     token infix__S_374fffCaret (:$*sym = <fff^>)
##          token infix:sym<fff^>
##              { <sym> <O(|%conditional)> }

sub infix__S_374fffCaret__PEEK { $_[0]->_AUTOLEXpeek('infix__S_374fffCaret',$retree) }
sub infix__S_374fffCaret {
no warnings 'recursion';
my $self = shift;
local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;
my %args = @_;
local $::sym = $args{sym} // q(fff^);


my $C = $self->cursor_xact("RULE infix__S_374fffCaret");
my $xact = $C->xact;
my $S = $C->{'_pos'};
$C->{'sym'} = ref $sym ? join(' ', @$sym) : $sym;

$self->_MATCHIFYr($S, "infix__S_374fffCaret", 
do {
if (my ($C) = ($C->_PATTERN(qr/\Gfff\^/))) {
$C->_SUBSUMEr(['O'], sub {
my $C = shift;
$C->O(%conditional)
});
}
else {
();
}
}
);
}

##     token infix__S_375CaretfffCaret (:$*sym = <^fff^>)
##          token infix:sym<^fff^>
##              { <sym> <O(|%conditional)> }

sub infix__S_375CaretfffCaret__PEEK { $_[0]->_AUTOLEXpeek('infix__S_375CaretfffCaret',$retree) }
sub infix__S_375CaretfffCaret {
no warnings 'recursion';
my $self = shift;
local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;
my %args = @_;
local $::sym = $args{sym} // q(^fff^);


my $C = $self->cursor_xact("RULE infix__S_375CaretfffCaret");
my $xact = $C->xact;
my $S = $C->{'_pos'};
$C->{'sym'} = ref $sym ? join(' ', @$sym) : $sym;

$self->_MATCHIFYr($S, "infix__S_375CaretfffCaret", 
do {
if (my ($C) = ($C->_PATTERN(qr/\G\^fff\^/))) {
$C->_SUBSUMEr(['O'], sub {
my $C = shift;
$C->O(%conditional)
});
}
else {
();
}
}
);
}

## assignment
# There is no "--> type" because assignment may be coerced to either
# item assignment or list assignment at "make" time.

##     token infix__S_376Equal (:$*sym = <=>)
##          token infix:sym<=> ()
##          {
##              <sym>
##              [
##              || <?{ $*LEFTSIGIL eq '$' }>
##                  <O(|%item_assignment)>
##              ||  <O(|%list_assignment)>
##              ]
##          }

sub infix__S_376Equal__PEEK { $_[0]->_AUTOLEXpeek('infix__S_376Equal',$retree) }
sub infix__S_376Equal {
no warnings 'recursion';
my $self = shift;
local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;
my %args = @_;
local $::sym = $args{sym} // q(=);


my $C = $self->cursor_xact("RULE infix__S_376Equal");
my $xact = $C->xact;
my $S = $C->{'_pos'};
$C->{'sym'} = ref $sym ? join(' ', @$sym) : $sym;

$self->_MATCHIFYr($S, "infix__S_376Equal", 
do {
if (my ($C) = ($C->_PATTERN(qr/\G\=/))) {
$C->_BRACKETr(sub {
my $C=shift;
do {
my $C = $C->cursor_xact('ALT ||');
my $xact = $C->xact;
my @gather;
do {
push @gather, do {
if (my ($C) = ($C->before( sub { my $C=shift;
(($C) x !!do {
$::LEFTSIGIL eq '$' 
})
}))) {
$C->_SUBSUMEr(['O'], sub {
my $C = shift;
$C->O(%item_assignment)
});
}
else {
();
}
}
}
or $xact->[-2] or
do {
push @gather, $C->_SUBSUMEr(['O'], sub {
my $C = shift;
$C->O(%list_assignment)
})};
@gather;
}
});
}
else {
();
}
}
);
}

##     token infix__S_377ColonEqual (:$*sym = <:=>)
##          token infix:sym<:=>
##              { <sym> <O(|%item_assignment)> }

sub infix__S_377ColonEqual__PEEK { $_[0]->_AUTOLEXpeek('infix__S_377ColonEqual',$retree) }
sub infix__S_377ColonEqual {
no warnings 'recursion';
my $self = shift;
local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;
my %args = @_;
local $::sym = $args{sym} // q(:=);


my $C = $self->cursor_xact("RULE infix__S_377ColonEqual");
my $xact = $C->xact;
my $S = $C->{'_pos'};
$C->{'sym'} = ref $sym ? join(' ', @$sym) : $sym;

$self->_MATCHIFYr($S, "infix__S_377ColonEqual", 
do {
if (my ($C) = ($C->_PATTERN(qr/\G\:\=/))) {
$C->_SUBSUMEr(['O'], sub {
my $C = shift;
$C->O(%item_assignment)
});
}
else {
();
}
}
);
}

##     token infix__S_378ColonColonEqual (:$*sym = <::=>)
##          token infix:sym<::=>
##              { <sym> <O(|%item_assignment)> }

sub infix__S_378ColonColonEqual__PEEK { $_[0]->_AUTOLEXpeek('infix__S_378ColonColonEqual',$retree) }
sub infix__S_378ColonColonEqual {
no warnings 'recursion';
my $self = shift;
local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;
my %args = @_;
local $::sym = $args{sym} // q(::=);


my $C = $self->cursor_xact("RULE infix__S_378ColonColonEqual");
my $xact = $C->xact;
my $S = $C->{'_pos'};
$C->{'sym'} = ref $sym ? join(' ', @$sym) : $sym;

$self->_MATCHIFYr($S, "infix__S_378ColonColonEqual", 
do {
if (my ($C) = ($C->_PATTERN(qr/\G\:\:\=/))) {
$C->_SUBSUMEr(['O'], sub {
my $C = shift;
$C->O(%item_assignment)
});
}
else {
();
}
}
);
}

##     token infix__S_379DotEqual (:$*sym = <.=>)
##          token infix:sym<.=> {
##              <sym>
##              <O(|%item_assignment,
##                  nextterm => 'dottyopish',
##                  _reducecheck => 'check_doteq'
##              )>
##          }

sub infix__S_379DotEqual__PEEK { $_[0]->_AUTOLEXpeek('infix__S_379DotEqual',$retree) }
sub infix__S_379DotEqual {
no warnings 'recursion';
my $self = shift;
local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;
my %args = @_;
local $::sym = $args{sym} // q(.=);


my $C = $self->cursor_xact("RULE infix__S_379DotEqual");
my $xact = $C->xact;
my $S = $C->{'_pos'};
$C->{'sym'} = ref $sym ? join(' ', @$sym) : $sym;

$self->_MATCHIFYr($S, "infix__S_379DotEqual", 
do {
if (my ($C) = ($C->_PATTERN(qr/\G\.\=/))) {
$C->_SUBSUMEr(['O'], sub {
my $C = shift;
$C->O(%item_assignment,
nextterm => 'dottyopish',
_reducecheck => 'check_doteq'
)
});
}
else {
();
}
}
);
}

##     method check_doteq
sub check_doteq {
my $self = shift;


# [ <?before \w+';' | 'new'|'sort'|'subst'|'trans'|'reverse'|'uniq'|'map'|'samecase'|'substr'|'flip'|'fmt' > || ]
return $self if $self->{'left'}{'scope_declarator'};
my $ok = 0;

eval {
my $methop = $self->{'right'}{'methodop'};
my $name = $methop->{'longname'}->Str;
if ($name eq 'new' or $name eq 'sort' or $name eq 'subst' or $name eq 'trans' or $name eq 'reverse' or $name eq 'uniq' or $name eq 'map' or $name eq 'samecase' or $name eq 'substr' or $name eq 'flip' or $name eq 'fmt') {
$ok = 1;
}
elsif (not $methop->{'args'}[0]) {
$ok = 1;
}
};

$self->cursor_force($self->{'infix'}{'_pos'})->worryobs('.= as append operator', '~=') unless $ok;
$self;
}

##     token infix__S_380EqualGt (:$*sym =  => )
##          token infix:sym => 
##              { <sym> <O(|%item_assignment, fiddly => 0)> }

sub infix__S_380EqualGt__PEEK { $_[0]->_AUTOLEXpeek('infix__S_380EqualGt',$retree) }
sub infix__S_380EqualGt {
no warnings 'recursion';
my $self = shift;
local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;
my %args = @_;
local $::sym = $args{sym} //['=>'];


my $C = $self->cursor_xact("RULE infix__S_380EqualGt");
my $xact = $C->xact;
my $S = $C->{'_pos'};
$C->{'sym'} = ref $sym ? join(' ', @$sym) : $sym;

$self->_MATCHIFYr($S, "infix__S_380EqualGt", 
do {
if (my ($C) = ($C->_PATTERN(qr/\G\=\>/))) {
$C->_SUBSUMEr(['O'], sub {
my $C = shift;
$C->O(%item_assignment, fiddly => 0)
});
}
else {
();
}
}
);
}

# Note, other assignment ops generated by infix_postfix_meta_operator rule

## loose unary
##     token prefix__S_381so (:$*sym = <so>)
##          token prefix:sym<so>
##              { <sym>  <O(|%loose_unary)> }

sub prefix__S_381so__PEEK { $_[0]->_AUTOLEXpeek('prefix__S_381so',$retree) }
sub prefix__S_381so {
no warnings 'recursion';
my $self = shift;
local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;
my %args = @_;
local $::sym = $args{sym} // q(so);


my $C = $self->cursor_xact("RULE prefix__S_381so");
my $xact = $C->xact;
my $S = $C->{'_pos'};
$C->{'sym'} = ref $sym ? join(' ', @$sym) : $sym;

$self->_MATCHIFYr($S, "prefix__S_381so", 
do {
if (my ($C) = ($C->_PATTERN(qr/\Gso/))) {
do {
if (my ($C) = ($C->_PATTERN(qr/\G\b/))) {
$C->_SUBSUMEr(['O'], sub {
my $C = shift;
$C->O(%loose_unary)
});
}
else {
();
}
};
}
else {
();
}
}
);
}

##     token prefix__S_382not (:$*sym = <not>)
##          token prefix:sym<not>
##              { <sym>  <O(|%loose_unary)> }

sub prefix__S_382not__PEEK { $_[0]->_AUTOLEXpeek('prefix__S_382not',$retree) }
sub prefix__S_382not {
no warnings 'recursion';
my $self = shift;
local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;
my %args = @_;
local $::sym = $args{sym} // q(not);


my $C = $self->cursor_xact("RULE prefix__S_382not");
my $xact = $C->xact;
my $S = $C->{'_pos'};
$C->{'sym'} = ref $sym ? join(' ', @$sym) : $sym;

$self->_MATCHIFYr($S, "prefix__S_382not", 
do {
if (my ($C) = ($C->_PATTERN(qr/\Gnot/))) {
do {
if (my ($C) = ($C->_PATTERN(qr/\G\b/))) {
$C->_SUBSUMEr(['O'], sub {
my $C = shift;
$C->O(%loose_unary)
});
}
else {
();
}
};
}
else {
();
}
}
);
}

## list item separator
##     token infix__S_383Comma (:$*sym = <,>)
##          token infix:sym<,>
##              { <sym> <O(|%comma, fiddly => 0)> }

sub infix__S_383Comma__PEEK { $_[0]->_AUTOLEXpeek('infix__S_383Comma',$retree) }
sub infix__S_383Comma {
no warnings 'recursion';
my $self = shift;
local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;
my %args = @_;
local $::sym = $args{sym} // q[,];


my $C = $self->cursor_xact("RULE infix__S_383Comma");
my $xact = $C->xact;
my $S = $C->{'_pos'};
$C->{'sym'} = ref $sym ? join(' ', @$sym) : $sym;

$self->_MATCHIFYr($S, "infix__S_383Comma", 
do {
if (my ($C) = ($C->_PATTERN(qr/\G\,/))) {
$C->_SUBSUMEr(['O'], sub {
my $C = shift;
$C->O(%comma, fiddly => 0)
});
}
else {
();
}
}
);
}

##     token infix__S_384Colon (:$*sym = <:>)
##          token infix:sym<:> {
##              ':' <?before \s | <terminator> >
##              {
##                  $.panic("Illegal use of colon as invocant marker") unless $*INVOCANT_OK-- or $*PRECLIM ge $item_assignment_prec;
##                  $<sym> = ',';
##                  $<wascolon> = True;
##              }
##              <O(|%comma)>
##          }

sub infix__S_384Colon__PEEK { $_[0]->_AUTOLEXpeek('infix__S_384Colon',$retree) }
sub infix__S_384Colon {
no warnings 'recursion';
my $self = shift;
local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;
my %args = @_;
local $::sym = $args{sym} // q(:);


my $C = $self->cursor_xact("RULE infix__S_384Colon");
my $xact = $C->xact;
my $S = $C->{'_pos'};
$C->{'sym'} = ref $sym ? join(' ', @$sym) : $sym;

$self->_MATCHIFYr($S, "infix__S_384Colon", 
do {
if (my ($C) = ($C->_EXACT(':'))) {
do {
if (my ($C) = ($C->before(sub { my $C=shift;
do {
my @result = do {
my $trystate;
my ($tag, $try);
my @try;
my $relex;

my $fate;
my $x;
if ($fate = $C->{'_fate'} and $fate->[1] eq 'infix__S_384Colon_01') {
$C->deb("Fate passed to infix__S_384Colon_01: ", ::fatestr($fate)) if $::DEBUG & DEBUG::fates;
($C->{'_fate'}, $tag, $try) = @$fate;
@try = ($try);
$x = 'ALT infix__S_384Colon_01';    # some outer ltm is controlling us
}
else {
$x = 'ALTLTM infix__S_384Colon_01'; # we are top level ltm
}
my $C = $C->cursor_xact($x);
my $xact = $C->xact;

my @gather = ();
for (;;) {
if (not @try) {
$relex //= $C->cursor_fate('STD::P6', 'infix__S_384Colon_01', $retree);
@try = $relex->($C, $trystate);
}
last unless @try;
$try = shift(@try) // next;

if (ref $try eq 'ARRAY') {
($C->{'_fate'}, $tag, $try) = @$try;	# next candidate fate
}

$C->deb("infix__S_384Colon_01 trying $tag $try") if $::DEBUG & DEBUG::try_processing;
push @gather, ((
sub { my $C=shift;
$C->_PATTERN(qr/\G\s/)
},
sub { my $C=shift;
$C->_SUBSUMEr(['terminator'], sub {
my $C = shift;
$C->terminator
})
},
)[$try])->($C);
last if $xact->[-2];  # committed?
last if @gather;
}
@gather;
};
@result;
}

}))) {
do {
if (my ($C) = (scalar(do {
my $M = $C; 
$C->panic("Illegal use of colon as invocant marker") unless $::INVOCANT_OK-- or $::PRECLIM ge $item_assignment_prec;
$M->{'sym'} = ',';
$M->{'wascolon'} = 1;
;
}, $C))) {
$C->_SUBSUMEr(['O'], sub {
my $C = shift;
$C->O(%comma)
});
}
else {
();
}
};
}
else {
();
}
};
}
else {
();
}
}
);
}

##     token infix__S_385X (:$*sym = <X>)
##          token infix:sym<X>
##              { <sym> <O(|%list_infix)> }

sub infix__S_385X__PEEK { $_[0]->_AUTOLEXpeek('infix__S_385X',$retree) }
sub infix__S_385X {
no warnings 'recursion';
my $self = shift;
local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;
my %args = @_;
local $::sym = $args{sym} // q(X);


my $C = $self->cursor_xact("RULE infix__S_385X");
my $xact = $C->xact;
my $S = $C->{'_pos'};
$C->{'sym'} = ref $sym ? join(' ', @$sym) : $sym;

$self->_MATCHIFYr($S, "infix__S_385X", 
do {
if (my ($C) = ($C->_PATTERN(qr/\GX/))) {
$C->_SUBSUMEr(['O'], sub {
my $C = shift;
$C->O(%list_infix)
});
}
else {
();
}
}
);
}

##     token infix__S_386Z (:$*sym = <Z>)
##          token infix:sym<Z>
##              { <sym> <O(|%list_infix)> }

sub infix__S_386Z__PEEK { $_[0]->_AUTOLEXpeek('infix__S_386Z',$retree) }
sub infix__S_386Z {
no warnings 'recursion';
my $self = shift;
local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;
my %args = @_;
local $::sym = $args{sym} // q(Z);


my $C = $self->cursor_xact("RULE infix__S_386Z");
my $xact = $C->xact;
my $S = $C->{'_pos'};
$C->{'sym'} = ref $sym ? join(' ', @$sym) : $sym;

$self->_MATCHIFYr($S, "infix__S_386Z", 
do {
if (my ($C) = ($C->_PATTERN(qr/\GZ/))) {
$C->_SUBSUMEr(['O'], sub {
my $C = shift;
$C->O(%list_infix)
});
}
else {
();
}
}
);
}

##     token infix__S_387minmax (:$*sym = <minmax>)
##          token infix:sym<minmax>
##              { <sym> <O(|%list_infix)> }

sub infix__S_387minmax__PEEK { $_[0]->_AUTOLEXpeek('infix__S_387minmax',$retree) }
sub infix__S_387minmax {
no warnings 'recursion';
my $self = shift;
local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;
my %args = @_;
local $::sym = $args{sym} // q(minmax);


my $C = $self->cursor_xact("RULE infix__S_387minmax");
my $xact = $C->xact;
my $S = $C->{'_pos'};
$C->{'sym'} = ref $sym ? join(' ', @$sym) : $sym;

$self->_MATCHIFYr($S, "infix__S_387minmax", 
do {
if (my ($C) = ($C->_PATTERN(qr/\Gminmax/))) {
$C->_SUBSUMEr(['O'], sub {
my $C = shift;
$C->O(%list_infix)
});
}
else {
();
}
}
);
}

##     token infix__S_388DotDotDot (:$*sym = <...>)
##          token infix:sym<...>
##              { <sym> <O(|%list_infix)> }

sub infix__S_388DotDotDot__PEEK { $_[0]->_AUTOLEXpeek('infix__S_388DotDotDot',$retree) }
sub infix__S_388DotDotDot {
no warnings 'recursion';
my $self = shift;
local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;
my %args = @_;
local $::sym = $args{sym} // q(...);


my $C = $self->cursor_xact("RULE infix__S_388DotDotDot");
my $xact = $C->xact;
my $S = $C->{'_pos'};
$C->{'sym'} = ref $sym ? join(' ', @$sym) : $sym;

$self->_MATCHIFYr($S, "infix__S_388DotDotDot", 
do {
if (my ($C) = ($C->_PATTERN(qr/\G\.\.\./))) {
$C->_SUBSUMEr(['O'], sub {
my $C = shift;
$C->O(%list_infix)
});
}
else {
();
}
}
);
}

##     token term__S_389DotDotDot (:$*sym = <...>)
##          token term:sym<...>
##              { <sym> <args>? <O(|%list_prefix)> }

sub term__S_389DotDotDot__PEEK { $_[0]->_AUTOLEXpeek('term__S_389DotDotDot',$retree) }
sub term__S_389DotDotDot {
no warnings 'recursion';
my $self = shift;
local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;
my %args = @_;
local $::sym = $args{sym} // q(...);


my $C = $self->cursor_xact("RULE term__S_389DotDotDot");
my $xact = $C->xact;
my $S = $C->{'_pos'};
$C->{'args'} = [];
$C->{'sym'} = ref $sym ? join(' ', @$sym) : $sym;

$self->_MATCHIFYr($S, "term__S_389DotDotDot", 
do {
if (my ($C) = ($C->_PATTERN(qr/\G\.\.\./))) {
do {
if (my ($C) = ($C->_OPTr(sub { my $C=shift;
$C->_SUBSUMEr(['args'], sub {
my $C = shift;
$C->args
})
}))) {
$C->_SUBSUMEr(['O'], sub {
my $C = shift;
$C->O(%list_prefix)
});
}
else {
();
}
};
}
else {
();
}
}
);
}

##     token term__S_390QuestionQuestionQuestion (:$*sym = <???>)
##          token term:sym<???>
##              { <sym> <args>? <O(|%list_prefix)> }

sub term__S_390QuestionQuestionQuestion__PEEK { $_[0]->_AUTOLEXpeek('term__S_390QuestionQuestionQuestion',$retree) }
sub term__S_390QuestionQuestionQuestion {
no warnings 'recursion';
my $self = shift;
local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;
my %args = @_;
local $::sym = $args{sym} // q(???);


my $C = $self->cursor_xact("RULE term__S_390QuestionQuestionQuestion");
my $xact = $C->xact;
my $S = $C->{'_pos'};
$C->{'args'} = [];
$C->{'sym'} = ref $sym ? join(' ', @$sym) : $sym;

$self->_MATCHIFYr($S, "term__S_390QuestionQuestionQuestion", 
do {
if (my ($C) = ($C->_PATTERN(qr/\G\?\?\?/))) {
do {
if (my ($C) = ($C->_OPTr(sub { my $C=shift;
$C->_SUBSUMEr(['args'], sub {
my $C = shift;
$C->args
})
}))) {
$C->_SUBSUMEr(['O'], sub {
my $C = shift;
$C->O(%list_prefix)
});
}
else {
();
}
};
}
else {
();
}
}
);
}

##     token term__S_391BangBangBang (:$*sym = <!!!>)
##          token term:sym<!!!>
##              { <sym> <args>? <O(|%list_prefix)> }

sub term__S_391BangBangBang__PEEK { $_[0]->_AUTOLEXpeek('term__S_391BangBangBang',$retree) }
sub term__S_391BangBangBang {
no warnings 'recursion';
my $self = shift;
local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;
my %args = @_;
local $::sym = $args{sym} // q(!!!);


my $C = $self->cursor_xact("RULE term__S_391BangBangBang");
my $xact = $C->xact;
my $S = $C->{'_pos'};
$C->{'args'} = [];
$C->{'sym'} = ref $sym ? join(' ', @$sym) : $sym;

$self->_MATCHIFYr($S, "term__S_391BangBangBang", 
do {
if (my ($C) = ($C->_PATTERN(qr/\G\!\!\!/))) {
do {
if (my ($C) = ($C->_OPTr(sub { my $C=shift;
$C->_SUBSUMEr(['args'], sub {
my $C = shift;
$C->args
})
}))) {
$C->_SUBSUMEr(['O'], sub {
my $C = shift;
$C->O(%list_prefix)
});
}
else {
();
}
};
}
else {
();
}
}
);
}

my %deftrap = (
'say' => 1, 'print' => 1, 'abs' => 1, 'alarm' => 1, 'chomp' => 1, 'chop' => 1, 'chr' => 1, 'chroot' => 1, 'cos' => 1,
'defined' => 1, 'eval' => 1, 'exp' => 1, 'glob' => 1, 'lc' => 1, 'lcfirst' => 1, 'log' => 1, 'lstat' => 1, 'mkdir' => 1,
'ord' => 1, 'readlink' => 1, 'readpipe' => 1, 'require' => 1, 'reverse' => 1, 'rmdir' => 1, 'sin' => 1,
'split' => 1, 'sqrt' => 1, 'stat' => 1, 'uc' => 1, 'ucfirst' => 1, 'unlink' => 1,
'WHAT' => 1, 'WHICH' => 1, 'WHERE' => 1, 'HOW' => 1, 'WHENCE' => 1, 'VAR' => 1,
);

# force identifier(), identifier.(), etc. to be a function call always
##     token term__S_392identifier (:$*sym = 'identifier')
##          token term:identifier
##          {
##              :my $name;
##              :my $pos;
##              <identifier> <?before [<unsp>|'(']? > <![:]>
##              { $name = $<identifier>.Str; $pos = $.pos; }
##              <args( $.is_name($name) )>
##              { self.add_mystery($name,$pos,substr($*ORIG,$pos,1)) unless $<args><invocant>; }
##              {{
##                  if $*BORG and $*BORG.<block> {
##                      if not $*BORG.<name> {
##                          $*BORG.<culprit> = $<identifier>.cursor($pos);
##                          $*BORG.<name> = $name;
##                      }
##                  }
##                  if %deftrap{$name} {
##                      my $al = $<args><arglist>[0];
##                      my $ok = 0;
##                      $ok = 1 if $al and $al.from != $al.to;
##                      $ok = 1 if $<args><semiarglist>;
##                      if not $ok {
##                          $<identifier>.worryobs("bare '$name'", ".$name if you meant \$_, or use an explicit invocant or argument");
##                      }
##                  }
##              }}
##              <O(|%term)>
##          }

sub term__S_392identifier__PEEK { $_[0]->_AUTOLEXpeek('term__S_392identifier',$retree) }
sub term__S_392identifier {
no warnings 'recursion';
my $self = shift;
local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;
my %args = @_;
local $::sym = $args{sym} // 'identifier';
my $name;
my $pos;


my $C = $self->cursor_xact("RULE term__S_392identifier");
my $xact = $C->xact;
my $S = $C->{'_pos'};
$C->{'sym'} = ref $sym ? join(' ', @$sym) : $sym;

$self->_MATCHIFYr($S, "term__S_392identifier", 
do {
if (my ($C) = ($C->_SUBSUMEr(['identifier'], sub {
my $C = shift;
$C->identifier
}))) {
do {
if (my ($C) = ($C->before(sub { my $C=shift;
$C->_OPTr(sub { my $C=shift;
$C->_BRACKETr(sub {
my $C=shift;
do {
my @result = do {
my $trystate;
my ($tag, $try);
my @try;
my $relex;

my $fate;
my $x;
if ($fate = $C->{'_fate'} and $fate->[1] eq 'term__S_392identifier_02') {
$C->deb("Fate passed to term__S_392identifier_02: ", ::fatestr($fate)) if $::DEBUG & DEBUG::fates;
($C->{'_fate'}, $tag, $try) = @$fate;
@try = ($try);
$x = 'ALT term__S_392identifier_02';    # some outer ltm is controlling us
}
else {
$x = 'ALTLTM term__S_392identifier_02'; # we are top level ltm
}
my $C = $C->cursor_xact($x);
my $xact = $C->xact;

my @gather = ();
for (;;) {
if (not @try) {
$relex //= $C->cursor_fate('STD::P6', 'term__S_392identifier_02', $retree);
@try = $relex->($C, $trystate);
}
last unless @try;
$try = shift(@try) // next;

if (ref $try eq 'ARRAY') {
($C->{'_fate'}, $tag, $try) = @$try;	# next candidate fate
}

$C->deb("term__S_392identifier_02 trying $tag $try") if $::DEBUG & DEBUG::try_processing;
push @gather, ((
sub { my $C=shift;
$C->_SUBSUMEr(['unsp'], sub {
my $C = shift;
$C->unsp
})
},
sub { my $C=shift;
$C->_EXACT('(')
},
)[$try])->($C);
last if $xact->[-2];  # committed?
last if @gather;
}
@gather;
};
@result;
}

})
})
}))) {
do {
if (my ($C) = ($C->_NOTBEFORE( sub { my $C=shift;
$C->_PATTERN(qr/\G[:]/)
}))) {
do {
if (my ($C) = (scalar(do {
my $M = $C;  $name = $M->{'identifier'}->Str; $pos = $C->{'_pos'}; ;
}, $C))) {
do {
if (my ($C) = ($C->_SUBSUMEr(['args'], sub {
my $C = shift;
$C->args( $C->is_name($name) )
}))) {
do {
if (my ($C) = (scalar(do {
my $M = $C;  $self->add_mystery($name,$pos,substr($::ORIG,$pos,1)) unless $M->{'args'}{'invocant'}; ;
}, $C))) {
do {
if (my ($C) = (scalar(do {
my $M = $C; 
if ($::BORG and $::BORG->{'block'}) {
if (not $::BORG->{'name'}) {
$::BORG->{'culprit'} = $M->{'identifier'}->cursor($pos);
$::BORG->{'name'} = $name;
}
}
if ($deftrap{$name}) {
my $al = $M->{'args'}{'arglist'}[0];
my $ok = 0;
$ok = 1 if $al and $al->from != $al->to;
$ok = 1 if $M->{'args'}{'semiarglist'};
if (not $ok) {
$M->{'identifier'}->worryobs("bare '$name'", ".$name if you meant \$_, or use an explicit invocant or argument");
}
}
;
}, $C))) {
$C->_SUBSUMEr(['O'], sub {
my $C = shift;
$C->O(%term)
});
}
else {
();
}
};
}
else {
();
}
};
}
else {
();
}
};
}
else {
();
}
};
}
else {
();
}
};
}
else {
();
}
};
}
else {
();
}
}
);
}

##     token args ($istype = 0)
##          token args ($istype = 0) {
##              :my $listopish = 0;
##              :my $*GOAL ::= '';
##              :my $*INVOCANT_OK = 1;
##              :my $*INVOCANT_IS;
##              [
##          #    | :dba('argument list') '.(' ~ ')' <semiarglist>
##              | :dba('argument list') '(' ~ ')' <semiarglist>
##              | :dba('argument list') <.unsp> '(' ~ ')' <semiarglist>
##              |  { $listopish = 1 } [<?before \s> <!{ $istype }> <.ws> <!infixstopper> <arglist>]?
##              ]
##              { $<invocant> = $*INVOCANT_IS; }
##      
##              :dba('extra arglist after (...):')
##              [
##              || <?{ $listopish }>
##              || ':' <?before \s> <moreargs=.arglist>    # either switch to listopiness
##              || {{ $<O> = {}; }}   # or allow adverbs (XXX needs hoisting?)
##              ]
##          }

sub args__PEEK { $_[0]->_AUTOLEXpeek('args',$retree) }
sub args {
no warnings 'recursion';
my $self = shift;
local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;
my $istype = shift() // 0;
my $listopish = 0;
local $::GOAL = '';
local $::INVOCANT_OK = 1;
local $::INVOCANT_IS;


my $C = $self->cursor_xact("RULE args");
my $xact = $C->xact;
my $S = $C->{'_pos'};
$C->{'arglist'} = [];

$self->_MATCHIFYr($S, "args", 
do {
if (my ($C) = ($C->_BRACKETr(sub {
my $C=shift;
do {
my @result = do {
my $trystate;
my ($tag, $try);
my @try;
my $relex;

my $fate;
my $x;
if ($fate = $C->{'_fate'} and $fate->[1] eq 'args_01') {
$C->deb("Fate passed to args_01: ", ::fatestr($fate)) if $::DEBUG & DEBUG::fates;
($C->{'_fate'}, $tag, $try) = @$fate;
@try = ($try);
$x = 'ALT args_01';    # some outer ltm is controlling us
}
else {
$x = 'ALTLTM args_01'; # we are top level ltm
}
my $C = $C->cursor_xact($x);
my $xact = $C->xact;

my @gather = ();
for (;;) {
if (not @try) {
$relex //= $C->cursor_fate('STD::P6', 'args_01', $retree);
@try = $relex->($C, $trystate);
}
last unless @try;
$try = shift(@try) // next;

if (ref $try eq 'ARRAY') {
($C->{'_fate'}, $tag, $try) = @$try;	# next candidate fate
}

$C->deb("args_01 trying $tag $try") if $::DEBUG & DEBUG::try_processing;
push @gather, ((
sub { my $C=shift;
do {
if (my ($C) = ($C->_EXACT('('))) {
do {
if (my ($C) = (((local $::GOAL = ')' ), $C)[-1])) {
do {
if (my ($C) = ($C->_SUBSUMEr(['semiarglist'], sub {
my $C = shift;
$C->semiarglist
}))) {
$C->_BRACKETr(sub {
my $C=shift;
do {
my $C = $C->cursor_xact('ALT ||');
my $xact = $C->xact;
my @gather;
do {
push @gather, $C->_EXACT(')')
}
or $xact->[-2] or
do {
push @gather, $C->FAILGOAL(')' , 'argument list')};
@gather;
}
});
}
else {
();
}
};
}
else {
();
}
};
}
else {
();
}
}
},
sub { my $C=shift;
do {
if (my ($C) = ($C->unsp)) {
do {
if (my ($C) = ($C->_EXACT('('))) {
do {
if (my ($C) = (((local $::GOAL = ')' ), $C)[-1])) {
do {
if (my ($C) = ($C->_SUBSUMEr(['semiarglist'], sub {
my $C = shift;
$C->semiarglist
}))) {
$C->_BRACKETr(sub {
my $C=shift;
do {
my $C = $C->cursor_xact('ALT ||');
my $xact = $C->xact;
my @gather;
do {
push @gather, $C->_EXACT(')')
}
or $xact->[-2] or
do {
push @gather, $C->FAILGOAL(')' , 'argument list')};
@gather;
}
});
}
else {
();
}
};
}
else {
();
}
};
}
else {
();
}
};
}
else {
();
}
}
},
sub { my $C=shift;
do {
if (my ($C) = (scalar(do {
$listopish = 1 
}, $C))) {
$C->_OPTr(sub { my $C=shift;
$C->_BRACKETr(sub {
my $C=shift;
do {
if (my ($C) = ($C->before(sub { my $C=shift;
$C->_PATTERN(qr/\G\s/)
}))) {
do {
if (my ($C) = ($C->_NOTBEFORE( sub { my $C=shift;
(($C) x !!do {
$istype 
})
}))) {
do {
if (my ($C) = ($C->ws)) {
do {
if (my ($C) = ($C->_NOTBEFORE( sub { my $C=shift;
$C->infixstopper
}))) {
$C->_SUBSUMEr(['arglist'], sub {
my $C = shift;
$C->arglist
});
}
else {
();
}
};
}
else {
();
}
};
}
else {
();
}
};
}
else {
();
}
}
})
});
}
else {
();
}
}
},
)[$try])->($C);
last if $xact->[-2];  # committed?
last if @gather;
}
@gather;
};
@result;
}

}))) {
do {
if (my ($C) = (scalar(do {
my $M = $C;  $M->{'invocant'} = $::INVOCANT_IS; ;
}, $C))) {
$C->_BRACKETr(sub {
my $C=shift;
do {
my $C = $C->cursor_xact('ALT ||');
my $xact = $C->xact;
my @gather;
do {
push @gather, $C->before( sub { my $C=shift;
(($C) x !!do {
$listopish 
})
})
}
or $xact->[-2] or
do {
push @gather, do {
if (my ($C) = ($C->_EXACT(':'))) {
do {
if (my ($C) = ($C->before(sub { my $C=shift;
$C->_PATTERN(qr/\G\s/)
}))) {
$C->_SUBSUMEr(['moreargs'], sub {
my $C = shift;
$C->arglist
});
}
else {
();
}
};
}
else {
();
}
}
}
or $xact->[-2] or
do {
push @gather, scalar(do {
my $M = $C;  $M->{'O'} = {}; ;
}, $C)};
@gather;
}
});
}
else {
();
}
};
}
else {
();
}
}
);
}

# names containing :: may or may not be function calls
# bare identifier without parens also handled here if no other rule parses it
##     token term__S_393name (:$*sym = 'name')
##          token term:name
##          {
##              :my $name;
##              :my $pos;
##              <longname>
##              {
##                  $name = $<longname>.Str;
##                  $pos = $.pos;
##              }
##              [
##              ||  <?{
##                      $.is_name($name) or substr($name,0,2) eq '::'
##                  }>
##      
##                  # parametric type?
##                  :dba('type parameter')
##                  <.unsp>? [ <?before '['> <postcircumfix> ]?
##      
##                  :dba('namespace variable lookup')
##                  [
##                      <?after '::'>
##                      <?before [ '' | '<' | '{' | '<<' ] > <postcircumfix>
##                      { $*VAR = $.cursor_all(self.pos, $.pos) }
##                  ]?
##      
##              # unrecognized names are assumed to be post-declared listops.
##              || <args> { self.add_mystery($name,$pos,'termish') unless $<args><invocant>; }
##                  {{
##                      if $*BORG and $*BORG.<block> {
##                          if not $*BORG.<name> {
##                              $*BORG.<culprit> = $<longname>.cursor($pos);
##                              $*BORG.<name> //= $name;
##                          }
##                      }
##                  }}
##              ]
##              <O(%term)>
##          }

sub term__S_393name__PEEK { $_[0]->_AUTOLEXpeek('term__S_393name',$retree) }
sub term__S_393name {
no warnings 'recursion';
my $self = shift;
local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;
my %args = @_;
local $::sym = $args{sym} // 'name';
my $name;
my $pos;


my $C = $self->cursor_xact("RULE term__S_393name");
my $xact = $C->xact;
my $S = $C->{'_pos'};
$C->{'postcircumfix'} = [];
$C->{'sym'} = ref $sym ? join(' ', @$sym) : $sym;

$self->_MATCHIFYr($S, "term__S_393name", 
do {
if (my ($C) = ($C->_SUBSUMEr(['longname'], sub {
my $C = shift;
$C->longname
}))) {
do {
if (my ($C) = (scalar(do {
my $M = $C; 
$name = $M->{'longname'}->Str;
$pos = $C->{'_pos'};
;
}, $C))) {
do {
if (my ($C) = ($C->_BRACKETr(sub {
my $C=shift;
do {
my $C = $C->cursor_xact('ALT ||');
my $xact = $C->xact;
my @gather;
do {
push @gather, do {
if (my ($C) = ($C->before( sub { my $C=shift;
(($C) x !!do {

$C->is_name($name) or substr($name,0,2) eq '::'

})
}))) {
do {
if (my ($C) = ($C->_OPTr(sub { my $C=shift;
$C->unsp
}))) {
do {
if (my ($C) = ($C->_OPTr(sub { my $C=shift;
$C->_BRACKETr(sub {
my $C=shift;
do {
if (my ($C) = ($C->before(sub { my $C=shift;
$C->_EXACT('[')
}))) {
$C->_SUBSUMEr(['postcircumfix'], sub {
my $C = shift;
$C->postcircumfix
});
}
else {
();
}
}
})
}))) {
$C->_OPTr(sub { my $C=shift;
$C->_BRACKETr(sub {
my $C=shift;
do {
if (my ($C) = ($C->before( sub { my $C=shift;
$C->after(sub { my $C=shift;
$C->_EXACT_rev('::')
})
}))) {
do {
if (my ($C) = ($C->before(sub { my $C=shift;
$C->_BRACKETr(sub {
my $C=shift;
do {
my @result = do {
my $trystate;
my ($tag, $try);
my @try;
my $relex;

my $fate;
my $x;
if ($fate = $C->{'_fate'} and $fate->[1] eq 'term__S_393name_07') {
$C->deb("Fate passed to term__S_393name_07: ", ::fatestr($fate)) if $::DEBUG & DEBUG::fates;
($C->{'_fate'}, $tag, $try) = @$fate;
@try = ($try);
$x = 'ALT term__S_393name_07';    # some outer ltm is controlling us
}
else {
$x = 'ALTLTM term__S_393name_07'; # we are top level ltm
}
my $C = $C->cursor_xact($x);
my $xact = $C->xact;

my @gather = ();
for (;;) {
if (not @try) {
$relex //= $C->cursor_fate('STD::P6', 'term__S_393name_07', $retree);
@try = $relex->($C, $trystate);
}
last unless @try;
$try = shift(@try) // next;

if (ref $try eq 'ARRAY') {
($C->{'_fate'}, $tag, $try) = @$try;	# next candidate fate
}

$C->deb("term__S_393name_07 trying $tag $try") if $::DEBUG & DEBUG::try_processing;
push @gather, ((
sub { my $C=shift;
$C->_EXACT('')
},
sub { my $C=shift;
$C->_EXACT('<')
},
sub { my $C=shift;
$C->_EXACT('{')
},
sub { my $C=shift;
$C->_EXACT('<<')
},
)[$try])->($C);
last if $xact->[-2];  # committed?
last if @gather;
}
@gather;
};
@result;
}

})
}))) {
do {
if (my ($C) = ($C->_SUBSUMEr(['postcircumfix'], sub {
my $C = shift;
$C->postcircumfix
}))) {
scalar(do {
$::VAR = $C->cursor_all($self->{'_pos'}, $C->{'_pos'}) 
}, $C);
}
else {
();
}
};
}
else {
();
}
};
}
else {
();
}
}
})
});
}
else {
();
}
};
}
else {
();
}
};
}
else {
();
}
}
}
or $xact->[-2] or
do {
push @gather, do {
if (my ($C) = ($C->_SUBSUMEr(['args'], sub {
my $C = shift;
$C->args
}))) {
do {
if (my ($C) = (scalar(do {
my $M = $C;  $self->add_mystery($name,$pos,'termish') unless $M->{'args'}{'invocant'}; ;
}, $C))) {
scalar(do {
my $M = $C; 
if ($::BORG and $::BORG->{'block'}) {
if (not $::BORG->{'name'}) {
$::BORG->{'culprit'} = $M->{'longname'}->cursor($pos);
$::BORG->{'name'} //= $name;
}
}
;
}, $C);
}
else {
();
}
};
}
else {
();
}
}};
@gather;
}
}))) {
$C->_SUBSUMEr(['O'], sub {
my $C = shift;
$C->O(%term)
});
}
else {
();
}
};
}
else {
();
}
};
}
else {
();
}
}
);
}

## loose and
##     token infix__S_394and (:$*sym = <and>)
##          token infix:sym<and>
##              { <sym> <O(|%loose_and, iffy => 1)> }

sub infix__S_394and__PEEK { $_[0]->_AUTOLEXpeek('infix__S_394and',$retree) }
sub infix__S_394and {
no warnings 'recursion';
my $self = shift;
local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;
my %args = @_;
local $::sym = $args{sym} // q(and);


my $C = $self->cursor_xact("RULE infix__S_394and");
my $xact = $C->xact;
my $S = $C->{'_pos'};
$C->{'sym'} = ref $sym ? join(' ', @$sym) : $sym;

$self->_MATCHIFYr($S, "infix__S_394and", 
do {
if (my ($C) = ($C->_PATTERN(qr/\Gand/))) {
$C->_SUBSUMEr(['O'], sub {
my $C = shift;
$C->O(%loose_and, iffy => 1)
});
}
else {
();
}
}
);
}

##     token infix__S_395andthen (:$*sym = <andthen>)
##          token infix:sym<andthen>
##              { <sym> <O(|%loose_and)> }

sub infix__S_395andthen__PEEK { $_[0]->_AUTOLEXpeek('infix__S_395andthen',$retree) }
sub infix__S_395andthen {
no warnings 'recursion';
my $self = shift;
local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;
my %args = @_;
local $::sym = $args{sym} // q(andthen);


my $C = $self->cursor_xact("RULE infix__S_395andthen");
my $xact = $C->xact;
my $S = $C->{'_pos'};
$C->{'sym'} = ref $sym ? join(' ', @$sym) : $sym;

$self->_MATCHIFYr($S, "infix__S_395andthen", 
do {
if (my ($C) = ($C->_PATTERN(qr/\Gandthen/))) {
$C->_SUBSUMEr(['O'], sub {
my $C = shift;
$C->O(%loose_and)
});
}
else {
();
}
}
);
}

## loose or
##     token infix__S_396or (:$*sym = <or>)
##          token infix:sym<or>
##              { <sym> <O(|%loose_or, iffy => 1)> }

sub infix__S_396or__PEEK { $_[0]->_AUTOLEXpeek('infix__S_396or',$retree) }
sub infix__S_396or {
no warnings 'recursion';
my $self = shift;
local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;
my %args = @_;
local $::sym = $args{sym} // q(or);


my $C = $self->cursor_xact("RULE infix__S_396or");
my $xact = $C->xact;
my $S = $C->{'_pos'};
$C->{'sym'} = ref $sym ? join(' ', @$sym) : $sym;

$self->_MATCHIFYr($S, "infix__S_396or", 
do {
if (my ($C) = ($C->_PATTERN(qr/\Gor/))) {
$C->_SUBSUMEr(['O'], sub {
my $C = shift;
$C->O(%loose_or, iffy => 1)
});
}
else {
();
}
}
);
}

##     token infix__S_397orelse (:$*sym = <orelse>)
##          token infix:sym<orelse>
##              { <sym> <O(|%loose_or)> }

sub infix__S_397orelse__PEEK { $_[0]->_AUTOLEXpeek('infix__S_397orelse',$retree) }
sub infix__S_397orelse {
no warnings 'recursion';
my $self = shift;
local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;
my %args = @_;
local $::sym = $args{sym} // q(orelse);


my $C = $self->cursor_xact("RULE infix__S_397orelse");
my $xact = $C->xact;
my $S = $C->{'_pos'};
$C->{'sym'} = ref $sym ? join(' ', @$sym) : $sym;

$self->_MATCHIFYr($S, "infix__S_397orelse", 
do {
if (my ($C) = ($C->_PATTERN(qr/\Gorelse/))) {
$C->_SUBSUMEr(['O'], sub {
my $C = shift;
$C->O(%loose_or)
});
}
else {
();
}
}
);
}

##     token infix__S_398xor (:$*sym = <xor>)
##          token infix:sym<xor>
##              { <sym> <O(|%loose_or, iffy => 1)> }

sub infix__S_398xor__PEEK { $_[0]->_AUTOLEXpeek('infix__S_398xor',$retree) }
sub infix__S_398xor {
no warnings 'recursion';
my $self = shift;
local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;
my %args = @_;
local $::sym = $args{sym} // q(xor);


my $C = $self->cursor_xact("RULE infix__S_398xor");
my $xact = $C->xact;
my $S = $C->{'_pos'};
$C->{'sym'} = ref $sym ? join(' ', @$sym) : $sym;

$self->_MATCHIFYr($S, "infix__S_398xor", 
do {
if (my ($C) = ($C->_PATTERN(qr/\Gxor/))) {
$C->_SUBSUMEr(['O'], sub {
my $C = shift;
$C->O(%loose_or, iffy => 1)
});
}
else {
();
}
}
);
}

## sequencer
##     token infix__S_399LtEqualEqual (:$*sym =  <== )
##          token infix:sym <== 
##              { <sym> <O(|%sequencer)> }

sub infix__S_399LtEqualEqual__PEEK { $_[0]->_AUTOLEXpeek('infix__S_399LtEqualEqual',$retree) }
sub infix__S_399LtEqualEqual {
no warnings 'recursion';
my $self = shift;
local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;
my %args = @_;
local $::sym = $args{sym} //['<=='];


my $C = $self->cursor_xact("RULE infix__S_399LtEqualEqual");
my $xact = $C->xact;
my $S = $C->{'_pos'};
$C->{'sym'} = ref $sym ? join(' ', @$sym) : $sym;

$self->_MATCHIFYr($S, "infix__S_399LtEqualEqual", 
do {
if (my ($C) = ($C->_PATTERN(qr/\G\<\=\=/))) {
$C->_SUBSUMEr(['O'], sub {
my $C = shift;
$C->O(%sequencer)
});
}
else {
();
}
}
);
}

##     token infix__S_400EqualEqualGt (:$*sym =  ==> )
##          token infix:sym ==> 
##              { <sym> <O(|%sequencer)> }

sub infix__S_400EqualEqualGt__PEEK { $_[0]->_AUTOLEXpeek('infix__S_400EqualEqualGt',$retree) }
sub infix__S_400EqualEqualGt {
no warnings 'recursion';
my $self = shift;
local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;
my %args = @_;
local $::sym = $args{sym} //['==>'];


my $C = $self->cursor_xact("RULE infix__S_400EqualEqualGt");
my $xact = $C->xact;
my $S = $C->{'_pos'};
$C->{'sym'} = ref $sym ? join(' ', @$sym) : $sym;

$self->_MATCHIFYr($S, "infix__S_400EqualEqualGt", 
do {
if (my ($C) = ($C->_PATTERN(qr/\G\=\=\>/))) {
$C->_SUBSUMEr(['O'], sub {
my $C = shift;
$C->O(%sequencer)
});
}
else {
();
}
}
);
}

##     token infix__S_401LtLtEqualEqual (:$*sym =  <<== )
##          token infix:sym <<== 
##              { <sym> <O(|%sequencer)> }

sub infix__S_401LtLtEqualEqual__PEEK { $_[0]->_AUTOLEXpeek('infix__S_401LtLtEqualEqual',$retree) }
sub infix__S_401LtLtEqualEqual {
no warnings 'recursion';
my $self = shift;
local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;
my %args = @_;
local $::sym = $args{sym} //['<<=='];


my $C = $self->cursor_xact("RULE infix__S_401LtLtEqualEqual");
my $xact = $C->xact;
my $S = $C->{'_pos'};
$C->{'sym'} = ref $sym ? join(' ', @$sym) : $sym;

$self->_MATCHIFYr($S, "infix__S_401LtLtEqualEqual", 
do {
if (my ($C) = ($C->_PATTERN(qr/\G\<\<\=\=/))) {
$C->_SUBSUMEr(['O'], sub {
my $C = shift;
$C->O(%sequencer)
});
}
else {
();
}
}
);
}

##     token infix__S_402EqualEqualGtGt (:$*sym =  ==>> )
##          token infix:sym ==>> 
##              { <sym> <O(|%sequencer)> }

sub infix__S_402EqualEqualGtGt__PEEK { $_[0]->_AUTOLEXpeek('infix__S_402EqualEqualGtGt',$retree) }
sub infix__S_402EqualEqualGtGt {
no warnings 'recursion';
my $self = shift;
local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;
my %args = @_;
local $::sym = $args{sym} //['==>>'];


my $C = $self->cursor_xact("RULE infix__S_402EqualEqualGtGt");
my $xact = $C->xact;
my $S = $C->{'_pos'};
$C->{'sym'} = ref $sym ? join(' ', @$sym) : $sym;

$self->_MATCHIFYr($S, "infix__S_402EqualEqualGtGt", 
do {
if (my ($C) = ($C->_PATTERN(qr/\G\=\=\>\>/))) {
$C->_SUBSUMEr(['O'], sub {
my $C = shift;
$C->O(%sequencer)
});
}
else {
();
}
}
);
}

## expression terminator
# Note: must always be called as <?terminator> or <?before ...<terminator>...>

##     token terminator__S_403Semi (:$*sym = <;>)
##          token terminator:sym<;>
##              { ';' <O(|%terminator)> }

sub terminator__S_403Semi__PEEK { $_[0]->_AUTOLEXpeek('terminator__S_403Semi',$retree) }
sub terminator__S_403Semi {
no warnings 'recursion';
my $self = shift;
local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;
my %args = @_;
local $::sym = $args{sym} // q(;);


my $C = $self->cursor_xact("RULE terminator__S_403Semi");
my $xact = $C->xact;
my $S = $C->{'_pos'};
$C->{'sym'} = ref $sym ? join(' ', @$sym) : $sym;

$self->_MATCHIFYr($S, "terminator__S_403Semi", 
do {
if (my ($C) = ($C->_EXACT(';'))) {
$C->_SUBSUMEr(['O'], sub {
my $C = shift;
$C->O(%terminator)
});
}
else {
();
}
}
);
}

##     token terminator__S_404if (:$*sym = <if>)
##          token terminator:sym<if>
##              { 'if'  <.nofun> <O(|%terminator)> }

sub terminator__S_404if__PEEK { $_[0]->_AUTOLEXpeek('terminator__S_404if',$retree) }
sub terminator__S_404if {
no warnings 'recursion';
my $self = shift;
local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;
my %args = @_;
local $::sym = $args{sym} // q(if);


my $C = $self->cursor_xact("RULE terminator__S_404if");
my $xact = $C->xact;
my $S = $C->{'_pos'};
$C->{'sym'} = ref $sym ? join(' ', @$sym) : $sym;

$self->_MATCHIFYr($S, "terminator__S_404if", 
do {
if (my ($C) = ($C->_EXACT('if'))) {
do {
if (my ($C) = ($C->_PATTERN(qr/\G\b/))) {
do {
if (my ($C) = ($C->nofun)) {
$C->_SUBSUMEr(['O'], sub {
my $C = shift;
$C->O(%terminator)
});
}
else {
();
}
};
}
else {
();
}
};
}
else {
();
}
}
);
}

##     token terminator__S_405unless (:$*sym = <unless>)
##          token terminator:sym<unless>
##              { 'unless'  <.nofun> <O(|%terminator)> }

sub terminator__S_405unless__PEEK { $_[0]->_AUTOLEXpeek('terminator__S_405unless',$retree) }
sub terminator__S_405unless {
no warnings 'recursion';
my $self = shift;
local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;
my %args = @_;
local $::sym = $args{sym} // q(unless);


my $C = $self->cursor_xact("RULE terminator__S_405unless");
my $xact = $C->xact;
my $S = $C->{'_pos'};
$C->{'sym'} = ref $sym ? join(' ', @$sym) : $sym;

$self->_MATCHIFYr($S, "terminator__S_405unless", 
do {
if (my ($C) = ($C->_EXACT('unless'))) {
do {
if (my ($C) = ($C->_PATTERN(qr/\G\b/))) {
do {
if (my ($C) = ($C->nofun)) {
$C->_SUBSUMEr(['O'], sub {
my $C = shift;
$C->O(%terminator)
});
}
else {
();
}
};
}
else {
();
}
};
}
else {
();
}
}
);
}

##     token terminator__S_406while (:$*sym = <while>)
##          token terminator:sym<while>
##              { 'while'  <.nofun> <O(|%terminator)> }

sub terminator__S_406while__PEEK { $_[0]->_AUTOLEXpeek('terminator__S_406while',$retree) }
sub terminator__S_406while {
no warnings 'recursion';
my $self = shift;
local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;
my %args = @_;
local $::sym = $args{sym} // q(while);


my $C = $self->cursor_xact("RULE terminator__S_406while");
my $xact = $C->xact;
my $S = $C->{'_pos'};
$C->{'sym'} = ref $sym ? join(' ', @$sym) : $sym;

$self->_MATCHIFYr($S, "terminator__S_406while", 
do {
if (my ($C) = ($C->_EXACT('while'))) {
do {
if (my ($C) = ($C->_PATTERN(qr/\G\b/))) {
do {
if (my ($C) = ($C->nofun)) {
$C->_SUBSUMEr(['O'], sub {
my $C = shift;
$C->O(%terminator)
});
}
else {
();
}
};
}
else {
();
}
};
}
else {
();
}
}
);
}

##     token terminator__S_407until (:$*sym = <until>)
##          token terminator:sym<until>
##              { 'until'  <.nofun> <O(|%terminator)> }

sub terminator__S_407until__PEEK { $_[0]->_AUTOLEXpeek('terminator__S_407until',$retree) }
sub terminator__S_407until {
no warnings 'recursion';
my $self = shift;
local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;
my %args = @_;
local $::sym = $args{sym} // q(until);


my $C = $self->cursor_xact("RULE terminator__S_407until");
my $xact = $C->xact;
my $S = $C->{'_pos'};
$C->{'sym'} = ref $sym ? join(' ', @$sym) : $sym;

$self->_MATCHIFYr($S, "terminator__S_407until", 
do {
if (my ($C) = ($C->_EXACT('until'))) {
do {
if (my ($C) = ($C->_PATTERN(qr/\G\b/))) {
do {
if (my ($C) = ($C->nofun)) {
$C->_SUBSUMEr(['O'], sub {
my $C = shift;
$C->O(%terminator)
});
}
else {
();
}
};
}
else {
();
}
};
}
else {
();
}
}
);
}

##     token terminator__S_408for (:$*sym = <for>)
##          token terminator:sym<for>
##              { 'for'  <.nofun> <O(|%terminator)> }

sub terminator__S_408for__PEEK { $_[0]->_AUTOLEXpeek('terminator__S_408for',$retree) }
sub terminator__S_408for {
no warnings 'recursion';
my $self = shift;
local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;
my %args = @_;
local $::sym = $args{sym} // q(for);


my $C = $self->cursor_xact("RULE terminator__S_408for");
my $xact = $C->xact;
my $S = $C->{'_pos'};
$C->{'sym'} = ref $sym ? join(' ', @$sym) : $sym;

$self->_MATCHIFYr($S, "terminator__S_408for", 
do {
if (my ($C) = ($C->_EXACT('for'))) {
do {
if (my ($C) = ($C->_PATTERN(qr/\G\b/))) {
do {
if (my ($C) = ($C->nofun)) {
$C->_SUBSUMEr(['O'], sub {
my $C = shift;
$C->O(%terminator)
});
}
else {
();
}
};
}
else {
();
}
};
}
else {
();
}
}
);
}

##     token terminator__S_409given (:$*sym = <given>)
##          token terminator:sym<given>
##              { 'given'  <.nofun> <O(|%terminator)> }

sub terminator__S_409given__PEEK { $_[0]->_AUTOLEXpeek('terminator__S_409given',$retree) }
sub terminator__S_409given {
no warnings 'recursion';
my $self = shift;
local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;
my %args = @_;
local $::sym = $args{sym} // q(given);


my $C = $self->cursor_xact("RULE terminator__S_409given");
my $xact = $C->xact;
my $S = $C->{'_pos'};
$C->{'sym'} = ref $sym ? join(' ', @$sym) : $sym;

$self->_MATCHIFYr($S, "terminator__S_409given", 
do {
if (my ($C) = ($C->_EXACT('given'))) {
do {
if (my ($C) = ($C->_PATTERN(qr/\G\b/))) {
do {
if (my ($C) = ($C->nofun)) {
$C->_SUBSUMEr(['O'], sub {
my $C = shift;
$C->O(%terminator)
});
}
else {
();
}
};
}
else {
();
}
};
}
else {
();
}
}
);
}

##     token terminator__S_410when (:$*sym = <when>)
##          token terminator:sym<when>
##              { 'when'  <.nofun> <O(|%terminator)> }

sub terminator__S_410when__PEEK { $_[0]->_AUTOLEXpeek('terminator__S_410when',$retree) }
sub terminator__S_410when {
no warnings 'recursion';
my $self = shift;
local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;
my %args = @_;
local $::sym = $args{sym} // q(when);


my $C = $self->cursor_xact("RULE terminator__S_410when");
my $xact = $C->xact;
my $S = $C->{'_pos'};
$C->{'sym'} = ref $sym ? join(' ', @$sym) : $sym;

$self->_MATCHIFYr($S, "terminator__S_410when", 
do {
if (my ($C) = ($C->_EXACT('when'))) {
do {
if (my ($C) = ($C->_PATTERN(qr/\G\b/))) {
do {
if (my ($C) = ($C->nofun)) {
$C->_SUBSUMEr(['O'], sub {
my $C = shift;
$C->O(%terminator)
});
}
else {
();
}
};
}
else {
();
}
};
}
else {
();
}
}
);
}

##     token terminator__S_411MinusMinusGt (:$*sym =  --> )
##          token terminator:sym --> 
##              { '-->' <O(|%terminator)> }

sub terminator__S_411MinusMinusGt__PEEK { $_[0]->_AUTOLEXpeek('terminator__S_411MinusMinusGt',$retree) }
sub terminator__S_411MinusMinusGt {
no warnings 'recursion';
my $self = shift;
local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;
my %args = @_;
local $::sym = $args{sym} //['-->'];


my $C = $self->cursor_xact("RULE terminator__S_411MinusMinusGt");
my $xact = $C->xact;
my $S = $C->{'_pos'};
$C->{'sym'} = ref $sym ? join(' ', @$sym) : $sym;

$self->_MATCHIFYr($S, "terminator__S_411MinusMinusGt", 
do {
if (my ($C) = ($C->_EXACT('-->'))) {
$C->_SUBSUMEr(['O'], sub {
my $C = shift;
$C->O(%terminator)
});
}
else {
();
}
}
);
}

##     token terminator__S_412BangBang (:$*sym = <!!>)
##          token terminator:sym<!!>
##              { '!!' <?{ $*GOAL eq '!!' }> <O(|%terminator)> }

sub terminator__S_412BangBang__PEEK { $_[0]->_AUTOLEXpeek('terminator__S_412BangBang',$retree) }
sub terminator__S_412BangBang {
no warnings 'recursion';
my $self = shift;
local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;
my %args = @_;
local $::sym = $args{sym} // q(!!);


my $C = $self->cursor_xact("RULE terminator__S_412BangBang");
my $xact = $C->xact;
my $S = $C->{'_pos'};
$C->{'sym'} = ref $sym ? join(' ', @$sym) : $sym;

$self->_MATCHIFYr($S, "terminator__S_412BangBang", 
do {
if (my ($C) = ($C->_EXACT('!!'))) {
do {
if (my ($C) = ($C->before( sub { my $C=shift;
(($C) x !!do {
$::GOAL eq '!!' 
})
}))) {
$C->_SUBSUMEr(['O'], sub {
my $C = shift;
$C->O(%terminator)
});
}
else {
();
}
};
}
else {
();
}
}
);
}

##     regex infixstopper
##          regex infixstopper {
##              :dba('infix stopper')
##              [
##              | <?before <stopper> >
##              | <?before '!!'> <?{ $*GOAL eq '!!' }>
##              | <?before '{' | <lambda> > <?{ ($*GOAL eq '{' or $*GOAL eq 'endargs') and @*MEMOS[$.pos]<ws> }>
##              | <?{ $*GOAL eq 'endargs' and @*MEMOS[$.pos]<endargs> }>
##              ]
##          }

sub infixstopper__PEEK { $_[0]->_AUTOLEXpeek('infixstopper',$retree) }
sub infixstopper {
no warnings 'recursion';
my $self = shift;
local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;


my $C = $self->cursor_xact("RULE infixstopper");
my $xact = $C->xact;
my $S = $C->{'_pos'};

$self->_MATCHIFY($S, "infixstopper", 
$C->_BRACKET(sub {
my $C=shift;
do {
my @result = do {
my $trystate;
my ($tag, $try);
my @try;
my $relex;

my $fate;
my $x;
if ($fate = $C->{'_fate'} and $fate->[1] eq 'infixstopper_01') {
$C->deb("Fate passed to infixstopper_01: ", ::fatestr($fate)) if $::DEBUG & DEBUG::fates;
($C->{'_fate'}, $tag, $try) = @$fate;
@try = ($try);
$x = 'ALT infixstopper_01';    # some outer ltm is controlling us
}
else {
$x = 'ALTLTM infixstopper_01'; # we are top level ltm
}
my $C = $C->cursor_xact($x);
my $xact = $C->xact;

my @gather = ();
for (;;) {
if (not @try) {
$relex //= $C->cursor_fate('STD::P6', 'infixstopper_01', $retree);
@try = $relex->($C, $trystate);
}
last unless @try;
$try = shift(@try) // next;

if (ref $try eq 'ARRAY') {
($C->{'_fate'}, $tag, $try) = @$try;	# next candidate fate
}

$C->deb("infixstopper_01 trying $tag $try") if $::DEBUG & DEBUG::try_processing;
push @gather, ((
sub { my $C=shift;
$C->before(sub { my $C=shift;
$C->_SUBSUME(['stopper'], sub {
my $C = shift;
$C->stopper
})
})
},
sub { my $C=shift;
Cursor::lazymap(sub {
my $C=$_[0];
$C->before( sub { my $C=shift;
(($C) x !!do {
$::GOAL eq '!!' 
})
})
}, $C->before(sub { my $C=shift;
$C->_EXACT('!!')
}))
},
sub { my $C=shift;
Cursor::lazymap(sub {
my $C=$_[0];
$C->before( sub { my $C=shift;
(($C) x !!do {
($::GOAL eq '{' or $::GOAL eq 'endargs') and $::MEMOS[$C->{'_pos'}]{'ws'} 
})
})
}, $C->before(sub { my $C=shift;
do {
my @result = do {
my $trystate;
my ($tag, $try);
my @try;
my $relex;

my $fate;
my $x;
if ($fate = $C->{'_fate'} and $fate->[1] eq 'infixstopper_04') {
$C->deb("Fate passed to infixstopper_04: ", ::fatestr($fate)) if $::DEBUG & DEBUG::fates;
($C->{'_fate'}, $tag, $try) = @$fate;
@try = ($try);
$x = 'ALT infixstopper_04';    # some outer ltm is controlling us
}
else {
$x = 'ALTLTM infixstopper_04'; # we are top level ltm
}
my $C = $C->cursor_xact($x);
my $xact = $C->xact;

my @gather = ();
for (;;) {
if (not @try) {
$relex //= $C->cursor_fate('STD::P6', 'infixstopper_04', $retree);
@try = $relex->($C, $trystate);
}
last unless @try;
$try = shift(@try) // next;

if (ref $try eq 'ARRAY') {
($C->{'_fate'}, $tag, $try) = @$try;	# next candidate fate
}

$C->deb("infixstopper_04 trying $tag $try") if $::DEBUG & DEBUG::try_processing;
push @gather, ((
sub { my $C=shift;
$C->_EXACT('{')
},
sub { my $C=shift;
$C->_SUBSUME(['lambda'], sub {
my $C = shift;
$C->lambda
})
},
)[$try])->($C);
last if $xact->[-2];  # committed?
last if @gather;
}
@gather;
};
@result;
}

}))
},
sub { my $C=shift;
$C->before( sub { my $C=shift;
(($C) x !!do {
$::GOAL eq 'endargs' and $::MEMOS[$C->{'_pos'}]{'endargs'} 
})
})
},
)[$try])->($C);
last if $xact->[-2];  # committed?
last if @gather;
}
@gather;
};
@result;
}

})
);
}

BEGIN {
$retree = YAML::XS::Load(Encode::encode_utf8(<<'RETREE_END'));
---
POST: !!perl/hash:RE_ast
  decl: []
  kind: token
  min: 12345
  pkg: ~
  re: !!perl/hash:RE_sequence
    a: 0
    dba: postfix
    i: 0
    min: 12345
    r: 1
    s: 0
    zyg:
    - !!perl/hash:RE_assertion
      assert: '!'
      min: 0
      re: !!perl/hash:RE_method
        a: 0
        dba: POST
        i: 0
        min: 12345
        name: stdstopper
        nobind: 1
        r: 1
        rest: ''
        s: 0
    - !!perl/hash:RE_assertion
      assert: '!'
      min: 0
      re: !!perl/hash:RE_block
        a: 0
        context: bool
        dba: POST
        i: 0
        min: 0
        nobind: 1
        r: 1
        s: 0
        text: ' @*MEMOS[$.pos]<ws> '
    - !!perl/hash:RE_quantified_atom
      atom: !!perl/hash:RE_bracket
        decl: []
        min: 1
        re: &1 !!perl/hash:RE_any
          a: 0
          altname: POST_01
          dba: POST
          i: 0
          min: 1
          name: POST_01
          r: 1
          s: 0
          zyg:
          - !!perl/hash:RE_method
            a: 0
            alt: POST_01 0
            dba: POST
            i: 0
            min: 12345
            name: unsp
            nobind: 1
            r: 1
            rest: ''
            s: 0
          - !!perl/hash:RE_string
            a: 0
            alt: POST_01 1
            dba: POST
            i: 0
            min: 1
            r: 1
            s: 0
            text: \
      min: 0
      quant:
      - '?'
      - ':'
      - ''
      - 0
    - !!perl/hash:RE_quantified_atom
      atom: !!perl/hash:RE_bracket
        decl: []
        min: 12345
        re: !!perl/hash:RE_sequence
          a: 0
          dba: POST
          i: 0
          min: 12345
          r: 1
          s: 0
          zyg:
          - !!perl/hash:RE_quantified_atom
            atom: !!perl/hash:RE_bracket
              decl: []
              min: 1
              re: !!perl/hash:RE_sequence
                a: 0
                dba: POST
                i: 0
                min: 1
                r: 1
                s: 0
                zyg:
                - !!perl/hash:RE_string
                  a: 0
                  dba: POST
                  i: 0
                  min: 1
                  r: 1
                  s: 0
                  text: .
                - !!perl/hash:RE_quantified_atom
                  atom: !!perl/hash:RE_method
                    a: 0
                    dba: POST
                    i: 0
                    min: 12345
                    name: unsp
                    nobind: 1
                    r: 1
                    rest: ''
                    s: 0
                  min: 0
                  quant:
                  - '?'
                  - ':'
                  - ''
                  - 0
            min: 0
            quant:
            - '?'
            - ':'
            - ''
            - 0
          - !!perl/hash:RE_method
            a: 0
            dba: POST
            i: 0
            min: 12345
            name: postfix_prefix_meta_operator
            r: 1
            rest: ''
            s: 0
          - !!perl/hash:RE_quantified_atom
            atom: !!perl/hash:RE_method
              a: 0
              dba: POST
              i: 0
              min: 12345
              name: unsp
              nobind: 1
              r: 1
              rest: ''
              s: 0
            min: 0
            quant:
            - '?'
            - ':'
            - ''
            - 0
      min: 0
      quant:
      - '*'
      - ':'
      - ''
      - 0
    - !!perl/hash:RE_bracket
      decl: []
      min: 12345
      re: &2 !!perl/hash:RE_any
        a: 0
        altname: POST_04
        dba: postfix
        i: 0
        min: 12345
        name: POST_04
        r: 1
        s: 0
        zyg:
        - !!perl/hash:RE_sequence
          a: 0
          alt: POST_04 0
          dba: postfix
          i: 0
          min: 12345
          r: 1
          s: 0
          zyg:
          - !!perl/hash:RE_method
            a: 0
            dba: postfix
            i: 0
            min: 12345
            name: dotty
            r: 1
            rest: ''
            s: 0
          - !!perl/hash:RE_block
            a: 0
            context: void
            dba: postfix
            i: 0
            min: 0
            r: 1
            s: 0
            text: ' $<O> = $<dotty><O>;  $<sym> = $<dotty><sym>;  $<~CAPS> = $<dotty><~CAPS>; '
        - !!perl/hash:RE_sequence
          a: 0
          alt: POST_04 1
          dba: postfix
          i: 0
          min: 12345
          r: 1
          s: 0
          zyg:
          - !!perl/hash:RE_method
            a: 0
            dba: postfix
            i: 0
            min: 12345
            name: privop
            r: 1
            rest: ''
            s: 0
          - !!perl/hash:RE_block
            a: 0
            context: void
            dba: postfix
            i: 0
            min: 0
            r: 1
            s: 0
            text: ' $<O> = $<privop><O>; $<sym> = $<privop><sym>; $<~CAPS> = $<privop><~CAPS>; '
        - !!perl/hash:RE_sequence
          a: 0
          alt: POST_04 2
          dba: postfix
          i: 0
          min: 12345
          r: 1
          s: 0
          zyg:
          - !!perl/hash:RE_method
            a: 0
            dba: postfix
            i: 0
            min: 12345
            name: postop
            r: 1
            rest: ''
            s: 0
          - !!perl/hash:RE_block
            a: 0
            context: void
            dba: postfix
            i: 0
            min: 0
            r: 1
            s: 0
            text: ' $<O> = $<postop><O>; $<sym> = $<postop><sym>; $<~CAPS> = $<postop><~CAPS>; '
    - !!perl/hash:RE_block
      a: 0
      context: void
      dba: postfix
      i: 0
      min: 0
      r: 1
      s: 0
      text: ' $*LEFTSIGIL = ''@''; '
POST_01: *1
POST_04: *2
PRE: !!perl/hash:RE_ast
  decl: []
  kind: token
  min: 24690
  pkg: ~
  re: !!perl/hash:RE_sequence
    a: 0
    dba: prefix or meta-prefix
    i: 0
    min: 24690
    r: 1
    s: 0
    zyg:
    - !!perl/hash:RE_bracket
      decl: []
      min: 12345
      re: &3 !!perl/hash:RE_any
        a: 0
        altname: PRE_01
        dba: prefix or meta-prefix
        i: 0
        min: 12345
        name: PRE_01
        r: 1
        s: 0
        zyg:
        - !!perl/hash:RE_sequence
          a: 0
          alt: PRE_01 0
          dba: prefix or meta-prefix
          i: 0
          min: 12345
          r: 1
          s: 0
          zyg:
          - !!perl/hash:RE_method
            a: 0
            dba: prefix or meta-prefix
            i: 0
            min: 12345
            name: prefix
            r: 1
            rest: ''
            s: 0
          - !!perl/hash:RE_block
            a: 0
            context: void
            dba: prefix or meta-prefix
            i: 0
            min: 0
            r: 1
            s: 0
            text: ' $<O> = $<prefix><O>; $<sym> = $<prefix><sym> '
        - !!perl/hash:RE_sequence
          a: 0
          alt: PRE_01 1
          dba: prefix or meta-prefix
          i: 0
          min: 12345
          r: 1
          s: 0
          zyg:
          - !!perl/hash:RE_method
            a: 0
            dba: prefix or meta-prefix
            i: 0
            min: 12345
            name: prefix_circumfix_meta_operator
            r: 1
            rest: ''
            s: 0
          - !!perl/hash:RE_block
            a: 0
            context: void
            dba: prefix or meta-prefix
            i: 0
            min: 0
            r: 1
            s: 0
            text: ' $<O> = $<prefix_circumfix_meta_operator><O>; $<sym> = $<prefix_circumfix_meta_operator>.Str '
    - !!perl/hash:RE_quantified_atom
      atom: !!perl/hash:RE_method
        a: 0
        dba: prefix or meta-prefix
        i: 0
        min: 12345
        name: prefix_postfix_meta_operator
        r: 1
        rest: ''
        s: 0
      min: 0
      quant:
      - '*'
      - ':'
      - ''
      - 0
    - !!perl/hash:RE_method
      a: 0
      dba: prefix or meta-prefix
      i: 0
      min: 12345
      name: ws
      nobind: 1
      r: 1
      rest: ''
      s: 0
PRE_01: *3
arglist: !!perl/hash:RE_ast
  decl:
  - !!perl/hash:RE_decl
    a: 0
    dba: arglist
    i: 0
    max: 0
    min: 0
    r: 1
    s: 0
    text: my $inv_ok = $*INVOCANT_OK
  - !!perl/hash:RE_decl
    a: 0
    dba: arglist
    i: 0
    max: 0
    min: 0
    r: 1
    s: 0
    text: my StrPos $*endargs = 0
  - !!perl/hash:RE_decl
    a: 0
    dba: arglist
    i: 0
    max: 0
    min: 0
    r: 1
    s: 0
    text: my $*GOAL ::= 'endargs'
  - !!perl/hash:RE_decl
    a: 0
    dba: arglist
    i: 0
    max: 0
    min: 0
    r: 1
    s: 0
    text: my $*QSIGIL ::= ''
  kind: token
  min: 12345
  pkg: ~
  re: !!perl/hash:RE_sequence
    a: 0
    dba: argument list
    i: 0
    min: 12345
    r: 1
    s: 0
    zyg:
    - !!perl/hash:RE_method
      a: 0
      dba: arglist
      i: 0
      min: 12345
      name: ws
      nobind: 1
      r: 1
      rest: ''
      s: 0
    - !!perl/hash:RE_bracket
      decl: []
      min: 0
      re: &4 !!perl/hash:RE_any
        a: 0
        altname: arglist_01
        dba: argument list
        i: 0
        min: 0
        name: arglist_01
        r: 1
        s: 0
        zyg:
        - !!perl/hash:RE_assertion
          alt: arglist_01 0
          assert: '?'
          min: 0
          re: !!perl/hash:RE_method
            a: 0
            dba: argument list
            i: 0
            min: 12345
            name: stdstopper
            nobind: 1
            r: 1
            rest: ''
            s: 0
        - !!perl/hash:RE_sequence
          a: 0
          alt: arglist_01 1
          dba: argument list
          i: 0
          min: 0
          r: 1
          s: 0
          zyg:
          - !!perl/hash:RE_method
            min: 0
            name: EXPR
            rest: (item %list_prefix)
          - !!perl/hash:RE_block
            a: 0
            context: void
            dba: argument list
            i: 0
            min: 0
            r: 1
            s: 0
            text: "\n                my $delims = $<EXPR><delims>;\n                for
              @$delims {\n                    if $_.<infix><wascolon> // '' {\n                        if
              $inv_ok {\n                            $*INVOCANT_IS = $<EXPR><list>[0];\n
              \                       }\n                    }\n                }\n
              \           "
arglist_01: *4
args: !!perl/hash:RE_ast
  decl:
  - !!perl/hash:RE_decl
    a: 0
    dba: args
    i: 0
    max: 0
    min: 0
    r: 1
    s: 0
    text: my $listopish = 0
  - !!perl/hash:RE_decl
    a: 0
    dba: args
    i: 0
    max: 0
    min: 0
    r: 1
    s: 0
    text: my $*GOAL ::= ''
  - !!perl/hash:RE_decl
    a: 0
    dba: args
    i: 0
    max: 0
    min: 0
    r: 1
    s: 0
    text: my $*INVOCANT_OK = 1
  - !!perl/hash:RE_decl
    a: 0
    dba: args
    i: 0
    max: 0
    min: 0
    r: 1
    s: 0
    text: my $*INVOCANT_IS
  kind: token
  min: 0
  pkg: ~
  re: !!perl/hash:RE_sequence
    a: 0
    dba: 'extra arglist after (...):'
    i: 0
    min: 0
    r: 1
    s: 0
    zyg:
    - !!perl/hash:RE_bracket
      decl: []
      min: 0
      re: &5 !!perl/hash:RE_any
        a: 0
        altname: args_01
        dba: argument list
        i: 0
        min: 0
        name: args_01
        r: 1
        s: 0
        zyg:
        - !!perl/hash:RE_sequence
          a: 0
          alt: args_01 0
          dba: argument list
          i: 0
          min: 12347
          r: 1
          s: 0
          zyg:
          - !!perl/hash:RE_string
            a: 0
            dba: argument list
            i: 0
            min: 1
            r: 1
            s: 0
            text: (
          - !!perl/hash:RE_meta
            a: 0
            dba: argument list
            extra: 'local $::GOAL = '')'' '
            i: 0
            min: 0
            r: 1
            s: 0
            text: ':'
          - !!perl/hash:RE_method
            a: 0
            dba: argument list
            i: 0
            min: 12345
            name: semiarglist
            r: 1
            rest: ''
            s: 0
          - !!perl/hash:RE_bracket
            decl: []
            min: 1
            re: !!perl/hash:RE_first
              a: 0
              dba: argument list
              i: 0
              min: 1
              r: 1
              s: 0
              zyg:
              - !!perl/hash:RE_string
                a: 0
                dba: argument list
                i: 0
                min: 1
                r: 1
                s: 0
                text: )
              - !!perl/hash:RE_method
                min: 0
                name: FAILGOAL
                nobind: 1
                rest: (')' , 'argument list')
        - !!perl/hash:RE_sequence
          a: 0
          alt: args_01 1
          dba: argument list
          i: 0
          min: 24692
          r: 1
          s: 0
          zyg:
          - !!perl/hash:RE_method
            a: 0
            dba: argument list
            i: 0
            min: 12345
            name: unsp
            nobind: 1
            r: 1
            rest: ''
            s: 0
          - !!perl/hash:RE_string
            a: 0
            dba: argument list
            i: 0
            min: 1
            r: 1
            s: 0
            text: (
          - !!perl/hash:RE_meta
            a: 0
            dba: argument list
            extra: 'local $::GOAL = '')'' '
            i: 0
            min: 0
            r: 1
            s: 0
            text: ':'
          - !!perl/hash:RE_method
            a: 0
            dba: argument list
            i: 0
            min: 12345
            name: semiarglist
            r: 1
            rest: ''
            s: 0
          - !!perl/hash:RE_bracket
            decl: []
            min: 1
            re: !!perl/hash:RE_first
              a: 0
              dba: argument list
              i: 0
              min: 1
              r: 1
              s: 0
              zyg:
              - !!perl/hash:RE_string
                a: 0
                dba: argument list
                i: 0
                min: 1
                r: 1
                s: 0
                text: )
              - !!perl/hash:RE_method
                min: 0
                name: FAILGOAL
                nobind: 1
                rest: (')' , 'argument list')
        - !!perl/hash:RE_sequence
          a: 0
          alt: args_01 2
          dba: argument list
          i: 0
          min: 0
          r: 1
          s: 0
          zyg:
          - !!perl/hash:RE_block
            a: 0
            context: void
            dba: argument list
            i: 0
            min: 0
            r: 1
            s: 0
            text: ' $listopish = 1 '
          - !!perl/hash:RE_quantified_atom
            atom: !!perl/hash:RE_bracket
              decl: []
              min: 24690
              re: !!perl/hash:RE_sequence
                a: 0
                dba: argument list
                i: 0
                min: 24690
                r: 1
                s: 0
                zyg:
                - !!perl/hash:RE_assertion
                  assert: '?'
                  min: 0
                  re: !!perl/hash:RE_method_re
                    a: 0
                    dba: argument list
                    i: 0
                    min: 0
                    name: before
                    nobind: 1
                    r: 1
                    re: !!perl/hash:RE_ast
                      decl: []
                      min: 1
                      re: !!perl/hash:RE_meta
                        a: 0
                        dba: argument list
                        i: 0
                        min: 1
                        r: 1
                        s: 0
                        text: \s
                    s: 0
                - !!perl/hash:RE_assertion
                  assert: '!'
                  min: 0
                  re: !!perl/hash:RE_block
                    a: 0
                    context: bool
                    dba: argument list
                    i: 0
                    min: 0
                    nobind: 1
                    r: 1
                    s: 0
                    text: ' $istype '
                - !!perl/hash:RE_method
                  a: 0
                  dba: argument list
                  i: 0
                  min: 12345
                  name: ws
                  nobind: 1
                  r: 1
                  rest: ''
                  s: 0
                - !!perl/hash:RE_assertion
                  assert: '!'
                  min: 0
                  re: !!perl/hash:RE_method
                    a: 0
                    dba: argument list
                    i: 0
                    min: 12345
                    name: infixstopper
                    nobind: 1
                    r: 1
                    rest: ''
                    s: 0
                - !!perl/hash:RE_method
                  a: 0
                  dba: argument list
                  i: 0
                  min: 12345
                  name: arglist
                  r: 1
                  rest: ''
                  s: 0
            min: 0
            quant:
            - '?'
            - ':'
            - ''
            - 0
    - !!perl/hash:RE_block
      a: 0
      context: void
      dba: args
      i: 0
      min: 0
      r: 1
      s: 0
      text: ' $<invocant> = $*INVOCANT_IS; '
    - !!perl/hash:RE_bracket
      decl: []
      min: 0
      re: !!perl/hash:RE_first
        a: 0
        dba: 'extra arglist after (...):'
        i: 0
        min: 0
        r: 1
        s: 0
        zyg:
        - !!perl/hash:RE_assertion
          assert: '?'
          min: 0
          re: !!perl/hash:RE_block
            a: 0
            context: bool
            dba: 'extra arglist after (...):'
            i: 0
            min: 0
            nobind: 1
            r: 1
            s: 0
            text: ' $listopish '
        - !!perl/hash:RE_sequence
          a: 0
          dba: 'extra arglist after (...):'
          i: 0
          min: 12346
          r: 1
          s: 0
          zyg:
          - !!perl/hash:RE_string
            a: 0
            dba: 'extra arglist after (...):'
            i: 0
            min: 1
            r: 1
            s: 0
            text: ':'
          - !!perl/hash:RE_assertion
            assert: '?'
            min: 0
            re: !!perl/hash:RE_method_re
              a: 0
              dba: 'extra arglist after (...):'
              i: 0
              min: 0
              name: before
              nobind: 1
              r: 1
              re: !!perl/hash:RE_ast
                decl: []
                min: 1
                re: !!perl/hash:RE_meta
                  a: 0
                  dba: 'extra arglist after (...):'
                  i: 0
                  min: 1
                  r: 1
                  s: 0
                  text: \s
              s: 0
          - !!perl/hash:RE_bindnamed
            a: 0
            atom: !!perl/hash:RE_method
              a: 0
              dba: 'extra arglist after (...):'
              i: 0
              min: 12345
              name: arglist
              nobind: 1
              r: 1
              rest: ''
              s: 0
            dba: 'extra arglist after (...):'
            i: 0
            min: 12345
            r: 1
            s: 0
            var: moreargs
        - !!perl/hash:RE_block
          a: 0
          context: void
          dba: 'extra arglist after (...):'
          i: 0
          min: 0
          r: 1
          s: 0
          text: ' $<O> = {}; '
args_01: *5
blast: !!perl/hash:RE_ast
  decl: []
  kind: token
  min: 24690
  pkg: ~
  re: !!perl/hash:RE_sequence
    a: 0
    dba: blast
    i: 0
    min: 24690
    r: 1
    s: 0
    zyg:
    - !!perl/hash:RE_assertion
      assert: '?'
      min: 0
      re: !!perl/hash:RE_method_re
        a: 0
        dba: blast
        i: 0
        min: 0
        name: before
        nobind: 1
        r: 1
        re: !!perl/hash:RE_ast
          decl: []
          min: 1
          re: !!perl/hash:RE_meta
            a: 0
            dba: blast
            i: 0
            min: 1
            r: 1
            s: 0
            text: \s
        s: 0
    - !!perl/hash:RE_method
      a: 0
      dba: blast
      i: 0
      min: 12345
      name: ws
      nobind: 1
      r: 1
      rest: ''
      s: 0
    - !!perl/hash:RE_bracket
      decl: []
      min: 12345
      re: &6 !!perl/hash:RE_any
        a: 0
        altname: blast_02
        dba: blast
        i: 0
        min: 12345
        name: blast_02
        r: 1
        s: 0
        zyg:
        - !!perl/hash:RE_method
          a: 0
          alt: blast_02 0
          dba: blast
          i: 0
          min: 12345
          name: block
          r: 1
          rest: ''
          s: 0
        - !!perl/hash:RE_method
          a: 0
          alt: blast_02 1
          dba: blast
          i: 0
          min: 12345
          name: statement
          r: 1
          rest: ''
          s: 0
blast_02: *6
block: !!perl/hash:RE_ast
  decl:
  - !!perl/hash:RE_decl
    a: 0
    dba: block
    i: 0
    max: 0
    min: 0
    r: 1
    s: 0
    text: temp $*CURPAD
  kind: token
  min: 37035
  pkg: ~
  re: !!perl/hash:RE_sequence
    a: 0
    dba: scoped block
    i: 0
    min: 37035
    r: 1
    s: 0
    zyg:
    - !!perl/hash:RE_bracket
      decl: []
      min: 0
      re: !!perl/hash:RE_first
        a: 0
        dba: scoped block
        i: 0
        min: 0
        r: 1
        s: 0
        zyg:
        - !!perl/hash:RE_assertion
          assert: '?'
          min: 0
          re: !!perl/hash:RE_method_re
            a: 0
            dba: scoped block
            i: 0
            min: 0
            name: before
            nobind: 1
            r: 1
            re: !!perl/hash:RE_ast
              decl: []
              min: 1
              re: !!perl/hash:RE_string
                a: 0
                dba: scoped block
                i: 0
                min: 1
                r: 1
                s: 0
                text: '{'
            s: 0
        - !!perl/hash:RE_method
          min: 0
          name: panic
          nobind: 1
          rest: ("Missing block")
    - !!perl/hash:RE_method
      a: 0
      dba: scoped block
      i: 0
      min: 12345
      name: newpad
      nobind: 1
      r: 1
      rest: ''
      s: 0
    - !!perl/hash:RE_method
      a: 0
      dba: scoped block
      i: 0
      min: 12345
      name: blockoid
      r: 1
      rest: ''
      s: 0
    - !!perl/hash:RE_method
      a: 0
      dba: scoped block
      i: 0
      min: 12345
      name: checkyada
      nobind: 1
      r: 1
      rest: ''
      s: 0
blockoid: !!perl/hash:RE_ast
  decl:
  - !!perl/hash:RE_decl
    a: 0
    dba: blockoid
    i: 0
    max: 0
    min: 0
    r: 1
    s: 0
    text: temp %*LANG
  - !!perl/hash:RE_decl
    a: 0
    dba: blockoid
    i: 0
    max: 0
    min: 0
    r: 1
    s: 0
    text: my $*SIGNUM
  kind: token
  min: 12345
  pkg: ~
  re: !!perl/hash:RE_sequence
    a: 0
    dba: blockoid
    i: 0
    min: 12345
    r: 1
    s: 0
    zyg:
    - !!perl/hash:RE_method
      a: 0
      dba: blockoid
      i: 0
      min: 12345
      name: finishpad
      nobind: 1
      r: 1
      rest: ''
      s: 0
    - !!perl/hash:RE_bracket
      decl: []
      min: 0
      re: &7 !!perl/hash:RE_any
        a: 0
        altname: blockoid_01
        dba: block
        i: 0
        min: 0
        name: blockoid_01
        r: 1
        s: 0
        zyg:
        - !!perl/hash:RE_sequence
          a: 0
          alt: blockoid_01 0
          dba: block
          i: 0
          min: 24692
          r: 1
          s: 0
          zyg:
          - !!perl/hash:RE_string
            a: 0
            dba: block
            i: 0
            min: 1
            r: 1
            s: 0
            text: '{'
          - !!perl/hash:RE_meta
            a: 0
            dba: block
            extra: 'local $::GOAL = ''}'' '
            i: 0
            min: 0
            r: 1
            s: 0
            text: ':'
          - !!perl/hash:RE_method
            a: 0
            dba: block
            i: 0
            min: 12345
            name: statementlist
            r: 1
            rest: ''
            s: 0
          - !!perl/hash:RE_bracket
            decl: []
            min: 1
            re: !!perl/hash:RE_first
              a: 0
              dba: block
              i: 0
              min: 1
              r: 1
              s: 0
              zyg:
              - !!perl/hash:RE_string
                a: 0
                dba: block
                i: 0
                min: 1
                r: 1
                s: 0
                text: '}'
              - !!perl/hash:RE_method
                min: 0
                name: FAILGOAL
                nobind: 1
                rest: ('}' , 'block')
          - !!perl/hash:RE_meta
            a: 0
            dba: block
            i: 0
            min: 0
            r: 1
            s: 0
            text: '::'
          - !!perl/hash:RE_method
            a: 0
            dba: block
            i: 0
            min: 12345
            name: curlycheck
            nobind: 1
            r: 1
            rest: ''
            s: 0
        - !!perl/hash:RE_sequence
          a: 0
          alt: blockoid_01 1
          dba: block
          i: 0
          min: 0
          r: 1
          s: 0
          zyg:
          - !!perl/hash:RE_assertion
            assert: '?'
            min: 0
            re: !!perl/hash:RE_method
              a: 0
              dba: block
              i: 0
              min: 12345
              name: terminator
              nobind: 1
              r: 1
              rest: ''
              s: 0
          - !!perl/hash:RE_method
            min: 0
            name: panic
            nobind: 1
            rest: ('Missing block')
        - !!perl/hash:RE_sequence
          a: 0
          alt: blockoid_01 2
          dba: block
          i: 0
          min: 0
          r: 1
          s: 0
          zyg:
          - !!perl/hash:RE_assertion
            assert: '?'
            min: 0
            re: !!perl/hash:RE_noop
              a: 0
              dba: block
              i: 0
              min: 0
              nobind: 1
              r: 1
              s: 0
          - !!perl/hash:RE_method
            min: 0
            name: panic
            nobind: 1
            rest: ("Malformed block")
blockoid_01: *7
capterm: !!perl/hash:RE_ast
  decl: []
  kind: token
  min: 1
  pkg: ~
  re: !!perl/hash:RE_sequence
    a: 0
    dba: capterm
    i: 0
    min: 1
    r: 1
    s: 0
    zyg:
    - !!perl/hash:RE_string
      a: 0
      dba: capterm
      i: 0
      min: 1
      r: 1
      s: 0
      text: \
    - !!perl/hash:RE_bracket
      decl: []
      min: 0
      re: &8 !!perl/hash:RE_any
        a: 0
        altname: capterm_01
        dba: capterm
        i: 0
        min: 0
        name: capterm_01
        r: 1
        s: 0
        zyg:
        - !!perl/hash:RE_sequence
          a: 0
          alt: capterm_01 0
          dba: capterm
          i: 0
          min: 2
          r: 1
          s: 0
          zyg:
          - !!perl/hash:RE_string
            a: 0
            dba: capterm
            i: 0
            min: 1
            r: 1
            s: 0
            text: (
          - !!perl/hash:RE_quantified_atom
            atom: !!perl/hash:RE_method
              a: 0
              dba: capterm
              i: 0
              min: 12345
              name: capture
              r: 1
              rest: ''
              s: 0
            min: 0
            quant:
            - '?'
            - ':'
            - ''
            - 0
          - !!perl/hash:RE_string
            a: 0
            dba: capterm
            i: 0
            min: 1
            r: 1
            s: 0
            text: )
        - !!perl/hash:RE_sequence
          a: 0
          alt: capterm_01 1
          dba: capterm
          i: 0
          min: 12345
          r: 1
          s: 0
          zyg:
          - !!perl/hash:RE_assertion
            assert: '?'
            min: 0
            re: !!perl/hash:RE_method_re
              a: 0
              dba: capterm
              i: 0
              min: 0
              name: before
              nobind: 1
              r: 1
              re: !!perl/hash:RE_ast
                decl: []
                min: 1
                re: !!perl/hash:RE_meta
                  a: 0
                  dba: capterm
                  i: 0
                  min: 1
                  r: 1
                  s: 0
                  text: \S
              s: 0
          - !!perl/hash:RE_method
            a: 0
            dba: capterm
            i: 0
            min: 12345
            name: termish
            r: 1
            rest: ''
            s: 0
        - !!perl/hash:RE_sequence
          a: 0
          alt: capterm_01 2
          dba: capterm
          i: 0
          min: 0
          r: 1
          s: 0
          zyg:
          - !!perl/hash:RE_block
            a: 0
            context: void
            dba: capterm
            i: 0
            min: 0
            r: 1
            s: 0
            text: ''
          - !!perl/hash:RE_method
            min: 0
            name: panic
            nobind: 1
            rest: ("You can't backslash that")
capterm_01: *8
capture: !!perl/hash:RE_ast
  decl:
  - !!perl/hash:RE_decl
    a: 0
    dba: capture
    i: 0
    max: 0
    min: 0
    r: 1
    s: 1
    text: my $*INVOCANT_OK = 1
  kind: rule
  min: 12345
  pkg: ~
  re: !!perl/hash:RE_sequence
    a: 0
    dba: capture
    i: 0
    min: 12345
    r: 1
    s: 1
    zyg:
    - !!perl/hash:RE_method
      min: 0
      name: ws
      nobind: 1
      noquant: 1
      rest: ''
    - !!perl/hash:RE_method
      a: 0
      dba: capture
      i: 0
      min: 12345
      name: EXPR
      r: 1
      rest: ''
      s: 1
    - !!perl/hash:RE_method
      min: 0
      name: ws
      nobind: 1
      noquant: 1
      rest: ''
circumfix__S_252sigil: !!perl/hash:RE_ast
  decl: []
  kind: token
  min: 24692
  pkg: ~
  re: !!perl/hash:RE_sequence
    a: 0
    dba: contextualizer
    i: 0
    min: 24692
    r: 1
    s: 0
    zyg:
    - !!perl/hash:RE_method
      a: 0
      dba: contextualizer
      i: 0
      min: 12345
      name: sigil
      r: 1
      rest: ''
      s: 0
    - !!perl/hash:RE_string
      a: 0
      dba: contextualizer
      i: 0
      min: 1
      r: 1
      s: 0
      text: (
    - !!perl/hash:RE_meta
      a: 0
      dba: contextualizer
      extra: 'local $::GOAL = '')'' '
      i: 0
      min: 0
      r: 1
      s: 0
      text: ':'
    - !!perl/hash:RE_method
      a: 0
      dba: contextualizer
      i: 0
      min: 12345
      name: semilist
      r: 1
      rest: ''
      s: 0
    - !!perl/hash:RE_bracket
      decl: []
      min: 1
      re: !!perl/hash:RE_first
        a: 0
        dba: contextualizer
        i: 0
        min: 1
        r: 1
        s: 0
        zyg:
        - !!perl/hash:RE_string
          a: 0
          dba: contextualizer
          i: 0
          min: 1
          r: 1
          s: 0
          text: )
        - !!perl/hash:RE_method
          min: 0
          name: FAILGOAL
          nobind: 1
          rest: (')' , 'contextualizer')
    - !!perl/hash:RE_block
      a: 0
      context: void
      dba: contextualizer
      i: 0
      min: 0
      r: 1
      s: 0
      text: ' $*LEFTSIGIL ||= $<sigil>.Str '
    - !!perl/hash:RE_method
      min: 0
      name: O
      rest: (|%term)
circumfix__S_253Paren_Thesis: !!perl/hash:RE_ast
  decl: []
  kind: token
  min: 12347
  pkg: ~
  re: !!perl/hash:RE_sequence
    a: 0
    dba: parenthesized expression
    i: 0
    min: 12347
    r: 1
    s: 0
    zyg:
    - !!perl/hash:RE_string
      a: 0
      dba: parenthesized expression
      i: 0
      min: 1
      r: 1
      s: 0
      text: (
    - !!perl/hash:RE_meta
      a: 0
      dba: parenthesized expression
      extra: 'local $::GOAL = '')'' '
      i: 0
      min: 0
      r: 1
      s: 0
      text: ':'
    - !!perl/hash:RE_method
      a: 0
      dba: parenthesized expression
      i: 0
      min: 12345
      name: semilist
      r: 1
      rest: ''
      s: 0
    - !!perl/hash:RE_bracket
      decl: []
      min: 1
      re: !!perl/hash:RE_first
        a: 0
        dba: parenthesized expression
        i: 0
        min: 1
        r: 1
        s: 0
        zyg:
        - !!perl/hash:RE_string
          a: 0
          dba: parenthesized expression
          i: 0
          min: 1
          r: 1
          s: 0
          text: )
        - !!perl/hash:RE_method
          min: 0
          name: FAILGOAL
          nobind: 1
          rest: (')' , 'parenthesized expression')
    - !!perl/hash:RE_method
      min: 0
      name: O
      rest: (|%term)
circumfix__S_254Bra_Ket: !!perl/hash:RE_ast
  decl: []
  kind: token
  min: 12347
  pkg: ~
  re: !!perl/hash:RE_sequence
    a: 0
    dba: array composer
    i: 0
    min: 12347
    r: 1
    s: 0
    zyg:
    - !!perl/hash:RE_string
      a: 0
      dba: array composer
      i: 0
      min: 1
      r: 1
      s: 0
      text: '['
    - !!perl/hash:RE_meta
      a: 0
      dba: array composer
      extra: 'local $::GOAL = '']'' '
      i: 0
      min: 0
      r: 1
      s: 0
      text: ':'
    - !!perl/hash:RE_method
      a: 0
      dba: array composer
      i: 0
      min: 12345
      name: semilist
      r: 1
      rest: ''
      s: 0
    - !!perl/hash:RE_bracket
      decl: []
      min: 1
      re: !!perl/hash:RE_first
        a: 0
        dba: array composer
        i: 0
        min: 1
        r: 1
        s: 0
        zyg:
        - !!perl/hash:RE_string
          a: 0
          dba: array composer
          i: 0
          min: 1
          r: 1
          s: 0
          text: ']'
        - !!perl/hash:RE_method
          min: 0
          name: FAILGOAL
          nobind: 1
          rest: (']' , 'array composer')
    - !!perl/hash:RE_method
      min: 0
      name: O
      rest: (|%term)
    - !!perl/hash:RE_block
      a: 0
      context: void
      dba: array composer
      i: 0
      min: 0
      r: 1
      s: 0
      text: ' @*MEMOS[$.pos]<arraycomp> = 1; '
circumfix__S_275Cur_Ly: !!perl/hash:RE_ast
  decl: []
  kind: token
  min: 12345
  pkg: ~
  re: !!perl/hash:RE_sequence
    a: 0
    dba: circumfix__S_275Cur_Ly
    i: 0
    min: 12345
    r: 1
    s: 0
    zyg:
    - !!perl/hash:RE_assertion
      assert: '?'
      min: 0
      re: !!perl/hash:RE_method_re
        a: 0
        dba: circumfix__S_275Cur_Ly
        i: 0
        min: 0
        name: before
        nobind: 1
        r: 1
        re: !!perl/hash:RE_ast
          decl: []
          min: 1
          re: !!perl/hash:RE_string
            a: 0
            dba: circumfix__S_275Cur_Ly
            i: 0
            min: 1
            r: 1
            s: 0
            text: '{'
        s: 0
    - !!perl/hash:RE_method
      a: 0
      dba: circumfix__S_275Cur_Ly
      i: 0
      min: 12345
      name: pblock
      r: 1
      rest: ''
      s: 0
    - !!perl/hash:RE_block
      a: 0
      context: void
      dba: circumfix__S_275Cur_Ly
      i: 0
      min: 0
      r: 1
      s: 0
      text: "\n            if $*BORG {\n                $*BORG.<block> = $<pblock>;\n
        \           }\n        "
    - !!perl/hash:RE_method
      min: 0
      name: O
      rest: (|%term)
colonpair: !!perl/hash:RE_ast
  decl:
  - !!perl/hash:RE_decl
    a: 0
    dba: colonpair
    i: 0
    max: 0
    min: 0
    r: 1
    s: 0
    text: my $key
  - !!perl/hash:RE_decl
    a: 0
    dba: colonpair
    i: 0
    max: 0
    min: 0
    r: 1
    s: 0
    text: my $value
  kind: token
  min: 12346
  pkg: ~
  re: !!perl/hash:RE_sequence
    a: 0
    dba: colon pair
    i: 0
    min: 12346
    r: 1
    s: 0
    zyg:
    - !!perl/hash:RE_string
      a: 0
      dba: colonpair
      i: 0
      min: 1
      r: 1
      s: 0
      text: ':'
    - !!perl/hash:RE_bracket
      decl: []
      min: 12345
      re: &9 !!perl/hash:RE_any
        a: 0
        altname: colonpair_01
        dba: signature
        i: 0
        min: 12345
        name: colonpair_01
        r: 1
        s: 0
        zyg:
        - !!perl/hash:RE_sequence
          a: 0
          alt: colonpair_01 0
          dba: colon pair
          i: 0
          min: 12346
          r: 1
          s: 0
          zyg:
          - !!perl/hash:RE_string
            a: 0
            dba: colon pair
            i: 0
            min: 1
            r: 1
            s: 0
            text: '!'
          - !!perl/hash:RE_method
            a: 0
            dba: colon pair
            i: 0
            min: 12345
            name: identifier
            r: 1
            rest: ''
            s: 0
          - !!perl/hash:RE_quantified_atom
            atom: !!perl/hash:RE_bracket
              decl: []
              min: 1
              re: !!perl/hash:RE_sequence
                a: 0
                dba: colon pair
                i: 0
                min: 1
                r: 1
                s: 0
                zyg:
                - !!perl/hash:RE_cclass
                  a: 0
                  dba: colon pair
                  i: 0
                  min: 1
                  r: 1
                  s: 0
                  text: '[ \[ \( \< \{ ]'
                - !!perl/hash:RE_method
                  min: 0
                  name: panic
                  nobind: 1
                  rest: ("Argument not allowed on negated pair")
            min: 0
            quant:
            - '?'
            - ':'
            - ''
            - 0
          - !!perl/hash:RE_block
            a: 0
            context: void
            dba: colon pair
            i: 0
            min: 0
            r: 1
            s: 0
            text: ' $key = $<identifier>.Str; $value = 0; '
        - !!perl/hash:RE_sequence
          a: 0
          alt: colonpair_01 1
          dba: colon pair
          i: 0
          min: 12346
          r: 1
          s: 0
          zyg:
          - !!perl/hash:RE_bindnamed
            a: 0
            atom: !!perl/hash:RE_bracket
              decl: []
              min: 1
              re: !!perl/hash:RE_quantified_atom
                atom: !!perl/hash:RE_meta
                  a: 0
                  dba: colon pair
                  i: 0
                  min: 1
                  r: 1
                  s: 0
                  text: \d
                min: 1
                quant:
                - +
                - ':'
                - ''
                - 1
            dba: colon pair
            i: 0
            min: 1
            r: 1
            s: 0
            var: num
          - !!perl/hash:RE_method
            a: 0
            dba: colon pair
            i: 0
            min: 12345
            name: identifier
            r: 1
            rest: ''
            s: 0
          - !!perl/hash:RE_quantified_atom
            atom: !!perl/hash:RE_bracket
              decl: []
              min: 1
              re: !!perl/hash:RE_sequence
                a: 0
                dba: colon pair
                i: 0
                min: 1
                r: 1
                s: 0
                zyg:
                - !!perl/hash:RE_cclass
                  a: 0
                  dba: colon pair
                  i: 0
                  min: 1
                  r: 1
                  s: 0
                  text: '[ \[ \( \< \{ ]'
                - !!perl/hash:RE_method
                  min: 0
                  name: panic
                  nobind: 1
                  rest: ("2nd argument not allowed on pair")
            min: 0
            quant:
            - '?'
            - ':'
            - ''
            - 0
        - !!perl/hash:RE_sequence
          a: 0
          alt: colonpair_01 2
          dba: colon pair
          i: 0
          min: 12345
          r: 1
          s: 0
          zyg:
          - !!perl/hash:RE_method
            a: 0
            dba: colon pair
            i: 0
            min: 12345
            name: identifier
            r: 1
            rest: ''
            s: 0
          - !!perl/hash:RE_block
            a: 0
            context: void
            dba: colon pair
            i: 0
            min: 0
            r: 1
            s: 0
            text: ' $key = $<identifier>.Str; '
          - !!perl/hash:RE_bracket
            decl: []
            min: 0
            re: !!perl/hash:RE_first
              a: 0
              dba: pair value
              i: 0
              min: 0
              r: 1
              s: 0
              zyg:
              - !!perl/hash:RE_sequence
                a: 0
                dba: pair value
                i: 0
                min: 12345
                r: 1
                s: 0
                zyg:
                - !!perl/hash:RE_quantified_atom
                  atom: !!perl/hash:RE_method
                    a: 0
                    dba: colon pair
                    i: 0
                    min: 12345
                    name: unsp
                    nobind: 1
                    r: 1
                    rest: ''
                    s: 0
                  min: 0
                  quant:
                  - '?'
                  - ':'
                  - ''
                  - 0
                - !!perl/hash:RE_method
                  a: 0
                  dba: pair value
                  i: 0
                  min: 12345
                  name: circumfix
                  r: 1
                  rest: ''
                  s: 0
                - !!perl/hash:RE_block
                  a: 0
                  context: void
                  dba: pair value
                  i: 0
                  min: 0
                  r: 1
                  s: 0
                  text: ' $value = $<circumfix>; '
              - !!perl/hash:RE_block
                a: 0
                context: void
                dba: pair value
                i: 0
                min: 0
                r: 1
                s: 0
                text: ' $value = 1; '
        - !!perl/hash:RE_sequence
          a: 0
          alt: colonpair_01 3
          dba: signature
          i: 0
          min: 12347
          r: 1
          s: 0
          zyg:
          - !!perl/hash:RE_string
            a: 0
            dba: signature
            i: 0
            min: 1
            r: 1
            s: 0
            text: (
          - !!perl/hash:RE_meta
            a: 0
            dba: signature
            extra: 'local $::GOAL = '')'' '
            i: 0
            min: 0
            r: 1
            s: 0
            text: ':'
          - !!perl/hash:RE_method
            a: 0
            dba: signature
            i: 0
            min: 12345
            name: fakesignature
            r: 1
            rest: ''
            s: 0
          - !!perl/hash:RE_bracket
            decl: []
            min: 1
            re: !!perl/hash:RE_first
              a: 0
              dba: signature
              i: 0
              min: 1
              r: 1
              s: 0
              zyg:
              - !!perl/hash:RE_string
                a: 0
                dba: signature
                i: 0
                min: 1
                r: 1
                s: 0
                text: )
              - !!perl/hash:RE_method
                min: 0
                name: FAILGOAL
                nobind: 1
                rest: (')' , 'signature')
        - !!perl/hash:RE_sequence
          a: 0
          alt: colonpair_01 4
          dba: signature
          i: 0
          min: 12345
          r: 1
          s: 0
          zyg:
          - !!perl/hash:RE_method
            a: 0
            dba: signature
            i: 0
            min: 12345
            name: circumfix
            r: 1
            rest: ''
            s: 0
          - !!perl/hash:RE_block
            a: 0
            context: void
            dba: signature
            i: 0
            min: 0
            r: 1
            s: 0
            text: ' $key = ""; $value = $<circumfix>; '
        - !!perl/hash:RE_sequence
          a: 0
          alt: colonpair_01 5
          dba: signature
          i: 0
          min: 24690
          r: 1
          s: 0
          zyg:
          - !!perl/hash:RE_bindnamed
            a: 0
            atom: !!perl/hash:RE_paren
              decl: []
              min: 24690
              re: !!perl/hash:RE_sequence
                a: 0
                dba: signature
                i: 0
                min: 24690
                r: 1
                s: 0
                zyg:
                - !!perl/hash:RE_method
                  a: 0
                  dba: signature
                  i: 0
                  min: 12345
                  name: sigil
                  r: 1
                  rest: ''
                  s: 0
                - !!perl/hash:RE_block
                  a: 0
                  context: void
                  dba: signature
                  i: 0
                  min: 0
                  r: 1
                  s: 0
                  text: ''
                - !!perl/hash:RE_quantified_atom
                  atom: !!perl/hash:RE_method
                    a: 0
                    dba: signature
                    i: 0
                    min: 12345
                    name: twigil
                    r: 1
                    rest: ''
                    s: 0
                  min: 0
                  quant:
                  - '?'
                  - ':'
                  - ''
                  - 0
                - !!perl/hash:RE_method
                  a: 0
                  dba: signature
                  i: 0
                  min: 12345
                  name: desigilname
                  r: 1
                  rest: ''
                  s: 0
            dba: signature
            i: 0
            min: 24690
            r: 1
            s: 0
            var: var
          - !!perl/hash:RE_block
            a: 0
            context: void
            dba: signature
            i: 0
            min: 0
            r: 1
            s: 0
            text: ' $key = $<var><desigilname>.Str; $value = $<var>; '
    - !!perl/hash:RE_block
      a: 0
      context: void
      dba: colon pair
      i: 0
      min: 0
      r: 1
      s: 0
      text: ' $<k> = $key; $<v> = $value; '
colonpair_01: *9
comp_unit: !!perl/hash:RE_ast
  decl:
  - !!perl/hash:RE_decl
    a: 0
    dba: comp_unit
    i: 0
    max: 0
    min: 0
    r: 1
    s: 1
    text: my $*begin_compunit = 1
  - !!perl/hash:RE_decl
    a: 0
    dba: comp_unit
    i: 0
    max: 0
    min: 0
    r: 1
    s: 1
    text: my $*endargs = -1
  - !!perl/hash:RE_decl
    a: 0
    dba: comp_unit
    i: 0
    max: 0
    min: 0
    r: 1
    s: 1
    text: my %*LANG
  - !!perl/hash:RE_decl
    a: 0
    dba: comp_unit
    i: 0
    max: 0
    min: 0
    r: 1
    s: 1
    text: my $*PKGDECL ::= ""
  - !!perl/hash:RE_decl
    a: 0
    dba: comp_unit
    i: 0
    max: 0
    min: 0
    r: 1
    s: 1
    text: my $*IN_DECL = ''
  - !!perl/hash:RE_decl
    a: 0
    dba: comp_unit
    i: 0
    max: 0
    min: 0
    r: 1
    s: 1
    text: my $*DECLARAND
  - !!perl/hash:RE_decl
    a: 0
    dba: comp_unit
    i: 0
    max: 0
    min: 0
    r: 1
    s: 1
    text: my $*NEWPKG
  - !!perl/hash:RE_decl
    a: 0
    dba: comp_unit
    i: 0
    max: 0
    min: 0
    r: 1
    s: 1
    text: my $*NEWPAD
  - !!perl/hash:RE_decl
    a: 0
    dba: comp_unit
    i: 0
    max: 0
    min: 0
    r: 1
    s: 1
    text: my $*QSIGIL ::= ''
  - !!perl/hash:RE_decl
    a: 0
    dba: comp_unit
    i: 0
    max: 0
    min: 0
    r: 1
    s: 1
    text: my $*IN_META = 0
  - !!perl/hash:RE_decl
    a: 0
    dba: comp_unit
    i: 0
    max: 0
    min: 0
    r: 1
    s: 1
    text: my $*QUASIMODO
  - !!perl/hash:RE_decl
    a: 0
    dba: comp_unit
    i: 0
    max: 0
    min: 0
    r: 1
    s: 1
    text: my $*SCOPE = ""
  - !!perl/hash:RE_decl
    a: 0
    dba: comp_unit
    i: 0
    max: 0
    min: 0
    r: 1
    s: 1
    text: my $*LEFTSIGIL
  - !!perl/hash:RE_decl
    a: 0
    dba: comp_unit
    i: 0
    max: 0
    min: 0
    r: 1
    s: 1
    text: my $*PRECLIM
  - !!perl/hash:RE_decl
    a: 0
    dba: comp_unit
    i: 0
    max: 0
    min: 0
    r: 1
    s: 1
    text: my %*MYSTERY = ()
  - !!perl/hash:RE_decl
    a: 0
    dba: comp_unit
    i: 0
    max: 0
    min: 0
    r: 1
    s: 1
    text: my $*INVOCANT_OK
  - !!perl/hash:RE_decl
    a: 0
    dba: comp_unit
    i: 0
    max: 0
    min: 0
    r: 1
    s: 1
    text: my $*INVOCANT_IS
  - !!perl/hash:RE_decl
    a: 0
    dba: comp_unit
    i: 0
    max: 0
    min: 0
    r: 1
    s: 1
    text: my $*CURPAD
  - !!perl/hash:RE_decl
    a: 0
    dba: comp_unit
    i: 0
    max: 0
    min: 0
    r: 1
    s: 1
    text: my $*MULTINESS = ''
  - !!perl/hash:RE_decl
    a: 0
    dba: comp_unit
    i: 0
    max: 0
    min: 0
    r: 1
    s: 1
    text: my $*SIGNUM = 0
  - !!perl/hash:RE_decl
    a: 0
    dba: comp_unit
    i: 0
    max: 0
    min: 0
    r: 1
    s: 1
    text: my $*MONKEY_TYPING = False
  - !!perl/hash:RE_decl
    a: 0
    dba: comp_unit
    i: 0
    max: 0
    min: 0
    r: 1
    s: 1
    text: my $*CURPKG
  kind: rule
  min: 12345
  pkg: ~
  re: !!perl/hash:RE_sequence
    a: 0
    dba: comp_unit
    i: 0
    min: 12345
    r: 1
    s: 1
    zyg:
    - !!perl/hash:RE_method
      min: 0
      name: ws
      nobind: 1
      noquant: 1
      rest: ''
    - !!perl/hash:RE_block
      a: 0
      context: void
      dba: comp_unit
      i: 0
      min: 0
      r: 1
      s: 1
      text: "\n\n            %*LANG<MAIN>    = ::STD::P6 ;\n            %*LANG<Q>
        \      = ::STD::Q ;\n            %*LANG<Quasi>   = ::STD::Quasi ;\n            %*LANG<Regex>
        \  = ::STD::Regex ;\n            %*LANG<Trans>   = ::STD::Trans ;\n            %*LANG<P5>
        \     = ::STD::P5 ;\n            %*LANG<P5Regex> = ::STD::P5::Regex ;\n\n
        \           @*WORRIES = ();\n            self.load_setting($*SETTINGNAME);\n
        \           my $oid = $*SETTING.id;\n            my $id = 'MY:file<' ~ $*FILE<name>
        ~ '>';\n            $*CURPAD = Stash.new(\n                'OUTER::' => [$oid],\n
        \               '!file' => $*FILE, '!line' => 0,\n                '!id' =>
        [$id],\n            );\n            $ALL.{$id} = $*CURPAD;\n            $*UNIT
        = $*CURPAD;\n            $ALL.<UNIT> = $*UNIT;\n            self.finishpad;\n
        \           # $ = self.cursor_fresh($*CURPAD<$?LANGNAME>);\n        "
    - !!perl/hash:RE_method
      min: 0
      name: ws
      nobind: 1
      noquant: 1
      rest: ''
    - !!perl/hash:RE_method
      a: 0
      dba: comp_unit
      i: 0
      min: 12345
      name: statementlist
      r: 1
      rest: ''
      s: 1
    - !!perl/hash:RE_method
      min: 0
      name: ws
      nobind: 1
      noquant: 1
      rest: ''
    - !!perl/hash:RE_bracket
      decl: []
      min: 0
      re: !!perl/hash:RE_first
        a: 0
        dba: comp_unit
        i: 0
        min: 0
        r: 1
        s: 1
        zyg:
        - !!perl/hash:RE_sequence
          a: 0
          dba: comp_unit
          i: 0
          min: 0
          r: 1
          s: 1
          zyg:
          - !!perl/hash:RE_assertion
            assert: '?'
            min: 0
            re: !!perl/hash:RE_method
              a: 0
              dba: comp_unit
              i: 0
              min: 12345
              name: unitstopper
              nobind: 1
              r: 1
              rest: ''
              s: 1
          - !!perl/hash:RE_method
            min: 0
            name: ws
            nobind: 1
            noquant: 1
            rest: ''
        - !!perl/hash:RE_sequence
          a: 0
          dba: comp_unit
          i: 0
          min: 0
          r: 1
          s: 1
          zyg:
          - !!perl/hash:RE_method
            min: 0
            name: panic
            nobind: 1
            rest: ("Confused")
          - !!perl/hash:RE_method
            min: 0
            name: ws
            nobind: 1
            noquant: 1
            rest: ''
    - !!perl/hash:RE_method
      min: 0
      name: ws
      nobind: 1
      noquant: 1
      rest: ''
    - !!perl/hash:RE_block
      a: 0
      context: void
      dba: comp_unit
      i: 0
      min: 0
      r: 1
      s: 1
      text: "\n            if @*WORRIES {\n                warn \"Potential difficulties:\\n
        \ \" ~ join( \"\\n  \", @*WORRIES) ~ \"\\n\";\n            }\n            my
        $m = $.explain_mystery();\n            warn $m if $m;\n        "
    - !!perl/hash:RE_method
      min: 0
      name: ws
      nobind: 1
      noquant: 1
      rest: ''
curlycheck: !!perl/hash:RE_ast
  decl: []
  kind: token
  min: 0
  pkg: ~
  re: !!perl/hash:RE_bracket
    decl: []
    min: 0
    re: !!perl/hash:RE_first
      a: 0
      dba: curlycheck
      i: 0
      min: 0
      r: 1
      s: 0
      zyg:
      - !!perl/hash:RE_sequence
        a: 0
        dba: curlycheck
        i: 0
        min: 0
        r: 1
        s: 0
        zyg:
        - !!perl/hash:RE_assertion
          assert: '?'
          min: 0
          re: !!perl/hash:RE_method_re
            a: 0
            dba: curlycheck
            i: 0
            min: 0
            name: before
            nobind: 1
            r: 1
            re: !!perl/hash:RE_ast
              decl: []
              min: 0
              re: !!perl/hash:RE_sequence
                a: 0
                dba: curlycheck
                i: 0
                min: 0
                r: 1
                s: 0
                zyg:
                - !!perl/hash:RE_quantified_atom
                  atom: !!perl/hash:RE_meta
                    a: 0
                    dba: curlycheck
                    i: 0
                    min: 1
                    r: 1
                    s: 0
                    text: \h
                  min: 0
                  quant:
                  - '*'
                  - ':'
                  - ''
                  - 0
                - !!perl/hash:RE_meta
                  a: 0
                  dba: curlycheck
                  i: 0
                  min: 0
                  r: 1
                  s: 0
                  text: $$
            s: 0
        - !!perl/hash:RE_block
          a: 0
          context: void
          dba: curlycheck
          i: 0
          min: 0
          r: 1
          s: 0
          text: ' @*MEMOS[$.pos]<endstmt> = 2; '
      - !!perl/hash:RE_assertion
        assert: '?'
        min: 0
        re: !!perl/hash:RE_method_re
          a: 0
          dba: curlycheck
          i: 0
          min: 0
          name: before
          nobind: 1
          r: 1
          re: !!perl/hash:RE_ast
            decl: []
            min: 1
            re: !!perl/hash:RE_sequence
              a: 0
              dba: curlycheck
              i: 0
              min: 1
              r: 1
              s: 0
              zyg:
              - !!perl/hash:RE_quantified_atom
                atom: !!perl/hash:RE_meta
                  a: 0
                  dba: curlycheck
                  i: 0
                  min: 1
                  r: 1
                  s: 0
                  text: \h
                min: 0
                quant:
                - '*'
                - ':'
                - ''
                - 0
              - !!perl/hash:RE_cclass
                a: 0
                dba: curlycheck
                i: 0
                min: 1
                r: 1
                s: 0
                text: '[\\,:]'
          s: 0
      - !!perl/hash:RE_sequence
        a: 0
        dba: curlycheck
        i: 0
        min: 12345
        r: 1
        s: 0
        zyg:
        - !!perl/hash:RE_method
          a: 0
          dba: curlycheck
          i: 0
          min: 12345
          name: unv
          nobind: 1
          r: 1
          rest: ''
          s: 0
        - !!perl/hash:RE_meta
          a: 0
          dba: curlycheck
          i: 0
          min: 0
          r: 1
          s: 0
          text: $$
        - !!perl/hash:RE_block
          a: 0
          context: void
          dba: curlycheck
          i: 0
          min: 0
          r: 1
          s: 0
          text: ' @*MEMOS[$.pos]<endstmt> = 2; '
      - !!perl/hash:RE_sequence
        a: 0
        dba: curlycheck
        i: 0
        min: 0
        r: 1
        s: 0
        zyg:
        - !!perl/hash:RE_quantified_atom
          atom: !!perl/hash:RE_method
            a: 0
            dba: curlycheck
            i: 0
            min: 12345
            name: unsp
            nobind: 1
            r: 1
            rest: ''
            s: 0
          min: 0
          quant:
          - '?'
          - ':'
          - ''
          - 0
        - !!perl/hash:RE_block
          a: 0
          context: void
          dba: curlycheck
          i: 0
          min: 0
          r: 1
          s: 0
          text: ' @*MEMOS[$.pos]<endargs> = 1; '
declarator: !!perl/hash:RE_ast
  decl: []
  kind: token
  min: 12345
  pkg: ~
  re: !!perl/hash:RE_bracket
    decl: []
    min: 12345
    re: &10 !!perl/hash:RE_any
      a: 0
      altname: declarator_01
      dba: declarator
      i: 0
      min: 12345
      name: declarator_01
      r: 1
      s: 0
      zyg:
      - !!perl/hash:RE_sequence
        a: 0
        alt: declarator_01 0
        dba: declarator
        i: 0
        min: 12345
        r: 1
        s: 0
        zyg:
        - !!perl/hash:RE_method
          a: 0
          dba: declarator
          i: 0
          min: 12345
          name: variable_declarator
          r: 1
          rest: ''
          s: 0
        - !!perl/hash:RE_quantified_atom
          atom: !!perl/hash:RE_bracket
            decl: []
            min: 0
            re: !!perl/hash:RE_assertion
              assert: '?'
              min: 0
              re: !!perl/hash:RE_method_re
                a: 0
                dba: declarator
                i: 0
                min: 0
                name: before
                nobind: 1
                r: 1
                re: !!perl/hash:RE_ast
                  decl: []
                  min: 24691
                  re: !!perl/hash:RE_sequence
                    a: 0
                    dba: declarator
                    i: 0
                    min: 24691
                    r: 1
                    s: 0
                    zyg:
                    - !!perl/hash:RE_method
                      a: 0
                      dba: declarator
                      i: 0
                      min: 12345
                      name: ws
                      nobind: 1
                      r: 1
                      rest: ''
                      s: 0
                    - !!perl/hash:RE_string
                      a: 0
                      dba: declarator
                      i: 0
                      min: 1
                      r: 1
                      s: 0
                      text: ','
                    - !!perl/hash:RE_method
                      a: 0
                      dba: declarator
                      i: 0
                      min: 12345
                      name: ws
                      nobind: 1
                      r: 1
                      rest: ''
                      s: 0
                    - !!perl/hash:RE_block
                      a: 0
                      context: void
                      dba: declarator
                      i: 0
                      min: 0
                      r: 1
                      s: 0
                      text: ' @*MEMOS[$.pos]<declend> = $*SCOPE; '
                s: 0
          min: 0
          quant:
          - '?'
          - ':'
          - ''
          - 0
      - !!perl/hash:RE_sequence
        a: 0
        alt: declarator_01 1
        dba: declarator
        i: 0
        min: 12347
        r: 1
        s: 0
        zyg:
        - !!perl/hash:RE_string
          a: 0
          dba: declarator
          i: 0
          min: 1
          r: 1
          s: 0
          text: (
        - !!perl/hash:RE_meta
          a: 0
          dba: declarator
          extra: 'local $::GOAL = '')'' '
          i: 0
          min: 0
          r: 1
          s: 0
          text: ':'
        - !!perl/hash:RE_method
          a: 0
          dba: declarator
          i: 0
          min: 12345
          name: signature
          r: 1
          rest: ''
          s: 0
        - !!perl/hash:RE_bracket
          decl: []
          min: 1
          re: !!perl/hash:RE_first
            a: 0
            dba: declarator
            i: 0
            min: 1
            r: 1
            s: 0
            zyg:
            - !!perl/hash:RE_string
              a: 0
              dba: declarator
              i: 0
              min: 1
              r: 1
              s: 0
              text: )
            - !!perl/hash:RE_method
              min: 0
              name: FAILGOAL
              nobind: 1
              rest: (')' , 'declarator')
        - !!perl/hash:RE_quantified_atom
          atom: !!perl/hash:RE_method
            a: 0
            dba: declarator
            i: 0
            min: 12345
            name: trait
            r: 1
            rest: ''
            s: 0
          min: 0
          quant:
          - '*'
          - ':'
          - ''
          - 0
      - !!perl/hash:RE_method
        a: 0
        alt: declarator_01 2
        dba: declarator
        i: 0
        min: 12345
        name: routine_declarator
        r: 1
        rest: ''
        s: 0
      - !!perl/hash:RE_method
        a: 0
        alt: declarator_01 3
        dba: declarator
        i: 0
        min: 12345
        name: regex_declarator
        r: 1
        rest: ''
        s: 0
      - !!perl/hash:RE_method
        a: 0
        alt: declarator_01 4
        dba: declarator
        i: 0
        min: 12345
        name: type_declarator
        r: 1
        rest: ''
        s: 0
declarator_01: *10
def_module_name: !!perl/hash:RE_ast
  decl: []
  kind: token
  min: 12345
  pkg: ~
  re: !!perl/hash:RE_sequence
    a: 0
    dba: def_module_name
    i: 0
    min: 12345
    r: 1
    s: 0
    zyg:
    - !!perl/hash:RE_method
      a: 0
      dba: def_module_name
      i: 0
      min: 12345
      name: longname
      r: 1
      rest: ''
      s: 0
    - !!perl/hash:RE_quantified_atom
      atom: !!perl/hash:RE_bracket
        decl: []
        min: 37037
        re: !!perl/hash:RE_sequence
          a: 0
          dba: generic role
          i: 0
          min: 37037
          r: 1
          s: 0
          zyg:
          - !!perl/hash:RE_assertion
            assert: '?'
            min: 0
            re: !!perl/hash:RE_method_re
              a: 0
              dba: generic role
              i: 0
              min: 0
              name: before
              nobind: 1
              r: 1
              re: !!perl/hash:RE_ast
                decl: []
                min: 1
                re: !!perl/hash:RE_string
                  a: 0
                  dba: generic role
                  i: 0
                  min: 1
                  r: 1
                  s: 0
                  text: '['
              s: 0
          - !!perl/hash:RE_assertion
            assert: '?'
            min: 0
            re: !!perl/hash:RE_block
              a: 0
              context: bool
              dba: generic role
              i: 0
              min: 0
              nobind: 1
              r: 1
              s: 0
              text: ' ($*PKGDECL//'''') eq ''role'' '
          - !!perl/hash:RE_method
            a: 0
            dba: generic role
            i: 0
            min: 12345
            name: newpad
            nobind: 1
            r: 1
            rest: ''
            s: 0
          - !!perl/hash:RE_string
            a: 0
            dba: generic role
            i: 0
            min: 1
            r: 1
            s: 0
            text: '['
          - !!perl/hash:RE_meta
            a: 0
            dba: generic role
            extra: 'local $::GOAL = '']'' '
            i: 0
            min: 0
            r: 1
            s: 0
            text: ':'
          - !!perl/hash:RE_method
            a: 0
            dba: generic role
            i: 0
            min: 12345
            name: signature
            r: 1
            rest: ''
            s: 0
          - !!perl/hash:RE_bracket
            decl: []
            min: 1
            re: !!perl/hash:RE_first
              a: 0
              dba: generic role
              i: 0
              min: 1
              r: 1
              s: 0
              zyg:
              - !!perl/hash:RE_string
                a: 0
                dba: generic role
                i: 0
                min: 1
                r: 1
                s: 0
                text: ']'
              - !!perl/hash:RE_method
                min: 0
                name: FAILGOAL
                nobind: 1
                rest: (']' , 'generic role')
          - !!perl/hash:RE_block
            a: 0
            context: void
            dba: generic role
            i: 0
            min: 0
            r: 1
            s: 0
            text: ' $*IN_DECL = ''''; '
          - !!perl/hash:RE_method
            a: 0
            dba: generic role
            i: 0
            min: 12345
            name: finishpad
            nobind: 1
            r: 1
            rest: ''
            s: 0
      min: 0
      quant:
      - '?'
      - ':'
      - ''
      - 0
default_value: !!perl/hash:RE_ast
  decl:
  - !!perl/hash:RE_decl
    a: 0
    dba: default_value
    i: 0
    max: 0
    min: 0
    r: 1
    s: 1
    text: my $*IN_DECL = ''
  kind: rule
  min: 1
  pkg: ~
  re: !!perl/hash:RE_sequence
    a: 0
    dba: default_value
    i: 0
    min: 1
    r: 1
    s: 1
    zyg:
    - !!perl/hash:RE_method
      min: 0
      name: ws
      nobind: 1
      noquant: 1
      rest: ''
    - !!perl/hash:RE_string
      a: 0
      dba: default_value
      i: 0
      min: 1
      r: 1
      s: 1
      text: =
    - !!perl/hash:RE_method
      min: 0
      name: ws
      nobind: 1
      noquant: 1
      rest: ''
    - !!perl/hash:RE_method
      min: 0
      name: EXPR
      rest: (item %item_assignment)
    - !!perl/hash:RE_method
      min: 0
      name: ws
      nobind: 1
      noquant: 1
      rest: ''
deflongname: !!perl/hash:RE_ast
  decl: []
  kind: token
  min: 12345
  pkg: ~
  re: !!perl/hash:RE_sequence
    a: 0
    dba: new name to be defined
    i: 0
    min: 12345
    r: 1
    s: 0
    zyg:
    - !!perl/hash:RE_method
      a: 0
      dba: new name to be defined
      i: 0
      min: 12345
      name: name
      r: 1
      rest: ''
      s: 0
    - !!perl/hash:RE_bracket
      decl: []
      min: 0
      re: &11 !!perl/hash:RE_any
        a: 0
        altname: deflongname_01
        dba: new name to be defined
        i: 0
        min: 0
        name: deflongname_01
        r: 1
        s: 0
        zyg:
        - !!perl/hash:RE_sequence
          a: 0
          alt: deflongname_01 0
          dba: new name to be defined
          i: 0
          min: 12345
          r: 1
          s: 0
          zyg:
          - !!perl/hash:RE_quantified_atom
            atom: !!perl/hash:RE_method
              a: 0
              dba: new name to be defined
              i: 0
              min: 12345
              name: colonpair
              r: 1
              rest: ''
              s: 0
            min: 12345
            quant:
            - +
            - ':'
            - ''
            - 1
          - !!perl/hash:RE_block
            a: 0
            context: void
            dba: new name to be defined
            i: 0
            min: 0
            r: 1
            s: 0
            text: ' $.add_macro($<name>) if $*IN_DECL; '
        - !!perl/hash:RE_block
          a: 0
          alt: deflongname_01 1
          context: void
          dba: new name to be defined
          i: 0
          min: 0
          r: 1
          s: 0
          text: ' $.add_routine($<name>.Str) if $*IN_DECL; '
deflongname_01: *11
desigilname: !!perl/hash:RE_ast
  decl: []
  kind: token
  min: 0
  pkg: ~
  re: !!perl/hash:RE_bracket
    decl: []
    min: 0
    re: &12 !!perl/hash:RE_any
      a: 0
      altname: desigilname_01
      dba: desigilname
      i: 0
      min: 0
      name: desigilname_01
      r: 1
      s: 0
      zyg:
      - !!perl/hash:RE_sequence
        a: 0
        alt: desigilname_01 0
        dba: desigilname
        i: 0
        min: 12345
        r: 1
        s: 0
        zyg:
        - !!perl/hash:RE_assertion
          assert: '?'
          min: 0
          re: !!perl/hash:RE_method_re
            a: 0
            dba: desigilname
            i: 0
            min: 0
            name: before
            nobind: 1
            r: 1
            re: !!perl/hash:RE_ast
              decl: []
              min: 1
              re: !!perl/hash:RE_string
                a: 0
                dba: desigilname
                i: 0
                min: 1
                r: 1
                s: 0
                text: $
            s: 0
        - !!perl/hash:RE_method
          a: 0
          dba: desigilname
          i: 0
          min: 12345
          name: variable
          r: 1
          rest: ''
          s: 0
        - !!perl/hash:RE_block
          a: 0
          context: void
          dba: desigilname
          i: 0
          min: 0
          r: 1
          s: 0
          text: ' $*VAR = $<variable> '
      - !!perl/hash:RE_sequence
        a: 0
        alt: desigilname_01 1
        dba: desigilname
        i: 0
        min: 0
        r: 1
        s: 0
        zyg:
        - !!perl/hash:RE_assertion
          assert: '?'
          min: 0
          re: !!perl/hash:RE_method_re
            a: 0
            dba: desigilname
            i: 0
            min: 0
            name: before
            nobind: 1
            r: 1
            re: !!perl/hash:RE_ast
              decl: []
              min: 2
              re: !!perl/hash:RE_sequence
                a: 0
                dba: desigilname
                i: 0
                min: 2
                r: 1
                s: 0
                zyg:
                - !!perl/hash:RE_cclass
                  a: 0
                  dba: desigilname
                  i: 0
                  min: 1
                  r: 1
                  s: 0
                  text: '[\@\%\&]'
                - !!perl/hash:RE_quantified_atom
                  atom: !!perl/hash:RE_method
                    a: 0
                    dba: desigilname
                    i: 0
                    min: 12345
                    name: sigil
                    r: 1
                    rest: ''
                    s: 0
                  min: 0
                  quant:
                  - '*'
                  - ':'
                  - ''
                  - 0
                - !!perl/hash:RE_meta
                  a: 0
                  dba: desigilname
                  i: 0
                  min: 1
                  r: 1
                  s: 0
                  text: \w
            s: 0
        - !!perl/hash:RE_method
          min: 0
          name: panic
          nobind: 1
          rest: ("Invalid hard reference syntax")
      - !!perl/hash:RE_method
        a: 0
        alt: desigilname_01 2
        dba: desigilname
        i: 0
        min: 12345
        name: longname
        r: 1
        rest: ''
        s: 0
desigilname_01: *12
dotty__S_255DotStar: !!perl/hash:RE_ast
  decl: []
  kind: token
  min: 24692
  pkg: ~
  re: !!perl/hash:RE_sequence
    a: 0
    dba: dotty__S_255DotStar
    i: 0
    min: 24692
    r: 1
    s: 0
    zyg:
    - !!perl/hash:RE_bindpos
      atom: !!perl/hash:RE_paren
        decl: []
        min: 2
        re: !!perl/hash:RE_sequence
          a: 0
          dba: dotty__S_255DotStar
          i: 0
          min: 2
          r: 1
          s: 0
          zyg:
          - !!perl/hash:RE_string
            a: 0
            dba: dotty__S_255DotStar
            i: 0
            min: 1
            r: 1
            s: 0
            text: .
          - !!perl/hash:RE_bracket
            decl: []
            min: 1
            re: &13 !!perl/hash:RE_any
              a: 0
              altname: dotty__S_255DotStar_02
              dba: dotty__S_255DotStar
              i: 0
              min: 1
              name: dotty__S_255DotStar_02
              r: 1
              s: 0
              zyg:
              - !!perl/hash:RE_cclass
                a: 0
                alt: dotty__S_255DotStar_02 0
                dba: dotty__S_255DotStar
                i: 0
                min: 1
                r: 1
                s: 0
                text: '[+*?=]'
              - !!perl/hash:RE_sequence
                a: 0
                alt: dotty__S_255DotStar_02 1
                dba: dotty__S_255DotStar
                i: 0
                min: 1
                r: 1
                s: 0
                zyg:
                - !!perl/hash:RE_string
                  a: 0
                  dba: dotty__S_255DotStar
                  i: 0
                  min: 1
                  r: 1
                  s: 0
                  text: ^
                - !!perl/hash:RE_quantified_atom
                  atom: !!perl/hash:RE_string
                    a: 0
                    dba: dotty__S_255DotStar
                    i: 0
                    min: 1
                    r: 1
                    s: 0
                    text: '!'
                  min: 0
                  quant:
                  - '?'
                  - ':'
                  - ''
                  - 0
      min: 2
      var: 0
    - !!perl/hash:RE_meta
      a: 0
      dba: dotty__S_255DotStar
      i: 0
      min: 0
      r: 1
      s: 0
      text: '::'
    - !!perl/hash:RE_method
      a: 0
      dba: dotty__S_255DotStar
      i: 0
      min: 12345
      name: unspacey
      nobind: 1
      r: 1
      rest: ''
      s: 0
    - !!perl/hash:RE_method
      a: 0
      dba: dotty__S_255DotStar
      i: 0
      min: 12345
      name: dottyop
      r: 1
      rest: ''
      s: 0
    - !!perl/hash:RE_block
      a: 0
      context: void
      dba: dotty__S_255DotStar
      i: 0
      min: 0
      r: 1
      s: 0
      text: ' $<sym> = $0.Str; '
    - !!perl/hash:RE_method
      min: 0
      name: O
      rest: (%methodcall)
dotty__S_255DotStar_02: *13
dotty__S_256Dot: !!perl/hash:RE_ast
  decl: []
  kind: token
  min: 37035
  pkg: ~
  re: !!perl/hash:RE_sequence
    a: 0
    dba: dotty__S_256Dot
    i: 0
    min: 37035
    r: 1
    s: 0
    zyg:
    - !!perl/hash:RE_method
      a: 0
      dba: dotty__S_256Dot
      endsym: unspacey
      i: 0
      min: 12345
      name: sym
      r: 1
      rest: ''
      s: 0
      sym: .
    - !!perl/hash:RE_method
      a: 0
      dba: dotty__S_256Dot
      i: 0
      min: 12345
      name: unspacey
      nobind: 1
      r: 1
      rest: ''
      s: 0
    - !!perl/hash:RE_method
      a: 0
      dba: dotty__S_256Dot
      i: 0
      min: 12345
      name: dottyop
      r: 1
      rest: ''
      s: 0
    - !!perl/hash:RE_method
      min: 0
      name: O
      rest: (%methodcall)
dottyop: !!perl/hash:RE_ast
  decl: []
  kind: token
  min: 12345
  pkg: ~
  re: !!perl/hash:RE_bracket
    decl: []
    min: 12345
    re: &14 !!perl/hash:RE_any
      a: 0
      altname: dottyop_01
      dba: dotty method or postfix
      i: 0
      min: 12345
      name: dottyop_01
      r: 1
      s: 0
      zyg:
      - !!perl/hash:RE_method
        a: 0
        alt: dottyop_01 0
        dba: dotty method or postfix
        i: 0
        min: 12345
        name: methodop
        r: 1
        rest: ''
        s: 0
      - !!perl/hash:RE_method
        a: 0
        alt: dottyop_01 1
        dba: dotty method or postfix
        i: 0
        min: 12345
        name: colonpair
        r: 1
        rest: ''
        s: 0
      - !!perl/hash:RE_sequence
        a: 0
        alt: dottyop_01 2
        dba: dotty method or postfix
        i: 0
        min: 12345
        r: 1
        s: 0
        zyg:
        - !!perl/hash:RE_assertion
          assert: '!'
          min: 0
          re: !!perl/hash:RE_method
            a: 0
            dba: dotty method or postfix
            i: 0
            min: 12345
            name: alpha
            nobind: 1
            r: 1
            rest: ''
            s: 0
        - !!perl/hash:RE_method
          a: 0
          dba: dotty method or postfix
          i: 0
          min: 12345
          name: postop
          r: 1
          rest: ''
          s: 0
        - !!perl/hash:RE_block
          a: 0
          context: void
          dba: dotty method or postfix
          i: 0
          min: 0
          r: 1
          s: 0
          text: ' $<O> = $<postop><O>; $<sym> = $<postop><sym>; '
dottyop_01: *14
dottyopish: !!perl/hash:RE_ast
  decl: []
  kind: token
  min: 12345
  pkg: ~
  re: !!perl/hash:RE_bindnamed
    a: 0
    atom: !!perl/hash:RE_method
      a: 0
      dba: dottyopish
      i: 0
      min: 12345
      name: dottyop
      nobind: 1
      r: 1
      rest: ''
      s: 0
    dba: dottyopish
    i: 0
    min: 12345
    r: 1
    s: 0
    var: term
eat_terminator: !!perl/hash:RE_ast
  decl: []
  kind: token
  min: 0
  pkg: ~
  re: !!perl/hash:RE_bracket
    decl: []
    min: 0
    re: !!perl/hash:RE_first
      a: 0
      dba: eat_terminator
      i: 0
      min: 0
      r: 1
      s: 0
      zyg:
      - !!perl/hash:RE_sequence
        a: 0
        dba: eat_terminator
        i: 0
        min: 1
        r: 1
        s: 0
        zyg:
        - !!perl/hash:RE_string
          a: 0
          dba: eat_terminator
          i: 0
          min: 1
          r: 1
          s: 0
          text: ;
        - !!perl/hash:RE_quantified_atom
          atom: !!perl/hash:RE_bracket
            decl: []
            min: 0
            re: !!perl/hash:RE_sequence
              a: 0
              dba: eat_terminator
              i: 0
              min: 0
              r: 1
              s: 0
              zyg:
              - !!perl/hash:RE_assertion
                assert: '?'
                min: 0
                re: !!perl/hash:RE_method_re
                  a: 0
                  dba: eat_terminator
                  i: 0
                  min: 0
                  name: before
                  nobind: 1
                  r: 1
                  re: !!perl/hash:RE_ast
                    decl: []
                    min: 0
                    re: !!perl/hash:RE_meta
                      a: 0
                      dba: eat_terminator
                      i: 0
                      min: 0
                      r: 1
                      s: 0
                      text: $
                  s: 0
              - !!perl/hash:RE_block
                a: 0
                context: void
                dba: eat_terminator
                i: 0
                min: 0
                r: 1
                s: 0
                text: ' $*ORIG ~~ s/\;$/ /; '
          min: 0
          quant:
          - '?'
          - ':'
          - ''
          - 0
      - !!perl/hash:RE_sequence
        a: 0
        dba: eat_terminator
        i: 0
        min: 12345
        r: 1
        s: 0
        zyg:
        - !!perl/hash:RE_assertion
          assert: '?'
          min: 0
          re: !!perl/hash:RE_block
            a: 0
            context: bool
            dba: eat_terminator
            i: 0
            min: 0
            nobind: 1
            r: 1
            s: 0
            text: ' @*MEMOS[$.pos]<endstmt> '
        - !!perl/hash:RE_method
          a: 0
          dba: eat_terminator
          i: 0
          min: 12345
          name: ws
          nobind: 1
          r: 1
          rest: ''
          s: 0
      - !!perl/hash:RE_assertion
        assert: '?'
        min: 0
        re: !!perl/hash:RE_method
          a: 0
          dba: eat_terminator
          i: 0
          min: 12345
          name: terminator
          nobind: 1
          r: 1
          rest: ''
          s: 0
      - !!perl/hash:RE_meta
        a: 0
        dba: eat_terminator
        i: 0
        min: 0
        r: 1
        s: 0
        text: $
      - !!perl/hash:RE_assertion
        assert: '?'
        min: 0
        re: !!perl/hash:RE_method
          a: 0
          dba: eat_terminator
          i: 0
          min: 12345
          name: stopper
          nobind: 1
          r: 1
          rest: ''
          s: 0
      - !!perl/hash:RE_sequence
        a: 0
        dba: eat_terminator
        i: 0
        min: 0
        r: 1
        s: 0
        zyg:
        - !!perl/hash:RE_block
          a: 0
          context: void
          dba: eat_terminator
          i: 0
          min: 0
          r: 1
          s: 0
          text: ' if @*MEMOS[$.pos]<ws> { $.pos = @*MEMOS[$.pos]<ws>; } '
        - !!perl/hash:RE_method
          min: 0
          name: panic
          nobind: 1
          rest: ("Confused")
fakesignature: !!perl/hash:RE_ast
  decl:
  - !!perl/hash:RE_decl
    a: 0
    dba: fakesignature
    i: 0
    max: 0
    min: 0
    r: 1
    s: 0
    text: temp $*CURPAD
  kind: token
  min: 24690
  pkg: ~
  re: !!perl/hash:RE_sequence
    a: 0
    dba: fakesignature
    i: 0
    min: 24690
    r: 1
    s: 0
    zyg:
    - !!perl/hash:RE_method
      a: 0
      dba: fakesignature
      i: 0
      min: 12345
      name: newpad
      nobind: 1
      r: 1
      rest: ''
      s: 0
    - !!perl/hash:RE_method
      a: 0
      dba: fakesignature
      i: 0
      min: 12345
      name: signature
      r: 1
      rest: ''
      s: 0
fatarrow: !!perl/hash:RE_ast
  decl: []
  kind: token
  min: 24692
  pkg: ~
  re: !!perl/hash:RE_sequence
    a: 0
    dba: fatarrow
    i: 0
    min: 24692
    r: 1
    s: 0
    zyg:
    - !!perl/hash:RE_bindnamed
      a: 0
      atom: !!perl/hash:RE_method
        a: 0
        dba: fatarrow
        i: 0
        min: 12345
        name: identifier
        nobind: 1
        r: 1
        rest: ''
        s: 0
      dba: fatarrow
      i: 0
      min: 12345
      r: 1
      s: 0
      var: key
    - !!perl/hash:RE_quantified_atom
      atom: !!perl/hash:RE_meta
        a: 0
        dba: fatarrow
        i: 0
        min: 1
        r: 1
        s: 0
        text: \h
      min: 0
      quant:
      - '*'
      - ':'
      - ''
      - 0
    - !!perl/hash:RE_string
      a: 0
      dba: fatarrow
      i: 0
      min: 2
      r: 1
      s: 0
      text: =>
    - !!perl/hash:RE_method
      a: 0
      dba: fatarrow
      i: 0
      min: 12345
      name: ws
      nobind: 1
      r: 1
      rest: ''
      s: 0
    - !!perl/hash:RE_bindnamed
      a: 0
      atom: !!perl/hash:RE_method
        min: 0
        name: EXPR
        nobind: 1
        rest: (item %item_assignment)
      dba: fatarrow
      i: 0
      min: 0
      r: 1
      s: 0
      var: val
infix__S_251lambda: !!perl/hash:RE_ast
  decl: []
  kind: token
  min: 0
  pkg: ~
  re: !!perl/hash:RE_sequence
    a: 0
    dba: infix__S_251lambda
    i: 0
    min: 0
    r: 1
    s: 0
    zyg:
    - !!perl/hash:RE_assertion
      assert: '?'
      min: 0
      re: !!perl/hash:RE_method_re
        a: 0
        dba: infix__S_251lambda
        i: 0
        min: 0
        name: before
        nobind: 1
        r: 1
        re: !!perl/hash:RE_ast
          decl: []
          min: 1
          re: &15 !!perl/hash:RE_any
            a: 0
            altname: infix__S_251lambda_01
            dba: infix__S_251lambda
            i: 0
            min: 1
            name: infix__S_251lambda_01
            r: 1
            s: 0
            zyg:
            - !!perl/hash:RE_string
              a: 0
              alt: infix__S_251lambda_01 0
              dba: infix__S_251lambda
              i: 0
              min: 1
              r: 1
              s: 0
              text: '{'
            - !!perl/hash:RE_string
              a: 0
              alt: infix__S_251lambda_01 1
              dba: infix__S_251lambda
              i: 0
              min: 2
              r: 1
              s: 0
              text: ->
        s: 0
    - !!perl/hash:RE_assertion
      assert: '!'
      min: 0
      re: !!perl/hash:RE_block
        a: 0
        context: bool
        dba: infix__S_251lambda
        i: 0
        min: 0
        nobind: 1
        r: 1
        s: 0
        text: ' $*IN_META '
    - !!perl/hash:RE_block
      a: 0
      context: void
      dba: infix__S_251lambda
      i: 0
      min: 0
      r: 1
      s: 0
      text: "\n            my $line = $.lineof($.pos);\n            for 'if', 'unless',
        'while', 'until', 'for', 'loop', 'given', 'when', 'sub' {\n                my
        $m = %*MYSTERY{$_};\n                next unless $m;\n                if $line
        - ($m.<line>//-123) < 5 {\n                    if $m.<ctx> eq '(' {\n                        $.panic($_
        ~ '() interpreted as function call at line ' ~ $m.<line> ~\n                        \";
        please use whitespace \" ~\n                        ($_ eq 'loop' ?? 'around'
        !! 'instead of') ~\n                        \" parens\\nUnexpected block in
        infix position (two terms in a row)\");\n                    }\n                    else
        {\n                        $.panic(\"'$_' interpreted as listop at line \"
        ~ $m.<line> ~\n                        \"; please use 'do' to introduce statement_control:<$_>.\\nUnexpected
        block in infix position (two terms in a row)\");\n                    }\n
        \               }\n            }\n            return () if $*IN_REDUCE;\n
        \           my $endpos = $.pos;\n            my $startpos = @*MEMOS[$endpos]<ws>
        // $endpos;\n\n            if self.lineof($startpos) != self.lineof($endpos)
        {\n                $.panic(\"Unexpected block in infix position (previous
        line missing its semicolon?)\");\n            }\n            elsif @*MEMOS[$.pos-1]<baremeth>
        {\n                $.panic(\"Unexpected block in infix position (method call
        needs colon or parens to take arguments)\");\n            }\n            else
        {\n                $.panic(\"Unexpected block in infix position (two terms
        in a row, or previous statement missing semicolon?)\");\n            }\n        "
    - !!perl/hash:RE_method
      min: 0
      name: O
      rest: (|%term)
infix__S_251lambda_01: *15
infix__S_277Dot: !!perl/hash:RE_ast
  decl: []
  kind: token
  min: 2
  pkg: ~
  re: !!perl/hash:RE_sequence
    a: 0
    dba: infix__S_277Dot
    i: 0
    min: 2
    r: 1
    s: 0
    zyg:
    - !!perl/hash:RE_string
      a: 0
      dba: infix__S_277Dot
      i: 0
      min: 1
      r: 1
      s: 0
      text: .
    - !!perl/hash:RE_cclass
      a: 0
      dba: infix__S_277Dot
      i: 0
      min: 1
      r: 1
      s: 0
      text: '[\]\)\},:\s\$"'']'
    - !!perl/hash:RE_method
      min: 0
      name: obs
      nobind: 1
      rest: ('. to concatenate strings', '~')
infix__S_283StarStar: !!perl/hash:RE_ast
  decl: []
  kind: token
  min: 12345
  pkg: ~
  re: !!perl/hash:RE_sequence
    a: 0
    dba: infix__S_283StarStar
    i: 0
    min: 12345
    r: 1
    s: 0
    zyg:
    - !!perl/hash:RE_method
      a: 0
      dba: infix__S_283StarStar
      i: 0
      min: 12345
      name: sym
      r: 1
      rest: ''
      s: 0
      sym: '**'
    - !!perl/hash:RE_method
      min: 0
      name: O
      rest: (|%exponentiation)
infix__S_298Star: !!perl/hash:RE_ast
  decl: []
  kind: token
  min: 12345
  pkg: ~
  re: !!perl/hash:RE_sequence
    a: 0
    dba: infix__S_298Star
    i: 0
    min: 12345
    r: 1
    s: 0
    zyg:
    - !!perl/hash:RE_method
      a: 0
      dba: infix__S_298Star
      i: 0
      min: 12345
      name: sym
      r: 1
      rest: ''
      s: 0
      sym: '*'
    - !!perl/hash:RE_method
      min: 0
      name: O
      rest: (|%multiplicative)
infix__S_299Slash: !!perl/hash:RE_ast
  decl: []
  kind: token
  min: 12345
  pkg: ~
  re: !!perl/hash:RE_sequence
    a: 0
    dba: infix__S_299Slash
    i: 0
    min: 12345
    r: 1
    s: 0
    zyg:
    - !!perl/hash:RE_method
      a: 0
      dba: infix__S_299Slash
      i: 0
      min: 12345
      name: sym
      r: 1
      rest: ''
      s: 0
      sym: /
    - !!perl/hash:RE_method
      min: 0
      name: O
      rest: (|%multiplicative)
infix__S_300div: !!perl/hash:RE_ast
  decl: []
  kind: token
  min: 12345
  pkg: ~
  re: !!perl/hash:RE_sequence
    a: 0
    dba: infix__S_300div
    i: 0
    min: 12345
    r: 1
    s: 0
    zyg:
    - !!perl/hash:RE_method
      a: 0
      dba: infix__S_300div
      i: 0
      min: 12345
      name: sym
      r: 1
      rest: ''
      s: 0
      sym: div
    - !!perl/hash:RE_method
      min: 0
      name: O
      rest: (|%multiplicative)
infix__S_301Percent: !!perl/hash:RE_ast
  decl: []
  kind: token
  min: 12345
  pkg: ~
  re: !!perl/hash:RE_sequence
    a: 0
    dba: infix__S_301Percent
    i: 0
    min: 12345
    r: 1
    s: 0
    zyg:
    - !!perl/hash:RE_method
      a: 0
      dba: infix__S_301Percent
      i: 0
      min: 12345
      name: sym
      r: 1
      rest: ''
      s: 0
      sym: '%'
    - !!perl/hash:RE_method
      min: 0
      name: O
      rest: (|%multiplicative, iffy => 1)
infix__S_302mod: !!perl/hash:RE_ast
  decl: []
  kind: token
  min: 12345
  pkg: ~
  re: !!perl/hash:RE_sequence
    a: 0
    dba: infix__S_302mod
    i: 0
    min: 12345
    r: 1
    s: 0
    zyg:
    - !!perl/hash:RE_method
      a: 0
      dba: infix__S_302mod
      i: 0
      min: 12345
      name: sym
      r: 1
      rest: ''
      s: 0
      sym: mod
    - !!perl/hash:RE_method
      min: 0
      name: O
      rest: (|%multiplicative)
infix__S_303PlusAmp: !!perl/hash:RE_ast
  decl: []
  kind: token
  min: 12345
  pkg: ~
  re: !!perl/hash:RE_sequence
    a: 0
    dba: infix__S_303PlusAmp
    i: 0
    min: 12345
    r: 1
    s: 0
    zyg:
    - !!perl/hash:RE_method
      a: 0
      dba: infix__S_303PlusAmp
      i: 0
      min: 12345
      name: sym
      r: 1
      rest: ''
      s: 0
      sym: +&
    - !!perl/hash:RE_method
      min: 0
      name: O
      rest: (|%multiplicative)
infix__S_304PlusLt: !!perl/hash:RE_ast
  decl: []
  kind: token
  min: 12345
  pkg: ~
  re: !!perl/hash:RE_sequence
    a: 0
    dba: infix__S_304PlusLt
    i: 0
    min: 12345
    r: 1
    s: 0
    zyg:
    - !!perl/hash:RE_method
      a: 0
      dba: infix__S_304PlusLt
      i: 0
      min: 12345
      name: sym
      r: 1
      rest: ''
      s: 0
      sym: +<
    - !!perl/hash:RE_assertion
      assert: '!'
      min: 0
      re: !!perl/hash:RE_method_re
        a: 0
        dba: infix__S_304PlusLt
        i: 0
        min: 0
        name: before
        nobind: 1
        r: 1
        re: !!perl/hash:RE_ast
          decl: []
          min: 1
          re: !!perl/hash:RE_string
            a: 0
            dba: infix__S_304PlusLt
            i: 0
            min: 1
            r: 1
            s: 0
            text: <
        s: 0
    - !!perl/hash:RE_method
      min: 0
      name: O
      rest: (|%multiplicative)
infix__S_305LtLt: !!perl/hash:RE_ast
  decl: []
  kind: token
  min: 12346
  pkg: ~
  re: !!perl/hash:RE_sequence
    a: 0
    dba: infix__S_305LtLt
    i: 0
    min: 12346
    r: 1
    s: 0
    zyg:
    - !!perl/hash:RE_method
      a: 0
      dba: infix__S_305LtLt
      i: 0
      min: 12345
      name: sym
      r: 1
      rest: ''
      s: 0
      sym: <<
    - !!perl/hash:RE_meta
      a: 0
      dba: infix__S_305LtLt
      i: 0
      min: 1
      r: 1
      s: 0
      text: \s
    - !!perl/hash:RE_method
      min: 0
      name: obs
      nobind: 1
      rest: ('<< to do left shift', '+< or ~<')
    - !!perl/hash:RE_method
      min: 0
      name: O
      rest: (|%multiplicative)
infix__S_306GtGt: !!perl/hash:RE_ast
  decl: []
  kind: token
  min: 12346
  pkg: ~
  re: !!perl/hash:RE_sequence
    a: 0
    dba: infix__S_306GtGt
    i: 0
    min: 12346
    r: 1
    s: 0
    zyg:
    - !!perl/hash:RE_method
      a: 0
      dba: infix__S_306GtGt
      i: 0
      min: 12345
      name: sym
      r: 1
      rest: ''
      s: 0
      sym: '>>'
    - !!perl/hash:RE_meta
      a: 0
      dba: infix__S_306GtGt
      i: 0
      min: 1
      r: 1
      s: 0
      text: \s
    - !!perl/hash:RE_method
      min: 0
      name: obs
      nobind: 1
      rest: ('>> to do right shift', '+> or ~>')
    - !!perl/hash:RE_method
      min: 0
      name: O
      rest: (|%multiplicative)
infix__S_307PlusGt: !!perl/hash:RE_ast
  decl: []
  kind: token
  min: 12345
  pkg: ~
  re: !!perl/hash:RE_sequence
    a: 0
    dba: infix__S_307PlusGt
    i: 0
    min: 12345
    r: 1
    s: 0
    zyg:
    - !!perl/hash:RE_method
      a: 0
      dba: infix__S_307PlusGt
      i: 0
      min: 12345
      name: sym
      r: 1
      rest: ''
      s: 0
      sym: +>
    - !!perl/hash:RE_assertion
      assert: '!'
      min: 0
      re: !!perl/hash:RE_method_re
        a: 0
        dba: infix__S_307PlusGt
        i: 0
        min: 0
        name: before
        nobind: 1
        r: 1
        re: !!perl/hash:RE_ast
          decl: []
          min: 1
          re: !!perl/hash:RE_string
            a: 0
            dba: infix__S_307PlusGt
            i: 0
            min: 1
            r: 1
            s: 0
            text: '>'
        s: 0
    - !!perl/hash:RE_method
      min: 0
      name: O
      rest: (|%multiplicative)
infix__S_308TildeAmp: !!perl/hash:RE_ast
  decl: []
  kind: token
  min: 12345
  pkg: ~
  re: !!perl/hash:RE_sequence
    a: 0
    dba: infix__S_308TildeAmp
    i: 0
    min: 12345
    r: 1
    s: 0
    zyg:
    - !!perl/hash:RE_method
      a: 0
      dba: infix__S_308TildeAmp
      i: 0
      min: 12345
      name: sym
      r: 1
      rest: ''
      s: 0
      sym: ~&
    - !!perl/hash:RE_method
      min: 0
      name: O
      rest: (|%multiplicative)
infix__S_309QuestionAmp: !!perl/hash:RE_ast
  decl: []
  kind: token
  min: 12345
  pkg: ~
  re: !!perl/hash:RE_sequence
    a: 0
    dba: infix__S_309QuestionAmp
    i: 0
    min: 12345
    r: 1
    s: 0
    zyg:
    - !!perl/hash:RE_method
      a: 0
      dba: infix__S_309QuestionAmp
      i: 0
      min: 12345
      name: sym
      r: 1
      rest: ''
      s: 0
      sym: ?&
    - !!perl/hash:RE_method
      min: 0
      name: O
      rest: (|%multiplicative, iffy => 1)
infix__S_310TildeLt: !!perl/hash:RE_ast
  decl: []
  kind: token
  min: 12345
  pkg: ~
  re: !!perl/hash:RE_sequence
    a: 0
    dba: infix__S_310TildeLt
    i: 0
    min: 12345
    r: 1
    s: 0
    zyg:
    - !!perl/hash:RE_method
      a: 0
      dba: infix__S_310TildeLt
      i: 0
      min: 12345
      name: sym
      r: 1
      rest: ''
      s: 0
      sym: ~<
    - !!perl/hash:RE_assertion
      assert: '!'
      min: 0
      re: !!perl/hash:RE_method_re
        a: 0
        dba: infix__S_310TildeLt
        i: 0
        min: 0
        name: before
        nobind: 1
        r: 1
        re: !!perl/hash:RE_ast
          decl: []
          min: 1
          re: !!perl/hash:RE_string
            a: 0
            dba: infix__S_310TildeLt
            i: 0
            min: 1
            r: 1
            s: 0
            text: <
        s: 0
    - !!perl/hash:RE_method
      min: 0
      name: O
      rest: (|%multiplicative)
infix__S_311TildeGt: !!perl/hash:RE_ast
  decl: []
  kind: token
  min: 12345
  pkg: ~
  re: !!perl/hash:RE_sequence
    a: 0
    dba: infix__S_311TildeGt
    i: 0
    min: 12345
    r: 1
    s: 0
    zyg:
    - !!perl/hash:RE_method
      a: 0
      dba: infix__S_311TildeGt
      i: 0
      min: 12345
      name: sym
      r: 1
      rest: ''
      s: 0
      sym: ~>
    - !!perl/hash:RE_assertion
      assert: '!'
      min: 0
      re: !!perl/hash:RE_method_re
        a: 0
        dba: infix__S_311TildeGt
        i: 0
        min: 0
        name: before
        nobind: 1
        r: 1
        re: !!perl/hash:RE_ast
          decl: []
          min: 1
          re: !!perl/hash:RE_string
            a: 0
            dba: infix__S_311TildeGt
            i: 0
            min: 1
            r: 1
            s: 0
            text: '>'
        s: 0
    - !!perl/hash:RE_method
      min: 0
      name: O
      rest: (|%multiplicative)
infix__S_312Plus: !!perl/hash:RE_ast
  decl: []
  kind: token
  min: 12345
  pkg: ~
  re: !!perl/hash:RE_sequence
    a: 0
    dba: infix__S_312Plus
    i: 0
    min: 12345
    r: 1
    s: 0
    zyg:
    - !!perl/hash:RE_method
      a: 0
      dba: infix__S_312Plus
      i: 0
      min: 12345
      name: sym
      r: 1
      rest: ''
      s: 0
      sym: +
    - !!perl/hash:RE_assertion
      assert: '!'
      min: 0
      re: !!perl/hash:RE_method_re
        a: 0
        dba: infix__S_312Plus
        i: 0
        min: 0
        name: before
        nobind: 1
        r: 1
        re: !!perl/hash:RE_ast
          decl: []
          min: 1
          re: !!perl/hash:RE_string
            a: 0
            dba: infix__S_312Plus
            i: 0
            min: 1
            r: 1
            s: 0
            text: +
        s: 0
    - !!perl/hash:RE_method
      min: 0
      name: O
      rest: (|%additive)
infix__S_313Minus: !!perl/hash:RE_ast
  decl: []
  kind: token
  min: 12345
  pkg: ~
  re: !!perl/hash:RE_sequence
    a: 0
    dba: infix__S_313Minus
    i: 0
    min: 12345
    r: 1
    s: 0
    zyg:
    - !!perl/hash:RE_method
      a: 0
      dba: infix__S_313Minus
      i: 0
      min: 12345
      name: sym
      r: 1
      rest: ''
      s: 0
      sym: '-'
    - !!perl/hash:RE_assertion
      assert: '!'
      min: 0
      re: !!perl/hash:RE_method_re
        a: 0
        dba: infix__S_313Minus
        i: 0
        min: 0
        name: before
        nobind: 1
        r: 1
        re: !!perl/hash:RE_ast
          decl: []
          min: 1
          re: !!perl/hash:RE_string
            a: 0
            dba: infix__S_313Minus
            i: 0
            min: 1
            r: 1
            s: 0
            text: '-'
        s: 0
    - !!perl/hash:RE_method
      min: 0
      name: O
      rest: (|%additive)
infix__S_314PlusVert: !!perl/hash:RE_ast
  decl: []
  kind: token
  min: 12345
  pkg: ~
  re: !!perl/hash:RE_sequence
    a: 0
    dba: infix__S_314PlusVert
    i: 0
    min: 12345
    r: 1
    s: 0
    zyg:
    - !!perl/hash:RE_method
      a: 0
      dba: infix__S_314PlusVert
      i: 0
      min: 12345
      name: sym
      r: 1
      rest: ''
      s: 0
      sym: +|
    - !!perl/hash:RE_method
      min: 0
      name: O
      rest: (|%additive)
infix__S_315PlusCaret: !!perl/hash:RE_ast
  decl: []
  kind: token
  min: 12345
  pkg: ~
  re: !!perl/hash:RE_sequence
    a: 0
    dba: infix__S_315PlusCaret
    i: 0
    min: 12345
    r: 1
    s: 0
    zyg:
    - !!perl/hash:RE_method
      a: 0
      dba: infix__S_315PlusCaret
      i: 0
      min: 12345
      name: sym
      r: 1
      rest: ''
      s: 0
      sym: +^
    - !!perl/hash:RE_method
      min: 0
      name: O
      rest: (|%additive)
infix__S_316TildeVert: !!perl/hash:RE_ast
  decl: []
  kind: token
  min: 12345
  pkg: ~
  re: !!perl/hash:RE_sequence
    a: 0
    dba: infix__S_316TildeVert
    i: 0
    min: 12345
    r: 1
    s: 0
    zyg:
    - !!perl/hash:RE_method
      a: 0
      dba: infix__S_316TildeVert
      i: 0
      min: 12345
      name: sym
      r: 1
      rest: ''
      s: 0
      sym: ~|
    - !!perl/hash:RE_method
      min: 0
      name: O
      rest: (|%additive)
infix__S_317TildeCaret: !!perl/hash:RE_ast
  decl: []
  kind: token
  min: 12345
  pkg: ~
  re: !!perl/hash:RE_sequence
    a: 0
    dba: infix__S_317TildeCaret
    i: 0
    min: 12345
    r: 1
    s: 0
    zyg:
    - !!perl/hash:RE_method
      a: 0
      dba: infix__S_317TildeCaret
      i: 0
      min: 12345
      name: sym
      r: 1
      rest: ''
      s: 0
      sym: ~^
    - !!perl/hash:RE_method
      min: 0
      name: O
      rest: (|%additive)
infix__S_318QuestionVert: !!perl/hash:RE_ast
  decl: []
  kind: token
  min: 12345
  pkg: ~
  re: !!perl/hash:RE_sequence
    a: 0
    dba: infix__S_318QuestionVert
    i: 0
    min: 12345
    r: 1
    s: 0
    zyg:
    - !!perl/hash:RE_method
      a: 0
      dba: infix__S_318QuestionVert
      i: 0
      min: 12345
      name: sym
      r: 1
      rest: ''
      s: 0
      sym: ?|
    - !!perl/hash:RE_method
      min: 0
      name: O
      rest: (|%additive, iffy => 1)
infix__S_319QuestionCaret: !!perl/hash:RE_ast
  decl: []
  kind: token
  min: 12345
  pkg: ~
  re: !!perl/hash:RE_sequence
    a: 0
    dba: infix__S_319QuestionCaret
    i: 0
    min: 12345
    r: 1
    s: 0
    zyg:
    - !!perl/hash:RE_method
      a: 0
      dba: infix__S_319QuestionCaret
      i: 0
      min: 12345
      name: sym
      r: 1
      rest: ''
      s: 0
      sym: ?^
    - !!perl/hash:RE_method
      min: 0
      name: O
      rest: (|%additive)
infix__S_320x: !!perl/hash:RE_ast
  decl: []
  kind: token
  min: 12345
  pkg: ~
  re: !!perl/hash:RE_sequence
    a: 0
    dba: infix__S_320x
    i: 0
    min: 12345
    r: 1
    s: 0
    zyg:
    - !!perl/hash:RE_method
      a: 0
      dba: infix__S_320x
      i: 0
      min: 12345
      name: sym
      r: 1
      rest: ''
      s: 0
      sym: x
    - !!perl/hash:RE_method
      min: 0
      name: O
      rest: (|%replication)
infix__S_321xx: !!perl/hash:RE_ast
  decl: []
  kind: token
  min: 12345
  pkg: ~
  re: !!perl/hash:RE_sequence
    a: 0
    dba: infix__S_321xx
    i: 0
    min: 12345
    r: 1
    s: 0
    zyg:
    - !!perl/hash:RE_method
      a: 0
      dba: infix__S_321xx
      i: 0
      min: 12345
      name: sym
      r: 1
      rest: ''
      s: 0
      sym: xx
    - !!perl/hash:RE_method
      min: 0
      name: O
      rest: (|%replication)
infix__S_322Tilde: !!perl/hash:RE_ast
  decl: []
  kind: token
  min: 12345
  pkg: ~
  re: !!perl/hash:RE_sequence
    a: 0
    dba: infix__S_322Tilde
    i: 0
    min: 12345
    r: 1
    s: 0
    zyg:
    - !!perl/hash:RE_method
      a: 0
      dba: infix__S_322Tilde
      i: 0
      min: 12345
      name: sym
      r: 1
      rest: ''
      s: 0
      sym: '~'
    - !!perl/hash:RE_method
      min: 0
      name: O
      rest: (|%concatenation)
infix__S_323Amp: !!perl/hash:RE_ast
  decl: []
  kind: token
  min: 12345
  pkg: ~
  re: !!perl/hash:RE_sequence
    a: 0
    dba: infix__S_323Amp
    i: 0
    min: 12345
    r: 1
    s: 0
    zyg:
    - !!perl/hash:RE_method
      a: 0
      dba: infix__S_323Amp
      i: 0
      min: 12345
      name: sym
      r: 1
      rest: ''
      s: 0
      sym: '&'
    - !!perl/hash:RE_method
      min: 0
      name: O
      rest: (|%junctive_and, iffy => 1)
infix__S_324Vert: !!perl/hash:RE_ast
  decl: []
  kind: token
  min: 12345
  pkg: ~
  re: !!perl/hash:RE_sequence
    a: 0
    dba: infix__S_324Vert
    i: 0
    min: 12345
    r: 1
    s: 0
    zyg:
    - !!perl/hash:RE_method
      a: 0
      dba: infix__S_324Vert
      i: 0
      min: 12345
      name: sym
      r: 1
      rest: ''
      s: 0
      sym: '|'
    - !!perl/hash:RE_method
      min: 0
      name: O
      rest: (|%junctive_or, iffy => 1)
infix__S_325Caret: !!perl/hash:RE_ast
  decl: []
  kind: token
  min: 12345
  pkg: ~
  re: !!perl/hash:RE_sequence
    a: 0
    dba: infix__S_325Caret
    i: 0
    min: 12345
    r: 1
    s: 0
    zyg:
    - !!perl/hash:RE_method
      a: 0
      dba: infix__S_325Caret
      i: 0
      min: 12345
      name: sym
      r: 1
      rest: ''
      s: 0
      sym: ^
    - !!perl/hash:RE_method
      min: 0
      name: O
      rest: (|%junctive_or, iffy => 1)
infix__S_330LtEqualGt: !!perl/hash:RE_ast
  decl: []
  kind: token
  min: 12345
  pkg: ~
  re: !!perl/hash:RE_sequence
    a: 0
    dba: infix__S_330LtEqualGt
    i: 0
    min: 12345
    r: 1
    s: 0
    zyg:
    - !!perl/hash:RE_method
      a: 0
      dba: infix__S_330LtEqualGt
      i: 0
      min: 12345
      name: sym
      r: 1
      rest: ''
      s: 0
      sym: <=>
    - !!perl/hash:RE_method
      min: 0
      name: O
      rest: (|%structural, returns => 'Order')
infix__S_331cmp: !!perl/hash:RE_ast
  decl: []
  kind: token
  min: 12345
  pkg: ~
  re: !!perl/hash:RE_sequence
    a: 0
    dba: infix__S_331cmp
    i: 0
    min: 12345
    r: 1
    s: 0
    zyg:
    - !!perl/hash:RE_method
      a: 0
      dba: infix__S_331cmp
      i: 0
      min: 12345
      name: sym
      r: 1
      rest: ''
      s: 0
      sym: cmp
    - !!perl/hash:RE_method
      min: 0
      name: O
      rest: (|%structural, returns => 'Order')
infix__S_332leg: !!perl/hash:RE_ast
  decl: []
  kind: token
  min: 12345
  pkg: ~
  re: !!perl/hash:RE_sequence
    a: 0
    dba: infix__S_332leg
    i: 0
    min: 12345
    r: 1
    s: 0
    zyg:
    - !!perl/hash:RE_method
      a: 0
      dba: infix__S_332leg
      i: 0
      min: 12345
      name: sym
      r: 1
      rest: ''
      s: 0
      sym: leg
    - !!perl/hash:RE_method
      min: 0
      name: O
      rest: (|%structural, returns => 'Order')
infix__S_333but: !!perl/hash:RE_ast
  decl: []
  kind: token
  min: 12345
  pkg: ~
  re: !!perl/hash:RE_sequence
    a: 0
    dba: infix__S_333but
    i: 0
    min: 12345
    r: 1
    s: 0
    zyg:
    - !!perl/hash:RE_method
      a: 0
      dba: infix__S_333but
      i: 0
      min: 12345
      name: sym
      r: 1
      rest: ''
      s: 0
      sym: but
    - !!perl/hash:RE_method
      min: 0
      name: O
      rest: (|%structural)
infix__S_334does: !!perl/hash:RE_ast
  decl: []
  kind: token
  min: 12345
  pkg: ~
  re: !!perl/hash:RE_sequence
    a: 0
    dba: infix__S_334does
    i: 0
    min: 12345
    r: 1
    s: 0
    zyg:
    - !!perl/hash:RE_method
      a: 0
      dba: infix__S_334does
      i: 0
      min: 12345
      name: sym
      r: 1
      rest: ''
      s: 0
      sym: does
    - !!perl/hash:RE_method
      min: 0
      name: O
      rest: (|%structural)
infix__S_335DotDot: !!perl/hash:RE_ast
  decl: []
  kind: token
  min: 12345
  pkg: ~
  re: !!perl/hash:RE_sequence
    a: 0
    dba: infix__S_335DotDot
    i: 0
    min: 12345
    r: 1
    s: 0
    zyg:
    - !!perl/hash:RE_method
      a: 0
      dba: infix__S_335DotDot
      i: 0
      min: 12345
      name: sym
      r: 1
      rest: ''
      s: 0
      sym: ..
    - !!perl/hash:RE_quantified_atom
      atom: !!perl/hash:RE_bracket
        decl: []
        min: 0
        re: !!perl/hash:RE_sequence
          a: 0
          dba: infix__S_335DotDot
          i: 0
          min: 0
          r: 1
          s: 0
          zyg:
          - !!perl/hash:RE_assertion
            assert: '!'
            min: 0
            re: !!perl/hash:RE_block
              a: 0
              context: bool
              dba: infix__S_335DotDot
              i: 0
              min: 0
              nobind: 1
              r: 1
              s: 0
              text: ' $*IN_META '
          - !!perl/hash:RE_assertion
            assert: '?'
            min: 0
            re: !!perl/hash:RE_method_re
              a: 0
              dba: infix__S_335DotDot
              i: 0
              min: 0
              name: before
              nobind: 1
              r: 1
              re: !!perl/hash:RE_ast
                decl: []
                min: 1
                re: &16 !!perl/hash:RE_any
                  a: 0
                  altname: infix__S_335DotDot_02
                  dba: infix__S_335DotDot
                  i: 0
                  min: 1
                  name: infix__S_335DotDot_02
                  r: 1
                  s: 0
                  zyg:
                  - !!perl/hash:RE_string
                    a: 0
                    alt: infix__S_335DotDot_02 0
                    dba: infix__S_335DotDot
                    i: 0
                    min: 1
                    r: 1
                    s: 0
                    text: )
                  - !!perl/hash:RE_string
                    a: 0
                    alt: infix__S_335DotDot_02 1
                    dba: infix__S_335DotDot
                    i: 0
                    min: 1
                    r: 1
                    s: 0
                    text: ']'
              s: 0
          - !!perl/hash:RE_method
            min: 0
            name: panic
            nobind: 1
            rest: ("Please use ..* for indefinite range")
      min: 0
      quant:
      - '?'
      - ':'
      - ''
      - 0
    - !!perl/hash:RE_method
      min: 0
      name: O
      rest: (|%structural)
infix__S_335DotDot_02: *16
infix__S_336CaretDotDot: !!perl/hash:RE_ast
  decl: []
  kind: token
  min: 12345
  pkg: ~
  re: !!perl/hash:RE_sequence
    a: 0
    dba: infix__S_336CaretDotDot
    i: 0
    min: 12345
    r: 1
    s: 0
    zyg:
    - !!perl/hash:RE_method
      a: 0
      dba: infix__S_336CaretDotDot
      i: 0
      min: 12345
      name: sym
      r: 1
      rest: ''
      s: 0
      sym: ^..
    - !!perl/hash:RE_method
      min: 0
      name: O
      rest: (|%structural)
infix__S_337DotDotCaret: !!perl/hash:RE_ast
  decl: []
  kind: token
  min: 12345
  pkg: ~
  re: !!perl/hash:RE_sequence
    a: 0
    dba: infix__S_337DotDotCaret
    i: 0
    min: 12345
    r: 1
    s: 0
    zyg:
    - !!perl/hash:RE_method
      a: 0
      dba: infix__S_337DotDotCaret
      i: 0
      min: 12345
      name: sym
      r: 1
      rest: ''
      s: 0
      sym: ..^
    - !!perl/hash:RE_method
      min: 0
      name: O
      rest: (|%structural)
infix__S_338CaretDotDotCaret: !!perl/hash:RE_ast
  decl: []
  kind: token
  min: 12345
  pkg: ~
  re: !!perl/hash:RE_sequence
    a: 0
    dba: infix__S_338CaretDotDotCaret
    i: 0
    min: 12345
    r: 1
    s: 0
    zyg:
    - !!perl/hash:RE_method
      a: 0
      dba: infix__S_338CaretDotDotCaret
      i: 0
      min: 12345
      name: sym
      r: 1
      rest: ''
      s: 0
      sym: ^..^
    - !!perl/hash:RE_method
      min: 0
      name: O
      rest: (|%structural)
infix__S_339EqualEqual: !!perl/hash:RE_ast
  decl: []
  kind: token
  min: 12345
  pkg: ~
  re: !!perl/hash:RE_sequence
    a: 0
    dba: infix__S_339EqualEqual
    i: 0
    min: 12345
    r: 1
    s: 0
    zyg:
    - !!perl/hash:RE_method
      a: 0
      dba: infix__S_339EqualEqual
      i: 0
      min: 12345
      name: sym
      r: 1
      rest: ''
      s: 0
      sym: ==
    - !!perl/hash:RE_assertion
      assert: '!'
      min: 0
      re: !!perl/hash:RE_method_re
        a: 0
        dba: infix__S_339EqualEqual
        i: 0
        min: 0
        name: before
        nobind: 1
        r: 1
        re: !!perl/hash:RE_ast
          decl: []
          min: 1
          re: !!perl/hash:RE_string
            a: 0
            dba: infix__S_339EqualEqual
            i: 0
            min: 1
            r: 1
            s: 0
            text: =
        s: 0
    - !!perl/hash:RE_method
      min: 0
      name: O
      rest: (|%chaining)
infix__S_340BangEqual: !!perl/hash:RE_ast
  decl: []
  kind: token
  min: 12345
  pkg: ~
  re: !!perl/hash:RE_sequence
    a: 0
    dba: infix__S_340BangEqual
    i: 0
    min: 12345
    r: 1
    s: 0
    zyg:
    - !!perl/hash:RE_method
      a: 0
      dba: infix__S_340BangEqual
      i: 0
      min: 12345
      name: sym
      r: 1
      rest: ''
      s: 0
      sym: '!='
    - !!perl/hash:RE_assertion
      assert: '?'
      min: 0
      re: !!perl/hash:RE_method_re
        a: 0
        dba: infix__S_340BangEqual
        i: 0
        min: 0
        name: before
        nobind: 1
        r: 1
        re: !!perl/hash:RE_ast
          decl: []
          min: 1
          re: !!perl/hash:RE_meta
            a: 0
            dba: infix__S_340BangEqual
            i: 0
            min: 1
            r: 1
            s: 0
            text: \s
        s: 0
    - !!perl/hash:RE_method
      min: 0
      name: O
      rest: (|%chaining)
infix__S_341Lt: !!perl/hash:RE_ast
  decl: []
  kind: token
  min: 12345
  pkg: ~
  re: !!perl/hash:RE_sequence
    a: 0
    dba: infix__S_341Lt
    i: 0
    min: 12345
    r: 1
    s: 0
    zyg:
    - !!perl/hash:RE_method
      a: 0
      dba: infix__S_341Lt
      i: 0
      min: 12345
      name: sym
      r: 1
      rest: ''
      s: 0
      sym: <
    - !!perl/hash:RE_method
      min: 0
      name: O
      rest: (|%chaining)
infix__S_342LtEqual: !!perl/hash:RE_ast
  decl: []
  kind: token
  min: 12345
  pkg: ~
  re: !!perl/hash:RE_sequence
    a: 0
    dba: infix__S_342LtEqual
    i: 0
    min: 12345
    r: 1
    s: 0
    zyg:
    - !!perl/hash:RE_method
      a: 0
      dba: infix__S_342LtEqual
      i: 0
      min: 12345
      name: sym
      r: 1
      rest: ''
      s: 0
      sym: <=
    - !!perl/hash:RE_method
      min: 0
      name: O
      rest: (|%chaining)
infix__S_343Gt: !!perl/hash:RE_ast
  decl: []
  kind: token
  min: 12345
  pkg: ~
  re: !!perl/hash:RE_sequence
    a: 0
    dba: infix__S_343Gt
    i: 0
    min: 12345
    r: 1
    s: 0
    zyg:
    - !!perl/hash:RE_method
      a: 0
      dba: infix__S_343Gt
      i: 0
      min: 12345
      name: sym
      r: 1
      rest: ''
      s: 0
      sym: '>'
    - !!perl/hash:RE_method
      min: 0
      name: O
      rest: (|%chaining)
infix__S_344GtEqual: !!perl/hash:RE_ast
  decl: []
  kind: token
  min: 12345
  pkg: ~
  re: !!perl/hash:RE_sequence
    a: 0
    dba: infix__S_344GtEqual
    i: 0
    min: 12345
    r: 1
    s: 0
    zyg:
    - !!perl/hash:RE_method
      a: 0
      dba: infix__S_344GtEqual
      i: 0
      min: 12345
      name: sym
      r: 1
      rest: ''
      s: 0
      sym: '>='
    - !!perl/hash:RE_method
      min: 0
      name: O
      rest: (|%chaining)
infix__S_345TildeTilde: !!perl/hash:RE_ast
  decl: []
  kind: token
  min: 12345
  pkg: ~
  re: !!perl/hash:RE_sequence
    a: 0
    dba: infix__S_345TildeTilde
    i: 0
    min: 12345
    r: 1
    s: 0
    zyg:
    - !!perl/hash:RE_method
      a: 0
      dba: infix__S_345TildeTilde
      i: 0
      min: 12345
      name: sym
      r: 1
      rest: ''
      s: 0
      sym: ~~
    - !!perl/hash:RE_method
      min: 0
      name: O
      rest: (|%chaining)
infix__S_346BangTilde: !!perl/hash:RE_ast
  decl: []
  kind: token
  min: 12346
  pkg: ~
  re: !!perl/hash:RE_sequence
    a: 0
    dba: infix__S_346BangTilde
    i: 0
    min: 12346
    r: 1
    s: 0
    zyg:
    - !!perl/hash:RE_method
      a: 0
      dba: infix__S_346BangTilde
      i: 0
      min: 12345
      name: sym
      r: 1
      rest: ''
      s: 0
      sym: '!~'
    - !!perl/hash:RE_meta
      a: 0
      dba: infix__S_346BangTilde
      i: 0
      min: 1
      r: 1
      s: 0
      text: \s
    - !!perl/hash:RE_method
      min: 0
      name: obs
      nobind: 1
      rest: ('!~ to do negated pattern matching', '!~~')
    - !!perl/hash:RE_method
      min: 0
      name: O
      rest: (|%chaining)
infix__S_347EqualTilde: !!perl/hash:RE_ast
  decl: []
  kind: token
  min: 12345
  pkg: ~
  re: !!perl/hash:RE_sequence
    a: 0
    dba: infix__S_347EqualTilde
    i: 0
    min: 12345
    r: 1
    s: 0
    zyg:
    - !!perl/hash:RE_method
      a: 0
      dba: infix__S_347EqualTilde
      i: 0
      min: 12345
      name: sym
      r: 1
      rest: ''
      s: 0
      sym: =~
    - !!perl/hash:RE_method
      min: 0
      name: obs
      nobind: 1
      rest: ('=~ to do pattern matching', '~~')
    - !!perl/hash:RE_method
      min: 0
      name: O
      rest: (|%chaining)
infix__S_348eq: !!perl/hash:RE_ast
  decl: []
  kind: token
  min: 12345
  pkg: ~
  re: !!perl/hash:RE_sequence
    a: 0
    dba: infix__S_348eq
    i: 0
    min: 12345
    r: 1
    s: 0
    zyg:
    - !!perl/hash:RE_method
      a: 0
      dba: infix__S_348eq
      i: 0
      min: 12345
      name: sym
      r: 1
      rest: ''
      s: 0
      sym: eq
    - !!perl/hash:RE_method
      min: 0
      name: O
      rest: (|%chaining)
infix__S_349ne: !!perl/hash:RE_ast
  decl: []
  kind: token
  min: 12345
  pkg: ~
  re: !!perl/hash:RE_sequence
    a: 0
    dba: infix__S_349ne
    i: 0
    min: 12345
    r: 1
    s: 0
    zyg:
    - !!perl/hash:RE_method
      a: 0
      dba: infix__S_349ne
      i: 0
      min: 12345
      name: sym
      r: 1
      rest: ''
      s: 0
      sym: ne
    - !!perl/hash:RE_method
      min: 0
      name: O
      rest: (|%chaining)
infix__S_350lt: !!perl/hash:RE_ast
  decl: []
  kind: token
  min: 12345
  pkg: ~
  re: !!perl/hash:RE_sequence
    a: 0
    dba: infix__S_350lt
    i: 0
    min: 12345
    r: 1
    s: 0
    zyg:
    - !!perl/hash:RE_method
      a: 0
      dba: infix__S_350lt
      i: 0
      min: 12345
      name: sym
      r: 1
      rest: ''
      s: 0
      sym: lt
    - !!perl/hash:RE_method
      min: 0
      name: O
      rest: (|%chaining)
infix__S_351le: !!perl/hash:RE_ast
  decl: []
  kind: token
  min: 12345
  pkg: ~
  re: !!perl/hash:RE_sequence
    a: 0
    dba: infix__S_351le
    i: 0
    min: 12345
    r: 1
    s: 0
    zyg:
    - !!perl/hash:RE_method
      a: 0
      dba: infix__S_351le
      i: 0
      min: 12345
      name: sym
      r: 1
      rest: ''
      s: 0
      sym: le
    - !!perl/hash:RE_method
      min: 0
      name: O
      rest: (|%chaining)
infix__S_352gt: !!perl/hash:RE_ast
  decl: []
  kind: token
  min: 12345
  pkg: ~
  re: !!perl/hash:RE_sequence
    a: 0
    dba: infix__S_352gt
    i: 0
    min: 12345
    r: 1
    s: 0
    zyg:
    - !!perl/hash:RE_method
      a: 0
      dba: infix__S_352gt
      i: 0
      min: 12345
      name: sym
      r: 1
      rest: ''
      s: 0
      sym: gt
    - !!perl/hash:RE_method
      min: 0
      name: O
      rest: (|%chaining)
infix__S_353ge: !!perl/hash:RE_ast
  decl: []
  kind: token
  min: 12345
  pkg: ~
  re: !!perl/hash:RE_sequence
    a: 0
    dba: infix__S_353ge
    i: 0
    min: 12345
    r: 1
    s: 0
    zyg:
    - !!perl/hash:RE_method
      a: 0
      dba: infix__S_353ge
      i: 0
      min: 12345
      name: sym
      r: 1
      rest: ''
      s: 0
      sym: ge
    - !!perl/hash:RE_method
      min: 0
      name: O
      rest: (|%chaining)
infix__S_354EqualColonEqual: !!perl/hash:RE_ast
  decl: []
  kind: token
  min: 12345
  pkg: ~
  re: !!perl/hash:RE_sequence
    a: 0
    dba: infix__S_354EqualColonEqual
    i: 0
    min: 12345
    r: 1
    s: 0
    zyg:
    - !!perl/hash:RE_method
      a: 0
      dba: infix__S_354EqualColonEqual
      i: 0
      min: 12345
      name: sym
      r: 1
      rest: ''
      s: 0
      sym: =:=
    - !!perl/hash:RE_method
      min: 0
      name: O
      rest: (|%chaining)
infix__S_355EqualEqualEqual: !!perl/hash:RE_ast
  decl: []
  kind: token
  min: 12345
  pkg: ~
  re: !!perl/hash:RE_sequence
    a: 0
    dba: infix__S_355EqualEqualEqual
    i: 0
    min: 12345
    r: 1
    s: 0
    zyg:
    - !!perl/hash:RE_method
      a: 0
      dba: infix__S_355EqualEqualEqual
      i: 0
      min: 12345
      name: sym
      r: 1
      rest: ''
      s: 0
      sym: ===
    - !!perl/hash:RE_method
      min: 0
      name: O
      rest: (|%chaining)
infix__S_356eqv: !!perl/hash:RE_ast
  decl: []
  kind: token
  min: 12345
  pkg: ~
  re: !!perl/hash:RE_sequence
    a: 0
    dba: infix__S_356eqv
    i: 0
    min: 12345
    r: 1
    s: 0
    zyg:
    - !!perl/hash:RE_method
      a: 0
      dba: infix__S_356eqv
      i: 0
      min: 12345
      name: sym
      r: 1
      rest: ''
      s: 0
      sym: eqv
    - !!perl/hash:RE_method
      min: 0
      name: O
      rest: (|%chaining)
infix__S_357before: !!perl/hash:RE_ast
  decl: []
  kind: token
  min: 12345
  pkg: ~
  re: !!perl/hash:RE_sequence
    a: 0
    dba: infix__S_357before
    i: 0
    min: 12345
    r: 1
    s: 0
    zyg:
    - !!perl/hash:RE_method
      a: 0
      dba: infix__S_357before
      i: 0
      min: 12345
      name: sym
      r: 1
      rest: ''
      s: 0
      sym: before
    - !!perl/hash:RE_method
      min: 0
      name: O
      rest: (|%chaining)
infix__S_358after: !!perl/hash:RE_ast
  decl: []
  kind: token
  min: 12345
  pkg: ~
  re: !!perl/hash:RE_sequence
    a: 0
    dba: infix__S_358after
    i: 0
    min: 12345
    r: 1
    s: 0
    zyg:
    - !!perl/hash:RE_method
      a: 0
      dba: infix__S_358after
      i: 0
      min: 12345
      name: sym
      r: 1
      rest: ''
      s: 0
      sym: after
    - !!perl/hash:RE_method
      min: 0
      name: O
      rest: (|%chaining)
infix__S_359AmpAmp: !!perl/hash:RE_ast
  decl: []
  kind: token
  min: 12345
  pkg: ~
  re: !!perl/hash:RE_sequence
    a: 0
    dba: infix__S_359AmpAmp
    i: 0
    min: 12345
    r: 1
    s: 0
    zyg:
    - !!perl/hash:RE_method
      a: 0
      dba: infix__S_359AmpAmp
      i: 0
      min: 12345
      name: sym
      r: 1
      rest: ''
      s: 0
      sym: '&&'
    - !!perl/hash:RE_method
      min: 0
      name: O
      rest: (|%tight_and, iffy => 1)
infix__S_360VertVert: !!perl/hash:RE_ast
  decl: []
  kind: token
  min: 12345
  pkg: ~
  re: !!perl/hash:RE_sequence
    a: 0
    dba: infix__S_360VertVert
    i: 0
    min: 12345
    r: 1
    s: 0
    zyg:
    - !!perl/hash:RE_method
      a: 0
      dba: infix__S_360VertVert
      i: 0
      min: 12345
      name: sym
      r: 1
      rest: ''
      s: 0
      sym: '||'
    - !!perl/hash:RE_method
      min: 0
      name: O
      rest: (|%tight_or, iffy => 1)
infix__S_361CaretCaret: !!perl/hash:RE_ast
  decl: []
  kind: token
  min: 12345
  pkg: ~
  re: !!perl/hash:RE_sequence
    a: 0
    dba: infix__S_361CaretCaret
    i: 0
    min: 12345
    r: 1
    s: 0
    zyg:
    - !!perl/hash:RE_method
      a: 0
      dba: infix__S_361CaretCaret
      i: 0
      min: 12345
      name: sym
      r: 1
      rest: ''
      s: 0
      sym: ^^
    - !!perl/hash:RE_method
      min: 0
      name: O
      rest: (|%tight_or, iffy => 1)
infix__S_362SlashSlash: !!perl/hash:RE_ast
  decl: []
  kind: token
  min: 12345
  pkg: ~
  re: !!perl/hash:RE_sequence
    a: 0
    dba: infix__S_362SlashSlash
    i: 0
    min: 12345
    r: 1
    s: 0
    zyg:
    - !!perl/hash:RE_method
      a: 0
      dba: infix__S_362SlashSlash
      i: 0
      min: 12345
      name: sym
      r: 1
      rest: ''
      s: 0
      sym: //
    - !!perl/hash:RE_method
      min: 0
      name: O
      rest: (|%tight_or)
infix__S_363min: !!perl/hash:RE_ast
  decl: []
  kind: token
  min: 12345
  pkg: ~
  re: !!perl/hash:RE_sequence
    a: 0
    dba: infix__S_363min
    i: 0
    min: 12345
    r: 1
    s: 0
    zyg:
    - !!perl/hash:RE_method
      a: 0
      dba: infix__S_363min
      i: 0
      min: 12345
      name: sym
      r: 1
      rest: ''
      s: 0
      sym: min
    - !!perl/hash:RE_method
      min: 0
      name: O
      rest: (|%tight_or)
infix__S_364max: !!perl/hash:RE_ast
  decl: []
  kind: token
  min: 12345
  pkg: ~
  re: !!perl/hash:RE_sequence
    a: 0
    dba: infix__S_364max
    i: 0
    min: 12345
    r: 1
    s: 0
    zyg:
    - !!perl/hash:RE_method
      a: 0
      dba: infix__S_364max
      i: 0
      min: 12345
      name: sym
      r: 1
      rest: ''
      s: 0
      sym: max
    - !!perl/hash:RE_method
      min: 0
      name: O
      rest: (|%tight_or)
infix__S_365QuestionQuestion_BangBang: !!perl/hash:RE_ast
  decl:
  - !!perl/hash:RE_decl
    a: 0
    dba: infix__S_365QuestionQuestion_BangBang
    i: 0
    max: 0
    min: 0
    r: 1
    s: 0
    text: my $*GOAL ::= '!!'
  kind: token
  min: 12347
  pkg: ~
  re: !!perl/hash:RE_sequence
    a: 0
    dba: infix__S_365QuestionQuestion_BangBang
    i: 0
    min: 12347
    r: 1
    s: 0
    zyg:
    - !!perl/hash:RE_string
      a: 0
      dba: infix__S_365QuestionQuestion_BangBang
      i: 0
      min: 2
      r: 1
      s: 0
      text: ??
    - !!perl/hash:RE_method
      a: 0
      dba: infix__S_365QuestionQuestion_BangBang
      i: 0
      min: 12345
      name: ws
      nobind: 1
      r: 1
      rest: ''
      s: 0
    - !!perl/hash:RE_method
      min: 0
      name: EXPR
      rest: (item %item_assignment)
    - !!perl/hash:RE_bracket
      decl: []
      min: 0
      re: !!perl/hash:RE_first
        a: 0
        dba: infix__S_365QuestionQuestion_BangBang
        i: 0
        min: 0
        r: 1
        s: 0
        zyg:
        - !!perl/hash:RE_string
          a: 0
          dba: infix__S_365QuestionQuestion_BangBang
          i: 0
          min: 2
          r: 1
          s: 0
          text: '!!'
        - !!perl/hash:RE_bracket
          decl: []
          min: 0
          re: !!perl/hash:RE_first
            a: 0
            dba: infix__S_365QuestionQuestion_BangBang
            i: 0
            min: 0
            r: 1
            s: 0
            zyg:
            - !!perl/hash:RE_sequence
              a: 0
              dba: infix__S_365QuestionQuestion_BangBang
              i: 0
              min: 0
              r: 1
              s: 0
              zyg:
              - !!perl/hash:RE_assertion
                assert: '?'
                min: 0
                re: !!perl/hash:RE_method_re
                  a: 0
                  dba: infix__S_365QuestionQuestion_BangBang
                  i: 0
                  min: 0
                  name: before
                  nobind: 1
                  r: 1
                  re: !!perl/hash:RE_ast
                    decl: []
                    min: 1
                    re: !!perl/hash:RE_string
                      a: 0
                      dba: infix__S_365QuestionQuestion_BangBang
                      i: 0
                      min: 1
                      r: 1
                      s: 0
                      text: =
                  s: 0
              - !!perl/hash:RE_method
                min: 0
                name: panic
                nobind: 1
                rest: ("Assignment not allowed within ??!!")
            - !!perl/hash:RE_sequence
              a: 0
              dba: infix__S_365QuestionQuestion_BangBang
              i: 0
              min: 0
              r: 1
              s: 0
              zyg:
              - !!perl/hash:RE_assertion
                assert: '?'
                min: 0
                re: !!perl/hash:RE_method_re
                  a: 0
                  dba: infix__S_365QuestionQuestion_BangBang
                  i: 0
                  min: 0
                  name: before
                  nobind: 1
                  r: 1
                  re: !!perl/hash:RE_ast
                    decl: []
                    min: 2
                    re: !!perl/hash:RE_string
                      a: 0
                      dba: infix__S_365QuestionQuestion_BangBang
                      i: 0
                      min: 2
                      r: 1
                      s: 0
                      text: '::'
                  s: 0
              - !!perl/hash:RE_method
                min: 0
                name: panic
                nobind: 1
                rest: ("Please use !! rather than ::")
            - !!perl/hash:RE_sequence
              a: 0
              dba: infix__S_365QuestionQuestion_BangBang
              i: 0
              min: 0
              r: 1
              s: 0
              zyg:
              - !!perl/hash:RE_assertion
                assert: '?'
                min: 0
                re: !!perl/hash:RE_method_re
                  a: 0
                  dba: infix__S_365QuestionQuestion_BangBang
                  i: 0
                  min: 0
                  name: before
                  nobind: 1
                  r: 1
                  re: !!perl/hash:RE_ast
                    decl: []
                    min: 12345
                    re: !!perl/hash:RE_method
                      a: 0
                      dba: infix__S_365QuestionQuestion_BangBang
                      i: 0
                      min: 12345
                      name: infixish
                      r: 1
                      rest: ''
                      s: 0
                  s: 0
              - !!perl/hash:RE_method
                min: 0
                name: panic
                nobind: 1
                rest: ("Precedence too loose within ??!!; use ??()!! instead ")
            - !!perl/hash:RE_method
              min: 0
              name: panic
              nobind: 1
              rest: ("Found ?? but no !!; possible precedence problem")
    - !!perl/hash:RE_method
      min: 0
      name: O
      rest: (|%conditional, _reducecheck => 'raise_middle')
infix__S_366BangBang: !!perl/hash:RE_ast
  decl: []
  kind: token
  min: 12345
  pkg: ~
  re: !!perl/hash:RE_sequence
    a: 0
    dba: infix__S_366BangBang
    i: 0
    min: 12345
    r: 1
    s: 0
    zyg:
    - !!perl/hash:RE_method
      a: 0
      dba: infix__S_366BangBang
      i: 0
      min: 12345
      name: sym
      r: 1
      rest: ''
      s: 0
      sym: '!!'
    - !!perl/hash:RE_method
      min: 0
      name: panic
      nobind: 1
      rest: ("Ternary !! seems to be missing its ??")
infix__S_367Question: !!perl/hash:RE_ast
  decl: []
  kind: token
  min: 12345
  pkg: ~
  re: !!perl/hash:RE_sequence
    a: 0
    dba: infix__S_367Question
    i: 0
    min: 12345
    r: 1
    s: 0
    zyg:
    - !!perl/hash:RE_method
      a: 0
      dba: infix__S_367Question
      i: 0
      min: 12345
      name: sym
      r: 1
      rest: ''
      s: 0
      sym: '?'
    - !!perl/hash:RE_block
      a: 0
      context: void
      dba: infix__S_367Question
      i: 0
      min: 0
      r: 1
      s: 0
      text: ''
    - !!perl/hash:RE_assertion
      assert: '!'
      min: 0
      re: !!perl/hash:RE_method_re
        a: 0
        dba: infix__S_367Question
        i: 0
        min: 0
        name: before
        nobind: 1
        r: 1
        re: !!perl/hash:RE_ast
          decl: []
          min: 1
          re: !!perl/hash:RE_string
            a: 0
            dba: infix__S_367Question
            i: 0
            min: 1
            r: 1
            s: 0
            text: '?'
        s: 0
    - !!perl/hash:RE_assertion
      assert: '?'
      min: 0
      re: !!perl/hash:RE_method_re
        a: 0
        dba: infix__S_367Question
        i: 0
        min: 0
        name: before
        nobind: 1
        r: 1
        re: !!perl/hash:RE_ast
          decl: []
          min: 1
          re: !!perl/hash:RE_sequence
            a: 0
            dba: infix__S_367Question
            i: 0
            min: 1
            r: 1
            s: 0
            zyg:
            - !!perl/hash:RE_quantified_atom
              atom: !!perl/hash:RE_cclass
                a: 0
                dba: infix__S_367Question
                i: 0
                min: 1
                r: 1
                s: 0
                text: -[;]
              min: 0
              quant:
              - '*'
              - '?'
              - ''
              - 0
            - !!perl/hash:RE_string
              a: 0
              dba: infix__S_367Question
              i: 0
              min: 1
              r: 1
              s: 0
              text: ':'
        s: 0
    - !!perl/hash:RE_method
      min: 0
      name: obs
      nobind: 1
      rest: '(''?: for the conditional operator'', ''??!!'')'
    - !!perl/hash:RE_method
      min: 0
      name: O
      rest: (|%conditional)
infix__S_368ff: !!perl/hash:RE_ast
  decl: []
  kind: token
  min: 12345
  pkg: ~
  re: !!perl/hash:RE_sequence
    a: 0
    dba: infix__S_368ff
    i: 0
    min: 12345
    r: 1
    s: 0
    zyg:
    - !!perl/hash:RE_method
      a: 0
      dba: infix__S_368ff
      i: 0
      min: 12345
      name: sym
      r: 1
      rest: ''
      s: 0
      sym: ff
    - !!perl/hash:RE_method
      min: 0
      name: O
      rest: (|%conditional)
infix__S_369Caretff: !!perl/hash:RE_ast
  decl: []
  kind: token
  min: 12345
  pkg: ~
  re: !!perl/hash:RE_sequence
    a: 0
    dba: infix__S_369Caretff
    i: 0
    min: 12345
    r: 1
    s: 0
    zyg:
    - !!perl/hash:RE_method
      a: 0
      dba: infix__S_369Caretff
      i: 0
      min: 12345
      name: sym
      r: 1
      rest: ''
      s: 0
      sym: ^ff
    - !!perl/hash:RE_method
      min: 0
      name: O
      rest: (|%conditional)
infix__S_370ffCaret: !!perl/hash:RE_ast
  decl: []
  kind: token
  min: 12345
  pkg: ~
  re: !!perl/hash:RE_sequence
    a: 0
    dba: infix__S_370ffCaret
    i: 0
    min: 12345
    r: 1
    s: 0
    zyg:
    - !!perl/hash:RE_method
      a: 0
      dba: infix__S_370ffCaret
      i: 0
      min: 12345
      name: sym
      r: 1
      rest: ''
      s: 0
      sym: ff^
    - !!perl/hash:RE_method
      min: 0
      name: O
      rest: (|%conditional)
infix__S_371CaretffCaret: !!perl/hash:RE_ast
  decl: []
  kind: token
  min: 12345
  pkg: ~
  re: !!perl/hash:RE_sequence
    a: 0
    dba: infix__S_371CaretffCaret
    i: 0
    min: 12345
    r: 1
    s: 0
    zyg:
    - !!perl/hash:RE_method
      a: 0
      dba: infix__S_371CaretffCaret
      i: 0
      min: 12345
      name: sym
      r: 1
      rest: ''
      s: 0
      sym: ^ff^
    - !!perl/hash:RE_method
      min: 0
      name: O
      rest: (|%conditional)
infix__S_372fff: !!perl/hash:RE_ast
  decl: []
  kind: token
  min: 12345
  pkg: ~
  re: !!perl/hash:RE_sequence
    a: 0
    dba: infix__S_372fff
    i: 0
    min: 12345
    r: 1
    s: 0
    zyg:
    - !!perl/hash:RE_method
      a: 0
      dba: infix__S_372fff
      i: 0
      min: 12345
      name: sym
      r: 1
      rest: ''
      s: 0
      sym: fff
    - !!perl/hash:RE_method
      min: 0
      name: O
      rest: (|%conditional)
infix__S_373Caretfff: !!perl/hash:RE_ast
  decl: []
  kind: token
  min: 12345
  pkg: ~
  re: !!perl/hash:RE_sequence
    a: 0
    dba: infix__S_373Caretfff
    i: 0
    min: 12345
    r: 1
    s: 0
    zyg:
    - !!perl/hash:RE_method
      a: 0
      dba: infix__S_373Caretfff
      i: 0
      min: 12345
      name: sym
      r: 1
      rest: ''
      s: 0
      sym: ^fff
    - !!perl/hash:RE_method
      min: 0
      name: O
      rest: (|%conditional)
infix__S_374fffCaret: !!perl/hash:RE_ast
  decl: []
  kind: token
  min: 12345
  pkg: ~
  re: !!perl/hash:RE_sequence
    a: 0
    dba: infix__S_374fffCaret
    i: 0
    min: 12345
    r: 1
    s: 0
    zyg:
    - !!perl/hash:RE_method
      a: 0
      dba: infix__S_374fffCaret
      i: 0
      min: 12345
      name: sym
      r: 1
      rest: ''
      s: 0
      sym: fff^
    - !!perl/hash:RE_method
      min: 0
      name: O
      rest: (|%conditional)
infix__S_375CaretfffCaret: !!perl/hash:RE_ast
  decl: []
  kind: token
  min: 12345
  pkg: ~
  re: !!perl/hash:RE_sequence
    a: 0
    dba: infix__S_375CaretfffCaret
    i: 0
    min: 12345
    r: 1
    s: 0
    zyg:
    - !!perl/hash:RE_method
      a: 0
      dba: infix__S_375CaretfffCaret
      i: 0
      min: 12345
      name: sym
      r: 1
      rest: ''
      s: 0
      sym: ^fff^
    - !!perl/hash:RE_method
      min: 0
      name: O
      rest: (|%conditional)
infix__S_376Equal: !!perl/hash:RE_ast
  decl: []
  kind: token
  min: 12345
  pkg: ~
  re: !!perl/hash:RE_sequence
    a: 0
    dba: infix__S_376Equal
    i: 0
    min: 12345
    r: 1
    s: 0
    zyg:
    - !!perl/hash:RE_method
      a: 0
      dba: infix__S_376Equal
      i: 0
      min: 12345
      name: sym
      r: 1
      rest: ''
      s: 0
      sym: =
    - !!perl/hash:RE_bracket
      decl: []
      min: 0
      re: !!perl/hash:RE_first
        a: 0
        dba: infix__S_376Equal
        i: 0
        min: 0
        r: 1
        s: 0
        zyg:
        - !!perl/hash:RE_sequence
          a: 0
          dba: infix__S_376Equal
          i: 0
          min: 0
          r: 1
          s: 0
          zyg:
          - !!perl/hash:RE_assertion
            assert: '?'
            min: 0
            re: !!perl/hash:RE_block
              a: 0
              context: bool
              dba: infix__S_376Equal
              i: 0
              min: 0
              nobind: 1
              r: 1
              s: 0
              text: ' $*LEFTSIGIL eq ''$'' '
          - !!perl/hash:RE_method
            min: 0
            name: O
            rest: (|%item_assignment)
        - !!perl/hash:RE_method
          min: 0
          name: O
          rest: (|%list_assignment)
infix__S_377ColonEqual: !!perl/hash:RE_ast
  decl: []
  kind: token
  min: 12345
  pkg: ~
  re: !!perl/hash:RE_sequence
    a: 0
    dba: infix__S_377ColonEqual
    i: 0
    min: 12345
    r: 1
    s: 0
    zyg:
    - !!perl/hash:RE_method
      a: 0
      dba: infix__S_377ColonEqual
      i: 0
      min: 12345
      name: sym
      r: 1
      rest: ''
      s: 0
      sym: :=
    - !!perl/hash:RE_method
      min: 0
      name: O
      rest: (|%item_assignment)
infix__S_378ColonColonEqual: !!perl/hash:RE_ast
  decl: []
  kind: token
  min: 12345
  pkg: ~
  re: !!perl/hash:RE_sequence
    a: 0
    dba: infix__S_378ColonColonEqual
    i: 0
    min: 12345
    r: 1
    s: 0
    zyg:
    - !!perl/hash:RE_method
      a: 0
      dba: infix__S_378ColonColonEqual
      i: 0
      min: 12345
      name: sym
      r: 1
      rest: ''
      s: 0
      sym: ::=
    - !!perl/hash:RE_method
      min: 0
      name: O
      rest: (|%item_assignment)
infix__S_379DotEqual: !!perl/hash:RE_ast
  decl: []
  kind: token
  min: 12345
  pkg: ~
  re: !!perl/hash:RE_sequence
    a: 0
    dba: infix__S_379DotEqual
    i: 0
    min: 12345
    r: 1
    s: 0
    zyg:
    - !!perl/hash:RE_method
      a: 0
      dba: infix__S_379DotEqual
      i: 0
      min: 12345
      name: sym
      r: 1
      rest: ''
      s: 0
      sym: .=
    - !!perl/hash:RE_method
      min: 0
      name: O
      rest: "(|%item_assignment,\n            nextterm => 'dottyopish',\n            _reducecheck
        => 'check_doteq'\n        )"
infix__S_380EqualGt: !!perl/hash:RE_ast
  decl: []
  kind: token
  min: 12345
  pkg: ~
  re: !!perl/hash:RE_sequence
    a: 0
    dba: infix__S_380EqualGt
    i: 0
    min: 12345
    r: 1
    s: 0
    zyg:
    - !!perl/hash:RE_method
      a: 0
      dba: infix__S_380EqualGt
      i: 0
      min: 12345
      name: sym
      r: 1
      rest: ''
      s: 0
      sym: =>
    - !!perl/hash:RE_method
      min: 0
      name: O
      rest: (|%item_assignment, fiddly => 0)
infix__S_383Comma: !!perl/hash:RE_ast
  decl: []
  kind: token
  min: 12345
  pkg: ~
  re: !!perl/hash:RE_sequence
    a: 0
    dba: infix__S_383Comma
    i: 0
    min: 12345
    r: 1
    s: 0
    zyg:
    - !!perl/hash:RE_method
      a: 0
      dba: infix__S_383Comma
      i: 0
      min: 12345
      name: sym
      r: 1
      rest: ''
      s: 0
      sym: ','
    - !!perl/hash:RE_method
      min: 0
      name: O
      rest: (|%comma, fiddly => 0)
infix__S_384Colon: !!perl/hash:RE_ast
  decl: []
  kind: token
  min: 1
  pkg: ~
  re: !!perl/hash:RE_sequence
    a: 0
    dba: infix__S_384Colon
    i: 0
    min: 1
    r: 1
    s: 0
    zyg:
    - !!perl/hash:RE_string
      a: 0
      dba: infix__S_384Colon
      i: 0
      min: 1
      r: 1
      s: 0
      text: ':'
    - !!perl/hash:RE_assertion
      assert: '?'
      min: 0
      re: !!perl/hash:RE_method_re
        a: 0
        dba: infix__S_384Colon
        i: 0
        min: 0
        name: before
        nobind: 1
        r: 1
        re: !!perl/hash:RE_ast
          decl: []
          min: 1
          re: &17 !!perl/hash:RE_any
            a: 0
            altname: infix__S_384Colon_01
            dba: infix__S_384Colon
            i: 0
            min: 1
            name: infix__S_384Colon_01
            r: 1
            s: 0
            zyg:
            - !!perl/hash:RE_meta
              a: 0
              alt: infix__S_384Colon_01 0
              dba: infix__S_384Colon
              i: 0
              min: 1
              r: 1
              s: 0
              text: \s
            - !!perl/hash:RE_method
              a: 0
              alt: infix__S_384Colon_01 1
              dba: infix__S_384Colon
              i: 0
              min: 12345
              name: terminator
              r: 1
              rest: ''
              s: 0
        s: 0
    - !!perl/hash:RE_block
      a: 0
      context: void
      dba: infix__S_384Colon
      i: 0
      min: 0
      r: 1
      s: 0
      text: "\n            $.panic(\"Illegal use of colon as invocant marker\") unless
        $*INVOCANT_OK-- or $*PRECLIM ge $item_assignment_prec;\n            $<sym>
        = ',';\n            $<wascolon> = True;\n        "
    - !!perl/hash:RE_method
      min: 0
      name: O
      rest: (|%comma)
infix__S_384Colon_01: *17
infix__S_385X: !!perl/hash:RE_ast
  decl: []
  kind: token
  min: 12345
  pkg: ~
  re: !!perl/hash:RE_sequence
    a: 0
    dba: infix__S_385X
    i: 0
    min: 12345
    r: 1
    s: 0
    zyg:
    - !!perl/hash:RE_method
      a: 0
      dba: infix__S_385X
      i: 0
      min: 12345
      name: sym
      r: 1
      rest: ''
      s: 0
      sym: X
    - !!perl/hash:RE_method
      min: 0
      name: O
      rest: (|%list_infix)
infix__S_386Z: !!perl/hash:RE_ast
  decl: []
  kind: token
  min: 12345
  pkg: ~
  re: !!perl/hash:RE_sequence
    a: 0
    dba: infix__S_386Z
    i: 0
    min: 12345
    r: 1
    s: 0
    zyg:
    - !!perl/hash:RE_method
      a: 0
      dba: infix__S_386Z
      i: 0
      min: 12345
      name: sym
      r: 1
      rest: ''
      s: 0
      sym: Z
    - !!perl/hash:RE_method
      min: 0
      name: O
      rest: (|%list_infix)
infix__S_387minmax: !!perl/hash:RE_ast
  decl: []
  kind: token
  min: 12345
  pkg: ~
  re: !!perl/hash:RE_sequence
    a: 0
    dba: infix__S_387minmax
    i: 0
    min: 12345
    r: 1
    s: 0
    zyg:
    - !!perl/hash:RE_method
      a: 0
      dba: infix__S_387minmax
      i: 0
      min: 12345
      name: sym
      r: 1
      rest: ''
      s: 0
      sym: minmax
    - !!perl/hash:RE_method
      min: 0
      name: O
      rest: (|%list_infix)
infix__S_388DotDotDot: !!perl/hash:RE_ast
  decl: []
  kind: token
  min: 12345
  pkg: ~
  re: !!perl/hash:RE_sequence
    a: 0
    dba: infix__S_388DotDotDot
    i: 0
    min: 12345
    r: 1
    s: 0
    zyg:
    - !!perl/hash:RE_method
      a: 0
      dba: infix__S_388DotDotDot
      i: 0
      min: 12345
      name: sym
      r: 1
      rest: ''
      s: 0
      sym: '...'
    - !!perl/hash:RE_method
      min: 0
      name: O
      rest: (|%list_infix)
infix__S_394and: !!perl/hash:RE_ast
  decl: []
  kind: token
  min: 12345
  pkg: ~
  re: !!perl/hash:RE_sequence
    a: 0
    dba: infix__S_394and
    i: 0
    min: 12345
    r: 1
    s: 0
    zyg:
    - !!perl/hash:RE_method
      a: 0
      dba: infix__S_394and
      i: 0
      min: 12345
      name: sym
      r: 1
      rest: ''
      s: 0
      sym: and
    - !!perl/hash:RE_method
      min: 0
      name: O
      rest: (|%loose_and, iffy => 1)
infix__S_395andthen: !!perl/hash:RE_ast
  decl: []
  kind: token
  min: 12345
  pkg: ~
  re: !!perl/hash:RE_sequence
    a: 0
    dba: infix__S_395andthen
    i: 0
    min: 12345
    r: 1
    s: 0
    zyg:
    - !!perl/hash:RE_method
      a: 0
      dba: infix__S_395andthen
      i: 0
      min: 12345
      name: sym
      r: 1
      rest: ''
      s: 0
      sym: andthen
    - !!perl/hash:RE_method
      min: 0
      name: O
      rest: (|%loose_and)
infix__S_396or: !!perl/hash:RE_ast
  decl: []
  kind: token
  min: 12345
  pkg: ~
  re: !!perl/hash:RE_sequence
    a: 0
    dba: infix__S_396or
    i: 0
    min: 12345
    r: 1
    s: 0
    zyg:
    - !!perl/hash:RE_method
      a: 0
      dba: infix__S_396or
      i: 0
      min: 12345
      name: sym
      r: 1
      rest: ''
      s: 0
      sym: or
    - !!perl/hash:RE_method
      min: 0
      name: O
      rest: (|%loose_or, iffy => 1)
infix__S_397orelse: !!perl/hash:RE_ast
  decl: []
  kind: token
  min: 12345
  pkg: ~
  re: !!perl/hash:RE_sequence
    a: 0
    dba: infix__S_397orelse
    i: 0
    min: 12345
    r: 1
    s: 0
    zyg:
    - !!perl/hash:RE_method
      a: 0
      dba: infix__S_397orelse
      i: 0
      min: 12345
      name: sym
      r: 1
      rest: ''
      s: 0
      sym: orelse
    - !!perl/hash:RE_method
      min: 0
      name: O
      rest: (|%loose_or)
infix__S_398xor: !!perl/hash:RE_ast
  decl: []
  kind: token
  min: 12345
  pkg: ~
  re: !!perl/hash:RE_sequence
    a: 0
    dba: infix__S_398xor
    i: 0
    min: 12345
    r: 1
    s: 0
    zyg:
    - !!perl/hash:RE_method
      a: 0
      dba: infix__S_398xor
      i: 0
      min: 12345
      name: sym
      r: 1
      rest: ''
      s: 0
      sym: xor
    - !!perl/hash:RE_method
      min: 0
      name: O
      rest: (|%loose_or, iffy => 1)
infix__S_399LtEqualEqual: !!perl/hash:RE_ast
  decl: []
  kind: token
  min: 12345
  pkg: ~
  re: !!perl/hash:RE_sequence
    a: 0
    dba: infix__S_399LtEqualEqual
    i: 0
    min: 12345
    r: 1
    s: 0
    zyg:
    - !!perl/hash:RE_method
      a: 0
      dba: infix__S_399LtEqualEqual
      i: 0
      min: 12345
      name: sym
      r: 1
      rest: ''
      s: 0
      sym: <==
    - !!perl/hash:RE_method
      min: 0
      name: O
      rest: (|%sequencer)
infix__S_400EqualEqualGt: !!perl/hash:RE_ast
  decl: []
  kind: token
  min: 12345
  pkg: ~
  re: !!perl/hash:RE_sequence
    a: 0
    dba: infix__S_400EqualEqualGt
    i: 0
    min: 12345
    r: 1
    s: 0
    zyg:
    - !!perl/hash:RE_method
      a: 0
      dba: infix__S_400EqualEqualGt
      i: 0
      min: 12345
      name: sym
      r: 1
      rest: ''
      s: 0
      sym: ==>
    - !!perl/hash:RE_method
      min: 0
      name: O
      rest: (|%sequencer)
infix__S_401LtLtEqualEqual: !!perl/hash:RE_ast
  decl: []
  kind: token
  min: 12345
  pkg: ~
  re: !!perl/hash:RE_sequence
    a: 0
    dba: infix__S_401LtLtEqualEqual
    i: 0
    min: 12345
    r: 1
    s: 0
    zyg:
    - !!perl/hash:RE_method
      a: 0
      dba: infix__S_401LtLtEqualEqual
      i: 0
      min: 12345
      name: sym
      r: 1
      rest: ''
      s: 0
      sym: <<==
    - !!perl/hash:RE_method
      min: 0
      name: O
      rest: (|%sequencer)
infix__S_402EqualEqualGtGt: !!perl/hash:RE_ast
  decl: []
  kind: token
  min: 12345
  pkg: ~
  re: !!perl/hash:RE_sequence
    a: 0
    dba: infix__S_402EqualEqualGtGt
    i: 0
    min: 12345
    r: 1
    s: 0
    zyg:
    - !!perl/hash:RE_method
      a: 0
      dba: infix__S_402EqualEqualGtGt
      i: 0
      min: 12345
      name: sym
      r: 1
      rest: ''
      s: 0
      sym: ==>>
    - !!perl/hash:RE_method
      min: 0
      name: O
      rest: (|%sequencer)
infix_circumfix_meta_operator__S_265Fre_Nch: !!perl/hash:RE_ast
  decl: []
  kind: token
  min: 1
  pkg: ~
  re: !!perl/hash:RE_sequence
    a: 0
    dba: infix_circumfix_meta_operator__S_265Fre_Nch
    i: 0
    min: 1
    r: 1
    s: 0
    zyg:
    - !!perl/hash:RE_bracket
      decl: []
      min: 1
      re: &18 !!perl/hash:RE_any
        a: 0
        altname: infix_circumfix_meta_operator__S_265Fre_Nch_01
        dba: infix_circumfix_meta_operator__S_265Fre_Nch
        i: 0
        min: 1
        name: infix_circumfix_meta_operator__S_265Fre_Nch_01
        r: 1
        s: 0
        zyg:
        - !!perl/hash:RE_string
          a: 0
          alt: infix_circumfix_meta_operator__S_265Fre_Nch_01 0
          dba: infix_circumfix_meta_operator__S_265Fre_Nch
          i: 0
          min: 1
          r: 1
          s: 0
          text: 
        - !!perl/hash:RE_string
          a: 0
          alt: infix_circumfix_meta_operator__S_265Fre_Nch_01 1
          dba: infix_circumfix_meta_operator__S_265Fre_Nch
          i: 0
          min: 1
          r: 1
          s: 0
          text: 
    - !!perl/hash:RE_block
      a: 0
      context: void
      dba: infix_circumfix_meta_operator__S_265Fre_Nch
      i: 0
      min: 0
      r: 1
      s: 0
      text: ''
    - !!perl/hash:RE_method
      min: 0
      name: infixish
      rest: (1)
    - !!perl/hash:RE_bracket
      decl: []
      min: 0
      re: !!perl/hash:RE_first
        a: 0
        dba: infix_circumfix_meta_operator__S_265Fre_Nch
        i: 0
        min: 0
        r: 1
        s: 0
        zyg:
        - &19 !!perl/hash:RE_any
          a: 0
          altname: infix_circumfix_meta_operator__S_265Fre_Nch_02
          dba: infix_circumfix_meta_operator__S_265Fre_Nch
          i: 0
          min: 1
          name: infix_circumfix_meta_operator__S_265Fre_Nch_02
          r: 1
          s: 0
          zyg:
          - !!perl/hash:RE_string
            a: 0
            alt: infix_circumfix_meta_operator__S_265Fre_Nch_02 0
            dba: infix_circumfix_meta_operator__S_265Fre_Nch
            i: 0
            min: 1
            r: 1
            s: 0
            text: 
          - !!perl/hash:RE_string
            a: 0
            alt: infix_circumfix_meta_operator__S_265Fre_Nch_02 1
            dba: infix_circumfix_meta_operator__S_265Fre_Nch
            i: 0
            min: 1
            r: 1
            s: 0
            text: 
        - !!perl/hash:RE_method
          min: 0
          name: panic
          nobind: 1
          rest: ("Missing  or ")
    - !!perl/hash:RE_method
      min: 0
      name: can_meta
      nobind: 1
      rest: ($<infixish>, "hyper with")
    - !!perl/hash:RE_assertion
      assert: '?'
      min: 0
      re: !!perl/hash:RE_block
        a: 0
        context: bool
        dba: infix_circumfix_meta_operator__S_265Fre_Nch
        i: 0
        min: 0
        nobind: 1
        r: 1
        s: 0
        text: ' $<O> := $<infixish><O>; '
infix_circumfix_meta_operator__S_265Fre_Nch_01: *18
infix_circumfix_meta_operator__S_265Fre_Nch_02: *19
infix_circumfix_meta_operator__S_266LtLt_GtGt: !!perl/hash:RE_ast
  decl: []
  kind: token
  min: 2
  pkg: ~
  re: !!perl/hash:RE_sequence
    a: 0
    dba: infix_circumfix_meta_operator__S_266LtLt_GtGt
    i: 0
    min: 2
    r: 1
    s: 0
    zyg:
    - !!perl/hash:RE_bracket
      decl: []
      min: 2
      re: &20 !!perl/hash:RE_any
        a: 0
        altname: infix_circumfix_meta_operator__S_266LtLt_GtGt_01
        dba: infix_circumfix_meta_operator__S_266LtLt_GtGt
        i: 0
        min: 2
        name: infix_circumfix_meta_operator__S_266LtLt_GtGt_01
        r: 1
        s: 0
        zyg:
        - !!perl/hash:RE_string
          a: 0
          alt: infix_circumfix_meta_operator__S_266LtLt_GtGt_01 0
          dba: infix_circumfix_meta_operator__S_266LtLt_GtGt
          i: 0
          min: 2
          r: 1
          s: 0
          text: <<
        - !!perl/hash:RE_string
          a: 0
          alt: infix_circumfix_meta_operator__S_266LtLt_GtGt_01 1
          dba: infix_circumfix_meta_operator__S_266LtLt_GtGt
          i: 0
          min: 2
          r: 1
          s: 0
          text: '>>'
    - !!perl/hash:RE_block
      a: 0
      context: void
      dba: infix_circumfix_meta_operator__S_266LtLt_GtGt
      i: 0
      min: 0
      r: 1
      s: 0
      text: ''
    - !!perl/hash:RE_method
      min: 0
      name: infixish
      rest: (1)
    - !!perl/hash:RE_bracket
      decl: []
      min: 0
      re: !!perl/hash:RE_first
        a: 0
        dba: infix_circumfix_meta_operator__S_266LtLt_GtGt
        i: 0
        min: 0
        r: 1
        s: 0
        zyg:
        - &21 !!perl/hash:RE_any
          a: 0
          altname: infix_circumfix_meta_operator__S_266LtLt_GtGt_02
          dba: infix_circumfix_meta_operator__S_266LtLt_GtGt
          i: 0
          min: 2
          name: infix_circumfix_meta_operator__S_266LtLt_GtGt_02
          r: 1
          s: 0
          zyg:
          - !!perl/hash:RE_string
            a: 0
            alt: infix_circumfix_meta_operator__S_266LtLt_GtGt_02 0
            dba: infix_circumfix_meta_operator__S_266LtLt_GtGt
            i: 0
            min: 2
            r: 1
            s: 0
            text: <<
          - !!perl/hash:RE_string
            a: 0
            alt: infix_circumfix_meta_operator__S_266LtLt_GtGt_02 1
            dba: infix_circumfix_meta_operator__S_266LtLt_GtGt
            i: 0
            min: 2
            r: 1
            s: 0
            text: '>>'
        - !!perl/hash:RE_method
          min: 0
          name: panic
          nobind: 1
          rest: ("Missing << or >>")
    - !!perl/hash:RE_method
      min: 0
      name: can_meta
      nobind: 1
      rest: ($<infixish>, "hyper with")
    - !!perl/hash:RE_assertion
      assert: '?'
      min: 0
      re: !!perl/hash:RE_block
        a: 0
        context: bool
        dba: infix_circumfix_meta_operator__S_266LtLt_GtGt
        i: 0
        min: 0
        nobind: 1
        r: 1
        s: 0
        text: ' $<O> := $<infixish><O>; '
infix_circumfix_meta_operator__S_266LtLt_GtGt_01: *20
infix_circumfix_meta_operator__S_266LtLt_GtGt_02: *21
infix_postfix_meta_operator__S_267Equal: !!perl/hash:RE_ast
  decl: []
  kind: token
  min: 1
  pkg: ~
  re: !!perl/hash:RE_sequence
    a: 0
    dba: infix_postfix_meta_operator__S_267Equal
    i: 0
    min: 1
    r: 1
    s: 0
    zyg:
    - !!perl/hash:RE_string
      a: 0
      dba: infix_postfix_meta_operator__S_267Equal
      i: 0
      min: 1
      r: 1
      s: 0
      text: =
    - !!perl/hash:RE_method
      min: 0
      name: can_meta
      nobind: 1
      rest: ($op, "make assignment out of")
    - !!perl/hash:RE_bracket
      decl: []
      min: 0
      re: !!perl/hash:RE_first
        a: 0
        dba: infix_postfix_meta_operator__S_267Equal
        i: 0
        min: 0
        r: 1
        s: 0
        zyg:
        - !!perl/hash:RE_assertion
          assert: '!'
          min: 0
          re: !!perl/hash:RE_block
            a: 0
            context: bool
            dba: infix_postfix_meta_operator__S_267Equal
            i: 0
            min: 0
            nobind: 1
            r: 1
            s: 0
            text: ' $op<O><diffy> '
        - !!perl/hash:RE_method
          min: 0
          name: panic
          nobind: 1
          rest: ("Can't make assignment out of " ~ $op<sym> ~ " because " ~ $op<O><dba>
            ~ " operators are diffy")
    - !!perl/hash:RE_block
      a: 0
      context: void
      dba: infix_postfix_meta_operator__S_267Equal
      i: 0
      min: 0
      r: 1
      s: 0
      text: ' $<sym> = $op<sym> ~ ''=''; '
    - !!perl/hash:RE_method
      min: 0
      name: O
      rest: (|%item_assignment, $op.Opairs, dba => 'item assignment', iffy => 0)
infix_prefix_meta_operator__S_260Bang: !!perl/hash:RE_ast
  decl: []
  kind: token
  min: 12345
  pkg: ~
  re: !!perl/hash:RE_sequence
    a: 0
    dba: infix_prefix_meta_operator__S_260Bang
    i: 0
    min: 12345
    r: 1
    s: 0
    zyg:
    - !!perl/hash:RE_method
      a: 0
      dba: infix_prefix_meta_operator__S_260Bang
      i: 0
      min: 12345
      name: sym
      r: 1
      rest: ''
      s: 0
      sym: '!'
    - !!perl/hash:RE_assertion
      assert: '!'
      min: 0
      re: !!perl/hash:RE_method_re
        a: 0
        dba: infix_prefix_meta_operator__S_260Bang
        i: 0
        min: 0
        name: before
        nobind: 1
        r: 1
        re: !!perl/hash:RE_ast
          decl: []
          min: 1
          re: !!perl/hash:RE_string
            a: 0
            dba: infix_prefix_meta_operator__S_260Bang
            i: 0
            min: 1
            r: 1
            s: 0
            text: '!'
        s: 0
    - !!perl/hash:RE_block
      a: 0
      context: void
      dba: infix_prefix_meta_operator__S_260Bang
      i: 0
      min: 0
      r: 1
      s: 0
      text: ''
    - !!perl/hash:RE_bracket
      decl: []
      min: 0
      re: !!perl/hash:RE_first
        a: 0
        dba: infix_prefix_meta_operator__S_260Bang
        i: 0
        min: 0
        r: 1
        s: 0
        zyg:
        - !!perl/hash:RE_method
          min: 0
          name: infixish
          rest: (1)
        - !!perl/hash:RE_method
          min: 0
          name: panic
          nobind: 1
          rest: ("Negation metaoperator not followed by valid infix")
    - !!perl/hash:RE_bracket
      decl: []
      min: 0
      re: !!perl/hash:RE_first
        a: 0
        dba: infix_prefix_meta_operator__S_260Bang
        i: 0
        min: 0
        r: 1
        s: 0
        zyg:
        - !!perl/hash:RE_sequence
          a: 0
          dba: infix_prefix_meta_operator__S_260Bang
          i: 0
          min: 0
          r: 1
          s: 0
          zyg:
          - !!perl/hash:RE_assertion
            assert: '?'
            min: 0
            re: !!perl/hash:RE_block
              a: 0
              context: bool
              dba: infix_prefix_meta_operator__S_260Bang
              i: 0
              min: 0
              nobind: 1
              r: 1
              s: 0
              text: ' $<infixish>.Str eq ''='' '
          - !!perl/hash:RE_method
            min: 0
            name: O
            rest: (|%chaining)
        - !!perl/hash:RE_sequence
          a: 0
          dba: infix_prefix_meta_operator__S_260Bang
          i: 0
          min: 0
          r: 1
          s: 0
          zyg:
          - !!perl/hash:RE_method
            min: 0
            name: can_meta
            nobind: 1
            rest: ($<infixish>, "negate")
          - !!perl/hash:RE_assertion
            assert: '?'
            min: 0
            re: !!perl/hash:RE_block
              a: 0
              context: bool
              dba: infix_prefix_meta_operator__S_260Bang
              i: 0
              min: 0
              nobind: 1
              r: 1
              s: 0
              text: ' $<infixish><O><iffy> '
          - !!perl/hash:RE_assertion
            assert: '?'
            min: 0
            re: !!perl/hash:RE_block
              a: 0
              context: bool
              dba: infix_prefix_meta_operator__S_260Bang
              i: 0
              min: 0
              nobind: 1
              r: 1
              s: 0
              text: ' $<O> = $<infixish><O>; '
        - !!perl/hash:RE_method
          min: 0
          name: panic
          nobind: 1
          rest: ("Can't negate " ~ $<infixish>.Str ~ " because " ~ $<infixish><O><dba>
            ~ " operators are not iffy enough")
infix_prefix_meta_operator__S_261R: !!perl/hash:RE_ast
  decl: []
  kind: token
  min: 12345
  pkg: ~
  re: !!perl/hash:RE_sequence
    a: 0
    dba: infix_prefix_meta_operator__S_261R
    i: 0
    min: 12345
    r: 1
    s: 0
    zyg:
    - !!perl/hash:RE_method
      a: 0
      dba: infix_prefix_meta_operator__S_261R
      i: 0
      min: 12345
      name: sym
      r: 1
      rest: ''
      s: 0
      sym: R
    - !!perl/hash:RE_block
      a: 0
      context: void
      dba: infix_prefix_meta_operator__S_261R
      i: 0
      min: 0
      r: 1
      s: 0
      text: ''
    - !!perl/hash:RE_method
      min: 0
      name: infixish
      rest: (1)
    - !!perl/hash:RE_method
      min: 0
      name: can_meta
      nobind: 1
      rest: ($<infixish>, "reverse the args of")
    - !!perl/hash:RE_assertion
      assert: '?'
      min: 0
      re: !!perl/hash:RE_block
        a: 0
        context: bool
        dba: infix_prefix_meta_operator__S_261R
        i: 0
        min: 0
        nobind: 1
        r: 1
        s: 0
        text: ' $<O> = $<infixish><O>; '
infix_prefix_meta_operator__S_262S: !!perl/hash:RE_ast
  decl: []
  kind: token
  min: 12345
  pkg: ~
  re: !!perl/hash:RE_sequence
    a: 0
    dba: infix_prefix_meta_operator__S_262S
    i: 0
    min: 12345
    r: 1
    s: 0
    zyg:
    - !!perl/hash:RE_method
      a: 0
      dba: infix_prefix_meta_operator__S_262S
      i: 0
      min: 12345
      name: sym
      r: 1
      rest: ''
      s: 0
      sym: S
    - !!perl/hash:RE_block
      a: 0
      context: void
      dba: infix_prefix_meta_operator__S_262S
      i: 0
      min: 0
      r: 1
      s: 0
      text: ''
    - !!perl/hash:RE_method
      min: 0
      name: infixish
      rest: (1)
    - !!perl/hash:RE_method
      min: 0
      name: can_meta
      nobind: 1
      rest: ($<infixish>, "sequence the args of")
    - !!perl/hash:RE_assertion
      assert: '?'
      min: 0
      re: !!perl/hash:RE_block
        a: 0
        context: bool
        dba: infix_prefix_meta_operator__S_262S
        i: 0
        min: 0
        nobind: 1
        r: 1
        s: 0
        text: ' $<O> = $<infixish><O>; '
infix_prefix_meta_operator__S_263X: !!perl/hash:RE_ast
  decl: []
  kind: token
  min: 12345
  pkg: ~
  re: !!perl/hash:RE_sequence
    a: 0
    dba: infix_prefix_meta_operator__S_263X
    i: 0
    min: 12345
    r: 1
    s: 0
    zyg:
    - !!perl/hash:RE_method
      a: 0
      dba: infix_prefix_meta_operator__S_263X
      i: 0
      min: 12345
      name: sym
      r: 1
      rest: ''
      s: 0
      sym: X
    - !!perl/hash:RE_assertion
      assert: '?'
      min: 0
      re: !!perl/hash:RE_method_re
        a: 0
        dba: infix_prefix_meta_operator__S_263X
        i: 0
        min: 0
        name: before
        nobind: 1
        r: 1
        re: !!perl/hash:RE_ast
          decl: []
          min: 1
          re: !!perl/hash:RE_meta
            a: 0
            dba: infix_prefix_meta_operator__S_263X
            i: 0
            min: 1
            r: 1
            s: 0
            text: \S
        s: 0
    - !!perl/hash:RE_block
      a: 0
      context: void
      dba: infix_prefix_meta_operator__S_263X
      i: 0
      min: 0
      r: 1
      s: 0
      text: ''
    - !!perl/hash:RE_quantified_atom
      atom: !!perl/hash:RE_bracket
        decl: []
        min: 0
        re: !!perl/hash:RE_sequence
          a: 0
          dba: infix_prefix_meta_operator__S_263X
          i: 0
          min: 0
          r: 1
          s: 0
          zyg:
          - !!perl/hash:RE_method
            min: 0
            name: infixish
            rest: (1)
          - !!perl/hash:RE_method
            min: 0
            name: can_meta
            nobind: 1
            rest: ($<infixish>[0], "cross with")
          - !!perl/hash:RE_assertion
            assert: '?'
            min: 0
            re: !!perl/hash:RE_block
              a: 0
              context: bool
              dba: infix_prefix_meta_operator__S_263X
              i: 0
              min: 0
              nobind: 1
              r: 1
              s: 0
              text: ' $<O> = $<infixish>[0]<O>; $<O><prec>:delete; $<sym> ~= $<infixish>[0].Str '
      min: 0
      quant:
      - '?'
      - ':'
      - ''
      - 0
    - !!perl/hash:RE_method
      min: 0
      name: O
      rest: (|%list_infix, self.Opairs)
infix_prefix_meta_operator__S_264Z: !!perl/hash:RE_ast
  decl: []
  kind: token
  min: 12345
  pkg: ~
  re: !!perl/hash:RE_sequence
    a: 0
    dba: infix_prefix_meta_operator__S_264Z
    i: 0
    min: 12345
    r: 1
    s: 0
    zyg:
    - !!perl/hash:RE_method
      a: 0
      dba: infix_prefix_meta_operator__S_264Z
      i: 0
      min: 12345
      name: sym
      r: 1
      rest: ''
      s: 0
      sym: Z
    - !!perl/hash:RE_assertion
      assert: '?'
      min: 0
      re: !!perl/hash:RE_method_re
        a: 0
        dba: infix_prefix_meta_operator__S_264Z
        i: 0
        min: 0
        name: before
        nobind: 1
        r: 1
        re: !!perl/hash:RE_ast
          decl: []
          min: 1
          re: !!perl/hash:RE_meta
            a: 0
            dba: infix_prefix_meta_operator__S_264Z
            i: 0
            min: 1
            r: 1
            s: 0
            text: \S
        s: 0
    - !!perl/hash:RE_block
      a: 0
      context: void
      dba: infix_prefix_meta_operator__S_264Z
      i: 0
      min: 0
      r: 1
      s: 0
      text: ''
    - !!perl/hash:RE_quantified_atom
      atom: !!perl/hash:RE_bracket
        decl: []
        min: 0
        re: !!perl/hash:RE_sequence
          a: 0
          dba: infix_prefix_meta_operator__S_264Z
          i: 0
          min: 0
          r: 1
          s: 0
          zyg:
          - !!perl/hash:RE_method
            min: 0
            name: infixish
            rest: (1)
          - !!perl/hash:RE_method
            min: 0
            name: can_meta
            nobind: 1
            rest: ($<infixish>[0], "zip with")
          - !!perl/hash:RE_assertion
            assert: '?'
            min: 0
            re: !!perl/hash:RE_block
              a: 0
              context: bool
              dba: infix_prefix_meta_operator__S_264Z
              i: 0
              min: 0
              nobind: 1
              r: 1
              s: 0
              text: ' $<O> = $<infixish>[0]<O>; $<O><prec>:delete; $<sym> ~= $<infixish>[0].Str '
      min: 0
      quant:
      - '?'
      - ':'
      - ''
      - 0
    - !!perl/hash:RE_method
      min: 0
      name: O
      rest: (|%list_infix, self.Opairs)
infixish: !!perl/hash:RE_ast
  decl:
  - !!perl/hash:RE_decl
    a: 0
    dba: infixish
    i: 0
    max: 0
    min: 0
    r: 1
    s: 0
    text: my $infix
  - !!perl/hash:RE_decl
    a: 0
    dba: infixish
    i: 0
    max: 0
    min: 0
    r: 1
    s: 0
    text: my $*IN_META = $in_meta
  kind: token
  min: 0
  pkg: ~
  re: !!perl/hash:RE_sequence
    a: 0
    dba: infix or meta-infix
    i: 0
    min: 0
    r: 1
    s: 0
    zyg:
    - !!perl/hash:RE_assertion
      assert: '!'
      min: 0
      re: !!perl/hash:RE_method
        a: 0
        dba: infixish
        i: 0
        min: 12345
        name: stdstopper
        nobind: 1
        r: 1
        rest: ''
        s: 0
    - !!perl/hash:RE_assertion
      assert: '!'
      min: 0
      re: !!perl/hash:RE_method
        a: 0
        dba: infixish
        i: 0
        min: 12345
        name: infixstopper
        nobind: 1
        r: 1
        rest: ''
        s: 0
    - !!perl/hash:RE_bracket
      decl: []
      min: 0
      re: &22 !!perl/hash:RE_any
        a: 0
        altname: infixish_01
        dba: infix or meta-infix
        i: 0
        min: 0
        name: infixish_01
        r: 1
        s: 0
        zyg:
        - !!perl/hash:RE_sequence
          a: 0
          alt: infixish_01 0
          dba: infix or meta-infix
          i: 0
          min: 12345
          r: 1
          s: 0
          zyg:
          - !!perl/hash:RE_method
            a: 0
            dba: infix or meta-infix
            i: 0
            min: 12345
            name: colonpair
            r: 1
            rest: ''
            s: 0
          - !!perl/hash:RE_block
            a: 0
            context: void
            dba: infix or meta-infix
            i: 0
            min: 0
            r: 1
            s: 0
            text: "\n                $<fake> = 1;\n                $<sym> = ':';\n
              \               %<O><prec> = %item_assignment<prec>;  # actual test
              is non-inclusive!\n                %<O><assoc> = 'unary';\n                %<O><dba>
              = 'adverb';\n            "
        - !!perl/hash:RE_sequence
          a: 0
          alt: infixish_01 1
          dba: infix or meta-infix
          i: 0
          min: 0
          r: 1
          s: 0
          zyg:
          - !!perl/hash:RE_bracket
            decl: []
            min: 0
            re: &23 !!perl/hash:RE_any
              a: 0
              altname: infixish_02
              dba: bracketed infix
              i: 0
              min: 0
              name: infixish_02
              r: 1
              s: 0
              zyg:
              - !!perl/hash:RE_sequence
                a: 0
                alt: infixish_02 0
                dba: bracketed infix
                i: 0
                min: 2
                r: 1
                s: 0
                zyg:
                - !!perl/hash:RE_string
                  a: 0
                  dba: bracketed infix
                  i: 0
                  min: 1
                  r: 1
                  s: 0
                  text: '['
                - !!perl/hash:RE_meta
                  a: 0
                  dba: bracketed infix
                  extra: 'local $::GOAL = '']'' '
                  i: 0
                  min: 0
                  r: 1
                  s: 0
                  text: ':'
                - !!perl/hash:RE_bindnamed
                  a: 0
                  atom: !!perl/hash:RE_method
                    min: 0
                    name: infixish
                    nobind: 1
                    rest: (1)
                  dba: bracketed infix
                  i: 0
                  min: 0
                  r: 1
                  s: 0
                  var: infix
                - !!perl/hash:RE_bracket
                  decl: []
                  min: 1
                  re: !!perl/hash:RE_first
                    a: 0
                    dba: bracketed infix
                    i: 0
                    min: 1
                    r: 1
                    s: 0
                    zyg:
                    - !!perl/hash:RE_string
                      a: 0
                      dba: bracketed infix
                      i: 0
                      min: 1
                      r: 1
                      s: 0
                      text: ']'
                    - !!perl/hash:RE_method
                      min: 0
                      name: FAILGOAL
                      nobind: 1
                      rest: (']' , 'bracketed infix')
                - !!perl/hash:RE_block
                  a: 0
                  context: void
                  dba: bracketed infix
                  i: 0
                  min: 0
                  r: 1
                  s: 0
                  text: ' $<O> = $<infix><O>; $<sym> = $<infix><sym>; '
              - !!perl/hash:RE_sequence
                a: 0
                alt: infixish_02 1
                dba: bracketed infix
                i: 0
                min: 12345
                r: 1
                s: 0
                zyg:
                - !!perl/hash:RE_bindnamed
                  a: 0
                  atom: !!perl/hash:RE_method
                    a: 0
                    dba: bracketed infix
                    i: 0
                    min: 12345
                    name: infix_circumfix_meta_operator
                    r: 1
                    rest: ''
                    s: 0
                  dba: bracketed infix
                  i: 0
                  min: 12345
                  r: 1
                  s: 0
                  var: infix
                - !!perl/hash:RE_block
                  a: 0
                  context: void
                  dba: bracketed infix
                  i: 0
                  min: 0
                  r: 1
                  s: 0
                  text: ' $<O> = $<infix><O>; $<sym> = $<infix><sym>; '
              - !!perl/hash:RE_sequence
                a: 0
                alt: infixish_02 2
                dba: bracketed infix
                i: 0
                min: 12345
                r: 1
                s: 0
                zyg:
                - !!perl/hash:RE_bindnamed
                  a: 0
                  atom: !!perl/hash:RE_method
                    a: 0
                    dba: bracketed infix
                    i: 0
                    min: 12345
                    name: infix_prefix_meta_operator
                    r: 1
                    rest: ''
                    s: 0
                  dba: bracketed infix
                  i: 0
                  min: 12345
                  r: 1
                  s: 0
                  var: infix
                - !!perl/hash:RE_block
                  a: 0
                  context: void
                  dba: bracketed infix
                  i: 0
                  min: 0
                  r: 1
                  s: 0
                  text: ' $<O> = $<infix><O>; $<sym> = $<infix><sym>; '
              - !!perl/hash:RE_sequence
                a: 0
                alt: infixish_02 3
                dba: bracketed infix
                i: 0
                min: 12345
                r: 1
                s: 0
                zyg:
                - !!perl/hash:RE_method
                  a: 0
                  dba: bracketed infix
                  i: 0
                  min: 12345
                  name: infix
                  r: 1
                  rest: ''
                  s: 0
                - !!perl/hash:RE_block
                  a: 0
                  context: void
                  dba: bracketed infix
                  i: 0
                  min: 0
                  r: 1
                  s: 0
                  text: ' $<O> = $<infix><O>; $<sym> = $<infix><sym>; '
              - !!perl/hash:RE_sequence
                a: 0
                alt: infixish_02 4
                dba: bracketed infix
                i: 0
                min: 0
                r: 1
                s: 0
                zyg:
                - !!perl/hash:RE_block
                  a: 0
                  context: void
                  dba: bracketed infix
                  i: 0
                  min: 0
                  r: 1
                  s: 0
                  text: ''
                - !!perl/hash:RE_assertion
                  assert: '?'
                  min: 0
                  re: !!perl/hash:RE_method
                    a: 0
                    dba: bracketed infix
                    i: 0
                    min: 12345
                    name: dotty
                    nobind: 1
                    r: 1
                    rest: ''
                    s: 0
                - !!perl/hash:RE_method
                  min: 0
                  name: panic
                  nobind: 1
                  rest: ("Method call found where infix expected (omit whitespace?)")
              - !!perl/hash:RE_sequence
                a: 0
                alt: infixish_02 5
                dba: bracketed infix
                i: 0
                min: 0
                r: 1
                s: 0
                zyg:
                - !!perl/hash:RE_block
                  a: 0
                  context: void
                  dba: bracketed infix
                  i: 0
                  min: 0
                  r: 1
                  s: 0
                  text: ''
                - !!perl/hash:RE_assertion
                  assert: '?'
                  min: 0
                  re: !!perl/hash:RE_method
                    a: 0
                    dba: bracketed infix
                    i: 0
                    min: 12345
                    name: postfix
                    nobind: 1
                    r: 1
                    rest: ''
                    s: 0
                - !!perl/hash:RE_method
                  min: 0
                  name: panic
                  nobind: 1
                  rest: ("Postfix found where infix expected (omit whitespace?)")
          - !!perl/hash:RE_quantified_atom
            atom: !!perl/hash:RE_bracket
              decl: []
              min: 0
              re: !!perl/hash:RE_sequence
                a: 0
                dba: infix or meta-infix
                i: 0
                min: 0
                r: 1
                s: 0
                zyg:
                - !!perl/hash:RE_assertion
                  assert: '?'
                  min: 0
                  re: !!perl/hash:RE_method_re
                    a: 0
                    dba: infix or meta-infix
                    i: 0
                    min: 0
                    name: before
                    nobind: 1
                    r: 1
                    re: !!perl/hash:RE_ast
                      decl: []
                      min: 1
                      re: !!perl/hash:RE_string
                        a: 0
                        dba: infix or meta-infix
                        i: 0
                        min: 1
                        r: 1
                        s: 0
                        text: =
                    s: 0
                - !!perl/hash:RE_assertion
                  assert: '?'
                  min: 0
                  re: !!perl/hash:RE_block
                    a: 0
                    context: bool
                    dba: infix or meta-infix
                    i: 0
                    min: 0
                    nobind: 1
                    r: 1
                    s: 0
                    text: ' $infix = $<infix>; '
                - !!perl/hash:RE_method
                  min: 0
                  name: infix_postfix_meta_operator
                  rest: ($infix)
                - !!perl/hash:RE_block
                  a: 0
                  context: void
                  dba: infix or meta-infix
                  i: 0
                  min: 0
                  r: 1
                  s: 0
                  text: ' $<O> = $<infix_postfix_meta_operator>[0]<O>; $<sym> = $<infix_postfix_meta_operator>[0]<sym>; '
            min: 0
            quant:
            - '?'
            - ':'
            - ''
            - 0
infixish_01: *22
infixish_02: *23
infixstopper: !!perl/hash:RE_ast
  decl: []
  kind: regex
  min: 0
  pkg: ~
  re: !!perl/hash:RE_bracket
    decl: []
    min: 0
    re: &24 !!perl/hash:RE_any
      a: 0
      altname: infixstopper_01
      dba: infix stopper
      i: 0
      min: 0
      name: infixstopper_01
      r: 0
      s: 0
      zyg:
      - !!perl/hash:RE_assertion
        alt: infixstopper_01 0
        assert: '?'
        min: 0
        re: !!perl/hash:RE_method_re
          a: 0
          dba: infix stopper
          i: 0
          min: 0
          name: before
          nobind: 1
          r: 0
          re: !!perl/hash:RE_ast
            decl: []
            min: 12345
            re: !!perl/hash:RE_method
              a: 0
              dba: infix stopper
              i: 0
              min: 12345
              name: stopper
              r: 0
              rest: ''
              s: 0
          s: 0
      - !!perl/hash:RE_sequence
        a: 0
        alt: infixstopper_01 1
        dba: infix stopper
        i: 0
        min: 0
        r: 0
        s: 0
        zyg:
        - !!perl/hash:RE_assertion
          assert: '?'
          min: 0
          re: !!perl/hash:RE_method_re
            a: 0
            dba: infix stopper
            i: 0
            min: 0
            name: before
            nobind: 1
            r: 0
            re: !!perl/hash:RE_ast
              decl: []
              min: 2
              re: !!perl/hash:RE_string
                a: 0
                dba: infix stopper
                i: 0
                min: 2
                r: 0
                s: 0
                text: '!!'
            s: 0
        - !!perl/hash:RE_assertion
          assert: '?'
          min: 0
          re: !!perl/hash:RE_block
            a: 0
            context: bool
            dba: infix stopper
            i: 0
            min: 0
            nobind: 1
            r: 0
            s: 0
            text: ' $*GOAL eq ''!!'' '
      - !!perl/hash:RE_sequence
        a: 0
        alt: infixstopper_01 2
        dba: infix stopper
        i: 0
        min: 0
        r: 0
        s: 0
        zyg:
        - !!perl/hash:RE_assertion
          assert: '?'
          min: 0
          re: !!perl/hash:RE_method_re
            a: 0
            dba: infix stopper
            i: 0
            min: 0
            name: before
            nobind: 1
            r: 0
            re: !!perl/hash:RE_ast
              decl: []
              min: 1
              re: &25 !!perl/hash:RE_any
                a: 0
                altname: infixstopper_04
                dba: infix stopper
                i: 0
                min: 1
                name: infixstopper_04
                r: 0
                s: 0
                zyg:
                - !!perl/hash:RE_string
                  a: 0
                  alt: infixstopper_04 0
                  dba: infix stopper
                  i: 0
                  min: 1
                  r: 0
                  s: 0
                  text: '{'
                - !!perl/hash:RE_method
                  a: 0
                  alt: infixstopper_04 1
                  dba: infix stopper
                  i: 0
                  min: 12345
                  name: lambda
                  r: 0
                  rest: ''
                  s: 0
            s: 0
        - !!perl/hash:RE_assertion
          assert: '?'
          min: 0
          re: !!perl/hash:RE_block
            a: 0
            context: bool
            dba: infix stopper
            i: 0
            min: 0
            nobind: 1
            r: 0
            s: 0
            text: ' ($*GOAL eq ''{'' or $*GOAL eq ''endargs'') and @*MEMOS[$.pos]<ws> '
      - !!perl/hash:RE_assertion
        alt: infixstopper_01 3
        assert: '?'
        min: 0
        re: !!perl/hash:RE_block
          a: 0
          context: bool
          dba: infix stopper
          i: 0
          min: 0
          nobind: 1
          r: 0
          s: 0
          text: ' $*GOAL eq ''endargs'' and @*MEMOS[$.pos]<endargs> '
infixstopper_01: *24
infixstopper_04: *25
label: !!perl/hash:RE_ast
  decl:
  - !!perl/hash:RE_decl
    a: 0
    dba: label
    i: 0
    max: 0
    min: 0
    r: 1
    s: 0
    text: my $label
  kind: token
  min: 24691
  pkg: ~
  re: !!perl/hash:RE_sequence
    a: 0
    dba: label
    i: 0
    min: 24691
    r: 1
    s: 0
    zyg:
    - !!perl/hash:RE_method
      a: 0
      dba: label
      i: 0
      min: 12345
      name: identifier
      r: 1
      rest: ''
      s: 0
    - !!perl/hash:RE_string
      a: 0
      dba: label
      i: 0
      min: 1
      r: 1
      s: 0
      text: ':'
    - !!perl/hash:RE_assertion
      assert: '?'
      min: 0
      re: !!perl/hash:RE_method_re
        a: 0
        dba: label
        i: 0
        min: 0
        name: before
        nobind: 1
        r: 1
        re: !!perl/hash:RE_ast
          decl: []
          min: 1
          re: !!perl/hash:RE_meta
            a: 0
            dba: label
            i: 0
            min: 1
            r: 1
            s: 0
            text: \s
        s: 0
    - !!perl/hash:RE_method
      a: 0
      dba: label
      i: 0
      min: 12345
      name: ws
      nobind: 1
      r: 1
      rest: ''
      s: 0
    - !!perl/hash:RE_quantified_atom
      atom: !!perl/hash:RE_bracket
        decl: []
        min: 0
        re: !!perl/hash:RE_sequence
          a: 0
          dba: label
          i: 0
          min: 0
          r: 1
          s: 0
          zyg:
          - !!perl/hash:RE_assertion
            assert: '?'
            min: 0
            re: !!perl/hash:RE_block
              a: 0
              context: bool
              dba: label
              i: 0
              min: 0
              nobind: 1
              r: 1
              s: 0
              text: ' $.is_name($label = $<identifier>.Str) '
          - !!perl/hash:RE_method
            min: 0
            name: panic
            nobind: 1
            rest: ("Illegal redeclaration of '$label'")
      min: 0
      quant:
      - '?'
      - ':'
      - ''
      - 0
    - !!perl/hash:RE_block
      a: 0
      context: void
      dba: label
      i: 0
      min: 0
      r: 1
      s: 0
      text: ' my $*IN_DECL = ''label''; $.add_my_name($label); '
lambda: !!perl/hash:RE_ast
  decl: []
  kind: token
  min: 2
  pkg: ~
  re: &26 !!perl/hash:RE_any
    a: 0
    altname: lambda_00
    dba: lambda
    i: 0
    min: 2
    name: lambda_00
    r: 1
    s: 0
    zyg:
    - !!perl/hash:RE_string
      a: 0
      alt: lambda_00 0
      dba: lambda
      i: 0
      min: 2
      r: 1
      s: 0
      text: ->
    - !!perl/hash:RE_string
      a: 0
      alt: lambda_00 1
      dba: lambda
      i: 0
      min: 3
      r: 1
      s: 0
      text: <->
lambda_00: *26
macro_def: !!perl/hash:RE_ast
  decl:
  - !!perl/hash:RE_decl
    a: 0
    dba: macro_def
    i: 0
    max: 0
    min: 0
    r: 1
    s: 1
    text: temp $*CURPAD
  - !!perl/hash:RE_decl
    a: 0
    dba: macro_def
    i: 0
    max: 0
    min: 0
    r: 1
    s: 1
    text: my $*IN_DECL = 'macro'
  - !!perl/hash:RE_decl
    a: 0
    dba: macro_def
    i: 0
    max: 0
    min: 0
    r: 1
    s: 1
    text: my $*DECLARAND
  kind: rule
  min: 0
  pkg: ~
  re: !!perl/hash:RE_first
    a: 0
    dba: macro_def
    i: 0
    min: 0
    r: 1
    s: 1
    zyg:
    - !!perl/hash:RE_sequence
      a: 0
      dba: macro_def
      i: 0
      min: 49380
      r: 1
      s: 1
      zyg:
      - !!perl/hash:RE_method
        min: 0
        name: ws
        nobind: 1
        noquant: 1
        rest: ''
      - !!perl/hash:RE_bracket
        decl: []
        min: 49380
        re: !!perl/hash:RE_sequence
          a: 0
          dba: macro_def
          i: 0
          min: 49380
          r: 1
          s: 0
          zyg:
          - !!perl/hash:RE_quantified_atom
            atom: !!perl/hash:RE_bracket
              decl: []
              min: 1
              re: &27 !!perl/hash:RE_any
                a: 0
                altname: macro_def_02
                dba: macro_def
                i: 0
                min: 1
                name: macro_def_02
                r: 1
                s: 1
                zyg:
                - !!perl/hash:RE_sequence
                  a: 0
                  alt: macro_def_02 0
                  dba: macro_def
                  i: 0
                  min: 1
                  r: 1
                  s: 1
                  zyg:
                  - !!perl/hash:RE_method
                    min: 0
                    name: ws
                    nobind: 1
                    noquant: 1
                    rest: ''
                  - !!perl/hash:RE_string
                    a: 0
                    dba: macro_def
                    i: 0
                    min: 1
                    r: 1
                    s: 1
                    text: '&'
                  - !!perl/hash:RE_quantified_atom
                    atom: !!perl/hash:RE_method
                      a: 0
                      dba: macro_def
                      i: 0
                      min: 12345
                      name: deflongname
                      r: 1
                      rest: ''
                      s: 1
                    min: 0
                    quant:
                    - '?'
                    - ':'
                    - ''
                    - 0
                  - !!perl/hash:RE_method
                    min: 0
                    name: ws
                    nobind: 1
                    noquant: 1
                    rest: ''
                - !!perl/hash:RE_sequence
                  a: 0
                  alt: macro_def_02 1
                  dba: macro_def
                  i: 0
                  min: 12345
                  r: 1
                  s: 1
                  zyg:
                  - !!perl/hash:RE_method
                    min: 0
                    name: ws
                    nobind: 1
                    noquant: 1
                    rest: ''
                  - !!perl/hash:RE_method
                    a: 0
                    dba: macro_def
                    i: 0
                    min: 12345
                    name: deflongname
                    r: 1
                    rest: ''
                    s: 1
                  - !!perl/hash:RE_method
                    min: 0
                    name: ws
                    nobind: 1
                    noquant: 1
                    rest: ''
            min: 0
            quant:
            - '?'
            - ':'
            - ''
            - 0
          - !!perl/hash:RE_method
            min: 0
            name: ws
            nobind: 1
            noquant: 1
            rest: ''
          - !!perl/hash:RE_method
            min: 0
            name: newpad
            nobind: 1
            rest: (1)
          - !!perl/hash:RE_method
            min: 0
            name: ws
            nobind: 1
            noquant: 1
            rest: ''
          - !!perl/hash:RE_quantified_atom
            atom: !!perl/hash:RE_bracket
              decl: []
              min: 12345
              re: &28 !!perl/hash:RE_any
                a: 0
                altname: macro_def_03
                dba: macro_def
                i: 0
                min: 12345
                name: macro_def_03
                r: 1
                s: 1
                zyg:
                - !!perl/hash:RE_sequence
                  a: 0
                  alt: macro_def_03 0
                  dba: macro_def
                  i: 0
                  min: 12345
                  r: 1
                  s: 1
                  zyg:
                  - !!perl/hash:RE_method
                    min: 0
                    name: ws
                    nobind: 1
                    noquant: 1
                    rest: ''
                  - !!perl/hash:RE_method
                    a: 0
                    dba: macro_def
                    i: 0
                    min: 12345
                    name: multisig
                    r: 1
                    rest: ''
                    s: 1
                  - !!perl/hash:RE_method
                    min: 0
                    name: ws
                    nobind: 1
                    noquant: 1
                    rest: ''
                - !!perl/hash:RE_sequence
                  a: 0
                  alt: macro_def_03 1
                  dba: macro_def
                  i: 0
                  min: 12345
                  r: 1
                  s: 1
                  zyg:
                  - !!perl/hash:RE_method
                    min: 0
                    name: ws
                    nobind: 1
                    noquant: 1
                    rest: ''
                  - !!perl/hash:RE_method
                    a: 0
                    dba: macro_def
                    i: 0
                    min: 12345
                    name: trait
                    r: 1
                    rest: ''
                    s: 1
                  - !!perl/hash:RE_method
                    min: 0
                    name: ws
                    nobind: 1
                    noquant: 1
                    rest: ''
            min: 0
            quant:
            - '*'
            - ':'
            - ''
            - 0
          - !!perl/hash:RE_method
            min: 0
            name: ws
            nobind: 1
            noquant: 1
            rest: ''
          - !!perl/hash:RE_assertion
            assert: '!'
            min: 0
            re: !!perl/hash:RE_block
              a: 0
              context: bool
              dba: macro_def
              i: 0
              min: 0
              nobind: 1
              r: 1
              s: 1
              text: "\n                $*IN_DECL = '';\n            "
          - !!perl/hash:RE_method
            min: 0
            name: ws
            nobind: 1
            noquant: 1
            rest: ''
          - !!perl/hash:RE_block
            a: 0
            context: void
            dba: macro_def
            i: 0
            min: 0
            r: 1
            s: 1
            text: ' $*IN_DECL = ''''; '
          - !!perl/hash:RE_method
            min: 0
            name: ws
            nobind: 1
            noquant: 1
            rest: ''
          - !!perl/hash:RE_method
            a: 0
            dba: macro_def
            i: 0
            min: 12345
            name: blockoid
            r: 1
            rest: ''
            s: 1
          - !!perl/hash:RE_method
            a: 0
            dba: macro_def
            i: 0
            min: 12345
            name: checkyada
            nobind: 1
            r: 1
            rest: ''
            s: 0
          - !!perl/hash:RE_method
            a: 0
            dba: macro_def
            i: 0
            min: 12345
            name: getsig
            nobind: 1
            r: 1
            rest: ''
            s: 0
          - !!perl/hash:RE_method
            a: 0
            dba: macro_def
            i: 0
            min: 12345
            name: getdecl
            nobind: 1
            r: 1
            rest: ''
            s: 0
      - !!perl/hash:RE_method
        min: 0
        name: ws
        nobind: 1
        noquant: 1
        rest: ''
    - !!perl/hash:RE_sequence
      a: 0
      dba: macro_def
      i: 0
      min: 0
      r: 1
      s: 1
      zyg:
      - !!perl/hash:RE_method
        min: 0
        name: ws
        nobind: 1
        noquant: 1
        rest: ''
      - !!perl/hash:RE_method
        min: 0
        name: panic
        nobind: 1
        rest: ("Malformed macro")
      - !!perl/hash:RE_method
        min: 0
        name: ws
        nobind: 1
        noquant: 1
        rest: ''
macro_def_02: *27
macro_def_03: *28
method_def: !!perl/hash:RE_ast
  decl:
  - !!perl/hash:RE_decl
    a: 0
    dba: method_def
    i: 0
    max: 0
    min: 0
    r: 1
    s: 1
    text: temp $*CURPAD
  - !!perl/hash:RE_decl
    a: 0
    dba: method_def
    i: 0
    max: 0
    min: 0
    r: 1
    s: 1
    text: my $*IN_DECL = 'method'
  - !!perl/hash:RE_decl
    a: 0
    dba: method_def
    i: 0
    max: 0
    min: 0
    r: 1
    s: 1
    text: my $*DECLARAND
  kind: rule
  min: 0
  pkg: ~
  re: !!perl/hash:RE_first
    a: 0
    dba: method_def
    i: 0
    min: 0
    r: 1
    s: 1
    zyg:
    - !!perl/hash:RE_sequence
      a: 0
      dba: method_def
      i: 0
      min: 49380
      r: 1
      s: 1
      zyg:
      - !!perl/hash:RE_method
        min: 0
        name: ws
        nobind: 1
        noquant: 1
        rest: ''
      - !!perl/hash:RE_method
        min: 0
        name: newpad
        nobind: 1
        rest: (1)
      - !!perl/hash:RE_method
        min: 0
        name: ws
        nobind: 1
        noquant: 1
        rest: ''
      - !!perl/hash:RE_bracket
        decl: []
        min: 49380
        re: !!perl/hash:RE_sequence
          a: 0
          dba: method_def
          i: 0
          min: 49380
          r: 1
          s: 0
          zyg:
          - !!perl/hash:RE_bracket
            decl: []
            min: 0
            re: &29 !!perl/hash:RE_any
              a: 0
              altname: method_def_02
              dba: subscript signature
              i: 0
              min: 0
              name: method_def_02
              r: 1
              s: 1
              zyg:
              - !!perl/hash:RE_sequence
                a: 0
                alt: method_def_02 0
                dba: method_def
                i: 0
                min: 12345
                r: 1
                s: 1
                zyg:
                - !!perl/hash:RE_quantified_atom
                  atom: !!perl/hash:RE_cclass
                    a: 0
                    dba: method_def
                    i: 0
                    min: 1
                    r: 1
                    s: 1
                    text: '[ ! ^ ]'
                  min: 0
                  quant:
                  - '?'
                  - ':'
                  - ''
                  - 0
                - !!perl/hash:RE_method
                  a: 0
                  dba: method_def
                  i: 0
                  min: 12345
                  name: longname
                  r: 1
                  rest: ''
                  s: 1
                - !!perl/hash:RE_method
                  min: 0
                  name: ws
                  nobind: 1
                  noquant: 1
                  rest: ''
                - !!perl/hash:RE_quantified_atom
                  atom: !!perl/hash:RE_bracket
                    decl: []
                    min: 12345
                    re: &30 !!perl/hash:RE_any
                      a: 0
                      altname: method_def_03
                      dba: method_def
                      i: 0
                      min: 12345
                      name: method_def_03
                      r: 1
                      s: 1
                      zyg:
                      - !!perl/hash:RE_sequence
                        a: 0
                        alt: method_def_03 0
                        dba: method_def
                        i: 0
                        min: 12345
                        r: 1
                        s: 1
                        zyg:
                        - !!perl/hash:RE_method
                          min: 0
                          name: ws
                          nobind: 1
                          noquant: 1
                          rest: ''
                        - !!perl/hash:RE_method
                          a: 0
                          dba: method_def
                          i: 0
                          min: 12345
                          name: multisig
                          r: 1
                          rest: ''
                          s: 1
                        - !!perl/hash:RE_method
                          min: 0
                          name: ws
                          nobind: 1
                          noquant: 1
                          rest: ''
                      - !!perl/hash:RE_sequence
                        a: 0
                        alt: method_def_03 1
                        dba: method_def
                        i: 0
                        min: 12345
                        r: 1
                        s: 1
                        zyg:
                        - !!perl/hash:RE_method
                          min: 0
                          name: ws
                          nobind: 1
                          noquant: 1
                          rest: ''
                        - !!perl/hash:RE_method
                          a: 0
                          dba: method_def
                          i: 0
                          min: 12345
                          name: trait
                          r: 1
                          rest: ''
                          s: 1
                        - !!perl/hash:RE_method
                          min: 0
                          name: ws
                          nobind: 1
                          noquant: 1
                          rest: ''
                  min: 0
                  quant:
                  - '*'
                  - ':'
                  - ''
                  - 0
                - !!perl/hash:RE_method
                  min: 0
                  name: ws
                  nobind: 1
                  noquant: 1
                  rest: ''
              - !!perl/hash:RE_sequence
                a: 0
                alt: method_def_02 1
                dba: method_def
                i: 0
                min: 12345
                r: 1
                s: 1
                zyg:
                - !!perl/hash:RE_method
                  a: 0
                  dba: method_def
                  i: 0
                  min: 12345
                  name: multisig
                  r: 1
                  rest: ''
                  s: 1
                - !!perl/hash:RE_method
                  min: 0
                  name: ws
                  nobind: 1
                  noquant: 1
                  rest: ''
                - !!perl/hash:RE_quantified_atom
                  atom: !!perl/hash:RE_method
                    a: 0
                    dba: method_def
                    i: 0
                    min: 12345
                    name: trait
                    r: 1
                    rest: ''
                    s: 1
                  min: 0
                  quant:
                  - '*'
                  - ':'
                  - ''
                  - 0
                - !!perl/hash:RE_method
                  min: 0
                  name: ws
                  nobind: 1
                  noquant: 1
                  rest: ''
              - !!perl/hash:RE_sequence
                a: 0
                alt: method_def_02 2
                dba: subscript signature
                i: 0
                min: 24691
                r: 1
                s: 1
                zyg:
                - !!perl/hash:RE_method
                  a: 0
                  dba: method_def
                  i: 0
                  min: 12345
                  name: sigil
                  r: 1
                  rest: ''
                  s: 1
                - !!perl/hash:RE_method
                  min: 0
                  name: ws
                  nobind: 1
                  noquant: 1
                  rest: ''
                - !!perl/hash:RE_string
                  a: 0
                  dba: method_def
                  i: 0
                  min: 1
                  r: 1
                  s: 1
                  text: .
                - !!perl/hash:RE_method
                  min: 0
                  name: ws
                  nobind: 1
                  noquant: 1
                  rest: ''
                - !!perl/hash:RE_method
                  min: 0
                  name: ws
                  nobind: 1
                  noquant: 1
                  rest: ''
                - !!perl/hash:RE_bracket
                  decl: []
                  min: 12345
                  re: &31 !!perl/hash:RE_any
                    a: 0
                    altname: method_def_04
                    dba: subscript signature
                    i: 0
                    min: 12345
                    name: method_def_04
                    r: 1
                    s: 1
                    zyg:
                    - !!perl/hash:RE_sequence
                      a: 0
                      alt: method_def_04 0
                      dba: subscript signature
                      i: 0
                      min: 12347
                      r: 1
                      s: 1
                      zyg:
                      - !!perl/hash:RE_string
                        a: 0
                        dba: subscript signature
                        i: 0
                        min: 1
                        r: 1
                        s: 1
                        text: (
                      - !!perl/hash:RE_method
                        min: 0
                        name: ws
                        nobind: 1
                        noquant: 1
                        rest: ''
                      - !!perl/hash:RE_meta
                        a: 0
                        dba: subscript signature
                        extra: local $::GOAL = ')'
                        i: 0
                        min: 0
                        r: 1
                        s: 1
                        text: ':'
                      - !!perl/hash:RE_method
                        a: 0
                        dba: subscript signature
                        i: 0
                        min: 12345
                        name: signature
                        r: 1
                        rest: ''
                        s: 1
                      - !!perl/hash:RE_bracket
                        decl: []
                        min: 1
                        re: !!perl/hash:RE_first
                          a: 0
                          dba: subscript signature
                          i: 0
                          min: 1
                          r: 1
                          s: 1
                          zyg:
                          - !!perl/hash:RE_string
                            a: 0
                            dba: subscript signature
                            i: 0
                            min: 1
                            r: 1
                            s: 1
                            text: )
                          - !!perl/hash:RE_method
                            min: 0
                            name: FAILGOAL
                            nobind: 1
                            rest: (')', 'subscript signature')
                      - !!perl/hash:RE_method
                        min: 0
                        name: ws
                        nobind: 1
                        noquant: 1
                        rest: ''
                    - !!perl/hash:RE_sequence
                      a: 0
                      alt: method_def_04 1
                      dba: subscript signature
                      i: 0
                      min: 12347
                      r: 1
                      s: 1
                      zyg:
                      - !!perl/hash:RE_string
                        a: 0
                        dba: subscript signature
                        i: 0
                        min: 1
                        r: 1
                        s: 1
                        text: '['
                      - !!perl/hash:RE_method
                        min: 0
                        name: ws
                        nobind: 1
                        noquant: 1
                        rest: ''
                      - !!perl/hash:RE_meta
                        a: 0
                        dba: subscript signature
                        extra: local $::GOAL = ']'
                        i: 0
                        min: 0
                        r: 1
                        s: 1
                        text: ':'
                      - !!perl/hash:RE_method
                        a: 0
                        dba: subscript signature
                        i: 0
                        min: 12345
                        name: signature
                        r: 1
                        rest: ''
                        s: 1
                      - !!perl/hash:RE_bracket
                        decl: []
                        min: 1
                        re: !!perl/hash:RE_first
                          a: 0
                          dba: subscript signature
                          i: 0
                          min: 1
                          r: 1
                          s: 1
                          zyg:
                          - !!perl/hash:RE_string
                            a: 0
                            dba: subscript signature
                            i: 0
                            min: 1
                            r: 1
                            s: 1
                            text: ']'
                          - !!perl/hash:RE_method
                            min: 0
                            name: FAILGOAL
                            nobind: 1
                            rest: (']', 'subscript signature')
                      - !!perl/hash:RE_method
                        min: 0
                        name: ws
                        nobind: 1
                        noquant: 1
                        rest: ''
                    - !!perl/hash:RE_sequence
                      a: 0
                      alt: method_def_04 2
                      dba: subscript signature
                      i: 0
                      min: 12347
                      r: 1
                      s: 1
                      zyg:
                      - !!perl/hash:RE_string
                        a: 0
                        dba: subscript signature
                        i: 0
                        min: 1
                        r: 1
                        s: 1
                        text: '{'
                      - !!perl/hash:RE_method
                        min: 0
                        name: ws
                        nobind: 1
                        noquant: 1
                        rest: ''
                      - !!perl/hash:RE_meta
                        a: 0
                        dba: subscript signature
                        extra: local $::GOAL = '}'
                        i: 0
                        min: 0
                        r: 1
                        s: 1
                        text: ':'
                      - !!perl/hash:RE_method
                        a: 0
                        dba: subscript signature
                        i: 0
                        min: 12345
                        name: signature
                        r: 1
                        rest: ''
                        s: 1
                      - !!perl/hash:RE_bracket
                        decl: []
                        min: 1
                        re: !!perl/hash:RE_first
                          a: 0
                          dba: subscript signature
                          i: 0
                          min: 1
                          r: 1
                          s: 1
                          zyg:
                          - !!perl/hash:RE_string
                            a: 0
                            dba: subscript signature
                            i: 0
                            min: 1
                            r: 1
                            s: 1
                            text: '}'
                          - !!perl/hash:RE_method
                            min: 0
                            name: FAILGOAL
                            nobind: 1
                            rest: ('}', 'subscript signature')
                      - !!perl/hash:RE_method
                        min: 0
                        name: ws
                        nobind: 1
                        noquant: 1
                        rest: ''
                    - !!perl/hash:RE_sequence
                      a: 0
                      alt: method_def_04 3
                      dba: subscript signature
                      i: 0
                      min: 12345
                      r: 1
                      s: 1
                      zyg:
                      - !!perl/hash:RE_assertion
                        assert: '?'
                        min: 0
                        re: !!perl/hash:RE_method_re
                          a: 0
                          dba: subscript signature
                          i: 0
                          min: 0
                          name: before
                          nobind: 1
                          r: 1
                          re: !!perl/hash:RE_ast
                            decl: []
                            min: 1
                            re: !!perl/hash:RE_string
                              a: 0
                              dba: subscript signature
                              i: 0
                              min: 1
                              r: 1
                              s: 1
                              text: <
                          s: 1
                      - !!perl/hash:RE_method
                        min: 0
                        name: ws
                        nobind: 1
                        noquant: 1
                        rest: ''
                      - !!perl/hash:RE_method
                        a: 0
                        dba: subscript signature
                        i: 0
                        min: 12345
                        name: postcircumfix
                        r: 1
                        rest: ''
                        s: 1
                      - !!perl/hash:RE_method
                        min: 0
                        name: ws
                        nobind: 1
                        noquant: 1
                        rest: ''
                - !!perl/hash:RE_method
                  min: 0
                  name: ws
                  nobind: 1
                  noquant: 1
                  rest: ''
                - !!perl/hash:RE_quantified_atom
                  atom: !!perl/hash:RE_method
                    a: 0
                    dba: subscript signature
                    i: 0
                    min: 12345
                    name: trait
                    r: 1
                    rest: ''
                    s: 1
                  min: 0
                  quant:
                  - '*'
                  - ':'
                  - ''
                  - 0
                - !!perl/hash:RE_method
                  min: 0
                  name: ws
                  nobind: 1
                  noquant: 1
                  rest: ''
              - !!perl/hash:RE_sequence
                a: 0
                alt: method_def_02 3
                dba: subscript signature
                i: 0
                min: 0
                r: 1
                s: 1
                zyg:
                - !!perl/hash:RE_assertion
                  assert: '?'
                  min: 0
                  re: !!perl/hash:RE_noop
                    a: 0
                    dba: subscript signature
                    i: 0
                    min: 0
                    nobind: 1
                    r: 1
                    s: 1
                - !!perl/hash:RE_method
                  min: 0
                  name: ws
                  nobind: 1
                  noquant: 1
                  rest: ''
          - !!perl/hash:RE_method
            min: 0
            name: ws
            nobind: 1
            noquant: 1
            rest: ''
          - !!perl/hash:RE_block
            a: 0
            context: void
            dba: method_def
            i: 0
            min: 0
            r: 1
            s: 1
            text: ' $*IN_DECL = ''''; '
          - !!perl/hash:RE_method
            min: 0
            name: ws
            nobind: 1
            noquant: 1
            rest: ''
          - !!perl/hash:RE_method
            a: 0
            dba: method_def
            i: 0
            min: 12345
            name: blockoid
            r: 1
            rest: ''
            s: 1
          - !!perl/hash:RE_method
            a: 0
            dba: method_def
            i: 0
            min: 12345
            name: checkyada
            nobind: 1
            r: 1
            rest: ''
            s: 0
          - !!perl/hash:RE_method
            a: 0
            dba: method_def
            i: 0
            min: 12345
            name: getsig
            nobind: 1
            r: 1
            rest: ''
            s: 0
          - !!perl/hash:RE_method
            a: 0
            dba: method_def
            i: 0
            min: 12345
            name: getdecl
            nobind: 1
            r: 1
            rest: ''
            s: 0
      - !!perl/hash:RE_method
        min: 0
        name: ws
        nobind: 1
        noquant: 1
        rest: ''
    - !!perl/hash:RE_sequence
      a: 0
      dba: method_def
      i: 0
      min: 0
      r: 1
      s: 1
      zyg:
      - !!perl/hash:RE_method
        min: 0
        name: ws
        nobind: 1
        noquant: 1
        rest: ''
      - !!perl/hash:RE_method
        min: 0
        name: panic
        nobind: 1
        rest: ("Malformed method")
      - !!perl/hash:RE_method
        min: 0
        name: ws
        nobind: 1
        noquant: 1
        rest: ''
method_def_02: *29
method_def_03: *30
method_def_04: *31
methodop: !!perl/hash:RE_ast
  decl: []
  kind: token
  min: 12345
  pkg: ~
  re: !!perl/hash:RE_sequence
    a: 0
    dba: method arguments
    i: 0
    min: 12345
    r: 1
    s: 0
    zyg:
    - !!perl/hash:RE_bracket
      decl: []
      min: 12345
      re: &32 !!perl/hash:RE_any
        a: 0
        altname: methodop_01
        dba: methodop
        i: 0
        min: 12345
        name: methodop_01
        r: 1
        s: 0
        zyg:
        - !!perl/hash:RE_method
          a: 0
          alt: methodop_01 0
          dba: methodop
          i: 0
          min: 12345
          name: longname
          r: 1
          rest: ''
          s: 0
        - !!perl/hash:RE_sequence
          a: 0
          alt: methodop_01 1
          dba: methodop
          i: 0
          min: 12345
          r: 1
          s: 0
          zyg:
          - !!perl/hash:RE_assertion
            assert: '?'
            min: 0
            re: !!perl/hash:RE_method_re
              a: 0
              dba: methodop
              i: 0
              min: 0
              name: before
              nobind: 1
              r: 1
              re: !!perl/hash:RE_ast
                decl: []
                min: 1
                re: &33 !!perl/hash:RE_any
                  a: 0
                  altname: methodop_02
                  dba: methodop
                  i: 0
                  min: 1
                  name: methodop_02
                  r: 1
                  s: 0
                  zyg:
                  - !!perl/hash:RE_string
                    a: 0
                    alt: methodop_02 0
                    dba: methodop
                    i: 0
                    min: 1
                    r: 1
                    s: 0
                    text: $
                  - !!perl/hash:RE_string
                    a: 0
                    alt: methodop_02 1
                    dba: methodop
                    i: 0
                    min: 1
                    r: 1
                    s: 0
                    text: '@'
                  - !!perl/hash:RE_string
                    a: 0
                    alt: methodop_02 2
                    dba: methodop
                    i: 0
                    min: 1
                    r: 1
                    s: 0
                    text: '&'
              s: 0
          - !!perl/hash:RE_method
            a: 0
            dba: methodop
            i: 0
            min: 12345
            name: variable
            r: 1
            rest: ''
            s: 0
          - !!perl/hash:RE_block
            a: 0
            context: void
            dba: methodop
            i: 0
            min: 0
            r: 1
            s: 0
            text: ' $*VAR = $<variable> '
        - !!perl/hash:RE_sequence
          a: 0
          alt: methodop_01 2
          dba: methodop
          i: 0
          min: 12345
          r: 1
          s: 0
          zyg:
          - !!perl/hash:RE_assertion
            assert: '?'
            min: 0
            re: !!perl/hash:RE_method_re
              a: 0
              dba: methodop
              i: 0
              min: 0
              name: before
              nobind: 1
              r: 1
              re: !!perl/hash:RE_ast
                decl: []
                min: 1
                re: !!perl/hash:RE_cclass
                  a: 0
                  dba: methodop
                  i: 0
                  min: 1
                  r: 1
                  s: 0
                  text: '[ '' " ]'
              s: 0
          - !!perl/hash:RE_bracket
            decl: []
            min: 0
            re: !!perl/hash:RE_first
              a: 0
              dba: methodop
              i: 0
              min: 0
              r: 1
              s: 0
              zyg:
              - !!perl/hash:RE_assertion
                assert: '!'
                min: 0
                re: !!perl/hash:RE_block
                  a: 0
                  context: bool
                  dba: methodop
                  i: 0
                  min: 0
                  nobind: 1
                  r: 1
                  s: 0
                  text: $*QSIGIL
              - !!perl/hash:RE_assertion
                assert: '!'
                min: 0
                re: !!perl/hash:RE_method_re
                  a: 0
                  dba: methodop
                  i: 0
                  min: 0
                  name: before
                  nobind: 1
                  r: 1
                  re: !!perl/hash:RE_ast
                    decl: []
                    min: 2
                    re: !!perl/hash:RE_sequence
                      a: 0
                      dba: methodop
                      i: 0
                      min: 2
                      r: 1
                      s: 0
                      zyg:
                      - !!perl/hash:RE_string
                        a: 0
                        dba: methodop
                        i: 0
                        min: 1
                        r: 1
                        s: 0
                        text: '"'
                      - !!perl/hash:RE_quantified_atom
                        atom: !!perl/hash:RE_cclass
                          a: 0
                          dba: methodop
                          i: 0
                          min: 1
                          r: 1
                          s: 0
                          text: -["]
                        min: 0
                        quant:
                        - '*'
                        - '?'
                        - ''
                        - 0
                      - !!perl/hash:RE_meta
                        a: 0
                        dba: methodop
                        i: 0
                        min: 1
                        r: 1
                        s: 0
                        text: \s
                  s: 0
          - !!perl/hash:RE_method
            a: 0
            dba: methodop
            i: 0
            min: 12345
            name: quote
            r: 1
            rest: ''
            s: 0
          - !!perl/hash:RE_bracket
            decl: []
            min: 0
            re: !!perl/hash:RE_first
              a: 0
              dba: methodop
              i: 0
              min: 0
              r: 1
              s: 0
              zyg:
              - !!perl/hash:RE_assertion
                assert: '?'
                min: 0
                re: !!perl/hash:RE_method_re
                  a: 0
                  dba: methodop
                  i: 0
                  min: 0
                  name: before
                  nobind: 1
                  r: 1
                  re: !!perl/hash:RE_ast
                    decl: []
                    min: 1
                    re: &34 !!perl/hash:RE_any
                      a: 0
                      altname: methodop_08
                      dba: methodop
                      i: 0
                      min: 1
                      name: methodop_08
                      r: 1
                      s: 0
                      zyg:
                      - !!perl/hash:RE_string
                        a: 0
                        alt: methodop_08 0
                        dba: methodop
                        i: 0
                        min: 1
                        r: 1
                        s: 0
                        text: (
                      - !!perl/hash:RE_string
                        a: 0
                        alt: methodop_08 1
                        dba: methodop
                        i: 0
                        min: 2
                        r: 1
                        s: 0
                        text: .(
                      - !!perl/hash:RE_string
                        a: 0
                        alt: methodop_08 2
                        dba: methodop
                        i: 0
                        min: 1
                        r: 1
                        s: 0
                        text: \
                  s: 0
              - !!perl/hash:RE_method
                min: 0
                name: obs
                nobind: 1
                rest: ('. to concatenate strings or to call a quoted method', '~ to
                  concatenate, or if you meant to call a quoted method, please supply
                  the required parentheses')
          - !!perl/hash:RE_block
            a: 0
            context: void
            dba: methodop
            i: 0
            min: 0
            r: 1
            s: 0
            text: ' my $t = $<quote><nibble>.Str; $t ~~ /\W/ or $t ~~ /^(WHO|WHAT|WHERE|WHEN|WHY|HOW)$/
              or $.worry("Useless use of quotes") '
    - !!perl/hash:RE_quantified_atom
      atom: !!perl/hash:RE_method
        a: 0
        dba: methodop
        i: 0
        min: 12345
        name: unsp
        nobind: 1
        r: 1
        rest: ''
        s: 0
      min: 0
      quant:
      - '?'
      - ':'
      - ''
      - 0
    - !!perl/hash:RE_quantified_atom
      atom: !!perl/hash:RE_bracket
        decl: []
        min: 0
        re: &35 !!perl/hash:RE_any
          a: 0
          altname: methodop_10
          dba: method arguments
          i: 0
          min: 0
          name: methodop_10
          r: 1
          s: 0
          zyg:
          - !!perl/hash:RE_sequence
            a: 0
            alt: methodop_10 0
            dba: method arguments
            i: 0
            min: 12346
            r: 1
            s: 0
            zyg:
            - !!perl/hash:RE_string
              a: 0
              dba: method arguments
              i: 0
              min: 1
              r: 1
              s: 0
              text: ':'
            - !!perl/hash:RE_assertion
              assert: '?'
              min: 0
              re: !!perl/hash:RE_method_re
                a: 0
                dba: method arguments
                i: 0
                min: 0
                name: before
                nobind: 1
                r: 1
                re: !!perl/hash:RE_ast
                  decl: []
                  min: 1
                  re: !!perl/hash:RE_meta
                    a: 0
                    dba: method arguments
                    i: 0
                    min: 1
                    r: 1
                    s: 0
                    text: \s
                s: 0
            - !!perl/hash:RE_assertion
              assert: '!'
              min: 0
              re: !!perl/hash:RE_block
                a: 0
                context: bool
                dba: method arguments
                i: 0
                min: 0
                nobind: 1
                r: 1
                s: 0
                text: ' $*QSIGIL '
            - !!perl/hash:RE_method
              a: 0
              dba: method arguments
              i: 0
              min: 12345
              name: arglist
              r: 1
              rest: ''
              s: 0
          - !!perl/hash:RE_sequence
            a: 0
            alt: methodop_10 1
            dba: method arguments
            i: 0
            min: 12345
            r: 1
            s: 0
            zyg:
            - !!perl/hash:RE_assertion
              assert: '?'
              min: 0
              re: !!perl/hash:RE_cclass
                a: 0
                dba: method arguments
                i: 0
                min: 1
                nobind: 1
                r: 1
                s: 0
                text: '[\\(]'
            - !!perl/hash:RE_method
              a: 0
              dba: method arguments
              i: 0
              min: 12345
              name: args
              r: 1
              rest: ''
              s: 0
          - !!perl/hash:RE_block
            a: 0
            alt: methodop_10 2
            context: void
            dba: method arguments
            i: 0
            min: 0
            r: 1
            s: 0
            text: ' @*MEMOS[$.pos]<baremeth> = 1 '
      min: 0
      quant:
      - '?'
      - ':'
      - ''
      - 0
methodop_01: *32
methodop_02: *33
methodop_08: *34
methodop_10: *35
modifier_expr: !!perl/hash:RE_ast
  decl: []
  kind: rule
  min: 12345
  pkg: ~
  re: !!perl/hash:RE_sequence
    a: 0
    dba: modifier_expr
    i: 0
    min: 12345
    r: 1
    s: 1
    zyg:
    - !!perl/hash:RE_method
      min: 0
      name: ws
      nobind: 1
      noquant: 1
      rest: ''
    - !!perl/hash:RE_method
      a: 0
      dba: modifier_expr
      i: 0
      min: 12345
      name: EXPR
      r: 1
      rest: ''
      s: 1
    - !!perl/hash:RE_method
      min: 0
      name: ws
      nobind: 1
      noquant: 1
      rest: ''
module_name__S_100normal: !!perl/hash:RE_ast
  decl: []
  kind: token
  min: 12345
  pkg: ~
  re: !!perl/hash:RE_sequence
    a: 0
    dba: module_name__S_100normal
    i: 0
    min: 12345
    r: 1
    s: 0
    zyg:
    - !!perl/hash:RE_method
      a: 0
      dba: module_name__S_100normal
      i: 0
      min: 12345
      name: longname
      r: 1
      rest: ''
      s: 0
    - !!perl/hash:RE_quantified_atom
      atom: !!perl/hash:RE_bracket
        decl: []
        min: 12347
        re: !!perl/hash:RE_sequence
          a: 0
          dba: generic role
          i: 0
          min: 12347
          r: 1
          s: 0
          zyg:
          - !!perl/hash:RE_assertion
            assert: '?'
            min: 0
            re: !!perl/hash:RE_method_re
              a: 0
              dba: module_name__S_100normal
              i: 0
              min: 0
              name: before
              nobind: 1
              r: 1
              re: !!perl/hash:RE_ast
                decl: []
                min: 1
                re: !!perl/hash:RE_string
                  a: 0
                  dba: module_name__S_100normal
                  i: 0
                  min: 1
                  r: 1
                  s: 0
                  text: '['
              s: 0
          - !!perl/hash:RE_string
            a: 0
            dba: generic role
            i: 0
            min: 1
            r: 1
            s: 0
            text: '['
          - !!perl/hash:RE_meta
            a: 0
            dba: generic role
            extra: 'local $::GOAL = '']'' '
            i: 0
            min: 0
            r: 1
            s: 0
            text: ':'
          - !!perl/hash:RE_method
            a: 0
            dba: generic role
            i: 0
            min: 12345
            name: arglist
            r: 1
            rest: ''
            s: 0
          - !!perl/hash:RE_bracket
            decl: []
            min: 1
            re: !!perl/hash:RE_first
              a: 0
              dba: generic role
              i: 0
              min: 1
              r: 1
              s: 0
              zyg:
              - !!perl/hash:RE_string
                a: 0
                dba: generic role
                i: 0
                min: 1
                r: 1
                s: 0
                text: ']'
              - !!perl/hash:RE_method
                min: 0
                name: FAILGOAL
                nobind: 1
                rest: (']' , 'generic role')
      min: 0
      quant:
      - '?'
      - ':'
      - ''
      - 0
module_name__S_101deprecated: !!perl/hash:RE_ast
  decl: []
  kind: token
  min: 8
  pkg: ~
  re: !!perl/hash:RE_string
    a: 0
    dba: module_name__S_101deprecated
    i: 0
    min: 8
    r: 1
    s: 0
    text: v6-alpha
multi_declarator__S_120multi: !!perl/hash:RE_ast
  decl:
  - !!perl/hash:RE_decl
    a: 0
    dba: multi_declarator__S_120multi
    i: 0
    max: 0
    min: 0
    r: 1
    s: 0
    text: my $*MULTINESS = 'multi'
  kind: token
  min: 37035
  pkg: ~
  re: !!perl/hash:RE_sequence
    a: 0
    dba: multi_declarator__S_120multi
    i: 0
    min: 37035
    r: 1
    s: 0
    zyg:
    - !!perl/hash:RE_method
      a: 0
      dba: multi_declarator__S_120multi
      endsym: spacey
      i: 0
      min: 12345
      name: sym
      r: 1
      rest: ''
      s: 0
      sym: multi
    - !!perl/hash:RE_method
      a: 0
      dba: multi_declarator__S_120multi
      i: 0
      min: 12345
      name: spacey
      nobind: 1
      r: 1
      rest: ''
      s: 0
    - !!perl/hash:RE_method
      a: 0
      dba: multi_declarator__S_120multi
      i: 0
      min: 12345
      name: ws
      nobind: 1
      r: 1
      rest: ''
      s: 0
    - !!perl/hash:RE_bracket
      decl: []
      min: 0
      re: !!perl/hash:RE_first
        a: 0
        dba: multi_declarator__S_120multi
        i: 0
        min: 0
        r: 1
        s: 0
        zyg:
        - !!perl/hash:RE_method
          a: 0
          dba: multi_declarator__S_120multi
          i: 0
          min: 12345
          name: declarator
          r: 1
          rest: ''
          s: 0
        - !!perl/hash:RE_method
          a: 0
          dba: multi_declarator__S_120multi
          i: 0
          min: 12345
          name: routine_def
          r: 1
          rest: ''
          s: 0
        - !!perl/hash:RE_method
          min: 0
          name: panic
          nobind: 1
          rest: ('Malformed multi')
multi_declarator__S_121proto: !!perl/hash:RE_ast
  decl:
  - !!perl/hash:RE_decl
    a: 0
    dba: multi_declarator__S_121proto
    i: 0
    max: 0
    min: 0
    r: 1
    s: 0
    text: my $*MULTINESS = 'proto'
  kind: token
  min: 37035
  pkg: ~
  re: !!perl/hash:RE_sequence
    a: 0
    dba: multi_declarator__S_121proto
    i: 0
    min: 37035
    r: 1
    s: 0
    zyg:
    - !!perl/hash:RE_method
      a: 0
      dba: multi_declarator__S_121proto
      endsym: spacey
      i: 0
      min: 12345
      name: sym
      r: 1
      rest: ''
      s: 0
      sym: proto
    - !!perl/hash:RE_method
      a: 0
      dba: multi_declarator__S_121proto
      i: 0
      min: 12345
      name: spacey
      nobind: 1
      r: 1
      rest: ''
      s: 0
    - !!perl/hash:RE_method
      a: 0
      dba: multi_declarator__S_121proto
      i: 0
      min: 12345
      name: ws
      nobind: 1
      r: 1
      rest: ''
      s: 0
    - !!perl/hash:RE_bracket
      decl: []
      min: 0
      re: !!perl/hash:RE_first
        a: 0
        dba: multi_declarator__S_121proto
        i: 0
        min: 0
        r: 1
        s: 0
        zyg:
        - !!perl/hash:RE_method
          a: 0
          dba: multi_declarator__S_121proto
          i: 0
          min: 12345
          name: declarator
          r: 1
          rest: ''
          s: 0
        - !!perl/hash:RE_method
          a: 0
          dba: multi_declarator__S_121proto
          i: 0
          min: 12345
          name: routine_def
          r: 1
          rest: ''
          s: 0
        - !!perl/hash:RE_method
          min: 0
          name: panic
          nobind: 1
          rest: ('Malformed proto')
multi_declarator__S_122only: !!perl/hash:RE_ast
  decl:
  - !!perl/hash:RE_decl
    a: 0
    dba: multi_declarator__S_122only
    i: 0
    max: 0
    min: 0
    r: 1
    s: 0
    text: my $*MULTINESS = 'only'
  kind: token
  min: 37035
  pkg: ~
  re: !!perl/hash:RE_sequence
    a: 0
    dba: multi_declarator__S_122only
    i: 0
    min: 37035
    r: 1
    s: 0
    zyg:
    - !!perl/hash:RE_method
      a: 0
      dba: multi_declarator__S_122only
      endsym: spacey
      i: 0
      min: 12345
      name: sym
      r: 1
      rest: ''
      s: 0
      sym: only
    - !!perl/hash:RE_method
      a: 0
      dba: multi_declarator__S_122only
      i: 0
      min: 12345
      name: spacey
      nobind: 1
      r: 1
      rest: ''
      s: 0
    - !!perl/hash:RE_method
      a: 0
      dba: multi_declarator__S_122only
      i: 0
      min: 12345
      name: ws
      nobind: 1
      r: 1
      rest: ''
      s: 0
    - !!perl/hash:RE_bracket
      decl: []
      min: 0
      re: !!perl/hash:RE_first
        a: 0
        dba: multi_declarator__S_122only
        i: 0
        min: 0
        r: 1
        s: 0
        zyg:
        - !!perl/hash:RE_method
          a: 0
          dba: multi_declarator__S_122only
          i: 0
          min: 12345
          name: declarator
          r: 1
          rest: ''
          s: 0
        - !!perl/hash:RE_method
          a: 0
          dba: multi_declarator__S_122only
          i: 0
          min: 12345
          name: routine_def
          r: 1
          rest: ''
          s: 0
        - !!perl/hash:RE_method
          min: 0
          name: panic
          nobind: 1
          rest: ('Malformed only')
multi_declarator__S_123null: !!perl/hash:RE_ast
  decl:
  - !!perl/hash:RE_decl
    a: 0
    dba: multi_declarator__S_123null
    i: 0
    max: 0
    min: 0
    r: 1
    s: 0
    text: my $*MULTINESS = ''
  kind: token
  min: 12345
  pkg: ~
  re: !!perl/hash:RE_method
    a: 0
    dba: multi_declarator__S_123null
    i: 0
    min: 12345
    name: declarator
    r: 1
    rest: ''
    s: 0
multisig: !!perl/hash:RE_ast
  decl:
  - !!perl/hash:RE_decl
    a: 0
    dba: multisig
    i: 0
    max: 0
    min: 0
    r: 1
    s: 1
    text: my $signum = 0
  kind: rule
  min: 2
  pkg: ~
  re: !!perl/hash:RE_sequence
    a: 0
    dba: signature
    i: 0
    min: 2
    r: 1
    s: 1
    zyg:
    - !!perl/hash:RE_method
      min: 0
      name: ws
      nobind: 1
      noquant: 1
      rest: ''
    - !!perl/hash:RE_method
      min: 0
      name: ws
      nobind: 1
      noquant: 1
      rest: ''
    - !!perl/hash:RE_quantified_atom
      atom: !!perl/hash:RE_bracket
        decl: []
        min: 2
        re: !!perl/hash:RE_sequence
          a: 0
          dba: signature
          i: 0
          min: 2
          r: 1
          s: 1
          zyg:
          - !!perl/hash:RE_method
            min: 0
            name: ws
            nobind: 1
            noquant: 1
            rest: ''
          - !!perl/hash:RE_quantified_atom
            atom: !!perl/hash:RE_string
              a: 0
              dba: signature
              i: 0
              min: 1
              r: 1
              s: 1
              text: ':'
            min: 0
            quant:
            - '?'
            - ':'
            - ''
            - 0
          - !!perl/hash:RE_string
            a: 0
            dba: signature
            i: 0
            min: 1
            r: 1
            s: 1
            text: (
          - !!perl/hash:RE_method
            min: 0
            name: ws
            nobind: 1
            noquant: 1
            rest: ''
          - !!perl/hash:RE_meta
            a: 0
            dba: signature
            extra: local $::GOAL = ')'
            i: 0
            min: 0
            r: 1
            s: 1
            text: ':'
          - !!perl/hash:RE_method
            min: 0
            name: signature
            rest: (++$signum)
          - !!perl/hash:RE_bracket
            decl: []
            min: 1
            re: !!perl/hash:RE_first
              a: 0
              dba: signature
              i: 0
              min: 1
              r: 1
              s: 1
              zyg:
              - !!perl/hash:RE_string
                a: 0
                dba: signature
                i: 0
                min: 1
                r: 1
                s: 1
                text: )
              - !!perl/hash:RE_method
                min: 0
                name: FAILGOAL
                nobind: 1
                rest: (')', 'signature')
          - !!perl/hash:RE_method
            min: 0
            name: ws
            nobind: 1
            noquant: 1
            rest: ''
      min: 2
      quant:
      - '**'
      - ':'
      - !!perl/hash:RE_string
        a: 0
        dba: signature
        i: 0
        min: 1
        r: 1
        s: 1
        text: '|'
      - 1
    - !!perl/hash:RE_method
      min: 0
      name: ws
      nobind: 1
      noquant: 1
      rest: ''
named_param: !!perl/hash:RE_ast
  decl:
  - !!perl/hash:RE_decl
    a: 0
    dba: named_param
    i: 0
    max: 0
    min: 0
    r: 1
    s: 0
    text: my $*GOAL ::= ')'
  kind: token
  min: 12346
  pkg: ~
  re: !!perl/hash:RE_sequence
    a: 0
    dba: named_param
    i: 0
    min: 12346
    r: 1
    s: 0
    zyg:
    - !!perl/hash:RE_string
      a: 0
      dba: named_param
      i: 0
      min: 1
      r: 1
      s: 0
      text: ':'
    - !!perl/hash:RE_bracket
      decl: []
      min: 12345
      re: &36 !!perl/hash:RE_any
        a: 0
        altname: named_param_01
        dba: named_param
        i: 0
        min: 12345
        name: named_param_01
        r: 1
        s: 0
        zyg:
        - !!perl/hash:RE_sequence
          a: 0
          alt: named_param_01 0
          dba: named_param
          i: 0
          min: 37036
          r: 1
          s: 0
          zyg:
          - !!perl/hash:RE_bindnamed
            a: 0
            atom: !!perl/hash:RE_method
              a: 0
              dba: named_param
              i: 0
              min: 12345
              name: identifier
              nobind: 1
              r: 1
              rest: ''
              s: 0
            dba: named_param
            i: 0
            min: 12345
            r: 1
            s: 0
            var: name
          - !!perl/hash:RE_string
            a: 0
            dba: named_param
            i: 0
            min: 1
            r: 1
            s: 0
            text: (
          - !!perl/hash:RE_method
            a: 0
            dba: named_param
            i: 0
            min: 12345
            name: ws
            nobind: 1
            r: 1
            rest: ''
            s: 0
          - !!perl/hash:RE_bracket
            decl: []
            min: 12345
            re: &37 !!perl/hash:RE_any
              a: 0
              altname: named_param_02
              dba: named_param
              i: 0
              min: 12345
              name: named_param_02
              r: 1
              s: 0
              zyg:
              - !!perl/hash:RE_method
                a: 0
                alt: named_param_02 0
                dba: named_param
                i: 0
                min: 12345
                name: named_param
                r: 1
                rest: ''
                s: 0
              - !!perl/hash:RE_sequence
                a: 0
                alt: named_param_02 1
                dba: named_param
                i: 0
                min: 24690
                r: 1
                s: 0
                zyg:
                - !!perl/hash:RE_method
                  a: 0
                  dba: named_param
                  i: 0
                  min: 12345
                  name: param_var
                  r: 1
                  rest: ''
                  s: 0
                - !!perl/hash:RE_method
                  a: 0
                  dba: named_param
                  i: 0
                  min: 12345
                  name: ws
                  nobind: 1
                  r: 1
                  rest: ''
                  s: 0
          - !!perl/hash:RE_bracket
            decl: []
            min: 0
            re: !!perl/hash:RE_first
              a: 0
              dba: named_param
              i: 0
              min: 0
              r: 1
              s: 0
              zyg:
              - !!perl/hash:RE_string
                a: 0
                dba: named_param
                i: 0
                min: 1
                r: 1
                s: 0
                text: )
              - !!perl/hash:RE_method
                min: 0
                name: panic
                nobind: 1
                rest: ("Unable to parse named parameter; couldn't find right parenthesis")
        - !!perl/hash:RE_method
          a: 0
          alt: named_param_01 1
          dba: named_param
          i: 0
          min: 12345
          name: param_var
          r: 1
          rest: ''
          s: 0
named_param_01: *36
named_param_02: *37
nullterm: !!perl/hash:RE_ast
  decl: []
  kind: token
  min: 0
  pkg: ~
  re: !!perl/hash:RE_assertion
    assert: '?'
    min: 0
    re: !!perl/hash:RE_noop
      a: 0
      dba: nullterm
      i: 0
      min: 0
      nobind: 1
      r: 1
      s: 0
nulltermish: !!perl/hash:RE_ast
  decl: []
  kind: token
  min: 0
  pkg: ~
  re: !!perl/hash:RE_bracket
    decl: []
    min: 0
    re: &38 !!perl/hash:RE_any
      a: 0
      altname: nulltermish_01
      dba: null term
      i: 0
      min: 0
      name: nulltermish_01
      r: 1
      s: 0
      zyg:
      - !!perl/hash:RE_assertion
        alt: nulltermish_01 0
        assert: '?'
        min: 0
        re: !!perl/hash:RE_method
          a: 0
          dba: null term
          i: 0
          min: 12345
          name: stdstopper
          nobind: 1
          r: 1
          rest: ''
          s: 0
      - !!perl/hash:RE_sequence
        a: 0
        alt: nulltermish_01 1
        dba: null term
        i: 0
        min: 12345
        r: 1
        s: 0
        zyg:
        - !!perl/hash:RE_bindnamed
          a: 0
          atom: !!perl/hash:RE_method
            a: 0
            dba: null term
            i: 0
            min: 12345
            name: termish
            nobind: 1
            r: 1
            rest: ''
            s: 0
          dba: null term
          i: 0
          min: 12345
          r: 1
          s: 0
          var: term
        - !!perl/hash:RE_block
          a: 0
          context: void
          dba: null term
          i: 0
          min: 0
          r: 1
          s: 0
          text: "\n                $.<PRE>  = $<term><PRE>:delete;\n                $.<POST>
            = $<term><POST>:delete;\n                $.<~CAPS> = $<term><~CAPS>;\n
            \           "
      - !!perl/hash:RE_assertion
        alt: nulltermish_01 2
        assert: '?'
        min: 0
        re: !!perl/hash:RE_noop
          a: 0
          dba: null term
          i: 0
          min: 0
          nobind: 1
          r: 1
          s: 0
nulltermish_01: *38
number: !!perl/hash:RE_ast
  decl: []
  kind: token
  min: 3
  pkg: ~
  re: !!perl/hash:RE_bracket
    decl: []
    min: 3
    re: &39 !!perl/hash:RE_any
      a: 0
      altname: number_01
      dba: number
      i: 0
      min: 3
      name: number_01
      r: 1
      s: 0
      zyg:
      - !!perl/hash:RE_sequence
        a: 0
        alt: number_01 0
        dba: number
        i: 0
        min: 3
        r: 1
        s: 0
        zyg:
        - !!perl/hash:RE_string
          a: 0
          dba: number
          i: 0
          min: 3
          r: 1
          s: 0
          text: 'NaN'
        - !!perl/hash:RE_meta
          a: 0
          dba: number
          i: 0
          min: 0
          r: 1
          s: 0
          text: 
      - !!perl/hash:RE_method
        a: 0
        alt: number_01 1
        dba: number
        i: 0
        min: 12345
        name: integer
        r: 1
        rest: ''
        s: 0
      - !!perl/hash:RE_method
        a: 0
        alt: number_01 2
        dba: number
        i: 0
        min: 12345
        name: dec_number
        r: 1
        rest: ''
        s: 0
      - !!perl/hash:RE_method
        a: 0
        alt: number_01 3
        dba: number
        i: 0
        min: 12345
        name: rad_number
        r: 1
        rest: ''
        s: 0
      - !!perl/hash:RE_sequence
        a: 0
        alt: number_01 4
        dba: number
        i: 0
        min: 3
        r: 1
        s: 0
        zyg:
        - !!perl/hash:RE_string
          a: 0
          dba: number
          i: 0
          min: 3
          r: 1
          s: 0
          text: 'Inf'
        - !!perl/hash:RE_meta
          a: 0
          dba: number
          i: 0
          min: 0
          r: 1
          s: 0
          text: 
number_01: *39
old_rx_mods: !!perl/hash:RE_ast
  decl: []
  kind: token
  min: 1
  pkg: ~
  re: !!perl/hash:RE_sequence
    a: 0
    dba: old_rx_mods
    i: 0
    min: 1
    r: 1
    s: 0
    zyg:
    - !!perl/hash:RE_assertion
      assert: '!'
      min: 0
      re: !!perl/hash:RE_method_re
        a: 0
        dba: old_rx_mods
        i: 0
        min: 0
        name: after
        nobind: 1
        r: 1
        re: !!perl/hash:RE_ast
          decl: []
          min: 1
          re: !!perl/hash:RE_meta
            a: 0
            dba: old_rx_mods
            i: 0
            min: 1
            r: 1
            s: 0
            text: \s
        s: 0
    - !!perl/hash:RE_bindpos
      atom: !!perl/hash:RE_paren
        decl: []
        min: 1
        re: !!perl/hash:RE_quantified_atom
          atom: !!perl/hash:RE_qw
            a: 0
            dba: old_rx_mods
            i: 0
            min: 1
            r: 1
            s: 0
            text: < i g s m x c e >
          min: 1
          quant:
          - +
          - ':'
          - ''
          - 1
      min: 1
      var: 0
    - !!perl/hash:RE_block
      a: 0
      context: void
      dba: old_rx_mods
      i: 0
      min: 0
      r: 1
      s: 0
      text: "\n            given $0.Str {\n                $_ ~~ /i/ and $.worryobs('/i',':i');\n
        \               $_ ~~ /g/ and $.worryobs('/g',':g');\n                $_
        ~~ /s/ and $.worryobs('/s','^^ and $$ anchors');\n                $_ ~~ /m/
        and $.worryobs('/m','. or \\N');\n                $_ ~~ /x/ and $.worryobs('/x','normal
        default whitespace');\n                $_ ~~ /c/ and $.worryobs('/c',':c
        or :p');\n                $_ ~~ /e/ and $.worryobs('/e','interpolated {...}
        or s{} = ... form');\n                $.obs('suffix regex modifiers','prefix
        adverbs');\n            }\n        "
old_tr_mods: !!perl/hash:RE_ast
  decl: []
  kind: token
  min: 1
  pkg: ~
  re: !!perl/hash:RE_sequence
    a: 0
    dba: old_tr_mods
    i: 0
    min: 1
    r: 1
    s: 0
    zyg:
    - !!perl/hash:RE_bindpos
      atom: !!perl/hash:RE_paren
        decl: []
        min: 1
        re: !!perl/hash:RE_quantified_atom
          atom: !!perl/hash:RE_qw
            a: 0
            dba: old_tr_mods
            i: 0
            min: 1
            r: 1
            s: 0
            text: < c d s ] >
          min: 1
          quant:
          - +
          - ':'
          - ''
          - 1
      min: 1
      var: 0
    - !!perl/hash:RE_block
      a: 0
      context: void
      dba: old_tr_mods
      i: 0
      min: 0
      r: 1
      s: 0
      text: "\n            given $0.Str {\n                $_ ~~ /c/ and $.worryobs('/c',':c');\n
        \               $_ ~~ /d/ and $.worryobs('/g',':d');\n                $_
        ~~ /s/ and $.worryobs('/s',':s');\n                $.obs('suffix transliteration
        modifiers','prefix adverbs');\n            }\n        "
package_declarator__S_110class: !!perl/hash:RE_ast
  decl:
  - !!perl/hash:RE_decl
    a: 0
    dba: package_declarator__S_110class
    i: 0
    max: 0
    min: 0
    r: 1
    s: 0
    text: my $*PKGDECL ::= 'class'
  kind: token
  min: 37035
  pkg: ~
  re: !!perl/hash:RE_sequence
    a: 0
    dba: package_declarator__S_110class
    i: 0
    min: 37035
    r: 1
    s: 0
    zyg:
    - !!perl/hash:RE_method
      a: 0
      dba: package_declarator__S_110class
      endsym: spacey
      i: 0
      min: 12345
      name: sym
      r: 1
      rest: ''
      s: 0
      sym: class
    - !!perl/hash:RE_method
      a: 0
      dba: package_declarator__S_110class
      i: 0
      min: 12345
      name: spacey
      nobind: 1
      r: 1
      rest: ''
      s: 0
    - !!perl/hash:RE_method
      a: 0
      dba: package_declarator__S_110class
      i: 0
      min: 12345
      name: package_def
      r: 1
      rest: ''
      s: 0
package_declarator__S_111grammar: !!perl/hash:RE_ast
  decl:
  - !!perl/hash:RE_decl
    a: 0
    dba: package_declarator__S_111grammar
    i: 0
    max: 0
    min: 0
    r: 1
    s: 0
    text: my $*PKGDECL ::= 'grammar'
  kind: token
  min: 37035
  pkg: ~
  re: !!perl/hash:RE_sequence
    a: 0
    dba: package_declarator__S_111grammar
    i: 0
    min: 37035
    r: 1
    s: 0
    zyg:
    - !!perl/hash:RE_method
      a: 0
      dba: package_declarator__S_111grammar
      endsym: spacey
      i: 0
      min: 12345
      name: sym
      r: 1
      rest: ''
      s: 0
      sym: grammar
    - !!perl/hash:RE_method
      a: 0
      dba: package_declarator__S_111grammar
      i: 0
      min: 12345
      name: spacey
      nobind: 1
      r: 1
      rest: ''
      s: 0
    - !!perl/hash:RE_method
      a: 0
      dba: package_declarator__S_111grammar
      i: 0
      min: 12345
      name: package_def
      r: 1
      rest: ''
      s: 0
package_declarator__S_112module: !!perl/hash:RE_ast
  decl:
  - !!perl/hash:RE_decl
    a: 0
    dba: package_declarator__S_112module
    i: 0
    max: 0
    min: 0
    r: 1
    s: 0
    text: my $*PKGDECL ::= 'module'
  kind: token
  min: 37035
  pkg: ~
  re: !!perl/hash:RE_sequence
    a: 0
    dba: package_declarator__S_112module
    i: 0
    min: 37035
    r: 1
    s: 0
    zyg:
    - !!perl/hash:RE_method
      a: 0
      dba: package_declarator__S_112module
      endsym: spacey
      i: 0
      min: 12345
      name: sym
      r: 1
      rest: ''
      s: 0
      sym: module
    - !!perl/hash:RE_method
      a: 0
      dba: package_declarator__S_112module
      i: 0
      min: 12345
      name: spacey
      nobind: 1
      r: 1
      rest: ''
      s: 0
    - !!perl/hash:RE_method
      a: 0
      dba: package_declarator__S_112module
      i: 0
      min: 12345
      name: package_def
      r: 1
      rest: ''
      s: 0
package_declarator__S_113package: !!perl/hash:RE_ast
  decl:
  - !!perl/hash:RE_decl
    a: 0
    dba: package_declarator__S_113package
    i: 0
    max: 0
    min: 0
    r: 1
    s: 0
    text: my $*PKGDECL ::= 'package'
  kind: token
  min: 37035
  pkg: ~
  re: !!perl/hash:RE_sequence
    a: 0
    dba: package_declarator__S_113package
    i: 0
    min: 37035
    r: 1
    s: 0
    zyg:
    - !!perl/hash:RE_method
      a: 0
      dba: package_declarator__S_113package
      endsym: spacey
      i: 0
      min: 12345
      name: sym
      r: 1
      rest: ''
      s: 0
      sym: package
    - !!perl/hash:RE_method
      a: 0
      dba: package_declarator__S_113package
      i: 0
      min: 12345
      name: spacey
      nobind: 1
      r: 1
      rest: ''
      s: 0
    - !!perl/hash:RE_method
      a: 0
      dba: package_declarator__S_113package
      i: 0
      min: 12345
      name: package_def
      r: 1
      rest: ''
      s: 0
package_declarator__S_114role: !!perl/hash:RE_ast
  decl:
  - !!perl/hash:RE_decl
    a: 0
    dba: package_declarator__S_114role
    i: 0
    max: 0
    min: 0
    r: 1
    s: 0
    text: my $*PKGDECL ::= 'role'
  kind: token
  min: 37035
  pkg: ~
  re: !!perl/hash:RE_sequence
    a: 0
    dba: package_declarator__S_114role
    i: 0
    min: 37035
    r: 1
    s: 0
    zyg:
    - !!perl/hash:RE_method
      a: 0
      dba: package_declarator__S_114role
      endsym: spacey
      i: 0
      min: 12345
      name: sym
      r: 1
      rest: ''
      s: 0
      sym: role
    - !!perl/hash:RE_method
      a: 0
      dba: package_declarator__S_114role
      i: 0
      min: 12345
      name: spacey
      nobind: 1
      r: 1
      rest: ''
      s: 0
    - !!perl/hash:RE_method
      a: 0
      dba: package_declarator__S_114role
      i: 0
      min: 12345
      name: package_def
      r: 1
      rest: ''
      s: 0
package_declarator__S_115knowhow: !!perl/hash:RE_ast
  decl:
  - !!perl/hash:RE_decl
    a: 0
    dba: package_declarator__S_115knowhow
    i: 0
    max: 0
    min: 0
    r: 1
    s: 0
    text: my $*PKGDECL ::= 'knowhow'
  kind: token
  min: 37035
  pkg: ~
  re: !!perl/hash:RE_sequence
    a: 0
    dba: package_declarator__S_115knowhow
    i: 0
    min: 37035
    r: 1
    s: 0
    zyg:
    - !!perl/hash:RE_method
      a: 0
      dba: package_declarator__S_115knowhow
      endsym: spacey
      i: 0
      min: 12345
      name: sym
      r: 1
      rest: ''
      s: 0
      sym: knowhow
    - !!perl/hash:RE_method
      a: 0
      dba: package_declarator__S_115knowhow
      i: 0
      min: 12345
      name: spacey
      nobind: 1
      r: 1
      rest: ''
      s: 0
    - !!perl/hash:RE_method
      a: 0
      dba: package_declarator__S_115knowhow
      i: 0
      min: 12345
      name: package_def
      r: 1
      rest: ''
      s: 0
package_declarator__S_116slang: !!perl/hash:RE_ast
  decl:
  - !!perl/hash:RE_decl
    a: 0
    dba: package_declarator__S_116slang
    i: 0
    max: 0
    min: 0
    r: 1
    s: 0
    text: my $*PKGDECL ::= 'slang'
  kind: token
  min: 37035
  pkg: ~
  re: !!perl/hash:RE_sequence
    a: 0
    dba: package_declarator__S_116slang
    i: 0
    min: 37035
    r: 1
    s: 0
    zyg:
    - !!perl/hash:RE_method
      a: 0
      dba: package_declarator__S_116slang
      endsym: spacey
      i: 0
      min: 12345
      name: sym
      r: 1
      rest: ''
      s: 0
      sym: slang
    - !!perl/hash:RE_method
      a: 0
      dba: package_declarator__S_116slang
      i: 0
      min: 12345
      name: spacey
      nobind: 1
      r: 1
      rest: ''
      s: 0
    - !!perl/hash:RE_method
      a: 0
      dba: package_declarator__S_116slang
      i: 0
      min: 12345
      name: package_def
      r: 1
      rest: ''
      s: 0
package_declarator__S_117require: !!perl/hash:RE_ast
  decl: []
  kind: token
  min: 49380
  pkg: ~
  re: !!perl/hash:RE_sequence
    a: 0
    dba: package_declarator__S_117require
    i: 0
    min: 49380
    r: 1
    s: 0
    zyg:
    - !!perl/hash:RE_method
      a: 0
      dba: package_declarator__S_117require
      endsym: spacey
      i: 0
      min: 12345
      name: sym
      r: 1
      rest: ''
      s: 0
      sym: require
    - !!perl/hash:RE_method
      a: 0
      dba: package_declarator__S_117require
      i: 0
      min: 12345
      name: spacey
      nobind: 1
      r: 1
      rest: ''
      s: 0
    - !!perl/hash:RE_method
      a: 0
      dba: package_declarator__S_117require
      i: 0
      min: 12345
      name: ws
      nobind: 1
      r: 1
      rest: ''
      s: 0
    - !!perl/hash:RE_bracket
      decl: []
      min: 12345
      re: !!perl/hash:RE_first
        a: 0
        dba: package_declarator__S_117require
        i: 0
        min: 12345
        r: 1
        s: 0
        zyg:
        - !!perl/hash:RE_sequence
          a: 0
          dba: package_declarator__S_117require
          i: 0
          min: 12345
          r: 1
          s: 0
          zyg:
          - !!perl/hash:RE_method
            a: 0
            dba: package_declarator__S_117require
            i: 0
            min: 12345
            name: module_name
            r: 1
            rest: ''
            s: 0
          - !!perl/hash:RE_quantified_atom
            atom: !!perl/hash:RE_method
              a: 0
              dba: package_declarator__S_117require
              i: 0
              min: 12345
              name: EXPR
              r: 1
              rest: ''
              s: 0
            min: 0
            quant:
            - '?'
            - ':'
            - ''
            - 0
        - !!perl/hash:RE_method
          a: 0
          dba: package_declarator__S_117require
          i: 0
          min: 12345
          name: EXPR
          r: 1
          rest: ''
          s: 0
package_declarator__S_118trusts: !!perl/hash:RE_ast
  decl: []
  kind: token
  min: 49380
  pkg: ~
  re: !!perl/hash:RE_sequence
    a: 0
    dba: package_declarator__S_118trusts
    i: 0
    min: 49380
    r: 1
    s: 0
    zyg:
    - !!perl/hash:RE_method
      a: 0
      dba: package_declarator__S_118trusts
      endsym: spacey
      i: 0
      min: 12345
      name: sym
      r: 1
      rest: ''
      s: 0
      sym: trusts
    - !!perl/hash:RE_method
      a: 0
      dba: package_declarator__S_118trusts
      i: 0
      min: 12345
      name: spacey
      nobind: 1
      r: 1
      rest: ''
      s: 0
    - !!perl/hash:RE_method
      a: 0
      dba: package_declarator__S_118trusts
      i: 0
      min: 12345
      name: ws
      nobind: 1
      r: 1
      rest: ''
      s: 0
    - !!perl/hash:RE_method
      a: 0
      dba: package_declarator__S_118trusts
      i: 0
      min: 12345
      name: module_name
      r: 1
      rest: ''
      s: 0
package_declarator__S_119does: !!perl/hash:RE_ast
  decl: []
  kind: token
  min: 37035
  pkg: ~
  re: !!perl/hash:RE_sequence
    a: 0
    dba: package_declarator__S_119does
    i: 0
    min: 37035
    r: 1
    s: 1
    zyg:
    - !!perl/hash:RE_method
      a: 0
      dba: package_declarator__S_119does
      endsym: spacey
      i: 0
      min: 12345
      name: sym
      r: 1
      rest: ''
      s: 0
      sym: does
    - !!perl/hash:RE_method
      a: 0
      dba: package_declarator__S_119does
      i: 0
      min: 12345
      name: spacey
      nobind: 1
      r: 1
      rest: ''
      s: 0
    - !!perl/hash:RE_method
      min: 0
      name: ws
      nobind: 1
      noquant: 1
      rest: ''
    - !!perl/hash:RE_method
      a: 0
      dba: package_declarator__S_119does
      i: 0
      min: 12345
      name: typename
      r: 1
      rest: ''
      s: 1
    - !!perl/hash:RE_method
      min: 0
      name: ws
      nobind: 1
      noquant: 1
      rest: ''
package_def: !!perl/hash:RE_ast
  decl:
  - !!perl/hash:RE_decl
    a: 0
    dba: package_def
    i: 0
    max: 0
    min: 0
    r: 1
    s: 1
    text: my $longname
  - !!perl/hash:RE_decl
    a: 0
    dba: package_def
    i: 0
    max: 0
    min: 0
    r: 1
    s: 1
    text: my $*IN_DECL = 'package'
  - !!perl/hash:RE_decl
    a: 0
    dba: package_def
    i: 0
    max: 0
    min: 0
    r: 1
    s: 1
    text: my $*DECLARAND
  - !!perl/hash:RE_decl
    a: 0
    dba: package_def
    i: 0
    max: 0
    min: 0
    r: 1
    s: 1
    text: my $*NEWPKG
  - !!perl/hash:RE_decl
    a: 0
    dba: package_def
    i: 0
    max: 0
    min: 0
    r: 1
    s: 1
    text: my $*NEWPAD
  - !!perl/hash:RE_decl
    a: 0
    dba: package_def
    i: 0
    max: 0
    min: 0
    r: 1
    s: 1
    text: temp $*CURPKG
  kind: rule
  min: 0
  pkg: ~
  re: !!perl/hash:RE_first
    a: 0
    dba: package_def
    i: 0
    min: 0
    r: 1
    s: 1
    zyg:
    - !!perl/hash:RE_sequence
      a: 0
      dba: package_def
      i: 0
      min: 12345
      r: 1
      s: 1
      zyg:
      - !!perl/hash:RE_method
        min: 0
        name: ws
        nobind: 1
        noquant: 1
        rest: ''
      - !!perl/hash:RE_block
        a: 0
        context: void
        dba: package_def
        i: 0
        min: 0
        r: 1
        s: 1
        text: ' $*SCOPE ||= ''our''; '
      - !!perl/hash:RE_method
        min: 0
        name: ws
        nobind: 1
        noquant: 1
        rest: ''
      - !!perl/hash:RE_bracket
        decl: []
        min: 12345
        re: !!perl/hash:RE_sequence
          a: 0
          dba: package_def
          i: 0
          min: 12345
          r: 1
          s: 1
          zyg:
          - !!perl/hash:RE_quantified_atom
            atom: !!perl/hash:RE_bracket
              decl: []
              min: 12345
              re: !!perl/hash:RE_sequence
                a: 0
                dba: package_def
                i: 0
                min: 12345
                r: 1
                s: 1
                zyg:
                - !!perl/hash:RE_method
                  min: 0
                  name: ws
                  nobind: 1
                  noquant: 1
                  rest: ''
                - !!perl/hash:RE_method
                  a: 0
                  dba: package_def
                  i: 0
                  min: 12345
                  name: def_module_name
                  r: 1
                  rest: ''
                  s: 1
                - !!perl/hash:RE_block
                  a: 0
                  context: void
                  dba: package_def
                  i: 0
                  min: 0
                  r: 1
                  s: 1
                  text: "\n                    $longname = $<def_module_name>[0]<longname>;\n
                    \                   $.add_name($longname.Str);\n                "
                - !!perl/hash:RE_method
                  min: 0
                  name: ws
                  nobind: 1
                  noquant: 1
                  rest: ''
            min: 0
            quant:
            - '?'
            - ':'
            - ''
            - 0
          - !!perl/hash:RE_method
            min: 0
            name: ws
            nobind: 1
            noquant: 1
            rest: ''
          - !!perl/hash:RE_quantified_atom
            atom: !!perl/hash:RE_method
              a: 0
              dba: package_def
              i: 0
              min: 12345
              name: trait
              r: 1
              rest: ''
              s: 1
            min: 0
            quant:
            - '*'
            - ':'
            - ''
            - 0
          - !!perl/hash:RE_method
            min: 0
            name: ws
            nobind: 1
            noquant: 1
            rest: ''
          - !!perl/hash:RE_method
            a: 0
            dba: package_def
            i: 0
            min: 12345
            name: getdecl
            nobind: 1
            r: 1
            rest: ''
            s: 1
          - !!perl/hash:RE_method
            min: 0
            name: ws
            nobind: 1
            noquant: 1
            rest: ''
          - !!perl/hash:RE_bracket
            decl: []
            min: 0
            re: !!perl/hash:RE_first
              a: 0
              dba: package_def
              i: 0
              min: 0
              r: 1
              s: 1
              zyg:
              - !!perl/hash:RE_sequence
                a: 0
                dba: package_def
                i: 0
                min: 12345
                r: 1
                s: 1
                zyg:
                - !!perl/hash:RE_assertion
                  assert: '?'
                  min: 0
                  re: !!perl/hash:RE_method_re
                    a: 0
                    dba: package_def
                    i: 0
                    min: 0
                    name: before
                    nobind: 1
                    r: 1
                    re: !!perl/hash:RE_ast
                      decl: []
                      min: 1
                      re: !!perl/hash:RE_string
                        a: 0
                        dba: package_def
                        i: 0
                        min: 1
                        r: 1
                        s: 1
                        text: '{'
                    s: 1
                - !!perl/hash:RE_method
                  min: 0
                  name: ws
                  nobind: 1
                  noquant: 1
                  rest: ''
                - !!perl/hash:RE_bracket
                  decl: []
                  min: 12345
                  re: !!perl/hash:RE_sequence
                    a: 0
                    dba: package_def
                    i: 0
                    min: 12345
                    r: 1
                    s: 1
                    zyg:
                    - !!perl/hash:RE_block
                      a: 0
                      context: void
                      dba: package_def
                      i: 0
                      min: 0
                      r: 1
                      s: 1
                      text: "\n                    # figure out the actual full package
                        name (nested in outer package)\n                    if $longname
                        and $*NEWPKG {\n                        my $shortname = $longname.<name>.Str;\n
                        \                       if $*SCOPE eq 'our' {\n                            $*CURPKG
                        = $*NEWPKG // $*CURPKG.{$shortname ~ '::'};\n                            self.deb(\"added
                        our \" ~ $*CURPKG.id) if $*DEBUG +& DEBUG::symtab;\n                        }\n
                        \                       else {\n                            $*CURPKG
                        = $*NEWPKG // $*CURPKG.{$shortname ~ '::'};\n                            self.deb(\"added
                        my \" ~ $*CURPKG.id) if $*DEBUG +& DEBUG::symtab;\n                        }\n
                        \                   }\n                    $*begin_compunit
                        = 0;\n                "
                    - !!perl/hash:RE_method
                      min: 0
                      name: ws
                      nobind: 1
                      noquant: 1
                      rest: ''
                    - !!perl/hash:RE_method
                      a: 0
                      dba: package_def
                      i: 0
                      min: 12345
                      name: block
                      r: 1
                      rest: ''
                      s: 1
                    - !!perl/hash:RE_method
                      min: 0
                      name: ws
                      nobind: 1
                      noquant: 1
                      rest: ''
                - !!perl/hash:RE_method
                  min: 0
                  name: ws
                  nobind: 1
                  noquant: 1
                  rest: ''
              - !!perl/hash:RE_sequence
                a: 0
                dba: package_def
                i: 0
                min: 0
                r: 1
                s: 1
                zyg:
                - !!perl/hash:RE_assertion
                  assert: '?'
                  min: 0
                  re: !!perl/hash:RE_method_re
                    a: 0
                    dba: package_def
                    i: 0
                    min: 0
                    name: before
                    nobind: 1
                    r: 1
                    re: !!perl/hash:RE_ast
                      decl: []
                      min: 1
                      re: !!perl/hash:RE_string
                        a: 0
                        dba: package_def
                        i: 0
                        min: 1
                        r: 1
                        s: 1
                        text: ;
                    s: 1
                - !!perl/hash:RE_method
                  min: 0
                  name: ws
                  nobind: 1
                  noquant: 1
                  rest: ''
                - !!perl/hash:RE_bracket
                  decl: []
                  min: 0
                  re: !!perl/hash:RE_first
                    a: 0
                    dba: package_def
                    i: 0
                    min: 0
                    r: 1
                    s: 1
                    zyg:
                    - !!perl/hash:RE_sequence
                      a: 0
                      dba: package_def
                      i: 0
                      min: 12345
                      r: 1
                      s: 1
                      zyg:
                      - !!perl/hash:RE_assertion
                        assert: '?'
                        min: 0
                        re: !!perl/hash:RE_block
                          a: 0
                          context: bool
                          dba: package_def
                          i: 0
                          min: 0
                          nobind: 1
                          r: 1
                          s: 1
                          text: ' $*begin_compunit '
                      - !!perl/hash:RE_method
                        min: 0
                        name: ws
                        nobind: 1
                        noquant: 1
                        rest: ''
                      - !!perl/hash:RE_block
                        a: 0
                        context: void
                        dba: package_def
                        i: 0
                        min: 0
                        r: 1
                        s: 1
                        text: "\n                        $longname orelse $.panic(\"Compilation
                          unit cannot be anonymous\");\n                        my
                          $shortname = $longname.<name>.Str;\n                        $*CURPKG
                          = $*NEWPKG // $*CURPKG.{$shortname ~ '::'};\n                        $*begin_compunit
                          = 0;\n\n                        # throw out null core when
                          compiling the real CORE\n                        if $shortname
                          eq 'CORE' and $*CORE.id ~~ /NULL/ {\n                            $*UNIT<OUTER::>
                          = [''];\n                            $*CORE = $*UNIT;\n
                          \                           $*SETTING = $*UNIT;\n                            $ALL
                          = {\n                                CORE => $*UNIT,\n                                SETTING
                          => $*UNIT,\n                                $*UNIT.id =>
                          $*UNIT,\n                            };\n                        }\n
                          \                   "
                      - !!perl/hash:RE_method
                        min: 0
                        name: ws
                        nobind: 1
                        noquant: 1
                        rest: ''
                      - !!perl/hash:RE_method
                        a: 0
                        dba: package_def
                        i: 0
                        min: 12345
                        name: statementlist
                        r: 1
                        rest: ''
                        s: 1
                      - !!perl/hash:RE_method
                        min: 0
                        name: ws
                        nobind: 1
                        noquant: 1
                        rest: ''
                    - !!perl/hash:RE_sequence
                      a: 0
                      dba: package_def
                      i: 0
                      min: 0
                      r: 1
                      s: 1
                      zyg:
                      - !!perl/hash:RE_method
                        min: 0
                        name: panic
                        nobind: 1
                        rest: ("Too late for semicolon form of " ~ $*PKGDECL ~ " definition")
                      - !!perl/hash:RE_method
                        min: 0
                        name: ws
                        nobind: 1
                        noquant: 1
                        rest: ''
                - !!perl/hash:RE_method
                  min: 0
                  name: ws
                  nobind: 1
                  noquant: 1
                  rest: ''
              - !!perl/hash:RE_sequence
                a: 0
                dba: package_def
                i: 0
                min: 0
                r: 1
                s: 1
                zyg:
                - !!perl/hash:RE_method
                  min: 0
                  name: panic
                  nobind: 1
                  rest: ("Unable to parse " ~ $*PKGDECL ~ " definition")
                - !!perl/hash:RE_method
                  min: 0
                  name: ws
                  nobind: 1
                  noquant: 1
                  rest: ''
          - !!perl/hash:RE_method
            min: 0
            name: ws
            nobind: 1
            noquant: 1
            rest: ''
      - !!perl/hash:RE_method
        min: 0
        name: ws
        nobind: 1
        noquant: 1
        rest: ''
    - !!perl/hash:RE_sequence
      a: 0
      dba: package_def
      i: 0
      min: 0
      r: 1
      s: 1
      zyg:
      - !!perl/hash:RE_method
        min: 0
        name: ws
        nobind: 1
        noquant: 1
        rest: ''
      - !!perl/hash:RE_method
        min: 0
        name: panic
        nobind: 1
        rest: ("Malformed $*PKGDECL")
      - !!perl/hash:RE_method
        min: 0
        name: ws
        nobind: 1
        noquant: 1
        rest: ''
param_sep: !!perl/hash:RE_ast
  decl: []
  kind: rule
  min: 1
  pkg: ~
  re: !!perl/hash:RE_sequence
    a: 0
    dba: param_sep
    i: 0
    min: 1
    r: 1
    s: 1
    zyg:
    - !!perl/hash:RE_method
      min: 0
      name: ws
      nobind: 1
      noquant: 1
      rest: ''
    - !!perl/hash:RE_bracket
      decl: []
      min: 1
      re: &40 !!perl/hash:RE_any
        a: 0
        altname: param_sep_01
        dba: param_sep
        i: 0
        min: 1
        name: param_sep_01
        r: 1
        s: 1
        zyg:
        - !!perl/hash:RE_string
          a: 0
          alt: param_sep_01 0
          dba: param_sep
          i: 0
          min: 1
          r: 1
          s: 1
          text: ','
        - !!perl/hash:RE_string
          a: 0
          alt: param_sep_01 1
          dba: param_sep
          i: 0
          min: 1
          r: 1
          s: 1
          text: ':'
        - !!perl/hash:RE_string
          a: 0
          alt: param_sep_01 2
          dba: param_sep
          i: 0
          min: 1
          r: 1
          s: 1
          text: ;
        - !!perl/hash:RE_string
          a: 0
          alt: param_sep_01 3
          dba: param_sep
          i: 0
          min: 2
          r: 1
          s: 1
          text: ;;
    - !!perl/hash:RE_method
      min: 0
      name: ws
      nobind: 1
      noquant: 1
      rest: ''
param_sep_01: *40
param_var: !!perl/hash:RE_ast
  decl: []
  kind: token
  min: 12345
  pkg: ~
  re: !!perl/hash:RE_bracket
    decl: []
    min: 12345
    re: &41 !!perl/hash:RE_any
      a: 0
      altname: param_var_01
      dba: formal parameter
      i: 0
      min: 12345
      name: param_var_01
      r: 1
      s: 0
      zyg:
      - !!perl/hash:RE_sequence
        a: 0
        alt: param_var_01 0
        dba: formal parameter
        i: 0
        min: 12347
        r: 1
        s: 0
        zyg:
        - !!perl/hash:RE_string
          a: 0
          dba: formal parameter
          i: 0
          min: 1
          r: 1
          s: 0
          text: '['
        - !!perl/hash:RE_meta
          a: 0
          dba: formal parameter
          extra: 'local $::GOAL = '']'' '
          i: 0
          min: 0
          r: 1
          s: 0
          text: ':'
        - !!perl/hash:RE_method
          a: 0
          dba: formal parameter
          i: 0
          min: 12345
          name: signature
          r: 1
          rest: ''
          s: 0
        - !!perl/hash:RE_bracket
          decl: []
          min: 1
          re: !!perl/hash:RE_first
            a: 0
            dba: formal parameter
            i: 0
            min: 1
            r: 1
            s: 0
            zyg:
            - !!perl/hash:RE_string
              a: 0
              dba: formal parameter
              i: 0
              min: 1
              r: 1
              s: 0
              text: ']'
            - !!perl/hash:RE_method
              min: 0
              name: FAILGOAL
              nobind: 1
              rest: (']' , 'formal parameter')
      - !!perl/hash:RE_sequence
        a: 0
        alt: param_var_01 1
        dba: formal parameter
        i: 0
        min: 12347
        r: 1
        s: 0
        zyg:
        - !!perl/hash:RE_string
          a: 0
          dba: formal parameter
          i: 0
          min: 1
          r: 1
          s: 0
          text: (
        - !!perl/hash:RE_meta
          a: 0
          dba: formal parameter
          extra: 'local $::GOAL = '')'' '
          i: 0
          min: 0
          r: 1
          s: 0
          text: ':'
        - !!perl/hash:RE_method
          a: 0
          dba: formal parameter
          i: 0
          min: 12345
          name: signature
          r: 1
          rest: ''
          s: 0
        - !!perl/hash:RE_bracket
          decl: []
          min: 1
          re: !!perl/hash:RE_first
            a: 0
            dba: formal parameter
            i: 0
            min: 1
            r: 1
            s: 0
            zyg:
            - !!perl/hash:RE_string
              a: 0
              dba: formal parameter
              i: 0
              min: 1
              r: 1
              s: 0
              text: )
            - !!perl/hash:RE_method
              min: 0
              name: FAILGOAL
              nobind: 1
              rest: (')' , 'formal parameter')
      - !!perl/hash:RE_sequence
        a: 0
        alt: param_var_01 2
        dba: formal parameter
        i: 0
        min: 12345
        r: 1
        s: 0
        zyg:
        - !!perl/hash:RE_method
          a: 0
          dba: formal parameter
          i: 0
          min: 12345
          name: sigil
          r: 1
          rest: ''
          s: 0
        - !!perl/hash:RE_quantified_atom
          atom: !!perl/hash:RE_method
            a: 0
            dba: formal parameter
            i: 0
            min: 12345
            name: twigil
            r: 1
            rest: ''
            s: 0
          min: 0
          quant:
          - '?'
          - ':'
          - ''
          - 0
        - !!perl/hash:RE_quantified_atom
          atom: !!perl/hash:RE_bracket
            decl: []
            min: 1
            re: !!perl/hash:RE_first
              a: 0
              dba: formal parameter
              i: 0
              min: 1
              r: 1
              s: 0
              zyg:
              - !!perl/hash:RE_sequence
                a: 0
                dba: formal parameter
                i: 0
                min: 12345
                r: 1
                s: 0
                zyg:
                - !!perl/hash:RE_assertion
                  assert: '?'
                  min: 0
                  re: !!perl/hash:RE_block
                    a: 0
                    context: bool
                    dba: formal parameter
                    i: 0
                    min: 0
                    nobind: 1
                    r: 1
                    s: 0
                    text: ' $<sigil>.Str eq ''&'' '
                - !!perl/hash:RE_assertion
                  assert: '?'
                  min: 0
                  re: !!perl/hash:RE_method
                    a: 0
                    dba: formal parameter
                    i: 0
                    min: 12345
                    name: ident
                    nobind: 1
                    r: 1
                    rest: ''
                    s: 0
                - !!perl/hash:RE_block
                  a: 0
                  context: void
                  dba: formal parameter
                  i: 0
                  min: 0
                  r: 1
                  s: 0
                  text: ''
                - !!perl/hash:RE_bindnamed
                  a: 0
                  atom: !!perl/hash:RE_method
                    a: 0
                    dba: formal parameter
                    i: 0
                    min: 12345
                    name: sublongname
                    nobind: 1
                    r: 1
                    rest: ''
                    s: 0
                  dba: formal parameter
                  i: 0
                  min: 12345
                  r: 1
                  s: 0
                  var: name
              - !!perl/hash:RE_sequence
                a: 0
                dba: formal parameter
                i: 0
                min: 12345
                r: 1
                s: 0
                zyg:
                - !!perl/hash:RE_assertion
                  assert: '?'
                  min: 0
                  re: !!perl/hash:RE_block
                    a: 0
                    context: bool
                    dba: formal parameter
                    i: 0
                    min: 0
                    nobind: 1
                    r: 1
                    s: 0
                    text: ' $<sigil>.Str eq ''@'' || $<sigil>.Str eq ''%'' '
                - !!perl/hash:RE_bindnamed
                  a: 0
                  atom: !!perl/hash:RE_quantified_atom
                    atom: !!perl/hash:RE_method
                      a: 0
                      dba: formal parameter
                      i: 0
                      min: 12345
                      name: identifier
                      nobind: 1
                      r: 1
                      rest: ''
                      s: 0
                    min: 0
                    quant:
                    - '?'
                    - ':'
                    - ''
                    - 0
                  dba: formal parameter
                  i: 0
                  min: 0
                  r: 1
                  s: 0
                  var: name
                - !!perl/hash:RE_assertion
                  assert: '?'
                  min: 0
                  re: !!perl/hash:RE_method_re
                    a: 0
                    dba: formal parameter
                    i: 0
                    min: 0
                    name: before
                    nobind: 1
                    r: 1
                    re: !!perl/hash:RE_ast
                      decl: []
                      min: 1
                      re: !!perl/hash:RE_cclass
                        a: 0
                        dba: formal parameter
                        i: 0
                        min: 1
                        r: 1
                        s: 0
                        text: '[ \< \( \[ \{ ]'
                    s: 0
                - !!perl/hash:RE_method
                  a: 0
                  dba: formal parameter
                  i: 0
                  min: 12345
                  name: postcircumfix
                  r: 1
                  rest: ''
                  s: 0
              - !!perl/hash:RE_bindnamed
                a: 0
                atom: !!perl/hash:RE_method
                  a: 0
                  dba: formal parameter
                  i: 0
                  min: 12345
                  name: identifier
                  nobind: 1
                  r: 1
                  rest: ''
                  s: 0
                dba: formal parameter
                i: 0
                min: 12345
                r: 1
                s: 0
                var: name
              - !!perl/hash:RE_bindnamed
                a: 0
                atom: !!perl/hash:RE_bracket
                  decl: []
                  min: 1
                  re: !!perl/hash:RE_cclass
                    a: 0
                    dba: formal parameter
                    i: 0
                    min: 1
                    r: 1
                    s: 0
                    text: '[/!]'
                dba: formal parameter
                i: 0
                min: 1
                r: 1
                s: 0
                var: name
          min: 0
          quant:
          - '?'
          - ':'
          - ''
          - 0
        - !!perl/hash:RE_block
          a: 0
          context: void
          dba: formal parameter
          i: 0
          min: 0
          r: 1
          s: 0
          text: "\n                my $vname = $<sigil>.Str;\n                my $t
            = $<twigil>;\n                my $twigil = '';\n                $twigil
            = $t.[0].Str if @$t;\n                $vname ~= $twigil;\n                my
            $n = try { $<name>[0].Str } // '';\n                $vname ~= $n;\n                given
            $twigil {\n                    when '' {\n                        self.add_my_name($vname)
            if $n ne '';\n                    }\n                    when '.' {\n
            \                   }\n                    when '!' {\n                    }\n
            \                   when '*' {\n                    }\n                    default
            {\n                        self.worry(\"Illegal to use $twigil twigil
            in signature\");\n                    }\n                }\n            "
param_var_01: *41
parameter: !!perl/hash:RE_ast
  decl:
  - !!perl/hash:RE_decl
    a: 0
    dba: parameter
    i: 0
    max: 0
    min: 0
    r: 1
    s: 0
    text: my $kind
  - !!perl/hash:RE_decl
    a: 0
    dba: parameter
    i: 0
    max: 0
    min: 0
    r: 1
    s: 0
    text: my $quant = ''
  - !!perl/hash:RE_decl
    a: 0
    dba: parameter
    i: 0
    max: 0
    min: 0
    r: 1
    s: 0
    text: my $q
  - !!perl/hash:RE_decl
    a: 0
    dba: parameter
    i: 0
    max: 0
    min: 0
    r: 1
    s: 0
    text: my $*DECLARAND
  kind: token
  min: 24690
  pkg: ~
  re: !!perl/hash:RE_sequence
    a: 0
    dba: parameter
    i: 0
    min: 24690
    r: 1
    s: 0
    zyg:
    - !!perl/hash:RE_bracket
      decl: []
      min: 12345
      re: &42 !!perl/hash:RE_any
        a: 0
        altname: parameter_01
        dba: parameter
        i: 0
        min: 12345
        name: parameter_01
        r: 1
        s: 0
        zyg:
        - !!perl/hash:RE_sequence
          a: 0
          alt: parameter_01 0
          dba: parameter
          i: 0
          min: 12345
          r: 1
          s: 0
          zyg:
          - !!perl/hash:RE_quantified_atom
            atom: !!perl/hash:RE_method
              a: 0
              dba: parameter
              i: 0
              min: 12345
              name: type_constraint
              r: 1
              rest: ''
              s: 0
            min: 12345
            quant:
            - +
            - ':'
            - ''
            - 1
          - !!perl/hash:RE_block
            a: 0
            context: void
            dba: parameter
            i: 0
            min: 0
            r: 1
            s: 0
            text: "\n                my $t = $<type_constraint>;\n                my
              @t = grep { substr($_.Str,0,2) ne '::' }, @$t;\n                @t >
              1 and $.panic(\"Multiple prefix constraints not yet supported\")\n
              \           "
          - !!perl/hash:RE_bracket
            decl: []
            min: 0
            re: &43 !!perl/hash:RE_any
              a: 0
              altname: parameter_02
              dba: parameter
              i: 0
              min: 0
              name: parameter_02
              r: 1
              s: 0
              zyg:
              - !!perl/hash:RE_sequence
                a: 0
                alt: parameter_02 0
                dba: parameter
                i: 0
                min: 12347
                r: 1
                s: 0
                zyg:
                - !!perl/hash:RE_string
                  a: 0
                  dba: parameter
                  i: 0
                  min: 2
                  r: 1
                  s: 0
                  text: '**'
                - !!perl/hash:RE_method
                  a: 0
                  dba: parameter
                  i: 0
                  min: 12345
                  name: param_var
                  r: 1
                  rest: ''
                  s: 0
                - !!perl/hash:RE_block
                  a: 0
                  context: void
                  dba: parameter
                  i: 0
                  min: 0
                  r: 1
                  s: 0
                  text: ' $quant = ''**''; $kind = ''*''; '
              - !!perl/hash:RE_sequence
                a: 0
                alt: parameter_02 1
                dba: parameter
                i: 0
                min: 12346
                r: 1
                s: 0
                zyg:
                - !!perl/hash:RE_string
                  a: 0
                  dba: parameter
                  i: 0
                  min: 1
                  r: 1
                  s: 0
                  text: '*'
                - !!perl/hash:RE_method
                  a: 0
                  dba: parameter
                  i: 0
                  min: 12345
                  name: param_var
                  r: 1
                  rest: ''
                  s: 0
                - !!perl/hash:RE_block
                  a: 0
                  context: void
                  dba: parameter
                  i: 0
                  min: 0
                  r: 1
                  s: 0
                  text: ' $quant = ''*''; $kind = ''*''; '
              - !!perl/hash:RE_sequence
                a: 0
                alt: parameter_02 2
                dba: parameter
                i: 0
                min: 12346
                r: 1
                s: 0
                zyg:
                - !!perl/hash:RE_string
                  a: 0
                  dba: parameter
                  i: 0
                  min: 1
                  r: 1
                  s: 0
                  text: '|'
                - !!perl/hash:RE_method
                  a: 0
                  dba: parameter
                  i: 0
                  min: 12345
                  name: param_var
                  r: 1
                  rest: ''
                  s: 0
                - !!perl/hash:RE_block
                  a: 0
                  context: void
                  dba: parameter
                  i: 0
                  min: 0
                  r: 1
                  s: 0
                  text: ' $quant = ''|''; $kind = ''*''; '
              - !!perl/hash:RE_sequence
                a: 0
                alt: parameter_02 3
                dba: parameter
                i: 0
                min: 12346
                r: 1
                s: 0
                zyg:
                - !!perl/hash:RE_string
                  a: 0
                  dba: parameter
                  i: 0
                  min: 1
                  r: 1
                  s: 0
                  text: \
                - !!perl/hash:RE_method
                  a: 0
                  dba: parameter
                  i: 0
                  min: 12345
                  name: param_var
                  r: 1
                  rest: ''
                  s: 0
                - !!perl/hash:RE_block
                  a: 0
                  context: void
                  dba: parameter
                  i: 0
                  min: 0
                  r: 1
                  s: 0
                  text: ' $quant = ''\\''; $kind = ''!''; '
              - !!perl/hash:RE_sequence
                a: 0
                alt: parameter_02 4
                dba: parameter
                i: 0
                min: 12345
                r: 1
                s: 0
                zyg:
                - !!perl/hash:RE_bracket
                  decl: []
                  min: 12345
                  re: &44 !!perl/hash:RE_any
                    a: 0
                    altname: parameter_03
                    dba: parameter
                    i: 0
                    min: 12345
                    name: parameter_03
                    r: 1
                    s: 0
                    zyg:
                    - !!perl/hash:RE_sequence
                      a: 0
                      alt: parameter_03 0
                      dba: parameter
                      i: 0
                      min: 12345
                      r: 1
                      s: 0
                      zyg:
                      - !!perl/hash:RE_method
                        a: 0
                        dba: parameter
                        i: 0
                        min: 12345
                        name: param_var
                        r: 1
                        rest: ''
                        s: 0
                      - !!perl/hash:RE_block
                        a: 0
                        context: void
                        dba: parameter
                        i: 0
                        min: 0
                        r: 1
                        s: 0
                        text: ' $quant = ''''; $kind = ''!''; '
                    - !!perl/hash:RE_sequence
                      a: 0
                      alt: parameter_03 1
                      dba: parameter
                      i: 0
                      min: 12345
                      r: 1
                      s: 0
                      zyg:
                      - !!perl/hash:RE_method
                        a: 0
                        dba: parameter
                        i: 0
                        min: 12345
                        name: named_param
                        r: 1
                        rest: ''
                        s: 0
                      - !!perl/hash:RE_block
                        a: 0
                        context: void
                        dba: parameter
                        i: 0
                        min: 0
                        r: 1
                        s: 0
                        text: ' $quant = ''''; $kind = ''*''; '
                - !!perl/hash:RE_bracket
                  decl: []
                  min: 0
                  re: &45 !!perl/hash:RE_any
                    a: 0
                    altname: parameter_04
                    dba: parameter
                    i: 0
                    min: 0
                    name: parameter_04
                    r: 1
                    s: 0
                    zyg:
                    - !!perl/hash:RE_sequence
                      a: 0
                      alt: parameter_04 0
                      dba: parameter
                      i: 0
                      min: 1
                      r: 1
                      s: 0
                      zyg:
                      - !!perl/hash:RE_string
                        a: 0
                        dba: parameter
                        i: 0
                        min: 1
                        r: 1
                        s: 0
                        text: '?'
                      - !!perl/hash:RE_block
                        a: 0
                        context: void
                        dba: parameter
                        i: 0
                        min: 0
                        r: 1
                        s: 0
                        text: ' $quant = ''?''; $kind = ''?'' '
                    - !!perl/hash:RE_sequence
                      a: 0
                      alt: parameter_04 1
                      dba: parameter
                      i: 0
                      min: 1
                      r: 1
                      s: 0
                      zyg:
                      - !!perl/hash:RE_string
                        a: 0
                        dba: parameter
                        i: 0
                        min: 1
                        r: 1
                        s: 0
                        text: '!'
                      - !!perl/hash:RE_block
                        a: 0
                        context: void
                        dba: parameter
                        i: 0
                        min: 0
                        r: 1
                        s: 0
                        text: ' $quant = ''!''; $kind //= ''!'' '
                    - !!perl/hash:RE_assertion
                      alt: parameter_04 2
                      assert: '?'
                      min: 0
                      re: !!perl/hash:RE_noop
                        a: 0
                        dba: parameter
                        i: 0
                        min: 0
                        nobind: 1
                        r: 1
                        s: 0
              - !!perl/hash:RE_sequence
                a: 0
                alt: parameter_02 5
                dba: parameter
                i: 0
                min: 0
                r: 1
                s: 0
                zyg:
                - !!perl/hash:RE_assertion
                  assert: '?'
                  min: 0
                  re: !!perl/hash:RE_noop
                    a: 0
                    dba: parameter
                    i: 0
                    min: 0
                    nobind: 1
                    r: 1
                    s: 0
                - !!perl/hash:RE_block
                  a: 0
                  context: void
                  dba: parameter
                  i: 0
                  min: 0
                  r: 1
                  s: 0
                  text: ' $quant = ''''; $kind = ''!'' '
        - !!perl/hash:RE_sequence
          a: 0
          alt: parameter_01 1
          dba: parameter
          i: 0
          min: 12347
          r: 1
          s: 0
          zyg:
          - !!perl/hash:RE_string
            a: 0
            dba: parameter
            i: 0
            min: 2
            r: 1
            s: 0
            text: '**'
          - !!perl/hash:RE_method
            a: 0
            dba: parameter
            i: 0
            min: 12345
            name: param_var
            r: 1
            rest: ''
            s: 0
          - !!perl/hash:RE_block
            a: 0
            context: void
            dba: parameter
            i: 0
            min: 0
            r: 1
            s: 0
            text: ' $quant = ''**''; $kind = ''*''; '
        - !!perl/hash:RE_sequence
          a: 0
          alt: parameter_01 2
          dba: parameter
          i: 0
          min: 12346
          r: 1
          s: 0
          zyg:
          - !!perl/hash:RE_string
            a: 0
            dba: parameter
            i: 0
            min: 1
            r: 1
            s: 0
            text: '*'
          - !!perl/hash:RE_method
            a: 0
            dba: parameter
            i: 0
            min: 12345
            name: param_var
            r: 1
            rest: ''
            s: 0
          - !!perl/hash:RE_block
            a: 0
            context: void
            dba: parameter
            i: 0
            min: 0
            r: 1
            s: 0
            text: ' $quant = ''*''; $kind = ''*''; '
        - !!perl/hash:RE_sequence
          a: 0
          alt: parameter_01 3
          dba: parameter
          i: 0
          min: 12346
          r: 1
          s: 0
          zyg:
          - !!perl/hash:RE_string
            a: 0
            dba: parameter
            i: 0
            min: 1
            r: 1
            s: 0
            text: '|'
          - !!perl/hash:RE_method
            a: 0
            dba: parameter
            i: 0
            min: 12345
            name: param_var
            r: 1
            rest: ''
            s: 0
          - !!perl/hash:RE_block
            a: 0
            context: void
            dba: parameter
            i: 0
            min: 0
            r: 1
            s: 0
            text: ' $quant = ''|''; $kind = ''*''; '
        - !!perl/hash:RE_sequence
          a: 0
          alt: parameter_01 4
          dba: parameter
          i: 0
          min: 12346
          r: 1
          s: 0
          zyg:
          - !!perl/hash:RE_string
            a: 0
            dba: parameter
            i: 0
            min: 1
            r: 1
            s: 0
            text: \
          - !!perl/hash:RE_method
            a: 0
            dba: parameter
            i: 0
            min: 12345
            name: param_var
            r: 1
            rest: ''
            s: 0
          - !!perl/hash:RE_block
            a: 0
            context: void
            dba: parameter
            i: 0
            min: 0
            r: 1
            s: 0
            text: ' $quant = ''\\''; $kind = ''!''; '
        - !!perl/hash:RE_sequence
          a: 0
          alt: parameter_01 5
          dba: parameter
          i: 0
          min: 12345
          r: 1
          s: 0
          zyg:
          - !!perl/hash:RE_bracket
            decl: []
            min: 12345
            re: &46 !!perl/hash:RE_any
              a: 0
              altname: parameter_05
              dba: parameter
              i: 0
              min: 12345
              name: parameter_05
              r: 1
              s: 0
              zyg:
              - !!perl/hash:RE_sequence
                a: 0
                alt: parameter_05 0
                dba: parameter
                i: 0
                min: 12345
                r: 1
                s: 0
                zyg:
                - !!perl/hash:RE_method
                  a: 0
                  dba: parameter
                  i: 0
                  min: 12345
                  name: param_var
                  r: 1
                  rest: ''
                  s: 0
                - !!perl/hash:RE_block
                  a: 0
                  context: void
                  dba: parameter
                  i: 0
                  min: 0
                  r: 1
                  s: 0
                  text: ' $quant = ''''; $kind = ''!''; '
              - !!perl/hash:RE_sequence
                a: 0
                alt: parameter_05 1
                dba: parameter
                i: 0
                min: 12345
                r: 1
                s: 0
                zyg:
                - !!perl/hash:RE_method
                  a: 0
                  dba: parameter
                  i: 0
                  min: 12345
                  name: named_param
                  r: 1
                  rest: ''
                  s: 0
                - !!perl/hash:RE_block
                  a: 0
                  context: void
                  dba: parameter
                  i: 0
                  min: 0
                  r: 1
                  s: 0
                  text: ' $quant = ''''; $kind = ''*''; '
          - !!perl/hash:RE_bracket
            decl: []
            min: 0
            re: &47 !!perl/hash:RE_any
              a: 0
              altname: parameter_06
              dba: parameter
              i: 0
              min: 0
              name: parameter_06
              r: 1
              s: 0
              zyg:
              - !!perl/hash:RE_sequence
                a: 0
                alt: parameter_06 0
                dba: parameter
                i: 0
                min: 1
                r: 1
                s: 0
                zyg:
                - !!perl/hash:RE_string
                  a: 0
                  dba: parameter
                  i: 0
                  min: 1
                  r: 1
                  s: 0
                  text: '?'
                - !!perl/hash:RE_block
                  a: 0
                  context: void
                  dba: parameter
                  i: 0
                  min: 0
                  r: 1
                  s: 0
                  text: ' $quant = ''?''; $kind = ''?'' '
              - !!perl/hash:RE_sequence
                a: 0
                alt: parameter_06 1
                dba: parameter
                i: 0
                min: 1
                r: 1
                s: 0
                zyg:
                - !!perl/hash:RE_string
                  a: 0
                  dba: parameter
                  i: 0
                  min: 1
                  r: 1
                  s: 0
                  text: '!'
                - !!perl/hash:RE_block
                  a: 0
                  context: void
                  dba: parameter
                  i: 0
                  min: 0
                  r: 1
                  s: 0
                  text: ' $quant = ''!''; $kind //= ''!'' '
              - !!perl/hash:RE_assertion
                alt: parameter_06 2
                assert: '?'
                min: 0
                re: !!perl/hash:RE_noop
                  a: 0
                  dba: parameter
                  i: 0
                  min: 0
                  nobind: 1
                  r: 1
                  s: 0
        - !!perl/hash:RE_sequence
          a: 0
          alt: parameter_01 6
          dba: parameter
          i: 0
          min: 12345
          r: 1
          s: 0
          zyg:
          - !!perl/hash:RE_block
            a: 0
            context: void
            dba: parameter
            i: 0
            min: 0
            r: 1
            s: 0
            text: ''
          - !!perl/hash:RE_method
            a: 0
            dba: parameter
            i: 0
            min: 12345
            name: longname
            r: 1
            rest: ''
            s: 0
          - !!perl/hash:RE_method
            min: 0
            name: panic
            nobind: 1
            rest: '("In parameter declaration, typename ''" ~ $<longname>.Str ~ "''
              must be predeclared (or marked as declarative with :: prefix)")'
    - !!perl/hash:RE_quantified_atom
      atom: !!perl/hash:RE_method
        a: 0
        dba: parameter
        i: 0
        min: 12345
        name: trait
        r: 1
        rest: ''
        s: 0
      min: 0
      quant:
      - '*'
      - ':'
      - ''
      - 0
    - !!perl/hash:RE_quantified_atom
      atom: !!perl/hash:RE_method
        a: 0
        dba: parameter
        i: 0
        min: 12345
        name: post_constraint
        r: 1
        rest: ''
        s: 0
      min: 0
      quant:
      - '*'
      - ':'
      - ''
      - 0
    - !!perl/hash:RE_method
      a: 0
      dba: parameter
      i: 0
      min: 12345
      name: getdecl
      nobind: 1
      r: 1
      rest: ''
      s: 0
    - !!perl/hash:RE_quantified_atom
      atom: !!perl/hash:RE_bracket
        decl: []
        min: 12345
        re: !!perl/hash:RE_sequence
          a: 0
          dba: parameter
          i: 0
          min: 12345
          r: 1
          s: 0
          zyg:
          - !!perl/hash:RE_method
            a: 0
            dba: parameter
            i: 0
            min: 12345
            name: default_value
            r: 1
            rest: ''
            s: 0
          - !!perl/hash:RE_block
            a: 0
            context: void
            dba: parameter
            i: 0
            min: 0
            r: 1
            s: 0
            text: "\n                given $quant {\n                  when '!' {
              $.panic(\"Can't put a default on a required parameter\") }\n                  when
              '*' { $.panic(\"Can't put a default on a slurpy parameter\") }\n                  when
              '**' { $.panic(\"Can't put a default on a slice parameter\") }\n                  when
              '|' { $.panic(\"Can't put a default on an slurpy capture parameter\")
              }\n                  when '\\\\' { $.panic(\"Can't put a default on
              a capture parameter\") }\n                }\n                $kind =
              '?' if $kind eq '!';\n            "
          - !!perl/hash:RE_quantified_atom
            atom: !!perl/hash:RE_bracket
              decl: []
              min: 0
              re: !!perl/hash:RE_sequence
                a: 0
                dba: parameter
                i: 0
                min: 0
                r: 1
                s: 0
                zyg:
                - !!perl/hash:RE_assertion
                  assert: '?'
                  min: 0
                  re: !!perl/hash:RE_method_re
                    a: 0
                    dba: parameter
                    i: 0
                    min: 0
                    name: before
                    nobind: 1
                    r: 1
                    re: !!perl/hash:RE_ast
                      decl: []
                      min: 1
                      re: !!perl/hash:RE_string
                        a: 0
                        dba: parameter
                        i: 0
                        min: 1
                        r: 1
                        s: 0
                        text: ':'
                    s: 0
                - !!perl/hash:RE_method
                  min: 0
                  name: panic
                  nobind: 1
                  rest: ("Can't put a default on the invocant parameter")
            min: 0
            quant:
            - '?'
            - ':'
            - ''
            - 0
          - !!perl/hash:RE_quantified_atom
            atom: !!perl/hash:RE_bracket
              decl: []
              min: 0
              re: !!perl/hash:RE_sequence
                a: 0
                dba: parameter
                i: 0
                min: 0
                r: 1
                s: 0
                zyg:
                - !!perl/hash:RE_assertion
                  assert: '!'
                  min: 0
                  re: !!perl/hash:RE_method_re
                    a: 0
                    dba: parameter
                    i: 0
                    min: 0
                    name: before
                    nobind: 1
                    r: 1
                    re: !!perl/hash:RE_ast
                      decl: []
                      min: 1
                      re: !!perl/hash:RE_cclass
                        a: 0
                        dba: parameter
                        i: 0
                        min: 1
                        r: 1
                        s: 0
                        text: '[,;)\]\{\-]'
                    s: 0
                - !!perl/hash:RE_method
                  min: 0
                  name: panic
                  nobind: 1
                  rest: ("Default expression must come last")
            min: 0
            quant:
            - '?'
            - ':'
            - ''
            - 0
      min: 0
      quant:
      - '?'
      - ':'
      - ''
      - 0
    - !!perl/hash:RE_quantified_atom
      atom: !!perl/hash:RE_bracket
        decl: []
        min: 0
        re: !!perl/hash:RE_sequence
          a: 0
          dba: parameter
          i: 0
          min: 0
          r: 1
          s: 0
          zyg:
          - !!perl/hash:RE_assertion
            assert: '?'
            min: 0
            re: !!perl/hash:RE_method_re
              a: 0
              dba: parameter
              i: 0
              min: 0
              name: before
              nobind: 1
              r: 1
              re: !!perl/hash:RE_ast
                decl: []
                min: 1
                re: !!perl/hash:RE_string
                  a: 0
                  dba: parameter
                  i: 0
                  min: 1
                  r: 1
                  s: 0
                  text: ':'
              s: 0
          - !!perl/hash:RE_assertion
            assert: '?'
            min: 0
            re: !!perl/hash:RE_block
              a: 0
              context: bool
              dba: parameter
              i: 0
              min: 0
              nobind: 1
              r: 1
              s: 0
              text: ' $kind ne ''!'' '
          - !!perl/hash:RE_method
            min: 0
            name: panic
            nobind: 1
            rest: ("Invocant is too exotic")
      min: 0
      quant:
      - '?'
      - ':'
      - ''
      - 0
    - !!perl/hash:RE_block
      a: 0
      context: void
      dba: parameter
      i: 0
      min: 0
      r: 1
      s: 0
      text: "\n            $<quant> = $quant;\n            $<kind> = $kind;\n        "
    - !!perl/hash:RE_block
      a: 0
      context: void
      dba: parameter
      i: 0
      min: 0
      r: 1
      s: 0
      text: "\n            given $kind {\n                when '!' {\n                    given
        $*zone {\n                        when 'posopt' {\n    $.panic(\"Can't put
        required parameter after optional parameters\");\n                        }\n
        \                       when 'var' {\n    $.panic(\"Can't put required parameter
        after variadic parameters\");\n                        }\n                    }\n
        \               }\n                when '?' {\n                    given $*zone
        {\n                        when 'posreq' { $*zone = 'posopt' }\n                        when
        'var' {\n    $.panic(\"Can't put optional positional parameter after variadic
        parameters\");\n                        }\n                    }\n                }\n
        \               when '*' {\n                    $*zone = 'var';\n                }\n
        \           }\n        "
parameter_01: *42
parameter_02: *43
parameter_03: *44
parameter_04: *45
parameter_05: *46
parameter_06: *47
pblock: !!perl/hash:RE_ast
  decl:
  - !!perl/hash:RE_decl
    a: 0
    dba: pblock
    i: 0
    max: 0
    min: 0
    r: 1
    s: 0
    text: temp $*CURPAD
  kind: token
  min: 24690
  pkg: ~
  re: !!perl/hash:RE_sequence
    a: 0
    dba: parameterized block
    i: 0
    min: 24690
    r: 1
    s: 0
    zyg:
    - !!perl/hash:RE_bracket
      decl: []
      min: 0
      re: !!perl/hash:RE_first
        a: 0
        dba: parameterized block
        i: 0
        min: 0
        r: 1
        s: 0
        zyg:
        - !!perl/hash:RE_assertion
          assert: '?'
          min: 0
          re: !!perl/hash:RE_method_re
            a: 0
            dba: parameterized block
            i: 0
            min: 0
            name: before
            nobind: 1
            r: 1
            re: !!perl/hash:RE_ast
              decl: []
              min: 1
              re: &48 !!perl/hash:RE_any
                a: 0
                altname: pblock_02
                dba: parameterized block
                i: 0
                min: 1
                name: pblock_02
                r: 1
                s: 0
                zyg:
                - !!perl/hash:RE_method
                  a: 0
                  alt: pblock_02 0
                  dba: parameterized block
                  i: 0
                  min: 12345
                  name: lambda
                  nobind: 1
                  r: 1
                  rest: ''
                  s: 0
                - !!perl/hash:RE_string
                  a: 0
                  alt: pblock_02 1
                  dba: parameterized block
                  i: 0
                  min: 1
                  r: 1
                  s: 0
                  text: '{'
            s: 0
        - !!perl/hash:RE_block
          a: 0
          context: void
          dba: parameterized block
          i: 0
          min: 0
          r: 1
          s: 0
          text: "\n                if $*BORG and $*BORG.<block> {\n                    if
            $*BORG.<name> {\n                        my $m = \"Function '\" ~ $*BORG.<name>
            ~ \"' needs parens to avoid gobbling block\" ~ $*BORG.<culprit>.locmess;\n
            \                       $*BORG.<block>.panic($m ~ \"\\nMissing block (apparently
            gobbled by '\" ~ $*BORG.<name> ~ \"')\");\n                    }\n                    else
            {\n                        my $m = \"Expression needs parens to avoid
            gobbling block\" ~ $*BORG.<culprit>.locmess;\n                        $*BORG.<block>.panic($m
            ~ \"\\nMissing block (apparently gobbled by expression)\");\n                    }\n
            \               }\n                elsif %*MYSTERY {\n                    $.panic(\"Missing
            block (apparently gobbled by undeclared routine?)\");\n                }\n
            \               else {\n                    $.panic(\"Missing block\");\n
            \               }\n            "
    - !!perl/hash:RE_bracket
      decl: []
      min: 24690
      re: &49 !!perl/hash:RE_any
        a: 0
        altname: pblock_04
        dba: parameterized block
        i: 0
        min: 24690
        name: pblock_04
        r: 1
        s: 0
        zyg:
        - !!perl/hash:RE_sequence
          a: 0
          alt: pblock_04 0
          dba: parameterized block
          i: 0
          min: 37035
          r: 1
          s: 0
          zyg:
          - !!perl/hash:RE_method
            a: 0
            dba: parameterized block
            i: 0
            min: 12345
            name: lambda
            r: 1
            rest: ''
            s: 0
          - !!perl/hash:RE_method
            min: 0
            name: newpad
            nobind: 1
            rest: (1)
          - !!perl/hash:RE_method
            min: 0
            name: signature
            rest: (1)
          - !!perl/hash:RE_method
            a: 0
            dba: parameterized block
            i: 0
            min: 12345
            name: blockoid
            r: 1
            rest: ''
            s: 0
          - !!perl/hash:RE_method
            a: 0
            dba: parameterized block
            i: 0
            min: 12345
            name: getsig
            nobind: 1
            r: 1
            rest: ''
            s: 0
        - !!perl/hash:RE_sequence
          a: 0
          alt: pblock_04 1
          dba: parameterized block
          i: 0
          min: 24690
          r: 1
          s: 0
          zyg:
          - !!perl/hash:RE_assertion
            assert: '?'
            min: 0
            re: !!perl/hash:RE_method_re
              a: 0
              dba: parameterized block
              i: 0
              min: 0
              name: before
              nobind: 1
              r: 1
              re: !!perl/hash:RE_ast
                decl: []
                min: 1
                re: !!perl/hash:RE_string
                  a: 0
                  dba: parameterized block
                  i: 0
                  min: 1
                  r: 1
                  s: 0
                  text: '{'
              s: 0
          - !!perl/hash:RE_method
            min: 0
            name: newpad
            nobind: 1
            rest: (1)
          - !!perl/hash:RE_method
            a: 0
            dba: parameterized block
            i: 0
            min: 12345
            name: blockoid
            r: 1
            rest: ''
            s: 0
          - !!perl/hash:RE_method
            a: 0
            dba: parameterized block
            i: 0
            min: 12345
            name: getsig
            nobind: 1
            r: 1
            rest: ''
            s: 0
pblock_02: *48
pblock_04: *49
post_constraint: !!perl/hash:RE_ast
  decl:
  - !!perl/hash:RE_decl
    a: 0
    dba: post_constraint
    i: 0
    max: 0
    min: 0
    r: 1
    s: 1
    text: my $*IN_DECL = ''
  kind: rule
  min: 5
  pkg: ~
  re: !!perl/hash:RE_sequence
    a: 0
    dba: constraint
    i: 0
    min: 5
    r: 1
    s: 1
    zyg:
    - !!perl/hash:RE_method
      min: 0
      name: ws
      nobind: 1
      noquant: 1
      rest: ''
    - !!perl/hash:RE_method
      min: 0
      name: ws
      nobind: 1
      noquant: 1
      rest: ''
    - !!perl/hash:RE_bracket
      decl: []
      min: 5
      re: &50 !!perl/hash:RE_any
        a: 0
        altname: post_constraint_01
        dba: constraint
        i: 0
        min: 5
        name: post_constraint_01
        r: 1
        s: 1
        zyg:
        - !!perl/hash:RE_sequence
          a: 0
          alt: post_constraint_01 0
          dba: constraint
          i: 0
          min: 12347
          r: 1
          s: 1
          zyg:
          - !!perl/hash:RE_string
            a: 0
            dba: constraint
            i: 0
            min: 1
            r: 1
            s: 1
            text: '['
          - !!perl/hash:RE_method
            min: 0
            name: ws
            nobind: 1
            noquant: 1
            rest: ''
          - !!perl/hash:RE_meta
            a: 0
            dba: constraint
            extra: local $::GOAL = ']'
            i: 0
            min: 0
            r: 1
            s: 1
            text: ':'
          - !!perl/hash:RE_method
            a: 0
            dba: constraint
            i: 0
            min: 12345
            name: signature
            r: 1
            rest: ''
            s: 1
          - !!perl/hash:RE_bracket
            decl: []
            min: 1
            re: !!perl/hash:RE_first
              a: 0
              dba: constraint
              i: 0
              min: 1
              r: 1
              s: 1
              zyg:
              - !!perl/hash:RE_string
                a: 0
                dba: constraint
                i: 0
                min: 1
                r: 1
                s: 1
                text: ']'
              - !!perl/hash:RE_method
                min: 0
                name: FAILGOAL
                nobind: 1
                rest: (']', 'constraint')
          - !!perl/hash:RE_method
            min: 0
            name: ws
            nobind: 1
            noquant: 1
            rest: ''
        - !!perl/hash:RE_sequence
          a: 0
          alt: post_constraint_01 1
          dba: constraint
          i: 0
          min: 12347
          r: 1
          s: 1
          zyg:
          - !!perl/hash:RE_string
            a: 0
            dba: constraint
            i: 0
            min: 1
            r: 1
            s: 1
            text: (
          - !!perl/hash:RE_method
            min: 0
            name: ws
            nobind: 1
            noquant: 1
            rest: ''
          - !!perl/hash:RE_meta
            a: 0
            dba: constraint
            extra: local $::GOAL = ')'
            i: 0
            min: 0
            r: 1
            s: 1
            text: ':'
          - !!perl/hash:RE_method
            a: 0
            dba: constraint
            i: 0
            min: 12345
            name: signature
            r: 1
            rest: ''
            s: 1
          - !!perl/hash:RE_bracket
            decl: []
            min: 1
            re: !!perl/hash:RE_first
              a: 0
              dba: constraint
              i: 0
              min: 1
              r: 1
              s: 1
              zyg:
              - !!perl/hash:RE_string
                a: 0
                dba: constraint
                i: 0
                min: 1
                r: 1
                s: 1
                text: )
              - !!perl/hash:RE_method
                min: 0
                name: FAILGOAL
                nobind: 1
                rest: (')', 'constraint')
          - !!perl/hash:RE_method
            min: 0
            name: ws
            nobind: 1
            noquant: 1
            rest: ''
        - !!perl/hash:RE_sequence
          a: 0
          alt: post_constraint_01 2
          dba: constraint
          i: 0
          min: 5
          r: 1
          s: 1
          zyg:
          - !!perl/hash:RE_string
            a: 0
            dba: constraint
            i: 0
            min: 5
            r: 1
            s: 1
            text: where
          - !!perl/hash:RE_method
            min: 0
            name: ws
            nobind: 1
            noquant: 1
            rest: ''
          - !!perl/hash:RE_method
            min: 0
            name: EXPR
            rest: (item %chaining)
          - !!perl/hash:RE_method
            min: 0
            name: ws
            nobind: 1
            noquant: 1
            rest: ''
    - !!perl/hash:RE_method
      min: 0
      name: ws
      nobind: 1
      noquant: 1
      rest: ''
post_constraint_01: *50
postcircumfix__S_268Paren_Thesis: !!perl/hash:RE_ast
  decl: []
  kind: token
  min: 12347
  pkg: ~
  re: !!perl/hash:RE_sequence
    a: 0
    dba: argument list
    i: 0
    min: 12347
    r: 1
    s: 0
    zyg:
    - !!perl/hash:RE_string
      a: 0
      dba: argument list
      i: 0
      min: 1
      r: 1
      s: 0
      text: (
    - !!perl/hash:RE_meta
      a: 0
      dba: argument list
      extra: 'local $::GOAL = '')'' '
      i: 0
      min: 0
      r: 1
      s: 0
      text: ':'
    - !!perl/hash:RE_method
      a: 0
      dba: argument list
      i: 0
      min: 12345
      name: semiarglist
      r: 1
      rest: ''
      s: 0
    - !!perl/hash:RE_bracket
      decl: []
      min: 1
      re: !!perl/hash:RE_first
        a: 0
        dba: argument list
        i: 0
        min: 1
        r: 1
        s: 0
        zyg:
        - !!perl/hash:RE_string
          a: 0
          dba: argument list
          i: 0
          min: 1
          r: 1
          s: 0
          text: )
        - !!perl/hash:RE_method
          min: 0
          name: FAILGOAL
          nobind: 1
          rest: (')' , 'argument list')
    - !!perl/hash:RE_method
      min: 0
      name: O
      rest: (|%methodcall)
postcircumfix__S_269Bra_Ket: !!perl/hash:RE_ast
  decl: []
  kind: token
  min: 12347
  pkg: ~
  re: !!perl/hash:RE_sequence
    a: 0
    dba: subscript
    i: 0
    min: 12347
    r: 1
    s: 0
    zyg:
    - !!perl/hash:RE_string
      a: 0
      dba: subscript
      i: 0
      min: 1
      r: 1
      s: 0
      text: '['
    - !!perl/hash:RE_meta
      a: 0
      dba: subscript
      extra: 'local $::GOAL = '']'' '
      i: 0
      min: 0
      r: 1
      s: 0
      text: ':'
    - !!perl/hash:RE_method
      a: 0
      dba: subscript
      i: 0
      min: 12345
      name: semilist
      r: 1
      rest: ''
      s: 0
    - !!perl/hash:RE_bracket
      decl: []
      min: 1
      re: !!perl/hash:RE_first
        a: 0
        dba: subscript
        i: 0
        min: 1
        r: 1
        s: 0
        zyg:
        - !!perl/hash:RE_string
          a: 0
          dba: subscript
          i: 0
          min: 1
          r: 1
          s: 0
          text: ']'
        - !!perl/hash:RE_method
          min: 0
          name: FAILGOAL
          nobind: 1
          rest: (']' , 'subscript')
    - !!perl/hash:RE_block
      a: 0
      context: void
      dba: subscript
      i: 0
      min: 0
      r: 1
      s: 0
      text: ' $<semilist>.Str ~~ /^\s*\-[1]\s*$/ and $.obs("[-1] subscript to access
        final element","[*-1]") '
    - !!perl/hash:RE_method
      min: 0
      name: O
      rest: (|%methodcall)
postcircumfix__S_270Cur_Ly: !!perl/hash:RE_ast
  decl: []
  kind: token
  min: 24692
  pkg: ~
  re: !!perl/hash:RE_sequence
    a: 0
    dba: subscript
    i: 0
    min: 24692
    r: 1
    s: 0
    zyg:
    - !!perl/hash:RE_string
      a: 0
      dba: subscript
      i: 0
      min: 1
      r: 1
      s: 0
      text: '{'
    - !!perl/hash:RE_meta
      a: 0
      dba: subscript
      extra: 'local $::GOAL = ''}'' '
      i: 0
      min: 0
      r: 1
      s: 0
      text: ':'
    - !!perl/hash:RE_method
      a: 0
      dba: subscript
      i: 0
      min: 12345
      name: semilist
      r: 1
      rest: ''
      s: 0
    - !!perl/hash:RE_bracket
      decl: []
      min: 1
      re: !!perl/hash:RE_first
        a: 0
        dba: subscript
        i: 0
        min: 1
        r: 1
        s: 0
        zyg:
        - !!perl/hash:RE_string
          a: 0
          dba: subscript
          i: 0
          min: 1
          r: 1
          s: 0
          text: '}'
        - !!perl/hash:RE_method
          min: 0
          name: FAILGOAL
          nobind: 1
          rest: ('}' , 'subscript')
    - !!perl/hash:RE_method
      min: 0
      name: O
      rest: (|%methodcall)
    - !!perl/hash:RE_method
      a: 0
      dba: subscript
      i: 0
      min: 12345
      name: curlycheck
      nobind: 1
      r: 1
      rest: ''
      s: 0
postcircumfix__S_271Lt_Gt: !!perl/hash:RE_ast
  decl:
  - !!perl/hash:RE_decl
    a: 0
    dba: postcircumfix__S_271Lt_Gt
    i: 0
    max: 0
    min: 0
    r: 1
    s: 0
    text: my $pos
  kind: token
  min: 1
  pkg: ~
  re: !!perl/hash:RE_sequence
    a: 0
    dba: postcircumfix__S_271Lt_Gt
    i: 0
    min: 1
    r: 1
    s: 0
    zyg:
    - !!perl/hash:RE_string
      a: 0
      dba: postcircumfix__S_271Lt_Gt
      i: 0
      min: 1
      r: 1
      s: 0
      text: <
    - !!perl/hash:RE_block
      a: 0
      context: void
      dba: postcircumfix__S_271Lt_Gt
      i: 0
      min: 0
      r: 1
      s: 0
      text: ' $pos = $.pos '
    - !!perl/hash:RE_bracket
      decl: []
      min: 0
      re: !!perl/hash:RE_first
        a: 0
        dba: postcircumfix__S_271Lt_Gt
        i: 0
        min: 0
        r: 1
        s: 0
        zyg:
        - !!perl/hash:RE_sequence
          a: 0
          dba: postcircumfix__S_271Lt_Gt
          i: 0
          min: 1
          r: 1
          s: 0
          zyg:
          - !!perl/hash:RE_method
            min: 0
            name: nibble
            rest: ($.cursor_fresh( %*LANG<Q> ).tweak(:q).tweak(:w).balanced('<','>'))
          - !!perl/hash:RE_string
            a: 0
            dba: postcircumfix__S_271Lt_Gt
            i: 0
            min: 1
            r: 1
            s: 0
            text: '>'
        - !!perl/hash:RE_sequence
          a: 0
          dba: postcircumfix__S_271Lt_Gt
          i: 0
          min: 0
          r: 1
          s: 0
          zyg:
          - !!perl/hash:RE_assertion
            assert: '?'
            min: 0
            re: !!perl/hash:RE_method_re
              a: 0
              dba: postcircumfix__S_271Lt_Gt
              i: 0
              min: 0
              name: before
              nobind: 1
              r: 1
              re: !!perl/hash:RE_ast
                decl: []
                min: 1
                re: !!perl/hash:RE_sequence
                  a: 0
                  dba: postcircumfix__S_271Lt_Gt
                  i: 0
                  min: 1
                  r: 1
                  s: 0
                  zyg:
                  - !!perl/hash:RE_quantified_atom
                    atom: !!perl/hash:RE_meta
                      a: 0
                      dba: postcircumfix__S_271Lt_Gt
                      i: 0
                      min: 1
                      r: 1
                      s: 0
                      text: \h
                    min: 0
                    quant:
                    - '*'
                    - ':'
                    - ''
                    - 0
                  - !!perl/hash:RE_bracket
                    decl: []
                    min: 1
                    re: &51 !!perl/hash:RE_any
                      a: 0
                      altname: postcircumfix__S_271Lt_Gt_04
                      dba: postcircumfix__S_271Lt_Gt
                      i: 0
                      min: 1
                      name: postcircumfix__S_271Lt_Gt_04
                      r: 1
                      s: 0
                      zyg:
                      - !!perl/hash:RE_meta
                        a: 0
                        alt: postcircumfix__S_271Lt_Gt_04 0
                        dba: postcircumfix__S_271Lt_Gt
                        i: 0
                        min: 1
                        r: 1
                        s: 0
                        text: \d
                      - !!perl/hash:RE_method
                        a: 0
                        alt: postcircumfix__S_271Lt_Gt_04 1
                        dba: postcircumfix__S_271Lt_Gt
                        i: 0
                        min: 12345
                        name: sigil
                        r: 1
                        rest: ''
                        s: 0
                      - !!perl/hash:RE_string
                        a: 0
                        alt: postcircumfix__S_271Lt_Gt_04 2
                        dba: postcircumfix__S_271Lt_Gt
                        i: 0
                        min: 1
                        r: 1
                        s: 0
                        text: ':'
              s: 0
          - !!perl/hash:RE_block
            a: 0
            context: void
            dba: postcircumfix__S_271Lt_Gt
            i: 0
            min: 0
            r: 1
            s: 0
            text: ' $.cursor_force($pos).panic("Whitespace required before < operator") '
        - !!perl/hash:RE_block
          a: 0
          context: void
          dba: postcircumfix__S_271Lt_Gt
          i: 0
          min: 0
          r: 1
          s: 0
          text: ' $.cursor_force($pos).panic("Unable to parse quote-words subscript;
            couldn''t find right angle quote") '
    - !!perl/hash:RE_method
      min: 0
      name: O
      rest: (|%methodcall)
postcircumfix__S_271Lt_Gt_04: *51
postcircumfix__S_272LtLt_GtGt: !!perl/hash:RE_ast
  decl: []
  kind: token
  min: 2
  pkg: ~
  re: !!perl/hash:RE_sequence
    a: 0
    dba: postcircumfix__S_272LtLt_GtGt
    i: 0
    min: 2
    r: 1
    s: 0
    zyg:
    - !!perl/hash:RE_string
      a: 0
      dba: postcircumfix__S_272LtLt_GtGt
      i: 0
      min: 2
      r: 1
      s: 0
      text: <<
    - !!perl/hash:RE_method
      min: 0
      name: nibble
      rest: ($.cursor_fresh( %*LANG<Q> ).tweak(:qq).tweak(:ww).balanced('<<','>>'))
    - !!perl/hash:RE_bracket
      decl: []
      min: 0
      re: !!perl/hash:RE_first
        a: 0
        dba: postcircumfix__S_272LtLt_GtGt
        i: 0
        min: 0
        r: 1
        s: 0
        zyg:
        - !!perl/hash:RE_string
          a: 0
          dba: postcircumfix__S_272LtLt_GtGt
          i: 0
          min: 2
          r: 1
          s: 0
          text: '>>'
        - !!perl/hash:RE_method
          min: 0
          name: panic
          nobind: 1
          rest: ("Unable to parse quote-words subscript; couldn't find right double-angle
            quote")
    - !!perl/hash:RE_method
      min: 0
      name: O
      rest: (|%methodcall)
postcircumfix__S_273Fre_Nch: !!perl/hash:RE_ast
  decl: []
  kind: token
  min: 1
  pkg: ~
  re: !!perl/hash:RE_sequence
    a: 0
    dba: postcircumfix__S_273Fre_Nch
    i: 0
    min: 1
    r: 1
    s: 0
    zyg:
    - !!perl/hash:RE_string
      a: 0
      dba: postcircumfix__S_273Fre_Nch
      i: 0
      min: 1
      r: 1
      s: 0
      text: 
    - !!perl/hash:RE_method
      min: 0
      name: nibble
      rest: ($.cursor_fresh( %*LANG<Q> ).tweak(:qq).tweak(:ww).balanced('',''))
    - !!perl/hash:RE_bracket
      decl: []
      min: 0
      re: !!perl/hash:RE_first
        a: 0
        dba: postcircumfix__S_273Fre_Nch
        i: 0
        min: 0
        r: 1
        s: 0
        zyg:
        - !!perl/hash:RE_string
          a: 0
          dba: postcircumfix__S_273Fre_Nch
          i: 0
          min: 1
          r: 1
          s: 0
          text: 
        - !!perl/hash:RE_method
          min: 0
          name: panic
          nobind: 1
          rest: ("Unable to parse quote-words subscript; couldn't find right double-angle
            quote")
    - !!perl/hash:RE_method
      min: 0
      name: O
      rest: (|%methodcall)
postfix__S_276i: !!perl/hash:RE_ast
  decl: []
  kind: token
  min: 12345
  pkg: ~
  re: !!perl/hash:RE_sequence
    a: 0
    dba: postfix__S_276i
    i: 0
    min: 12345
    r: 1
    s: 0
    zyg:
    - !!perl/hash:RE_method
      a: 0
      dba: postfix__S_276i
      i: 0
      min: 12345
      name: sym
      r: 1
      rest: ''
      s: 0
      sym: i
    - !!perl/hash:RE_meta
      a: 0
      dba: postfix__S_276i
      i: 0
      min: 0
      r: 1
      s: 0
      text: 
    - !!perl/hash:RE_method
      min: 0
      name: O
      rest: (|%methodcall)
postfix__S_278MinusGt: !!perl/hash:RE_ast
  decl: []
  kind: token
  min: 2
  pkg: ~
  re: !!perl/hash:RE_sequence
    a: 0
    dba: postfix__S_278MinusGt
    i: 0
    min: 2
    r: 1
    s: 0
    zyg:
    - !!perl/hash:RE_string
      a: 0
      dba: postfix__S_278MinusGt
      i: 0
      min: 2
      r: 1
      s: 0
      text: ->
    - !!perl/hash:RE_bracket
      decl: []
      min: 0
      re: &52 !!perl/hash:RE_any
        a: 0
        altname: postfix__S_278MinusGt_01
        dba: postfix__S_278MinusGt
        i: 0
        min: 0
        name: postfix__S_278MinusGt_01
        r: 1
        s: 0
        zyg:
        - !!perl/hash:RE_sequence
          a: 0
          alt: postfix__S_278MinusGt_01 0
          dba: postfix__S_278MinusGt
          i: 0
          min: 1
          r: 1
          s: 0
          zyg:
          - !!perl/hash:RE_bindnamed
            a: 0
            atom: !!perl/hash:RE_cclass
              a: 0
              dba: postfix__S_278MinusGt
              i: 0
              min: 1
              r: 1
              s: 0
              text: '[ \[ \{ \( ]'
            dba: postfix__S_278MinusGt
            i: 0
            min: 1
            r: 1
            s: 0
            var: brack
          - !!perl/hash:RE_method
            min: 0
            name: obs
            nobind: 1
            rest: ("'->" ~ $<brack>.Str ~ "' as postfix dereferencer", "'." ~ $<brack>.Str
              ~ "' or just '" ~ $<brack>.Str ~ "' to deref, or whitespace to delimit
              a pointy block")
        - !!perl/hash:RE_method
          alt: postfix__S_278MinusGt_01 1
          min: 0
          name: obs
          nobind: 1
          rest: ('-> as postfix', 'either . to call a method, or whitespace to delimit
            a pointy block')
postfix__S_278MinusGt_01: *52
postfix__S_279PlusPlus: !!perl/hash:RE_ast
  decl: []
  kind: token
  min: 12345
  pkg: ~
  re: !!perl/hash:RE_sequence
    a: 0
    dba: postfix__S_279PlusPlus
    i: 0
    min: 12345
    r: 1
    s: 0
    zyg:
    - !!perl/hash:RE_method
      a: 0
      dba: postfix__S_279PlusPlus
      i: 0
      min: 12345
      name: sym
      r: 1
      rest: ''
      s: 0
      sym: ++
    - !!perl/hash:RE_method
      min: 0
      name: O
      rest: (|%autoincrement)
postfix__S_280MinusMinus: !!perl/hash:RE_ast
  decl: []
  kind: token
  min: 12345
  pkg: ~
  re: !!perl/hash:RE_sequence
    a: 0
    dba: postfix__S_280MinusMinus
    i: 0
    min: 12345
    r: 1
    s: 0
    zyg:
    - !!perl/hash:RE_method
      a: 0
      dba: postfix__S_280MinusMinus
      i: 0
      min: 12345
      name: sym
      r: 1
      rest: ''
      s: 0
      sym: --
    - !!perl/hash:RE_method
      min: 0
      name: O
      rest: (|%autoincrement)
postfix_prefix_meta_operator__S_259Nch: !!perl/hash:RE_ast
  decl: []
  kind: token
  min: 2
  pkg: ~
  re: !!perl/hash:RE_sequence
    a: 0
    dba: postfix_prefix_meta_operator__S_259Nch
    i: 0
    min: 2
    r: 1
    s: 0
    zyg:
    - !!perl/hash:RE_bracket
      decl: []
      min: 2
      re: &53 !!perl/hash:RE_any
        a: 0
        altname: postfix_prefix_meta_operator__S_259Nch_01
        dba: postfix_prefix_meta_operator__S_259Nch
        i: 0
        min: 2
        name: postfix_prefix_meta_operator__S_259Nch_01
        r: 1
        s: 0
        zyg:
        - !!perl/hash:RE_method
          a: 0
          alt: postfix_prefix_meta_operator__S_259Nch_01 0
          dba: postfix_prefix_meta_operator__S_259Nch
          i: 0
          min: 12345
          name: sym
          r: 1
          rest: ''
          s: 0
          sym: 
        - !!perl/hash:RE_string
          a: 0
          alt: postfix_prefix_meta_operator__S_259Nch_01 1
          dba: postfix_prefix_meta_operator__S_259Nch
          i: 0
          min: 2
          r: 1
          s: 0
          text: '>>'
    - !!perl/hash:RE_bracket
      decl: []
      min: 0
      re: !!perl/hash:RE_first
        a: 0
        dba: postfix_prefix_meta_operator__S_259Nch
        i: 0
        min: 0
        r: 1
        s: 0
        zyg:
        - !!perl/hash:RE_assertion
          assert: '!'
          min: 0
          re: !!perl/hash:RE_block
            a: 0
            context: bool
            dba: postfix_prefix_meta_operator__S_259Nch
            i: 0
            min: 0
            nobind: 1
            r: 1
            s: 0
            text: ' $*QSIGIL '
        - !!perl/hash:RE_assertion
          assert: '!'
          min: 0
          re: !!perl/hash:RE_method_re
            a: 0
            dba: postfix_prefix_meta_operator__S_259Nch
            i: 0
            min: 0
            name: before
            nobind: 1
            r: 1
            re: !!perl/hash:RE_ast
              decl: []
              min: 1
              re: !!perl/hash:RE_string
                a: 0
                dba: postfix_prefix_meta_operator__S_259Nch
                i: 0
                min: 1
                r: 1
                s: 0
                text: (
            s: 0
postfix_prefix_meta_operator__S_259Nch_01: *53
postop: !!perl/hash:RE_ast
  decl: []
  kind: token
  min: 12345
  pkg: ~
  re: &54 !!perl/hash:RE_any
    a: 0
    altname: postop_00
    dba: postop
    i: 0
    min: 12345
    name: postop_00
    r: 1
    s: 0
    zyg:
    - !!perl/hash:RE_sequence
      a: 0
      alt: postop_00 0
      dba: postop
      i: 0
      min: 12345
      r: 1
      s: 0
      zyg:
      - !!perl/hash:RE_method
        a: 0
        dba: postop
        i: 0
        min: 12345
        name: postfix
        r: 1
        rest: ''
        s: 0
      - !!perl/hash:RE_block
        a: 0
        context: void
        dba: postop
        i: 0
        min: 0
        r: 1
        s: 0
        text: ' $<O> := $<postfix><O>; $<sym> := $<postfix><sym>; '
    - !!perl/hash:RE_sequence
      a: 0
      alt: postop_00 1
      dba: postop
      i: 0
      min: 12345
      r: 1
      s: 0
      zyg:
      - !!perl/hash:RE_method
        a: 0
        dba: postop
        i: 0
        min: 12345
        name: postcircumfix
        r: 1
        rest: ''
        s: 0
      - !!perl/hash:RE_block
        a: 0
        context: void
        dba: postop
        i: 0
        min: 0
        r: 1
        s: 0
        text: ' $<O> := $<postcircumfix><O>; $<sym> := $<postcircumfix><sym>; '
postop_00: *54
prefix__S_281PlusPlus: !!perl/hash:RE_ast
  decl: []
  kind: token
  min: 12345
  pkg: ~
  re: !!perl/hash:RE_sequence
    a: 0
    dba: prefix__S_281PlusPlus
    i: 0
    min: 12345
    r: 1
    s: 0
    zyg:
    - !!perl/hash:RE_method
      a: 0
      dba: prefix__S_281PlusPlus
      i: 0
      min: 12345
      name: sym
      r: 1
      rest: ''
      s: 0
      sym: ++
    - !!perl/hash:RE_method
      min: 0
      name: O
      rest: (|%autoincrement)
prefix__S_282MinusMinus: !!perl/hash:RE_ast
  decl: []
  kind: token
  min: 12345
  pkg: ~
  re: !!perl/hash:RE_sequence
    a: 0
    dba: prefix__S_282MinusMinus
    i: 0
    min: 12345
    r: 1
    s: 0
    zyg:
    - !!perl/hash:RE_method
      a: 0
      dba: prefix__S_282MinusMinus
      i: 0
      min: 12345
      name: sym
      r: 1
      rest: ''
      s: 0
      sym: --
    - !!perl/hash:RE_method
      min: 0
      name: O
      rest: (|%autoincrement)
prefix__S_284Bang: !!perl/hash:RE_ast
  decl: []
  kind: token
  min: 12345
  pkg: ~
  re: !!perl/hash:RE_sequence
    a: 0
    dba: prefix__S_284Bang
    i: 0
    min: 12345
    r: 1
    s: 0
    zyg:
    - !!perl/hash:RE_method
      a: 0
      dba: prefix__S_284Bang
      i: 0
      min: 12345
      name: sym
      r: 1
      rest: ''
      s: 0
      sym: '!'
    - !!perl/hash:RE_method
      min: 0
      name: O
      rest: (|%symbolic_unary)
prefix__S_285Plus: !!perl/hash:RE_ast
  decl: []
  kind: token
  min: 12345
  pkg: ~
  re: !!perl/hash:RE_sequence
    a: 0
    dba: prefix__S_285Plus
    i: 0
    min: 12345
    r: 1
    s: 0
    zyg:
    - !!perl/hash:RE_method
      a: 0
      dba: prefix__S_285Plus
      i: 0
      min: 12345
      name: sym
      r: 1
      rest: ''
      s: 0
      sym: +
    - !!perl/hash:RE_method
      min: 0
      name: O
      rest: (|%symbolic_unary)
prefix__S_286Minus: !!perl/hash:RE_ast
  decl: []
  kind: token
  min: 12345
  pkg: ~
  re: !!perl/hash:RE_sequence
    a: 0
    dba: prefix__S_286Minus
    i: 0
    min: 12345
    r: 1
    s: 0
    zyg:
    - !!perl/hash:RE_method
      a: 0
      dba: prefix__S_286Minus
      i: 0
      min: 12345
      name: sym
      r: 1
      rest: ''
      s: 0
      sym: '-'
    - !!perl/hash:RE_method
      min: 0
      name: O
      rest: (|%symbolic_unary)
prefix__S_287TildeTilde: !!perl/hash:RE_ast
  decl: []
  kind: token
  min: 24690
  pkg: ~
  re: !!perl/hash:RE_sequence
    a: 0
    dba: prefix__S_287TildeTilde
    i: 0
    min: 24690
    r: 1
    s: 0
    zyg:
    - !!perl/hash:RE_method
      a: 0
      dba: prefix__S_287TildeTilde
      i: 0
      min: 12345
      name: sym
      r: 1
      rest: ''
      s: 0
      sym: ~~
    - !!perl/hash:RE_method
      a: 0
      dba: prefix__S_287TildeTilde
      i: 0
      min: 12345
      name: badinfix
      nobind: 1
      r: 1
      rest: ''
      s: 0
    - !!perl/hash:RE_method
      min: 0
      name: O
      rest: (|%symbolic_unary)
prefix__S_288Tilde: !!perl/hash:RE_ast
  decl: []
  kind: token
  min: 12345
  pkg: ~
  re: !!perl/hash:RE_sequence
    a: 0
    dba: prefix__S_288Tilde
    i: 0
    min: 12345
    r: 1
    s: 0
    zyg:
    - !!perl/hash:RE_method
      a: 0
      dba: prefix__S_288Tilde
      i: 0
      min: 12345
      name: sym
      r: 1
      rest: ''
      s: 0
      sym: '~'
    - !!perl/hash:RE_method
      min: 0
      name: O
      rest: (|%symbolic_unary)
prefix__S_289QuestionQuestion: !!perl/hash:RE_ast
  decl: []
  kind: token
  min: 24690
  pkg: ~
  re: !!perl/hash:RE_sequence
    a: 0
    dba: prefix__S_289QuestionQuestion
    i: 0
    min: 24690
    r: 1
    s: 0
    zyg:
    - !!perl/hash:RE_method
      a: 0
      dba: prefix__S_289QuestionQuestion
      i: 0
      min: 12345
      name: sym
      r: 1
      rest: ''
      s: 0
      sym: ??
    - !!perl/hash:RE_method
      a: 0
      dba: prefix__S_289QuestionQuestion
      i: 0
      min: 12345
      name: badinfix
      nobind: 1
      r: 1
      rest: ''
      s: 0
    - !!perl/hash:RE_method
      min: 0
      name: O
      rest: (|%symbolic_unary)
prefix__S_290Question: !!perl/hash:RE_ast
  decl: []
  kind: token
  min: 12345
  pkg: ~
  re: !!perl/hash:RE_sequence
    a: 0
    dba: prefix__S_290Question
    i: 0
    min: 12345
    r: 1
    s: 0
    zyg:
    - !!perl/hash:RE_method
      a: 0
      dba: prefix__S_290Question
      i: 0
      min: 12345
      name: sym
      r: 1
      rest: ''
      s: 0
      sym: '?'
    - !!perl/hash:RE_method
      min: 0
      name: O
      rest: (|%symbolic_unary)
prefix__S_291TildeCaret: !!perl/hash:RE_ast
  decl: []
  kind: token
  min: 12345
  pkg: ~
  re: !!perl/hash:RE_sequence
    a: 0
    dba: prefix__S_291TildeCaret
    i: 0
    min: 12345
    r: 1
    s: 0
    zyg:
    - !!perl/hash:RE_method
      a: 0
      dba: prefix__S_291TildeCaret
      i: 0
      min: 12345
      name: sym
      r: 1
      rest: ''
      s: 0
      sym: ~^
    - !!perl/hash:RE_method
      min: 0
      name: O
      rest: (|%symbolic_unary)
prefix__S_292PlusCaret: !!perl/hash:RE_ast
  decl: []
  kind: token
  min: 12345
  pkg: ~
  re: !!perl/hash:RE_sequence
    a: 0
    dba: prefix__S_292PlusCaret
    i: 0
    min: 12345
    r: 1
    s: 0
    zyg:
    - !!perl/hash:RE_method
      a: 0
      dba: prefix__S_292PlusCaret
      i: 0
      min: 12345
      name: sym
      r: 1
      rest: ''
      s: 0
      sym: +^
    - !!perl/hash:RE_method
      min: 0
      name: O
      rest: (|%symbolic_unary)
prefix__S_293QuestionCaret: !!perl/hash:RE_ast
  decl: []
  kind: token
  min: 12345
  pkg: ~
  re: !!perl/hash:RE_sequence
    a: 0
    dba: prefix__S_293QuestionCaret
    i: 0
    min: 12345
    r: 1
    s: 0
    zyg:
    - !!perl/hash:RE_method
      a: 0
      dba: prefix__S_293QuestionCaret
      i: 0
      min: 12345
      name: sym
      r: 1
      rest: ''
      s: 0
      sym: ?^
    - !!perl/hash:RE_method
      min: 0
      name: O
      rest: (|%symbolic_unary)
prefix__S_294CaretCaret: !!perl/hash:RE_ast
  decl: []
  kind: token
  min: 24690
  pkg: ~
  re: !!perl/hash:RE_sequence
    a: 0
    dba: prefix__S_294CaretCaret
    i: 0
    min: 24690
    r: 1
    s: 0
    zyg:
    - !!perl/hash:RE_method
      a: 0
      dba: prefix__S_294CaretCaret
      i: 0
      min: 12345
      name: sym
      r: 1
      rest: ''
      s: 0
      sym: ^^
    - !!perl/hash:RE_method
      a: 0
      dba: prefix__S_294CaretCaret
      i: 0
      min: 12345
      name: badinfix
      nobind: 1
      r: 1
      rest: ''
      s: 0
    - !!perl/hash:RE_method
      min: 0
      name: O
      rest: (|%symbolic_unary)
prefix__S_295Caret: !!perl/hash:RE_ast
  decl: []
  kind: token
  min: 12345
  pkg: ~
  re: !!perl/hash:RE_sequence
    a: 0
    dba: prefix__S_295Caret
    i: 0
    min: 12345
    r: 1
    s: 0
    zyg:
    - !!perl/hash:RE_method
      a: 0
      dba: prefix__S_295Caret
      i: 0
      min: 12345
      name: sym
      r: 1
      rest: ''
      s: 0
      sym: ^
    - !!perl/hash:RE_method
      min: 0
      name: O
      rest: (|%symbolic_unary)
prefix__S_296VertVert: !!perl/hash:RE_ast
  decl: []
  kind: token
  min: 12345
  pkg: ~
  re: !!perl/hash:RE_sequence
    a: 0
    dba: prefix__S_296VertVert
    i: 0
    min: 12345
    r: 1
    s: 0
    zyg:
    - !!perl/hash:RE_method
      a: 0
      dba: prefix__S_296VertVert
      i: 0
      min: 12345
      name: sym
      r: 1
      rest: ''
      s: 0
      sym: '||'
    - !!perl/hash:RE_method
      min: 0
      name: O
      rest: (|%symbolic_unary)
prefix__S_297Vert: !!perl/hash:RE_ast
  decl: []
  kind: token
  min: 12345
  pkg: ~
  re: !!perl/hash:RE_sequence
    a: 0
    dba: prefix__S_297Vert
    i: 0
    min: 12345
    r: 1
    s: 0
    zyg:
    - !!perl/hash:RE_method
      a: 0
      dba: prefix__S_297Vert
      i: 0
      min: 12345
      name: sym
      r: 1
      rest: ''
      s: 0
      sym: '|'
    - !!perl/hash:RE_method
      min: 0
      name: O
      rest: (|%symbolic_unary)
prefix__S_326sleep: !!perl/hash:RE_ast
  decl: []
  kind: token
  min: 12345
  pkg: ~
  re: !!perl/hash:RE_sequence
    a: 0
    dba: prefix__S_326sleep
    i: 0
    min: 12345
    r: 1
    s: 0
    zyg:
    - !!perl/hash:RE_method
      a: 0
      dba: prefix__S_326sleep
      i: 0
      min: 12345
      name: sym
      r: 1
      rest: ''
      s: 0
      sym: sleep
    - !!perl/hash:RE_meta
      a: 0
      dba: prefix__S_326sleep
      i: 0
      min: 0
      r: 1
      s: 0
      text: 
    - !!perl/hash:RE_assertion
      assert: '?'
      min: 0
      re: !!perl/hash:RE_method_re
        a: 0
        dba: prefix__S_326sleep
        i: 0
        min: 0
        name: before
        nobind: 1
        r: 1
        re: !!perl/hash:RE_ast
          decl: []
          min: 0
          re: !!perl/hash:RE_quantified_atom
            atom: !!perl/hash:RE_meta
              a: 0
              dba: prefix__S_326sleep
              i: 0
              min: 1
              r: 1
              s: 0
              text: \s
            min: 0
            quant:
            - '*'
            - ':'
            - ''
            - 0
        s: 0
    - !!perl/hash:RE_method
      min: 0
      name: O
      rest: (|%named_unary)
prefix__S_327abs: !!perl/hash:RE_ast
  decl: []
  kind: token
  min: 12345
  pkg: ~
  re: !!perl/hash:RE_sequence
    a: 0
    dba: prefix__S_327abs
    i: 0
    min: 12345
    r: 1
    s: 0
    zyg:
    - !!perl/hash:RE_method
      a: 0
      dba: prefix__S_327abs
      i: 0
      min: 12345
      name: sym
      r: 1
      rest: ''
      s: 0
      sym: abs
    - !!perl/hash:RE_meta
      a: 0
      dba: prefix__S_327abs
      i: 0
      min: 0
      r: 1
      s: 0
      text: 
    - !!perl/hash:RE_assertion
      assert: '?'
      min: 0
      re: !!perl/hash:RE_method_re
        a: 0
        dba: prefix__S_327abs
        i: 0
        min: 0
        name: before
        nobind: 1
        r: 1
        re: !!perl/hash:RE_ast
          decl: []
          min: 0
          re: !!perl/hash:RE_quantified_atom
            atom: !!perl/hash:RE_meta
              a: 0
              dba: prefix__S_327abs
              i: 0
              min: 1
              r: 1
              s: 0
              text: \s
            min: 0
            quant:
            - '*'
            - ':'
            - ''
            - 0
        s: 0
    - !!perl/hash:RE_method
      min: 0
      name: O
      rest: (|%named_unary)
prefix__S_328let: !!perl/hash:RE_ast
  decl: []
  kind: token
  min: 12345
  pkg: ~
  re: !!perl/hash:RE_sequence
    a: 0
    dba: prefix__S_328let
    i: 0
    min: 12345
    r: 1
    s: 0
    zyg:
    - !!perl/hash:RE_method
      a: 0
      dba: prefix__S_328let
      i: 0
      min: 12345
      name: sym
      r: 1
      rest: ''
      s: 0
      sym: let
    - !!perl/hash:RE_meta
      a: 0
      dba: prefix__S_328let
      i: 0
      min: 0
      r: 1
      s: 0
      text: 
    - !!perl/hash:RE_assertion
      assert: '?'
      min: 0
      re: !!perl/hash:RE_method_re
        a: 0
        dba: prefix__S_328let
        i: 0
        min: 0
        name: before
        nobind: 1
        r: 1
        re: !!perl/hash:RE_ast
          decl: []
          min: 0
          re: !!perl/hash:RE_quantified_atom
            atom: !!perl/hash:RE_meta
              a: 0
              dba: prefix__S_328let
              i: 0
              min: 1
              r: 1
              s: 0
              text: \s
            min: 0
            quant:
            - '*'
            - ':'
            - ''
            - 0
        s: 0
    - !!perl/hash:RE_method
      min: 0
      name: O
      rest: (|%named_unary)
prefix__S_329temp: !!perl/hash:RE_ast
  decl: []
  kind: token
  min: 12345
  pkg: ~
  re: !!perl/hash:RE_sequence
    a: 0
    dba: prefix__S_329temp
    i: 0
    min: 12345
    r: 1
    s: 0
    zyg:
    - !!perl/hash:RE_method
      a: 0
      dba: prefix__S_329temp
      i: 0
      min: 12345
      name: sym
      r: 1
      rest: ''
      s: 0
      sym: temp
    - !!perl/hash:RE_meta
      a: 0
      dba: prefix__S_329temp
      i: 0
      min: 0
      r: 1
      s: 0
      text: 
    - !!perl/hash:RE_assertion
      assert: '?'
      min: 0
      re: !!perl/hash:RE_method_re
        a: 0
        dba: prefix__S_329temp
        i: 0
        min: 0
        name: before
        nobind: 1
        r: 1
        re: !!perl/hash:RE_ast
          decl: []
          min: 0
          re: !!perl/hash:RE_quantified_atom
            atom: !!perl/hash:RE_meta
              a: 0
              dba: prefix__S_329temp
              i: 0
              min: 1
              r: 1
              s: 0
              text: \s
            min: 0
            quant:
            - '*'
            - ':'
            - ''
            - 0
        s: 0
    - !!perl/hash:RE_method
      min: 0
      name: O
      rest: (|%named_unary)
prefix__S_381so: !!perl/hash:RE_ast
  decl: []
  kind: token
  min: 12345
  pkg: ~
  re: !!perl/hash:RE_sequence
    a: 0
    dba: prefix__S_381so
    i: 0
    min: 12345
    r: 1
    s: 0
    zyg:
    - !!perl/hash:RE_method
      a: 0
      dba: prefix__S_381so
      i: 0
      min: 12345
      name: sym
      r: 1
      rest: ''
      s: 0
      sym: so
    - !!perl/hash:RE_meta
      a: 0
      dba: prefix__S_381so
      i: 0
      min: 0
      r: 1
      s: 0
      text: 
    - !!perl/hash:RE_method
      min: 0
      name: O
      rest: (|%loose_unary)
prefix__S_382not: !!perl/hash:RE_ast
  decl: []
  kind: token
  min: 12345
  pkg: ~
  re: !!perl/hash:RE_sequence
    a: 0
    dba: prefix__S_382not
    i: 0
    min: 12345
    r: 1
    s: 0
    zyg:
    - !!perl/hash:RE_method
      a: 0
      dba: prefix__S_382not
      i: 0
      min: 12345
      name: sym
      r: 1
      rest: ''
      s: 0
      sym: not
    - !!perl/hash:RE_meta
      a: 0
      dba: prefix__S_382not
      i: 0
      min: 0
      r: 1
      s: 0
      text: 
    - !!perl/hash:RE_method
      min: 0
      name: O
      rest: (|%loose_unary)
prefix_circumfix_meta_operator__S_257reduce: !!perl/hash:RE_ast
  decl:
  - !!perl/hash:RE_decl
    a: 0
    dba: prefix_circumfix_meta_operator__S_257reduce
    i: 0
    max: 0
    min: 0
    r: 0
    s: 0
    text: my $*IN_REDUCE = 1
  - !!perl/hash:RE_decl
    a: 0
    dba: prefix_circumfix_meta_operator__S_257reduce
    i: 0
    max: 0
    min: 0
    r: 0
    s: 0
    text: my $op
  kind: regex
  min: 2
  pkg: ~
  re: !!perl/hash:RE_sequence
    a: 0
    dba: prefix_circumfix_meta_operator__S_257reduce
    i: 0
    min: 2
    r: 0
    s: 0
    zyg:
    - !!perl/hash:RE_assertion
      assert: '?'
      min: 0
      re: !!perl/hash:RE_method_re
        a: 0
        dba: prefix_circumfix_meta_operator__S_257reduce
        i: 0
        min: 0
        name: before
        nobind: 1
        r: 0
        re: !!perl/hash:RE_ast
          decl: []
          min: 3
          re: !!perl/hash:RE_sequence
            a: 0
            dba: prefix_circumfix_meta_operator__S_257reduce
            i: 0
            min: 3
            r: 0
            s: 0
            zyg:
            - !!perl/hash:RE_string
              a: 0
              dba: prefix_circumfix_meta_operator__S_257reduce
              i: 0
              min: 1
              r: 0
              s: 0
              text: '['
            - !!perl/hash:RE_quantified_atom
              atom: !!perl/hash:RE_meta
                a: 0
                dba: prefix_circumfix_meta_operator__S_257reduce
                i: 0
                min: 1
                r: 0
                s: 0
                text: \S
              min: 1
              quant:
              - +
              - '!'
              - ''
              - 1
            - !!perl/hash:RE_string
              a: 0
              dba: prefix_circumfix_meta_operator__S_257reduce
              i: 0
              min: 1
              r: 0
              s: 0
              text: ']'
        s: 0
    - !!perl/hash:RE_bindnamed
      a: 0
      atom: !!perl/hash:RE_paren
        decl: []
        min: 2
        re: !!perl/hash:RE_sequence
          a: 0
          dba: prefix_circumfix_meta_operator__S_257reduce
          i: 0
          min: 2
          r: 0
          s: 0
          zyg:
          - !!perl/hash:RE_string
            a: 0
            dba: prefix_circumfix_meta_operator__S_257reduce
            i: 0
            min: 1
            r: 0
            s: 0
            text: '['
          - !!perl/hash:RE_bracket
            decl: []
            min: 0
            re: !!perl/hash:RE_first
              a: 0
              dba: prefix_circumfix_meta_operator__S_257reduce
              i: 0
              min: 0
              r: 0
              s: 0
              zyg:
              - !!perl/hash:RE_sequence
                a: 0
                dba: prefix_circumfix_meta_operator__S_257reduce
                i: 0
                min: 0
                r: 0
                s: 0
                zyg:
                - !!perl/hash:RE_bindnamed
                  a: 0
                  atom: !!perl/hash:RE_method
                    min: 0
                    name: infixish
                    nobind: 1
                    rest: (1)
                  dba: prefix_circumfix_meta_operator__S_257reduce
                  i: 0
                  min: 0
                  r: 0
                  s: 0
                  var: op
                - !!perl/hash:RE_assertion
                  assert: '?'
                  min: 0
                  re: !!perl/hash:RE_method_re
                    a: 0
                    dba: prefix_circumfix_meta_operator__S_257reduce
                    i: 0
                    min: 0
                    name: before
                    nobind: 1
                    r: 0
                    re: !!perl/hash:RE_ast
                      decl: []
                      min: 1
                      re: !!perl/hash:RE_string
                        a: 0
                        dba: prefix_circumfix_meta_operator__S_257reduce
                        i: 0
                        min: 1
                        r: 0
                        s: 0
                        text: ']'
                    s: 0
              - !!perl/hash:RE_sequence
                a: 0
                dba: prefix_circumfix_meta_operator__S_257reduce
                i: 0
                min: 1
                r: 0
                s: 0
                zyg:
                - !!perl/hash:RE_string
                  a: 0
                  dba: prefix_circumfix_meta_operator__S_257reduce
                  i: 0
                  min: 1
                  r: 0
                  s: 0
                  text: \
                - !!perl/hash:RE_bindnamed
                  a: 0
                  atom: !!perl/hash:RE_method
                    min: 0
                    name: infixish
                    nobind: 1
                    rest: (1)
                  dba: prefix_circumfix_meta_operator__S_257reduce
                  i: 0
                  min: 0
                  r: 0
                  s: 0
                  var: op
                - !!perl/hash:RE_assertion
                  assert: '?'
                  min: 0
                  re: !!perl/hash:RE_method_re
                    a: 0
                    dba: prefix_circumfix_meta_operator__S_257reduce
                    i: 0
                    min: 0
                    name: before
                    nobind: 1
                    r: 0
                    re: !!perl/hash:RE_ast
                      decl: []
                      min: 1
                      re: !!perl/hash:RE_string
                        a: 0
                        dba: prefix_circumfix_meta_operator__S_257reduce
                        i: 0
                        min: 1
                        r: 0
                        s: 0
                        text: ']'
                    s: 0
              - !!perl/hash:RE_assertion
                assert: '!'
                min: 0
                re: !!perl/hash:RE_noop
                  a: 0
                  dba: prefix_circumfix_meta_operator__S_257reduce
                  i: 0
                  min: 0
                  nobind: 1
                  r: 0
                  s: 0
          - !!perl/hash:RE_string
            a: 0
            dba: prefix_circumfix_meta_operator__S_257reduce
            i: 0
            min: 1
            r: 0
            s: 0
            text: ']'
          - !!perl/hash:RE_bracket
            decl: []
            min: 0
            re: &55 !!perl/hash:RE_any
              a: 0
              altname: prefix_circumfix_meta_operator__S_257reduce_08
              dba: prefix_circumfix_meta_operator__S_257reduce
              i: 0
              min: 0
              name: prefix_circumfix_meta_operator__S_257reduce_08
              r: 0
              s: 0
              zyg:
              - !!perl/hash:RE_string
                a: 0
                alt: prefix_circumfix_meta_operator__S_257reduce_08 0
                dba: prefix_circumfix_meta_operator__S_257reduce
                i: 0
                min: 1
                r: 0
                s: 0
                text: 
              - !!perl/hash:RE_assertion
                alt: prefix_circumfix_meta_operator__S_257reduce_08 1
                assert: '?'
                min: 0
                re: !!perl/hash:RE_noop
                  a: 0
                  dba: prefix_circumfix_meta_operator__S_257reduce
                  i: 0
                  min: 0
                  nobind: 1
                  r: 0
                  s: 0
      dba: prefix_circumfix_meta_operator__S_257reduce
      i: 0
      min: 2
      r: 0
      s: 0
      var: s
    - !!perl/hash:RE_block
      a: 0
      context: void
      dba: prefix_circumfix_meta_operator__S_257reduce
      i: 0
      min: 0
      r: 0
      s: 0
      text: ' $op = $<s><op>; '
    - !!perl/hash:RE_method
      min: 0
      name: can_meta
      nobind: 1
      rest: ($op, "reduce with")
    - !!perl/hash:RE_bracket
      decl: []
      min: 0
      re: !!perl/hash:RE_first
        a: 0
        dba: prefix_circumfix_meta_operator__S_257reduce
        i: 0
        min: 0
        r: 0
        s: 0
        zyg:
        - !!perl/hash:RE_assertion
          assert: '!'
          min: 0
          re: !!perl/hash:RE_block
            a: 0
            context: bool
            dba: prefix_circumfix_meta_operator__S_257reduce
            i: 0
            min: 0
            nobind: 1
            r: 0
            s: 0
            text: ' $op<O><diffy> '
        - !!perl/hash:RE_assertion
          assert: '?'
          min: 0
          re: !!perl/hash:RE_block
            a: 0
            context: bool
            dba: prefix_circumfix_meta_operator__S_257reduce
            i: 0
            min: 0
            nobind: 1
            r: 0
            s: 0
            text: ' $op<O><assoc> eq ''chain'' '
        - !!perl/hash:RE_method
          min: 0
          name: panic
          nobind: 1
          rest: ("Can't reduce with " ~ $op<sym> ~ " because " ~ $op<O><dba> ~ " operators
            are diffy and not chaining")
    - !!perl/hash:RE_method
      min: 0
      name: O
      rest: ($op.Opairs, |%list_prefix, assoc => 'unary', uassoc => 'left')
    - !!perl/hash:RE_block
      a: 0
      context: void
      dba: prefix_circumfix_meta_operator__S_257reduce
      i: 0
      min: 0
      r: 0
      s: 0
      text: ' $<sym> = $<s>.Str; '
    - !!perl/hash:RE_bracket
      decl: []
      min: 0
      re: !!perl/hash:RE_first
        a: 0
        dba: prefix_circumfix_meta_operator__S_257reduce
        i: 0
        min: 0
        r: 0
        s: 0
        zyg:
        - !!perl/hash:RE_assertion
          assert: '?'
          min: 0
          re: !!perl/hash:RE_method_re
            a: 0
            dba: prefix_circumfix_meta_operator__S_257reduce
            i: 0
            min: 0
            name: before
            nobind: 1
            r: 0
            re: !!perl/hash:RE_ast
              decl: []
              min: 1
              re: !!perl/hash:RE_string
                a: 0
                dba: prefix_circumfix_meta_operator__S_257reduce
                i: 0
                min: 1
                r: 0
                s: 0
                text: (
            s: 0
        - !!perl/hash:RE_assertion
          assert: '?'
          min: 0
          re: !!perl/hash:RE_method_re
            a: 0
            dba: prefix_circumfix_meta_operator__S_257reduce
            i: 0
            min: 0
            name: before
            nobind: 1
            r: 0
            re: !!perl/hash:RE_ast
              decl: []
              min: 1
              re: !!perl/hash:RE_sequence
                a: 0
                dba: prefix_circumfix_meta_operator__S_257reduce
                i: 0
                min: 1
                r: 0
                s: 0
                zyg:
                - !!perl/hash:RE_quantified_atom
                  atom: !!perl/hash:RE_meta
                    a: 0
                    dba: prefix_circumfix_meta_operator__S_257reduce
                    i: 0
                    min: 1
                    r: 0
                    s: 0
                    text: \s
                  min: 1
                  quant:
                  - +
                  - '!'
                  - ''
                  - 1
                - !!perl/hash:RE_quantified_atom
                  atom: !!perl/hash:RE_bracket
                    decl: []
                    min: 0
                    re: !!perl/hash:RE_sequence
                      a: 0
                      dba: prefix_circumfix_meta_operator__S_257reduce
                      i: 0
                      min: 0
                      r: 0
                      s: 0
                      zyg:
                      - !!perl/hash:RE_assertion
                        assert: '?'
                        min: 0
                        re: !!perl/hash:RE_method
                          a: 0
                          dba: prefix_circumfix_meta_operator__S_257reduce
                          i: 0
                          min: 12345
                          name: stdstopper
                          nobind: 1
                          r: 0
                          rest: ''
                          s: 0
                      - !!perl/hash:RE_block
                        a: 0
                        context: void
                        dba: prefix_circumfix_meta_operator__S_257reduce
                        i: 0
                        min: 0
                        r: 0
                        s: 0
                        text: ' $<O><term> = 1 '
                  min: 0
                  quant:
                  - '?'
                  - '!'
                  - ''
                  - 0
            s: 0
        - !!perl/hash:RE_block
          a: 0
          context: void
          dba: prefix_circumfix_meta_operator__S_257reduce
          i: 0
          min: 0
          r: 0
          s: 0
          text: ' $<O><term> = 1 '
prefix_circumfix_meta_operator__S_257reduce_08: *55
prefix_postfix_meta_operator__S_258Fre: !!perl/hash:RE_ast
  decl: []
  kind: token
  min: 2
  pkg: ~
  re: &56 !!perl/hash:RE_any
    a: 0
    altname: prefix_postfix_meta_operator__S_258Fre_00
    dba: prefix_postfix_meta_operator__S_258Fre
    i: 0
    min: 2
    name: prefix_postfix_meta_operator__S_258Fre_00
    r: 1
    s: 0
    zyg:
    - !!perl/hash:RE_method
      a: 0
      alt: prefix_postfix_meta_operator__S_258Fre_00 0
      dba: prefix_postfix_meta_operator__S_258Fre
      i: 0
      min: 12345
      name: sym
      r: 1
      rest: ''
      s: 0
      sym: 
    - !!perl/hash:RE_string
      a: 0
      alt: prefix_postfix_meta_operator__S_258Fre_00 1
      dba: prefix_postfix_meta_operator__S_258Fre
      i: 0
      min: 2
      r: 1
      s: 0
      text: <<
prefix_postfix_meta_operator__S_258Fre_00: *56
privop: !!perl/hash:RE_ast
  decl: []
  kind: token
  min: 12346
  pkg: ~
  re: !!perl/hash:RE_sequence
    a: 0
    dba: privop
    i: 0
    min: 12346
    r: 1
    s: 0
    zyg:
    - !!perl/hash:RE_string
      a: 0
      dba: privop
      i: 0
      min: 1
      r: 1
      s: 0
      text: '!'
    - !!perl/hash:RE_method
      a: 0
      dba: privop
      i: 0
      min: 12345
      name: methodop
      r: 1
      rest: ''
      s: 0
    - !!perl/hash:RE_method
      min: 0
      name: O
      rest: (%methodcall)
quasiquibble: !!perl/hash:RE_ast
  decl:
  - !!perl/hash:RE_decl
    a: 0
    dba: quasiquibble
    i: 0
    max: 0
    min: 0
    r: 1
    s: 0
    text: temp %*LANG
  - !!perl/hash:RE_decl
    a: 0
    dba: quasiquibble
    i: 0
    max: 0
    min: 0
    r: 1
    s: 0
    text: my ($lang, $start, $stop)
  - !!perl/hash:RE_decl
    a: 0
    dba: quasiquibble
    i: 0
    max: 0
    min: 0
    r: 1
    s: 0
    text: my $*QUASIMODO = 0
  kind: token
  min: 12345
  pkg: ~
  re: !!perl/hash:RE_sequence
    a: 0
    dba: quasiquibble
    i: 0
    min: 12345
    r: 1
    s: 0
    zyg:
    - !!perl/hash:RE_method
      min: 0
      name: babble
      rest: ($l)
    - !!perl/hash:RE_block
      a: 0
      context: void
      dba: quasiquibble
      i: 0
      min: 0
      r: 1
      s: 0
      text: "\n            my $B = $<babble><B>;\n            ($lang,$start,$stop)
        = @$B;\n            %*LANG<MAIN> = $lang;\n        "
    - !!perl/hash:RE_bracket
      decl: []
      min: 12345
      re: !!perl/hash:RE_first
        a: 0
        dba: quasiquibble
        i: 0
        min: 12345
        r: 1
        s: 0
        zyg:
        - !!perl/hash:RE_sequence
          a: 0
          dba: quasiquibble
          i: 0
          min: 12345
          r: 1
          s: 0
          zyg:
          - !!perl/hash:RE_assertion
            assert: '?'
            min: 0
            re: !!perl/hash:RE_block
              a: 0
              context: bool
              dba: quasiquibble
              i: 0
              min: 0
              nobind: 1
              r: 1
              s: 0
              text: ' $start eq ''{'' '
          - !!perl/hash:RE_bracket
            decl: []
            min: 12345
            re: !!perl/hash:RE_sequence
              a: 0
              dba: quasiquibble
              i: 0
              lang: ($lang)
              min: 12345
              r: 1
              s: 0
              zyg:
              - !!perl/hash:RE_decl
                a: 0
                dba: quasiquibble
                i: 0
                lang: ($lang)
                max: 0
                min: 0
                noquant: 1
                r: 1
                s: 0
                text: 'my $newlang = ($lang);  $C = $C->cursor_fresh($newlang); '
              - !!perl/hash:RE_method
                a: 0
                dba: quasiquibble
                i: 0
                lang: ($lang)
                min: 12345
                name: block
                r: 1
                rest: ''
                s: 0
        - !!perl/hash:RE_bracket
          decl: []
          min: 24690
          re: !!perl/hash:RE_sequence
            a: 0
            dba: quasiquibble
            i: 0
            lang: ($lang)
            min: 24690
            r: 1
            s: 0
            zyg:
            - !!perl/hash:RE_decl
              a: 0
              dba: quasiquibble
              i: 0
              lang: ($lang)
              max: 0
              min: 0
              noquant: 1
              r: 1
              s: 0
              text: 'my $newlang = ($lang);  $C = $C->cursor_fresh($newlang); '
            - !!perl/hash:RE_method
              a: 0
              dba: quasiquibble
              i: 0
              lang: ($lang)
              min: 12345
              name: starter
              r: 1
              rest: ''
              s: 0
            - !!perl/hash:RE_method
              a: 0
              dba: quasiquibble
              i: 0
              lang: ($lang)
              min: 12345
              name: statementlist
              r: 1
              rest: ''
              s: 0
            - !!perl/hash:RE_bracket
              decl: []
              min: 0
              re: !!perl/hash:RE_first
                a: 0
                dba: quasiquibble
                i: 0
                lang: ($lang)
                min: 0
                r: 1
                s: 0
                zyg:
                - !!perl/hash:RE_method
                  a: 0
                  dba: quasiquibble
                  i: 0
                  lang: ($lang)
                  min: 12345
                  name: stopper
                  r: 1
                  rest: ''
                  s: 0
                - !!perl/hash:RE_method
                  min: 0
                  name: panic
                  nobind: 1
                  rest: ("Couldn't find terminator $stop")
quote__S_203SlashSlash: !!perl/hash:RE_ast
  decl: []
  kind: token
  min: 2
  pkg: ~
  re: !!perl/hash:RE_sequence
    a: 0
    dba: quote__S_203SlashSlash
    i: 0
    min: 2
    r: 1
    s: 0
    zyg:
    - !!perl/hash:RE_string
      a: 0
      dba: quote__S_203SlashSlash
      i: 0
      min: 1
      r: 1
      s: 0
      text: /
    - !!perl/hash:RE_quantified_atom
      atom: !!perl/hash:RE_meta
        a: 0
        dba: quote__S_203SlashSlash
        i: 0
        min: 1
        r: 1
        s: 0
        text: \s
      min: 0
      quant:
      - '*'
      - ':'
      - ''
      - 0
    - !!perl/hash:RE_string
      a: 0
      dba: quote__S_203SlashSlash
      i: 0
      min: 1
      r: 1
      s: 0
      text: /
    - !!perl/hash:RE_method
      min: 0
      name: panic
      nobind: 1
      rest: ("Null regex not allowed")
quote__S_204Slash_Slash: !!perl/hash:RE_ast
  decl: []
  kind: token
  min: 1
  pkg: ~
  re: !!perl/hash:RE_sequence
    a: 0
    dba: quote__S_204Slash_Slash
    i: 0
    min: 1
    r: 1
    s: 0
    zyg:
    - !!perl/hash:RE_string
      a: 0
      dba: quote__S_204Slash_Slash
      i: 0
      min: 1
      r: 1
      s: 0
      text: /
    - !!perl/hash:RE_method
      min: 0
      name: nibble
      rest: ( $.cursor_fresh( %*LANG<Regex> ).unbalanced("/") )
    - !!perl/hash:RE_bracket
      decl: []
      min: 0
      re: !!perl/hash:RE_first
        a: 0
        dba: quote__S_204Slash_Slash
        i: 0
        min: 0
        r: 1
        s: 0
        zyg:
        - !!perl/hash:RE_string
          a: 0
          dba: quote__S_204Slash_Slash
          i: 0
          min: 1
          r: 1
          s: 0
          text: /
        - !!perl/hash:RE_method
          min: 0
          name: panic
          nobind: 1
          rest: ("Unable to parse regex; couldn't find final '/'")
    - !!perl/hash:RE_quantified_atom
      atom: !!perl/hash:RE_method
        a: 0
        dba: quote__S_204Slash_Slash
        i: 0
        min: 12345
        name: old_rx_mods
        nobind: 1
        r: 1
        rest: ''
        s: 0
      min: 0
      quant:
      - '?'
      - ':'
      - ''
      - 0
quote__S_205qq: !!perl/hash:RE_ast
  decl:
  - !!perl/hash:RE_decl
    a: 0
    dba: quote__S_205qq
    i: 0
    max: 0
    min: 0
    r: 1
    s: 0
    text: my $qm
  kind: token
  min: 12347
  pkg: ~
  re: !!perl/hash:RE_sequence
    a: 0
    dba: quote__S_205qq
    i: 0
    min: 12347
    r: 1
    s: 0
    zyg:
    - !!perl/hash:RE_string
      a: 0
      dba: quote__S_205qq
      i: 0
      min: 2
      r: 1
      s: 0
      text: qq
    - !!perl/hash:RE_bracket
      decl: []
      min: 12345
      re: &57 !!perl/hash:RE_any
        a: 0
        altname: quote__S_205qq_01
        dba: quote__S_205qq
        i: 0
        min: 12345
        name: quote__S_205qq_01
        r: 1
        s: 0
        zyg:
        - !!perl/hash:RE_sequence
          a: 0
          alt: quote__S_205qq_01 0
          dba: quote__S_205qq
          i: 0
          min: 24690
          r: 1
          s: 0
          zyg:
          - !!perl/hash:RE_method
            a: 0
            dba: quote__S_205qq
            i: 0
            min: 12345
            name: quote_mod
            r: 1
            rest: ''
            s: 0
          - !!perl/hash:RE_meta
            a: 0
            dba: quote__S_205qq
            i: 0
            min: 0
            r: 1
            s: 0
            text: 
          - !!perl/hash:RE_assertion
            assert: '!'
            min: 0
            re: !!perl/hash:RE_method_re
              a: 0
              dba: quote__S_205qq
              i: 0
              min: 0
              name: before
              nobind: 1
              r: 1
              re: !!perl/hash:RE_ast
                decl: []
                min: 1
                re: !!perl/hash:RE_string
                  a: 0
                  dba: quote__S_205qq
                  i: 0
                  min: 1
                  r: 1
                  s: 0
                  text: (
              s: 0
          - !!perl/hash:RE_block
            a: 0
            context: void
            dba: quote__S_205qq
            i: 0
            min: 0
            r: 1
            s: 0
            text: ' $qm = $<quote_mod>.Str '
          - !!perl/hash:RE_method
            a: 0
            dba: quote__S_205qq
            i: 0
            min: 12345
            name: ws
            nobind: 1
            r: 1
            rest: ''
            s: 0
          - !!perl/hash:RE_method
            min: 0
            name: quibble
            rest: ($.cursor_fresh( %*LANG<Q> ).tweak(:qq).tweak($qm => 1))
        - !!perl/hash:RE_sequence
          a: 0
          alt: quote__S_205qq_01 1
          dba: quote__S_205qq
          i: 0
          min: 12345
          r: 1
          s: 0
          zyg:
          - !!perl/hash:RE_meta
            a: 0
            dba: quote__S_205qq
            i: 0
            min: 0
            r: 1
            s: 0
            text: 
          - !!perl/hash:RE_assertion
            assert: '!'
            min: 0
            re: !!perl/hash:RE_method_re
              a: 0
              dba: quote__S_205qq
              i: 0
              min: 0
              name: before
              nobind: 1
              r: 1
              re: !!perl/hash:RE_ast
                decl: []
                min: 1
                re: !!perl/hash:RE_string
                  a: 0
                  dba: quote__S_205qq
                  i: 0
                  min: 1
                  r: 1
                  s: 0
                  text: (
              s: 0
          - !!perl/hash:RE_method
            a: 0
            dba: quote__S_205qq
            i: 0
            min: 12345
            name: ws
            nobind: 1
            r: 1
            rest: ''
            s: 0
          - !!perl/hash:RE_method
            min: 0
            name: quibble
            rest: ($.cursor_fresh( %*LANG<Q> ).tweak(:qq))
quote__S_205qq_01: *57
quote__S_206q: !!perl/hash:RE_ast
  decl:
  - !!perl/hash:RE_decl
    a: 0
    dba: quote__S_206q
    i: 0
    max: 0
    min: 0
    r: 1
    s: 0
    text: my $qm
  kind: token
  min: 12346
  pkg: ~
  re: !!perl/hash:RE_sequence
    a: 0
    dba: quote__S_206q
    i: 0
    min: 12346
    r: 1
    s: 0
    zyg:
    - !!perl/hash:RE_string
      a: 0
      dba: quote__S_206q
      i: 0
      min: 1
      r: 1
      s: 0
      text: q
    - !!perl/hash:RE_bracket
      decl: []
      min: 12345
      re: &58 !!perl/hash:RE_any
        a: 0
        altname: quote__S_206q_01
        dba: quote__S_206q
        i: 0
        min: 12345
        name: quote__S_206q_01
        r: 1
        s: 0
        zyg:
        - !!perl/hash:RE_sequence
          a: 0
          alt: quote__S_206q_01 0
          dba: quote__S_206q
          i: 0
          min: 12345
          r: 1
          s: 0
          zyg:
          - !!perl/hash:RE_method
            a: 0
            dba: quote__S_206q
            i: 0
            min: 12345
            name: quote_mod
            r: 1
            rest: ''
            s: 0
          - !!perl/hash:RE_meta
            a: 0
            dba: quote__S_206q
            i: 0
            min: 0
            r: 1
            s: 0
            text: 
          - !!perl/hash:RE_assertion
            assert: '!'
            min: 0
            re: !!perl/hash:RE_method_re
              a: 0
              dba: quote__S_206q
              i: 0
              min: 0
              name: before
              nobind: 1
              r: 1
              re: !!perl/hash:RE_ast
                decl: []
                min: 1
                re: !!perl/hash:RE_string
                  a: 0
                  dba: quote__S_206q
                  i: 0
                  min: 1
                  r: 1
                  s: 0
                  text: (
              s: 0
          - !!perl/hash:RE_block
            a: 0
            context: void
            dba: quote__S_206q
            i: 0
            min: 0
            r: 1
            s: 0
            text: ' $qm = $<quote_mod>.Str '
          - !!perl/hash:RE_method
            min: 0
            name: quibble
            rest: ($.cursor_fresh( %*LANG<Q> ).tweak(:q).tweak($qm => 1))
        - !!perl/hash:RE_sequence
          a: 0
          alt: quote__S_206q_01 1
          dba: quote__S_206q
          i: 0
          min: 12345
          r: 1
          s: 0
          zyg:
          - !!perl/hash:RE_meta
            a: 0
            dba: quote__S_206q
            i: 0
            min: 0
            r: 1
            s: 0
            text: 
          - !!perl/hash:RE_assertion
            assert: '!'
            min: 0
            re: !!perl/hash:RE_method_re
              a: 0
              dba: quote__S_206q
              i: 0
              min: 0
              name: before
              nobind: 1
              r: 1
              re: !!perl/hash:RE_ast
                decl: []
                min: 1
                re: !!perl/hash:RE_string
                  a: 0
                  dba: quote__S_206q
                  i: 0
                  min: 1
                  r: 1
                  s: 0
                  text: (
              s: 0
          - !!perl/hash:RE_method
            a: 0
            dba: quote__S_206q
            i: 0
            min: 12345
            name: ws
            nobind: 1
            r: 1
            rest: ''
            s: 0
          - !!perl/hash:RE_method
            min: 0
            name: quibble
            rest: ($.cursor_fresh( %*LANG<Q> ).tweak(:q))
quote__S_206q_01: *58
quote__S_207Q: !!perl/hash:RE_ast
  decl:
  - !!perl/hash:RE_decl
    a: 0
    dba: quote__S_207Q
    i: 0
    max: 0
    min: 0
    r: 1
    s: 0
    text: my $qm
  kind: token
  min: 12346
  pkg: ~
  re: !!perl/hash:RE_sequence
    a: 0
    dba: quote__S_207Q
    i: 0
    min: 12346
    r: 1
    s: 0
    zyg:
    - !!perl/hash:RE_string
      a: 0
      dba: quote__S_207Q
      i: 0
      min: 1
      r: 1
      s: 0
      text: Q
    - !!perl/hash:RE_bracket
      decl: []
      min: 12345
      re: &59 !!perl/hash:RE_any
        a: 0
        altname: quote__S_207Q_01
        dba: quote__S_207Q
        i: 0
        min: 12345
        name: quote__S_207Q_01
        r: 1
        s: 0
        zyg:
        - !!perl/hash:RE_sequence
          a: 0
          alt: quote__S_207Q_01 0
          dba: quote__S_207Q
          i: 0
          min: 12345
          r: 1
          s: 0
          zyg:
          - !!perl/hash:RE_method
            a: 0
            dba: quote__S_207Q
            i: 0
            min: 12345
            name: quote_mod
            r: 1
            rest: ''
            s: 0
          - !!perl/hash:RE_meta
            a: 0
            dba: quote__S_207Q
            i: 0
            min: 0
            r: 1
            s: 0
            text: 
          - !!perl/hash:RE_assertion
            assert: '!'
            min: 0
            re: !!perl/hash:RE_method_re
              a: 0
              dba: quote__S_207Q
              i: 0
              min: 0
              name: before
              nobind: 1
              r: 1
              re: !!perl/hash:RE_ast
                decl: []
                min: 1
                re: !!perl/hash:RE_string
                  a: 0
                  dba: quote__S_207Q
                  i: 0
                  min: 1
                  r: 1
                  s: 0
                  text: (
              s: 0
          - !!perl/hash:RE_block
            a: 0
            context: void
            dba: quote__S_207Q
            i: 0
            min: 0
            r: 1
            s: 0
            text: ' $qm = $<quote_mod>.Str '
          - !!perl/hash:RE_method
            min: 0
            name: quibble
            rest: ($.cursor_fresh( %*LANG<Q> ).tweak($qm => 1))
        - !!perl/hash:RE_sequence
          a: 0
          alt: quote__S_207Q_01 1
          dba: quote__S_207Q
          i: 0
          min: 12345
          r: 1
          s: 0
          zyg:
          - !!perl/hash:RE_meta
            a: 0
            dba: quote__S_207Q
            i: 0
            min: 0
            r: 1
            s: 0
            text: 
          - !!perl/hash:RE_assertion
            assert: '!'
            min: 0
            re: !!perl/hash:RE_method_re
              a: 0
              dba: quote__S_207Q
              i: 0
              min: 0
              name: before
              nobind: 1
              r: 1
              re: !!perl/hash:RE_ast
                decl: []
                min: 1
                re: !!perl/hash:RE_string
                  a: 0
                  dba: quote__S_207Q
                  i: 0
                  min: 1
                  r: 1
                  s: 0
                  text: (
              s: 0
          - !!perl/hash:RE_method
            a: 0
            dba: quote__S_207Q
            i: 0
            min: 12345
            name: ws
            nobind: 1
            r: 1
            rest: ''
            s: 0
          - !!perl/hash:RE_method
            min: 0
            name: quibble
            rest: ($.cursor_fresh( %*LANG<Q> ))
quote__S_207Q_01: *59
quote__S_219rx: !!perl/hash:RE_ast
  decl: []
  kind: token
  min: 12345
  pkg: ~
  re: !!perl/hash:RE_sequence
    a: 0
    dba: quote__S_219rx
    i: 0
    min: 12345
    r: 1
    s: 0
    zyg:
    - !!perl/hash:RE_method
      a: 0
      dba: quote__S_219rx
      i: 0
      min: 12345
      name: sym
      r: 1
      rest: ''
      s: 0
      sym: rx
    - !!perl/hash:RE_meta
      a: 0
      dba: quote__S_219rx
      i: 0
      min: 0
      r: 1
      s: 0
      text: 
    - !!perl/hash:RE_assertion
      assert: '!'
      min: 0
      re: !!perl/hash:RE_method_re
        a: 0
        dba: quote__S_219rx
        i: 0
        min: 0
        name: before
        nobind: 1
        r: 1
        re: !!perl/hash:RE_ast
          decl: []
          min: 1
          re: !!perl/hash:RE_string
            a: 0
            dba: quote__S_219rx
            i: 0
            min: 1
            r: 1
            s: 0
            text: (
        s: 0
    - !!perl/hash:RE_method
      min: 0
      name: quibble
      rest: ( $.cursor_fresh( %*LANG<Regex> ) )
    - !!perl/hash:RE_assertion
      assert: '!'
      min: 0
      re: !!perl/hash:RE_method
        a: 0
        dba: quote__S_219rx
        i: 0
        min: 12345
        name: old_rx_mods
        nobind: 1
        r: 1
        rest: ''
        s: 0
quote__S_220m: !!perl/hash:RE_ast
  decl: []
  kind: token
  min: 12345
  pkg: ~
  re: !!perl/hash:RE_sequence
    a: 0
    dba: quote__S_220m
    i: 0
    min: 12345
    r: 1
    s: 0
    zyg:
    - !!perl/hash:RE_method
      a: 0
      dba: quote__S_220m
      i: 0
      min: 12345
      name: sym
      r: 1
      rest: ''
      s: 0
      sym: m
    - !!perl/hash:RE_meta
      a: 0
      dba: quote__S_220m
      i: 0
      min: 0
      r: 1
      s: 0
      text: 
    - !!perl/hash:RE_assertion
      assert: '!'
      min: 0
      re: !!perl/hash:RE_method_re
        a: 0
        dba: quote__S_220m
        i: 0
        min: 0
        name: before
        nobind: 1
        r: 1
        re: !!perl/hash:RE_ast
          decl: []
          min: 1
          re: !!perl/hash:RE_string
            a: 0
            dba: quote__S_220m
            i: 0
            min: 1
            r: 1
            s: 0
            text: (
        s: 0
    - !!perl/hash:RE_method
      min: 0
      name: quibble
      rest: ( $.cursor_fresh( %*LANG<Regex> ) )
    - !!perl/hash:RE_assertion
      assert: '!'
      min: 0
      re: !!perl/hash:RE_method
        a: 0
        dba: quote__S_220m
        i: 0
        min: 12345
        name: old_rx_mods
        nobind: 1
        r: 1
        rest: ''
        s: 0
quote__S_221mm: !!perl/hash:RE_ast
  decl: []
  kind: token
  min: 12345
  pkg: ~
  re: !!perl/hash:RE_sequence
    a: 0
    dba: quote__S_221mm
    i: 0
    min: 12345
    r: 1
    s: 0
    zyg:
    - !!perl/hash:RE_method
      a: 0
      dba: quote__S_221mm
      i: 0
      min: 12345
      name: sym
      r: 1
      rest: ''
      s: 0
      sym: mm
    - !!perl/hash:RE_meta
      a: 0
      dba: quote__S_221mm
      i: 0
      min: 0
      r: 1
      s: 0
      text: 
    - !!perl/hash:RE_assertion
      assert: '!'
      min: 0
      re: !!perl/hash:RE_method_re
        a: 0
        dba: quote__S_221mm
        i: 0
        min: 0
        name: before
        nobind: 1
        r: 1
        re: !!perl/hash:RE_ast
          decl: []
          min: 1
          re: !!perl/hash:RE_string
            a: 0
            dba: quote__S_221mm
            i: 0
            min: 1
            r: 1
            s: 0
            text: (
        s: 0
    - !!perl/hash:RE_method
      min: 0
      name: quibble
      rest: ( $.cursor_fresh( %*LANG<Regex> ).tweak(:s))
    - !!perl/hash:RE_assertion
      assert: '!'
      min: 0
      re: !!perl/hash:RE_method
        a: 0
        dba: quote__S_221mm
        i: 0
        min: 12345
        name: old_rx_mods
        nobind: 1
        r: 1
        rest: ''
        s: 0
quote__S_222s: !!perl/hash:RE_ast
  decl: []
  kind: token
  min: 12345
  pkg: ~
  re: !!perl/hash:RE_sequence
    a: 0
    dba: quote__S_222s
    i: 0
    min: 12345
    r: 1
    s: 0
    zyg:
    - !!perl/hash:RE_method
      a: 0
      dba: quote__S_222s
      i: 0
      min: 12345
      name: sym
      r: 1
      rest: ''
      s: 0
      sym: s
    - !!perl/hash:RE_meta
      a: 0
      dba: quote__S_222s
      i: 0
      min: 0
      r: 1
      s: 0
      text: 
    - !!perl/hash:RE_assertion
      assert: '!'
      min: 0
      re: !!perl/hash:RE_method_re
        a: 0
        dba: quote__S_222s
        i: 0
        min: 0
        name: before
        nobind: 1
        r: 1
        re: !!perl/hash:RE_ast
          decl: []
          min: 1
          re: !!perl/hash:RE_string
            a: 0
            dba: quote__S_222s
            i: 0
            min: 1
            r: 1
            s: 0
            text: (
        s: 0
    - !!perl/hash:RE_bindnamed
      a: 0
      atom: !!perl/hash:RE_method
        min: 0
        name: sibble
        nobind: 1
        rest: ( $.cursor_fresh( %*LANG<Regex> ), $.cursor_fresh( %*LANG<Q> ).tweak(:qq))
      dba: quote__S_222s
      i: 0
      min: 0
      r: 1
      s: 0
      var: pat
    - !!perl/hash:RE_assertion
      assert: '!'
      min: 0
      re: !!perl/hash:RE_method
        a: 0
        dba: quote__S_222s
        i: 0
        min: 12345
        name: old_rx_mods
        nobind: 1
        r: 1
        rest: ''
        s: 0
quote__S_223ss: !!perl/hash:RE_ast
  decl: []
  kind: token
  min: 12345
  pkg: ~
  re: !!perl/hash:RE_sequence
    a: 0
    dba: quote__S_223ss
    i: 0
    min: 12345
    r: 1
    s: 0
    zyg:
    - !!perl/hash:RE_method
      a: 0
      dba: quote__S_223ss
      i: 0
      min: 12345
      name: sym
      r: 1
      rest: ''
      s: 0
      sym: ss
    - !!perl/hash:RE_meta
      a: 0
      dba: quote__S_223ss
      i: 0
      min: 0
      r: 1
      s: 0
      text: 
    - !!perl/hash:RE_assertion
      assert: '!'
      min: 0
      re: !!perl/hash:RE_method_re
        a: 0
        dba: quote__S_223ss
        i: 0
        min: 0
        name: before
        nobind: 1
        r: 1
        re: !!perl/hash:RE_ast
          decl: []
          min: 1
          re: !!perl/hash:RE_string
            a: 0
            dba: quote__S_223ss
            i: 0
            min: 1
            r: 1
            s: 0
            text: (
        s: 0
    - !!perl/hash:RE_bindnamed
      a: 0
      atom: !!perl/hash:RE_method
        min: 0
        name: sibble
        nobind: 1
        rest: ( $.cursor_fresh( %*LANG<Regex> ).tweak(:s), $.cursor_fresh( %*LANG<Q>
          ).tweak(:qq))
      dba: quote__S_223ss
      i: 0
      min: 0
      r: 1
      s: 0
      var: pat
    - !!perl/hash:RE_assertion
      assert: '!'
      min: 0
      re: !!perl/hash:RE_method
        a: 0
        dba: quote__S_223ss
        i: 0
        min: 12345
        name: old_rx_mods
        nobind: 1
        r: 1
        rest: ''
        s: 0
quote__S_224tr: !!perl/hash:RE_ast
  decl: []
  kind: token
  min: 12345
  pkg: ~
  re: !!perl/hash:RE_sequence
    a: 0
    dba: quote__S_224tr
    i: 0
    min: 12345
    r: 1
    s: 0
    zyg:
    - !!perl/hash:RE_method
      a: 0
      dba: quote__S_224tr
      i: 0
      min: 12345
      name: sym
      r: 1
      rest: ''
      s: 0
      sym: tr
    - !!perl/hash:RE_meta
      a: 0
      dba: quote__S_224tr
      i: 0
      min: 0
      r: 1
      s: 0
      text: 
    - !!perl/hash:RE_assertion
      assert: '!'
      min: 0
      re: !!perl/hash:RE_method_re
        a: 0
        dba: quote__S_224tr
        i: 0
        min: 0
        name: before
        nobind: 1
        r: 1
        re: !!perl/hash:RE_ast
          decl: []
          min: 1
          re: !!perl/hash:RE_string
            a: 0
            dba: quote__S_224tr
            i: 0
            min: 1
            r: 1
            s: 0
            text: (
        s: 0
    - !!perl/hash:RE_bindnamed
      a: 0
      atom: !!perl/hash:RE_method
        min: 0
        name: tribble
        nobind: 1
        rest: ( $.cursor_fresh( %*LANG<Q> ).tweak(:tr))
      dba: quote__S_224tr
      i: 0
      min: 0
      r: 1
      s: 0
      var: pat
    - !!perl/hash:RE_assertion
      assert: '!'
      min: 0
      re: !!perl/hash:RE_method
        a: 0
        dba: quote__S_224tr
        i: 0
        min: 12345
        name: old_tr_mods
        nobind: 1
        r: 1
        rest: ''
        s: 0
quote__S_225y: !!perl/hash:RE_ast
  decl: []
  kind: token
  min: 12345
  pkg: ~
  re: !!perl/hash:RE_sequence
    a: 0
    dba: quote__S_225y
    i: 0
    min: 12345
    r: 1
    s: 0
    zyg:
    - !!perl/hash:RE_method
      a: 0
      dba: quote__S_225y
      i: 0
      min: 12345
      name: sym
      r: 1
      rest: ''
      s: 0
      sym: y
    - !!perl/hash:RE_meta
      a: 0
      dba: quote__S_225y
      i: 0
      min: 0
      r: 1
      s: 0
      text: 
    - !!perl/hash:RE_assertion
      assert: '!'
      min: 0
      re: !!perl/hash:RE_block
        a: 0
        context: bool
        dba: quote__S_225y
        i: 0
        min: 0
        nobind: 1
        r: 1
        s: 0
        text: ' self.is_known(''&y'') or self.is_known(''y'') '
    - !!perl/hash:RE_assertion
      assert: '!'
      min: 0
      re: !!perl/hash:RE_method_re
        a: 0
        dba: quote__S_225y
        i: 0
        min: 0
        name: before
        nobind: 1
        r: 1
        re: !!perl/hash:RE_ast
          decl: []
          min: 1
          re: !!perl/hash:RE_string
            a: 0
            dba: quote__S_225y
            i: 0
            min: 1
            r: 1
            s: 0
            text: (
        s: 0
    - !!perl/hash:RE_assertion
      assert: '?'
      min: 0
      re: !!perl/hash:RE_method_re
        a: 0
        dba: quote__S_225y
        i: 0
        min: 0
        name: before
        nobind: 1
        r: 1
        re: !!perl/hash:RE_ast
          decl: []
          min: 1
          re: !!perl/hash:RE_sequence
            a: 0
            dba: quote__S_225y
            i: 0
            min: 1
            r: 1
            s: 0
            zyg:
            - !!perl/hash:RE_quantified_atom
              atom: !!perl/hash:RE_meta
                a: 0
                dba: quote__S_225y
                i: 0
                min: 1
                r: 1
                s: 0
                text: \h
              min: 0
              quant:
              - '*'
              - ':'
              - ''
              - 0
            - !!perl/hash:RE_meta
              a: 0
              dba: quote__S_225y
              i: 0
              min: 1
              r: 1
              s: 0
              text: \W
        s: 0
    - !!perl/hash:RE_method
      min: 0
      name: obs
      nobind: 1
      rest: ('y///','tr///')
quote__S_226quasi: !!perl/hash:RE_ast
  decl: []
  kind: token
  min: 12345
  pkg: ~
  re: !!perl/hash:RE_sequence
    a: 0
    dba: quote__S_226quasi
    i: 0
    min: 12345
    r: 1
    s: 0
    zyg:
    - !!perl/hash:RE_method
      a: 0
      dba: quote__S_226quasi
      i: 0
      min: 12345
      name: sym
      r: 1
      rest: ''
      s: 0
      sym: quasi
    - !!perl/hash:RE_meta
      a: 0
      dba: quote__S_226quasi
      i: 0
      min: 0
      r: 1
      s: 0
      text: 
    - !!perl/hash:RE_assertion
      assert: '!'
      min: 0
      re: !!perl/hash:RE_method_re
        a: 0
        dba: quote__S_226quasi
        i: 0
        min: 0
        name: before
        nobind: 1
        r: 1
        re: !!perl/hash:RE_ast
          decl: []
          min: 1
          re: !!perl/hash:RE_string
            a: 0
            dba: quote__S_226quasi
            i: 0
            min: 1
            r: 1
            s: 0
            text: (
        s: 0
    - !!perl/hash:RE_method
      min: 0
      name: quasiquibble
      rest: ($.cursor_fresh( %*LANG<Quasi> ))
quote_mod__S_208w: !!perl/hash:RE_ast
  decl: []
  kind: token
  min: 12345
  pkg: ~
  re: !!perl/hash:RE_method
    a: 0
    dba: quote_mod__S_208w
    i: 0
    min: 12345
    name: sym
    r: 1
    rest: ''
    s: 0
    sym: w
quote_mod__S_209ww: !!perl/hash:RE_ast
  decl: []
  kind: token
  min: 12345
  pkg: ~
  re: !!perl/hash:RE_method
    a: 0
    dba: quote_mod__S_209ww
    i: 0
    min: 12345
    name: sym
    r: 1
    rest: ''
    s: 0
    sym: ww
quote_mod__S_210p: !!perl/hash:RE_ast
  decl: []
  kind: token
  min: 12345
  pkg: ~
  re: !!perl/hash:RE_method
    a: 0
    dba: quote_mod__S_210p
    i: 0
    min: 12345
    name: sym
    r: 1
    rest: ''
    s: 0
    sym: p
quote_mod__S_211x: !!perl/hash:RE_ast
  decl: []
  kind: token
  min: 12345
  pkg: ~
  re: !!perl/hash:RE_method
    a: 0
    dba: quote_mod__S_211x
    i: 0
    min: 12345
    name: sym
    r: 1
    rest: ''
    s: 0
    sym: x
quote_mod__S_212to: !!perl/hash:RE_ast
  decl: []
  kind: token
  min: 12345
  pkg: ~
  re: !!perl/hash:RE_method
    a: 0
    dba: quote_mod__S_212to
    i: 0
    min: 12345
    name: sym
    r: 1
    rest: ''
    s: 0
    sym: to
quote_mod__S_213s: !!perl/hash:RE_ast
  decl: []
  kind: token
  min: 12345
  pkg: ~
  re: !!perl/hash:RE_method
    a: 0
    dba: quote_mod__S_213s
    i: 0
    min: 12345
    name: sym
    r: 1
    rest: ''
    s: 0
    sym: s
quote_mod__S_214a: !!perl/hash:RE_ast
  decl: []
  kind: token
  min: 12345
  pkg: ~
  re: !!perl/hash:RE_method
    a: 0
    dba: quote_mod__S_214a
    i: 0
    min: 12345
    name: sym
    r: 1
    rest: ''
    s: 0
    sym: a
quote_mod__S_215h: !!perl/hash:RE_ast
  decl: []
  kind: token
  min: 12345
  pkg: ~
  re: !!perl/hash:RE_method
    a: 0
    dba: quote_mod__S_215h
    i: 0
    min: 12345
    name: sym
    r: 1
    rest: ''
    s: 0
    sym: h
quote_mod__S_216f: !!perl/hash:RE_ast
  decl: []
  kind: token
  min: 12345
  pkg: ~
  re: !!perl/hash:RE_method
    a: 0
    dba: quote_mod__S_216f
    i: 0
    min: 12345
    name: sym
    r: 1
    rest: ''
    s: 0
    sym: f
quote_mod__S_217c: !!perl/hash:RE_ast
  decl: []
  kind: token
  min: 12345
  pkg: ~
  re: !!perl/hash:RE_method
    a: 0
    dba: quote_mod__S_217c
    i: 0
    min: 12345
    name: sym
    r: 1
    rest: ''
    s: 0
    sym: c
quote_mod__S_218b: !!perl/hash:RE_ast
  decl: []
  kind: token
  min: 12345
  pkg: ~
  re: !!perl/hash:RE_method
    a: 0
    dba: quote_mod__S_218b
    i: 0
    min: 12345
    name: sym
    r: 1
    rest: ''
    s: 0
    sym: b
regex_block: !!perl/hash:RE_ast
  decl:
  - !!perl/hash:RE_decl
    a: 0
    dba: regex_block
    i: 0
    max: 0
    min: 0
    r: 1
    s: 0
    text: temp %*LANG
  - !!perl/hash:RE_decl
    a: 0
    dba: regex_block
    i: 0
    max: 0
    min: 0
    r: 1
    s: 0
    text: my $lang = %*LANG<Regex>
  - !!perl/hash:RE_decl
    a: 0
    dba: regex_block
    i: 0
    max: 0
    min: 0
    r: 1
    s: 0
    text: my $*GOAL ::= '}'
  kind: token
  min: 12346
  pkg: ~
  re: !!perl/hash:RE_sequence
    a: 0
    dba: regex_block
    i: 0
    min: 12346
    r: 1
    s: 0
    zyg:
    - !!perl/hash:RE_quantified_atom
      atom: !!perl/hash:RE_bracket
        decl: []
        min: 24690
        re: !!perl/hash:RE_sequence
          a: 0
          dba: regex_block
          i: 0
          min: 24690
          r: 1
          s: 0
          zyg:
          - !!perl/hash:RE_method
            a: 0
            dba: regex_block
            i: 0
            min: 12345
            name: quotepair
            r: 1
            rest: ''
            s: 0
          - !!perl/hash:RE_method
            a: 0
            dba: regex_block
            i: 0
            min: 12345
            name: ws
            nobind: 1
            r: 1
            rest: ''
            s: 0
          - !!perl/hash:RE_block
            a: 0
            context: void
            dba: regex_block
            i: 0
            min: 0
            r: 1
            s: 0
            text: "\n                my $kv = $<quotepair>[*-1];\n                $lang
              = $lang.tweak($kv.<k>, $kv.<v>)\n                    or self.panic(\"Unrecognized
              adverb :\" ~ $kv.<k> ~ '(' ~ $kv.<v> ~ ')');\n            "
      min: 0
      quant:
      - '*'
      - ':'
      - ''
      - 0
    - !!perl/hash:RE_string
      a: 0
      dba: regex_block
      i: 0
      min: 1
      r: 1
      s: 0
      text: '{'
    - !!perl/hash:RE_method
      min: 0
      name: nibble
      rest: ( $.cursor_fresh($lang).unbalanced('}') )
    - !!perl/hash:RE_bracket
      decl: []
      min: 0
      re: !!perl/hash:RE_first
        a: 0
        dba: regex_block
        i: 0
        min: 0
        r: 1
        s: 0
        zyg:
        - !!perl/hash:RE_string
          a: 0
          dba: regex_block
          i: 0
          min: 1
          r: 1
          s: 0
          text: '}'
        - !!perl/hash:RE_method
          min: 0
          name: panic
          nobind: 1
          rest: ("Unable to parse regex; couldn't find right brace")
    - !!perl/hash:RE_method
      a: 0
      dba: regex_block
      i: 0
      min: 12345
      name: curlycheck
      nobind: 1
      r: 1
      rest: ''
      s: 0
regex_declarator__S_128regex: !!perl/hash:RE_ast
  decl: []
  kind: token
  min: 37035
  pkg: ~
  re: !!perl/hash:RE_sequence
    a: 0
    dba: regex_declarator__S_128regex
    i: 0
    min: 37035
    r: 1
    s: 0
    zyg:
    - !!perl/hash:RE_method
      a: 0
      dba: regex_declarator__S_128regex
      endsym: spacey
      i: 0
      min: 12345
      name: sym
      r: 1
      rest: ''
      s: 0
      sym: regex
    - !!perl/hash:RE_method
      a: 0
      dba: regex_declarator__S_128regex
      i: 0
      min: 12345
      name: spacey
      nobind: 1
      r: 1
      rest: ''
      s: 0
    - !!perl/hash:RE_method
      a: 0
      dba: regex_declarator__S_128regex
      i: 0
      min: 12345
      name: regex_def
      r: 1
      rest: ''
      s: 0
regex_declarator__S_129token: !!perl/hash:RE_ast
  decl: []
  kind: token
  min: 37035
  pkg: ~
  re: !!perl/hash:RE_sequence
    a: 0
    dba: regex_declarator__S_129token
    i: 0
    min: 37035
    r: 1
    s: 0
    zyg:
    - !!perl/hash:RE_method
      a: 0
      dba: regex_declarator__S_129token
      endsym: spacey
      i: 0
      min: 12345
      name: sym
      r: 1
      rest: ''
      s: 0
      sym: token
    - !!perl/hash:RE_method
      a: 0
      dba: regex_declarator__S_129token
      i: 0
      min: 12345
      name: spacey
      nobind: 1
      r: 1
      rest: ''
      s: 0
    - !!perl/hash:RE_method
      a: 0
      dba: regex_declarator__S_129token
      i: 0
      min: 12345
      name: regex_def
      r: 1
      rest: ''
      s: 0
regex_declarator__S_130rule: !!perl/hash:RE_ast
  decl: []
  kind: token
  min: 37035
  pkg: ~
  re: !!perl/hash:RE_sequence
    a: 0
    dba: regex_declarator__S_130rule
    i: 0
    min: 37035
    r: 1
    s: 0
    zyg:
    - !!perl/hash:RE_method
      a: 0
      dba: regex_declarator__S_130rule
      endsym: spacey
      i: 0
      min: 12345
      name: sym
      r: 1
      rest: ''
      s: 0
      sym: rule
    - !!perl/hash:RE_method
      a: 0
      dba: regex_declarator__S_130rule
      i: 0
      min: 12345
      name: spacey
      nobind: 1
      r: 1
      rest: ''
      s: 0
    - !!perl/hash:RE_method
      a: 0
      dba: regex_declarator__S_130rule
      i: 0
      min: 12345
      name: regex_def
      r: 1
      rest: ''
      s: 0
regex_def: !!perl/hash:RE_ast
  decl:
  - !!perl/hash:RE_decl
    a: 0
    dba: regex_def
    i: 0
    max: 0
    min: 0
    r: 1
    s: 1
    text: temp $*CURPAD
  - !!perl/hash:RE_decl
    a: 0
    dba: regex_def
    i: 0
    max: 0
    min: 0
    r: 1
    s: 1
    text: my $*IN_DECL = 'regex'
  - !!perl/hash:RE_decl
    a: 0
    dba: regex_def
    i: 0
    max: 0
    min: 0
    r: 1
    s: 1
    text: my $*DECLARAND
  kind: rule
  min: 0
  pkg: ~
  re: !!perl/hash:RE_first
    a: 0
    dba: regex_def
    i: 0
    min: 0
    r: 1
    s: 1
    zyg:
    - !!perl/hash:RE_sequence
      a: 0
      dba: regex_def
      i: 0
      min: 49380
      r: 1
      s: 1
      zyg:
      - !!perl/hash:RE_method
        min: 0
        name: ws
        nobind: 1
        noquant: 1
        rest: ''
      - !!perl/hash:RE_bracket
        decl: []
        min: 49380
        re: !!perl/hash:RE_sequence
          a: 0
          dba: regex_def
          i: 0
          min: 49380
          r: 1
          s: 0
          zyg:
          - !!perl/hash:RE_quantified_atom
            atom: !!perl/hash:RE_bracket
              decl: []
              min: 1
              re: &60 !!perl/hash:RE_any
                a: 0
                altname: regex_def_02
                dba: regex_def
                i: 0
                min: 1
                name: regex_def_02
                r: 1
                s: 1
                zyg:
                - !!perl/hash:RE_sequence
                  a: 0
                  alt: regex_def_02 0
                  dba: regex_def
                  i: 0
                  min: 1
                  r: 1
                  s: 1
                  zyg:
                  - !!perl/hash:RE_method
                    min: 0
                    name: ws
                    nobind: 1
                    noquant: 1
                    rest: ''
                  - !!perl/hash:RE_string
                    a: 0
                    dba: regex_def
                    i: 0
                    min: 1
                    r: 1
                    s: 1
                    text: '&'
                  - !!perl/hash:RE_quantified_atom
                    atom: !!perl/hash:RE_method
                      a: 0
                      dba: regex_def
                      i: 0
                      min: 12345
                      name: deflongname
                      r: 1
                      rest: ''
                      s: 1
                    min: 0
                    quant:
                    - '?'
                    - ':'
                    - ''
                    - 0
                  - !!perl/hash:RE_method
                    min: 0
                    name: ws
                    nobind: 1
                    noquant: 1
                    rest: ''
                - !!perl/hash:RE_sequence
                  a: 0
                  alt: regex_def_02 1
                  dba: regex_def
                  i: 0
                  min: 12345
                  r: 1
                  s: 1
                  zyg:
                  - !!perl/hash:RE_method
                    min: 0
                    name: ws
                    nobind: 1
                    noquant: 1
                    rest: ''
                  - !!perl/hash:RE_method
                    a: 0
                    dba: regex_def
                    i: 0
                    min: 12345
                    name: deflongname
                    r: 1
                    rest: ''
                    s: 1
                  - !!perl/hash:RE_method
                    min: 0
                    name: ws
                    nobind: 1
                    noquant: 1
                    rest: ''
            min: 0
            quant:
            - '?'
            - ':'
            - ''
            - 0
          - !!perl/hash:RE_method
            min: 0
            name: ws
            nobind: 1
            noquant: 1
            rest: ''
          - !!perl/hash:RE_method
            min: 0
            name: newpad
            nobind: 1
            rest: (1)
          - !!perl/hash:RE_method
            min: 0
            name: ws
            nobind: 1
            noquant: 1
            rest: ''
          - !!perl/hash:RE_quantified_atom
            atom: !!perl/hash:RE_bracket
              decl: []
              min: 2
              re: &61 !!perl/hash:RE_any
                a: 0
                altname: regex_def_03
                dba: regex_def
                i: 0
                min: 2
                name: regex_def_03
                r: 1
                s: 1
                zyg:
                - !!perl/hash:RE_sequence
                  a: 0
                  alt: regex_def_03 0
                  dba: regex_def
                  i: 0
                  min: 2
                  r: 1
                  s: 1
                  zyg:
                  - !!perl/hash:RE_method
                    min: 0
                    name: ws
                    nobind: 1
                    noquant: 1
                    rest: ''
                  - !!perl/hash:RE_bracket
                    decl: []
                    min: 2
                    re: !!perl/hash:RE_sequence
                      a: 0
                      dba: regex_def
                      i: 0
                      min: 2
                      r: 1
                      s: 1
                      zyg:
                      - !!perl/hash:RE_quantified_atom
                        atom: !!perl/hash:RE_string
                          a: 0
                          dba: regex_def
                          i: 0
                          min: 1
                          r: 1
                          s: 1
                          text: ':'
                        min: 0
                        quant:
                        - '?'
                        - ':'
                        - ''
                        - 0
                      - !!perl/hash:RE_string
                        a: 0
                        dba: regex_def
                        i: 0
                        min: 1
                        r: 1
                        s: 1
                        text: (
                      - !!perl/hash:RE_method
                        min: 0
                        name: ws
                        nobind: 1
                        noquant: 1
                        rest: ''
                      - !!perl/hash:RE_method
                        min: 0
                        name: signature
                        rest: (1)
                      - !!perl/hash:RE_method
                        min: 0
                        name: ws
                        nobind: 1
                        noquant: 1
                        rest: ''
                      - !!perl/hash:RE_string
                        a: 0
                        dba: regex_def
                        i: 0
                        min: 1
                        r: 1
                        s: 1
                        text: )
                  - !!perl/hash:RE_method
                    min: 0
                    name: ws
                    nobind: 1
                    noquant: 1
                    rest: ''
                - !!perl/hash:RE_sequence
                  a: 0
                  alt: regex_def_03 1
                  dba: regex_def
                  i: 0
                  min: 12345
                  r: 1
                  s: 1
                  zyg:
                  - !!perl/hash:RE_method
                    min: 0
                    name: ws
                    nobind: 1
                    noquant: 1
                    rest: ''
                  - !!perl/hash:RE_method
                    a: 0
                    dba: regex_def
                    i: 0
                    min: 12345
                    name: trait
                    r: 1
                    rest: ''
                    s: 1
                  - !!perl/hash:RE_method
                    min: 0
                    name: ws
                    nobind: 1
                    noquant: 1
                    rest: ''
            min: 0
            quant:
            - '*'
            - ':'
            - ''
            - 0
          - !!perl/hash:RE_method
            min: 0
            name: ws
            nobind: 1
            noquant: 1
            rest: ''
          - !!perl/hash:RE_block
            a: 0
            context: void
            dba: regex_def
            i: 0
            min: 0
            r: 1
            s: 1
            text: ' $*IN_DECL = ''''; '
          - !!perl/hash:RE_method
            min: 0
            name: ws
            nobind: 1
            noquant: 1
            rest: ''
          - !!perl/hash:RE_method
            a: 0
            dba: regex_def
            i: 0
            min: 12345
            name: finishpad
            nobind: 1
            r: 1
            rest: ''
            s: 1
          - !!perl/hash:RE_method
            min: 0
            name: ws
            nobind: 1
            noquant: 1
            rest: ''
          - !!perl/hash:RE_method
            a: 0
            dba: regex_def
            i: 0
            min: 12345
            name: regex_block
            r: 1
            rest: ''
            s: 1
          - !!perl/hash:RE_method
            a: 0
            dba: regex_def
            i: 0
            min: 12345
            name: getsig
            nobind: 1
            r: 1
            rest: ''
            s: 0
          - !!perl/hash:RE_method
            a: 0
            dba: regex_def
            i: 0
            min: 12345
            name: getdecl
            nobind: 1
            r: 1
            rest: ''
            s: 0
      - !!perl/hash:RE_method
        min: 0
        name: ws
        nobind: 1
        noquant: 1
        rest: ''
    - !!perl/hash:RE_sequence
      a: 0
      dba: regex_def
      i: 0
      min: 0
      r: 1
      s: 1
      zyg:
      - !!perl/hash:RE_method
        min: 0
        name: ws
        nobind: 1
        noquant: 1
        rest: ''
      - !!perl/hash:RE_method
        min: 0
        name: panic
        nobind: 1
        rest: ("Malformed regex")
      - !!perl/hash:RE_method
        min: 0
        name: ws
        nobind: 1
        noquant: 1
        rest: ''
regex_def_02: *60
regex_def_03: *61
routine_declarator__S_124sub: !!perl/hash:RE_ast
  decl: []
  kind: token
  min: 37035
  pkg: ~
  re: !!perl/hash:RE_sequence
    a: 0
    dba: routine_declarator__S_124sub
    i: 0
    min: 37035
    r: 1
    s: 0
    zyg:
    - !!perl/hash:RE_method
      a: 0
      dba: routine_declarator__S_124sub
      endsym: nofun
      i: 0
      min: 12345
      name: sym
      r: 1
      rest: ''
      s: 0
      sym: sub
    - !!perl/hash:RE_method
      a: 0
      dba: routine_declarator__S_124sub
      i: 0
      min: 12345
      name: nofun
      nobind: 1
      r: 1
      rest: ''
      s: 0
    - !!perl/hash:RE_method
      a: 0
      dba: routine_declarator__S_124sub
      i: 0
      min: 12345
      name: routine_def
      r: 1
      rest: ''
      s: 0
routine_declarator__S_125method: !!perl/hash:RE_ast
  decl: []
  kind: token
  min: 37035
  pkg: ~
  re: !!perl/hash:RE_sequence
    a: 0
    dba: routine_declarator__S_125method
    i: 0
    min: 37035
    r: 1
    s: 0
    zyg:
    - !!perl/hash:RE_method
      a: 0
      dba: routine_declarator__S_125method
      endsym: nofun
      i: 0
      min: 12345
      name: sym
      r: 1
      rest: ''
      s: 0
      sym: method
    - !!perl/hash:RE_method
      a: 0
      dba: routine_declarator__S_125method
      i: 0
      min: 12345
      name: nofun
      nobind: 1
      r: 1
      rest: ''
      s: 0
    - !!perl/hash:RE_method
      a: 0
      dba: routine_declarator__S_125method
      i: 0
      min: 12345
      name: method_def
      r: 1
      rest: ''
      s: 0
routine_declarator__S_126submethod: !!perl/hash:RE_ast
  decl: []
  kind: token
  min: 37035
  pkg: ~
  re: !!perl/hash:RE_sequence
    a: 0
    dba: routine_declarator__S_126submethod
    i: 0
    min: 37035
    r: 1
    s: 0
    zyg:
    - !!perl/hash:RE_method
      a: 0
      dba: routine_declarator__S_126submethod
      endsym: nofun
      i: 0
      min: 12345
      name: sym
      r: 1
      rest: ''
      s: 0
      sym: submethod
    - !!perl/hash:RE_method
      a: 0
      dba: routine_declarator__S_126submethod
      i: 0
      min: 12345
      name: nofun
      nobind: 1
      r: 1
      rest: ''
      s: 0
    - !!perl/hash:RE_method
      a: 0
      dba: routine_declarator__S_126submethod
      i: 0
      min: 12345
      name: method_def
      r: 1
      rest: ''
      s: 0
routine_declarator__S_127macro: !!perl/hash:RE_ast
  decl: []
  kind: token
  min: 37035
  pkg: ~
  re: !!perl/hash:RE_sequence
    a: 0
    dba: routine_declarator__S_127macro
    i: 0
    min: 37035
    r: 1
    s: 0
    zyg:
    - !!perl/hash:RE_method
      a: 0
      dba: routine_declarator__S_127macro
      endsym: nofun
      i: 0
      min: 12345
      name: sym
      r: 1
      rest: ''
      s: 0
      sym: macro
    - !!perl/hash:RE_method
      a: 0
      dba: routine_declarator__S_127macro
      i: 0
      min: 12345
      name: nofun
      nobind: 1
      r: 1
      rest: ''
      s: 0
    - !!perl/hash:RE_method
      a: 0
      dba: routine_declarator__S_127macro
      i: 0
      min: 12345
      name: macro_def
      r: 1
      rest: ''
      s: 0
routine_def: !!perl/hash:RE_ast
  decl:
  - !!perl/hash:RE_decl
    a: 0
    dba: routine_def
    i: 0
    max: 0
    min: 0
    r: 1
    s: 1
    text: temp $*CURPAD
  - !!perl/hash:RE_decl
    a: 0
    dba: routine_def
    i: 0
    max: 0
    min: 0
    r: 1
    s: 1
    text: my $*IN_DECL = 'routine'
  - !!perl/hash:RE_decl
    a: 0
    dba: routine_def
    i: 0
    max: 0
    min: 0
    r: 1
    s: 1
    text: my $*DECLARAND
  kind: rule
  min: 0
  pkg: ~
  re: !!perl/hash:RE_first
    a: 0
    dba: routine_def
    i: 0
    min: 0
    r: 1
    s: 1
    zyg:
    - !!perl/hash:RE_sequence
      a: 0
      dba: routine_def
      i: 0
      min: 49380
      r: 1
      s: 1
      zyg:
      - !!perl/hash:RE_method
        min: 0
        name: ws
        nobind: 1
        noquant: 1
        rest: ''
      - !!perl/hash:RE_bracket
        decl: []
        min: 49380
        re: !!perl/hash:RE_sequence
          a: 0
          dba: routine_def
          i: 0
          min: 49380
          r: 1
          s: 0
          zyg:
          - !!perl/hash:RE_quantified_atom
            atom: !!perl/hash:RE_bracket
              decl: []
              min: 1
              re: &62 !!perl/hash:RE_any
                a: 0
                altname: routine_def_02
                dba: routine_def
                i: 0
                min: 1
                name: routine_def_02
                r: 1
                s: 1
                zyg:
                - !!perl/hash:RE_sequence
                  a: 0
                  alt: routine_def_02 0
                  dba: routine_def
                  i: 0
                  min: 1
                  r: 1
                  s: 1
                  zyg:
                  - !!perl/hash:RE_method
                    min: 0
                    name: ws
                    nobind: 1
                    noquant: 1
                    rest: ''
                  - !!perl/hash:RE_bindnamed
                    a: 0
                    atom: !!perl/hash:RE_bracket
                      decl: []
                      min: 1
                      re: !!perl/hash:RE_sequence
                        a: 0
                        dba: routine_def
                        i: 0
                        min: 1
                        r: 1
                        s: 1
                        zyg:
                        - !!perl/hash:RE_string
                          a: 0
                          dba: routine_def
                          i: 0
                          min: 1
                          r: 1
                          s: 1
                          text: '&'
                        - !!perl/hash:RE_quantified_atom
                          atom: !!perl/hash:RE_string
                            a: 0
                            dba: routine_def
                            i: 0
                            min: 1
                            r: 1
                            s: 1
                            text: '*'
                          min: 0
                          quant:
                          - '?'
                          - ':'
                          - ''
                          - 0
                    dba: routine_def
                    i: 0
                    min: 1
                    r: 1
                    s: 1
                    var: sigil
                  - !!perl/hash:RE_method
                    min: 0
                    name: ws
                    nobind: 1
                    noquant: 1
                    rest: ''
                  - !!perl/hash:RE_quantified_atom
                    atom: !!perl/hash:RE_method
                      a: 0
                      dba: routine_def
                      i: 0
                      min: 12345
                      name: deflongname
                      r: 1
                      rest: ''
                      s: 1
                    min: 0
                    quant:
                    - '?'
                    - ':'
                    - ''
                    - 0
                  - !!perl/hash:RE_method
                    min: 0
                    name: ws
                    nobind: 1
                    noquant: 1
                    rest: ''
                - !!perl/hash:RE_sequence
                  a: 0
                  alt: routine_def_02 1
                  dba: routine_def
                  i: 0
                  min: 12345
                  r: 1
                  s: 1
                  zyg:
                  - !!perl/hash:RE_method
                    min: 0
                    name: ws
                    nobind: 1
                    noquant: 1
                    rest: ''
                  - !!perl/hash:RE_method
                    a: 0
                    dba: routine_def
                    i: 0
                    min: 12345
                    name: deflongname
                    r: 1
                    rest: ''
                    s: 1
                  - !!perl/hash:RE_method
                    min: 0
                    name: ws
                    nobind: 1
                    noquant: 1
                    rest: ''
            min: 0
            quant:
            - '?'
            - ':'
            - ''
            - 0
          - !!perl/hash:RE_method
            min: 0
            name: ws
            nobind: 1
            noquant: 1
            rest: ''
          - !!perl/hash:RE_method
            min: 0
            name: newpad
            nobind: 1
            rest: (1)
          - !!perl/hash:RE_method
            min: 0
            name: ws
            nobind: 1
            noquant: 1
            rest: ''
          - !!perl/hash:RE_quantified_atom
            atom: !!perl/hash:RE_bracket
              decl: []
              min: 12345
              re: &63 !!perl/hash:RE_any
                a: 0
                altname: routine_def_04
                dba: routine_def
                i: 0
                min: 12345
                name: routine_def_04
                r: 1
                s: 1
                zyg:
                - !!perl/hash:RE_sequence
                  a: 0
                  alt: routine_def_04 0
                  dba: routine_def
                  i: 0
                  min: 12345
                  r: 1
                  s: 1
                  zyg:
                  - !!perl/hash:RE_method
                    min: 0
                    name: ws
                    nobind: 1
                    noquant: 1
                    rest: ''
                  - !!perl/hash:RE_method
                    a: 0
                    dba: routine_def
                    i: 0
                    min: 12345
                    name: multisig
                    r: 1
                    rest: ''
                    s: 1
                  - !!perl/hash:RE_method
                    min: 0
                    name: ws
                    nobind: 1
                    noquant: 1
                    rest: ''
                - !!perl/hash:RE_sequence
                  a: 0
                  alt: routine_def_04 1
                  dba: routine_def
                  i: 0
                  min: 12345
                  r: 1
                  s: 1
                  zyg:
                  - !!perl/hash:RE_method
                    min: 0
                    name: ws
                    nobind: 1
                    noquant: 1
                    rest: ''
                  - !!perl/hash:RE_method
                    a: 0
                    dba: routine_def
                    i: 0
                    min: 12345
                    name: trait
                    r: 1
                    rest: ''
                    s: 1
                  - !!perl/hash:RE_method
                    min: 0
                    name: ws
                    nobind: 1
                    noquant: 1
                    rest: ''
            min: 0
            quant:
            - '*'
            - ':'
            - ''
            - 0
          - !!perl/hash:RE_method
            min: 0
            name: ws
            nobind: 1
            noquant: 1
            rest: ''
          - !!perl/hash:RE_assertion
            assert: '!'
            min: 0
            re: !!perl/hash:RE_block
              a: 0
              context: bool
              dba: routine_def
              i: 0
              min: 0
              nobind: 1
              r: 1
              s: 1
              text: "\n                $*IN_DECL = '';\n            "
          - !!perl/hash:RE_method
            min: 0
            name: ws
            nobind: 1
            noquant: 1
            rest: ''
          - !!perl/hash:RE_method
            a: 0
            dba: routine_def
            i: 0
            min: 12345
            name: blockoid
            r: 1
            rest: ''
            s: 1
          - !!perl/hash:RE_method
            a: 0
            dba: routine_def
            i: 0
            min: 12345
            name: checkyada
            nobind: 1
            r: 1
            rest: ''
            s: 0
          - !!perl/hash:RE_method
            a: 0
            dba: routine_def
            i: 0
            min: 12345
            name: getsig
            nobind: 1
            r: 1
            rest: ''
            s: 0
          - !!perl/hash:RE_method
            a: 0
            dba: routine_def
            i: 0
            min: 12345
            name: getdecl
            nobind: 1
            r: 1
            rest: ''
            s: 0
      - !!perl/hash:RE_method
        min: 0
        name: ws
        nobind: 1
        noquant: 1
        rest: ''
    - !!perl/hash:RE_sequence
      a: 0
      dba: routine_def
      i: 0
      min: 0
      r: 1
      s: 1
      zyg:
      - !!perl/hash:RE_method
        min: 0
        name: ws
        nobind: 1
        noquant: 1
        rest: ''
      - !!perl/hash:RE_method
        min: 0
        name: panic
        nobind: 1
        rest: ("Malformed routine")
      - !!perl/hash:RE_method
        min: 0
        name: ws
        nobind: 1
        noquant: 1
        rest: ''
routine_def_02: *62
routine_def_04: *63
scope_declarator__S_103my: !!perl/hash:RE_ast
  decl: []
  kind: token
  min: 24690
  pkg: ~
  re: !!perl/hash:RE_sequence
    a: 0
    dba: scope_declarator__S_103my
    i: 0
    min: 24690
    r: 1
    s: 0
    zyg:
    - !!perl/hash:RE_method
      a: 0
      dba: scope_declarator__S_103my
      endsym: nofun
      i: 0
      min: 12345
      name: sym
      r: 1
      rest: ''
      s: 0
      sym: my
    - !!perl/hash:RE_method
      a: 0
      dba: scope_declarator__S_103my
      i: 0
      min: 12345
      name: nofun
      nobind: 1
      r: 1
      rest: ''
      s: 0
    - !!perl/hash:RE_method
      min: 0
      name: scoped
      rest: ('my')
scope_declarator__S_104our: !!perl/hash:RE_ast
  decl: []
  kind: token
  min: 24690
  pkg: ~
  re: !!perl/hash:RE_sequence
    a: 0
    dba: scope_declarator__S_104our
    i: 0
    min: 24690
    r: 1
    s: 0
    zyg:
    - !!perl/hash:RE_method
      a: 0
      dba: scope_declarator__S_104our
      endsym: nofun
      i: 0
      min: 12345
      name: sym
      r: 1
      rest: ''
      s: 0
      sym: our
    - !!perl/hash:RE_method
      a: 0
      dba: scope_declarator__S_104our
      i: 0
      min: 12345
      name: nofun
      nobind: 1
      r: 1
      rest: ''
      s: 0
    - !!perl/hash:RE_method
      min: 0
      name: scoped
      rest: ('our')
scope_declarator__S_105anon: !!perl/hash:RE_ast
  decl: []
  kind: token
  min: 24690
  pkg: ~
  re: !!perl/hash:RE_sequence
    a: 0
    dba: scope_declarator__S_105anon
    i: 0
    min: 24690
    r: 1
    s: 0
    zyg:
    - !!perl/hash:RE_method
      a: 0
      dba: scope_declarator__S_105anon
      endsym: nofun
      i: 0
      min: 12345
      name: sym
      r: 1
      rest: ''
      s: 0
      sym: anon
    - !!perl/hash:RE_method
      a: 0
      dba: scope_declarator__S_105anon
      i: 0
      min: 12345
      name: nofun
      nobind: 1
      r: 1
      rest: ''
      s: 0
    - !!perl/hash:RE_method
      min: 0
      name: scoped
      rest: ('anon')
scope_declarator__S_106state: !!perl/hash:RE_ast
  decl: []
  kind: token
  min: 24690
  pkg: ~
  re: !!perl/hash:RE_sequence
    a: 0
    dba: scope_declarator__S_106state
    i: 0
    min: 24690
    r: 1
    s: 0
    zyg:
    - !!perl/hash:RE_method
      a: 0
      dba: scope_declarator__S_106state
      endsym: nofun
      i: 0
      min: 12345
      name: sym
      r: 1
      rest: ''
      s: 0
      sym: state
    - !!perl/hash:RE_method
      a: 0
      dba: scope_declarator__S_106state
      i: 0
      min: 12345
      name: nofun
      nobind: 1
      r: 1
      rest: ''
      s: 0
    - !!perl/hash:RE_method
      min: 0
      name: scoped
      rest: ('state')
scope_declarator__S_107has: !!perl/hash:RE_ast
  decl: []
  kind: token
  min: 24690
  pkg: ~
  re: !!perl/hash:RE_sequence
    a: 0
    dba: scope_declarator__S_107has
    i: 0
    min: 24690
    r: 1
    s: 0
    zyg:
    - !!perl/hash:RE_method
      a: 0
      dba: scope_declarator__S_107has
      endsym: nofun
      i: 0
      min: 12345
      name: sym
      r: 1
      rest: ''
      s: 0
      sym: has
    - !!perl/hash:RE_method
      a: 0
      dba: scope_declarator__S_107has
      i: 0
      min: 12345
      name: nofun
      nobind: 1
      r: 1
      rest: ''
      s: 0
    - !!perl/hash:RE_method
      min: 0
      name: scoped
      rest: ('has')
scope_declarator__S_108augment: !!perl/hash:RE_ast
  decl: []
  kind: token
  min: 24690
  pkg: ~
  re: !!perl/hash:RE_sequence
    a: 0
    dba: scope_declarator__S_108augment
    i: 0
    min: 24690
    r: 1
    s: 0
    zyg:
    - !!perl/hash:RE_method
      a: 0
      dba: scope_declarator__S_108augment
      endsym: nofun
      i: 0
      min: 12345
      name: sym
      r: 1
      rest: ''
      s: 0
      sym: augment
    - !!perl/hash:RE_method
      a: 0
      dba: scope_declarator__S_108augment
      i: 0
      min: 12345
      name: nofun
      nobind: 1
      r: 1
      rest: ''
      s: 0
    - !!perl/hash:RE_method
      min: 0
      name: scoped
      rest: ('augment')
scope_declarator__S_109supersede: !!perl/hash:RE_ast
  decl: []
  kind: token
  min: 24690
  pkg: ~
  re: !!perl/hash:RE_sequence
    a: 0
    dba: scope_declarator__S_109supersede
    i: 0
    min: 24690
    r: 1
    s: 0
    zyg:
    - !!perl/hash:RE_method
      a: 0
      dba: scope_declarator__S_109supersede
      endsym: nofun
      i: 0
      min: 12345
      name: sym
      r: 1
      rest: ''
      s: 0
      sym: supersede
    - !!perl/hash:RE_method
      a: 0
      dba: scope_declarator__S_109supersede
      i: 0
      min: 12345
      name: nofun
      nobind: 1
      r: 1
      rest: ''
      s: 0
    - !!perl/hash:RE_method
      min: 0
      name: scoped
      rest: ('supersede')
scoped: !!perl/hash:RE_ast
  decl: []
  kind: rule
  min: 0
  pkg: ~
  re: !!perl/hash:RE_first
    a: 0
    dba: scoped declarator
    i: 0
    min: 0
    r: 1
    s: 1
    zyg:
    - !!perl/hash:RE_sequence
      a: 0
      dba: scoped declarator
      i: 0
      min: 12345
      r: 1
      s: 1
      zyg:
      - !!perl/hash:RE_method
        min: 0
        name: ws
        nobind: 1
        noquant: 1
        rest: ''
      - !!perl/hash:RE_method
        min: 0
        name: ws
        nobind: 1
        noquant: 1
        rest: ''
      - !!perl/hash:RE_bracket
        decl: []
        min: 12345
        re: &64 !!perl/hash:RE_any
          a: 0
          altname: scoped_01
          dba: scoped declarator
          i: 0
          min: 12345
          name: scoped_01
          r: 1
          s: 1
          zyg:
          - !!perl/hash:RE_sequence
            a: 0
            alt: scoped_01 0
            dba: scoped declarator
            i: 0
            min: 12345
            r: 1
            s: 1
            zyg:
            - !!perl/hash:RE_method
              a: 0
              dba: scoped declarator
              i: 0
              min: 12345
              name: declarator
              r: 1
              rest: ''
              s: 1
            - !!perl/hash:RE_method
              min: 0
              name: ws
              nobind: 1
              noquant: 1
              rest: ''
          - !!perl/hash:RE_sequence
            a: 0
            alt: scoped_01 1
            dba: scoped declarator
            i: 0
            min: 12345
            r: 1
            s: 1
            zyg:
            - !!perl/hash:RE_method
              a: 0
              dba: scoped declarator
              i: 0
              min: 12345
              name: regex_declarator
              r: 1
              rest: ''
              s: 1
            - !!perl/hash:RE_method
              min: 0
              name: ws
              nobind: 1
              noquant: 1
              rest: ''
          - !!perl/hash:RE_sequence
            a: 0
            alt: scoped_01 2
            dba: scoped declarator
            i: 0
            min: 12345
            r: 1
            s: 1
            zyg:
            - !!perl/hash:RE_method
              a: 0
              dba: scoped declarator
              i: 0
              min: 12345
              name: package_declarator
              r: 1
              rest: ''
              s: 1
            - !!perl/hash:RE_method
              min: 0
              name: ws
              nobind: 1
              noquant: 1
              rest: ''
          - !!perl/hash:RE_sequence
            a: 0
            alt: scoped_01 3
            dba: scoped declarator
            i: 0
            min: 24690
            r: 1
            s: 1
            zyg:
            - !!perl/hash:RE_quantified_atom
              atom: !!perl/hash:RE_bracket
                decl: []
                min: 12345
                re: !!perl/hash:RE_sequence
                  a: 0
                  dba: scoped declarator
                  i: 0
                  min: 12345
                  r: 1
                  s: 1
                  zyg:
                  - !!perl/hash:RE_method
                    a: 0
                    dba: scoped declarator
                    i: 0
                    min: 12345
                    name: typename
                    r: 1
                    rest: ''
                    s: 1
                  - !!perl/hash:RE_method
                    min: 0
                    name: ws
                    nobind: 1
                    noquant: 1
                    rest: ''
              min: 12345
              quant:
              - +
              - ':'
              - ''
              - 1
            - !!perl/hash:RE_method
              min: 0
              name: ws
              nobind: 1
              noquant: 1
              rest: ''
            - !!perl/hash:RE_block
              a: 0
              context: void
              dba: scoped declarator
              i: 0
              min: 0
              r: 1
              s: 1
              text: "\n                my $t = $<typename>;\n                @$t >
                1 and $.panic(\"Multiple prefix constraints not yet supported\");\n
                \               $*OFTYPE = $t[0];\n            "
            - !!perl/hash:RE_method
              min: 0
              name: ws
              nobind: 1
              noquant: 1
              rest: ''
            - !!perl/hash:RE_method
              a: 0
              dba: scoped declarator
              i: 0
              min: 12345
              name: multi_declarator
              r: 1
              rest: ''
              s: 1
            - !!perl/hash:RE_method
              min: 0
              name: ws
              nobind: 1
              noquant: 1
              rest: ''
          - !!perl/hash:RE_sequence
            a: 0
            alt: scoped_01 4
            dba: scoped declarator
            i: 0
            min: 12345
            r: 1
            s: 1
            zyg:
            - !!perl/hash:RE_method
              a: 0
              dba: scoped declarator
              i: 0
              min: 12345
              name: multi_declarator
              r: 1
              rest: ''
              s: 1
            - !!perl/hash:RE_method
              min: 0
              name: ws
              nobind: 1
              noquant: 1
              rest: ''
      - !!perl/hash:RE_method
        min: 0
        name: ws
        nobind: 1
        noquant: 1
        rest: ''
    - !!perl/hash:RE_sequence
      a: 0
      dba: scoped declarator
      i: 0
      min: 12345
      r: 1
      s: 1
      zyg:
      - !!perl/hash:RE_method
        min: 0
        name: ws
        nobind: 1
        noquant: 1
        rest: ''
      - !!perl/hash:RE_assertion
        assert: '?'
        min: 0
        re: !!perl/hash:RE_method_re
          a: 0
          dba: scoped declarator
          i: 0
          min: 0
          name: before
          nobind: 1
          r: 1
          re: !!perl/hash:RE_ast
            decl: []
            min: 1
            re: !!perl/hash:RE_cclass
              a: 0
              dba: scoped declarator
              i: 0
              min: 1
              r: 1
              s: 1
              text: '[A..Z]'
          s: 1
      - !!perl/hash:RE_method
        a: 0
        dba: scoped declarator
        i: 0
        min: 12345
        name: longname
        r: 1
        rest: ''
        s: 1
      - !!perl/hash:RE_block
        a: 0
        context: void
        dba: scoped declarator
        i: 0
        min: 0
        r: 1
        s: 1
        text: "\n                my $t = $<longname>.Str;\n                if not
          $.is_known($t) {\n                    $.panic(\"In $*SCOPE declaration,
          typename '$t' must be predeclared (or marked as declarative with :: prefix)\");\n
          \               }\n            "
      - !!perl/hash:RE_method
        min: 0
        name: ws
        nobind: 1
        noquant: 1
        rest: ''
      - !!perl/hash:RE_assertion
        assert: '!'
        min: 0
        re: !!perl/hash:RE_noop
          a: 0
          dba: scoped declarator
          i: 0
          min: 0
          nobind: 1
          r: 1
          s: 1
      - !!perl/hash:RE_method
        min: 0
        name: ws
        nobind: 1
        noquant: 1
        rest: ''
    - !!perl/hash:RE_sequence
      a: 0
      dba: scoped declarator
      i: 0
      min: 0
      r: 1
      s: 1
      zyg:
      - !!perl/hash:RE_method
        min: 0
        name: ws
        nobind: 1
        noquant: 1
        rest: ''
      - !!perl/hash:RE_method
        min: 0
        name: panic
        nobind: 1
        rest: ("Malformed $*SCOPE")
      - !!perl/hash:RE_method
        min: 0
        name: ws
        nobind: 1
        noquant: 1
        rest: ''
scoped_01: *64
semiarglist: !!perl/hash:RE_ast
  decl: []
  kind: token
  min: 24690
  pkg: ~
  re: !!perl/hash:RE_sequence
    a: 0
    dba: semiarglist
    i: 0
    min: 24690
    r: 1
    s: 0
    zyg:
    - !!perl/hash:RE_quantified_atom
      atom: !!perl/hash:RE_method
        a: 0
        dba: semiarglist
        i: 0
        min: 12345
        name: arglist
        r: 1
        rest: ''
        s: 0
      min: 12345
      quant:
      - '**'
      - ':'
      - !!perl/hash:RE_string
        a: 0
        dba: semiarglist
        i: 0
        min: 1
        r: 1
        s: 0
        text: ;
      - 1
    - !!perl/hash:RE_method
      a: 0
      dba: semiarglist
      i: 0
      min: 12345
      name: ws
      nobind: 1
      r: 1
      rest: ''
      s: 0
semilist: !!perl/hash:RE_ast
  decl:
  - !!perl/hash:RE_decl
    a: 0
    dba: semilist
    i: 0
    max: 0
    min: 0
    r: 1
    s: 1
    text: my $*INVOCANT_OK = 0
  kind: rule
  min: 0
  pkg: ~
  re: !!perl/hash:RE_sequence
    a: 0
    dba: semicolon list
    i: 0
    min: 0
    r: 1
    s: 1
    zyg:
    - !!perl/hash:RE_method
      min: 0
      name: ws
      nobind: 1
      noquant: 1
      rest: ''
    - !!perl/hash:RE_method
      min: 0
      name: ws
      nobind: 1
      noquant: 1
      rest: ''
    - !!perl/hash:RE_bracket
      decl: []
      min: 0
      re: &65 !!perl/hash:RE_any
        a: 0
        altname: semilist_01
        dba: semicolon list
        i: 0
        min: 0
        name: semilist_01
        r: 1
        s: 1
        zyg:
        - !!perl/hash:RE_sequence
          a: 0
          alt: semilist_01 0
          dba: semicolon list
          i: 0
          min: 0
          r: 1
          s: 1
          zyg:
          - !!perl/hash:RE_assertion
            assert: '?'
            min: 0
            re: !!perl/hash:RE_method_re
              a: 0
              dba: semicolon list
              i: 0
              min: 0
              name: before
              nobind: 1
              r: 1
              re: !!perl/hash:RE_ast
                decl: []
                min: 1
                re: !!perl/hash:RE_cclass
                  a: 0
                  dba: semicolon list
                  i: 0
                  min: 1
                  r: 1
                  s: 1
                  text: '[\)\]\}]'
              s: 1
          - !!perl/hash:RE_method
            min: 0
            name: ws
            nobind: 1
            noquant: 1
            rest: ''
        - !!perl/hash:RE_sequence
          a: 0
          alt: semilist_01 1
          dba: semicolon list
          i: 0
          min: 0
          r: 1
          s: 1
          zyg:
          - !!perl/hash:RE_quantified_atom
            atom: !!perl/hash:RE_bracket
              decl: []
              min: 24690
              re: !!perl/hash:RE_sequence
                a: 0
                dba: semicolon list
                i: 0
                min: 24690
                r: 1
                s: 1
                zyg:
                - !!perl/hash:RE_method
                  a: 0
                  dba: semicolon list
                  i: 0
                  min: 12345
                  name: statement
                  r: 1
                  rest: ''
                  s: 1
                - !!perl/hash:RE_method
                  a: 0
                  dba: semicolon list
                  i: 0
                  min: 12345
                  name: eat_terminator
                  r: 1
                  rest: ''
                  s: 1
                - !!perl/hash:RE_method
                  min: 0
                  name: ws
                  nobind: 1
                  noquant: 1
                  rest: ''
            min: 0
            quant:
            - '*'
            - ':'
            - ''
            - 0
          - !!perl/hash:RE_method
            min: 0
            name: ws
            nobind: 1
            noquant: 1
            rest: ''
    - !!perl/hash:RE_method
      min: 0
      name: ws
      nobind: 1
      noquant: 1
      rest: ''
semilist_01: *65
sibble: !!perl/hash:RE_ast
  decl:
  - !!perl/hash:RE_decl
    a: 0
    dba: sibble
    i: 0
    max: 0
    min: 0
    r: 1
    s: 0
    text: my ($lang, $start, $stop)
  kind: token
  min: 0
  pkg: ~
  re: !!perl/hash:RE_sequence
    a: 0
    dba: sibble
    i: 0
    min: 0
    r: 1
    s: 0
    zyg:
    - !!perl/hash:RE_method
      min: 0
      name: babble
      rest: ($l)
    - !!perl/hash:RE_block
      a: 0
      context: void
      dba: sibble
      i: 0
      min: 0
      r: 1
      s: 0
      text: ' my $B = $<babble><B>; ($lang,$start,$stop) = @$B; '
    - !!perl/hash:RE_var
      a: 0
      dba: sibble
      i: 0
      min: 0
      r: 1
      s: 0
      var: $start
    - !!perl/hash:RE_bindnamed
      a: 0
      atom: !!perl/hash:RE_method
        min: 0
        name: nibble
        nobind: 1
        rest: ($lang)
      dba: sibble
      i: 0
      min: 0
      r: 1
      s: 0
      var: left
    - !!perl/hash:RE_bracket
      decl: []
      min: 0
      re: !!perl/hash:RE_first
        a: 0
        dba: sibble
        i: 0
        min: 0
        r: 1
        s: 0
        zyg:
        - !!perl/hash:RE_var
          a: 0
          dba: sibble
          i: 0
          min: 0
          r: 1
          s: 0
          var: $stop
        - !!perl/hash:RE_method
          min: 0
          name: panic
          nobind: 1
          rest: ("Couldn't find terminator $stop")
    - !!perl/hash:RE_bracket
      decl: []
      min: 0
      re: !!perl/hash:RE_first
        a: 0
        dba: sibble
        i: 0
        min: 0
        r: 1
        s: 0
        zyg:
        - !!perl/hash:RE_sequence
          a: 0
          dba: sibble
          i: 0
          min: 24690
          r: 1
          s: 0
          zyg:
          - !!perl/hash:RE_assertion
            assert: '?'
            min: 0
            re: !!perl/hash:RE_block
              a: 0
              context: bool
              dba: sibble
              i: 0
              min: 0
              nobind: 1
              r: 1
              s: 0
              text: ' $start ne $stop '
          - !!perl/hash:RE_method
            a: 0
            dba: sibble
            i: 0
            min: 12345
            name: ws
            nobind: 1
            r: 1
            rest: ''
            s: 0
          - !!perl/hash:RE_bracket
            decl: []
            min: 0
            re: !!perl/hash:RE_first
              a: 0
              dba: sibble
              i: 0
              min: 0
              r: 1
              s: 0
              zyg:
              - !!perl/hash:RE_method
                a: 0
                dba: sibble
                i: 0
                min: 12345
                name: infixish
                r: 1
                rest: ''
                s: 0
              - !!perl/hash:RE_method
                min: 0
                name: panic
                rest: ("Missing assignment operator")
          - !!perl/hash:RE_bracket
            decl: []
            min: 0
            re: !!perl/hash:RE_first
              a: 0
              dba: sibble
              i: 0
              min: 0
              r: 1
              s: 0
              zyg:
              - !!perl/hash:RE_assertion
                assert: '?'
                min: 0
                re: !!perl/hash:RE_block
                  a: 0
                  context: bool
                  dba: sibble
                  i: 0
                  min: 0
                  nobind: 1
                  r: 1
                  s: 0
                  text: ' $<infixish>.Str eq ''='' || $<infixish>.<infix_postfix_meta_operator> '
              - !!perl/hash:RE_method
                min: 0
                name: panic
                nobind: 1
                rest: ("Malformed assignment operator")
          - !!perl/hash:RE_method
            a: 0
            dba: sibble
            i: 0
            min: 12345
            name: ws
            nobind: 1
            r: 1
            rest: ''
            s: 0
          - !!perl/hash:RE_bindnamed
            a: 0
            atom: !!perl/hash:RE_method
              min: 0
              name: EXPR
              rest: (item %item_assignment)
            dba: sibble
            i: 0
            min: 0
            r: 1
            s: 0
            var: right
        - !!perl/hash:RE_sequence
          a: 0
          dba: sibble
          i: 0
          min: 0
          r: 1
          s: 0
          zyg:
          - !!perl/hash:RE_block
            a: 0
            context: void
            dba: sibble
            i: 0
            min: 0
            r: 1
            s: 0
            text: ' $lang = $lang2.unbalanced($stop); '
          - !!perl/hash:RE_bindnamed
            a: 0
            atom: !!perl/hash:RE_method
              min: 0
              name: nibble
              nobind: 1
              rest: ($lang)
            dba: sibble
            i: 0
            min: 0
            r: 1
            s: 0
            var: right
          - !!perl/hash:RE_var
            a: 0
            dba: sibble
            i: 0
            min: 0
            r: 1
            s: 0
            var: $stop
signature: !!perl/hash:RE_ast
  decl:
  - !!perl/hash:RE_decl
    a: 0
    dba: signature
    i: 0
    max: 0
    min: 0
    r: 1
    s: 0
    text: my $*IN_DECL = 'sig'
  - !!perl/hash:RE_decl
    a: 0
    dba: signature
    i: 0
    max: 0
    min: 0
    r: 1
    s: 0
    text: my $*zone = 'posreq'
  - !!perl/hash:RE_decl
    a: 0
    dba: signature
    i: 0
    max: 0
    min: 0
    r: 1
    s: 0
    text: my $startpos = self.pos
  - !!perl/hash:RE_decl
    a: 0
    dba: signature
    i: 0
    max: 0
    min: 0
    r: 1
    s: 0
    text: my $*MULTINESS = 'only'
  - !!perl/hash:RE_decl
    a: 0
    dba: signature
    i: 0
    max: 0
    min: 0
    r: 1
    s: 0
    text: my $*SIGNUM = $padsig
  kind: token
  min: 24690
  pkg: ~
  re: !!perl/hash:RE_sequence
    a: 0
    dba: signature
    i: 0
    min: 24690
    r: 1
    s: 0
    zyg:
    - !!perl/hash:RE_method
      a: 0
      dba: signature
      i: 0
      min: 12345
      name: ws
      nobind: 1
      r: 1
      rest: ''
      s: 0
    - !!perl/hash:RE_quantified_atom
      atom: !!perl/hash:RE_bracket
        decl: []
        min: 0
        re: &66 !!perl/hash:RE_any
          a: 0
          altname: signature_01
          dba: signature
          i: 0
          min: 0
          name: signature_01
          r: 1
          s: 0
          zyg:
          - !!perl/hash:RE_assertion
            alt: signature_01 0
            assert: '?'
            min: 0
            re: !!perl/hash:RE_method_re
              a: 0
              dba: signature
              i: 0
              min: 0
              name: before
              nobind: 1
              r: 1
              re: !!perl/hash:RE_ast
                decl: []
                min: 1
                re: &67 !!perl/hash:RE_any
                  a: 0
                  altname: signature_02
                  dba: signature
                  i: 0
                  min: 1
                  name: signature_02
                  r: 1
                  s: 0
                  zyg:
                  - !!perl/hash:RE_string
                    a: 0
                    alt: signature_02 0
                    dba: signature
                    i: 0
                    min: 3
                    r: 1
                    s: 0
                    text: -->
                  - !!perl/hash:RE_string
                    a: 0
                    alt: signature_02 1
                    dba: signature
                    i: 0
                    min: 1
                    r: 1
                    s: 0
                    text: )
                  - !!perl/hash:RE_string
                    a: 0
                    alt: signature_02 2
                    dba: signature
                    i: 0
                    min: 1
                    r: 1
                    s: 0
                    text: ']'
                  - !!perl/hash:RE_string
                    a: 0
                    alt: signature_02 3
                    dba: signature
                    i: 0
                    min: 1
                    r: 1
                    s: 0
                    text: '{'
                  - !!perl/hash:RE_sequence
                    a: 0
                    alt: signature_02 4
                    dba: signature
                    i: 0
                    min: 2
                    r: 1
                    s: 0
                    zyg:
                    - !!perl/hash:RE_string
                      a: 0
                      dba: signature
                      i: 0
                      min: 1
                      r: 1
                      s: 0
                      text: ':'
                    - !!perl/hash:RE_meta
                      a: 0
                      dba: signature
                      i: 0
                      min: 1
                      r: 1
                      s: 0
                      text: \s
              s: 0
          - !!perl/hash:RE_bracket
            alt: signature_01 1
            decl: []
            min: 0
            re: !!perl/hash:RE_first
              a: 0
              dba: signature
              i: 0
              min: 0
              r: 1
              s: 0
              zyg:
              - !!perl/hash:RE_method
                a: 0
                dba: signature
                i: 0
                min: 12345
                name: parameter
                r: 1
                rest: ''
                s: 0
              - !!perl/hash:RE_method
                min: 0
                name: panic
                nobind: 1
                rest: ("Malformed parameter")
      min: 0
      quant:
      - '**'
      - ':'
      - !!perl/hash:RE_method
        a: 0
        dba: signature
        i: 0
        min: 12345
        name: param_sep
        r: 1
        rest: ''
        s: 0
      - 1
    - !!perl/hash:RE_method
      a: 0
      dba: signature
      i: 0
      min: 12345
      name: ws
      nobind: 1
      r: 1
      rest: ''
      s: 0
    - !!perl/hash:RE_block
      a: 0
      context: void
      dba: signature
      i: 0
      min: 0
      r: 1
      s: 0
      text: ' $*IN_DECL = ''''; '
    - !!perl/hash:RE_quantified_atom
      atom: !!perl/hash:RE_bracket
        decl: []
        min: 37038
        re: !!perl/hash:RE_sequence
          a: 0
          dba: signature
          i: 0
          min: 37038
          r: 1
          s: 0
          zyg:
          - !!perl/hash:RE_string
            a: 0
            dba: signature
            i: 0
            min: 3
            r: 1
            s: 0
            text: -->
          - !!perl/hash:RE_method
            a: 0
            dba: signature
            i: 0
            min: 12345
            name: ws
            nobind: 1
            r: 1
            rest: ''
            s: 0
          - !!perl/hash:RE_method
            a: 0
            dba: signature
            i: 0
            min: 12345
            name: typename
            r: 1
            rest: ''
            s: 0
          - !!perl/hash:RE_method
            a: 0
            dba: signature
            i: 0
            min: 12345
            name: ws
            nobind: 1
            r: 1
            rest: ''
            s: 0
      min: 0
      quant:
      - '?'
      - ':'
      - ''
      - 0
    - !!perl/hash:RE_block
      a: 0
      context: void
      dba: signature
      i: 0
      min: 0
      r: 1
      s: 0
      text: "\n            $*LEFTSIGIL = '@';\n            if $padsig {\n                $*CURPAD.<$?SIGNATURE>
        ~= '|' if $padsig > 1;\n                $*CURPAD.<$?SIGNATURE> ~= '(' ~ substr($*ORIG,
        $startpos, $.pos - $startpos) ~ ')';\n                $*CURPAD.<!NEEDSIG>:delete;\n
        \           }\n        "
signature_01: *66
signature_02: *67
sigterm: !!perl/hash:RE_ast
  decl: []
  kind: token
  min: 12348
  pkg: ~
  re: !!perl/hash:RE_sequence
    a: 0
    dba: signature
    i: 0
    min: 12348
    r: 1
    s: 0
    zyg:
    - !!perl/hash:RE_string
      a: 0
      dba: signature
      i: 0
      min: 2
      r: 1
      s: 0
      text: :(
    - !!perl/hash:RE_meta
      a: 0
      dba: signature
      extra: 'local $::GOAL = '')'' '
      i: 0
      min: 0
      r: 1
      s: 0
      text: ':'
    - !!perl/hash:RE_method
      a: 0
      dba: signature
      i: 0
      min: 12345
      name: fakesignature
      r: 1
      rest: ''
      s: 0
    - !!perl/hash:RE_bracket
      decl: []
      min: 1
      re: !!perl/hash:RE_first
        a: 0
        dba: signature
        i: 0
        min: 1
        r: 1
        s: 0
        zyg:
        - !!perl/hash:RE_string
          a: 0
          dba: signature
          i: 0
          min: 1
          r: 1
          s: 0
          text: )
        - !!perl/hash:RE_method
          min: 0
          name: FAILGOAL
          nobind: 1
          rest: (')' , 'signature')
special_variable__S_153Dollar_a2_: !!perl/hash:RE_ast
  decl: []
  kind: token
  min: 12345
  pkg: ~
  re: !!perl/hash:RE_method
    a: 0
    dba: special_variable__S_153Dollar_a2_
    i: 0
    min: 12345
    name: sym
    r: 1
    rest: ''
    s: 0
    sym: $
special_variable__S_154DollarBang: !!perl/hash:RE_ast
  decl: []
  kind: token
  min: 12345
  pkg: ~
  re: !!perl/hash:RE_sequence
    a: 0
    dba: special_variable__S_154DollarBang
    i: 0
    min: 12345
    r: 1
    s: 0
    zyg:
    - !!perl/hash:RE_method
      a: 0
      dba: special_variable__S_154DollarBang
      i: 0
      min: 12345
      name: sym
      r: 1
      rest: ''
      s: 0
      sym: $!
    - !!perl/hash:RE_assertion
      assert: '!'
      min: 0
      re: !!perl/hash:RE_method_re
        a: 0
        dba: special_variable__S_154DollarBang
        i: 0
        min: 0
        name: before
        nobind: 1
        r: 1
        re: !!perl/hash:RE_ast
          decl: []
          min: 1
          re: !!perl/hash:RE_meta
            a: 0
            dba: special_variable__S_154DollarBang
            i: 0
            min: 1
            r: 1
            s: 0
            text: \w
        s: 0
special_variable__S_155DollarBangCur_Ly: !!perl/hash:RE_ast
  decl: []
  kind: token
  min: 5
  pkg: ~
  re: !!perl/hash:RE_sequence
    a: 0
    dba: special_variable__S_155DollarBangCur_Ly
    i: 0
    min: 5
    r: 1
    s: 0
    zyg:
    - !!perl/hash:RE_bindpos
      atom: !!perl/hash:RE_paren
        decl: []
        min: 5
        re: !!perl/hash:RE_sequence
          a: 0
          dba: special_variable__S_155DollarBangCur_Ly
          i: 0
          min: 5
          r: 1
          s: 0
          zyg:
          - !!perl/hash:RE_string
            a: 0
            dba: special_variable__S_155DollarBangCur_Ly
            i: 0
            min: 3
            r: 1
            s: 0
            text: $!{
          - !!perl/hash:RE_meta
            a: 0
            dba: special_variable__S_155DollarBangCur_Ly
            i: 0
            min: 0
            r: 1
            s: 0
            text: '::'
          - !!perl/hash:RE_bindpos
            atom: !!perl/hash:RE_paren
              decl: []
              min: 1
              re: !!perl/hash:RE_meta
                a: 0
                dba: special_variable__S_155DollarBangCur_Ly
                i: 0
                min: 1
                r: 1
                s: 0
                text: .*?
            min: 1
            var: 0
          - !!perl/hash:RE_string
            a: 0
            dba: special_variable__S_155DollarBangCur_Ly
            i: 0
            min: 1
            r: 1
            s: 0
            text: '}'
      min: 5
      var: 0
    - !!perl/hash:RE_method
      min: 0
      name: obs
      nobind: 1
      rest: ($0.Str ~ " variable", 'smart match against $!')
special_variable__S_156DollarSlash: !!perl/hash:RE_ast
  decl: []
  kind: token
  min: 12345
  pkg: ~
  re: !!perl/hash:RE_sequence
    a: 0
    dba: special_variable__S_156DollarSlash
    i: 0
    min: 12345
    r: 1
    s: 0
    zyg:
    - !!perl/hash:RE_method
      a: 0
      dba: special_variable__S_156DollarSlash
      i: 0
      min: 12345
      name: sym
      r: 1
      rest: ''
      s: 0
      sym: $/
    - !!perl/hash:RE_quantified_atom
      atom: !!perl/hash:RE_bracket
        decl: []
        min: 0
        re: !!perl/hash:RE_sequence
          a: 0
          dba: special_variable__S_156DollarSlash
          i: 0
          min: 0
          r: 1
          s: 0
          zyg:
          - !!perl/hash:RE_assertion
            assert: '?'
            min: 0
            re: !!perl/hash:RE_method_re
              a: 0
              dba: special_variable__S_156DollarSlash
              i: 0
              min: 0
              name: before
              nobind: 1
              r: 1
              re: !!perl/hash:RE_ast
                decl: []
                min: 1
                re: !!perl/hash:RE_sequence
                  a: 0
                  dba: special_variable__S_156DollarSlash
                  i: 0
                  min: 1
                  r: 1
                  s: 0
                  zyg:
                  - !!perl/hash:RE_quantified_atom
                    atom: !!perl/hash:RE_meta
                      a: 0
                      dba: special_variable__S_156DollarSlash
                      i: 0
                      min: 1
                      r: 1
                      s: 0
                      text: \h
                    min: 0
                    quant:
                    - '*'
                    - ':'
                    - ''
                    - 0
                  - !!perl/hash:RE_string
                    a: 0
                    dba: special_variable__S_156DollarSlash
                    i: 0
                    min: 1
                    r: 1
                    s: 0
                    text: =
                  - !!perl/hash:RE_assertion
                    assert: '!'
                    min: 0
                    re: !!perl/hash:RE_cclass
                      a: 0
                      dba: special_variable__S_156DollarSlash
                      i: 0
                      min: 1
                      nobind: 1
                      r: 1
                      s: 0
                      text: '[=]'
              s: 0
          - !!perl/hash:RE_method
            min: 0
            name: obs
            nobind: 1
            rest: "('$/ variable as input record separator',\n                 \"the
              filehandle's :irs attribute\")"
      min: 0
      quant:
      - '?'
      - ':'
      - ''
      - 0
special_variable__S_157DollarTilde: !!perl/hash:RE_ast
  decl: []
  kind: token
  min: 12345
  pkg: ~
  re: !!perl/hash:RE_sequence
    a: 0
    dba: special_variable__S_157DollarTilde
    i: 0
    min: 12345
    r: 1
    s: 0
    zyg:
    - !!perl/hash:RE_method
      a: 0
      dba: special_variable__S_157DollarTilde
      i: 0
      min: 12345
      name: sym
      r: 1
      rest: ''
      s: 0
      sym: $~
    - !!perl/hash:RE_meta
      a: 0
      dba: special_variable__S_157DollarTilde
      i: 0
      min: 0
      r: 1
      s: 0
      text: '::'
    - !!perl/hash:RE_assertion
      assert: '?'
      min: 0
      re: !!perl/hash:RE_method_re
        a: 0
        dba: special_variable__S_157DollarTilde
        i: 0
        min: 0
        name: before
        nobind: 1
        r: 1
        re: !!perl/hash:RE_ast
          decl: []
          min: 1
          re: &68 !!perl/hash:RE_any
            a: 0
            altname: special_variable__S_157DollarTilde_01
            dba: special_variable__S_157DollarTilde
            i: 0
            min: 1
            name: special_variable__S_157DollarTilde_01
            r: 1
            s: 0
            zyg:
            - !!perl/hash:RE_meta
              a: 0
              alt: special_variable__S_157DollarTilde_01 0
              dba: special_variable__S_157DollarTilde
              i: 0
              min: 1
              r: 1
              s: 0
              text: \s
            - !!perl/hash:RE_string
              a: 0
              alt: special_variable__S_157DollarTilde_01 1
              dba: special_variable__S_157DollarTilde
              i: 0
              min: 1
              r: 1
              s: 0
              text: ','
            - !!perl/hash:RE_string
              a: 0
              alt: special_variable__S_157DollarTilde_01 2
              dba: special_variable__S_157DollarTilde
              i: 0
              min: 1
              r: 1
              s: 0
              text: =
            - !!perl/hash:RE_method
              a: 0
              alt: special_variable__S_157DollarTilde_01 3
              dba: special_variable__S_157DollarTilde
              i: 0
              min: 12345
              name: terminator
              r: 1
              rest: ''
              s: 0
        s: 0
    - !!perl/hash:RE_method
      min: 0
      name: obs
      nobind: 1
      rest: ('$~ variable', 'Form module')
special_variable__S_157DollarTilde_01: *68
special_variable__S_158DollarGrave: !!perl/hash:RE_ast
  decl: []
  kind: token
  min: 12345
  pkg: ~
  re: !!perl/hash:RE_sequence
    a: 0
    dba: special_variable__S_158DollarGrave
    i: 0
    min: 12345
    r: 1
    s: 0
    zyg:
    - !!perl/hash:RE_method
      a: 0
      dba: special_variable__S_158DollarGrave
      i: 0
      min: 12345
      name: sym
      r: 1
      rest: ''
      s: 0
      sym: $`
    - !!perl/hash:RE_meta
      a: 0
      dba: special_variable__S_158DollarGrave
      i: 0
      min: 0
      r: 1
      s: 0
      text: '::'
    - !!perl/hash:RE_assertion
      assert: '?'
      min: 0
      re: !!perl/hash:RE_method_re
        a: 0
        dba: special_variable__S_158DollarGrave
        i: 0
        min: 0
        name: before
        nobind: 1
        r: 1
        re: !!perl/hash:RE_ast
          decl: []
          min: 1
          re: &69 !!perl/hash:RE_any
            a: 0
            altname: special_variable__S_158DollarGrave_01
            dba: special_variable__S_158DollarGrave
            i: 0
            min: 1
            name: special_variable__S_158DollarGrave_01
            r: 1
            s: 0
            zyg:
            - !!perl/hash:RE_meta
              a: 0
              alt: special_variable__S_158DollarGrave_01 0
              dba: special_variable__S_158DollarGrave
              i: 0
              min: 1
              r: 1
              s: 0
              text: \s
            - !!perl/hash:RE_string
              a: 0
              alt: special_variable__S_158DollarGrave_01 1
              dba: special_variable__S_158DollarGrave
              i: 0
              min: 1
              r: 1
              s: 0
              text: ','
            - !!perl/hash:RE_method
              a: 0
              alt: special_variable__S_158DollarGrave_01 2
              dba: special_variable__S_158DollarGrave
              i: 0
              min: 12345
              name: terminator
              r: 1
              rest: ''
              s: 0
        s: 0
    - !!perl/hash:RE_method
      min: 0
      name: obs
      nobind: 1
      rest: ('$` variable', 'explicit pattern before <(')
special_variable__S_158DollarGrave_01: *69
special_variable__S_159DollarAt: !!perl/hash:RE_ast
  decl: []
  kind: token
  min: 12345
  pkg: ~
  re: !!perl/hash:RE_sequence
    a: 0
    dba: special_variable__S_159DollarAt
    i: 0
    min: 12345
    r: 1
    s: 0
    zyg:
    - !!perl/hash:RE_method
      a: 0
      dba: special_variable__S_159DollarAt
      i: 0
      min: 12345
      name: sym
      r: 1
      rest: ''
      s: 0
      sym: $@
    - !!perl/hash:RE_assertion
      assert: '?'
      min: 0
      re: !!perl/hash:RE_method_re
        a: 0
        dba: special_variable__S_159DollarAt
        i: 0
        min: 0
        name: before
        nobind: 1
        r: 1
        re: !!perl/hash:RE_ast
          decl: []
          min: 1
          re: !!perl/hash:RE_meta
            a: 0
            dba: special_variable__S_159DollarAt
            i: 0
            min: 1
            r: 1
            s: 0
            text: \W
        s: 0
    - !!perl/hash:RE_meta
      a: 0
      dba: special_variable__S_159DollarAt
      i: 0
      min: 0
      r: 1
      s: 0
      text: '::'
    - !!perl/hash:RE_method
      min: 0
      name: obs
      nobind: 1
      rest: ('$@ variable as eval error', '$!')
special_variable__S_160DollarSharp: !!perl/hash:RE_ast
  decl: []
  kind: token
  min: 12345
  pkg: ~
  re: !!perl/hash:RE_sequence
    a: 0
    dba: special_variable__S_160DollarSharp
    i: 0
    min: 12345
    r: 1
    s: 0
    zyg:
    - !!perl/hash:RE_method
      a: 0
      dba: special_variable__S_160DollarSharp
      i: 0
      min: 12345
      name: sym
      r: 1
      rest: ''
      s: 0
      sym: $#
    - !!perl/hash:RE_meta
      a: 0
      dba: special_variable__S_160DollarSharp
      i: 0
      min: 0
      r: 1
      s: 0
      text: '::'
    - !!perl/hash:RE_bracket
      decl: []
      min: 0
      re: !!perl/hash:RE_first
        a: 0
        dba: special_variable__S_160DollarSharp
        i: 0
        min: 0
        r: 1
        s: 0
        zyg:
        - !!perl/hash:RE_sequence
          a: 0
          dba: special_variable__S_160DollarSharp
          i: 0
          min: 1
          r: 1
          s: 0
          zyg:
          - !!perl/hash:RE_bindpos
            atom: !!perl/hash:RE_paren
              decl: []
              min: 1
              re: !!perl/hash:RE_quantified_atom
                atom: !!perl/hash:RE_meta
                  a: 0
                  dba: special_variable__S_160DollarSharp
                  i: 0
                  min: 1
                  r: 1
                  s: 0
                  text: \w
                min: 1
                quant:
                - +
                - ':'
                - ''
                - 1
            min: 1
            var: 0
          - !!perl/hash:RE_method
            min: 0
            name: obs
            nobind: 1
            rest: ("\$#" ~ $0.Str ~ " variable", '@' ~ $0.Str ~ '.end')
        - !!perl/hash:RE_method
          min: 0
          name: obs
          nobind: 1
          rest: ('$# variable', '.fmt')
special_variable__S_161DollarDollar: !!perl/hash:RE_ast
  decl: []
  kind: token
  min: 12345
  pkg: ~
  re: !!perl/hash:RE_sequence
    a: 0
    dba: special_variable__S_161DollarDollar
    i: 0
    min: 12345
    r: 1
    s: 0
    zyg:
    - !!perl/hash:RE_method
      a: 0
      dba: special_variable__S_161DollarDollar
      i: 0
      min: 12345
      name: sym
      r: 1
      rest: ''
      s: 0
      sym: $$
    - !!perl/hash:RE_assertion
      assert: '!'
      min: 0
      re: !!perl/hash:RE_method
        a: 0
        dba: special_variable__S_161DollarDollar
        i: 0
        min: 12345
        name: alpha
        nobind: 1
        r: 1
        rest: ''
        s: 0
    - !!perl/hash:RE_meta
      a: 0
      dba: special_variable__S_161DollarDollar
      i: 0
      min: 0
      r: 1
      s: 0
      text: '::'
    - !!perl/hash:RE_assertion
      assert: '?'
      min: 0
      re: !!perl/hash:RE_method_re
        a: 0
        dba: special_variable__S_161DollarDollar
        i: 0
        min: 0
        name: before
        nobind: 1
        r: 1
        re: !!perl/hash:RE_ast
          decl: []
          min: 1
          re: &70 !!perl/hash:RE_any
            a: 0
            altname: special_variable__S_161DollarDollar_01
            dba: special_variable__S_161DollarDollar
            i: 0
            min: 1
            name: special_variable__S_161DollarDollar_01
            r: 1
            s: 0
            zyg:
            - !!perl/hash:RE_meta
              a: 0
              alt: special_variable__S_161DollarDollar_01 0
              dba: special_variable__S_161DollarDollar
              i: 0
              min: 1
              r: 1
              s: 0
              text: \s
            - !!perl/hash:RE_string
              a: 0
              alt: special_variable__S_161DollarDollar_01 1
              dba: special_variable__S_161DollarDollar
              i: 0
              min: 1
              r: 1
              s: 0
              text: ','
            - !!perl/hash:RE_method
              a: 0
              alt: special_variable__S_161DollarDollar_01 2
              dba: special_variable__S_161DollarDollar
              i: 0
              min: 12345
              name: terminator
              r: 1
              rest: ''
              s: 0
        s: 0
    - !!perl/hash:RE_method
      min: 0
      name: obs
      nobind: 1
      rest: ('$$ variable', '$*PID')
special_variable__S_161DollarDollar_01: *70
special_variable__S_162DollarPercent: !!perl/hash:RE_ast
  decl: []
  kind: token
  min: 12345
  pkg: ~
  re: !!perl/hash:RE_sequence
    a: 0
    dba: special_variable__S_162DollarPercent
    i: 0
    min: 12345
    r: 1
    s: 0
    zyg:
    - !!perl/hash:RE_method
      a: 0
      dba: special_variable__S_162DollarPercent
      i: 0
      min: 12345
      name: sym
      r: 1
      rest: ''
      s: 0
      sym: $%
    - !!perl/hash:RE_assertion
      assert: '!'
      min: 0
      re: !!perl/hash:RE_method_re
        a: 0
        dba: special_variable__S_162DollarPercent
        i: 0
        min: 0
        name: before
        nobind: 1
        r: 1
        re: !!perl/hash:RE_ast
          decl: []
          min: 1
          re: !!perl/hash:RE_meta
            a: 0
            dba: special_variable__S_162DollarPercent
            i: 0
            min: 1
            r: 1
            s: 0
            text: \w
        s: 0
    - !!perl/hash:RE_assertion
      assert: '!'
      min: 0
      re: !!perl/hash:RE_method
        a: 0
        dba: special_variable__S_162DollarPercent
        i: 0
        min: 12345
        name: sigil
        nobind: 1
        r: 1
        rest: ''
        s: 0
    - !!perl/hash:RE_meta
      a: 0
      dba: special_variable__S_162DollarPercent
      i: 0
      min: 0
      r: 1
      s: 0
      text: '::'
    - !!perl/hash:RE_method
      min: 0
      name: obs
      nobind: 1
      rest: ('$% variable', 'Form module')
special_variable__S_163DollarCaretX: !!perl/hash:RE_ast
  decl: []
  kind: token
  min: 12348
  pkg: ~
  re: !!perl/hash:RE_sequence
    a: 0
    dba: special_variable__S_163DollarCaretX
    i: 0
    min: 12348
    r: 1
    s: 0
    zyg:
    - !!perl/hash:RE_method
      a: 0
      dba: special_variable__S_163DollarCaretX
      i: 0
      min: 12345
      name: sigil
      r: 1
      rest: ''
      s: 0
    - !!perl/hash:RE_string
      a: 0
      dba: special_variable__S_163DollarCaretX
      i: 0
      min: 1
      r: 1
      s: 0
      text: ^
    - !!perl/hash:RE_bindnamed
      a: 0
      atom: !!perl/hash:RE_bracket
        decl: []
        min: 1
        re: !!perl/hash:RE_cclass
          a: 0
          dba: special_variable__S_163DollarCaretX
          i: 0
          min: 1
          r: 1
          s: 0
          text: '[A..Z]'
      dba: special_variable__S_163DollarCaretX
      i: 0
      min: 1
      r: 1
      s: 0
      var: letter
    - !!perl/hash:RE_meta
      a: 0
      dba: special_variable__S_163DollarCaretX
      i: 0
      min: 1
      r: 1
      s: 0
      text: \W
    - !!perl/hash:RE_method
      min: 0
      name: obscaret
      nobind: 1
      rest: ($<sigil>.Str ~ '^' ~ $<letter>.Str, $<sigil>.Str, $<letter>.Str)
special_variable__S_164DollarCaret: !!perl/hash:RE_ast
  decl: []
  kind: token
  min: 12345
  pkg: ~
  re: !!perl/hash:RE_sequence
    a: 0
    dba: special_variable__S_164DollarCaret
    i: 0
    min: 12345
    r: 1
    s: 0
    zyg:
    - !!perl/hash:RE_method
      a: 0
      dba: special_variable__S_164DollarCaret
      i: 0
      min: 12345
      name: sym
      r: 1
      rest: ''
      s: 0
      sym: $^
    - !!perl/hash:RE_meta
      a: 0
      dba: special_variable__S_164DollarCaret
      i: 0
      min: 0
      r: 1
      s: 0
      text: '::'
    - !!perl/hash:RE_assertion
      assert: '?'
      min: 0
      re: !!perl/hash:RE_method_re
        a: 0
        dba: special_variable__S_164DollarCaret
        i: 0
        min: 0
        name: before
        nobind: 1
        r: 1
        re: !!perl/hash:RE_ast
          decl: []
          min: 1
          re: &71 !!perl/hash:RE_any
            a: 0
            altname: special_variable__S_164DollarCaret_01
            dba: special_variable__S_164DollarCaret
            i: 0
            min: 1
            name: special_variable__S_164DollarCaret_01
            r: 1
            s: 0
            zyg:
            - !!perl/hash:RE_meta
              a: 0
              alt: special_variable__S_164DollarCaret_01 0
              dba: special_variable__S_164DollarCaret
              i: 0
              min: 1
              r: 1
              s: 0
              text: \s
            - !!perl/hash:RE_string
              a: 0
              alt: special_variable__S_164DollarCaret_01 1
              dba: special_variable__S_164DollarCaret
              i: 0
              min: 1
              r: 1
              s: 0
              text: ','
            - !!perl/hash:RE_string
              a: 0
              alt: special_variable__S_164DollarCaret_01 2
              dba: special_variable__S_164DollarCaret
              i: 0
              min: 1
              r: 1
              s: 0
              text: =
            - !!perl/hash:RE_method
              a: 0
              alt: special_variable__S_164DollarCaret_01 3
              dba: special_variable__S_164DollarCaret
              i: 0
              min: 12345
              name: terminator
              r: 1
              rest: ''
              s: 0
        s: 0
    - !!perl/hash:RE_method
      min: 0
      name: obs
      nobind: 1
      rest: ('$^ variable', 'Form module')
special_variable__S_164DollarCaret_01: *71
special_variable__S_165DollarAmp: !!perl/hash:RE_ast
  decl: []
  kind: token
  min: 12345
  pkg: ~
  re: !!perl/hash:RE_sequence
    a: 0
    dba: special_variable__S_165DollarAmp
    i: 0
    min: 12345
    r: 1
    s: 0
    zyg:
    - !!perl/hash:RE_method
      a: 0
      dba: special_variable__S_165DollarAmp
      i: 0
      min: 12345
      name: sym
      r: 1
      rest: ''
      s: 0
      sym: $&
    - !!perl/hash:RE_meta
      a: 0
      dba: special_variable__S_165DollarAmp
      i: 0
      min: 0
      r: 1
      s: 0
      text: '::'
    - !!perl/hash:RE_assertion
      assert: '?'
      min: 0
      re: !!perl/hash:RE_method_re
        a: 0
        dba: special_variable__S_165DollarAmp
        i: 0
        min: 0
        name: before
        nobind: 1
        r: 1
        re: !!perl/hash:RE_ast
          decl: []
          min: 1
          re: &72 !!perl/hash:RE_any
            a: 0
            altname: special_variable__S_165DollarAmp_01
            dba: special_variable__S_165DollarAmp
            i: 0
            min: 1
            name: special_variable__S_165DollarAmp_01
            r: 1
            s: 0
            zyg:
            - !!perl/hash:RE_meta
              a: 0
              alt: special_variable__S_165DollarAmp_01 0
              dba: special_variable__S_165DollarAmp
              i: 0
              min: 1
              r: 1
              s: 0
              text: \s
            - !!perl/hash:RE_string
              a: 0
              alt: special_variable__S_165DollarAmp_01 1
              dba: special_variable__S_165DollarAmp
              i: 0
              min: 1
              r: 1
              s: 0
              text: ','
            - !!perl/hash:RE_method
              a: 0
              alt: special_variable__S_165DollarAmp_01 2
              dba: special_variable__S_165DollarAmp
              i: 0
              min: 12345
              name: terminator
              r: 1
              rest: ''
              s: 0
        s: 0
    - !!perl/hash:RE_method
      min: 0
      name: obs
      nobind: 1
      rest: ('$& variable', '$/ or $()')
special_variable__S_165DollarAmp_01: *72
special_variable__S_166DollarStar: !!perl/hash:RE_ast
  decl: []
  kind: token
  min: 12345
  pkg: ~
  re: !!perl/hash:RE_sequence
    a: 0
    dba: special_variable__S_166DollarStar
    i: 0
    min: 12345
    r: 1
    s: 0
    zyg:
    - !!perl/hash:RE_method
      a: 0
      dba: special_variable__S_166DollarStar
      i: 0
      min: 12345
      name: sym
      r: 1
      rest: ''
      s: 0
      sym: $*
    - !!perl/hash:RE_meta
      a: 0
      dba: special_variable__S_166DollarStar
      i: 0
      min: 0
      r: 1
      s: 0
      text: '::'
    - !!perl/hash:RE_assertion
      assert: '?'
      min: 0
      re: !!perl/hash:RE_method_re
        a: 0
        dba: special_variable__S_166DollarStar
        i: 0
        min: 0
        name: before
        nobind: 1
        r: 1
        re: !!perl/hash:RE_ast
          decl: []
          min: 1
          re: &73 !!perl/hash:RE_any
            a: 0
            altname: special_variable__S_166DollarStar_01
            dba: special_variable__S_166DollarStar
            i: 0
            min: 1
            name: special_variable__S_166DollarStar_01
            r: 1
            s: 0
            zyg:
            - !!perl/hash:RE_meta
              a: 0
              alt: special_variable__S_166DollarStar_01 0
              dba: special_variable__S_166DollarStar
              i: 0
              min: 1
              r: 1
              s: 0
              text: \s
            - !!perl/hash:RE_string
              a: 0
              alt: special_variable__S_166DollarStar_01 1
              dba: special_variable__S_166DollarStar
              i: 0
              min: 1
              r: 1
              s: 0
              text: ','
            - !!perl/hash:RE_string
              a: 0
              alt: special_variable__S_166DollarStar_01 2
              dba: special_variable__S_166DollarStar
              i: 0
              min: 1
              r: 1
              s: 0
              text: =
            - !!perl/hash:RE_method
              a: 0
              alt: special_variable__S_166DollarStar_01 3
              dba: special_variable__S_166DollarStar
              i: 0
              min: 12345
              name: terminator
              r: 1
              rest: ''
              s: 0
        s: 0
    - !!perl/hash:RE_method
      min: 0
      name: obs
      nobind: 1
      rest: ('$* variable', '^^ and $$')
special_variable__S_166DollarStar_01: *73
special_variable__S_167DollarThesis: !!perl/hash:RE_ast
  decl: []
  kind: token
  min: 12345
  pkg: ~
  re: !!perl/hash:RE_sequence
    a: 0
    dba: special_variable__S_167DollarThesis
    i: 0
    min: 12345
    r: 1
    s: 0
    zyg:
    - !!perl/hash:RE_method
      a: 0
      dba: special_variable__S_167DollarThesis
      i: 0
      min: 12345
      name: sym
      r: 1
      rest: ''
      s: 0
      sym: $)
    - !!perl/hash:RE_assertion
      assert: '?'
      min: 0
      re: !!perl/hash:RE_block
        a: 0
        context: bool
        dba: special_variable__S_167DollarThesis
        i: 0
        min: 0
        nobind: 1
        r: 1
        s: 0
        text: ' $*GOAL ne '')'' '
    - !!perl/hash:RE_assertion
      assert: '?'
      min: 0
      re: !!perl/hash:RE_method_re
        a: 0
        dba: special_variable__S_167DollarThesis
        i: 0
        min: 0
        name: before
        nobind: 1
        r: 1
        re: !!perl/hash:RE_ast
          decl: []
          min: 1
          re: &74 !!perl/hash:RE_any
            a: 0
            altname: special_variable__S_167DollarThesis_01
            dba: special_variable__S_167DollarThesis
            i: 0
            min: 1
            name: special_variable__S_167DollarThesis_01
            r: 1
            s: 0
            zyg:
            - !!perl/hash:RE_meta
              a: 0
              alt: special_variable__S_167DollarThesis_01 0
              dba: special_variable__S_167DollarThesis
              i: 0
              min: 1
              r: 1
              s: 0
              text: \s
            - !!perl/hash:RE_string
              a: 0
              alt: special_variable__S_167DollarThesis_01 1
              dba: special_variable__S_167DollarThesis
              i: 0
              min: 1
              r: 1
              s: 0
              text: ','
            - !!perl/hash:RE_method
              a: 0
              alt: special_variable__S_167DollarThesis_01 2
              dba: special_variable__S_167DollarThesis
              i: 0
              min: 12345
              name: terminator
              r: 1
              rest: ''
              s: 0
        s: 0
    - !!perl/hash:RE_method
      min: 0
      name: obs
      nobind: 1
      rest: ('$) variable', '$*EGID')
special_variable__S_167DollarThesis_01: *74
special_variable__S_168DollarMinus: !!perl/hash:RE_ast
  decl: []
  kind: token
  min: 12345
  pkg: ~
  re: !!perl/hash:RE_sequence
    a: 0
    dba: special_variable__S_168DollarMinus
    i: 0
    min: 12345
    r: 1
    s: 0
    zyg:
    - !!perl/hash:RE_method
      a: 0
      dba: special_variable__S_168DollarMinus
      i: 0
      min: 12345
      name: sym
      r: 1
      rest: ''
      s: 0
      sym: $-
    - !!perl/hash:RE_meta
      a: 0
      dba: special_variable__S_168DollarMinus
      i: 0
      min: 0
      r: 1
      s: 0
      text: '::'
    - !!perl/hash:RE_assertion
      assert: '?'
      min: 0
      re: !!perl/hash:RE_method_re
        a: 0
        dba: special_variable__S_168DollarMinus
        i: 0
        min: 0
        name: before
        nobind: 1
        r: 1
        re: !!perl/hash:RE_ast
          decl: []
          min: 1
          re: &75 !!perl/hash:RE_any
            a: 0
            altname: special_variable__S_168DollarMinus_01
            dba: special_variable__S_168DollarMinus
            i: 0
            min: 1
            name: special_variable__S_168DollarMinus_01
            r: 1
            s: 0
            zyg:
            - !!perl/hash:RE_meta
              a: 0
              alt: special_variable__S_168DollarMinus_01 0
              dba: special_variable__S_168DollarMinus
              i: 0
              min: 1
              r: 1
              s: 0
              text: \s
            - !!perl/hash:RE_string
              a: 0
              alt: special_variable__S_168DollarMinus_01 1
              dba: special_variable__S_168DollarMinus
              i: 0
              min: 1
              r: 1
              s: 0
              text: ','
            - !!perl/hash:RE_string
              a: 0
              alt: special_variable__S_168DollarMinus_01 2
              dba: special_variable__S_168DollarMinus
              i: 0
              min: 1
              r: 1
              s: 0
              text: =
            - !!perl/hash:RE_method
              a: 0
              alt: special_variable__S_168DollarMinus_01 3
              dba: special_variable__S_168DollarMinus
              i: 0
              min: 12345
              name: terminator
              r: 1
              rest: ''
              s: 0
        s: 0
    - !!perl/hash:RE_method
      min: 0
      name: obs
      nobind: 1
      rest: ('$- variable', 'Form module')
special_variable__S_168DollarMinus_01: *75
special_variable__S_169DollarEqual: !!perl/hash:RE_ast
  decl: []
  kind: token
  min: 12345
  pkg: ~
  re: !!perl/hash:RE_sequence
    a: 0
    dba: special_variable__S_169DollarEqual
    i: 0
    min: 12345
    r: 1
    s: 0
    zyg:
    - !!perl/hash:RE_method
      a: 0
      dba: special_variable__S_169DollarEqual
      i: 0
      min: 12345
      name: sym
      r: 1
      rest: ''
      s: 0
      sym: $=
    - !!perl/hash:RE_meta
      a: 0
      dba: special_variable__S_169DollarEqual
      i: 0
      min: 0
      r: 1
      s: 0
      text: '::'
    - !!perl/hash:RE_assertion
      assert: '?'
      min: 0
      re: !!perl/hash:RE_method_re
        a: 0
        dba: special_variable__S_169DollarEqual
        i: 0
        min: 0
        name: before
        nobind: 1
        r: 1
        re: !!perl/hash:RE_ast
          decl: []
          min: 1
          re: &76 !!perl/hash:RE_any
            a: 0
            altname: special_variable__S_169DollarEqual_01
            dba: special_variable__S_169DollarEqual
            i: 0
            min: 1
            name: special_variable__S_169DollarEqual_01
            r: 1
            s: 0
            zyg:
            - !!perl/hash:RE_meta
              a: 0
              alt: special_variable__S_169DollarEqual_01 0
              dba: special_variable__S_169DollarEqual
              i: 0
              min: 1
              r: 1
              s: 0
              text: \s
            - !!perl/hash:RE_string
              a: 0
              alt: special_variable__S_169DollarEqual_01 1
              dba: special_variable__S_169DollarEqual
              i: 0
              min: 1
              r: 1
              s: 0
              text: ','
            - !!perl/hash:RE_string
              a: 0
              alt: special_variable__S_169DollarEqual_01 2
              dba: special_variable__S_169DollarEqual
              i: 0
              min: 1
              r: 1
              s: 0
              text: =
            - !!perl/hash:RE_method
              a: 0
              alt: special_variable__S_169DollarEqual_01 3
              dba: special_variable__S_169DollarEqual
              i: 0
              min: 12345
              name: terminator
              r: 1
              rest: ''
              s: 0
        s: 0
    - !!perl/hash:RE_method
      min: 0
      name: obs
      nobind: 1
      rest: ('$= variable', 'Form module')
special_variable__S_169DollarEqual_01: *76
special_variable__S_170AtPlus: !!perl/hash:RE_ast
  decl: []
  kind: token
  min: 12345
  pkg: ~
  re: !!perl/hash:RE_sequence
    a: 0
    dba: special_variable__S_170AtPlus
    i: 0
    min: 12345
    r: 1
    s: 0
    zyg:
    - !!perl/hash:RE_method
      a: 0
      dba: special_variable__S_170AtPlus
      i: 0
      min: 12345
      name: sym
      r: 1
      rest: ''
      s: 0
      sym: '@+'
    - !!perl/hash:RE_meta
      a: 0
      dba: special_variable__S_170AtPlus
      i: 0
      min: 0
      r: 1
      s: 0
      text: '::'
    - !!perl/hash:RE_assertion
      assert: '?'
      min: 0
      re: !!perl/hash:RE_method_re
        a: 0
        dba: special_variable__S_170AtPlus
        i: 0
        min: 0
        name: before
        nobind: 1
        r: 1
        re: !!perl/hash:RE_ast
          decl: []
          min: 1
          re: &77 !!perl/hash:RE_any
            a: 0
            altname: special_variable__S_170AtPlus_01
            dba: special_variable__S_170AtPlus
            i: 0
            min: 1
            name: special_variable__S_170AtPlus_01
            r: 1
            s: 0
            zyg:
            - !!perl/hash:RE_meta
              a: 0
              alt: special_variable__S_170AtPlus_01 0
              dba: special_variable__S_170AtPlus
              i: 0
              min: 1
              r: 1
              s: 0
              text: \s
            - !!perl/hash:RE_string
              a: 0
              alt: special_variable__S_170AtPlus_01 1
              dba: special_variable__S_170AtPlus
              i: 0
              min: 1
              r: 1
              s: 0
              text: ','
            - !!perl/hash:RE_method
              a: 0
              alt: special_variable__S_170AtPlus_01 2
              dba: special_variable__S_170AtPlus
              i: 0
              min: 12345
              name: terminator
              r: 1
              rest: ''
              s: 0
        s: 0
    - !!perl/hash:RE_method
      min: 0
      name: obs
      nobind: 1
      rest: ('@+ variable', '.to method')
special_variable__S_170AtPlus_01: *77
special_variable__S_171PercentPlus: !!perl/hash:RE_ast
  decl: []
  kind: token
  min: 12345
  pkg: ~
  re: !!perl/hash:RE_sequence
    a: 0
    dba: special_variable__S_171PercentPlus
    i: 0
    min: 12345
    r: 1
    s: 0
    zyg:
    - !!perl/hash:RE_method
      a: 0
      dba: special_variable__S_171PercentPlus
      i: 0
      min: 12345
      name: sym
      r: 1
      rest: ''
      s: 0
      sym: '%+'
    - !!perl/hash:RE_meta
      a: 0
      dba: special_variable__S_171PercentPlus
      i: 0
      min: 0
      r: 1
      s: 0
      text: '::'
    - !!perl/hash:RE_assertion
      assert: '?'
      min: 0
      re: !!perl/hash:RE_method_re
        a: 0
        dba: special_variable__S_171PercentPlus
        i: 0
        min: 0
        name: before
        nobind: 1
        r: 1
        re: !!perl/hash:RE_ast
          decl: []
          min: 1
          re: &78 !!perl/hash:RE_any
            a: 0
            altname: special_variable__S_171PercentPlus_01
            dba: special_variable__S_171PercentPlus
            i: 0
            min: 1
            name: special_variable__S_171PercentPlus_01
            r: 1
            s: 0
            zyg:
            - !!perl/hash:RE_meta
              a: 0
              alt: special_variable__S_171PercentPlus_01 0
              dba: special_variable__S_171PercentPlus
              i: 0
              min: 1
              r: 1
              s: 0
              text: \s
            - !!perl/hash:RE_string
              a: 0
              alt: special_variable__S_171PercentPlus_01 1
              dba: special_variable__S_171PercentPlus
              i: 0
              min: 1
              r: 1
              s: 0
              text: ','
            - !!perl/hash:RE_method
              a: 0
              alt: special_variable__S_171PercentPlus_01 2
              dba: special_variable__S_171PercentPlus
              i: 0
              min: 12345
              name: terminator
              r: 1
              rest: ''
              s: 0
        s: 0
    - !!perl/hash:RE_method
      min: 0
      name: obs
      nobind: 1
      rest: ('%+ variable', '.to method')
special_variable__S_171PercentPlus_01: *78
special_variable__S_172DollarPlusBra_Ket: !!perl/hash:RE_ast
  decl: []
  kind: token
  min: 3
  pkg: ~
  re: !!perl/hash:RE_sequence
    a: 0
    dba: special_variable__S_172DollarPlusBra_Ket
    i: 0
    min: 3
    r: 1
    s: 0
    zyg:
    - !!perl/hash:RE_string
      a: 0
      dba: special_variable__S_172DollarPlusBra_Ket
      i: 0
      min: 3
      r: 1
      s: 0
      text: $+[
    - !!perl/hash:RE_method
      min: 0
      name: obs
      nobind: 1
      rest: ('@+ variable', '.to method')
special_variable__S_173AtPlusBra_Ket: !!perl/hash:RE_ast
  decl: []
  kind: token
  min: 3
  pkg: ~
  re: !!perl/hash:RE_sequence
    a: 0
    dba: special_variable__S_173AtPlusBra_Ket
    i: 0
    min: 3
    r: 1
    s: 0
    zyg:
    - !!perl/hash:RE_string
      a: 0
      dba: special_variable__S_173AtPlusBra_Ket
      i: 0
      min: 3
      r: 1
      s: 0
      text: '@+['
    - !!perl/hash:RE_method
      min: 0
      name: obs
      nobind: 1
      rest: ('@+ variable', '.to method')
special_variable__S_174AtPlusCur_Ly: !!perl/hash:RE_ast
  decl: []
  kind: token
  min: 3
  pkg: ~
  re: !!perl/hash:RE_sequence
    a: 0
    dba: special_variable__S_174AtPlusCur_Ly
    i: 0
    min: 3
    r: 1
    s: 0
    zyg:
    - !!perl/hash:RE_string
      a: 0
      dba: special_variable__S_174AtPlusCur_Ly
      i: 0
      min: 3
      r: 1
      s: 0
      text: '@+{'
    - !!perl/hash:RE_method
      min: 0
      name: obs
      nobind: 1
      rest: ('%+ variable', '.to method')
special_variable__S_175AtMinus: !!perl/hash:RE_ast
  decl: []
  kind: token
  min: 12345
  pkg: ~
  re: !!perl/hash:RE_sequence
    a: 0
    dba: special_variable__S_175AtMinus
    i: 0
    min: 12345
    r: 1
    s: 0
    zyg:
    - !!perl/hash:RE_method
      a: 0
      dba: special_variable__S_175AtMinus
      i: 0
      min: 12345
      name: sym
      r: 1
      rest: ''
      s: 0
      sym: '@-'
    - !!perl/hash:RE_meta
      a: 0
      dba: special_variable__S_175AtMinus
      i: 0
      min: 0
      r: 1
      s: 0
      text: '::'
    - !!perl/hash:RE_assertion
      assert: '?'
      min: 0
      re: !!perl/hash:RE_method_re
        a: 0
        dba: special_variable__S_175AtMinus
        i: 0
        min: 0
        name: before
        nobind: 1
        r: 1
        re: !!perl/hash:RE_ast
          decl: []
          min: 1
          re: &79 !!perl/hash:RE_any
            a: 0
            altname: special_variable__S_175AtMinus_01
            dba: special_variable__S_175AtMinus
            i: 0
            min: 1
            name: special_variable__S_175AtMinus_01
            r: 1
            s: 0
            zyg:
            - !!perl/hash:RE_meta
              a: 0
              alt: special_variable__S_175AtMinus_01 0
              dba: special_variable__S_175AtMinus
              i: 0
              min: 1
              r: 1
              s: 0
              text: \s
            - !!perl/hash:RE_string
              a: 0
              alt: special_variable__S_175AtMinus_01 1
              dba: special_variable__S_175AtMinus
              i: 0
              min: 1
              r: 1
              s: 0
              text: ','
            - !!perl/hash:RE_method
              a: 0
              alt: special_variable__S_175AtMinus_01 2
              dba: special_variable__S_175AtMinus
              i: 0
              min: 12345
              name: terminator
              r: 1
              rest: ''
              s: 0
        s: 0
    - !!perl/hash:RE_method
      min: 0
      name: obs
      nobind: 1
      rest: ('@- variable', '.from method')
special_variable__S_175AtMinus_01: *79
special_variable__S_176PercentMinus: !!perl/hash:RE_ast
  decl: []
  kind: token
  min: 12345
  pkg: ~
  re: !!perl/hash:RE_sequence
    a: 0
    dba: special_variable__S_176PercentMinus
    i: 0
    min: 12345
    r: 1
    s: 0
    zyg:
    - !!perl/hash:RE_method
      a: 0
      dba: special_variable__S_176PercentMinus
      i: 0
      min: 12345
      name: sym
      r: 1
      rest: ''
      s: 0
      sym: '%-'
    - !!perl/hash:RE_meta
      a: 0
      dba: special_variable__S_176PercentMinus
      i: 0
      min: 0
      r: 1
      s: 0
      text: '::'
    - !!perl/hash:RE_assertion
      assert: '?'
      min: 0
      re: !!perl/hash:RE_method_re
        a: 0
        dba: special_variable__S_176PercentMinus
        i: 0
        min: 0
        name: before
        nobind: 1
        r: 1
        re: !!perl/hash:RE_ast
          decl: []
          min: 1
          re: &80 !!perl/hash:RE_any
            a: 0
            altname: special_variable__S_176PercentMinus_01
            dba: special_variable__S_176PercentMinus
            i: 0
            min: 1
            name: special_variable__S_176PercentMinus_01
            r: 1
            s: 0
            zyg:
            - !!perl/hash:RE_meta
              a: 0
              alt: special_variable__S_176PercentMinus_01 0
              dba: special_variable__S_176PercentMinus
              i: 0
              min: 1
              r: 1
              s: 0
              text: \s
            - !!perl/hash:RE_string
              a: 0
              alt: special_variable__S_176PercentMinus_01 1
              dba: special_variable__S_176PercentMinus
              i: 0
              min: 1
              r: 1
              s: 0
              text: ','
            - !!perl/hash:RE_method
              a: 0
              alt: special_variable__S_176PercentMinus_01 2
              dba: special_variable__S_176PercentMinus
              i: 0
              min: 12345
              name: terminator
              r: 1
              rest: ''
              s: 0
        s: 0
    - !!perl/hash:RE_method
      min: 0
      name: obs
      nobind: 1
      rest: ('%- variable', '.from method')
special_variable__S_176PercentMinus_01: *80
special_variable__S_177DollarMinusBra_Ket: !!perl/hash:RE_ast
  decl: []
  kind: token
  min: 3
  pkg: ~
  re: !!perl/hash:RE_sequence
    a: 0
    dba: special_variable__S_177DollarMinusBra_Ket
    i: 0
    min: 3
    r: 1
    s: 0
    zyg:
    - !!perl/hash:RE_string
      a: 0
      dba: special_variable__S_177DollarMinusBra_Ket
      i: 0
      min: 3
      r: 1
      s: 0
      text: $-[
    - !!perl/hash:RE_method
      min: 0
      name: obs
      nobind: 1
      rest: ('@- variable', '.from method')
special_variable__S_178AtMinusBra_Ket: !!perl/hash:RE_ast
  decl: []
  kind: token
  min: 3
  pkg: ~
  re: !!perl/hash:RE_sequence
    a: 0
    dba: special_variable__S_178AtMinusBra_Ket
    i: 0
    min: 3
    r: 1
    s: 0
    zyg:
    - !!perl/hash:RE_string
      a: 0
      dba: special_variable__S_178AtMinusBra_Ket
      i: 0
      min: 3
      r: 1
      s: 0
      text: '@-['
    - !!perl/hash:RE_method
      min: 0
      name: obs
      nobind: 1
      rest: ('@- variable', '.from method')
special_variable__S_179PercentMinusCur_Ly: !!perl/hash:RE_ast
  decl: []
  kind: token
  min: 3
  pkg: ~
  re: !!perl/hash:RE_sequence
    a: 0
    dba: special_variable__S_179PercentMinusCur_Ly
    i: 0
    min: 3
    r: 1
    s: 0
    zyg:
    - !!perl/hash:RE_string
      a: 0
      dba: special_variable__S_179PercentMinusCur_Ly
      i: 0
      min: 3
      r: 1
      s: 0
      text: '@-{'
    - !!perl/hash:RE_method
      min: 0
      name: obs
      nobind: 1
      rest: ('%- variable', '.from method')
special_variable__S_180DollarPlus: !!perl/hash:RE_ast
  decl: []
  kind: token
  min: 12345
  pkg: ~
  re: !!perl/hash:RE_sequence
    a: 0
    dba: special_variable__S_180DollarPlus
    i: 0
    min: 12345
    r: 1
    s: 0
    zyg:
    - !!perl/hash:RE_method
      a: 0
      dba: special_variable__S_180DollarPlus
      i: 0
      min: 12345
      name: sym
      r: 1
      rest: ''
      s: 0
      sym: $+
    - !!perl/hash:RE_meta
      a: 0
      dba: special_variable__S_180DollarPlus
      i: 0
      min: 0
      r: 1
      s: 0
      text: '::'
    - !!perl/hash:RE_assertion
      assert: '?'
      min: 0
      re: !!perl/hash:RE_method_re
        a: 0
        dba: special_variable__S_180DollarPlus
        i: 0
        min: 0
        name: before
        nobind: 1
        r: 1
        re: !!perl/hash:RE_ast
          decl: []
          min: 1
          re: &81 !!perl/hash:RE_any
            a: 0
            altname: special_variable__S_180DollarPlus_01
            dba: special_variable__S_180DollarPlus
            i: 0
            min: 1
            name: special_variable__S_180DollarPlus_01
            r: 1
            s: 0
            zyg:
            - !!perl/hash:RE_meta
              a: 0
              alt: special_variable__S_180DollarPlus_01 0
              dba: special_variable__S_180DollarPlus
              i: 0
              min: 1
              r: 1
              s: 0
              text: \s
            - !!perl/hash:RE_string
              a: 0
              alt: special_variable__S_180DollarPlus_01 1
              dba: special_variable__S_180DollarPlus
              i: 0
              min: 1
              r: 1
              s: 0
              text: ','
            - !!perl/hash:RE_method
              a: 0
              alt: special_variable__S_180DollarPlus_01 2
              dba: special_variable__S_180DollarPlus
              i: 0
              min: 12345
              name: terminator
              r: 1
              rest: ''
              s: 0
        s: 0
    - !!perl/hash:RE_method
      min: 0
      name: obs
      nobind: 1
      rest: ('$+ variable', 'Form module')
special_variable__S_180DollarPlus_01: *81
special_variable__S_181DollarCurCaret_Ly: !!perl/hash:RE_ast
  decl: []
  kind: token
  min: 12349
  pkg: ~
  re: !!perl/hash:RE_sequence
    a: 0
    dba: special_variable__S_181DollarCurCaret_Ly
    i: 0
    min: 12349
    r: 1
    s: 0
    zyg:
    - !!perl/hash:RE_method
      a: 0
      dba: special_variable__S_181DollarCurCaret_Ly
      i: 0
      min: 12345
      name: sigil
      r: 1
      rest: ''
      s: 0
    - !!perl/hash:RE_string
      a: 0
      dba: special_variable__S_181DollarCurCaret_Ly
      i: 0
      min: 2
      r: 1
      s: 0
      text: '{^'
    - !!perl/hash:RE_meta
      a: 0
      dba: special_variable__S_181DollarCurCaret_Ly
      i: 0
      min: 0
      r: 1
      s: 0
      text: '::'
    - !!perl/hash:RE_bindnamed
      a: 0
      atom: !!perl/hash:RE_bracket
        decl: []
        min: 1
        re: !!perl/hash:RE_meta
          a: 0
          dba: special_variable__S_181DollarCurCaret_Ly
          i: 0
          min: 1
          r: 1
          s: 0
          text: .*?
      dba: special_variable__S_181DollarCurCaret_Ly
      i: 0
      min: 1
      r: 1
      s: 0
      var: text
    - !!perl/hash:RE_string
      a: 0
      dba: special_variable__S_181DollarCurCaret_Ly
      i: 0
      min: 1
      r: 1
      s: 0
      text: '}'
    - !!perl/hash:RE_method
      min: 0
      name: obscaret
      nobind: 1
      rest: ($<sigil>.Str ~ '{^' ~ $<text>.Str ~ '}', $<sigil>.Str, $<text>.Str)
special_variable__S_182ColonColonCur_Ly: !!perl/hash:RE_ast
  decl: []
  kind: token
  min: 2
  pkg: ~
  re: !!perl/hash:RE_sequence
    a: 0
    dba: special_variable__S_182ColonColonCur_Ly
    i: 0
    min: 2
    r: 1
    s: 0
    zyg:
    - !!perl/hash:RE_string
      a: 0
      dba: special_variable__S_182ColonColonCur_Ly
      i: 0
      min: 2
      r: 1
      s: 0
      text: '::'
    - !!perl/hash:RE_assertion
      assert: '?'
      min: 0
      re: !!perl/hash:RE_method_re
        a: 0
        dba: special_variable__S_182ColonColonCur_Ly
        i: 0
        min: 0
        name: before
        nobind: 1
        r: 1
        re: !!perl/hash:RE_ast
          decl: []
          min: 1
          re: !!perl/hash:RE_string
            a: 0
            dba: special_variable__S_182ColonColonCur_Ly
            i: 0
            min: 1
            r: 1
            s: 0
            text: '{'
        s: 0
special_variable__S_183DollarCur_Ly: !!perl/hash:RE_ast
  decl: []
  kind: regex
  min: 12348
  pkg: ~
  re: !!perl/hash:RE_sequence
    a: 0
    dba: special_variable__S_183DollarCur_Ly
    i: 0
    min: 12348
    r: 0
    s: 0
    zyg:
    - !!perl/hash:RE_method
      a: 0
      dba: special_variable__S_183DollarCur_Ly
      i: 0
      min: 12345
      name: sigil
      r: 0
      rest: ''
      s: 0
    - !!perl/hash:RE_string
      a: 0
      dba: special_variable__S_183DollarCur_Ly
      i: 0
      min: 1
      r: 0
      s: 0
      text: '{'
    - !!perl/hash:RE_block
      a: 0
      context: void
      dba: special_variable__S_183DollarCur_Ly
      i: 0
      min: 0
      r: 0
      s: 0
      text: ''
    - !!perl/hash:RE_bindnamed
      a: 0
      atom: !!perl/hash:RE_bracket
        decl: []
        min: 1
        re: !!perl/hash:RE_meta
          a: 0
          dba: special_variable__S_183DollarCur_Ly
          i: 0
          min: 1
          r: 0
          s: 0
          text: .*?
      dba: special_variable__S_183DollarCur_Ly
      i: 0
      min: 1
      r: 0
      s: 0
      var: text
    - !!perl/hash:RE_string
      a: 0
      dba: special_variable__S_183DollarCur_Ly
      i: 0
      min: 1
      r: 0
      s: 0
      text: '}'
    - !!perl/hash:RE_block
      a: 0
      context: void
      dba: special_variable__S_183DollarCur_Ly
      i: 0
      min: 0
      r: 0
      s: 0
      text: "\n            my $sigil = $<sigil>.Str;\n            my $text = $<text>.Str;\n
        \           my $bad = $sigil ~ '{' ~ $text ~ '}';\n            $text = $text
        - 1 if $text ~~ /^\\d+$/;\n            if $text !~~ /^(\\w|\\:)+$/ {\n                $.obs($bad,
        $sigil ~ '(' ~ $text ~ ')');\n            }\n            elsif $*QSIGIL {\n
        \               $.obs($bad, '{' ~ $sigil ~ $text ~ '}');\n            }\n
        \           else {\n                $.obs($bad, $sigil ~ $text);\n            }\n
        \       "
special_variable__S_184DollarBra: !!perl/hash:RE_ast
  decl: []
  kind: token
  min: 12345
  pkg: ~
  re: !!perl/hash:RE_sequence
    a: 0
    dba: special_variable__S_184DollarBra
    i: 0
    min: 12345
    r: 1
    s: 0
    zyg:
    - !!perl/hash:RE_method
      a: 0
      dba: special_variable__S_184DollarBra
      i: 0
      min: 12345
      name: sym
      r: 1
      rest: ''
      s: 0
      sym: $[
    - !!perl/hash:RE_meta
      a: 0
      dba: special_variable__S_184DollarBra
      i: 0
      min: 0
      r: 1
      s: 0
      text: '::'
    - !!perl/hash:RE_assertion
      assert: '?'
      min: 0
      re: !!perl/hash:RE_method_re
        a: 0
        dba: special_variable__S_184DollarBra
        i: 0
        min: 0
        name: before
        nobind: 1
        r: 1
        re: !!perl/hash:RE_ast
          decl: []
          min: 1
          re: &82 !!perl/hash:RE_any
            a: 0
            altname: special_variable__S_184DollarBra_01
            dba: special_variable__S_184DollarBra
            i: 0
            min: 1
            name: special_variable__S_184DollarBra_01
            r: 1
            s: 0
            zyg:
            - !!perl/hash:RE_meta
              a: 0
              alt: special_variable__S_184DollarBra_01 0
              dba: special_variable__S_184DollarBra
              i: 0
              min: 1
              r: 1
              s: 0
              text: \s
            - !!perl/hash:RE_string
              a: 0
              alt: special_variable__S_184DollarBra_01 1
              dba: special_variable__S_184DollarBra
              i: 0
              min: 1
              r: 1
              s: 0
              text: ','
            - !!perl/hash:RE_string
              a: 0
              alt: special_variable__S_184DollarBra_01 2
              dba: special_variable__S_184DollarBra
              i: 0
              min: 1
              r: 1
              s: 0
              text: =
            - !!perl/hash:RE_method
              a: 0
              alt: special_variable__S_184DollarBra_01 3
              dba: special_variable__S_184DollarBra
              i: 0
              min: 12345
              name: terminator
              r: 1
              rest: ''
              s: 0
        s: 0
    - !!perl/hash:RE_method
      min: 0
      name: obs
      nobind: 1
      rest: ('$[ variable', 'user-defined array indices')
special_variable__S_184DollarBra_01: *82
special_variable__S_185DollarKet: !!perl/hash:RE_ast
  decl: []
  kind: token
  min: 12345
  pkg: ~
  re: !!perl/hash:RE_sequence
    a: 0
    dba: special_variable__S_185DollarKet
    i: 0
    min: 12345
    r: 1
    s: 0
    zyg:
    - !!perl/hash:RE_method
      a: 0
      dba: special_variable__S_185DollarKet
      i: 0
      min: 12345
      name: sym
      r: 1
      rest: ''
      s: 0
      sym: $]
    - !!perl/hash:RE_meta
      a: 0
      dba: special_variable__S_185DollarKet
      i: 0
      min: 0
      r: 1
      s: 0
      text: '::'
    - !!perl/hash:RE_assertion
      assert: '?'
      min: 0
      re: !!perl/hash:RE_method_re
        a: 0
        dba: special_variable__S_185DollarKet
        i: 0
        min: 0
        name: before
        nobind: 1
        r: 1
        re: !!perl/hash:RE_ast
          decl: []
          min: 1
          re: &83 !!perl/hash:RE_any
            a: 0
            altname: special_variable__S_185DollarKet_01
            dba: special_variable__S_185DollarKet
            i: 0
            min: 1
            name: special_variable__S_185DollarKet_01
            r: 1
            s: 0
            zyg:
            - !!perl/hash:RE_meta
              a: 0
              alt: special_variable__S_185DollarKet_01 0
              dba: special_variable__S_185DollarKet
              i: 0
              min: 1
              r: 1
              s: 0
              text: \s
            - !!perl/hash:RE_string
              a: 0
              alt: special_variable__S_185DollarKet_01 1
              dba: special_variable__S_185DollarKet
              i: 0
              min: 1
              r: 1
              s: 0
              text: ','
            - !!perl/hash:RE_method
              a: 0
              alt: special_variable__S_185DollarKet_01 2
              dba: special_variable__S_185DollarKet
              i: 0
              min: 12345
              name: terminator
              r: 1
              rest: ''
              s: 0
        s: 0
    - !!perl/hash:RE_method
      min: 0
      name: obs
      nobind: 1
      rest: ('$] variable', '$*PERL_VERSION')
special_variable__S_185DollarKet_01: *83
special_variable__S_186DollarBack: !!perl/hash:RE_ast
  decl: []
  kind: token
  min: 12345
  pkg: ~
  re: !!perl/hash:RE_sequence
    a: 0
    dba: special_variable__S_186DollarBack
    i: 0
    min: 12345
    r: 1
    s: 0
    zyg:
    - !!perl/hash:RE_method
      a: 0
      dba: special_variable__S_186DollarBack
      i: 0
      min: 12345
      name: sym
      r: 1
      rest: ''
      s: 0
      sym: $\
    - !!perl/hash:RE_meta
      a: 0
      dba: special_variable__S_186DollarBack
      i: 0
      min: 0
      r: 1
      s: 0
      text: '::'
    - !!perl/hash:RE_assertion
      assert: '?'
      min: 0
      re: !!perl/hash:RE_method_re
        a: 0
        dba: special_variable__S_186DollarBack
        i: 0
        min: 0
        name: before
        nobind: 1
        r: 1
        re: !!perl/hash:RE_ast
          decl: []
          min: 1
          re: &84 !!perl/hash:RE_any
            a: 0
            altname: special_variable__S_186DollarBack_01
            dba: special_variable__S_186DollarBack
            i: 0
            min: 1
            name: special_variable__S_186DollarBack_01
            r: 1
            s: 0
            zyg:
            - !!perl/hash:RE_meta
              a: 0
              alt: special_variable__S_186DollarBack_01 0
              dba: special_variable__S_186DollarBack
              i: 0
              min: 1
              r: 1
              s: 0
              text: \s
            - !!perl/hash:RE_string
              a: 0
              alt: special_variable__S_186DollarBack_01 1
              dba: special_variable__S_186DollarBack
              i: 0
              min: 1
              r: 1
              s: 0
              text: ','
            - !!perl/hash:RE_string
              a: 0
              alt: special_variable__S_186DollarBack_01 2
              dba: special_variable__S_186DollarBack
              i: 0
              min: 1
              r: 1
              s: 0
              text: =
            - !!perl/hash:RE_method
              a: 0
              alt: special_variable__S_186DollarBack_01 3
              dba: special_variable__S_186DollarBack
              i: 0
              min: 12345
              name: terminator
              r: 1
              rest: ''
              s: 0
        s: 0
    - !!perl/hash:RE_method
      min: 0
      name: obs
      nobind: 1
      rest: ('$\\ variable', "the filehandle's :ors attribute")
special_variable__S_186DollarBack_01: *84
special_variable__S_187DollarVert: !!perl/hash:RE_ast
  decl: []
  kind: token
  min: 12345
  pkg: ~
  re: !!perl/hash:RE_sequence
    a: 0
    dba: special_variable__S_187DollarVert
    i: 0
    min: 12345
    r: 1
    s: 0
    zyg:
    - !!perl/hash:RE_method
      a: 0
      dba: special_variable__S_187DollarVert
      i: 0
      min: 12345
      name: sym
      r: 1
      rest: ''
      s: 0
      sym: $|
    - !!perl/hash:RE_meta
      a: 0
      dba: special_variable__S_187DollarVert
      i: 0
      min: 0
      r: 1
      s: 0
      text: '::'
    - !!perl/hash:RE_assertion
      assert: '?'
      min: 0
      re: !!perl/hash:RE_method_re
        a: 0
        dba: special_variable__S_187DollarVert
        i: 0
        min: 0
        name: before
        nobind: 1
        r: 1
        re: !!perl/hash:RE_ast
          decl: []
          min: 1
          re: &85 !!perl/hash:RE_any
            a: 0
            altname: special_variable__S_187DollarVert_01
            dba: special_variable__S_187DollarVert
            i: 0
            min: 1
            name: special_variable__S_187DollarVert_01
            r: 1
            s: 0
            zyg:
            - !!perl/hash:RE_meta
              a: 0
              alt: special_variable__S_187DollarVert_01 0
              dba: special_variable__S_187DollarVert
              i: 0
              min: 1
              r: 1
              s: 0
              text: \s
            - !!perl/hash:RE_string
              a: 0
              alt: special_variable__S_187DollarVert_01 1
              dba: special_variable__S_187DollarVert
              i: 0
              min: 1
              r: 1
              s: 0
              text: ','
            - !!perl/hash:RE_string
              a: 0
              alt: special_variable__S_187DollarVert_01 2
              dba: special_variable__S_187DollarVert
              i: 0
              min: 1
              r: 1
              s: 0
              text: =
            - !!perl/hash:RE_method
              a: 0
              alt: special_variable__S_187DollarVert_01 3
              dba: special_variable__S_187DollarVert
              i: 0
              min: 12345
              name: terminator
              r: 1
              rest: ''
              s: 0
        s: 0
    - !!perl/hash:RE_method
      min: 0
      name: obs
      nobind: 1
      rest: ('$| variable', ':autoflush on open')
special_variable__S_187DollarVert_01: *85
special_variable__S_188DollarColon: !!perl/hash:RE_ast
  decl: []
  kind: token
  min: 12345
  pkg: ~
  re: !!perl/hash:RE_sequence
    a: 0
    dba: special_variable__S_188DollarColon
    i: 0
    min: 12345
    r: 1
    s: 0
    zyg:
    - !!perl/hash:RE_method
      a: 0
      dba: special_variable__S_188DollarColon
      i: 0
      min: 12345
      name: sym
      r: 1
      rest: ''
      s: 0
      sym: '$:'
    - !!perl/hash:RE_assertion
      assert: '?'
      min: 0
      re: !!perl/hash:RE_method_re
        a: 0
        dba: special_variable__S_188DollarColon
        i: 0
        min: 0
        name: before
        nobind: 1
        r: 1
        re: !!perl/hash:RE_ast
          decl: []
          min: 1
          re: !!perl/hash:RE_cclass
            a: 0
            dba: special_variable__S_188DollarColon
            i: 0
            min: 1
            r: 1
            s: 0
            text: '[\x20\t\n\],=)}]'
        s: 0
    - !!perl/hash:RE_method
      min: 0
      name: obs
      nobind: 1
      rest: '(''$: variable'', ''Form module'')'
special_variable__S_189DollarSemi: !!perl/hash:RE_ast
  decl: []
  kind: token
  min: 12345
  pkg: ~
  re: !!perl/hash:RE_sequence
    a: 0
    dba: special_variable__S_189DollarSemi
    i: 0
    min: 12345
    r: 1
    s: 0
    zyg:
    - !!perl/hash:RE_method
      a: 0
      dba: special_variable__S_189DollarSemi
      i: 0
      min: 12345
      name: sym
      r: 1
      rest: ''
      s: 0
      sym: $;
    - !!perl/hash:RE_meta
      a: 0
      dba: special_variable__S_189DollarSemi
      i: 0
      min: 0
      r: 1
      s: 0
      text: '::'
    - !!perl/hash:RE_assertion
      assert: '?'
      min: 0
      re: !!perl/hash:RE_method_re
        a: 0
        dba: special_variable__S_189DollarSemi
        i: 0
        min: 0
        name: before
        nobind: 1
        r: 1
        re: !!perl/hash:RE_ast
          decl: []
          min: 1
          re: &86 !!perl/hash:RE_any
            a: 0
            altname: special_variable__S_189DollarSemi_01
            dba: special_variable__S_189DollarSemi
            i: 0
            min: 1
            name: special_variable__S_189DollarSemi_01
            r: 1
            s: 0
            zyg:
            - !!perl/hash:RE_meta
              a: 0
              alt: special_variable__S_189DollarSemi_01 0
              dba: special_variable__S_189DollarSemi
              i: 0
              min: 1
              r: 1
              s: 0
              text: \s
            - !!perl/hash:RE_string
              a: 0
              alt: special_variable__S_189DollarSemi_01 1
              dba: special_variable__S_189DollarSemi
              i: 0
              min: 1
              r: 1
              s: 0
              text: ','
            - !!perl/hash:RE_string
              a: 0
              alt: special_variable__S_189DollarSemi_01 2
              dba: special_variable__S_189DollarSemi
              i: 0
              min: 1
              r: 1
              s: 0
              text: =
            - !!perl/hash:RE_method
              a: 0
              alt: special_variable__S_189DollarSemi_01 3
              dba: special_variable__S_189DollarSemi
              i: 0
              min: 12345
              name: terminator
              r: 1
              rest: ''
              s: 0
        s: 0
    - !!perl/hash:RE_method
      min: 0
      name: obs
      nobind: 1
      rest: ('$; variable', 'real multidimensional hashes')
special_variable__S_189DollarSemi_01: *86
special_variable__S_190DollarSingle: !!perl/hash:RE_ast
  decl: []
  kind: token
  min: 12345
  pkg: ~
  re: !!perl/hash:RE_sequence
    a: 0
    dba: special_variable__S_190DollarSingle
    i: 0
    min: 12345
    r: 1
    s: 0
    zyg:
    - !!perl/hash:RE_method
      a: 0
      dba: special_variable__S_190DollarSingle
      i: 0
      min: 12345
      name: sym
      r: 1
      rest: ''
      s: 0
      sym: $'
    - !!perl/hash:RE_meta
      a: 0
      dba: special_variable__S_190DollarSingle
      i: 0
      min: 0
      r: 1
      s: 0
      text: '::'
    - !!perl/hash:RE_assertion
      assert: '?'
      min: 0
      re: !!perl/hash:RE_method_re
        a: 0
        dba: special_variable__S_190DollarSingle
        i: 0
        min: 0
        name: before
        nobind: 1
        r: 1
        re: !!perl/hash:RE_ast
          decl: []
          min: 1
          re: &87 !!perl/hash:RE_any
            a: 0
            altname: special_variable__S_190DollarSingle_01
            dba: special_variable__S_190DollarSingle
            i: 0
            min: 1
            name: special_variable__S_190DollarSingle_01
            r: 1
            s: 0
            zyg:
            - !!perl/hash:RE_meta
              a: 0
              alt: special_variable__S_190DollarSingle_01 0
              dba: special_variable__S_190DollarSingle
              i: 0
              min: 1
              r: 1
              s: 0
              text: \s
            - !!perl/hash:RE_string
              a: 0
              alt: special_variable__S_190DollarSingle_01 1
              dba: special_variable__S_190DollarSingle
              i: 0
              min: 1
              r: 1
              s: 0
              text: ','
            - !!perl/hash:RE_method
              a: 0
              alt: special_variable__S_190DollarSingle_01 2
              dba: special_variable__S_190DollarSingle
              i: 0
              min: 12345
              name: terminator
              r: 1
              rest: ''
              s: 0
        s: 0
    - !!perl/hash:RE_method
      min: 0
      name: obs
      nobind: 1
      rest: ('$' ~ "'" ~ 'variable', "explicit pattern after )\x3E")
special_variable__S_190DollarSingle_01: *87
special_variable__S_191DollarDouble: !!perl/hash:RE_ast
  decl: []
  kind: token
  min: 12345
  pkg: ~
  re: !!perl/hash:RE_sequence
    a: 0
    dba: special_variable__S_191DollarDouble
    i: 0
    min: 12345
    r: 1
    s: 0
    zyg:
    - !!perl/hash:RE_method
      a: 0
      dba: special_variable__S_191DollarDouble
      i: 0
      min: 12345
      name: sym
      r: 1
      rest: ''
      s: 0
      sym: $"
    - !!perl/hash:RE_assertion
      assert: '!'
      min: 0
      re: !!perl/hash:RE_block
        a: 0
        context: bool
        dba: special_variable__S_191DollarDouble
        i: 0
        min: 0
        nobind: 1
        r: 1
        s: 0
        text: ' $*QSIGIL '
    - !!perl/hash:RE_meta
      a: 0
      dba: special_variable__S_191DollarDouble
      i: 0
      min: 0
      r: 1
      s: 0
      text: '::'
    - !!perl/hash:RE_assertion
      assert: '?'
      min: 0
      re: !!perl/hash:RE_method_re
        a: 0
        dba: special_variable__S_191DollarDouble
        i: 0
        min: 0
        name: before
        nobind: 1
        r: 1
        re: !!perl/hash:RE_ast
          decl: []
          min: 1
          re: &88 !!perl/hash:RE_any
            a: 0
            altname: special_variable__S_191DollarDouble_01
            dba: special_variable__S_191DollarDouble
            i: 0
            min: 1
            name: special_variable__S_191DollarDouble_01
            r: 1
            s: 0
            zyg:
            - !!perl/hash:RE_meta
              a: 0
              alt: special_variable__S_191DollarDouble_01 0
              dba: special_variable__S_191DollarDouble
              i: 0
              min: 1
              r: 1
              s: 0
              text: \s
            - !!perl/hash:RE_string
              a: 0
              alt: special_variable__S_191DollarDouble_01 1
              dba: special_variable__S_191DollarDouble
              i: 0
              min: 1
              r: 1
              s: 0
              text: ','
            - !!perl/hash:RE_string
              a: 0
              alt: special_variable__S_191DollarDouble_01 2
              dba: special_variable__S_191DollarDouble
              i: 0
              min: 1
              r: 1
              s: 0
              text: =
            - !!perl/hash:RE_method
              a: 0
              alt: special_variable__S_191DollarDouble_01 3
              dba: special_variable__S_191DollarDouble
              i: 0
              min: 12345
              name: terminator
              r: 1
              rest: ''
              s: 0
        s: 0
    - !!perl/hash:RE_method
      min: 0
      name: obs
      nobind: 1
      rest: ('$" variable', '.join() method')
special_variable__S_191DollarDouble_01: *88
special_variable__S_192DollarComma: !!perl/hash:RE_ast
  decl: []
  kind: token
  min: 12345
  pkg: ~
  re: !!perl/hash:RE_sequence
    a: 0
    dba: special_variable__S_192DollarComma
    i: 0
    min: 12345
    r: 1
    s: 0
    zyg:
    - !!perl/hash:RE_method
      a: 0
      dba: special_variable__S_192DollarComma
      i: 0
      min: 12345
      name: sym
      r: 1
      rest: ''
      s: 0
      sym: $,
    - !!perl/hash:RE_meta
      a: 0
      dba: special_variable__S_192DollarComma
      i: 0
      min: 0
      r: 1
      s: 0
      text: '::'
    - !!perl/hash:RE_assertion
      assert: '?'
      min: 0
      re: !!perl/hash:RE_method_re
        a: 0
        dba: special_variable__S_192DollarComma
        i: 0
        min: 0
        name: before
        nobind: 1
        r: 1
        re: !!perl/hash:RE_ast
          decl: []
          min: 1
          re: &89 !!perl/hash:RE_any
            a: 0
            altname: special_variable__S_192DollarComma_01
            dba: special_variable__S_192DollarComma
            i: 0
            min: 1
            name: special_variable__S_192DollarComma_01
            r: 1
            s: 0
            zyg:
            - !!perl/hash:RE_meta
              a: 0
              alt: special_variable__S_192DollarComma_01 0
              dba: special_variable__S_192DollarComma
              i: 0
              min: 1
              r: 1
              s: 0
              text: \s
            - !!perl/hash:RE_string
              a: 0
              alt: special_variable__S_192DollarComma_01 1
              dba: special_variable__S_192DollarComma
              i: 0
              min: 1
              r: 1
              s: 0
              text: ','
            - !!perl/hash:RE_method
              a: 0
              alt: special_variable__S_192DollarComma_01 2
              dba: special_variable__S_192DollarComma
              i: 0
              min: 12345
              name: terminator
              r: 1
              rest: ''
              s: 0
        s: 0
    - !!perl/hash:RE_method
      min: 0
      name: obs
      nobind: 1
      rest: ('$, variable', ".join() method")
special_variable__S_192DollarComma_01: *89
special_variable__S_193DollarLt: !!perl/hash:RE_ast
  decl: []
  kind: token
  min: 12345
  pkg: ~
  re: !!perl/hash:RE_sequence
    a: 0
    dba: special_variable__S_193DollarLt
    i: 0
    min: 12345
    r: 1
    s: 0
    zyg:
    - !!perl/hash:RE_method
      a: 0
      dba: special_variable__S_193DollarLt
      i: 0
      min: 12345
      name: sym
      r: 1
      rest: ''
      s: 0
      sym: '[''$<'']'
    - !!perl/hash:RE_meta
      a: 0
      dba: special_variable__S_193DollarLt
      i: 0
      min: 0
      r: 1
      s: 0
      text: '::'
    - !!perl/hash:RE_assertion
      assert: '!'
      min: 0
      re: !!perl/hash:RE_method_re
        a: 0
        dba: special_variable__S_193DollarLt
        i: 0
        min: 0
        name: before
        nobind: 1
        r: 1
        re: !!perl/hash:RE_ast
          decl: []
          min: 2
          re: !!perl/hash:RE_sequence
            a: 0
            dba: special_variable__S_193DollarLt
            i: 0
            min: 2
            r: 1
            s: 0
            zyg:
            - !!perl/hash:RE_quantified_atom
              atom: !!perl/hash:RE_meta
                a: 0
                dba: special_variable__S_193DollarLt
                i: 0
                min: 1
                r: 1
                s: 0
                text: \s
              min: 0
              quant:
              - '*'
              - ':'
              - ''
              - 0
            - !!perl/hash:RE_quantified_atom
              atom: !!perl/hash:RE_meta
                a: 0
                dba: special_variable__S_193DollarLt
                i: 0
                min: 1
                r: 1
                s: 0
                text: \w
              min: 1
              quant:
              - +
              - ':'
              - ''
              - 1
            - !!perl/hash:RE_quantified_atom
              atom: !!perl/hash:RE_meta
                a: 0
                dba: special_variable__S_193DollarLt
                i: 0
                min: 1
                r: 1
                s: 0
                text: \s
              min: 0
              quant:
              - '*'
              - ':'
              - ''
              - 0
            - !!perl/hash:RE_string
              a: 0
              dba: special_variable__S_193DollarLt
              i: 0
              min: 1
              r: 1
              s: 0
              text: '>'
        s: 0
    - !!perl/hash:RE_method
      min: 0
      name: obs
      nobind: 1
      rest: ('$< variable', '$*UID')
special_variable__S_194DollarGt: !!perl/hash:RE_ast
  decl: []
  kind: token
  min: 12345
  pkg: ~
  re: !!perl/hash:RE_sequence
    a: 0
    dba: special_variable__S_194DollarGt
    i: 0
    min: 12345
    r: 1
    s: 0
    zyg:
    - !!perl/hash:RE_method
      a: 0
      dba: special_variable__S_194DollarGt
      i: 0
      min: 12345
      name: sym
      r: 1
      rest: ''
      s: 0
      sym: $>
    - !!perl/hash:RE_meta
      a: 0
      dba: special_variable__S_194DollarGt
      i: 0
      min: 0
      r: 1
      s: 0
      text: '::'
    - !!perl/hash:RE_assertion
      assert: '?'
      min: 0
      re: !!perl/hash:RE_method_re
        a: 0
        dba: special_variable__S_194DollarGt
        i: 0
        min: 0
        name: before
        nobind: 1
        r: 1
        re: !!perl/hash:RE_ast
          decl: []
          min: 1
          re: &90 !!perl/hash:RE_any
            a: 0
            altname: special_variable__S_194DollarGt_01
            dba: special_variable__S_194DollarGt
            i: 0
            min: 1
            name: special_variable__S_194DollarGt_01
            r: 1
            s: 0
            zyg:
            - !!perl/hash:RE_meta
              a: 0
              alt: special_variable__S_194DollarGt_01 0
              dba: special_variable__S_194DollarGt
              i: 0
              min: 1
              r: 1
              s: 0
              text: \s
            - !!perl/hash:RE_string
              a: 0
              alt: special_variable__S_194DollarGt_01 1
              dba: special_variable__S_194DollarGt
              i: 0
              min: 1
              r: 1
              s: 0
              text: ','
            - !!perl/hash:RE_method
              a: 0
              alt: special_variable__S_194DollarGt_01 2
              dba: special_variable__S_194DollarGt
              i: 0
              min: 12345
              name: terminator
              r: 1
              rest: ''
              s: 0
        s: 0
    - !!perl/hash:RE_method
      min: 0
      name: obs
      nobind: 1
      rest: ('$> variable', '$*EUID')
special_variable__S_194DollarGt_01: *90
special_variable__S_195DollarDot: !!perl/hash:RE_ast
  decl: []
  kind: token
  min: 12345
  pkg: ~
  re: !!perl/hash:RE_sequence
    a: 0
    dba: special_variable__S_195DollarDot
    i: 0
    min: 12345
    r: 1
    s: 0
    zyg:
    - !!perl/hash:RE_method
      a: 0
      dba: special_variable__S_195DollarDot
      i: 0
      min: 12345
      name: sym
      r: 1
      rest: ''
      s: 0
      sym: $.
    - !!perl/hash:RE_meta
      a: 0
      dba: special_variable__S_195DollarDot
      i: 0
      min: 0
      r: 1
      s: 0
      text: '::'
    - !!perl/hash:RE_assertion
      assert: '?'
      min: 0
      re: !!perl/hash:RE_method_re
        a: 0
        dba: special_variable__S_195DollarDot
        i: 0
        min: 0
        name: before
        nobind: 1
        r: 1
        re: !!perl/hash:RE_ast
          decl: []
          min: 1
          re: &91 !!perl/hash:RE_any
            a: 0
            altname: special_variable__S_195DollarDot_01
            dba: special_variable__S_195DollarDot
            i: 0
            min: 1
            name: special_variable__S_195DollarDot_01
            r: 1
            s: 0
            zyg:
            - !!perl/hash:RE_meta
              a: 0
              alt: special_variable__S_195DollarDot_01 0
              dba: special_variable__S_195DollarDot
              i: 0
              min: 1
              r: 1
              s: 0
              text: \s
            - !!perl/hash:RE_string
              a: 0
              alt: special_variable__S_195DollarDot_01 1
              dba: special_variable__S_195DollarDot
              i: 0
              min: 1
              r: 1
              s: 0
              text: ','
            - !!perl/hash:RE_method
              a: 0
              alt: special_variable__S_195DollarDot_01 2
              dba: special_variable__S_195DollarDot
              i: 0
              min: 12345
              name: terminator
              r: 1
              rest: ''
              s: 0
        s: 0
    - !!perl/hash:RE_method
      min: 0
      name: obs
      nobind: 1
      rest: ('$. variable', "the filehandle's .line method")
special_variable__S_195DollarDot_01: *91
special_variable__S_196DollarQuestion: !!perl/hash:RE_ast
  decl: []
  kind: token
  min: 12345
  pkg: ~
  re: !!perl/hash:RE_sequence
    a: 0
    dba: special_variable__S_196DollarQuestion
    i: 0
    min: 12345
    r: 1
    s: 0
    zyg:
    - !!perl/hash:RE_method
      a: 0
      dba: special_variable__S_196DollarQuestion
      i: 0
      min: 12345
      name: sym
      r: 1
      rest: ''
      s: 0
      sym: $?
    - !!perl/hash:RE_meta
      a: 0
      dba: special_variable__S_196DollarQuestion
      i: 0
      min: 0
      r: 1
      s: 0
      text: '::'
    - !!perl/hash:RE_assertion
      assert: '?'
      min: 0
      re: !!perl/hash:RE_method_re
        a: 0
        dba: special_variable__S_196DollarQuestion
        i: 0
        min: 0
        name: before
        nobind: 1
        r: 1
        re: !!perl/hash:RE_ast
          decl: []
          min: 1
          re: &92 !!perl/hash:RE_any
            a: 0
            altname: special_variable__S_196DollarQuestion_01
            dba: special_variable__S_196DollarQuestion
            i: 0
            min: 1
            name: special_variable__S_196DollarQuestion_01
            r: 1
            s: 0
            zyg:
            - !!perl/hash:RE_meta
              a: 0
              alt: special_variable__S_196DollarQuestion_01 0
              dba: special_variable__S_196DollarQuestion
              i: 0
              min: 1
              r: 1
              s: 0
              text: \s
            - !!perl/hash:RE_string
              a: 0
              alt: special_variable__S_196DollarQuestion_01 1
              dba: special_variable__S_196DollarQuestion
              i: 0
              min: 1
              r: 1
              s: 0
              text: ','
            - !!perl/hash:RE_method
              a: 0
              alt: special_variable__S_196DollarQuestion_01 2
              dba: special_variable__S_196DollarQuestion
              i: 0
              min: 12345
              name: terminator
              r: 1
              rest: ''
              s: 0
        s: 0
    - !!perl/hash:RE_method
      min: 0
      name: obs
      nobind: 1
      rest: ('$? variable as child error', '$!')
special_variable__S_196DollarQuestion_01: *92
statement: !!perl/hash:RE_ast
  decl:
  - !!perl/hash:RE_decl
    a: 0
    dba: statement
    i: 0
    max: 0
    min: 0
    r: 1
    s: 0
    text: my $*endargs = -1
  - !!perl/hash:RE_decl
    a: 0
    dba: statement
    i: 0
    max: 0
    min: 0
    r: 1
    s: 0
    text: my $*QSIGIL ::= 0
  kind: token
  min: 0
  pkg: ~
  re: !!perl/hash:RE_sequence
    a: 0
    dba: statement
    i: 0
    min: 0
    r: 1
    s: 0
    zyg:
    - !!perl/hash:RE_assertion
      assert: '!'
      min: 0
      re: !!perl/hash:RE_method_re
        a: 0
        dba: statement
        i: 0
        min: 0
        name: before
        nobind: 1
        r: 1
        re: !!perl/hash:RE_ast
          decl: []
          min: 1
          re: !!perl/hash:RE_cclass
            a: 0
            dba: statement
            i: 0
            min: 1
            r: 1
            s: 0
            text: '[\)\]\}]'
        s: 0
    - !!perl/hash:RE_assertion
      assert: '!'
      min: 0
      re: !!perl/hash:RE_assertion
        assert: '!'
        min: 0
        nobind: 1
        re: !!perl/hash:RE_block
          a: 0
          context: bool
          dba: statement
          i: 0
          min: 0
          nobind: 1
          r: 1
          s: 0
          text: ' $*LASTSTATE = $.pos; $ = %*LANG<MAIN>.bless($); '
    - !!perl/hash:RE_bracket
      decl: []
      min: 0
      re: &93 !!perl/hash:RE_any
        a: 0
        altname: statement_02
        dba: statement end
        i: 0
        min: 0
        name: statement_02
        r: 1
        s: 0
        zyg:
        - !!perl/hash:RE_sequence
          a: 0
          alt: statement_02 0
          dba: statement
          i: 0
          min: 24690
          r: 1
          s: 0
          zyg:
          - !!perl/hash:RE_method
            a: 0
            dba: statement
            i: 0
            min: 12345
            name: label
            r: 1
            rest: ''
            s: 0
          - !!perl/hash:RE_method
            a: 0
            dba: statement
            i: 0
            min: 12345
            name: statement
            r: 1
            rest: ''
            s: 0
        - !!perl/hash:RE_method
          a: 0
          alt: statement_02 1
          dba: statement
          i: 0
          min: 12345
          name: statement_control
          r: 1
          rest: ''
          s: 0
        - !!perl/hash:RE_sequence
          a: 0
          alt: statement_02 2
          dba: statement end
          i: 0
          min: 12345
          r: 1
          s: 0
          zyg:
          - !!perl/hash:RE_method
            a: 0
            dba: statement
            i: 0
            min: 12345
            name: EXPR
            r: 1
            rest: ''
            s: 0
          - !!perl/hash:RE_bracket
            decl: []
            min: 0
            re: !!perl/hash:RE_first
              a: 0
              dba: statement modifier
              i: 0
              min: 0
              r: 1
              s: 0
              zyg:
              - !!perl/hash:RE_assertion
                assert: '?'
                min: 0
                re: !!perl/hash:RE_block
                  a: 0
                  context: bool
                  dba: statement end
                  i: 0
                  min: 0
                  nobind: 1
                  r: 1
                  s: 0
                  text: ' (@*MEMOS[$.pos]<endstmt> // 0) == 2 '
              - !!perl/hash:RE_sequence
                a: 0
                dba: statement modifier
                i: 0
                min: 12345
                r: 1
                s: 0
                zyg:
                - !!perl/hash:RE_method
                  a: 0
                  dba: statement modifier
                  i: 0
                  min: 12345
                  name: ws
                  nobind: 1
                  r: 1
                  rest: ''
                  s: 0
                - !!perl/hash:RE_quantified_atom
                  atom: !!perl/hash:RE_bracket
                    decl: []
                    min: 12345
                    re: &94 !!perl/hash:RE_any
                      a: 0
                      altname: statement_05
                      dba: statement modifier loop
                      i: 0
                      min: 12345
                      name: statement_05
                      r: 1
                      s: 0
                      zyg:
                      - !!perl/hash:RE_sequence
                        a: 0
                        alt: statement_05 0
                        dba: statement modifier
                        i: 0
                        min: 12345
                        r: 1
                        s: 0
                        zyg:
                        - !!perl/hash:RE_method
                          a: 0
                          dba: statement modifier
                          i: 0
                          min: 12345
                          name: statement_mod_loop
                          r: 1
                          rest: ''
                          s: 0
                        - !!perl/hash:RE_block
                          a: 0
                          context: void
                          dba: statement modifier
                          i: 0
                          min: 0
                          r: 1
                          s: 0
                          text: "\n                        my $sp = $<EXPR><statement_prefix>;\n
                            \                       if $sp and $sp<sym> eq 'do' {\n
                            \                          my $s = $<statement_mod_loop>[0]<sym>;\n
                            \                          $.obs(\"do...$s\" ,\"repeat...$s\");\n
                            \                       }\n                    "
                      - !!perl/hash:RE_sequence
                        a: 0
                        alt: statement_05 1
                        dba: statement modifier loop
                        i: 0
                        min: 12345
                        r: 1
                        s: 0
                        zyg:
                        - !!perl/hash:RE_method
                          a: 0
                          dba: statement modifier
                          i: 0
                          min: 12345
                          name: statement_mod_cond
                          r: 1
                          rest: ''
                          s: 0
                        - !!perl/hash:RE_bracket
                          decl: []
                          min: 0
                          re: !!perl/hash:RE_first
                            a: 0
                            dba: statement modifier loop
                            i: 0
                            min: 0
                            r: 1
                            s: 0
                            zyg:
                            - !!perl/hash:RE_assertion
                              assert: '?'
                              min: 0
                              re: !!perl/hash:RE_block
                                a: 0
                                context: bool
                                dba: statement modifier loop
                                i: 0
                                min: 0
                                nobind: 1
                                r: 1
                                s: 0
                                text: ' (@*MEMOS[$.pos]<endstmt> // 0) == 2 '
                            - !!perl/hash:RE_sequence
                              a: 0
                              dba: statement modifier loop
                              i: 0
                              min: 12345
                              r: 1
                              s: 0
                              zyg:
                              - !!perl/hash:RE_method
                                a: 0
                                dba: statement modifier loop
                                i: 0
                                min: 12345
                                name: ws
                                nobind: 1
                                r: 1
                                rest: ''
                                s: 0
                              - !!perl/hash:RE_quantified_atom
                                atom: !!perl/hash:RE_method
                                  a: 0
                                  dba: statement modifier loop
                                  i: 0
                                  min: 12345
                                  name: statement_mod_loop
                                  r: 1
                                  rest: ''
                                  s: 0
                                min: 0
                                quant:
                                - '?'
                                - ':'
                                - ''
                                - 0
                  min: 0
                  quant:
                  - '?'
                  - ':'
                  - ''
                  - 0
        - !!perl/hash:RE_assertion
          alt: statement_02 3
          assert: '?'
          min: 0
          re: !!perl/hash:RE_method_re
            a: 0
            dba: statement end
            i: 0
            min: 0
            name: before
            nobind: 1
            r: 1
            re: !!perl/hash:RE_ast
              decl: []
              min: 1
              re: !!perl/hash:RE_string
                a: 0
                dba: statement end
                i: 0
                min: 1
                r: 1
                s: 0
                text: ;
            s: 0
        - !!perl/hash:RE_sequence
          a: 0
          alt: statement_02 4
          dba: statement end
          i: 0
          min: 0
          r: 1
          s: 0
          zyg:
          - !!perl/hash:RE_block
            a: 0
            context: void
            dba: statement end
            i: 0
            min: 0
            r: 1
            s: 0
            text: ''
          - !!perl/hash:RE_method
            min: 0
            name: panic
            nobind: 1
            rest: ("Bogus statement")
    - !!perl/hash:RE_quantified_atom
      atom: !!perl/hash:RE_bracket
        decl: []
        min: 0
        re: !!perl/hash:RE_sequence
          a: 0
          dba: statement
          i: 0
          min: 0
          r: 1
          s: 0
          zyg:
          - !!perl/hash:RE_assertion
            assert: '?'
            min: 0
            re: !!perl/hash:RE_block
              a: 0
              context: bool
              dba: statement
              i: 0
              min: 0
              nobind: 1
              r: 1
              s: 0
              text: ' (@*MEMOS[@*MEMOS[$.pos]<ws>//$.pos]<endargs>//0) == 1 '
          - !!perl/hash:RE_quantified_atom
            atom: !!perl/hash:RE_meta
              a: 0
              dba: statement
              i: 0
              min: 1
              r: 1
              s: 0
              text: \h
            min: 0
            quant:
            - '*'
            - ':'
            - ''
            - 0
          - !!perl/hash:RE_assertion
            assert: '!'
            min: 0
            re: !!perl/hash:RE_method_re
              a: 0
              dba: statement
              i: 0
              min: 0
              name: before
              nobind: 1
              r: 1
              re: !!perl/hash:RE_ast
                decl: []
                min: 1
                re: &95 !!perl/hash:RE_any
                  a: 0
                  altname: statement_10
                  dba: statement
                  i: 0
                  min: 1
                  name: statement_10
                  r: 1
                  s: 0
                  zyg:
                  - !!perl/hash:RE_string
                    a: 0
                    alt: statement_10 0
                    dba: statement
                    i: 0
                    min: 1
                    r: 1
                    s: 0
                    text: ;
                  - !!perl/hash:RE_string
                    a: 0
                    alt: statement_10 1
                    dba: statement
                    i: 0
                    min: 1
                    r: 1
                    s: 0
                    text: )
                  - !!perl/hash:RE_string
                    a: 0
                    alt: statement_10 2
                    dba: statement
                    i: 0
                    min: 1
                    r: 1
                    s: 0
                    text: ']'
                  - !!perl/hash:RE_string
                    a: 0
                    alt: statement_10 3
                    dba: statement
                    i: 0
                    min: 1
                    r: 1
                    s: 0
                    text: '}'
              s: 0
          - !!perl/hash:RE_assertion
            assert: '!'
            min: 0
            re: !!perl/hash:RE_method
              a: 0
              dba: statement
              i: 0
              min: 12345
              name: infixstopper
              nobind: 1
              r: 1
              rest: ''
              s: 0
          - !!perl/hash:RE_block
            a: 0
            context: void
            dba: statement
            i: 0
            min: 0
            r: 1
            s: 0
            text: ' $*HIGHWATER = $.pos = @*MEMOS[$.pos]<ws>//$.pos; '
          - !!perl/hash:RE_method
            min: 0
            name: panic
            nobind: 1
            rest: ("Missing punctuation (semicolon or comma?) after block")
      min: 0
      quant:
      - '?'
      - ':'
      - ''
      - 0
statement_02: *93
statement_05: *94
statement_10: *95
statement_control__S_062need: !!perl/hash:RE_ast
  decl:
  - !!perl/hash:RE_decl
    a: 0
    dba: statement_control__S_062need
    i: 0
    max: 0
    min: 0
    r: 1
    s: 0
    text: my $longname
  kind: token
  min: 37035
  pkg: ~
  re: !!perl/hash:RE_sequence
    a: 0
    dba: statement_control__S_062need
    i: 0
    min: 37035
    r: 1
    s: 1
    zyg:
    - !!perl/hash:RE_method
      a: 0
      dba: statement_control__S_062need
      endsym: spacey
      i: 0
      min: 12345
      name: sym
      r: 1
      rest: ''
      s: 0
      sym: need
    - !!perl/hash:RE_method
      a: 0
      dba: statement_control__S_062need
      i: 0
      min: 12345
      name: spacey
      nobind: 1
      r: 1
      rest: ''
      s: 0
    - !!perl/hash:RE_method
      min: 0
      name: ws
      nobind: 1
      noquant: 1
      rest: ''
    - !!perl/hash:RE_quantified_atom
      atom: !!perl/hash:RE_bracket
        decl: []
        min: 12345
        re: &96 !!perl/hash:RE_any
          a: 0
          altname: statement_control__S_062need_01
          dba: statement_control__S_062need
          i: 0
          min: 12345
          name: statement_control__S_062need_01
          r: 1
          s: 1
          zyg:
          - !!perl/hash:RE_sequence
            a: 0
            alt: statement_control__S_062need_01 0
            dba: statement_control__S_062need
            i: 0
            min: 12345
            r: 1
            s: 1
            zyg:
            - !!perl/hash:RE_method
              a: 0
              dba: statement_control__S_062need
              i: 0
              min: 12345
              name: version
              r: 1
              rest: ''
              s: 1
            - !!perl/hash:RE_method
              min: 0
              name: ws
              nobind: 1
              noquant: 1
              rest: ''
          - !!perl/hash:RE_sequence
            a: 0
            alt: statement_control__S_062need_01 1
            dba: statement_control__S_062need
            i: 0
            min: 12345
            r: 1
            s: 1
            zyg:
            - !!perl/hash:RE_method
              a: 0
              dba: statement_control__S_062need
              i: 0
              min: 12345
              name: module_name
              r: 1
              rest: ''
              s: 1
            - !!perl/hash:RE_method
              min: 0
              name: ws
              nobind: 1
              noquant: 1
              rest: ''
            - !!perl/hash:RE_block
              a: 0
              context: void
              dba: statement_control__S_062need
              i: 0
              min: 0
              r: 1
              s: 1
              text: "\n                my $*IN_DECL = 'use';\n                my $*SCOPE
                = 'use';\n                $longname = $<module_name>[*-1]<longname>;\n
                \               $.do_need($longname);\n            "
            - !!perl/hash:RE_method
              min: 0
              name: ws
              nobind: 1
              noquant: 1
              rest: ''
      min: 12345
      quant:
      - '**'
      - ':'
      - !!perl/hash:RE_string
        a: 0
        dba: statement_control__S_062need
        i: 0
        min: 1
        r: 1
        s: 1
        text: ','
      - 1
    - !!perl/hash:RE_method
      min: 0
      name: ws
      nobind: 1
      noquant: 1
      rest: ''
statement_control__S_062need_01: *96
statement_control__S_063import: !!perl/hash:RE_ast
  decl:
  - !!perl/hash:RE_decl
    a: 0
    dba: statement_control__S_063import
    i: 0
    max: 0
    min: 0
    r: 1
    s: 0
    text: my $longname
  - !!perl/hash:RE_decl
    a: 0
    dba: statement_control__S_063import
    i: 0
    max: 0
    min: 0
    r: 1
    s: 0
    text: my $*IN_DECL = 'use'
  - !!perl/hash:RE_decl
    a: 0
    dba: statement_control__S_063import
    i: 0
    max: 0
    min: 0
    r: 1
    s: 0
    text: my $*SCOPE = 'use'
  kind: token
  min: 61725
  pkg: ~
  re: !!perl/hash:RE_sequence
    a: 0
    dba: statement_control__S_063import
    i: 0
    min: 61725
    r: 1
    s: 0
    zyg:
    - !!perl/hash:RE_method
      a: 0
      dba: statement_control__S_063import
      endsym: spacey
      i: 0
      min: 12345
      name: sym
      r: 1
      rest: ''
      s: 0
      sym: import
    - !!perl/hash:RE_method
      a: 0
      dba: statement_control__S_063import
      i: 0
      min: 12345
      name: spacey
      nobind: 1
      r: 1
      rest: ''
      s: 0
    - !!perl/hash:RE_method
      a: 0
      dba: statement_control__S_063import
      i: 0
      min: 12345
      name: ws
      nobind: 1
      r: 1
      rest: ''
      s: 0
    - !!perl/hash:RE_method
      a: 0
      dba: statement_control__S_063import
      i: 0
      min: 12345
      name: term
      r: 1
      rest: ''
      s: 0
    - !!perl/hash:RE_bracket
      decl: []
      min: 0
      re: !!perl/hash:RE_first
        a: 0
        dba: statement_control__S_063import
        i: 0
        min: 0
        r: 1
        s: 0
        zyg:
        - !!perl/hash:RE_sequence
          a: 0
          dba: statement_control__S_063import
          i: 0
          min: 24690
          r: 1
          s: 0
          zyg:
          - !!perl/hash:RE_method
            a: 0
            dba: statement_control__S_063import
            i: 0
            min: 12345
            name: spacey
            nobind: 1
            r: 1
            rest: ''
            s: 0
          - !!perl/hash:RE_method
            a: 0
            dba: statement_control__S_063import
            i: 0
            min: 12345
            name: arglist
            r: 1
            rest: ''
            s: 0
          - !!perl/hash:RE_block
            a: 0
            context: void
            dba: statement_control__S_063import
            i: 0
            min: 0
            r: 1
            s: 0
            text: "\n                $.do_import($<term>, $<arglist>);\n            "
        - !!perl/hash:RE_block
          a: 0
          context: void
          dba: statement_control__S_063import
          i: 0
          min: 0
          r: 1
          s: 0
          text: ' $.do_import($<term>, ''''); '
    - !!perl/hash:RE_method
      a: 0
      dba: statement_control__S_063import
      i: 0
      min: 12345
      name: ws
      nobind: 1
      r: 1
      rest: ''
      s: 0
statement_control__S_064use: !!perl/hash:RE_ast
  decl:
  - !!perl/hash:RE_decl
    a: 0
    dba: statement_control__S_064use
    i: 0
    max: 0
    min: 0
    r: 1
    s: 0
    text: my $longname
  - !!perl/hash:RE_decl
    a: 0
    dba: statement_control__S_064use
    i: 0
    max: 0
    min: 0
    r: 1
    s: 0
    text: my $*IN_DECL = 'use'
  - !!perl/hash:RE_decl
    a: 0
    dba: statement_control__S_064use
    i: 0
    max: 0
    min: 0
    r: 1
    s: 0
    text: my $*SCOPE = 'use'
  kind: token
  min: 61725
  pkg: ~
  re: !!perl/hash:RE_sequence
    a: 0
    dba: statement_control__S_064use
    i: 0
    min: 61725
    r: 1
    s: 0
    zyg:
    - !!perl/hash:RE_method
      a: 0
      dba: statement_control__S_064use
      endsym: spacey
      i: 0
      min: 12345
      name: sym
      r: 1
      rest: ''
      s: 0
      sym: use
    - !!perl/hash:RE_method
      a: 0
      dba: statement_control__S_064use
      i: 0
      min: 12345
      name: spacey
      nobind: 1
      r: 1
      rest: ''
      s: 0
    - !!perl/hash:RE_method
      a: 0
      dba: statement_control__S_064use
      i: 0
      min: 12345
      name: ws
      nobind: 1
      r: 1
      rest: ''
      s: 0
    - !!perl/hash:RE_bracket
      decl: []
      min: 12345
      re: &97 !!perl/hash:RE_any
        a: 0
        altname: statement_control__S_064use_01
        dba: statement_control__S_064use
        i: 0
        min: 12345
        name: statement_control__S_064use_01
        r: 1
        s: 0
        zyg:
        - !!perl/hash:RE_method
          a: 0
          alt: statement_control__S_064use_01 0
          dba: statement_control__S_064use
          i: 0
          min: 12345
          name: version
          r: 1
          rest: ''
          s: 0
        - !!perl/hash:RE_sequence
          a: 0
          alt: statement_control__S_064use_01 1
          dba: statement_control__S_064use
          i: 0
          min: 12345
          r: 1
          s: 0
          zyg:
          - !!perl/hash:RE_method
            a: 0
            dba: statement_control__S_064use
            i: 0
            min: 12345
            name: module_name
            r: 1
            rest: ''
            s: 0
          - !!perl/hash:RE_block
            a: 0
            context: void
            dba: statement_control__S_064use
            i: 0
            min: 0
            r: 1
            s: 0
            text: "\n                $longname = $<module_name><longname>;\n                if
              $longname.Str eq 'MONKEY_TYPING' {\n                    $*MONKEY_TYPING
              = True;\n                }\n            "
          - !!perl/hash:RE_bracket
            decl: []
            min: 0
            re: !!perl/hash:RE_first
              a: 0
              dba: statement_control__S_064use
              i: 0
              min: 0
              r: 1
              s: 0
              zyg:
              - !!perl/hash:RE_sequence
                a: 0
                dba: statement_control__S_064use
                i: 0
                min: 24690
                r: 1
                s: 0
                zyg:
                - !!perl/hash:RE_method
                  a: 0
                  dba: statement_control__S_064use
                  i: 0
                  min: 12345
                  name: spacey
                  nobind: 1
                  r: 1
                  rest: ''
                  s: 0
                - !!perl/hash:RE_method
                  a: 0
                  dba: statement_control__S_064use
                  i: 0
                  min: 12345
                  name: arglist
                  r: 1
                  rest: ''
                  s: 0
                - !!perl/hash:RE_block
                  a: 0
                  context: void
                  dba: statement_control__S_064use
                  i: 0
                  min: 0
                  r: 1
                  s: 0
                  text: "\n                    $.do_use($longname, $<arglist>);\n
                    \               "
              - !!perl/hash:RE_block
                a: 0
                context: void
                dba: statement_control__S_064use
                i: 0
                min: 0
                r: 1
                s: 0
                text: ' $.do_use($longname, ''''); '
    - !!perl/hash:RE_method
      a: 0
      dba: statement_control__S_064use
      i: 0
      min: 12345
      name: ws
      nobind: 1
      r: 1
      rest: ''
      s: 0
statement_control__S_064use_01: *97
statement_control__S_065no: !!perl/hash:RE_ast
  decl: []
  kind: token
  min: 61725
  pkg: ~
  re: !!perl/hash:RE_sequence
    a: 0
    dba: statement_control__S_065no
    i: 0
    min: 61725
    r: 1
    s: 0
    zyg:
    - !!perl/hash:RE_method
      a: 0
      dba: statement_control__S_065no
      endsym: spacey
      i: 0
      min: 12345
      name: sym
      r: 1
      rest: ''
      s: 0
      sym: no
    - !!perl/hash:RE_method
      a: 0
      dba: statement_control__S_065no
      i: 0
      min: 12345
      name: spacey
      nobind: 1
      r: 1
      rest: ''
      s: 0
    - !!perl/hash:RE_method
      a: 0
      dba: statement_control__S_065no
      i: 0
      min: 12345
      name: ws
      nobind: 1
      r: 1
      rest: ''
      s: 0
    - !!perl/hash:RE_method
      a: 0
      dba: statement_control__S_065no
      i: 0
      min: 12345
      name: module_name
      r: 1
      rest: ''
      s: 0
    - !!perl/hash:RE_quantified_atom
      atom: !!perl/hash:RE_bracket
        decl: []
        min: 24690
        re: !!perl/hash:RE_sequence
          a: 0
          dba: statement_control__S_065no
          i: 0
          min: 24690
          r: 1
          s: 0
          zyg:
          - !!perl/hash:RE_method
            a: 0
            dba: statement_control__S_065no
            i: 0
            min: 12345
            name: spacey
            nobind: 1
            r: 1
            rest: ''
            s: 0
          - !!perl/hash:RE_method
            a: 0
            dba: statement_control__S_065no
            i: 0
            min: 12345
            name: arglist
            r: 1
            rest: ''
            s: 0
      min: 0
      quant:
      - '?'
      - ':'
      - ''
      - 0
    - !!perl/hash:RE_method
      a: 0
      dba: statement_control__S_065no
      i: 0
      min: 12345
      name: ws
      nobind: 1
      r: 1
      rest: ''
      s: 0
statement_control__S_066if: !!perl/hash:RE_ast
  decl: []
  kind: token
  min: 37035
  pkg: ~
  re: !!perl/hash:RE_sequence
    a: 0
    dba: statement_control__S_066if
    i: 0
    min: 37035
    r: 1
    s: 1
    zyg:
    - !!perl/hash:RE_method
      a: 0
      dba: statement_control__S_066if
      endsym: spacey
      i: 0
      min: 12345
      name: sym
      r: 1
      rest: ''
      s: 0
      sym: if
    - !!perl/hash:RE_method
      a: 0
      dba: statement_control__S_066if
      i: 0
      min: 12345
      name: spacey
      nobind: 1
      r: 1
      rest: ''
      s: 0
    - !!perl/hash:RE_method
      min: 0
      name: ws
      nobind: 1
      noquant: 1
      rest: ''
    - !!perl/hash:RE_method
      a: 0
      dba: statement_control__S_066if
      i: 0
      min: 12345
      name: xblock
      r: 1
      rest: ''
      s: 1
    - !!perl/hash:RE_method
      min: 0
      name: ws
      nobind: 1
      noquant: 1
      rest: ''
    - !!perl/hash:RE_quantified_atom
      atom: !!perl/hash:RE_bracket
        decl: []
        min: 12350
        re: !!perl/hash:RE_sequence
          a: 0
          dba: statement_control__S_066if
          i: 0
          min: 12350
          r: 1
          s: 1
          zyg:
          - !!perl/hash:RE_method
            min: 0
            name: ws
            nobind: 1
            noquant: 1
            rest: ''
          - !!perl/hash:RE_bracket
            decl: []
            min: 0
            re: !!perl/hash:RE_first
              a: 0
              dba: statement_control__S_066if
              i: 0
              min: 0
              r: 1
              s: 1
              zyg:
              - !!perl/hash:RE_sequence
                a: 0
                dba: statement_control__S_066if
                i: 0
                min: 0
                r: 1
                s: 1
                zyg:
                - !!perl/hash:RE_assertion
                  assert: '!'
                  min: 0
                  re: !!perl/hash:RE_method_re
                    a: 0
                    dba: statement_control__S_066if
                    i: 0
                    min: 0
                    name: before
                    nobind: 1
                    r: 1
                    re: !!perl/hash:RE_ast
                      decl: []
                      min: 6
                      re: !!perl/hash:RE_sequence
                        a: 0
                        dba: statement_control__S_066if
                        i: 0
                        min: 6
                        r: 1
                        s: 1
                        zyg:
                        - !!perl/hash:RE_string
                          a: 0
                          dba: statement_control__S_066if
                          i: 0
                          min: 4
                          r: 1
                          s: 1
                          text: else
                        - !!perl/hash:RE_quantified_atom
                          atom: !!perl/hash:RE_meta
                            a: 0
                            dba: statement_control__S_066if
                            i: 0
                            min: 1
                            r: 1
                            s: 1
                            text: \s
                          min: 0
                          quant:
                          - '*'
                          - ':'
                          - ''
                          - 0
                        - !!perl/hash:RE_string
                          a: 0
                          dba: statement_control__S_066if
                          i: 0
                          min: 2
                          r: 1
                          s: 1
                          text: if
                    s: 1
                - !!perl/hash:RE_method
                  min: 0
                  name: ws
                  nobind: 1
                  noquant: 1
                  rest: ''
              - !!perl/hash:RE_sequence
                a: 0
                dba: statement_control__S_066if
                i: 0
                min: 0
                r: 1
                s: 1
                zyg:
                - !!perl/hash:RE_method
                  min: 0
                  name: panic
                  nobind: 1
                  rest: ("Please use 'elsif'")
                - !!perl/hash:RE_method
                  min: 0
                  name: ws
                  nobind: 1
                  noquant: 1
                  rest: ''
          - !!perl/hash:RE_method
            min: 0
            name: ws
            nobind: 1
            noquant: 1
            rest: ''
          - !!perl/hash:RE_string
            a: 0
            dba: statement_control__S_066if
            i: 0
            min: 5
            r: 1
            s: 1
            text: elsif
          - !!perl/hash:RE_assertion
            assert: '?'
            min: 0
            re: !!perl/hash:RE_method
              a: 0
              dba: statement_control__S_066if
              i: 0
              min: 12345
              name: spacey
              nobind: 1
              r: 1
              rest: ''
              s: 1
          - !!perl/hash:RE_method
            min: 0
            name: ws
            nobind: 1
            noquant: 1
            rest: ''
          - !!perl/hash:RE_bindnamed
            a: 0
            atom: !!perl/hash:RE_method
              a: 0
              dba: statement_control__S_066if
              i: 0
              min: 12345
              name: xblock
              nobind: 1
              r: 1
              rest: ''
              s: 1
            dba: statement_control__S_066if
            i: 0
            min: 12345
            r: 1
            s: 1
            var: elsif
          - !!perl/hash:RE_method
            min: 0
            name: ws
            nobind: 1
            noquant: 1
            rest: ''
      min: 0
      quant:
      - '*'
      - ':'
      - ''
      - 0
    - !!perl/hash:RE_method
      min: 0
      name: ws
      nobind: 1
      noquant: 1
      rest: ''
    - !!perl/hash:RE_quantified_atom
      atom: !!perl/hash:RE_bracket
        decl: []
        min: 12349
        re: !!perl/hash:RE_sequence
          a: 0
          dba: statement_control__S_066if
          i: 0
          min: 12349
          r: 1
          s: 1
          zyg:
          - !!perl/hash:RE_method
            min: 0
            name: ws
            nobind: 1
            noquant: 1
            rest: ''
          - !!perl/hash:RE_string
            a: 0
            dba: statement_control__S_066if
            i: 0
            min: 4
            r: 1
            s: 1
            text: else
          - !!perl/hash:RE_assertion
            assert: '?'
            min: 0
            re: !!perl/hash:RE_method
              a: 0
              dba: statement_control__S_066if
              i: 0
              min: 12345
              name: spacey
              nobind: 1
              r: 1
              rest: ''
              s: 1
          - !!perl/hash:RE_method
            min: 0
            name: ws
            nobind: 1
            noquant: 1
            rest: ''
          - !!perl/hash:RE_bindnamed
            a: 0
            atom: !!perl/hash:RE_method
              a: 0
              dba: statement_control__S_066if
              i: 0
              min: 12345
              name: pblock
              nobind: 1
              r: 1
              rest: ''
              s: 1
            dba: statement_control__S_066if
            i: 0
            min: 12345
            r: 1
            s: 1
            var: else
          - !!perl/hash:RE_method
            min: 0
            name: ws
            nobind: 1
            noquant: 1
            rest: ''
      min: 0
      quant:
      - '?'
      - ':'
      - ''
      - 0
    - !!perl/hash:RE_method
      min: 0
      name: ws
      nobind: 1
      noquant: 1
      rest: ''
statement_control__S_067unless: !!perl/hash:RE_ast
  decl: []
  kind: token
  min: 37035
  pkg: ~
  re: !!perl/hash:RE_sequence
    a: 0
    dba: statement_control__S_067unless
    i: 0
    min: 37035
    r: 1
    s: 1
    zyg:
    - !!perl/hash:RE_method
      a: 0
      dba: statement_control__S_067unless
      endsym: spacey
      i: 0
      min: 12345
      name: sym
      r: 1
      rest: ''
      s: 0
      sym: unless
    - !!perl/hash:RE_method
      a: 0
      dba: statement_control__S_067unless
      i: 0
      min: 12345
      name: spacey
      nobind: 1
      r: 1
      rest: ''
      s: 0
    - !!perl/hash:RE_method
      min: 0
      name: ws
      nobind: 1
      noquant: 1
      rest: ''
    - !!perl/hash:RE_method
      a: 0
      dba: statement_control__S_067unless
      i: 0
      min: 12345
      name: xblock
      r: 1
      rest: ''
      s: 1
    - !!perl/hash:RE_method
      min: 0
      name: ws
      nobind: 1
      noquant: 1
      rest: ''
    - !!perl/hash:RE_bracket
      decl: []
      min: 0
      re: !!perl/hash:RE_first
        a: 0
        dba: statement_control__S_067unless
        i: 0
        min: 0
        r: 1
        s: 1
        zyg:
        - !!perl/hash:RE_sequence
          a: 0
          dba: statement_control__S_067unless
          i: 0
          min: 0
          r: 1
          s: 1
          zyg:
          - !!perl/hash:RE_assertion
            assert: '!'
            min: 0
            re: !!perl/hash:RE_method_re
              a: 0
              dba: statement_control__S_067unless
              i: 0
              min: 0
              name: before
              nobind: 1
              r: 1
              re: !!perl/hash:RE_ast
                decl: []
                min: 4
                re: !!perl/hash:RE_string
                  a: 0
                  dba: statement_control__S_067unless
                  i: 0
                  min: 4
                  r: 1
                  s: 1
                  text: else
              s: 1
          - !!perl/hash:RE_method
            min: 0
            name: ws
            nobind: 1
            noquant: 1
            rest: ''
        - !!perl/hash:RE_sequence
          a: 0
          dba: statement_control__S_067unless
          i: 0
          min: 0
          r: 1
          s: 1
          zyg:
          - !!perl/hash:RE_method
            min: 0
            name: panic
            nobind: 1
            rest: ("unless does not take \"else\" in Perl 6; please rewrite using
              \"if\"")
          - !!perl/hash:RE_method
            min: 0
            name: ws
            nobind: 1
            noquant: 1
            rest: ''
    - !!perl/hash:RE_method
      min: 0
      name: ws
      nobind: 1
      noquant: 1
      rest: ''
statement_control__S_068while: !!perl/hash:RE_ast
  decl: []
  kind: token
  min: 37035
  pkg: ~
  re: !!perl/hash:RE_sequence
    a: 0
    dba: statement_control__S_068while
    i: 0
    min: 37035
    r: 1
    s: 1
    zyg:
    - !!perl/hash:RE_method
      a: 0
      dba: statement_control__S_068while
      endsym: spacey
      i: 0
      min: 12345
      name: sym
      r: 1
      rest: ''
      s: 0
      sym: while
    - !!perl/hash:RE_method
      a: 0
      dba: statement_control__S_068while
      i: 0
      min: 12345
      name: spacey
      nobind: 1
      r: 1
      rest: ''
      s: 0
    - !!perl/hash:RE_method
      min: 0
      name: ws
      nobind: 1
      noquant: 1
      rest: ''
    - !!perl/hash:RE_quantified_atom
      atom: !!perl/hash:RE_bracket
        decl: []
        min: 0
        re: !!perl/hash:RE_sequence
          a: 0
          dba: statement_control__S_068while
          i: 0
          min: 0
          r: 1
          s: 1
          zyg:
          - !!perl/hash:RE_method
            min: 0
            name: ws
            nobind: 1
            noquant: 1
            rest: ''
          - !!perl/hash:RE_assertion
            assert: '?'
            min: 0
            re: !!perl/hash:RE_method_re
              a: 0
              dba: statement_control__S_068while
              i: 0
              min: 0
              name: before
              nobind: 1
              r: 1
              re: !!perl/hash:RE_ast
                decl: []
                min: 5
                re: !!perl/hash:RE_sequence
                  a: 0
                  dba: statement_control__S_068while
                  i: 0
                  min: 5
                  r: 1
                  s: 1
                  zyg:
                  - !!perl/hash:RE_string
                    a: 0
                    dba: statement_control__S_068while
                    i: 0
                    min: 1
                    r: 1
                    s: 1
                    text: (
                  - !!perl/hash:RE_method
                    min: 0
                    name: ws
                    nobind: 1
                    noquant: 1
                    rest: ''
                  - !!perl/hash:RE_quantified_atom
                    atom: !!perl/hash:RE_bracket
                      decl: []
                      min: 3
                      re: !!perl/hash:RE_sequence
                        a: 0
                        dba: statement_control__S_068while
                        i: 0
                        min: 3
                        r: 1
                        s: 1
                        zyg:
                        - !!perl/hash:RE_quantified_atom
                          atom: !!perl/hash:RE_string
                            a: 0
                            dba: statement_control__S_068while
                            i: 0
                            min: 2
                            r: 1
                            s: 1
                            text: my
                          min: 0
                          quant:
                          - '?'
                          - ':'
                          - ''
                          - 0
                        - !!perl/hash:RE_method
                          min: 0
                          name: ws
                          nobind: 1
                          noquant: 1
                          rest: ''
                        - !!perl/hash:RE_string
                          a: 0
                          dba: statement_control__S_068while
                          i: 0
                          min: 1
                          r: 1
                          s: 1
                          text: $
                        - !!perl/hash:RE_quantified_atom
                          atom: !!perl/hash:RE_meta
                            a: 0
                            dba: statement_control__S_068while
                            i: 0
                            min: 1
                            r: 1
                            s: 1
                            text: \w
                          min: 1
                          quant:
                          - +
                          - ':'
                          - ''
                          - 1
                        - !!perl/hash:RE_method
                          min: 0
                          name: ws
                          nobind: 1
                          noquant: 1
                          rest: ''
                        - !!perl/hash:RE_string
                          a: 0
                          dba: statement_control__S_068while
                          i: 0
                          min: 1
                          r: 1
                          s: 1
                          text: =
                    min: 0
                    quant:
                    - '?'
                    - ':'
                    - ''
                    - 0
                  - !!perl/hash:RE_method
                    min: 0
                    name: ws
                    nobind: 1
                    noquant: 1
                    rest: ''
                  - !!perl/hash:RE_string
                    a: 0
                    dba: statement_control__S_068while
                    i: 0
                    min: 1
                    r: 1
                    s: 1
                    text: <
                  - !!perl/hash:RE_method
                    min: 0
                    name: ws
                    nobind: 1
                    noquant: 1
                    rest: ''
                  - !!perl/hash:RE_quantified_atom
                    atom: !!perl/hash:RE_string
                      a: 0
                      dba: statement_control__S_068while
                      i: 0
                      min: 1
                      r: 1
                      s: 1
                      text: $
                    min: 0
                    quant:
                    - '?'
                    - ':'
                    - ''
                    - 0
                  - !!perl/hash:RE_quantified_atom
                    atom: !!perl/hash:RE_meta
                      a: 0
                      dba: statement_control__S_068while
                      i: 0
                      min: 1
                      r: 1
                      s: 1
                      text: \w
                    min: 1
                    quant:
                    - +
                    - ':'
                    - ''
                    - 1
                  - !!perl/hash:RE_method
                    min: 0
                    name: ws
                    nobind: 1
                    noquant: 1
                    rest: ''
                  - !!perl/hash:RE_string
                    a: 0
                    dba: statement_control__S_068while
                    i: 0
                    min: 1
                    r: 1
                    s: 1
                    text: '>'
                  - !!perl/hash:RE_method
                    min: 0
                    name: ws
                    nobind: 1
                    noquant: 1
                    rest: ''
                  - !!perl/hash:RE_string
                    a: 0
                    dba: statement_control__S_068while
                    i: 0
                    min: 1
                    r: 1
                    s: 1
                    text: )
              s: 1
          - !!perl/hash:RE_method
            min: 0
            name: ws
            nobind: 1
            noquant: 1
            rest: ''
          - !!perl/hash:RE_method
            min: 0
            name: panic
            nobind: 1
            rest: ("This appears to be Perl 5 code")
          - !!perl/hash:RE_method
            min: 0
            name: ws
            nobind: 1
            noquant: 1
            rest: ''
      min: 0
      quant:
      - '?'
      - ':'
      - ''
      - 0
    - !!perl/hash:RE_method
      min: 0
      name: ws
      nobind: 1
      noquant: 1
      rest: ''
    - !!perl/hash:RE_method
      a: 0
      dba: statement_control__S_068while
      i: 0
      min: 12345
      name: xblock
      r: 1
      rest: ''
      s: 1
    - !!perl/hash:RE_method
      min: 0
      name: ws
      nobind: 1
      noquant: 1
      rest: ''
statement_control__S_069until: !!perl/hash:RE_ast
  decl: []
  kind: token
  min: 37035
  pkg: ~
  re: !!perl/hash:RE_sequence
    a: 0
    dba: statement_control__S_069until
    i: 0
    min: 37035
    r: 1
    s: 1
    zyg:
    - !!perl/hash:RE_method
      a: 0
      dba: statement_control__S_069until
      endsym: spacey
      i: 0
      min: 12345
      name: sym
      r: 1
      rest: ''
      s: 0
      sym: until
    - !!perl/hash:RE_method
      a: 0
      dba: statement_control__S_069until
      i: 0
      min: 12345
      name: spacey
      nobind: 1
      r: 1
      rest: ''
      s: 0
    - !!perl/hash:RE_method
      min: 0
      name: ws
      nobind: 1
      noquant: 1
      rest: ''
    - !!perl/hash:RE_method
      a: 0
      dba: statement_control__S_069until
      i: 0
      min: 12345
      name: xblock
      r: 1
      rest: ''
      s: 1
    - !!perl/hash:RE_method
      min: 0
      name: ws
      nobind: 1
      noquant: 1
      rest: ''
statement_control__S_070repeat: !!perl/hash:RE_ast
  decl: []
  kind: token
  min: 49385
  pkg: ~
  re: !!perl/hash:RE_sequence
    a: 0
    dba: statement_control__S_070repeat
    i: 0
    min: 49385
    r: 1
    s: 1
    zyg:
    - !!perl/hash:RE_method
      a: 0
      dba: statement_control__S_070repeat
      endsym: spacey
      i: 0
      min: 12345
      name: sym
      r: 1
      rest: ''
      s: 0
      sym: repeat
    - !!perl/hash:RE_method
      a: 0
      dba: statement_control__S_070repeat
      i: 0
      min: 12345
      name: spacey
      nobind: 1
      r: 1
      rest: ''
      s: 0
    - !!perl/hash:RE_method
      min: 0
      name: ws
      nobind: 1
      noquant: 1
      rest: ''
    - !!perl/hash:RE_bracket
      decl: []
      min: 24695
      re: &98 !!perl/hash:RE_any
        a: 0
        altname: statement_control__S_070repeat_01
        dba: statement_control__S_070repeat
        i: 0
        min: 24695
        name: statement_control__S_070repeat_01
        r: 1
        s: 1
        zyg:
        - !!perl/hash:RE_sequence
          a: 0
          alt: statement_control__S_070repeat_01 0
          dba: statement_control__S_070repeat
          i: 0
          min: 24695
          r: 1
          s: 1
          zyg:
          - !!perl/hash:RE_bindnamed
            a: 0
            atom: !!perl/hash:RE_bracket
              decl: []
              min: 5
              re: &99 !!perl/hash:RE_any
                a: 0
                altname: statement_control__S_070repeat_02
                dba: statement_control__S_070repeat
                i: 0
                min: 5
                name: statement_control__S_070repeat_02
                r: 1
                s: 1
                zyg:
                - !!perl/hash:RE_string
                  a: 0
                  alt: statement_control__S_070repeat_02 0
                  dba: statement_control__S_070repeat
                  i: 0
                  min: 5
                  r: 1
                  s: 1
                  text: while
                - !!perl/hash:RE_string
                  a: 0
                  alt: statement_control__S_070repeat_02 1
                  dba: statement_control__S_070repeat
                  i: 0
                  min: 5
                  r: 1
                  s: 1
                  text: until
            dba: statement_control__S_070repeat
            i: 0
            min: 5
            r: 1
            s: 1
            var: wu
          - !!perl/hash:RE_method
            a: 0
            dba: statement_control__S_070repeat
            i: 0
            min: 12345
            name: spacey
            nobind: 1
            r: 1
            rest: ''
            s: 1
          - !!perl/hash:RE_method
            min: 0
            name: ws
            nobind: 1
            noquant: 1
            rest: ''
          - !!perl/hash:RE_method
            a: 0
            dba: statement_control__S_070repeat
            i: 0
            min: 12345
            name: xblock
            r: 1
            rest: ''
            s: 1
          - !!perl/hash:RE_method
            min: 0
            name: ws
            nobind: 1
            noquant: 1
            rest: ''
        - !!perl/hash:RE_sequence
          a: 0
          alt: statement_control__S_070repeat_01 1
          dba: statement_control__S_070repeat
          i: 0
          min: 24695
          r: 1
          s: 1
          zyg:
          - !!perl/hash:RE_method
            a: 0
            dba: statement_control__S_070repeat
            i: 0
            min: 12345
            name: pblock
            r: 1
            rest: ''
            s: 1
          - !!perl/hash:RE_method
            min: 0
            name: ws
            nobind: 1
            noquant: 1
            rest: ''
          - !!perl/hash:RE_bindnamed
            a: 0
            atom: !!perl/hash:RE_bracket
              decl: []
              min: 5
              re: &100 !!perl/hash:RE_any
                a: 0
                altname: statement_control__S_070repeat_03
                dba: statement_control__S_070repeat
                i: 0
                min: 5
                name: statement_control__S_070repeat_03
                r: 1
                s: 1
                zyg:
                - !!perl/hash:RE_string
                  a: 0
                  alt: statement_control__S_070repeat_03 0
                  dba: statement_control__S_070repeat
                  i: 0
                  min: 5
                  r: 1
                  s: 1
                  text: while
                - !!perl/hash:RE_string
                  a: 0
                  alt: statement_control__S_070repeat_03 1
                  dba: statement_control__S_070repeat
                  i: 0
                  min: 5
                  r: 1
                  s: 1
                  text: until
            dba: statement_control__S_070repeat
            i: 0
            min: 5
            r: 1
            s: 1
            var: wu
          - !!perl/hash:RE_bracket
            decl: []
            min: 0
            re: !!perl/hash:RE_first
              a: 0
              dba: statement_control__S_070repeat
              i: 0
              min: 0
              r: 1
              s: 1
              zyg:
              - !!perl/hash:RE_method
                a: 0
                dba: statement_control__S_070repeat
                i: 0
                min: 12345
                name: spacey
                nobind: 1
                r: 1
                rest: ''
                s: 1
              - !!perl/hash:RE_method
                min: 0
                name: panic
                nobind: 1
                rest: ("Whitespace required after keyword")
          - !!perl/hash:RE_method
            min: 0
            name: ws
            nobind: 1
            noquant: 1
            rest: ''
          - !!perl/hash:RE_method
            a: 0
            dba: statement_control__S_070repeat
            i: 0
            min: 12345
            name: EXPR
            r: 1
            rest: ''
            s: 1
          - !!perl/hash:RE_method
            min: 0
            name: ws
            nobind: 1
            noquant: 1
            rest: ''
    - !!perl/hash:RE_method
      min: 0
      name: ws
      nobind: 1
      noquant: 1
      rest: ''
statement_control__S_070repeat_01: *98
statement_control__S_070repeat_02: *99
statement_control__S_070repeat_03: *100
statement_control__S_071loop: !!perl/hash:RE_ast
  decl: []
  kind: token
  min: 61725
  pkg: ~
  re: !!perl/hash:RE_sequence
    a: 0
    dba: statement_control__S_071loop
    i: 0
    min: 61725
    r: 1
    s: 0
    zyg:
    - !!perl/hash:RE_method
      a: 0
      dba: statement_control__S_071loop
      endsym: spacey
      i: 0
      min: 12345
      name: sym
      r: 1
      rest: ''
      s: 0
      sym: loop
    - !!perl/hash:RE_method
      a: 0
      dba: statement_control__S_071loop
      i: 0
      min: 12345
      name: spacey
      nobind: 1
      r: 1
      rest: ''
      s: 0
    - !!perl/hash:RE_method
      a: 0
      dba: statement_control__S_071loop
      i: 0
      min: 12345
      name: ws
      nobind: 1
      r: 1
      rest: ''
      s: 0
    - !!perl/hash:RE_bindnamed
      a: 0
      atom: !!perl/hash:RE_quantified_atom
        atom: !!perl/hash:RE_paren
          decl: []
          min: 1
          re: !!perl/hash:RE_sequence
            a: 0
            dba: statement_control__S_071loop
            i: 0
            min: 1
            r: 1
            s: 0
            zyg:
            - !!perl/hash:RE_string
              a: 0
              dba: statement_control__S_071loop
              i: 0
              min: 1
              r: 1
              s: 0
              text: (
            - !!perl/hash:RE_bracket
              decl: []
              min: 0
              re: !!perl/hash:RE_first
                a: 0
                dba: statement_control__S_071loop
                i: 0
                min: 0
                r: 1
                s: 1
                zyg:
                - !!perl/hash:RE_sequence
                  a: 0
                  dba: statement_control__S_071loop
                  i: 0
                  min: 3
                  r: 1
                  s: 1
                  zyg:
                  - !!perl/hash:RE_method
                    min: 0
                    name: ws
                    nobind: 1
                    noquant: 1
                    rest: ''
                  - !!perl/hash:RE_bindnamed
                    a: 0
                    atom: !!perl/hash:RE_quantified_atom
                      atom: !!perl/hash:RE_method
                        a: 0
                        dba: statement_control__S_071loop
                        i: 0
                        min: 12345
                        name: EXPR
                        nobind: 1
                        r: 1
                        rest: ''
                        s: 1
                      min: 0
                      quant:
                      - '?'
                      - ':'
                      - ''
                      - 0
                    dba: statement_control__S_071loop
                    i: 0
                    min: 0
                    r: 1
                    s: 1
                    var: e1
                  - !!perl/hash:RE_method
                    min: 0
                    name: ws
                    nobind: 1
                    noquant: 1
                    rest: ''
                  - !!perl/hash:RE_string
                    a: 0
                    dba: statement_control__S_071loop
                    i: 0
                    min: 1
                    r: 1
                    s: 1
                    text: ;
                  - !!perl/hash:RE_method
                    min: 0
                    name: ws
                    nobind: 1
                    noquant: 1
                    rest: ''
                  - !!perl/hash:RE_bindnamed
                    a: 0
                    atom: !!perl/hash:RE_quantified_atom
                      atom: !!perl/hash:RE_method
                        a: 0
                        dba: statement_control__S_071loop
                        i: 0
                        min: 12345
                        name: EXPR
                        nobind: 1
                        r: 1
                        rest: ''
                        s: 1
                      min: 0
                      quant:
                      - '?'
                      - ':'
                      - ''
                      - 0
                    dba: statement_control__S_071loop
                    i: 0
                    min: 0
                    r: 1
                    s: 1
                    var: e2
                  - !!perl/hash:RE_method
                    min: 0
                    name: ws
                    nobind: 1
                    noquant: 1
                    rest: ''
                  - !!perl/hash:RE_string
                    a: 0
                    dba: statement_control__S_071loop
                    i: 0
                    min: 1
                    r: 1
                    s: 1
                    text: ;
                  - !!perl/hash:RE_method
                    min: 0
                    name: ws
                    nobind: 1
                    noquant: 1
                    rest: ''
                  - !!perl/hash:RE_bindnamed
                    a: 0
                    atom: !!perl/hash:RE_quantified_atom
                      atom: !!perl/hash:RE_method
                        a: 0
                        dba: statement_control__S_071loop
                        i: 0
                        min: 12345
                        name: EXPR
                        nobind: 1
                        r: 1
                        rest: ''
                        s: 1
                      min: 0
                      quant:
                      - '?'
                      - ':'
                      - ''
                      - 0
                    dba: statement_control__S_071loop
                    i: 0
                    min: 0
                    r: 1
                    s: 1
                    var: e3
                  - !!perl/hash:RE_method
                    min: 0
                    name: ws
                    nobind: 1
                    noquant: 1
                    rest: ''
                  - !!perl/hash:RE_string
                    a: 0
                    dba: statement_control__S_071loop
                    i: 0
                    min: 1
                    r: 1
                    s: 1
                    text: )
                - !!perl/hash:RE_method
                  min: 0
                  name: panic
                  nobind: 1
                  rest: ("Malformed loop spec")
            - !!perl/hash:RE_quantified_atom
              atom: !!perl/hash:RE_bracket
                decl: []
                min: 0
                re: !!perl/hash:RE_sequence
                  a: 0
                  dba: statement_control__S_071loop
                  i: 0
                  min: 0
                  r: 1
                  s: 0
                  zyg:
                  - !!perl/hash:RE_assertion
                    assert: '?'
                    min: 0
                    re: !!perl/hash:RE_method_re
                      a: 0
                      dba: statement_control__S_071loop
                      i: 0
                      min: 0
                      name: before
                      nobind: 1
                      r: 1
                      re: !!perl/hash:RE_ast
                        decl: []
                        min: 1
                        re: !!perl/hash:RE_string
                          a: 0
                          dba: statement_control__S_071loop
                          i: 0
                          min: 1
                          r: 1
                          s: 0
                          text: '{'
                      s: 0
                  - !!perl/hash:RE_method
                    min: 0
                    name: panic
                    nobind: 1
                    rest: ("Whitespace required before block")
              min: 0
              quant:
              - '?'
              - ':'
              - ''
              - 0
        min: 0
        quant:
        - '?'
        - ':'
        - ''
        - 0
      dba: statement_control__S_071loop
      i: 0
      min: 0
      r: 1
      s: 0
      var: eee
    - !!perl/hash:RE_method
      a: 0
      dba: statement_control__S_071loop
      i: 0
      min: 12345
      name: ws
      nobind: 1
      r: 1
      rest: ''
      s: 0
    - !!perl/hash:RE_method
      a: 0
      dba: statement_control__S_071loop
      i: 0
      min: 12345
      name: block
      r: 1
      rest: ''
      s: 0
statement_control__S_072for: !!perl/hash:RE_ast
  decl: []
  kind: token
  min: 37035
  pkg: ~
  re: !!perl/hash:RE_sequence
    a: 0
    dba: statement_control__S_072for
    i: 0
    min: 37035
    r: 1
    s: 1
    zyg:
    - !!perl/hash:RE_method
      a: 0
      dba: statement_control__S_072for
      endsym: spacey
      i: 0
      min: 12345
      name: sym
      r: 1
      rest: ''
      s: 0
      sym: for
    - !!perl/hash:RE_method
      a: 0
      dba: statement_control__S_072for
      i: 0
      min: 12345
      name: spacey
      nobind: 1
      r: 1
      rest: ''
      s: 0
    - !!perl/hash:RE_method
      min: 0
      name: ws
      nobind: 1
      noquant: 1
      rest: ''
    - !!perl/hash:RE_quantified_atom
      atom: !!perl/hash:RE_bracket
        decl: []
        min: 0
        re: !!perl/hash:RE_sequence
          a: 0
          dba: statement_control__S_072for
          i: 0
          min: 0
          r: 1
          s: 1
          zyg:
          - !!perl/hash:RE_method
            min: 0
            name: ws
            nobind: 1
            noquant: 1
            rest: ''
          - !!perl/hash:RE_assertion
            assert: '?'
            min: 0
            re: !!perl/hash:RE_method_re
              a: 0
              dba: statement_control__S_072for
              i: 0
              min: 0
              name: before
              nobind: 1
              r: 1
              re: !!perl/hash:RE_ast
                decl: []
                min: 3
                re: !!perl/hash:RE_sequence
                  a: 0
                  dba: statement_control__S_072for
                  i: 0
                  min: 3
                  r: 1
                  s: 1
                  zyg:
                  - !!perl/hash:RE_quantified_atom
                    atom: !!perl/hash:RE_string
                      a: 0
                      dba: statement_control__S_072for
                      i: 0
                      min: 2
                      r: 1
                      s: 1
                      text: my
                    min: 0
                    quant:
                    - '?'
                    - ':'
                    - ''
                    - 0
                  - !!perl/hash:RE_method
                    min: 0
                    name: ws
                    nobind: 1
                    noquant: 1
                    rest: ''
                  - !!perl/hash:RE_string
                    a: 0
                    dba: statement_control__S_072for
                    i: 0
                    min: 1
                    r: 1
                    s: 1
                    text: $
                  - !!perl/hash:RE_quantified_atom
                    atom: !!perl/hash:RE_meta
                      a: 0
                      dba: statement_control__S_072for
                      i: 0
                      min: 1
                      r: 1
                      s: 1
                      text: \w
                    min: 1
                    quant:
                    - +
                    - ':'
                    - ''
                    - 1
                  - !!perl/hash:RE_method
                    min: 0
                    name: ws
                    nobind: 1
                    noquant: 1
                    rest: ''
                  - !!perl/hash:RE_string
                    a: 0
                    dba: statement_control__S_072for
                    i: 0
                    min: 1
                    r: 1
                    s: 1
                    text: (
                  - !!perl/hash:RE_method
                    min: 0
                    name: ws
                    nobind: 1
                    noquant: 1
                    rest: ''
              s: 1
          - !!perl/hash:RE_method
            min: 0
            name: ws
            nobind: 1
            noquant: 1
            rest: ''
          - !!perl/hash:RE_method
            min: 0
            name: panic
            nobind: 1
            rest: ("This appears to be Perl 5 code")
          - !!perl/hash:RE_method
            min: 0
            name: ws
            nobind: 1
            noquant: 1
            rest: ''
      min: 0
      quant:
      - '?'
      - ':'
      - ''
      - 0
    - !!perl/hash:RE_method
      min: 0
      name: ws
      nobind: 1
      noquant: 1
      rest: ''
    - !!perl/hash:RE_quantified_atom
      atom: !!perl/hash:RE_bracket
        decl: []
        min: 0
        re: !!perl/hash:RE_sequence
          a: 0
          dba: statement_control__S_072for
          i: 0
          min: 0
          r: 1
          s: 1
          zyg:
          - !!perl/hash:RE_method
            min: 0
            name: ws
            nobind: 1
            noquant: 1
            rest: ''
          - !!perl/hash:RE_assertion
            assert: '?'
            min: 0
            re: !!perl/hash:RE_method_re
              a: 0
              dba: statement_control__S_072for
              i: 0
              min: 0
              name: before
              nobind: 1
              r: 1
              re: !!perl/hash:RE_ast
                decl: []
                min: 4
                re: !!perl/hash:RE_sequence
                  a: 0
                  dba: statement_control__S_072for
                  i: 0
                  min: 4
                  r: 1
                  s: 1
                  zyg:
                  - !!perl/hash:RE_string
                    a: 0
                    dba: statement_control__S_072for
                    i: 0
                    min: 1
                    r: 1
                    s: 1
                    text: (
                  - !!perl/hash:RE_method
                    min: 0
                    name: ws
                    nobind: 1
                    noquant: 1
                    rest: ''
                  - !!perl/hash:RE_quantified_atom
                    atom: !!perl/hash:RE_method
                      a: 0
                      dba: statement_control__S_072for
                      i: 0
                      min: 12345
                      name: EXPR
                      nobind: 1
                      r: 1
                      rest: ''
                      s: 1
                    min: 0
                    quant:
                    - '?'
                    - ':'
                    - ''
                    - 0
                  - !!perl/hash:RE_method
                    min: 0
                    name: ws
                    nobind: 1
                    noquant: 1
                    rest: ''
                  - !!perl/hash:RE_string
                    a: 0
                    dba: statement_control__S_072for
                    i: 0
                    min: 1
                    r: 1
                    s: 1
                    text: ;
                  - !!perl/hash:RE_method
                    min: 0
                    name: ws
                    nobind: 1
                    noquant: 1
                    rest: ''
                  - !!perl/hash:RE_quantified_atom
                    atom: !!perl/hash:RE_method
                      a: 0
                      dba: statement_control__S_072for
                      i: 0
                      min: 12345
                      name: EXPR
                      nobind: 1
                      r: 1
                      rest: ''
                      s: 1
                    min: 0
                    quant:
                    - '?'
                    - ':'
                    - ''
                    - 0
                  - !!perl/hash:RE_method
                    min: 0
                    name: ws
                    nobind: 1
                    noquant: 1
                    rest: ''
                  - !!perl/hash:RE_string
                    a: 0
                    dba: statement_control__S_072for
                    i: 0
                    min: 1
                    r: 1
                    s: 1
                    text: ;
                  - !!perl/hash:RE_method
                    min: 0
                    name: ws
                    nobind: 1
                    noquant: 1
                    rest: ''
                  - !!perl/hash:RE_quantified_atom
                    atom: !!perl/hash:RE_method
                      a: 0
                      dba: statement_control__S_072for
                      i: 0
                      min: 12345
                      name: EXPR
                      nobind: 1
                      r: 1
                      rest: ''
                      s: 1
                    min: 0
                    quant:
                    - '?'
                    - ':'
                    - ''
                    - 0
                  - !!perl/hash:RE_method
                    min: 0
                    name: ws
                    nobind: 1
                    noquant: 1
                    rest: ''
                  - !!perl/hash:RE_string
                    a: 0
                    dba: statement_control__S_072for
                    i: 0
                    min: 1
                    r: 1
                    s: 1
                    text: )
                  - !!perl/hash:RE_method
                    min: 0
                    name: ws
                    nobind: 1
                    noquant: 1
                    rest: ''
              s: 1
          - !!perl/hash:RE_method
            min: 0
            name: ws
            nobind: 1
            noquant: 1
            rest: ''
          - !!perl/hash:RE_method
            min: 0
            name: obs
            nobind: 1
            rest: ('C-style "for (;;)" loop', '"loop (;;)"')
          - !!perl/hash:RE_method
            min: 0
            name: ws
            nobind: 1
            noquant: 1
            rest: ''
      min: 0
      quant:
      - '?'
      - ':'
      - ''
      - 0
    - !!perl/hash:RE_method
      min: 0
      name: ws
      nobind: 1
      noquant: 1
      rest: ''
    - !!perl/hash:RE_method
      a: 0
      dba: statement_control__S_072for
      i: 0
      min: 12345
      name: xblock
      r: 1
      rest: ''
      s: 1
    - !!perl/hash:RE_method
      min: 0
      name: ws
      nobind: 1
      noquant: 1
      rest: ''
statement_control__S_073given: !!perl/hash:RE_ast
  decl: []
  kind: token
  min: 37035
  pkg: ~
  re: !!perl/hash:RE_sequence
    a: 0
    dba: statement_control__S_073given
    i: 0
    min: 37035
    r: 1
    s: 1
    zyg:
    - !!perl/hash:RE_method
      a: 0
      dba: statement_control__S_073given
      endsym: spacey
      i: 0
      min: 12345
      name: sym
      r: 1
      rest: ''
      s: 0
      sym: given
    - !!perl/hash:RE_method
      a: 0
      dba: statement_control__S_073given
      i: 0
      min: 12345
      name: spacey
      nobind: 1
      r: 1
      rest: ''
      s: 0
    - !!perl/hash:RE_method
      min: 0
      name: ws
      nobind: 1
      noquant: 1
      rest: ''
    - !!perl/hash:RE_method
      a: 0
      dba: statement_control__S_073given
      i: 0
      min: 12345
      name: xblock
      r: 1
      rest: ''
      s: 1
    - !!perl/hash:RE_method
      min: 0
      name: ws
      nobind: 1
      noquant: 1
      rest: ''
statement_control__S_074when: !!perl/hash:RE_ast
  decl: []
  kind: token
  min: 37035
  pkg: ~
  re: !!perl/hash:RE_sequence
    a: 0
    dba: statement_control__S_074when
    i: 0
    min: 37035
    r: 1
    s: 1
    zyg:
    - !!perl/hash:RE_method
      a: 0
      dba: statement_control__S_074when
      endsym: spacey
      i: 0
      min: 12345
      name: sym
      r: 1
      rest: ''
      s: 0
      sym: when
    - !!perl/hash:RE_method
      a: 0
      dba: statement_control__S_074when
      i: 0
      min: 12345
      name: spacey
      nobind: 1
      r: 1
      rest: ''
      s: 0
    - !!perl/hash:RE_method
      min: 0
      name: ws
      nobind: 1
      noquant: 1
      rest: ''
    - !!perl/hash:RE_method
      a: 0
      dba: statement_control__S_074when
      i: 0
      min: 12345
      name: xblock
      r: 1
      rest: ''
      s: 1
    - !!perl/hash:RE_method
      min: 0
      name: ws
      nobind: 1
      noquant: 1
      rest: ''
statement_control__S_075default: !!perl/hash:RE_ast
  decl: []
  kind: rule
  min: 37035
  pkg: ~
  re: !!perl/hash:RE_sequence
    a: 0
    dba: statement_control__S_075default
    i: 0
    min: 37035
    r: 1
    s: 1
    zyg:
    - !!perl/hash:RE_method
      a: 0
      dba: statement_control__S_075default
      endsym: spacey
      i: 0
      min: 12345
      name: sym
      r: 1
      rest: ''
      s: 1
      sym: default
    - !!perl/hash:RE_method
      a: 0
      dba: statement_control__S_075default
      i: 0
      min: 12345
      name: spacey
      nobind: 1
      r: 1
      rest: ''
      s: 1
    - !!perl/hash:RE_method
      min: 0
      name: ws
      nobind: 1
      noquant: 1
      rest: ''
    - !!perl/hash:RE_method
      a: 0
      dba: statement_control__S_075default
      i: 0
      min: 12345
      name: block
      r: 1
      rest: ''
      s: 1
    - !!perl/hash:RE_method
      min: 0
      name: ws
      nobind: 1
      noquant: 1
      rest: ''
statement_control__S_090CATCH: !!perl/hash:RE_ast
  decl: []
  kind: rule
  min: 37035
  pkg: ~
  re: !!perl/hash:RE_sequence
    a: 0
    dba: statement_control__S_090CATCH
    i: 0
    min: 37035
    r: 1
    s: 1
    zyg:
    - !!perl/hash:RE_method
      a: 0
      dba: statement_control__S_090CATCH
      endsym: spacey
      i: 0
      min: 12345
      name: sym
      r: 1
      rest: ''
      s: 1
      sym: CATCH
    - !!perl/hash:RE_method
      a: 0
      dba: statement_control__S_090CATCH
      i: 0
      min: 12345
      name: spacey
      nobind: 1
      r: 1
      rest: ''
      s: 1
    - !!perl/hash:RE_method
      min: 0
      name: ws
      nobind: 1
      noquant: 1
      rest: ''
    - !!perl/hash:RE_method
      a: 0
      dba: statement_control__S_090CATCH
      i: 0
      min: 12345
      name: block
      r: 1
      rest: ''
      s: 1
    - !!perl/hash:RE_method
      min: 0
      name: ws
      nobind: 1
      noquant: 1
      rest: ''
statement_control__S_091CONTROL: !!perl/hash:RE_ast
  decl: []
  kind: rule
  min: 37035
  pkg: ~
  re: !!perl/hash:RE_sequence
    a: 0
    dba: statement_control__S_091CONTROL
    i: 0
    min: 37035
    r: 1
    s: 1
    zyg:
    - !!perl/hash:RE_method
      a: 0
      dba: statement_control__S_091CONTROL
      endsym: spacey
      i: 0
      min: 12345
      name: sym
      r: 1
      rest: ''
      s: 1
      sym: CONTROL
    - !!perl/hash:RE_method
      a: 0
      dba: statement_control__S_091CONTROL
      i: 0
      min: 12345
      name: spacey
      nobind: 1
      r: 1
      rest: ''
      s: 1
    - !!perl/hash:RE_method
      min: 0
      name: ws
      nobind: 1
      noquant: 1
      rest: ''
    - !!perl/hash:RE_method
      a: 0
      dba: statement_control__S_091CONTROL
      i: 0
      min: 12345
      name: block
      r: 1
      rest: ''
      s: 1
    - !!perl/hash:RE_method
      min: 0
      name: ws
      nobind: 1
      noquant: 1
      rest: ''
statement_control__S_092TEMP: !!perl/hash:RE_ast
  decl: []
  kind: rule
  min: 37035
  pkg: ~
  re: !!perl/hash:RE_sequence
    a: 0
    dba: statement_control__S_092TEMP
    i: 0
    min: 37035
    r: 1
    s: 1
    zyg:
    - !!perl/hash:RE_method
      a: 0
      dba: statement_control__S_092TEMP
      endsym: spacey
      i: 0
      min: 12345
      name: sym
      r: 1
      rest: ''
      s: 1
      sym: TEMP
    - !!perl/hash:RE_method
      a: 0
      dba: statement_control__S_092TEMP
      i: 0
      min: 12345
      name: spacey
      nobind: 1
      r: 1
      rest: ''
      s: 1
    - !!perl/hash:RE_method
      min: 0
      name: ws
      nobind: 1
      noquant: 1
      rest: ''
    - !!perl/hash:RE_method
      a: 0
      dba: statement_control__S_092TEMP
      i: 0
      min: 12345
      name: block
      r: 1
      rest: ''
      s: 1
    - !!perl/hash:RE_method
      min: 0
      name: ws
      nobind: 1
      noquant: 1
      rest: ''
statement_mod_cond__S_093if: !!perl/hash:RE_ast
  decl: []
  kind: rule
  min: 37035
  pkg: ~
  re: !!perl/hash:RE_sequence
    a: 0
    dba: statement_mod_cond__S_093if
    i: 0
    min: 37035
    r: 1
    s: 1
    zyg:
    - !!perl/hash:RE_method
      a: 0
      dba: statement_mod_cond__S_093if
      endsym: nofun
      i: 0
      min: 12345
      name: sym
      r: 1
      rest: ''
      s: 1
      sym: if
    - !!perl/hash:RE_method
      a: 0
      dba: statement_mod_cond__S_093if
      i: 0
      min: 12345
      name: nofun
      nobind: 1
      r: 1
      rest: ''
      s: 1
    - !!perl/hash:RE_method
      min: 0
      name: ws
      nobind: 1
      noquant: 1
      rest: ''
    - !!perl/hash:RE_method
      a: 0
      dba: statement_mod_cond__S_093if
      i: 0
      min: 12345
      name: modifier_expr
      r: 1
      rest: ''
      s: 1
    - !!perl/hash:RE_method
      min: 0
      name: ws
      nobind: 1
      noquant: 1
      rest: ''
statement_mod_cond__S_094unless: !!perl/hash:RE_ast
  decl: []
  kind: rule
  min: 37035
  pkg: ~
  re: !!perl/hash:RE_sequence
    a: 0
    dba: statement_mod_cond__S_094unless
    i: 0
    min: 37035
    r: 1
    s: 1
    zyg:
    - !!perl/hash:RE_method
      a: 0
      dba: statement_mod_cond__S_094unless
      endsym: nofun
      i: 0
      min: 12345
      name: sym
      r: 1
      rest: ''
      s: 1
      sym: unless
    - !!perl/hash:RE_method
      a: 0
      dba: statement_mod_cond__S_094unless
      i: 0
      min: 12345
      name: nofun
      nobind: 1
      r: 1
      rest: ''
      s: 1
    - !!perl/hash:RE_method
      min: 0
      name: ws
      nobind: 1
      noquant: 1
      rest: ''
    - !!perl/hash:RE_method
      a: 0
      dba: statement_mod_cond__S_094unless
      i: 0
      min: 12345
      name: modifier_expr
      r: 1
      rest: ''
      s: 1
    - !!perl/hash:RE_method
      min: 0
      name: ws
      nobind: 1
      noquant: 1
      rest: ''
statement_mod_cond__S_095when: !!perl/hash:RE_ast
  decl: []
  kind: rule
  min: 37035
  pkg: ~
  re: !!perl/hash:RE_sequence
    a: 0
    dba: statement_mod_cond__S_095when
    i: 0
    min: 37035
    r: 1
    s: 1
    zyg:
    - !!perl/hash:RE_method
      a: 0
      dba: statement_mod_cond__S_095when
      endsym: nofun
      i: 0
      min: 12345
      name: sym
      r: 1
      rest: ''
      s: 1
      sym: when
    - !!perl/hash:RE_method
      a: 0
      dba: statement_mod_cond__S_095when
      i: 0
      min: 12345
      name: nofun
      nobind: 1
      r: 1
      rest: ''
      s: 1
    - !!perl/hash:RE_method
      min: 0
      name: ws
      nobind: 1
      noquant: 1
      rest: ''
    - !!perl/hash:RE_method
      a: 0
      dba: statement_mod_cond__S_095when
      i: 0
      min: 12345
      name: modifier_expr
      r: 1
      rest: ''
      s: 1
    - !!perl/hash:RE_method
      min: 0
      name: ws
      nobind: 1
      noquant: 1
      rest: ''
statement_mod_loop__S_096while: !!perl/hash:RE_ast
  decl: []
  kind: rule
  min: 37035
  pkg: ~
  re: !!perl/hash:RE_sequence
    a: 0
    dba: statement_mod_loop__S_096while
    i: 0
    min: 37035
    r: 1
    s: 1
    zyg:
    - !!perl/hash:RE_method
      a: 0
      dba: statement_mod_loop__S_096while
      endsym: nofun
      i: 0
      min: 12345
      name: sym
      r: 1
      rest: ''
      s: 1
      sym: while
    - !!perl/hash:RE_method
      a: 0
      dba: statement_mod_loop__S_096while
      i: 0
      min: 12345
      name: nofun
      nobind: 1
      r: 1
      rest: ''
      s: 1
    - !!perl/hash:RE_method
      min: 0
      name: ws
      nobind: 1
      noquant: 1
      rest: ''
    - !!perl/hash:RE_method
      a: 0
      dba: statement_mod_loop__S_096while
      i: 0
      min: 12345
      name: modifier_expr
      r: 1
      rest: ''
      s: 1
    - !!perl/hash:RE_method
      min: 0
      name: ws
      nobind: 1
      noquant: 1
      rest: ''
statement_mod_loop__S_097until: !!perl/hash:RE_ast
  decl: []
  kind: rule
  min: 37035
  pkg: ~
  re: !!perl/hash:RE_sequence
    a: 0
    dba: statement_mod_loop__S_097until
    i: 0
    min: 37035
    r: 1
    s: 1
    zyg:
    - !!perl/hash:RE_method
      a: 0
      dba: statement_mod_loop__S_097until
      endsym: nofun
      i: 0
      min: 12345
      name: sym
      r: 1
      rest: ''
      s: 1
      sym: until
    - !!perl/hash:RE_method
      a: 0
      dba: statement_mod_loop__S_097until
      i: 0
      min: 12345
      name: nofun
      nobind: 1
      r: 1
      rest: ''
      s: 1
    - !!perl/hash:RE_method
      min: 0
      name: ws
      nobind: 1
      noquant: 1
      rest: ''
    - !!perl/hash:RE_method
      a: 0
      dba: statement_mod_loop__S_097until
      i: 0
      min: 12345
      name: modifier_expr
      r: 1
      rest: ''
      s: 1
    - !!perl/hash:RE_method
      min: 0
      name: ws
      nobind: 1
      noquant: 1
      rest: ''
statement_mod_loop__S_098for: !!perl/hash:RE_ast
  decl: []
  kind: rule
  min: 37035
  pkg: ~
  re: !!perl/hash:RE_sequence
    a: 0
    dba: statement_mod_loop__S_098for
    i: 0
    min: 37035
    r: 1
    s: 1
    zyg:
    - !!perl/hash:RE_method
      a: 0
      dba: statement_mod_loop__S_098for
      endsym: nofun
      i: 0
      min: 12345
      name: sym
      r: 1
      rest: ''
      s: 1
      sym: for
    - !!perl/hash:RE_method
      a: 0
      dba: statement_mod_loop__S_098for
      i: 0
      min: 12345
      name: nofun
      nobind: 1
      r: 1
      rest: ''
      s: 1
    - !!perl/hash:RE_method
      min: 0
      name: ws
      nobind: 1
      noquant: 1
      rest: ''
    - !!perl/hash:RE_method
      a: 0
      dba: statement_mod_loop__S_098for
      i: 0
      min: 12345
      name: modifier_expr
      r: 1
      rest: ''
      s: 1
    - !!perl/hash:RE_method
      min: 0
      name: ws
      nobind: 1
      noquant: 1
      rest: ''
statement_mod_loop__S_099given: !!perl/hash:RE_ast
  decl: []
  kind: rule
  min: 37035
  pkg: ~
  re: !!perl/hash:RE_sequence
    a: 0
    dba: statement_mod_loop__S_099given
    i: 0
    min: 37035
    r: 1
    s: 1
    zyg:
    - !!perl/hash:RE_method
      a: 0
      dba: statement_mod_loop__S_099given
      endsym: nofun
      i: 0
      min: 12345
      name: sym
      r: 1
      rest: ''
      s: 1
      sym: given
    - !!perl/hash:RE_method
      a: 0
      dba: statement_mod_loop__S_099given
      i: 0
      min: 12345
      name: nofun
      nobind: 1
      r: 1
      rest: ''
      s: 1
    - !!perl/hash:RE_method
      min: 0
      name: ws
      nobind: 1
      noquant: 1
      rest: ''
    - !!perl/hash:RE_method
      a: 0
      dba: statement_mod_loop__S_099given
      i: 0
      min: 12345
      name: modifier_expr
      r: 1
      rest: ''
      s: 1
    - !!perl/hash:RE_method
      min: 0
      name: ws
      nobind: 1
      noquant: 1
      rest: ''
statement_prefix__S_076BEGIN: !!perl/hash:RE_ast
  decl: []
  kind: token
  min: 24690
  pkg: ~
  re: !!perl/hash:RE_sequence
    a: 0
    dba: statement_prefix__S_076BEGIN
    i: 0
    min: 24690
    r: 1
    s: 0
    zyg:
    - !!perl/hash:RE_method
      a: 0
      dba: statement_prefix__S_076BEGIN
      i: 0
      min: 12345
      name: sym
      r: 1
      rest: ''
      s: 0
      sym: BEGIN
    - !!perl/hash:RE_method
      a: 0
      dba: statement_prefix__S_076BEGIN
      i: 0
      min: 12345
      name: blast
      r: 1
      rest: ''
      s: 0
statement_prefix__S_077CHECK: !!perl/hash:RE_ast
  decl: []
  kind: token
  min: 24690
  pkg: ~
  re: !!perl/hash:RE_sequence
    a: 0
    dba: statement_prefix__S_077CHECK
    i: 0
    min: 24690
    r: 1
    s: 0
    zyg:
    - !!perl/hash:RE_method
      a: 0
      dba: statement_prefix__S_077CHECK
      i: 0
      min: 12345
      name: sym
      r: 1
      rest: ''
      s: 0
      sym: CHECK
    - !!perl/hash:RE_method
      a: 0
      dba: statement_prefix__S_077CHECK
      i: 0
      min: 12345
      name: blast
      r: 1
      rest: ''
      s: 0
statement_prefix__S_078INIT: !!perl/hash:RE_ast
  decl: []
  kind: token
  min: 24690
  pkg: ~
  re: !!perl/hash:RE_sequence
    a: 0
    dba: statement_prefix__S_078INIT
    i: 0
    min: 24690
    r: 1
    s: 0
    zyg:
    - !!perl/hash:RE_method
      a: 0
      dba: statement_prefix__S_078INIT
      i: 0
      min: 12345
      name: sym
      r: 1
      rest: ''
      s: 0
      sym: INIT
    - !!perl/hash:RE_method
      a: 0
      dba: statement_prefix__S_078INIT
      i: 0
      min: 12345
      name: blast
      r: 1
      rest: ''
      s: 0
statement_prefix__S_079START: !!perl/hash:RE_ast
  decl: []
  kind: token
  min: 24690
  pkg: ~
  re: !!perl/hash:RE_sequence
    a: 0
    dba: statement_prefix__S_079START
    i: 0
    min: 24690
    r: 1
    s: 0
    zyg:
    - !!perl/hash:RE_method
      a: 0
      dba: statement_prefix__S_079START
      i: 0
      min: 12345
      name: sym
      r: 1
      rest: ''
      s: 0
      sym: START
    - !!perl/hash:RE_method
      a: 0
      dba: statement_prefix__S_079START
      i: 0
      min: 12345
      name: blast
      r: 1
      rest: ''
      s: 0
statement_prefix__S_080ENTER: !!perl/hash:RE_ast
  decl: []
  kind: token
  min: 24690
  pkg: ~
  re: !!perl/hash:RE_sequence
    a: 0
    dba: statement_prefix__S_080ENTER
    i: 0
    min: 24690
    r: 1
    s: 0
    zyg:
    - !!perl/hash:RE_method
      a: 0
      dba: statement_prefix__S_080ENTER
      i: 0
      min: 12345
      name: sym
      r: 1
      rest: ''
      s: 0
      sym: ENTER
    - !!perl/hash:RE_method
      a: 0
      dba: statement_prefix__S_080ENTER
      i: 0
      min: 12345
      name: blast
      r: 1
      rest: ''
      s: 0
statement_prefix__S_081FIRST: !!perl/hash:RE_ast
  decl: []
  kind: token
  min: 24690
  pkg: ~
  re: !!perl/hash:RE_sequence
    a: 0
    dba: statement_prefix__S_081FIRST
    i: 0
    min: 24690
    r: 1
    s: 0
    zyg:
    - !!perl/hash:RE_method
      a: 0
      dba: statement_prefix__S_081FIRST
      i: 0
      min: 12345
      name: sym
      r: 1
      rest: ''
      s: 0
      sym: FIRST
    - !!perl/hash:RE_method
      a: 0
      dba: statement_prefix__S_081FIRST
      i: 0
      min: 12345
      name: blast
      r: 1
      rest: ''
      s: 0
statement_prefix__S_082END: !!perl/hash:RE_ast
  decl: []
  kind: token
  min: 24690
  pkg: ~
  re: !!perl/hash:RE_sequence
    a: 0
    dba: statement_prefix__S_082END
    i: 0
    min: 24690
    r: 1
    s: 0
    zyg:
    - !!perl/hash:RE_method
      a: 0
      dba: statement_prefix__S_082END
      i: 0
      min: 12345
      name: sym
      r: 1
      rest: ''
      s: 0
      sym: END
    - !!perl/hash:RE_method
      a: 0
      dba: statement_prefix__S_082END
      i: 0
      min: 12345
      name: blast
      r: 1
      rest: ''
      s: 0
statement_prefix__S_083LEAVE: !!perl/hash:RE_ast
  decl: []
  kind: token
  min: 24690
  pkg: ~
  re: !!perl/hash:RE_sequence
    a: 0
    dba: statement_prefix__S_083LEAVE
    i: 0
    min: 24690
    r: 1
    s: 0
    zyg:
    - !!perl/hash:RE_method
      a: 0
      dba: statement_prefix__S_083LEAVE
      i: 0
      min: 12345
      name: sym
      r: 1
      rest: ''
      s: 0
      sym: LEAVE
    - !!perl/hash:RE_method
      a: 0
      dba: statement_prefix__S_083LEAVE
      i: 0
      min: 12345
      name: blast
      r: 1
      rest: ''
      s: 0
statement_prefix__S_084KEEP: !!perl/hash:RE_ast
  decl: []
  kind: token
  min: 24690
  pkg: ~
  re: !!perl/hash:RE_sequence
    a: 0
    dba: statement_prefix__S_084KEEP
    i: 0
    min: 24690
    r: 1
    s: 0
    zyg:
    - !!perl/hash:RE_method
      a: 0
      dba: statement_prefix__S_084KEEP
      i: 0
      min: 12345
      name: sym
      r: 1
      rest: ''
      s: 0
      sym: KEEP
    - !!perl/hash:RE_method
      a: 0
      dba: statement_prefix__S_084KEEP
      i: 0
      min: 12345
      name: blast
      r: 1
      rest: ''
      s: 0
statement_prefix__S_085UNDO: !!perl/hash:RE_ast
  decl: []
  kind: token
  min: 24690
  pkg: ~
  re: !!perl/hash:RE_sequence
    a: 0
    dba: statement_prefix__S_085UNDO
    i: 0
    min: 24690
    r: 1
    s: 0
    zyg:
    - !!perl/hash:RE_method
      a: 0
      dba: statement_prefix__S_085UNDO
      i: 0
      min: 12345
      name: sym
      r: 1
      rest: ''
      s: 0
      sym: UNDO
    - !!perl/hash:RE_method
      a: 0
      dba: statement_prefix__S_085UNDO
      i: 0
      min: 12345
      name: blast
      r: 1
      rest: ''
      s: 0
statement_prefix__S_086NEXT: !!perl/hash:RE_ast
  decl: []
  kind: token
  min: 24690
  pkg: ~
  re: !!perl/hash:RE_sequence
    a: 0
    dba: statement_prefix__S_086NEXT
    i: 0
    min: 24690
    r: 1
    s: 0
    zyg:
    - !!perl/hash:RE_method
      a: 0
      dba: statement_prefix__S_086NEXT
      i: 0
      min: 12345
      name: sym
      r: 1
      rest: ''
      s: 0
      sym: NEXT
    - !!perl/hash:RE_method
      a: 0
      dba: statement_prefix__S_086NEXT
      i: 0
      min: 12345
      name: blast
      r: 1
      rest: ''
      s: 0
statement_prefix__S_087LAST: !!perl/hash:RE_ast
  decl: []
  kind: token
  min: 24690
  pkg: ~
  re: !!perl/hash:RE_sequence
    a: 0
    dba: statement_prefix__S_087LAST
    i: 0
    min: 24690
    r: 1
    s: 0
    zyg:
    - !!perl/hash:RE_method
      a: 0
      dba: statement_prefix__S_087LAST
      i: 0
      min: 12345
      name: sym
      r: 1
      rest: ''
      s: 0
      sym: LAST
    - !!perl/hash:RE_method
      a: 0
      dba: statement_prefix__S_087LAST
      i: 0
      min: 12345
      name: blast
      r: 1
      rest: ''
      s: 0
statement_prefix__S_088PRE: !!perl/hash:RE_ast
  decl: []
  kind: token
  min: 24690
  pkg: ~
  re: !!perl/hash:RE_sequence
    a: 0
    dba: statement_prefix__S_088PRE
    i: 0
    min: 24690
    r: 1
    s: 0
    zyg:
    - !!perl/hash:RE_method
      a: 0
      dba: statement_prefix__S_088PRE
      i: 0
      min: 12345
      name: sym
      r: 1
      rest: ''
      s: 0
      sym: PRE
    - !!perl/hash:RE_method
      a: 0
      dba: statement_prefix__S_088PRE
      i: 0
      min: 12345
      name: blast
      r: 1
      rest: ''
      s: 0
statement_prefix__S_089POST: !!perl/hash:RE_ast
  decl: []
  kind: token
  min: 24690
  pkg: ~
  re: !!perl/hash:RE_sequence
    a: 0
    dba: statement_prefix__S_089POST
    i: 0
    min: 24690
    r: 1
    s: 0
    zyg:
    - !!perl/hash:RE_method
      a: 0
      dba: statement_prefix__S_089POST
      i: 0
      min: 12345
      name: sym
      r: 1
      rest: ''
      s: 0
      sym: POST
    - !!perl/hash:RE_method
      a: 0
      dba: statement_prefix__S_089POST
      i: 0
      min: 12345
      name: blast
      r: 1
      rest: ''
      s: 0
statement_prefix__S_230sink: !!perl/hash:RE_ast
  decl: []
  kind: token
  min: 24690
  pkg: ~
  re: !!perl/hash:RE_sequence
    a: 0
    dba: statement_prefix__S_230sink
    i: 0
    min: 24690
    r: 1
    s: 0
    zyg:
    - !!perl/hash:RE_method
      a: 0
      dba: statement_prefix__S_230sink
      i: 0
      min: 12345
      name: sym
      r: 1
      rest: ''
      s: 0
      sym: sink
    - !!perl/hash:RE_method
      a: 0
      dba: statement_prefix__S_230sink
      i: 0
      min: 12345
      name: blast
      r: 1
      rest: ''
      s: 0
statement_prefix__S_231try: !!perl/hash:RE_ast
  decl: []
  kind: token
  min: 24690
  pkg: ~
  re: !!perl/hash:RE_sequence
    a: 0
    dba: statement_prefix__S_231try
    i: 0
    min: 24690
    r: 1
    s: 0
    zyg:
    - !!perl/hash:RE_method
      a: 0
      dba: statement_prefix__S_231try
      i: 0
      min: 12345
      name: sym
      r: 1
      rest: ''
      s: 0
      sym: try
    - !!perl/hash:RE_method
      a: 0
      dba: statement_prefix__S_231try
      i: 0
      min: 12345
      name: blast
      r: 1
      rest: ''
      s: 0
statement_prefix__S_232quietly: !!perl/hash:RE_ast
  decl: []
  kind: token
  min: 24690
  pkg: ~
  re: !!perl/hash:RE_sequence
    a: 0
    dba: statement_prefix__S_232quietly
    i: 0
    min: 24690
    r: 1
    s: 0
    zyg:
    - !!perl/hash:RE_method
      a: 0
      dba: statement_prefix__S_232quietly
      i: 0
      min: 12345
      name: sym
      r: 1
      rest: ''
      s: 0
      sym: quietly
    - !!perl/hash:RE_method
      a: 0
      dba: statement_prefix__S_232quietly
      i: 0
      min: 12345
      name: blast
      r: 1
      rest: ''
      s: 0
statement_prefix__S_233gather: !!perl/hash:RE_ast
  decl: []
  kind: token
  min: 24690
  pkg: ~
  re: !!perl/hash:RE_sequence
    a: 0
    dba: statement_prefix__S_233gather
    i: 0
    min: 24690
    r: 1
    s: 0
    zyg:
    - !!perl/hash:RE_method
      a: 0
      dba: statement_prefix__S_233gather
      i: 0
      min: 12345
      name: sym
      r: 1
      rest: ''
      s: 0
      sym: gather
    - !!perl/hash:RE_method
      a: 0
      dba: statement_prefix__S_233gather
      i: 0
      min: 12345
      name: blast
      r: 1
      rest: ''
      s: 0
statement_prefix__S_234contend: !!perl/hash:RE_ast
  decl: []
  kind: token
  min: 24690
  pkg: ~
  re: !!perl/hash:RE_sequence
    a: 0
    dba: statement_prefix__S_234contend
    i: 0
    min: 24690
    r: 1
    s: 0
    zyg:
    - !!perl/hash:RE_method
      a: 0
      dba: statement_prefix__S_234contend
      i: 0
      min: 12345
      name: sym
      r: 1
      rest: ''
      s: 0
      sym: contend
    - !!perl/hash:RE_method
      a: 0
      dba: statement_prefix__S_234contend
      i: 0
      min: 12345
      name: blast
      r: 1
      rest: ''
      s: 0
statement_prefix__S_235async: !!perl/hash:RE_ast
  decl: []
  kind: token
  min: 24690
  pkg: ~
  re: !!perl/hash:RE_sequence
    a: 0
    dba: statement_prefix__S_235async
    i: 0
    min: 24690
    r: 1
    s: 0
    zyg:
    - !!perl/hash:RE_method
      a: 0
      dba: statement_prefix__S_235async
      i: 0
      min: 12345
      name: sym
      r: 1
      rest: ''
      s: 0
      sym: async
    - !!perl/hash:RE_method
      a: 0
      dba: statement_prefix__S_235async
      i: 0
      min: 12345
      name: blast
      r: 1
      rest: ''
      s: 0
statement_prefix__S_236maybe: !!perl/hash:RE_ast
  decl: []
  kind: token
  min: 24690
  pkg: ~
  re: !!perl/hash:RE_sequence
    a: 0
    dba: statement_prefix__S_236maybe
    i: 0
    min: 24690
    r: 1
    s: 0
    zyg:
    - !!perl/hash:RE_method
      a: 0
      dba: statement_prefix__S_236maybe
      i: 0
      min: 12345
      name: sym
      r: 1
      rest: ''
      s: 0
      sym: maybe
    - !!perl/hash:RE_method
      a: 0
      dba: statement_prefix__S_236maybe
      i: 0
      min: 12345
      name: blast
      r: 1
      rest: ''
      s: 0
statement_prefix__S_237lazy: !!perl/hash:RE_ast
  decl: []
  kind: token
  min: 24690
  pkg: ~
  re: !!perl/hash:RE_sequence
    a: 0
    dba: statement_prefix__S_237lazy
    i: 0
    min: 24690
    r: 1
    s: 0
    zyg:
    - !!perl/hash:RE_method
      a: 0
      dba: statement_prefix__S_237lazy
      i: 0
      min: 12345
      name: sym
      r: 1
      rest: ''
      s: 0
      sym: lazy
    - !!perl/hash:RE_method
      a: 0
      dba: statement_prefix__S_237lazy
      i: 0
      min: 12345
      name: blast
      r: 1
      rest: ''
      s: 0
statement_prefix__S_238do: !!perl/hash:RE_ast
  decl: []
  kind: token
  min: 24690
  pkg: ~
  re: !!perl/hash:RE_sequence
    a: 0
    dba: statement_prefix__S_238do
    i: 0
    min: 24690
    r: 1
    s: 0
    zyg:
    - !!perl/hash:RE_method
      a: 0
      dba: statement_prefix__S_238do
      i: 0
      min: 12345
      name: sym
      r: 1
      rest: ''
      s: 0
      sym: do
    - !!perl/hash:RE_method
      a: 0
      dba: statement_prefix__S_238do
      i: 0
      min: 12345
      name: blast
      r: 1
      rest: ''
      s: 0
statement_prefix__S_239lift: !!perl/hash:RE_ast
  decl:
  - !!perl/hash:RE_decl
    a: 0
    dba: statement_prefix__S_239lift
    i: 0
    max: 0
    min: 0
    r: 1
    s: 0
    text: my $*QUASIMODO = 1
  kind: token
  min: 24690
  pkg: ~
  re: !!perl/hash:RE_sequence
    a: 0
    dba: statement_prefix__S_239lift
    i: 0
    min: 24690
    r: 1
    s: 0
    zyg:
    - !!perl/hash:RE_method
      a: 0
      dba: statement_prefix__S_239lift
      i: 0
      min: 12345
      name: sym
      r: 1
      rest: ''
      s: 0
      sym: lift
    - !!perl/hash:RE_method
      a: 0
      dba: statement_prefix__S_239lift
      i: 0
      min: 12345
      name: blast
      r: 1
      rest: ''
      s: 0
statementlist: !!perl/hash:RE_ast
  decl:
  - !!perl/hash:RE_decl
    a: 0
    dba: statementlist
    i: 0
    max: 0
    min: 0
    r: 1
    s: 1
    text: my $*INVOCANT_OK = 0
  - !!perl/hash:RE_decl
    a: 0
    dba: statementlist
    i: 0
    max: 0
    min: 0
    r: 1
    s: 1
    text: temp $*MONKEY_TYPING
  kind: rule
  min: 0
  pkg: ~
  re: !!perl/hash:RE_sequence
    a: 0
    dba: statement list
    i: 0
    min: 0
    r: 1
    s: 1
    zyg:
    - !!perl/hash:RE_method
      min: 0
      name: ws
      nobind: 1
      noquant: 1
      rest: ''
    - !!perl/hash:RE_method
      min: 0
      name: ws
      nobind: 1
      noquant: 1
      rest: ''
    - !!perl/hash:RE_bracket
      decl: []
      min: 0
      re: &101 !!perl/hash:RE_any
        a: 0
        altname: statementlist_01
        dba: statement list
        i: 0
        min: 0
        name: statementlist_01
        r: 1
        s: 1
        zyg:
        - !!perl/hash:RE_sequence
          a: 0
          alt: statementlist_01 0
          dba: statement list
          i: 0
          min: 0
          r: 1
          s: 1
          zyg:
          - !!perl/hash:RE_meta
            a: 0
            dba: statement list
            i: 0
            min: 0
            r: 1
            s: 1
            text: $
          - !!perl/hash:RE_method
            min: 0
            name: ws
            nobind: 1
            noquant: 1
            rest: ''
        - !!perl/hash:RE_sequence
          a: 0
          alt: statementlist_01 1
          dba: statement list
          i: 0
          min: 0
          r: 1
          s: 1
          zyg:
          - !!perl/hash:RE_assertion
            assert: '?'
            min: 0
            re: !!perl/hash:RE_method_re
              a: 0
              dba: statement list
              i: 0
              min: 0
              name: before
              nobind: 1
              r: 1
              re: !!perl/hash:RE_ast
                decl: []
                min: 1
                re: !!perl/hash:RE_cclass
                  a: 0
                  dba: statement list
                  i: 0
                  min: 1
                  r: 1
                  s: 1
                  text: '[\)\]\}]'
              s: 1
          - !!perl/hash:RE_method
            min: 0
            name: ws
            nobind: 1
            noquant: 1
            rest: ''
        - !!perl/hash:RE_sequence
          a: 0
          alt: statementlist_01 2
          dba: statement list
          i: 0
          min: 0
          r: 1
          s: 1
          zyg:
          - !!perl/hash:RE_quantified_atom
            atom: !!perl/hash:RE_bracket
              decl: []
              min: 24690
              re: !!perl/hash:RE_sequence
                a: 0
                dba: statement list
                i: 0
                min: 24690
                r: 1
                s: 1
                zyg:
                - !!perl/hash:RE_method
                  a: 0
                  dba: statement list
                  i: 0
                  min: 12345
                  name: statement
                  r: 1
                  rest: ''
                  s: 1
                - !!perl/hash:RE_method
                  a: 0
                  dba: statement list
                  i: 0
                  min: 12345
                  name: eat_terminator
                  r: 1
                  rest: ''
                  s: 1
                - !!perl/hash:RE_method
                  min: 0
                  name: ws
                  nobind: 1
                  noquant: 1
                  rest: ''
            min: 0
            quant:
            - '*'
            - ':'
            - ''
            - 0
          - !!perl/hash:RE_method
            min: 0
            name: ws
            nobind: 1
            noquant: 1
            rest: ''
    - !!perl/hash:RE_method
      min: 0
      name: ws
      nobind: 1
      noquant: 1
      rest: ''
statementlist_01: *101
strtonum__S_200rational: !!perl/hash:RE_ast
  decl: []
  kind: token
  min: 24691
  pkg: ~
  re: !!perl/hash:RE_sequence
    a: 0
    dba: strtonum__S_200rational
    i: 0
    min: 24691
    r: 1
    s: 0
    zyg:
    - !!perl/hash:RE_quantified_atom
      atom: !!perl/hash:RE_cclass
        a: 0
        dba: strtonum__S_200rational
        i: 0
        min: 1
        r: 1
        s: 0
        text: '[+\-]'
      min: 0
      quant:
      - '?'
      - ':'
      - ''
      - 0
    - !!perl/hash:RE_bindnamed
      a: 0
      atom: !!perl/hash:RE_method
        a: 0
        dba: strtonum__S_200rational
        i: 0
        min: 12345
        name: integer
        nobind: 1
        r: 1
        rest: ''
        s: 0
      dba: strtonum__S_200rational
      i: 0
      min: 12345
      r: 1
      s: 0
      var: nu
    - !!perl/hash:RE_string
      a: 0
      dba: strtonum__S_200rational
      i: 0
      min: 1
      r: 1
      s: 0
      text: /
    - !!perl/hash:RE_bindnamed
      a: 0
      atom: !!perl/hash:RE_method
        a: 0
        dba: strtonum__S_200rational
        i: 0
        min: 12345
        name: integer
        nobind: 1
        r: 1
        rest: ''
        s: 0
      dba: strtonum__S_200rational
      i: 0
      min: 12345
      r: 1
      s: 0
      var: de
strtonum__S_201complex: !!perl/hash:RE_ast
  decl: []
  kind: token
  min: 12347
  pkg: ~
  re: !!perl/hash:RE_sequence
    a: 0
    dba: strtonum__S_201complex
    i: 0
    min: 12347
    r: 1
    s: 0
    zyg:
    - !!perl/hash:RE_quantified_atom
      atom: !!perl/hash:RE_bracket
        decl: []
        min: 12345
        re: !!perl/hash:RE_sequence
          a: 0
          dba: strtonum__S_201complex
          i: 0
          min: 12345
          r: 1
          s: 0
          zyg:
          - !!perl/hash:RE_quantified_atom
            atom: !!perl/hash:RE_cclass
              a: 0
              dba: strtonum__S_201complex
              i: 0
              min: 1
              r: 1
              s: 0
              text: '[+\-]'
            min: 0
            quant:
            - '?'
            - ':'
            - ''
            - 0
          - !!perl/hash:RE_bindnamed
            a: 0
            atom: !!perl/hash:RE_method
              a: 0
              dba: strtonum__S_201complex
              i: 0
              min: 12345
              name: number
              nobind: 1
              r: 1
              rest: ''
              s: 0
            dba: strtonum__S_201complex
            i: 0
            min: 12345
            r: 1
            s: 0
            var: re
      min: 0
      quant:
      - '?'
      - ':'
      - ''
      - 0
    - !!perl/hash:RE_cclass
      a: 0
      dba: strtonum__S_201complex
      i: 0
      min: 1
      r: 1
      s: 0
      text: '[+\-]'
    - !!perl/hash:RE_bindnamed
      a: 0
      atom: !!perl/hash:RE_method
        a: 0
        dba: strtonum__S_201complex
        i: 0
        min: 12345
        name: number
        nobind: 1
        r: 1
        rest: ''
        s: 0
      dba: strtonum__S_201complex
      i: 0
      min: 12345
      r: 1
      s: 0
      var: im
    - !!perl/hash:RE_quantified_atom
      atom: !!perl/hash:RE_string
        a: 0
        dba: strtonum__S_201complex
        i: 0
        min: 1
        r: 1
        s: 0
        text: \
      min: 0
      quant:
      - '?'
      - ':'
      - ''
      - 0
    - !!perl/hash:RE_string
      a: 0
      dba: strtonum__S_201complex
      i: 0
      min: 1
      r: 1
      s: 0
      text: i
strtonum__S_202number: !!perl/hash:RE_ast
  decl: []
  kind: token
  min: 12345
  pkg: ~
  re: !!perl/hash:RE_sequence
    a: 0
    dba: strtonum__S_202number
    i: 0
    min: 12345
    r: 1
    s: 0
    zyg:
    - !!perl/hash:RE_quantified_atom
      atom: !!perl/hash:RE_cclass
        a: 0
        dba: strtonum__S_202number
        i: 0
        min: 1
        r: 1
        s: 0
        text: '[+\-]'
      min: 0
      quant:
      - '?'
      - ':'
      - ''
      - 0
    - !!perl/hash:RE_method
      a: 0
      dba: strtonum__S_202number
      i: 0
      min: 12345
      name: number
      r: 1
      rest: ''
      s: 0
sublongname: !!perl/hash:RE_ast
  decl: []
  kind: token
  min: 12345
  pkg: ~
  re: !!perl/hash:RE_sequence
    a: 0
    dba: sublongname
    i: 0
    min: 12345
    r: 1
    s: 0
    zyg:
    - !!perl/hash:RE_method
      a: 0
      dba: sublongname
      i: 0
      min: 12345
      name: subshortname
      r: 1
      rest: ''
      s: 0
    - !!perl/hash:RE_quantified_atom
      atom: !!perl/hash:RE_method
        a: 0
        dba: sublongname
        i: 0
        min: 12345
        name: sigterm
        r: 1
        rest: ''
        s: 0
      min: 0
      quant:
      - '?'
      - ':'
      - ''
      - 0
subshortname: !!perl/hash:RE_ast
  decl: []
  kind: token
  min: 12345
  pkg: ~
  re: !!perl/hash:RE_bracket
    decl: []
    min: 12345
    re: &102 !!perl/hash:RE_any
      a: 0
      altname: subshortname_01
      dba: subshortname
      i: 0
      min: 12345
      name: subshortname_01
      r: 1
      s: 0
      zyg:
      - !!perl/hash:RE_sequence
        a: 0
        alt: subshortname_01 0
        dba: subshortname
        i: 0
        min: 12345
        r: 1
        s: 0
        zyg:
        - !!perl/hash:RE_method
          a: 0
          dba: subshortname
          i: 0
          min: 12345
          name: category
          r: 1
          rest: ''
          s: 0
        - !!perl/hash:RE_quantified_atom
          atom: !!perl/hash:RE_bracket
            decl: []
            min: 12345
            re: !!perl/hash:RE_sequence
              a: 0
              dba: subshortname
              i: 0
              min: 12345
              r: 1
              s: 0
              zyg:
              - !!perl/hash:RE_quantified_atom
                atom: !!perl/hash:RE_method
                  a: 0
                  dba: subshortname
                  i: 0
                  min: 12345
                  name: colonpair
                  r: 1
                  rest: ''
                  s: 0
                min: 12345
                quant:
                - +
                - ':'
                - ''
                - 1
              - !!perl/hash:RE_block
                a: 0
                context: void
                dba: subshortname
                i: 0
                min: 0
                r: 1
                s: 0
                text: ' $.add_macro($<category>) if $*IN_DECL; '
          min: 0
          quant:
          - '?'
          - ':'
          - ''
          - 0
      - !!perl/hash:RE_method
        a: 0
        alt: subshortname_01 1
        dba: subshortname
        i: 0
        min: 12345
        name: desigilname
        r: 1
        rest: ''
        s: 0
subshortname_01: *102
term__S_138fatarrow: !!perl/hash:RE_ast
  decl: []
  kind: token
  min: 12345
  pkg: ~
  re: !!perl/hash:RE_method
    a: 0
    dba: term__S_138fatarrow
    i: 0
    min: 12345
    name: fatarrow
    r: 1
    rest: ''
    s: 0
term__S_139variable: !!perl/hash:RE_ast
  decl: []
  kind: token
  min: 12345
  pkg: ~
  re: !!perl/hash:RE_sequence
    a: 0
    dba: term__S_139variable
    i: 0
    min: 12345
    r: 1
    s: 0
    zyg:
    - !!perl/hash:RE_method
      a: 0
      dba: term__S_139variable
      i: 0
      min: 12345
      name: variable
      r: 1
      rest: ''
      s: 0
    - !!perl/hash:RE_block
      a: 0
      context: void
      dba: term__S_139variable
      i: 0
      min: 0
      r: 1
      s: 0
      text: ' $*VAR = $<variable> '
term__S_140package_declarator: !!perl/hash:RE_ast
  decl: []
  kind: token
  min: 12345
  pkg: ~
  re: !!perl/hash:RE_method
    a: 0
    dba: term__S_140package_declarator
    i: 0
    min: 12345
    name: package_declarator
    r: 1
    rest: ''
    s: 0
term__S_141scope_declarator: !!perl/hash:RE_ast
  decl: []
  kind: token
  min: 12345
  pkg: ~
  re: !!perl/hash:RE_method
    a: 0
    dba: term__S_141scope_declarator
    i: 0
    min: 12345
    name: scope_declarator
    r: 1
    rest: ''
    s: 0
term__S_142multi_declarator: !!perl/hash:RE_ast
  decl: []
  kind: token
  min: 12345
  pkg: ~
  re: !!perl/hash:RE_sequence
    a: 0
    dba: term__S_142multi_declarator
    i: 0
    min: 12345
    r: 1
    s: 0
    zyg:
    - !!perl/hash:RE_assertion
      assert: '?'
      min: 0
      re: !!perl/hash:RE_method_re
        a: 0
        dba: term__S_142multi_declarator
        i: 0
        min: 0
        name: before
        nobind: 1
        r: 1
        re: !!perl/hash:RE_ast
          decl: []
          min: 4
          re: &103 !!perl/hash:RE_any
            a: 0
            altname: term__S_142multi_declarator_01
            dba: term__S_142multi_declarator
            i: 0
            min: 4
            name: term__S_142multi_declarator_01
            r: 1
            s: 0
            zyg:
            - !!perl/hash:RE_string
              a: 0
              alt: term__S_142multi_declarator_01 0
              dba: term__S_142multi_declarator
              i: 0
              min: 5
              r: 1
              s: 0
              text: multi
            - !!perl/hash:RE_string
              a: 0
              alt: term__S_142multi_declarator_01 1
              dba: term__S_142multi_declarator
              i: 0
              min: 5
              r: 1
              s: 0
              text: proto
            - !!perl/hash:RE_string
              a: 0
              alt: term__S_142multi_declarator_01 2
              dba: term__S_142multi_declarator
              i: 0
              min: 4
              r: 1
              s: 0
              text: only
        s: 0
    - !!perl/hash:RE_method
      a: 0
      dba: term__S_142multi_declarator
      i: 0
      min: 12345
      name: multi_declarator
      r: 1
      rest: ''
      s: 0
term__S_142multi_declarator_01: *103
term__S_143routine_declarator: !!perl/hash:RE_ast
  decl: []
  kind: token
  min: 12345
  pkg: ~
  re: !!perl/hash:RE_method
    a: 0
    dba: term__S_143routine_declarator
    i: 0
    min: 12345
    name: routine_declarator
    r: 1
    rest: ''
    s: 0
term__S_144regex_declarator: !!perl/hash:RE_ast
  decl: []
  kind: token
  min: 12345
  pkg: ~
  re: !!perl/hash:RE_method
    a: 0
    dba: term__S_144regex_declarator
    i: 0
    min: 12345
    name: regex_declarator
    r: 1
    rest: ''
    s: 0
term__S_145type_declarator: !!perl/hash:RE_ast
  decl: []
  kind: token
  min: 12345
  pkg: ~
  re: !!perl/hash:RE_method
    a: 0
    dba: term__S_145type_declarator
    i: 0
    min: 12345
    name: type_declarator
    r: 1
    rest: ''
    s: 0
term__S_146circumfix: !!perl/hash:RE_ast
  decl: []
  kind: token
  min: 12345
  pkg: ~
  re: !!perl/hash:RE_method
    a: 0
    dba: term__S_146circumfix
    i: 0
    min: 12345
    name: circumfix
    r: 1
    rest: ''
    s: 0
term__S_147dotty: !!perl/hash:RE_ast
  decl: []
  kind: token
  min: 12345
  pkg: ~
  re: !!perl/hash:RE_method
    a: 0
    dba: term__S_147dotty
    i: 0
    min: 12345
    name: dotty
    r: 1
    rest: ''
    s: 0
term__S_148value: !!perl/hash:RE_ast
  decl: []
  kind: token
  min: 12345
  pkg: ~
  re: !!perl/hash:RE_method
    a: 0
    dba: term__S_148value
    i: 0
    min: 12345
    name: value
    r: 1
    rest: ''
    s: 0
term__S_149capterm: !!perl/hash:RE_ast
  decl: []
  kind: token
  min: 12345
  pkg: ~
  re: !!perl/hash:RE_method
    a: 0
    dba: term__S_149capterm
    i: 0
    min: 12345
    name: capterm
    r: 1
    rest: ''
    s: 0
term__S_150sigterm: !!perl/hash:RE_ast
  decl: []
  kind: token
  min: 12345
  pkg: ~
  re: !!perl/hash:RE_method
    a: 0
    dba: term__S_150sigterm
    i: 0
    min: 12345
    name: sigterm
    r: 1
    rest: ''
    s: 0
term__S_151statement_prefix: !!perl/hash:RE_ast
  decl: []
  kind: token
  min: 12345
  pkg: ~
  re: !!perl/hash:RE_method
    a: 0
    dba: term__S_151statement_prefix
    i: 0
    min: 12345
    name: statement_prefix
    r: 1
    rest: ''
    s: 0
term__S_152colonpair: !!perl/hash:RE_ast
  decl: []
  kind: token
  min: 24690
  pkg: ~
  re: !!perl/hash:RE_quantified_atom
    atom: !!perl/hash:RE_bracket
      decl: []
      min: 24690
      re: !!perl/hash:RE_sequence
        a: 0
        dba: term__S_152colonpair
        i: 0
        min: 24690
        r: 1
        s: 0
        zyg:
        - !!perl/hash:RE_method
          a: 0
          dba: term__S_152colonpair
          i: 0
          min: 12345
          name: colonpair
          r: 1
          rest: ''
          s: 0
        - !!perl/hash:RE_method
          a: 0
          dba: term__S_152colonpair
          i: 0
          min: 12345
          name: ws
          nobind: 1
          r: 1
          rest: ''
          s: 0
    min: 24690
    quant:
    - +
    - ':'
    - ''
    - 1
term__S_240YOU_ARE_HERE: !!perl/hash:RE_ast
  decl: []
  kind: token
  min: 24690
  pkg: ~
  re: !!perl/hash:RE_sequence
    a: 0
    dba: term__S_240YOU_ARE_HERE
    i: 0
    min: 24690
    r: 1
    s: 0
    zyg:
    - !!perl/hash:RE_method
      a: 0
      dba: term__S_240YOU_ARE_HERE
      i: 0
      min: 12345
      name: sym
      r: 1
      rest: ''
      s: 0
      sym: YOU_ARE_HERE
    - !!perl/hash:RE_method
      a: 0
      dba: term__S_240YOU_ARE_HERE
      i: 0
      min: 12345
      name: you_are_here
      nobind: 1
      r: 1
      rest: ''
      s: 0
    - !!perl/hash:RE_method
      min: 0
      name: O
      rest: (|%term)
term__S_241new: !!perl/hash:RE_ast
  decl: []
  kind: token
  min: 12349
  pkg: ~
  re: !!perl/hash:RE_sequence
    a: 0
    dba: term__S_241new
    i: 0
    min: 12349
    r: 1
    s: 0
    zyg:
    - !!perl/hash:RE_string
      a: 0
      dba: term__S_241new
      i: 0
      min: 3
      r: 1
      s: 0
      text: new
    - !!perl/hash:RE_quantified_atom
      atom: !!perl/hash:RE_meta
        a: 0
        dba: term__S_241new
        i: 0
        min: 1
        r: 1
        s: 0
        text: \h
      min: 1
      quant:
      - +
      - ':'
      - ''
      - 1
    - !!perl/hash:RE_method
      a: 0
      dba: term__S_241new
      i: 0
      min: 12345
      name: longname
      r: 1
      rest: ''
      s: 0
    - !!perl/hash:RE_quantified_atom
      atom: !!perl/hash:RE_meta
        a: 0
        dba: term__S_241new
        i: 0
        min: 1
        r: 1
        s: 0
        text: \h
      min: 0
      quant:
      - '*'
      - ':'
      - ''
      - 0
    - !!perl/hash:RE_assertion
      assert: '!'
      min: 0
      re: !!perl/hash:RE_method_re
        a: 0
        dba: term__S_241new
        i: 0
        min: 0
        name: before
        nobind: 1
        r: 1
        re: !!perl/hash:RE_ast
          decl: []
          min: 1
          re: !!perl/hash:RE_string
            a: 0
            dba: term__S_241new
            i: 0
            min: 1
            r: 1
            s: 0
            text: ':'
        s: 0
    - !!perl/hash:RE_method
      min: 0
      name: obs
      nobind: 1
      rest: ("C++ constructor syntax", "method call syntax")
term__S_242ColonColonQuestionIDENT: !!perl/hash:RE_ast
  decl: []
  kind: token
  min: 12348
  pkg: ~
  re: !!perl/hash:RE_sequence
    a: 0
    dba: term__S_242ColonColonQuestionIDENT
    i: 0
    min: 12348
    r: 1
    s: 0
    zyg:
    - !!perl/hash:RE_bindnamed
      a: 0
      atom: !!perl/hash:RE_bracket
        decl: []
        min: 12348
        re: !!perl/hash:RE_sequence
          a: 0
          dba: term__S_242ColonColonQuestionIDENT
          i: 0
          min: 12348
          r: 1
          s: 0
          zyg:
          - !!perl/hash:RE_string
            a: 0
            dba: term__S_242ColonColonQuestionIDENT
            i: 0
            min: 3
            r: 1
            s: 0
            text: ::?
          - !!perl/hash:RE_method
            a: 0
            dba: term__S_242ColonColonQuestionIDENT
            i: 0
            min: 12345
            name: identifier
            r: 1
            rest: ''
            s: 0
      dba: term__S_242ColonColonQuestionIDENT
      i: 0
      min: 12348
      r: 1
      s: 0
      var: sym
    - !!perl/hash:RE_meta
      a: 0
      dba: term__S_242ColonColonQuestionIDENT
      i: 0
      min: 0
      r: 1
      s: 0
      text: 
    - !!perl/hash:RE_method
      min: 0
      name: O
      rest: (|%term)
term__S_243Object: !!perl/hash:RE_ast
  decl: []
  kind: token
  min: 12345
  pkg: ~
  re: !!perl/hash:RE_sequence
    a: 0
    dba: term__S_243Object
    i: 0
    min: 12345
    r: 1
    s: 0
    zyg:
    - !!perl/hash:RE_method
      a: 0
      dba: term__S_243Object
      i: 0
      min: 12345
      name: sym
      r: 1
      rest: ''
      s: 0
      sym: Object
    - !!perl/hash:RE_meta
      a: 0
      dba: term__S_243Object
      i: 0
      min: 0
      r: 1
      s: 0
      text: 
    - !!perl/hash:RE_block
      a: 0
      context: void
      dba: term__S_243Object
      i: 0
      min: 0
      r: 1
      s: 0
      text: ''
    - !!perl/hash:RE_method
      min: 0
      name: obs
      nobind: 1
      rest: ('Object', 'Mu as the "most universal" object type')
term__S_244undef: !!perl/hash:RE_ast
  decl: []
  kind: token
  min: 12345
  pkg: ~
  re: !!perl/hash:RE_sequence
    a: 0
    dba: term__S_244undef
    i: 0
    min: 12345
    r: 1
    s: 0
    zyg:
    - !!perl/hash:RE_method
      a: 0
      dba: term__S_244undef
      i: 0
      min: 12345
      name: sym
      r: 1
      rest: ''
      s: 0
      sym: undef
    - !!perl/hash:RE_meta
      a: 0
      dba: term__S_244undef
      i: 0
      min: 0
      r: 1
      s: 0
      text: 
    - !!perl/hash:RE_block
      a: 0
      context: void
      dba: term__S_244undef
      i: 0
      min: 0
      r: 1
      s: 0
      text: ''
    - !!perl/hash:RE_quantified_atom
      atom: !!perl/hash:RE_bracket
        decl: []
        min: 0
        re: !!perl/hash:RE_sequence
          a: 0
          dba: term__S_244undef
          i: 0
          min: 0
          r: 1
          s: 0
          zyg:
          - !!perl/hash:RE_assertion
            assert: '?'
            min: 0
            re: !!perl/hash:RE_method_re
              a: 0
              dba: term__S_244undef
              i: 0
              min: 0
              name: before
              nobind: 1
              r: 1
              re: !!perl/hash:RE_ast
                decl: []
                min: 2
                re: !!perl/hash:RE_sequence
                  a: 0
                  dba: term__S_244undef
                  i: 0
                  min: 2
                  r: 1
                  s: 0
                  zyg:
                  - !!perl/hash:RE_quantified_atom
                    atom: !!perl/hash:RE_meta
                      a: 0
                      dba: term__S_244undef
                      i: 0
                      min: 1
                      r: 1
                      s: 0
                      text: \h
                    min: 0
                    quant:
                    - '*'
                    - ':'
                    - ''
                    - 0
                  - !!perl/hash:RE_string
                    a: 0
                    dba: term__S_244undef
                    i: 0
                    min: 2
                    r: 1
                    s: 0
                    text: $/
              s: 0
          - !!perl/hash:RE_method
            min: 0
            name: obs
            nobind: 1
            rest: "('$/ variable as input record separator',\n                 \"the
              filehandle's .slurp method\")"
      min: 0
      quant:
      - '?'
      - ':'
      - ''
      - 0
    - !!perl/hash:RE_quantified_atom
      atom: !!perl/hash:RE_bracket
        decl: []
        min: 0
        re: !!perl/hash:RE_sequence
          a: 0
          dba: term__S_244undef
          i: 0
          min: 0
          r: 1
          s: 0
          zyg:
          - !!perl/hash:RE_assertion
            assert: '?'
            min: 0
            re: !!perl/hash:RE_method_re
              a: 0
              dba: term__S_244undef
              i: 0
              min: 0
              name: before
              nobind: 1
              r: 1
              re: !!perl/hash:RE_ast
                decl: []
                min: 1
                re: !!perl/hash:RE_bracket
                  decl: []
                  min: 1
                  re: !!perl/hash:RE_first
                    a: 0
                    dba: term__S_244undef
                    i: 0
                    min: 1
                    r: 1
                    s: 0
                    zyg:
                    - !!perl/hash:RE_string
                      a: 0
                      dba: term__S_244undef
                      i: 0
                      min: 1
                      r: 1
                      s: 0
                      text: (
                    - !!perl/hash:RE_sequence
                      a: 0
                      dba: term__S_244undef
                      i: 0
                      min: 12346
                      r: 1
                      s: 0
                      zyg:
                      - !!perl/hash:RE_quantified_atom
                        atom: !!perl/hash:RE_meta
                          a: 0
                          dba: term__S_244undef
                          i: 0
                          min: 1
                          r: 1
                          s: 0
                          text: \h
                        min: 0
                        quant:
                        - '*'
                        - ':'
                        - ''
                        - 0
                      - !!perl/hash:RE_method
                        a: 0
                        dba: term__S_244undef
                        i: 0
                        min: 12345
                        name: sigil
                        r: 1
                        rest: ''
                        s: 0
                      - !!perl/hash:RE_quantified_atom
                        atom: !!perl/hash:RE_method
                          a: 0
                          dba: term__S_244undef
                          i: 0
                          min: 12345
                          name: twigil
                          r: 1
                          rest: ''
                          s: 0
                        min: 0
                        quant:
                        - '?'
                        - ':'
                        - ''
                        - 0
                      - !!perl/hash:RE_meta
                        a: 0
                        dba: term__S_244undef
                        i: 0
                        min: 1
                        r: 1
                        s: 0
                        text: \w
              s: 0
          - !!perl/hash:RE_method
            min: 0
            name: obs
            nobind: 1
            rest: ('undef as a verb', 'undefine function or assignment of Nil')
      min: 0
      quant:
      - '?'
      - ':'
      - ''
      - 0
    - !!perl/hash:RE_method
      min: 0
      name: obs
      nobind: 1
      rest: ('undef as a value', "something more specific:\n\tMu (the \"most undefined\"
        type object),\n\tan undefined type object such as Int,\n\tNil as an empty
        list,\n\t:!defined as a matcher,\n\tAny:U as a type constraint\n\tor fail()
        as a failure return\n\t   ")
term__S_245proceed: !!perl/hash:RE_ast
  decl: []
  kind: token
  min: 12345
  pkg: ~
  re: !!perl/hash:RE_sequence
    a: 0
    dba: term__S_245proceed
    i: 0
    min: 12345
    r: 1
    s: 0
    zyg:
    - !!perl/hash:RE_method
      a: 0
      dba: term__S_245proceed
      i: 0
      min: 12345
      name: sym
      r: 1
      rest: ''
      s: 0
      sym: proceed
    - !!perl/hash:RE_meta
      a: 0
      dba: term__S_245proceed
      i: 0
      min: 0
      r: 1
      s: 0
      text: 
    - !!perl/hash:RE_method
      min: 0
      name: O
      rest: (|%term)
term__S_246self: !!perl/hash:RE_ast
  decl: []
  kind: token
  min: 12345
  pkg: ~
  re: !!perl/hash:RE_sequence
    a: 0
    dba: term__S_246self
    i: 0
    min: 12345
    r: 1
    s: 0
    zyg:
    - !!perl/hash:RE_method
      a: 0
      dba: term__S_246self
      i: 0
      min: 12345
      name: sym
      r: 1
      rest: ''
      s: 0
      sym: self
    - !!perl/hash:RE_meta
      a: 0
      dba: term__S_246self
      i: 0
      min: 0
      r: 1
      s: 0
      text: 
    - !!perl/hash:RE_method
      min: 0
      name: O
      rest: (|%term)
term__S_247defer: !!perl/hash:RE_ast
  decl: []
  kind: token
  min: 12345
  pkg: ~
  re: !!perl/hash:RE_sequence
    a: 0
    dba: term__S_247defer
    i: 0
    min: 12345
    r: 1
    s: 0
    zyg:
    - !!perl/hash:RE_method
      a: 0
      dba: term__S_247defer
      i: 0
      min: 12345
      name: sym
      r: 1
      rest: ''
      s: 0
      sym: defer
    - !!perl/hash:RE_meta
      a: 0
      dba: term__S_247defer
      i: 0
      min: 0
      r: 1
      s: 0
      text: 
    - !!perl/hash:RE_method
      min: 0
      name: O
      rest: (|%term)
term__S_248rand: !!perl/hash:RE_ast
  decl: []
  kind: token
  min: 12345
  pkg: ~
  re: !!perl/hash:RE_sequence
    a: 0
    dba: term__S_248rand
    i: 0
    min: 12345
    r: 1
    s: 0
    zyg:
    - !!perl/hash:RE_method
      a: 0
      dba: term__S_248rand
      i: 0
      min: 12345
      name: sym
      r: 1
      rest: ''
      s: 0
      sym: rand
    - !!perl/hash:RE_meta
      a: 0
      dba: term__S_248rand
      i: 0
      min: 0
      r: 1
      s: 0
      text: 
    - !!perl/hash:RE_quantified_atom
      atom: !!perl/hash:RE_bracket
        decl: []
        min: 0
        re: !!perl/hash:RE_sequence
          a: 0
          dba: term__S_248rand
          i: 0
          min: 0
          r: 1
          s: 0
          zyg:
          - !!perl/hash:RE_assertion
            assert: '?'
            min: 0
            re: !!perl/hash:RE_method_re
              a: 0
              dba: term__S_248rand
              i: 0
              min: 0
              name: before
              nobind: 1
              r: 1
              re: !!perl/hash:RE_ast
                decl: []
                min: 1
                re: !!perl/hash:RE_sequence
                  a: 0
                  dba: term__S_248rand
                  i: 0
                  min: 1
                  r: 1
                  s: 0
                  zyg:
                  - !!perl/hash:RE_quantified_atom
                    atom: !!perl/hash:RE_string
                      a: 0
                      dba: term__S_248rand
                      i: 0
                      min: 1
                      r: 1
                      s: 0
                      text: (
                    min: 0
                    quant:
                    - '?'
                    - ':'
                    - ''
                    - 0
                  - !!perl/hash:RE_quantified_atom
                    atom: !!perl/hash:RE_meta
                      a: 0
                      dba: term__S_248rand
                      i: 0
                      min: 1
                      r: 1
                      s: 0
                      text: \h
                    min: 0
                    quant:
                    - '*'
                    - ':'
                    - ''
                    - 0
                  - !!perl/hash:RE_bracket
                    decl: []
                    min: 1
                    re: &104 !!perl/hash:RE_any
                      a: 0
                      altname: term__S_248rand_03
                      dba: term__S_248rand
                      i: 0
                      min: 1
                      name: term__S_248rand_03
                      r: 1
                      s: 0
                      zyg:
                      - !!perl/hash:RE_meta
                        a: 0
                        alt: term__S_248rand_03 0
                        dba: term__S_248rand
                        i: 0
                        min: 1
                        r: 1
                        s: 0
                        text: \d
                      - !!perl/hash:RE_string
                        a: 0
                        alt: term__S_248rand_03 1
                        dba: term__S_248rand
                        i: 0
                        min: 1
                        r: 1
                        s: 0
                        text: $
              s: 0
          - !!perl/hash:RE_method
            min: 0
            name: obs
            nobind: 1
            rest: ('rand(N)', 'N.rand or (1..N).pick')
      min: 0
      quant:
      - '?'
      - ':'
      - ''
      - 0
    - !!perl/hash:RE_quantified_atom
      atom: !!perl/hash:RE_bracket
        decl: []
        min: 0
        re: !!perl/hash:RE_sequence
          a: 0
          dba: term__S_248rand
          i: 0
          min: 0
          r: 1
          s: 0
          zyg:
          - !!perl/hash:RE_assertion
            assert: '?'
            min: 0
            re: !!perl/hash:RE_method_re
              a: 0
              dba: term__S_248rand
              i: 0
              min: 0
              name: before
              nobind: 1
              r: 1
              re: !!perl/hash:RE_ast
                decl: []
                min: 2
                re: !!perl/hash:RE_string
                  a: 0
                  dba: term__S_248rand
                  i: 0
                  min: 2
                  r: 1
                  s: 0
                  text: ()
              s: 0
          - !!perl/hash:RE_method
            min: 0
            name: obs
            nobind: 1
            rest: ('rand()', 'rand')
      min: 0
      quant:
      - '?'
      - ':'
      - ''
      - 0
    - !!perl/hash:RE_method
      min: 0
      name: O
      rest: (|%term)
term__S_248rand_03: *104
term__S_249Star: !!perl/hash:RE_ast
  decl: []
  kind: token
  min: 12345
  pkg: ~
  re: !!perl/hash:RE_sequence
    a: 0
    dba: term__S_249Star
    i: 0
    min: 12345
    r: 1
    s: 0
    zyg:
    - !!perl/hash:RE_method
      a: 0
      dba: term__S_249Star
      i: 0
      min: 12345
      name: sym
      r: 1
      rest: ''
      s: 0
      sym: '*'
    - !!perl/hash:RE_method
      min: 0
      name: O
      rest: (|%term)
term__S_250StarStar: !!perl/hash:RE_ast
  decl: []
  kind: token
  min: 12345
  pkg: ~
  re: !!perl/hash:RE_sequence
    a: 0
    dba: term__S_250StarStar
    i: 0
    min: 12345
    r: 1
    s: 0
    zyg:
    - !!perl/hash:RE_method
      a: 0
      dba: term__S_250StarStar
      i: 0
      min: 12345
      name: sym
      r: 1
      rest: ''
      s: 0
      sym: '**'
    - !!perl/hash:RE_method
      min: 0
      name: O
      rest: (|%term)
term__S_274lambda: !!perl/hash:RE_ast
  decl: []
  kind: token
  min: 12345
  pkg: ~
  re: !!perl/hash:RE_sequence
    a: 0
    dba: term__S_274lambda
    i: 0
    min: 12345
    r: 1
    s: 0
    zyg:
    - !!perl/hash:RE_assertion
      assert: '?'
      min: 0
      re: !!perl/hash:RE_method_re
        a: 0
        dba: term__S_274lambda
        i: 0
        min: 0
        name: before
        nobind: 1
        r: 1
        re: !!perl/hash:RE_ast
          decl: []
          min: 12345
          re: !!perl/hash:RE_method
            a: 0
            dba: term__S_274lambda
            i: 0
            min: 12345
            name: lambda
            nobind: 1
            r: 1
            rest: ''
            s: 0
        s: 0
    - !!perl/hash:RE_method
      a: 0
      dba: term__S_274lambda
      i: 0
      min: 12345
      name: pblock
      r: 1
      rest: ''
      s: 0
    - !!perl/hash:RE_block
      a: 0
      context: void
      dba: term__S_274lambda
      i: 0
      min: 0
      r: 1
      s: 0
      text: "\n            if $*BORG {\n                $*BORG.<block> = $<pblock>;\n
        \           }\n        "
    - !!perl/hash:RE_method
      min: 0
      name: O
      rest: (|%term)
term__S_389DotDotDot: !!perl/hash:RE_ast
  decl: []
  kind: token
  min: 12345
  pkg: ~
  re: !!perl/hash:RE_sequence
    a: 0
    dba: term__S_389DotDotDot
    i: 0
    min: 12345
    r: 1
    s: 0
    zyg:
    - !!perl/hash:RE_method
      a: 0
      dba: term__S_389DotDotDot
      i: 0
      min: 12345
      name: sym
      r: 1
      rest: ''
      s: 0
      sym: '...'
    - !!perl/hash:RE_quantified_atom
      atom: !!perl/hash:RE_method
        a: 0
        dba: term__S_389DotDotDot
        i: 0
        min: 12345
        name: args
        r: 1
        rest: ''
        s: 0
      min: 0
      quant:
      - '?'
      - ':'
      - ''
      - 0
    - !!perl/hash:RE_method
      min: 0
      name: O
      rest: (|%list_prefix)
term__S_390QuestionQuestionQuestion: !!perl/hash:RE_ast
  decl: []
  kind: token
  min: 12345
  pkg: ~
  re: !!perl/hash:RE_sequence
    a: 0
    dba: term__S_390QuestionQuestionQuestion
    i: 0
    min: 12345
    r: 1
    s: 0
    zyg:
    - !!perl/hash:RE_method
      a: 0
      dba: term__S_390QuestionQuestionQuestion
      i: 0
      min: 12345
      name: sym
      r: 1
      rest: ''
      s: 0
      sym: ???
    - !!perl/hash:RE_quantified_atom
      atom: !!perl/hash:RE_method
        a: 0
        dba: term__S_390QuestionQuestionQuestion
        i: 0
        min: 12345
        name: args
        r: 1
        rest: ''
        s: 0
      min: 0
      quant:
      - '?'
      - ':'
      - ''
      - 0
    - !!perl/hash:RE_method
      min: 0
      name: O
      rest: (|%list_prefix)
term__S_391BangBangBang: !!perl/hash:RE_ast
  decl: []
  kind: token
  min: 12345
  pkg: ~
  re: !!perl/hash:RE_sequence
    a: 0
    dba: term__S_391BangBangBang
    i: 0
    min: 12345
    r: 1
    s: 0
    zyg:
    - !!perl/hash:RE_method
      a: 0
      dba: term__S_391BangBangBang
      i: 0
      min: 12345
      name: sym
      r: 1
      rest: ''
      s: 0
      sym: '!!!'
    - !!perl/hash:RE_quantified_atom
      atom: !!perl/hash:RE_method
        a: 0
        dba: term__S_391BangBangBang
        i: 0
        min: 12345
        name: args
        r: 1
        rest: ''
        s: 0
      min: 0
      quant:
      - '?'
      - ':'
      - ''
      - 0
    - !!perl/hash:RE_method
      min: 0
      name: O
      rest: (|%list_prefix)
term__S_392identifier: !!perl/hash:RE_ast
  decl:
  - !!perl/hash:RE_decl
    a: 0
    dba: term__S_392identifier
    i: 0
    max: 0
    min: 0
    r: 1
    s: 0
    text: my $name
  - !!perl/hash:RE_decl
    a: 0
    dba: term__S_392identifier
    i: 0
    max: 0
    min: 0
    r: 1
    s: 0
    text: my $pos
  kind: token
  min: 12345
  pkg: ~
  re: !!perl/hash:RE_sequence
    a: 0
    dba: term__S_392identifier
    i: 0
    min: 12345
    r: 1
    s: 0
    zyg:
    - !!perl/hash:RE_method
      a: 0
      dba: term__S_392identifier
      i: 0
      min: 12345
      name: identifier
      r: 1
      rest: ''
      s: 0
    - !!perl/hash:RE_assertion
      assert: '?'
      min: 0
      re: !!perl/hash:RE_method_re
        a: 0
        dba: term__S_392identifier
        i: 0
        min: 0
        name: before
        nobind: 1
        r: 1
        re: !!perl/hash:RE_ast
          decl: []
          min: 0
          re: !!perl/hash:RE_quantified_atom
            atom: !!perl/hash:RE_bracket
              decl: []
              min: 1
              re: &105 !!perl/hash:RE_any
                a: 0
                altname: term__S_392identifier_02
                dba: term__S_392identifier
                i: 0
                min: 1
                name: term__S_392identifier_02
                r: 1
                s: 0
                zyg:
                - !!perl/hash:RE_method
                  a: 0
                  alt: term__S_392identifier_02 0
                  dba: term__S_392identifier
                  i: 0
                  min: 12345
                  name: unsp
                  r: 1
                  rest: ''
                  s: 0
                - !!perl/hash:RE_string
                  a: 0
                  alt: term__S_392identifier_02 1
                  dba: term__S_392identifier
                  i: 0
                  min: 1
                  r: 1
                  s: 0
                  text: (
            min: 0
            quant:
            - '?'
            - ':'
            - ''
            - 0
        s: 0
    - !!perl/hash:RE_assertion
      assert: '!'
      min: 0
      re: !!perl/hash:RE_cclass
        a: 0
        dba: term__S_392identifier
        i: 0
        min: 1
        nobind: 1
        r: 1
        s: 0
        text: '[:]'
    - !!perl/hash:RE_block
      a: 0
      context: void
      dba: term__S_392identifier
      i: 0
      min: 0
      r: 1
      s: 0
      text: ' $name = $<identifier>.Str; $pos = $.pos; '
    - !!perl/hash:RE_method
      min: 0
      name: args
      rest: ( $.is_name($name) )
    - !!perl/hash:RE_block
      a: 0
      context: void
      dba: term__S_392identifier
      i: 0
      min: 0
      r: 1
      s: 0
      text: ' self.add_mystery($name,$pos,substr($*ORIG,$pos,1)) unless $<args><invocant>; '
    - !!perl/hash:RE_block
      a: 0
      context: void
      dba: term__S_392identifier
      i: 0
      min: 0
      r: 1
      s: 0
      text: "\n            if $*BORG and $*BORG.<block> {\n                if not
        $*BORG.<name> {\n                    $*BORG.<culprit> = $<identifier>.cursor($pos);\n
        \                   $*BORG.<name> = $name;\n                }\n            }\n
        \           if %deftrap{$name} {\n                my $al = $<args><arglist>[0];\n
        \               my $ok = 0;\n                $ok = 1 if $al and $al.from !=
        $al.to;\n                $ok = 1 if $<args><semiarglist>;\n                if
        not $ok {\n                    $<identifier>.worryobs(\"bare '$name'\", \".$name
        if you meant \\$_, or use an explicit invocant or argument\");\n                }\n
        \           }\n        "
    - !!perl/hash:RE_method
      min: 0
      name: O
      rest: (|%term)
term__S_392identifier_02: *105
term__S_393name: !!perl/hash:RE_ast
  decl:
  - !!perl/hash:RE_decl
    a: 0
    dba: term__S_393name
    i: 0
    max: 0
    min: 0
    r: 1
    s: 0
    text: my $name
  - !!perl/hash:RE_decl
    a: 0
    dba: term__S_393name
    i: 0
    max: 0
    min: 0
    r: 1
    s: 0
    text: my $pos
  kind: token
  min: 12345
  pkg: ~
  re: !!perl/hash:RE_sequence
    a: 0
    dba: term__S_393name
    i: 0
    min: 12345
    r: 1
    s: 0
    zyg:
    - !!perl/hash:RE_method
      a: 0
      dba: term__S_393name
      i: 0
      min: 12345
      name: longname
      r: 1
      rest: ''
      s: 0
    - !!perl/hash:RE_block
      a: 0
      context: void
      dba: term__S_393name
      i: 0
      min: 0
      r: 1
      s: 0
      text: "\n            $name = $<longname>.Str;\n            $pos = $.pos;\n
        \       "
    - !!perl/hash:RE_bracket
      decl: []
      min: 0
      re: !!perl/hash:RE_first
        a: 0
        dba: namespace variable lookup
        i: 0
        min: 0
        r: 1
        s: 0
        zyg:
        - !!perl/hash:RE_sequence
          a: 0
          dba: namespace variable lookup
          i: 0
          min: 0
          r: 1
          s: 0
          zyg:
          - !!perl/hash:RE_assertion
            assert: '?'
            min: 0
            re: !!perl/hash:RE_block
              a: 0
              context: bool
              dba: term__S_393name
              i: 0
              min: 0
              nobind: 1
              r: 1
              s: 0
              text: "\n                $.is_name($name) or substr($name,0,2) eq '::'\n
                \           "
          - !!perl/hash:RE_quantified_atom
            atom: !!perl/hash:RE_method
              a: 0
              dba: type parameter
              i: 0
              min: 12345
              name: unsp
              nobind: 1
              r: 1
              rest: ''
              s: 0
            min: 0
            quant:
            - '?'
            - ':'
            - ''
            - 0
          - !!perl/hash:RE_quantified_atom
            atom: !!perl/hash:RE_bracket
              decl: []
              min: 12345
              re: !!perl/hash:RE_sequence
                a: 0
                dba: type parameter
                i: 0
                min: 12345
                r: 1
                s: 0
                zyg:
                - !!perl/hash:RE_assertion
                  assert: '?'
                  min: 0
                  re: !!perl/hash:RE_method_re
                    a: 0
                    dba: type parameter
                    i: 0
                    min: 0
                    name: before
                    nobind: 1
                    r: 1
                    re: !!perl/hash:RE_ast
                      decl: []
                      min: 1
                      re: !!perl/hash:RE_string
                        a: 0
                        dba: type parameter
                        i: 0
                        min: 1
                        r: 1
                        s: 0
                        text: '['
                    s: 0
                - !!perl/hash:RE_method
                  a: 0
                  dba: type parameter
                  i: 0
                  min: 12345
                  name: postcircumfix
                  r: 1
                  rest: ''
                  s: 0
            min: 0
            quant:
            - '?'
            - ':'
            - ''
            - 0
          - !!perl/hash:RE_quantified_atom
            atom: !!perl/hash:RE_bracket
              decl: []
              min: 12345
              re: !!perl/hash:RE_sequence
                a: 0
                dba: namespace variable lookup
                i: 0
                min: 12345
                r: 1
                s: 0
                zyg:
                - !!perl/hash:RE_assertion
                  assert: '?'
                  min: 0
                  re: !!perl/hash:RE_method_re
                    a: 0
                    dba: namespace variable lookup
                    i: 0
                    min: 0
                    name: after
                    nobind: 1
                    r: 1
                    re: !!perl/hash:RE_ast
                      decl: []
                      min: 2
                      re: !!perl/hash:RE_string
                        a: 0
                        dba: namespace variable lookup
                        i: 0
                        min: 2
                        r: 1
                        s: 0
                        text: '::'
                    s: 0
                - !!perl/hash:RE_assertion
                  assert: '?'
                  min: 0
                  re: !!perl/hash:RE_method_re
                    a: 0
                    dba: namespace variable lookup
                    i: 0
                    min: 0
                    name: before
                    nobind: 1
                    r: 1
                    re: !!perl/hash:RE_ast
                      decl: []
                      min: 1
                      re: !!perl/hash:RE_bracket
                        decl: []
                        min: 1
                        re: &106 !!perl/hash:RE_any
                          a: 0
                          altname: term__S_393name_07
                          dba: namespace variable lookup
                          i: 0
                          min: 1
                          name: term__S_393name_07
                          r: 1
                          s: 0
                          zyg:
                          - !!perl/hash:RE_string
                            a: 0
                            alt: term__S_393name_07 0
                            dba: namespace variable lookup
                            i: 0
                            min: 1
                            r: 1
                            s: 0
                            text: 
                          - !!perl/hash:RE_string
                            a: 0
                            alt: term__S_393name_07 1
                            dba: namespace variable lookup
                            i: 0
                            min: 1
                            r: 1
                            s: 0
                            text: <
                          - !!perl/hash:RE_string
                            a: 0
                            alt: term__S_393name_07 2
                            dba: namespace variable lookup
                            i: 0
                            min: 1
                            r: 1
                            s: 0
                            text: '{'
                          - !!perl/hash:RE_string
                            a: 0
                            alt: term__S_393name_07 3
                            dba: namespace variable lookup
                            i: 0
                            min: 2
                            r: 1
                            s: 0
                            text: <<
                    s: 0
                - !!perl/hash:RE_method
                  a: 0
                  dba: namespace variable lookup
                  i: 0
                  min: 12345
                  name: postcircumfix
                  r: 1
                  rest: ''
                  s: 0
                - !!perl/hash:RE_block
                  a: 0
                  context: void
                  dba: namespace variable lookup
                  i: 0
                  min: 0
                  r: 1
                  s: 0
                  text: ' $*VAR = $.cursor_all(self.pos, $.pos) '
            min: 0
            quant:
            - '?'
            - ':'
            - ''
            - 0
        - !!perl/hash:RE_sequence
          a: 0
          dba: namespace variable lookup
          i: 0
          min: 12345
          r: 1
          s: 0
          zyg:
          - !!perl/hash:RE_method
            a: 0
            dba: namespace variable lookup
            i: 0
            min: 12345
            name: args
            r: 1
            rest: ''
            s: 0
          - !!perl/hash:RE_block
            a: 0
            context: void
            dba: namespace variable lookup
            i: 0
            min: 0
            r: 1
            s: 0
            text: ' self.add_mystery($name,$pos,''termish'') unless $<args><invocant>; '
          - !!perl/hash:RE_block
            a: 0
            context: void
            dba: namespace variable lookup
            i: 0
            min: 0
            r: 1
            s: 0
            text: "\n                if $*BORG and $*BORG.<block> {\n                    if
              not $*BORG.<name> {\n                        $*BORG.<culprit> = $<longname>.cursor($pos);\n
              \                       $*BORG.<name> //= $name;\n                    }\n
              \               }\n            "
    - !!perl/hash:RE_method
      min: 0
      name: O
      rest: (%term)
term__S_393name_07: *106
terminator__S_403Semi: !!perl/hash:RE_ast
  decl: []
  kind: token
  min: 1
  pkg: ~
  re: !!perl/hash:RE_sequence
    a: 0
    dba: terminator__S_403Semi
    i: 0
    min: 1
    r: 1
    s: 0
    zyg:
    - !!perl/hash:RE_string
      a: 0
      dba: terminator__S_403Semi
      i: 0
      min: 1
      r: 1
      s: 0
      text: ;
    - !!perl/hash:RE_method
      min: 0
      name: O
      rest: (|%terminator)
terminator__S_404if: !!perl/hash:RE_ast
  decl: []
  kind: token
  min: 12347
  pkg: ~
  re: !!perl/hash:RE_sequence
    a: 0
    dba: terminator__S_404if
    i: 0
    min: 12347
    r: 1
    s: 0
    zyg:
    - !!perl/hash:RE_string
      a: 0
      dba: terminator__S_404if
      i: 0
      min: 2
      r: 1
      s: 0
      text: if
    - !!perl/hash:RE_meta
      a: 0
      dba: terminator__S_404if
      i: 0
      min: 0
      r: 1
      s: 0
      text: 
    - !!perl/hash:RE_method
      a: 0
      dba: terminator__S_404if
      i: 0
      min: 12345
      name: nofun
      nobind: 1
      r: 1
      rest: ''
      s: 0
    - !!perl/hash:RE_method
      min: 0
      name: O
      rest: (|%terminator)
terminator__S_405unless: !!perl/hash:RE_ast
  decl: []
  kind: token
  min: 12351
  pkg: ~
  re: !!perl/hash:RE_sequence
    a: 0
    dba: terminator__S_405unless
    i: 0
    min: 12351
    r: 1
    s: 0
    zyg:
    - !!perl/hash:RE_string
      a: 0
      dba: terminator__S_405unless
      i: 0
      min: 6
      r: 1
      s: 0
      text: unless
    - !!perl/hash:RE_meta
      a: 0
      dba: terminator__S_405unless
      i: 0
      min: 0
      r: 1
      s: 0
      text: 
    - !!perl/hash:RE_method
      a: 0
      dba: terminator__S_405unless
      i: 0
      min: 12345
      name: nofun
      nobind: 1
      r: 1
      rest: ''
      s: 0
    - !!perl/hash:RE_method
      min: 0
      name: O
      rest: (|%terminator)
terminator__S_406while: !!perl/hash:RE_ast
  decl: []
  kind: token
  min: 12350
  pkg: ~
  re: !!perl/hash:RE_sequence
    a: 0
    dba: terminator__S_406while
    i: 0
    min: 12350
    r: 1
    s: 0
    zyg:
    - !!perl/hash:RE_string
      a: 0
      dba: terminator__S_406while
      i: 0
      min: 5
      r: 1
      s: 0
      text: while
    - !!perl/hash:RE_meta
      a: 0
      dba: terminator__S_406while
      i: 0
      min: 0
      r: 1
      s: 0
      text: 
    - !!perl/hash:RE_method
      a: 0
      dba: terminator__S_406while
      i: 0
      min: 12345
      name: nofun
      nobind: 1
      r: 1
      rest: ''
      s: 0
    - !!perl/hash:RE_method
      min: 0
      name: O
      rest: (|%terminator)
terminator__S_407until: !!perl/hash:RE_ast
  decl: []
  kind: token
  min: 12350
  pkg: ~
  re: !!perl/hash:RE_sequence
    a: 0
    dba: terminator__S_407until
    i: 0
    min: 12350
    r: 1
    s: 0
    zyg:
    - !!perl/hash:RE_string
      a: 0
      dba: terminator__S_407until
      i: 0
      min: 5
      r: 1
      s: 0
      text: until
    - !!perl/hash:RE_meta
      a: 0
      dba: terminator__S_407until
      i: 0
      min: 0
      r: 1
      s: 0
      text: 
    - !!perl/hash:RE_method
      a: 0
      dba: terminator__S_407until
      i: 0
      min: 12345
      name: nofun
      nobind: 1
      r: 1
      rest: ''
      s: 0
    - !!perl/hash:RE_method
      min: 0
      name: O
      rest: (|%terminator)
terminator__S_408for: !!perl/hash:RE_ast
  decl: []
  kind: token
  min: 12348
  pkg: ~
  re: !!perl/hash:RE_sequence
    a: 0
    dba: terminator__S_408for
    i: 0
    min: 12348
    r: 1
    s: 0
    zyg:
    - !!perl/hash:RE_string
      a: 0
      dba: terminator__S_408for
      i: 0
      min: 3
      r: 1
      s: 0
      text: for
    - !!perl/hash:RE_meta
      a: 0
      dba: terminator__S_408for
      i: 0
      min: 0
      r: 1
      s: 0
      text: 
    - !!perl/hash:RE_method
      a: 0
      dba: terminator__S_408for
      i: 0
      min: 12345
      name: nofun
      nobind: 1
      r: 1
      rest: ''
      s: 0
    - !!perl/hash:RE_method
      min: 0
      name: O
      rest: (|%terminator)
terminator__S_409given: !!perl/hash:RE_ast
  decl: []
  kind: token
  min: 12350
  pkg: ~
  re: !!perl/hash:RE_sequence
    a: 0
    dba: terminator__S_409given
    i: 0
    min: 12350
    r: 1
    s: 0
    zyg:
    - !!perl/hash:RE_string
      a: 0
      dba: terminator__S_409given
      i: 0
      min: 5
      r: 1
      s: 0
      text: given
    - !!perl/hash:RE_meta
      a: 0
      dba: terminator__S_409given
      i: 0
      min: 0
      r: 1
      s: 0
      text: 
    - !!perl/hash:RE_method
      a: 0
      dba: terminator__S_409given
      i: 0
      min: 12345
      name: nofun
      nobind: 1
      r: 1
      rest: ''
      s: 0
    - !!perl/hash:RE_method
      min: 0
      name: O
      rest: (|%terminator)
terminator__S_410when: !!perl/hash:RE_ast
  decl: []
  kind: token
  min: 12349
  pkg: ~
  re: !!perl/hash:RE_sequence
    a: 0
    dba: terminator__S_410when
    i: 0
    min: 12349
    r: 1
    s: 0
    zyg:
    - !!perl/hash:RE_string
      a: 0
      dba: terminator__S_410when
      i: 0
      min: 4
      r: 1
      s: 0
      text: when
    - !!perl/hash:RE_meta
      a: 0
      dba: terminator__S_410when
      i: 0
      min: 0
      r: 1
      s: 0
      text: 
    - !!perl/hash:RE_method
      a: 0
      dba: terminator__S_410when
      i: 0
      min: 12345
      name: nofun
      nobind: 1
      r: 1
      rest: ''
      s: 0
    - !!perl/hash:RE_method
      min: 0
      name: O
      rest: (|%terminator)
terminator__S_411MinusMinusGt: !!perl/hash:RE_ast
  decl: []
  kind: token
  min: 3
  pkg: ~
  re: !!perl/hash:RE_sequence
    a: 0
    dba: terminator__S_411MinusMinusGt
    i: 0
    min: 3
    r: 1
    s: 0
    zyg:
    - !!perl/hash:RE_string
      a: 0
      dba: terminator__S_411MinusMinusGt
      i: 0
      min: 3
      r: 1
      s: 0
      text: -->
    - !!perl/hash:RE_method
      min: 0
      name: O
      rest: (|%terminator)
terminator__S_412BangBang: !!perl/hash:RE_ast
  decl: []
  kind: token
  min: 2
  pkg: ~
  re: !!perl/hash:RE_sequence
    a: 0
    dba: terminator__S_412BangBang
    i: 0
    min: 2
    r: 1
    s: 0
    zyg:
    - !!perl/hash:RE_string
      a: 0
      dba: terminator__S_412BangBang
      i: 0
      min: 2
      r: 1
      s: 0
      text: '!!'
    - !!perl/hash:RE_assertion
      assert: '?'
      min: 0
      re: !!perl/hash:RE_block
        a: 0
        context: bool
        dba: terminator__S_412BangBang
        i: 0
        min: 0
        nobind: 1
        r: 1
        s: 0
        text: ' $*GOAL eq ''!!'' '
    - !!perl/hash:RE_method
      min: 0
      name: O
      rest: (|%terminator)
termish: !!perl/hash:RE_ast
  decl:
  - !!perl/hash:RE_decl
    a: 0
    dba: termish
    i: 0
    max: 0
    min: 0
    r: 1
    s: 0
    text: my $*SCOPE = ""
  - !!perl/hash:RE_decl
    a: 0
    dba: termish
    i: 0
    max: 0
    min: 0
    r: 1
    s: 0
    text: my $*OFTYPE
  - !!perl/hash:RE_decl
    a: 0
    dba: termish
    i: 0
    max: 0
    min: 0
    r: 1
    s: 0
    text: my $*VAR
  kind: token
  min: 12345
  pkg: ~
  re: !!perl/hash:RE_sequence
    a: 0
    dba: postfix
    i: 0
    min: 12345
    r: 1
    s: 0
    zyg:
    - !!perl/hash:RE_bracket
      decl: []
      min: 12345
      re: &107 !!perl/hash:RE_any
        a: 0
        altname: termish_01
        dba: prefix or term
        i: 0
        min: 12345
        name: termish_01
        r: 1
        s: 0
        zyg:
        - !!perl/hash:RE_sequence
          a: 0
          alt: termish_01 0
          dba: prefix or term
          i: 0
          min: 12345
          r: 1
          s: 0
          zyg:
          - !!perl/hash:RE_method
            a: 0
            dba: prefix or term
            i: 0
            min: 12345
            name: PRE
            r: 1
            rest: ''
            s: 0
          - !!perl/hash:RE_quantified_atom
            atom: !!perl/hash:RE_bracket
              decl: []
              min: 12345
              re: !!perl/hash:RE_sequence
                a: 0
                dba: prefix or term
                i: 0
                min: 12345
                r: 1
                s: 0
                zyg:
                - !!perl/hash:RE_assertion
                  assert: '!'
                  min: 0
                  re: !!perl/hash:RE_block
                    a: 0
                    context: bool
                    dba: prefix or term
                    i: 0
                    min: 0
                    nobind: 1
                    r: 1
                    s: 0
                    text: ' my $p = $<PRE>; my @p = @$p; @p[*-1]<O><term> and $<term>
                      = pop @$p '
                - !!perl/hash:RE_method
                  a: 0
                  dba: prefix or term
                  i: 0
                  min: 12345
                  name: PRE
                  r: 1
                  rest: ''
                  s: 0
            min: 0
            quant:
            - '*'
            - ':'
            - ''
            - 0
          - !!perl/hash:RE_bracket
            decl: []
            min: 0
            re: !!perl/hash:RE_first
              a: 0
              dba: prefix or term
              i: 0
              min: 0
              r: 1
              s: 0
              zyg:
              - !!perl/hash:RE_assertion
                assert: '?'
                min: 0
                re: !!perl/hash:RE_block
                  a: 0
                  context: bool
                  dba: prefix or term
                  i: 0
                  min: 0
                  nobind: 1
                  r: 1
                  s: 0
                  text: ' $<term> '
              - !!perl/hash:RE_method
                a: 0
                dba: prefix or term
                i: 0
                min: 12345
                name: term
                r: 1
                rest: ''
                s: 0
              - !!perl/hash:RE_method
                min: 0
                name: panic
                nobind: 1
                rest: ("Prefix requires an argument")
        - !!perl/hash:RE_method
          a: 0
          alt: termish_01 1
          dba: prefix or term
          i: 0
          min: 12345
          name: term
          r: 1
          rest: ''
          s: 0
    - !!perl/hash:RE_bracket
      decl: []
      min: 0
      re: !!perl/hash:RE_first
        a: 0
        dba: postfix
        i: 0
        min: 0
        r: 1
        s: 0
        zyg:
        - !!perl/hash:RE_sequence
          a: 0
          dba: postfix
          i: 0
          min: 0
          r: 1
          s: 0
          zyg:
          - !!perl/hash:RE_assertion
            assert: '?'
            min: 0
            re: !!perl/hash:RE_block
              a: 0
              context: bool
              dba: postfix
              i: 0
              min: 0
              nobind: 1
              r: 1
              s: 0
              text: ' $*QSIGIL '
          - !!perl/hash:RE_bracket
            decl: []
            min: 0
            re: !!perl/hash:RE_first
              a: 0
              dba: postfix
              i: 0
              min: 0
              r: 1
              s: 0
              zyg:
              - !!perl/hash:RE_sequence
                a: 0
                dba: postfix
                i: 0
                min: 0
                r: 1
                s: 0
                zyg:
                - !!perl/hash:RE_assertion
                  assert: '?'
                  min: 0
                  re: !!perl/hash:RE_block
                    a: 0
                    context: bool
                    dba: postfix
                    i: 0
                    min: 0
                    nobind: 1
                    r: 1
                    s: 0
                    text: ' $*QSIGIL eq ''$'' '
                - !!perl/hash:RE_quantified_atom
                  atom: !!perl/hash:RE_bracket
                    decl: []
                    min: 12345
                    re: !!perl/hash:RE_sequence
                      a: 0
                      dba: postfix
                      i: 0
                      min: 12345
                      r: 1
                      s: 0
                      zyg:
                      - !!perl/hash:RE_quantified_atom
                        atom: !!perl/hash:RE_method
                          a: 0
                          dba: postfix
                          i: 0
                          min: 12345
                          name: POST
                          r: 1
                          rest: ''
                          s: 0
                        min: 12345
                        quant:
                        - +
                        - '!'
                        - ''
                        - 1
                      - !!perl/hash:RE_assertion
                        assert: '?'
                        min: 0
                        re: !!perl/hash:RE_method_re
                          a: 0
                          dba: postfix
                          i: 0
                          min: 0
                          name: after
                          nobind: 1
                          r: 1
                          re: !!perl/hash:RE_ast
                            decl: []
                            min: 1
                            re: !!perl/hash:RE_cclass
                              a: 0
                              dba: postfix
                              i: 0
                              min: 1
                              r: 1
                              s: 0
                              text: '[ \] } > ) ]'
                          s: 0
                  min: 0
                  quant:
                  - '?'
                  - ':'
                  - ''
                  - 0
              - !!perl/hash:RE_sequence
                a: 0
                dba: postfix
                i: 0
                min: 12345
                r: 1
                s: 0
                zyg:
                - !!perl/hash:RE_quantified_atom
                  atom: !!perl/hash:RE_method
                    a: 0
                    dba: postfix
                    i: 0
                    min: 12345
                    name: POST
                    r: 1
                    rest: ''
                    s: 0
                  min: 12345
                  quant:
                  - +
                  - '!'
                  - ''
                  - 1
                - !!perl/hash:RE_assertion
                  assert: '?'
                  min: 0
                  re: !!perl/hash:RE_method_re
                    a: 0
                    dba: postfix
                    i: 0
                    min: 0
                    name: after
                    nobind: 1
                    r: 1
                    re: !!perl/hash:RE_ast
                      decl: []
                      min: 1
                      re: !!perl/hash:RE_cclass
                        a: 0
                        dba: postfix
                        i: 0
                        min: 1
                        r: 1
                        s: 0
                        text: '[ \] } > ) ]'
                    s: 0
              - !!perl/hash:RE_block
                a: 0
                context: void
                dba: postfix
                i: 0
                min: 0
                r: 1
                s: 0
                text: ' $*VAR = 0; '
        - !!perl/hash:RE_sequence
          a: 0
          dba: postfix
          i: 0
          min: 0
          r: 1
          s: 0
          zyg:
          - !!perl/hash:RE_assertion
            assert: '!'
            min: 0
            re: !!perl/hash:RE_block
              a: 0
              context: bool
              dba: postfix
              i: 0
              min: 0
              nobind: 1
              r: 1
              s: 0
              text: ' $*QSIGIL '
          - !!perl/hash:RE_quantified_atom
            atom: !!perl/hash:RE_method
              a: 0
              dba: postfix
              i: 0
              min: 12345
              name: POST
              r: 1
              rest: ''
              s: 0
            min: 0
            quant:
            - '*'
            - ':'
            - ''
            - 0
    - !!perl/hash:RE_block
      a: 0
      context: void
      dba: postfix
      i: 0
      min: 0
      r: 1
      s: 0
      text: "\n            self.check_variable($*VAR) if $*VAR;\n            $.<~CAPS>
        = $<term><~CAPS>;\n        "
termish_01: *107
trait: !!perl/hash:RE_ast
  decl:
  - !!perl/hash:RE_decl
    a: 0
    dba: trait
    i: 0
    max: 0
    min: 0
    r: 1
    s: 1
    text: my $*IN_DECL = 0
  kind: rule
  min: 12345
  pkg: ~
  re: !!perl/hash:RE_sequence
    a: 0
    dba: trait
    i: 0
    min: 12345
    r: 1
    s: 1
    zyg:
    - !!perl/hash:RE_method
      min: 0
      name: ws
      nobind: 1
      noquant: 1
      rest: ''
    - !!perl/hash:RE_bracket
      decl: []
      min: 12345
      re: &108 !!perl/hash:RE_any
        a: 0
        altname: trait_01
        dba: trait
        i: 0
        min: 12345
        name: trait_01
        r: 1
        s: 1
        zyg:
        - !!perl/hash:RE_sequence
          a: 0
          alt: trait_01 0
          dba: trait
          i: 0
          min: 12345
          r: 1
          s: 1
          zyg:
          - !!perl/hash:RE_method
            a: 0
            dba: trait
            i: 0
            min: 12345
            name: trait_mod
            r: 1
            rest: ''
            s: 1
          - !!perl/hash:RE_method
            min: 0
            name: ws
            nobind: 1
            noquant: 1
            rest: ''
        - !!perl/hash:RE_sequence
          a: 0
          alt: trait_01 1
          dba: trait
          i: 0
          min: 12345
          r: 1
          s: 1
          zyg:
          - !!perl/hash:RE_method
            a: 0
            dba: trait
            i: 0
            min: 12345
            name: colonpair
            r: 1
            rest: ''
            s: 1
          - !!perl/hash:RE_method
            min: 0
            name: ws
            nobind: 1
            noquant: 1
            rest: ''
    - !!perl/hash:RE_method
      min: 0
      name: ws
      nobind: 1
      noquant: 1
      rest: ''
trait_01: *108
trait_mod__S_131is: !!perl/hash:RE_ast
  decl: []
  kind: token
  min: 37035
  pkg: ~
  re: !!perl/hash:RE_sequence
    a: 0
    dba: trait_mod__S_131is
    i: 0
    min: 37035
    r: 1
    s: 1
    zyg:
    - !!perl/hash:RE_method
      a: 0
      dba: trait_mod__S_131is
      endsym: spacey
      i: 0
      min: 12345
      name: sym
      r: 1
      rest: ''
      s: 0
      sym: is
    - !!perl/hash:RE_method
      a: 0
      dba: trait_mod__S_131is
      i: 0
      min: 12345
      name: spacey
      nobind: 1
      r: 1
      rest: ''
      s: 0
    - !!perl/hash:RE_method
      min: 0
      name: ws
      nobind: 1
      noquant: 1
      rest: ''
    - !!perl/hash:RE_method
      a: 0
      dba: trait_mod__S_131is
      i: 0
      min: 12345
      name: longname
      r: 1
      rest: ''
      s: 1
    - !!perl/hash:RE_quantified_atom
      atom: !!perl/hash:RE_method
        a: 0
        dba: trait_mod__S_131is
        i: 0
        min: 12345
        name: circumfix
        r: 1
        rest: ''
        s: 1
      min: 0
      quant:
      - '?'
      - ':'
      - ''
      - 0
    - !!perl/hash:RE_method
      min: 0
      name: ws
      nobind: 1
      noquant: 1
      rest: ''
    - !!perl/hash:RE_block
      a: 0
      context: void
      dba: trait_mod__S_131is
      i: 0
      min: 0
      r: 1
      s: 1
      text: "\n            if $*DECLARAND {\n                my $traitname = $<longname>.Str;\n
        \               # XXX eventually will use multiple dispatch\n                $*DECLARAND{$traitname}
        = self.gettrait($traitname, $<circumfix>);\n            }\n        "
    - !!perl/hash:RE_method
      min: 0
      name: ws
      nobind: 1
      noquant: 1
      rest: ''
trait_mod__S_132hides: !!perl/hash:RE_ast
  decl: []
  kind: token
  min: 37035
  pkg: ~
  re: !!perl/hash:RE_sequence
    a: 0
    dba: trait_mod__S_132hides
    i: 0
    min: 37035
    r: 1
    s: 1
    zyg:
    - !!perl/hash:RE_method
      a: 0
      dba: trait_mod__S_132hides
      endsym: spacey
      i: 0
      min: 12345
      name: sym
      r: 1
      rest: ''
      s: 0
      sym: hides
    - !!perl/hash:RE_method
      a: 0
      dba: trait_mod__S_132hides
      i: 0
      min: 12345
      name: spacey
      nobind: 1
      r: 1
      rest: ''
      s: 0
    - !!perl/hash:RE_method
      min: 0
      name: ws
      nobind: 1
      noquant: 1
      rest: ''
    - !!perl/hash:RE_method
      a: 0
      dba: trait_mod__S_132hides
      i: 0
      min: 12345
      name: module_name
      r: 1
      rest: ''
      s: 1
    - !!perl/hash:RE_method
      min: 0
      name: ws
      nobind: 1
      noquant: 1
      rest: ''
trait_mod__S_133does: !!perl/hash:RE_ast
  decl:
  - !!perl/hash:RE_decl
    a: 0
    dba: trait_mod__S_133does
    i: 0
    max: 0
    min: 0
    r: 1
    s: 0
    text: my $*PKGDECL ::= 'role'
  kind: token
  min: 37035
  pkg: ~
  re: !!perl/hash:RE_sequence
    a: 0
    dba: trait_mod__S_133does
    i: 0
    min: 37035
    r: 1
    s: 1
    zyg:
    - !!perl/hash:RE_method
      a: 0
      dba: trait_mod__S_133does
      endsym: spacey
      i: 0
      min: 12345
      name: sym
      r: 1
      rest: ''
      s: 0
      sym: does
    - !!perl/hash:RE_method
      a: 0
      dba: trait_mod__S_133does
      i: 0
      min: 12345
      name: spacey
      nobind: 1
      r: 1
      rest: ''
      s: 0
    - !!perl/hash:RE_method
      min: 0
      name: ws
      nobind: 1
      noquant: 1
      rest: ''
    - !!perl/hash:RE_method
      a: 0
      dba: trait_mod__S_133does
      i: 0
      min: 12345
      name: module_name
      r: 1
      rest: ''
      s: 1
    - !!perl/hash:RE_method
      min: 0
      name: ws
      nobind: 1
      noquant: 1
      rest: ''
trait_mod__S_134will: !!perl/hash:RE_ast
  decl: []
  kind: token
  min: 49380
  pkg: ~
  re: !!perl/hash:RE_sequence
    a: 0
    dba: trait_mod__S_134will
    i: 0
    min: 49380
    r: 1
    s: 1
    zyg:
    - !!perl/hash:RE_method
      a: 0
      dba: trait_mod__S_134will
      endsym: spacey
      i: 0
      min: 12345
      name: sym
      r: 1
      rest: ''
      s: 0
      sym: will
    - !!perl/hash:RE_method
      a: 0
      dba: trait_mod__S_134will
      i: 0
      min: 12345
      name: spacey
      nobind: 1
      r: 1
      rest: ''
      s: 0
    - !!perl/hash:RE_method
      min: 0
      name: ws
      nobind: 1
      noquant: 1
      rest: ''
    - !!perl/hash:RE_method
      a: 0
      dba: trait_mod__S_134will
      i: 0
      min: 12345
      name: identifier
      r: 1
      rest: ''
      s: 1
    - !!perl/hash:RE_method
      min: 0
      name: ws
      nobind: 1
      noquant: 1
      rest: ''
    - !!perl/hash:RE_method
      a: 0
      dba: trait_mod__S_134will
      i: 0
      min: 12345
      name: pblock
      r: 1
      rest: ''
      s: 1
    - !!perl/hash:RE_method
      min: 0
      name: ws
      nobind: 1
      noquant: 1
      rest: ''
trait_mod__S_135of: !!perl/hash:RE_ast
  decl: []
  kind: token
  min: 12347
  pkg: ~
  re: !!perl/hash:RE_sequence
    a: 0
    dba: trait_mod__S_135of
    i: 0
    min: 12347
    r: 1
    s: 1
    zyg:
    - !!perl/hash:RE_bracket
      decl: []
      min: 2
      re: &109 !!perl/hash:RE_any
        a: 0
        altname: trait_mod__S_135of_01
        dba: trait_mod__S_135of
        i: 0
        min: 2
        name: trait_mod__S_135of_01
        r: 1
        s: 0
        zyg:
        - !!perl/hash:RE_string
          a: 0
          alt: trait_mod__S_135of_01 0
          dba: trait_mod__S_135of
          i: 0
          min: 2
          r: 1
          s: 0
          text: of
        - !!perl/hash:RE_string
          a: 0
          alt: trait_mod__S_135of_01 1
          dba: trait_mod__S_135of
          i: 0
          min: 7
          r: 1
          s: 0
          text: returns
    - !!perl/hash:RE_method
      min: 0
      name: ws
      nobind: 1
      noquant: 1
      rest: ''
    - !!perl/hash:RE_method
      a: 0
      dba: trait_mod__S_135of
      i: 0
      min: 12345
      name: typename
      r: 1
      rest: ''
      s: 1
    - !!perl/hash:RE_method
      min: 0
      name: ws
      nobind: 1
      noquant: 1
      rest: ''
    - !!perl/hash:RE_quantified_atom
      atom: !!perl/hash:RE_bracket
        decl: []
        min: 0
        re: !!perl/hash:RE_sequence
          a: 0
          dba: trait_mod__S_135of
          i: 0
          min: 0
          r: 1
          s: 1
          zyg:
          - !!perl/hash:RE_method
            min: 0
            name: ws
            nobind: 1
            noquant: 1
            rest: ''
          - !!perl/hash:RE_assertion
            assert: '?'
            min: 0
            re: !!perl/hash:RE_block
              a: 0
              context: bool
              dba: trait_mod__S_135of
              i: 0
              min: 0
              nobind: 1
              r: 1
              s: 1
              text: ' $*OFTYPE '
          - !!perl/hash:RE_method
            min: 0
            name: ws
            nobind: 1
            noquant: 1
            rest: ''
          - !!perl/hash:RE_method
            min: 0
            name: panic
            nobind: 1
            rest: ("Extra 'of' type; already declared as type " ~ $*OFTYPE.Str)
          - !!perl/hash:RE_method
            min: 0
            name: ws
            nobind: 1
            noquant: 1
            rest: ''
      min: 0
      quant:
      - '?'
      - ':'
      - ''
      - 0
    - !!perl/hash:RE_method
      min: 0
      name: ws
      nobind: 1
      noquant: 1
      rest: ''
    - !!perl/hash:RE_block
      a: 0
      context: void
      dba: trait_mod__S_135of
      i: 0
      min: 0
      r: 1
      s: 1
      text: ' $*OFTYPE = $<typename>; '
    - !!perl/hash:RE_method
      min: 0
      name: ws
      nobind: 1
      noquant: 1
      rest: ''
trait_mod__S_135of_01: *109
trait_mod__S_136as: !!perl/hash:RE_ast
  decl: []
  kind: token
  min: 37035
  pkg: ~
  re: !!perl/hash:RE_sequence
    a: 0
    dba: trait_mod__S_136as
    i: 0
    min: 37035
    r: 1
    s: 1
    zyg:
    - !!perl/hash:RE_method
      a: 0
      dba: trait_mod__S_136as
      endsym: spacey
      i: 0
      min: 12345
      name: sym
      r: 1
      rest: ''
      s: 0
      sym: as
    - !!perl/hash:RE_method
      a: 0
      dba: trait_mod__S_136as
      i: 0
      min: 12345
      name: spacey
      nobind: 1
      r: 1
      rest: ''
      s: 0
    - !!perl/hash:RE_method
      min: 0
      name: ws
      nobind: 1
      noquant: 1
      rest: ''
    - !!perl/hash:RE_method
      a: 0
      dba: trait_mod__S_136as
      i: 0
      min: 12345
      name: typename
      r: 1
      rest: ''
      s: 1
    - !!perl/hash:RE_method
      min: 0
      name: ws
      nobind: 1
      noquant: 1
      rest: ''
trait_mod__S_137handles: !!perl/hash:RE_ast
  decl: []
  kind: token
  min: 37035
  pkg: ~
  re: !!perl/hash:RE_sequence
    a: 0
    dba: trait_mod__S_137handles
    i: 0
    min: 37035
    r: 1
    s: 1
    zyg:
    - !!perl/hash:RE_method
      a: 0
      dba: trait_mod__S_137handles
      endsym: spacey
      i: 0
      min: 12345
      name: sym
      r: 1
      rest: ''
      s: 0
      sym: handles
    - !!perl/hash:RE_method
      a: 0
      dba: trait_mod__S_137handles
      i: 0
      min: 12345
      name: spacey
      nobind: 1
      r: 1
      rest: ''
      s: 0
    - !!perl/hash:RE_method
      min: 0
      name: ws
      nobind: 1
      noquant: 1
      rest: ''
    - !!perl/hash:RE_method
      a: 0
      dba: trait_mod__S_137handles
      i: 0
      min: 12345
      name: term
      r: 1
      rest: ''
      s: 1
    - !!perl/hash:RE_method
      min: 0
      name: ws
      nobind: 1
      noquant: 1
      rest: ''
tribble: !!perl/hash:RE_ast
  decl:
  - !!perl/hash:RE_decl
    a: 0
    dba: tribble
    i: 0
    max: 0
    min: 0
    r: 1
    s: 0
    text: my ($lang, $start, $stop)
  kind: token
  min: 0
  pkg: ~
  re: !!perl/hash:RE_sequence
    a: 0
    dba: tribble
    i: 0
    min: 0
    r: 1
    s: 0
    zyg:
    - !!perl/hash:RE_method
      min: 0
      name: babble
      rest: ($l)
    - !!perl/hash:RE_block
      a: 0
      context: void
      dba: tribble
      i: 0
      min: 0
      r: 1
      s: 0
      text: ' my $B = $<babble><B>; ($lang,$start,$stop) = @$B; '
    - !!perl/hash:RE_var
      a: 0
      dba: tribble
      i: 0
      min: 0
      r: 1
      s: 0
      var: $start
    - !!perl/hash:RE_bindnamed
      a: 0
      atom: !!perl/hash:RE_method
        min: 0
        name: nibble
        nobind: 1
        rest: ($lang)
      dba: tribble
      i: 0
      min: 0
      r: 1
      s: 0
      var: left
    - !!perl/hash:RE_bracket
      decl: []
      min: 0
      re: !!perl/hash:RE_first
        a: 0
        dba: tribble
        i: 0
        min: 0
        r: 1
        s: 0
        zyg:
        - !!perl/hash:RE_var
          a: 0
          dba: tribble
          i: 0
          min: 0
          r: 1
          s: 0
          var: $stop
        - !!perl/hash:RE_method
          min: 0
          name: panic
          nobind: 1
          rest: ("Couldn't find terminator $stop")
    - !!perl/hash:RE_bracket
      decl: []
      min: 0
      re: !!perl/hash:RE_first
        a: 0
        dba: tribble
        i: 0
        min: 0
        r: 1
        s: 0
        zyg:
        - !!perl/hash:RE_sequence
          a: 0
          dba: tribble
          i: 0
          min: 12345
          r: 1
          s: 0
          zyg:
          - !!perl/hash:RE_assertion
            assert: '?'
            min: 0
            re: !!perl/hash:RE_block
              a: 0
              context: bool
              dba: tribble
              i: 0
              min: 0
              nobind: 1
              r: 1
              s: 0
              text: ' $start ne $stop '
          - !!perl/hash:RE_method
            a: 0
            dba: tribble
            i: 0
            min: 12345
            name: ws
            nobind: 1
            r: 1
            rest: ''
            s: 0
          - !!perl/hash:RE_method
            min: 0
            name: quibble
            rest: ($lang2)
        - !!perl/hash:RE_sequence
          a: 0
          dba: tribble
          i: 0
          min: 0
          r: 1
          s: 0
          zyg:
          - !!perl/hash:RE_block
            a: 0
            context: void
            dba: tribble
            i: 0
            min: 0
            r: 1
            s: 0
            text: ' $lang = $lang2.unbalanced($stop); '
          - !!perl/hash:RE_bindnamed
            a: 0
            atom: !!perl/hash:RE_method
              min: 0
              name: nibble
              nobind: 1
              rest: ($lang)
            dba: tribble
            i: 0
            min: 0
            r: 1
            s: 0
            var: right
          - !!perl/hash:RE_var
            a: 0
            dba: tribble
            i: 0
            min: 0
            r: 1
            s: 0
            var: $stop
type_constraint: !!perl/hash:RE_ast
  decl:
  - !!perl/hash:RE_decl
    a: 0
    dba: type_constraint
    i: 0
    max: 0
    min: 0
    r: 1
    s: 0
    text: my $*IN_DECL = ''
  kind: token
  min: 24690
  pkg: ~
  re: !!perl/hash:RE_sequence
    a: 0
    dba: type_constraint
    i: 0
    min: 24690
    r: 1
    s: 0
    zyg:
    - !!perl/hash:RE_bracket
      decl: []
      min: 12345
      re: &110 !!perl/hash:RE_any
        a: 0
        altname: type_constraint_01
        dba: type_constraint
        i: 0
        min: 12345
        name: type_constraint_01
        r: 1
        s: 0
        zyg:
        - !!perl/hash:RE_method
          a: 0
          alt: type_constraint_01 0
          dba: type_constraint
          i: 0
          min: 12345
          name: value
          r: 1
          rest: ''
          s: 0
        - !!perl/hash:RE_method
          a: 0
          alt: type_constraint_01 1
          dba: type_constraint
          i: 0
          min: 12345
          name: typename
          r: 1
          rest: ''
          s: 0
        - !!perl/hash:RE_sequence
          a: 0
          alt: type_constraint_01 2
          dba: type_constraint
          i: 0
          min: 12350
          r: 1
          s: 0
          zyg:
          - !!perl/hash:RE_string
            a: 0
            dba: type_constraint
            i: 0
            min: 5
            r: 1
            s: 0
            text: where
          - !!perl/hash:RE_method
            a: 0
            dba: type_constraint
            i: 0
            min: 12345
            name: ws
            nobind: 1
            r: 1
            rest: ''
            s: 0
          - !!perl/hash:RE_method
            min: 0
            name: EXPR
            rest: (item %chaining)
    - !!perl/hash:RE_method
      a: 0
      dba: type_constraint
      i: 0
      min: 12345
      name: ws
      nobind: 1
      r: 1
      rest: ''
      s: 0
type_constraint_01: *110
type_declarator__S_227subset: !!perl/hash:RE_ast
  decl:
  - !!perl/hash:RE_decl
    a: 0
    dba: type_declarator__S_227subset
    i: 0
    max: 0
    min: 0
    r: 1
    s: 0
    text: my $*IN_DECL = 'subset'
  - !!perl/hash:RE_decl
    a: 0
    dba: type_declarator__S_227subset
    i: 0
    max: 0
    min: 0
    r: 1
    s: 0
    text: my $*DECLARAND
  kind: token
  min: 0
  pkg: ~
  re: !!perl/hash:RE_first
    a: 0
    dba: type_declarator__S_227subset
    i: 0
    min: 0
    r: 1
    s: 1
    zyg:
    - !!perl/hash:RE_sequence
      a: 0
      dba: type_declarator__S_227subset
      i: 0
      min: 24690
      r: 1
      s: 1
      zyg:
      - !!perl/hash:RE_method
        a: 0
        dba: type_declarator__S_227subset
        endsym: spacey
        i: 0
        min: 12345
        name: sym
        r: 1
        rest: ''
        s: 0
        sym: subset
      - !!perl/hash:RE_method
        a: 0
        dba: type_declarator__S_227subset
        i: 0
        min: 12345
        name: spacey
        nobind: 1
        r: 1
        rest: ''
        s: 0
      - !!perl/hash:RE_method
        min: 0
        name: ws
        nobind: 1
        noquant: 1
        rest: ''
      - !!perl/hash:RE_bracket
        decl: []
        min: 0
        re: !!perl/hash:RE_sequence
          a: 0
          dba: type_declarator__S_227subset
          i: 0
          min: 0
          r: 1
          s: 1
          zyg:
          - !!perl/hash:RE_quantified_atom
            atom: !!perl/hash:RE_bracket
              decl: []
              min: 12345
              re: !!perl/hash:RE_sequence
                a: 0
                dba: type_declarator__S_227subset
                i: 0
                min: 12345
                r: 1
                s: 1
                zyg:
                - !!perl/hash:RE_method
                  min: 0
                  name: ws
                  nobind: 1
                  noquant: 1
                  rest: ''
                - !!perl/hash:RE_method
                  a: 0
                  dba: type_declarator__S_227subset
                  i: 0
                  min: 12345
                  name: longname
                  r: 1
                  rest: ''
                  s: 1
                - !!perl/hash:RE_method
                  min: 0
                  name: ws
                  nobind: 1
                  noquant: 1
                  rest: ''
                - !!perl/hash:RE_block
                  a: 0
                  context: void
                  dba: type_declarator__S_227subset
                  i: 0
                  min: 0
                  r: 1
                  s: 1
                  text: ' $.add_name($<longname>[0].Str); '
                - !!perl/hash:RE_method
                  min: 0
                  name: ws
                  nobind: 1
                  noquant: 1
                  rest: ''
            min: 0
            quant:
            - '?'
            - ':'
            - ''
            - 0
          - !!perl/hash:RE_method
            min: 0
            name: ws
            nobind: 1
            noquant: 1
            rest: ''
          - !!perl/hash:RE_quantified_atom
            atom: !!perl/hash:RE_method
              a: 0
              dba: type_declarator__S_227subset
              i: 0
              min: 12345
              name: trait
              r: 1
              rest: ''
              s: 1
            min: 0
            quant:
            - '*'
            - ':'
            - ''
            - 0
          - !!perl/hash:RE_method
            min: 0
            name: ws
            nobind: 1
            noquant: 1
            rest: ''
          - !!perl/hash:RE_quantified_atom
            atom: !!perl/hash:RE_bracket
              decl: []
              min: 5
              re: !!perl/hash:RE_sequence
                a: 0
                dba: type_declarator__S_227subset
                i: 0
                min: 5
                r: 1
                s: 1
                zyg:
                - !!perl/hash:RE_string
                  a: 0
                  dba: type_declarator__S_227subset
                  i: 0
                  min: 5
                  r: 1
                  s: 1
                  text: where
                - !!perl/hash:RE_method
                  min: 0
                  name: ws
                  nobind: 1
                  noquant: 1
                  rest: ''
                - !!perl/hash:RE_method
                  min: 0
                  name: EXPR
                  rest: (item %chaining)
                - !!perl/hash:RE_method
                  min: 0
                  name: ws
                  nobind: 1
                  noquant: 1
                  rest: ''
            min: 0
            quant:
            - '?'
            - ':'
            - ''
            - 0
          - !!perl/hash:RE_method
            min: 0
            name: ws
            nobind: 1
            noquant: 1
            rest: ''
      - !!perl/hash:RE_method
        min: 0
        name: ws
        nobind: 1
        noquant: 1
        rest: ''
    - !!perl/hash:RE_sequence
      a: 0
      dba: type_declarator__S_227subset
      i: 0
      min: 0
      r: 1
      s: 1
      zyg:
      - !!perl/hash:RE_method
        min: 0
        name: ws
        nobind: 1
        noquant: 1
        rest: ''
      - !!perl/hash:RE_method
        min: 0
        name: panic
        nobind: 1
        rest: ("Malformed subset")
      - !!perl/hash:RE_method
        min: 0
        name: ws
        nobind: 1
        noquant: 1
        rest: ''
type_declarator__S_228enum: !!perl/hash:RE_ast
  decl:
  - !!perl/hash:RE_decl
    a: 0
    dba: type_declarator__S_228enum
    i: 0
    max: 0
    min: 0
    r: 1
    s: 0
    text: my $*IN_DECL = 'enum'
  - !!perl/hash:RE_decl
    a: 0
    dba: type_declarator__S_228enum
    i: 0
    max: 0
    min: 0
    r: 1
    s: 0
    text: my $*DECLARAND
  kind: token
  min: 61725
  pkg: ~
  re: !!perl/hash:RE_sequence
    a: 0
    dba: type_declarator__S_228enum
    i: 0
    min: 61725
    r: 1
    s: 0
    zyg:
    - !!perl/hash:RE_method
      a: 0
      dba: type_declarator__S_228enum
      endsym: spacey
      i: 0
      min: 12345
      name: sym
      r: 1
      rest: ''
      s: 0
      sym: enum
    - !!perl/hash:RE_method
      a: 0
      dba: type_declarator__S_228enum
      i: 0
      min: 12345
      name: spacey
      nobind: 1
      r: 1
      rest: ''
      s: 0
    - !!perl/hash:RE_method
      a: 0
      dba: type_declarator__S_228enum
      i: 0
      min: 12345
      name: ws
      nobind: 1
      r: 1
      rest: ''
      s: 0
    - !!perl/hash:RE_quantified_atom
      atom: !!perl/hash:RE_bracket
        decl: []
        min: 24690
        re: !!perl/hash:RE_sequence
          a: 0
          dba: type_declarator__S_228enum
          i: 0
          min: 24690
          r: 1
          s: 0
          zyg:
          - !!perl/hash:RE_method
            a: 0
            dba: type_declarator__S_228enum
            i: 0
            min: 12345
            name: longname
            r: 1
            rest: ''
            s: 0
          - !!perl/hash:RE_block
            a: 0
            context: void
            dba: type_declarator__S_228enum
            i: 0
            min: 0
            r: 1
            s: 0
            text: ' $.add_name($<longname>[0].Str); '
          - !!perl/hash:RE_method
            a: 0
            dba: type_declarator__S_228enum
            i: 0
            min: 12345
            name: ws
            nobind: 1
            r: 1
            rest: ''
            s: 0
      min: 0
      quant:
      - '?'
      - ':'
      - ''
      - 0
    - !!perl/hash:RE_quantified_atom
      atom: !!perl/hash:RE_method
        a: 0
        dba: type_declarator__S_228enum
        i: 0
        min: 12345
        name: trait
        r: 1
        rest: ''
        s: 0
      min: 0
      quant:
      - '*'
      - ':'
      - ''
      - 0
    - !!perl/hash:RE_assertion
      assert: '?'
      min: 0
      re: !!perl/hash:RE_method_re
        a: 0
        dba: type_declarator__S_228enum
        i: 0
        min: 0
        name: before
        nobind: 1
        r: 1
        re: !!perl/hash:RE_ast
          decl: []
          min: 1
          re: !!perl/hash:RE_cclass
            a: 0
            dba: type_declarator__S_228enum
            i: 0
            min: 1
            r: 1
            s: 0
            text: '[ < (  ]'
        s: 0
    - !!perl/hash:RE_method
      a: 0
      dba: type_declarator__S_228enum
      i: 0
      min: 12345
      name: term
      r: 1
      rest: ''
      s: 0
    - !!perl/hash:RE_method
      a: 0
      dba: type_declarator__S_228enum
      i: 0
      min: 12345
      name: ws
      nobind: 1
      r: 1
      rest: ''
      s: 0
    - !!perl/hash:RE_block
      a: 0
      context: void
      dba: type_declarator__S_228enum
      i: 0
      min: 0
      r: 1
      s: 0
      text: '$.add_enum($<longname>, $<term>.Str); '
type_declarator__S_229constant: !!perl/hash:RE_ast
  decl:
  - !!perl/hash:RE_decl
    a: 0
    dba: type_declarator__S_229constant
    i: 0
    max: 0
    min: 0
    r: 1
    s: 0
    text: my $*IN_DECL = 'constant'
  - !!perl/hash:RE_decl
    a: 0
    dba: type_declarator__S_229constant
    i: 0
    max: 0
    min: 0
    r: 1
    s: 0
    text: my $*DECLARAND
  kind: token
  min: 61725
  pkg: ~
  re: !!perl/hash:RE_sequence
    a: 0
    dba: type_declarator__S_229constant
    i: 0
    min: 61725
    r: 1
    s: 0
    zyg:
    - !!perl/hash:RE_method
      a: 0
      dba: type_declarator__S_229constant
      endsym: spacey
      i: 0
      min: 12345
      name: sym
      r: 1
      rest: ''
      s: 0
      sym: constant
    - !!perl/hash:RE_method
      a: 0
      dba: type_declarator__S_229constant
      i: 0
      min: 12345
      name: spacey
      nobind: 1
      r: 1
      rest: ''
      s: 0
    - !!perl/hash:RE_method
      a: 0
      dba: type_declarator__S_229constant
      i: 0
      min: 12345
      name: ws
      nobind: 1
      r: 1
      rest: ''
      s: 0
    - !!perl/hash:RE_bracket
      decl: []
      min: 0
      re: &111 !!perl/hash:RE_any
        a: 0
        altname: type_declarator__S_229constant_01
        dba: type_declarator__S_229constant
        i: 0
        min: 0
        name: type_declarator__S_229constant_01
        r: 1
        s: 0
        zyg:
        - !!perl/hash:RE_sequence
          a: 0
          alt: type_declarator__S_229constant_01 0
          dba: type_declarator__S_229constant
          i: 0
          min: 12345
          r: 1
          s: 0
          zyg:
          - !!perl/hash:RE_method
            a: 0
            dba: type_declarator__S_229constant
            i: 0
            min: 12345
            name: identifier
            r: 1
            rest: ''
            s: 0
          - !!perl/hash:RE_block
            a: 0
            context: void
            dba: type_declarator__S_229constant
            i: 0
            min: 0
            r: 1
            s: 0
            text: ' $.add_name($<identifier>.Str); '
        - !!perl/hash:RE_sequence
          a: 0
          alt: type_declarator__S_229constant_01 1
          dba: type_declarator__S_229constant
          i: 0
          min: 12345
          r: 1
          s: 0
          zyg:
          - !!perl/hash:RE_method
            a: 0
            dba: type_declarator__S_229constant
            i: 0
            min: 12345
            name: variable
            r: 1
            rest: ''
            s: 0
          - !!perl/hash:RE_block
            a: 0
            context: void
            dba: type_declarator__S_229constant
            i: 0
            min: 0
            r: 1
            s: 0
            text: ' $.add_variable($<variable>.Str); '
        - !!perl/hash:RE_assertion
          alt: type_declarator__S_229constant_01 2
          assert: '?'
          min: 0
          re: !!perl/hash:RE_noop
            a: 0
            dba: type_declarator__S_229constant
            i: 0
            min: 0
            nobind: 1
            r: 1
            s: 0
    - !!perl/hash:RE_block
      a: 0
      context: void
      dba: type_declarator__S_229constant
      i: 0
      min: 0
      r: 1
      s: 0
      text: ' $*IN_DECL = ''''; '
    - !!perl/hash:RE_method
      a: 0
      dba: type_declarator__S_229constant
      i: 0
      min: 12345
      name: ws
      nobind: 1
      r: 1
      rest: ''
      s: 0
    - !!perl/hash:RE_quantified_atom
      atom: !!perl/hash:RE_method
        a: 0
        dba: type_declarator__S_229constant
        i: 0
        min: 12345
        name: trait
        r: 1
        rest: ''
        s: 0
      min: 0
      quant:
      - '*'
      - ':'
      - ''
      - 0
    - !!perl/hash:RE_bracket
      decl: []
      min: 0
      re: !!perl/hash:RE_first
        a: 0
        dba: type_declarator__S_229constant
        i: 0
        min: 0
        r: 1
        s: 0
        zyg:
        - !!perl/hash:RE_assertion
          assert: '?'
          min: 0
          re: !!perl/hash:RE_method_re
            a: 0
            dba: type_declarator__S_229constant
            i: 0
            min: 0
            name: before
            nobind: 1
            r: 1
            re: !!perl/hash:RE_ast
              decl: []
              min: 1
              re: !!perl/hash:RE_string
                a: 0
                dba: type_declarator__S_229constant
                i: 0
                min: 1
                r: 1
                s: 0
                text: =
            s: 0
        - !!perl/hash:RE_sequence
          a: 0
          dba: type_declarator__S_229constant
          i: 0
          min: 0
          r: 1
          s: 0
          zyg:
          - !!perl/hash:RE_assertion
            assert: '?'
            min: 0
            re: !!perl/hash:RE_method_re
              a: 0
              dba: type_declarator__S_229constant
              i: 0
              min: 0
              name: before
              nobind: 1
              r: 1
              re: !!perl/hash:RE_ast
                decl: []
                min: 1
                re: !!perl/hash:RE_sequence
                  a: 0
                  dba: type_declarator__S_229constant
                  i: 0
                  min: 1
                  r: 1
                  s: 0
                  zyg:
                  - !!perl/hash:RE_quantified_atom
                    atom: !!perl/hash:RE_cclass
                      a: 0
                      dba: type_declarator__S_229constant
                      i: 0
                      min: 1
                      r: 1
                      s: 0
                      text: -[\n=]
                    min: 0
                    quant:
                    - '*'
                    - ':'
                    - ''
                    - 0
                  - !!perl/hash:RE_string
                    a: 0
                    dba: type_declarator__S_229constant
                    i: 0
                    min: 1
                    r: 1
                    s: 0
                    text: =
              s: 0
          - !!perl/hash:RE_method
            min: 0
            name: panic
            nobind: 1
            rest: ("Malformed constant")
        - !!perl/hash:RE_method
          min: 0
          name: panic
          nobind: 1
          rest: ("Missing initializer on constant declaration")
    - !!perl/hash:RE_method
      a: 0
      dba: type_declarator__S_229constant
      i: 0
      min: 12345
      name: getdecl
      nobind: 1
      r: 1
      rest: ''
      s: 0
type_declarator__S_229constant_01: *111
typename: !!perl/hash:RE_ast
  decl: []
  kind: token
  min: 12345
  pkg: ~
  re: !!perl/hash:RE_sequence
    a: 0
    dba: typename
    i: 0
    min: 12345
    r: 1
    s: 0
    zyg:
    - !!perl/hash:RE_bracket
      decl: []
      min: 12345
      re: &112 !!perl/hash:RE_any
        a: 0
        altname: typename_01
        dba: typename
        i: 0
        min: 12345
        name: typename_01
        r: 1
        s: 0
        zyg:
        - !!perl/hash:RE_sequence
          a: 0
          alt: typename_01 0
          dba: typename
          i: 0
          min: 12348
          r: 1
          s: 0
          zyg:
          - !!perl/hash:RE_string
            a: 0
            dba: typename
            i: 0
            min: 3
            r: 1
            s: 0
            text: ::?
          - !!perl/hash:RE_method
            a: 0
            dba: typename
            i: 0
            min: 12345
            name: identifier
            r: 1
            rest: ''
            s: 0
        - !!perl/hash:RE_sequence
          a: 0
          alt: typename_01 1
          dba: typename
          i: 0
          min: 12345
          r: 1
          s: 0
          zyg:
          - !!perl/hash:RE_method
            a: 0
            dba: typename
            i: 0
            min: 12345
            name: longname
            r: 1
            rest: ''
            s: 0
          - !!perl/hash:RE_assertion
            assert: '?'
            min: 0
            re: !!perl/hash:RE_block
              a: 0
              context: bool
              dba: typename
              i: 0
              min: 0
              nobind: 1
              r: 1
              s: 0
              text: "\n            my $longname = $<longname>.Str;\n            if
                substr($longname, 0, 2) eq '::' {\n                $.add_my_name(substr($longname,
                2));\n            }\n            else {\n                $.is_name($longname)\n
                \           }\n          "
    - !!perl/hash:RE_quantified_atom
      atom: !!perl/hash:RE_method
        a: 0
        dba: typename
        i: 0
        min: 12345
        name: unsp
        nobind: 1
        r: 1
        rest: ''
        s: 0
      min: 0
      quant:
      - '?'
      - ':'
      - ''
      - 0
    - !!perl/hash:RE_quantified_atom
      atom: !!perl/hash:RE_bracket
        decl: []
        min: 12345
        re: !!perl/hash:RE_sequence
          a: 0
          dba: typename
          i: 0
          min: 12345
          r: 1
          s: 0
          zyg:
          - !!perl/hash:RE_assertion
            assert: '?'
            min: 0
            re: !!perl/hash:RE_method_re
              a: 0
              dba: typename
              i: 0
              min: 0
              name: before
              nobind: 1
              r: 1
              re: !!perl/hash:RE_ast
                decl: []
                min: 1
                re: !!perl/hash:RE_string
                  a: 0
                  dba: typename
                  i: 0
                  min: 1
                  r: 1
                  s: 0
                  text: '['
              s: 0
          - !!perl/hash:RE_bindnamed
            a: 0
            atom: !!perl/hash:RE_method
              a: 0
              dba: typename
              i: 0
              min: 12345
              name: postcircumfix
              nobind: 1
              r: 1
              rest: ''
              s: 0
            dba: typename
            i: 0
            min: 12345
            r: 1
            s: 0
            var: param
      min: 0
      quant:
      - '?'
      - ':'
      - ''
      - 0
    - !!perl/hash:RE_quantified_atom
      atom: !!perl/hash:RE_method
        a: 0
        dba: typename
        i: 0
        min: 12345
        name: unsp
        nobind: 1
        r: 1
        rest: ''
        s: 0
      min: 0
      quant:
      - '?'
      - ':'
      - ''
      - 0
    - !!perl/hash:RE_quantified_atom
      atom: !!perl/hash:RE_bracket
        decl: []
        min: 12345
        re: !!perl/hash:RE_sequence
          a: 0
          dba: typename
          i: 0
          min: 12345
          r: 1
          s: 0
          zyg:
          - !!perl/hash:RE_assertion
            assert: '?'
            min: 0
            re: !!perl/hash:RE_method_re
              a: 0
              dba: typename
              i: 0
              min: 0
              name: before
              nobind: 1
              r: 1
              re: !!perl/hash:RE_ast
                decl: []
                min: 1
                re: !!perl/hash:RE_string
                  a: 0
                  dba: typename
                  i: 0
                  min: 1
                  r: 1
                  s: 0
                  text: '{'
              s: 0
          - !!perl/hash:RE_bindnamed
            a: 0
            atom: !!perl/hash:RE_method
              a: 0
              dba: typename
              i: 0
              min: 12345
              name: postcircumfix
              nobind: 1
              r: 1
              rest: ''
              s: 0
            dba: typename
            i: 0
            min: 12345
            r: 1
            s: 0
            var: whence
      min: 0
      quant:
      - '?'
      - ':'
      - ''
      - 0
    - !!perl/hash:RE_quantified_atom
      atom: !!perl/hash:RE_bracket
        decl: []
        min: 37037
        re: !!perl/hash:RE_sequence
          a: 0
          dba: typename
          i: 0
          min: 37037
          r: 1
          s: 0
          zyg:
          - !!perl/hash:RE_method
            a: 0
            dba: typename
            i: 0
            min: 12345
            name: ws
            nobind: 1
            r: 1
            rest: ''
            s: 0
          - !!perl/hash:RE_string
            a: 0
            dba: typename
            i: 0
            min: 2
            r: 1
            s: 0
            text: of
          - !!perl/hash:RE_method
            a: 0
            dba: typename
            i: 0
            min: 12345
            name: ws
            nobind: 1
            r: 1
            rest: ''
            s: 0
          - !!perl/hash:RE_method
            a: 0
            dba: typename
            i: 0
            min: 12345
            name: typename
            r: 1
            rest: ''
            s: 0
      min: 0
      quant:
      - '?'
      - ':'
      - ''
      - 0
typename_01: *112
value__S_197quote: !!perl/hash:RE_ast
  decl: []
  kind: token
  min: 12345
  pkg: ~
  re: !!perl/hash:RE_method
    a: 0
    dba: value__S_197quote
    i: 0
    min: 12345
    name: quote
    r: 1
    rest: ''
    s: 0
value__S_198number: !!perl/hash:RE_ast
  decl: []
  kind: token
  min: 12345
  pkg: ~
  re: !!perl/hash:RE_method
    a: 0
    dba: value__S_198number
    i: 0
    min: 12345
    name: number
    r: 1
    rest: ''
    s: 0
value__S_199version: !!perl/hash:RE_ast
  decl: []
  kind: token
  min: 12345
  pkg: ~
  re: !!perl/hash:RE_method
    a: 0
    dba: value__S_199version
    i: 0
    min: 12345
    name: version
    r: 1
    rest: ''
    s: 0
variable: !!perl/hash:RE_ast
  decl:
  - !!perl/hash:RE_decl
    a: 0
    dba: variable
    i: 0
    max: 0
    min: 0
    r: 1
    s: 0
    text: my $*IN_META = 0
  - !!perl/hash:RE_decl
    a: 0
    dba: variable
    i: 0
    max: 0
    min: 0
    r: 1
    s: 0
    text: my $sigil = ''
  - !!perl/hash:RE_decl
    a: 0
    dba: variable
    i: 0
    max: 0
    min: 0
    r: 1
    s: 0
    text: my $twigil = ''
  - !!perl/hash:RE_decl
    a: 0
    dba: variable
    i: 0
    max: 0
    min: 0
    r: 1
    s: 0
    text: my $name
  kind: token
  min: 0
  pkg: ~
  re: !!perl/hash:RE_sequence
    a: 0
    dba: variable
    i: 0
    min: 0
    r: 1
    s: 0
    zyg:
    - !!perl/hash:RE_assertion
      assert: '?'
      min: 0
      re: !!perl/hash:RE_method_re
        a: 0
        dba: variable
        i: 0
        min: 0
        name: before
        nobind: 1
        r: 1
        re: !!perl/hash:RE_ast
          decl: []
          min: 12345
          re: !!perl/hash:RE_sequence
            a: 0
            dba: variable
            i: 0
            min: 12345
            r: 1
            s: 0
            zyg:
            - !!perl/hash:RE_method
              a: 0
              dba: variable
              i: 0
              min: 12345
              name: sigil
              r: 1
              rest: ''
              s: 0
            - !!perl/hash:RE_block
              a: 0
              context: void
              dba: variable
              i: 0
              min: 0
              r: 1
              s: 0
              text: "\n            $sigil = $<sigil>.Str;\n            $*LEFTSIGIL
                ||= $sigil;\n        "
        s: 0
    - !!perl/hash:RE_block
      a: 0
      context: void
      dba: variable
      i: 0
      min: 0
      r: 1
      s: 0
      text: ''
    - !!perl/hash:RE_bracket
      decl: []
      min: 0
      re: !!perl/hash:RE_first
        a: 0
        dba: variable
        i: 0
        min: 0
        r: 1
        s: 0
        zyg:
        - !!perl/hash:RE_sequence
          a: 0
          dba: variable
          i: 0
          min: 24690
          r: 1
          s: 0
          zyg:
          - !!perl/hash:RE_method
            a: 0
            dba: variable
            i: 0
            min: 12345
            name: sigil
            r: 1
            rest: ''
            s: 0
          - !!perl/hash:RE_quantified_atom
            atom: !!perl/hash:RE_method
              a: 0
              dba: variable
              i: 0
              min: 12345
              name: twigil
              r: 1
              rest: ''
              s: 0
            min: 0
            quant:
            - '?'
            - ':'
            - ''
            - 0
          - !!perl/hash:RE_assertion
            assert: '?'
            min: 0
            re: !!perl/hash:RE_method_re
              a: 0
              dba: variable
              i: 0
              min: 0
              name: before
              nobind: 1
              r: 1
              re: !!perl/hash:RE_ast
                decl: []
                min: 3
                re: !!perl/hash:RE_sequence
                  a: 0
                  dba: variable
                  i: 0
                  min: 3
                  r: 1
                  s: 0
                  zyg:
                  - !!perl/hash:RE_string
                    a: 0
                    dba: variable
                    i: 0
                    min: 2
                    r: 1
                    s: 0
                    text: '::'
                  - !!perl/hash:RE_bracket
                    decl: []
                    min: 1
                    re: &113 !!perl/hash:RE_any
                      a: 0
                      altname: variable_04
                      dba: variable
                      i: 0
                      min: 1
                      name: variable_04
                      r: 1
                      s: 0
                      zyg:
                      - !!perl/hash:RE_string
                        a: 0
                        alt: variable_04 0
                        dba: variable
                        i: 0
                        min: 1
                        r: 1
                        s: 0
                        text: '{'
                      - !!perl/hash:RE_string
                        a: 0
                        alt: variable_04 1
                        dba: variable
                        i: 0
                        min: 1
                        r: 1
                        s: 0
                        text: <
                      - !!perl/hash:RE_string
                        a: 0
                        alt: variable_04 2
                        dba: variable
                        i: 0
                        min: 1
                        r: 1
                        s: 0
                        text: (
              s: 0
          - !!perl/hash:RE_method
            a: 0
            dba: variable
            i: 0
            min: 12345
            name: longname
            r: 1
            rest: ''
            s: 0
        - !!perl/hash:RE_sequence
          a: 0
          dba: variable
          i: 0
          min: 3
          r: 1
          s: 0
          zyg:
          - !!perl/hash:RE_string
            a: 0
            dba: variable
            i: 0
            min: 1
            r: 1
            s: 0
            text: '&'
          - !!perl/hash:RE_bracket
            decl: []
            min: 2
            re: &114 !!perl/hash:RE_any
              a: 0
              altname: variable_06
              dba: infix noun
              i: 0
              min: 2
              name: variable_06
              r: 1
              s: 0
              zyg:
              - !!perl/hash:RE_sequence
                a: 0
                alt: variable_06 0
                dba: variable
                i: 0
                min: 12345
                r: 1
                s: 0
                zyg:
                - !!perl/hash:RE_quantified_atom
                  atom: !!perl/hash:RE_method
                    a: 0
                    dba: variable
                    i: 0
                    min: 12345
                    name: twigil
                    r: 1
                    rest: ''
                    s: 0
                  min: 0
                  quant:
                  - '?'
                  - ':'
                  - ''
                  - 0
                - !!perl/hash:RE_method
                  a: 0
                  dba: variable
                  i: 0
                  min: 12345
                  name: sublongname
                  r: 1
                  rest: ''
                  s: 0
                - !!perl/hash:RE_block
                  a: 0
                  context: void
                  dba: variable
                  i: 0
                  min: 0
                  r: 1
                  s: 0
                  text: ' $name = $<sublongname>.Str '
              - !!perl/hash:RE_sequence
                a: 0
                alt: variable_06 1
                dba: infix noun
                i: 0
                min: 2
                r: 1
                s: 0
                zyg:
                - !!perl/hash:RE_string
                  a: 0
                  dba: infix noun
                  i: 0
                  min: 1
                  r: 1
                  s: 0
                  text: '['
                - !!perl/hash:RE_meta
                  a: 0
                  dba: infix noun
                  extra: 'local $::GOAL = '']'' '
                  i: 0
                  min: 0
                  r: 1
                  s: 0
                  text: ':'
                - !!perl/hash:RE_method
                  min: 0
                  name: infixish
                  rest: (1)
                - !!perl/hash:RE_bracket
                  decl: []
                  min: 1
                  re: !!perl/hash:RE_first
                    a: 0
                    dba: infix noun
                    i: 0
                    min: 1
                    r: 1
                    s: 0
                    zyg:
                    - !!perl/hash:RE_string
                      a: 0
                      dba: infix noun
                      i: 0
                      min: 1
                      r: 1
                      s: 0
                      text: ']'
                    - !!perl/hash:RE_method
                      min: 0
                      name: FAILGOAL
                      nobind: 1
                      rest: (']' , 'infix noun')
        - !!perl/hash:RE_sequence
          a: 0
          dba: variable
          i: 0
          min: 3
          r: 1
          s: 0
          zyg:
          - !!perl/hash:RE_string
            a: 0
            dba: variable
            i: 0
            min: 3
            r: 1
            s: 0
            text: '$::'
          - !!perl/hash:RE_quantified_atom
            atom: !!perl/hash:RE_method
              a: 0
              dba: variable
              i: 0
              min: 12345
              name: name
              r: 1
              rest: ''
              s: 0
            min: 0
            quant:
            - '?'
            - ':'
            - ''
            - 0
        - !!perl/hash:RE_sequence
          a: 0
          dba: variable
          i: 0
          min: 12347
          r: 1
          s: 0
          zyg:
          - !!perl/hash:RE_string
            a: 0
            dba: variable
            i: 0
            min: 2
            r: 1
            s: 0
            text: '$:'
          - !!perl/hash:RE_method
            a: 0
            dba: variable
            i: 0
            min: 12345
            name: name
            r: 1
            rest: ''
            s: 0
        - !!perl/hash:RE_bracket
          decl: []
          min: 0
          re: &115 !!perl/hash:RE_any
            a: 0
            altname: variable_10
            dba: variable
            i: 0
            min: 0
            name: variable_10
            r: 1
            s: 0
            zyg:
            - !!perl/hash:RE_sequence
              a: 0
              alt: variable_10 0
              dba: variable
              i: 0
              min: 24690
              r: 1
              s: 0
              zyg:
              - !!perl/hash:RE_method
                a: 0
                dba: variable
                i: 0
                min: 12345
                name: sigil
                r: 1
                rest: ''
                s: 0
              - !!perl/hash:RE_quantified_atom
                atom: !!perl/hash:RE_method
                  a: 0
                  dba: variable
                  i: 0
                  min: 12345
                  name: twigil
                  r: 1
                  rest: ''
                  s: 0
                min: 0
                quant:
                - '?'
                - ':'
                - ''
                - 0
              - !!perl/hash:RE_method
                a: 0
                dba: variable
                i: 0
                min: 12345
                name: desigilname
                r: 1
                rest: ''
                s: 0
              - !!perl/hash:RE_block
                a: 0
                context: void
                dba: variable
                i: 0
                min: 0
                r: 1
                s: 0
                text: ' $name = $<desigilname>.Str '
            - !!perl/hash:RE_method
              a: 0
              alt: variable_10 1
              dba: variable
              i: 0
              min: 12345
              name: special_variable
              r: 1
              rest: ''
              s: 0
            - !!perl/hash:RE_sequence
              a: 0
              alt: variable_10 2
              dba: variable
              i: 0
              min: 24690
              r: 1
              s: 0
              zyg:
              - !!perl/hash:RE_method
                a: 0
                dba: variable
                i: 0
                min: 12345
                name: sigil
                r: 1
                rest: ''
                s: 0
              - !!perl/hash:RE_bindnamed
                a: 0
                atom: !!perl/hash:RE_method
                  a: 0
                  dba: variable
                  i: 0
                  min: 12345
                  name: decint
                  nobind: 1
                  r: 1
                  rest: ''
                  s: 0
                dba: variable
                i: 0
                min: 12345
                r: 1
                s: 0
                var: index
            - !!perl/hash:RE_sequence
              a: 0
              alt: variable_10 3
              dba: variable
              i: 0
              min: 24690
              r: 1
              s: 0
              zyg:
              - !!perl/hash:RE_method
                a: 0
                dba: variable
                i: 0
                min: 12345
                name: sigil
                r: 1
                rest: ''
                s: 0
              - !!perl/hash:RE_assertion
                assert: '?'
                min: 0
                re: !!perl/hash:RE_method_re
                  a: 0
                  dba: variable
                  i: 0
                  min: 0
                  name: before
                  nobind: 1
                  r: 1
                  re: !!perl/hash:RE_ast
                    decl: []
                    min: 1
                    re: &116 !!perl/hash:RE_any
                      a: 0
                      altname: variable_11
                      dba: variable
                      i: 0
                      min: 1
                      name: variable_11
                      r: 1
                      s: 0
                      zyg:
                      - !!perl/hash:RE_string
                        a: 0
                        alt: variable_11 0
                        dba: variable
                        i: 0
                        min: 1
                        r: 1
                        s: 0
                        text: <
                      - !!perl/hash:RE_string
                        a: 0
                        alt: variable_11 1
                        dba: variable
                        i: 0
                        min: 1
                        r: 1
                        s: 0
                        text: (
                  s: 0
              - !!perl/hash:RE_method
                a: 0
                dba: variable
                i: 0
                min: 12345
                name: postcircumfix
                r: 1
                rest: ''
                s: 0
            - !!perl/hash:RE_sequence
              a: 0
              alt: variable_10 4
              dba: variable
              i: 0
              min: 12345
              r: 1
              s: 0
              zyg:
              - !!perl/hash:RE_method
                a: 0
                dba: variable
                i: 0
                min: 12345
                name: sigil
                r: 1
                rest: ''
                s: 0
              - !!perl/hash:RE_assertion
                assert: '?'
                min: 0
                re: !!perl/hash:RE_block
                  a: 0
                  context: bool
                  dba: variable
                  i: 0
                  min: 0
                  nobind: 1
                  r: 1
                  s: 0
                  text: ' $*IN_DECL '
            - !!perl/hash:RE_sequence
              a: 0
              alt: variable_10 5
              dba: variable
              i: 0
              min: 0
              r: 1
              s: 0
              zyg:
              - !!perl/hash:RE_assertion
                assert: '?'
                min: 0
                re: !!perl/hash:RE_noop
                  a: 0
                  dba: variable
                  i: 0
                  min: 0
                  nobind: 1
                  r: 1
                  s: 0
              - !!perl/hash:RE_block
                a: 0
                context: void
                dba: variable
                i: 0
                min: 0
                r: 1
                s: 0
                text: "\n                if $*QSIGIL {\n                    return
                  ();\n                }\n                else {\n                    $.panic(\"Non-declarative
                  sigil is missing its name\");\n                }\n              "
    - !!perl/hash:RE_block
      a: 0
      context: void
      dba: variable
      i: 0
      min: 0
      r: 1
      s: 0
      text: ' my $t = $<twigil>; $twigil = $t.[0].Str if @$t; '
    - !!perl/hash:RE_quantified_atom
      atom: !!perl/hash:RE_bracket
        decl: []
        min: 12345
        re: !!perl/hash:RE_sequence
          a: 0
          dba: variable
          i: 0
          min: 12345
          r: 1
          s: 0
          zyg:
          - !!perl/hash:RE_assertion
            assert: '?'
            min: 0
            re: !!perl/hash:RE_block
              a: 0
              context: bool
              dba: variable
              i: 0
              min: 0
              nobind: 1
              r: 1
              s: 0
              text: ' $twigil eq ''.'' '
          - !!perl/hash:RE_bracket
            decl: []
            min: 0
            re: &117 !!perl/hash:RE_any
              a: 0
              altname: variable_13
              dba: variable
              i: 0
              min: 0
              name: variable_13
              r: 1
              s: 0
              zyg:
              - !!perl/hash:RE_method
                a: 0
                alt: variable_13 0
                dba: variable
                i: 0
                min: 12345
                name: unsp
                nobind: 1
                r: 1
                rest: ''
                s: 0
              - !!perl/hash:RE_string
                a: 0
                alt: variable_13 1
                dba: variable
                i: 0
                min: 1
                r: 1
                s: 0
                text: \
              - !!perl/hash:RE_assertion
                alt: variable_13 2
                assert: '?'
                min: 0
                re: !!perl/hash:RE_noop
                  a: 0
                  dba: variable
                  i: 0
                  min: 0
                  nobind: 1
                  r: 1
                  s: 0
          - !!perl/hash:RE_assertion
            assert: '?'
            min: 0
            re: !!perl/hash:RE_method_re
              a: 0
              dba: variable
              i: 0
              min: 0
              name: before
              nobind: 1
              r: 1
              re: !!perl/hash:RE_ast
                decl: []
                min: 1
                re: !!perl/hash:RE_string
                  a: 0
                  dba: variable
                  i: 0
                  min: 1
                  r: 1
                  s: 0
                  text: (
              s: 0
          - !!perl/hash:RE_method
            a: 0
            dba: variable
            i: 0
            min: 12345
            name: postcircumfix
            r: 1
            rest: ''
            s: 0
      min: 0
      quant:
      - '?'
      - ':'
      - ''
      - 0
variable_04: *113
variable_06: *114
variable_10: *115
variable_11: *116
variable_13: *117
variable_declarator: !!perl/hash:RE_ast
  decl:
  - !!perl/hash:RE_decl
    a: 0
    dba: variable_declarator
    i: 0
    max: 0
    min: 0
    r: 1
    s: 0
    text: my $*IN_DECL = 'variable'
  - !!perl/hash:RE_decl
    a: 0
    dba: variable_declarator
    i: 0
    max: 0
    min: 0
    r: 1
    s: 0
    text: my $*DECLARAND
  - !!perl/hash:RE_decl
    a: 0
    dba: variable_declarator
    i: 0
    max: 0
    min: 0
    r: 1
    s: 0
    text: my $var
  kind: token
  min: 37035
  pkg: ~
  re: !!perl/hash:RE_sequence
    a: 0
    dba: variable_declarator
    i: 0
    min: 37035
    r: 1
    s: 0
    zyg:
    - !!perl/hash:RE_method
      a: 0
      dba: variable_declarator
      i: 0
      min: 12345
      name: variable
      r: 1
      rest: ''
      s: 0
    - !!perl/hash:RE_block
      a: 0
      context: void
      dba: variable_declarator
      i: 0
      min: 0
      r: 1
      s: 0
      text: "\n            $var = $<variable>.Str;\n            $.add_variable($var);\n
        \           $*IN_DECL = '';\n        "
    - !!perl/hash:RE_quantified_atom
      atom: !!perl/hash:RE_bracket
        decl: []
        min: 0
        re: !!perl/hash:RE_sequence
          a: 0
          dba: variable_declarator
          i: 0
          min: 0
          r: 1
          s: 0
          zyg:
          - !!perl/hash:RE_quantified_atom
            atom: !!perl/hash:RE_method
              a: 0
              dba: variable_declarator
              i: 0
              min: 12345
              name: unsp
              nobind: 1
              r: 1
              rest: ''
              s: 0
            min: 0
            quant:
            - '?'
            - ':'
            - ''
            - 0
          - !!perl/hash:RE_bindnamed
            a: 0
            atom: !!perl/hash:RE_quantified_atom
              atom: !!perl/hash:RE_bracket
                decl: []
                min: 12345
                re: &118 !!perl/hash:RE_any
                  a: 0
                  altname: variable_declarator_02
                  dba: shape definition
                  i: 0
                  min: 12345
                  name: variable_declarator_02
                  r: 1
                  s: 0
                  zyg:
                  - !!perl/hash:RE_sequence
                    a: 0
                    alt: variable_declarator_02 0
                    dba: variable_declarator
                    i: 0
                    min: 12347
                    r: 1
                    s: 0
                    zyg:
                    - !!perl/hash:RE_string
                      a: 0
                      dba: variable_declarator
                      i: 0
                      min: 1
                      r: 1
                      s: 0
                      text: (
                    - !!perl/hash:RE_meta
                      a: 0
                      dba: variable_declarator
                      extra: 'local $::GOAL = '')'' '
                      i: 0
                      min: 0
                      r: 1
                      s: 0
                      text: ':'
                    - !!perl/hash:RE_method
                      a: 0
                      dba: variable_declarator
                      i: 0
                      min: 12345
                      name: signature
                      r: 1
                      rest: ''
                      s: 0
                    - !!perl/hash:RE_bracket
                      decl: []
                      min: 1
                      re: !!perl/hash:RE_first
                        a: 0
                        dba: variable_declarator
                        i: 0
                        min: 1
                        r: 1
                        s: 0
                        zyg:
                        - !!perl/hash:RE_string
                          a: 0
                          dba: variable_declarator
                          i: 0
                          min: 1
                          r: 1
                          s: 0
                          text: )
                        - !!perl/hash:RE_method
                          min: 0
                          name: FAILGOAL
                          nobind: 1
                          rest: (')' , 'variable_declarator')
                    - !!perl/hash:RE_block
                      a: 0
                      context: void
                      dba: variable_declarator
                      i: 0
                      min: 0
                      r: 1
                      s: 0
                      text: "\n                    given substr($var,0,1) {\n                        when
                        '&' {\n                            $.panic(\"The () shape
                        syntax in routine declarations is reserved (maybe use :()
                        to declare a longname?)\");\n                        }\n                        when
                        '@' {\n                            $.panic(\"The () shape
                        syntax in array declarations is reserved\");\n                        }\n
                        \                       when '%' {\n                            $.panic(\"The
                        () shape syntax in hash declarations is reserved\");\n                        }\n
                        \                       $.panic(\"The () shape syntax in
                        variable declarations is reserved\");\n                    }\n
                        \               "
                  - !!perl/hash:RE_sequence
                    a: 0
                    alt: variable_declarator_02 1
                    dba: shape definition
                    i: 0
                    min: 12347
                    r: 1
                    s: 0
                    zyg:
                    - !!perl/hash:RE_string
                      a: 0
                      dba: shape definition
                      i: 0
                      min: 1
                      r: 1
                      s: 0
                      text: '['
                    - !!perl/hash:RE_meta
                      a: 0
                      dba: shape definition
                      extra: 'local $::GOAL = '']'' '
                      i: 0
                      min: 0
                      r: 1
                      s: 0
                      text: ':'
                    - !!perl/hash:RE_method
                      a: 0
                      dba: shape definition
                      i: 0
                      min: 12345
                      name: semilist
                      r: 1
                      rest: ''
                      s: 0
                    - !!perl/hash:RE_bracket
                      decl: []
                      min: 1
                      re: !!perl/hash:RE_first
                        a: 0
                        dba: shape definition
                        i: 0
                        min: 1
                        r: 1
                        s: 0
                        zyg:
                        - !!perl/hash:RE_string
                          a: 0
                          dba: shape definition
                          i: 0
                          min: 1
                          r: 1
                          s: 0
                          text: ']'
                        - !!perl/hash:RE_method
                          min: 0
                          name: FAILGOAL
                          nobind: 1
                          rest: (']' , 'shape definition')
                  - !!perl/hash:RE_sequence
                    a: 0
                    alt: variable_declarator_02 2
                    dba: shape definition
                    i: 0
                    min: 24692
                    r: 1
                    s: 0
                    zyg:
                    - !!perl/hash:RE_string
                      a: 0
                      dba: shape definition
                      i: 0
                      min: 1
                      r: 1
                      s: 0
                      text: '{'
                    - !!perl/hash:RE_meta
                      a: 0
                      dba: shape definition
                      extra: 'local $::GOAL = ''}'' '
                      i: 0
                      min: 0
                      r: 1
                      s: 0
                      text: ':'
                    - !!perl/hash:RE_method
                      a: 0
                      dba: shape definition
                      i: 0
                      min: 12345
                      name: semilist
                      r: 1
                      rest: ''
                      s: 0
                    - !!perl/hash:RE_bracket
                      decl: []
                      min: 1
                      re: !!perl/hash:RE_first
                        a: 0
                        dba: shape definition
                        i: 0
                        min: 1
                        r: 1
                        s: 0
                        zyg:
                        - !!perl/hash:RE_string
                          a: 0
                          dba: shape definition
                          i: 0
                          min: 1
                          r: 1
                          s: 0
                          text: '}'
                        - !!perl/hash:RE_method
                          min: 0
                          name: FAILGOAL
                          nobind: 1
                          rest: ('}' , 'shape definition')
                    - !!perl/hash:RE_method
                      a: 0
                      dba: shape definition
                      i: 0
                      min: 12345
                      name: curlycheck
                      nobind: 1
                      r: 1
                      rest: ''
                      s: 0
                  - !!perl/hash:RE_sequence
                    a: 0
                    alt: variable_declarator_02 3
                    dba: shape definition
                    i: 0
                    min: 12345
                    r: 1
                    s: 0
                    zyg:
                    - !!perl/hash:RE_assertion
                      assert: '?'
                      min: 0
                      re: !!perl/hash:RE_method_re
                        a: 0
                        dba: shape definition
                        i: 0
                        min: 0
                        name: before
                        nobind: 1
                        r: 1
                        re: !!perl/hash:RE_ast
                          decl: []
                          min: 1
                          re: !!perl/hash:RE_string
                            a: 0
                            dba: shape definition
                            i: 0
                            min: 1
                            r: 1
                            s: 0
                            text: <
                        s: 0
                    - !!perl/hash:RE_method
                      a: 0
                      dba: shape definition
                      i: 0
                      min: 12345
                      name: postcircumfix
                      r: 1
                      rest: ''
                      s: 0
              min: 0
              quant:
              - '*'
              - ':'
              - ''
              - 0
            dba: variable_declarator
            i: 0
            min: 0
            r: 1
            s: 0
            var: shape
      min: 0
      quant:
      - '?'
      - ':'
      - ''
      - 0
    - !!perl/hash:RE_method
      a: 0
      dba: variable_declarator
      i: 0
      min: 12345
      name: ws
      nobind: 1
      r: 1
      rest: ''
      s: 0
    - !!perl/hash:RE_quantified_atom
      atom: !!perl/hash:RE_method
        a: 0
        dba: variable_declarator
        i: 0
        min: 12345
        name: trait
        r: 1
        rest: ''
        s: 0
      min: 0
      quant:
      - '*'
      - ':'
      - ''
      - 0
    - !!perl/hash:RE_method
      a: 0
      dba: variable_declarator
      i: 0
      min: 12345
      name: getdecl
      nobind: 1
      r: 1
      rest: ''
      s: 0
variable_declarator_02: *118
version__S_102v: !!perl/hash:RE_ast
  decl: []
  kind: token
  min: 12346
  pkg: ~
  re: !!perl/hash:RE_sequence
    a: 0
    dba: version__S_102v
    i: 0
    min: 12346
    r: 1
    s: 0
    zyg:
    - !!perl/hash:RE_string
      a: 0
      dba: version__S_102v
      i: 0
      min: 1
      r: 1
      s: 0
      text: v
    - !!perl/hash:RE_assertion
      assert: '?'
      min: 0
      re: !!perl/hash:RE_method_re
        a: 0
        dba: version__S_102v
        i: 0
        min: 0
        name: before
        nobind: 1
        r: 1
        re: !!perl/hash:RE_ast
          decl: []
          min: 1
          re: !!perl/hash:RE_quantified_atom
            atom: !!perl/hash:RE_meta
              a: 0
              dba: version__S_102v
              i: 0
              min: 1
              r: 1
              s: 0
              text: \d
            min: 1
            quant:
            - +
            - ':'
            - ''
            - 1
        s: 0
    - !!perl/hash:RE_meta
      a: 0
      dba: version__S_102v
      i: 0
      min: 0
      r: 1
      s: 0
      text: '::'
    - !!perl/hash:RE_quantified_atom
      atom: !!perl/hash:RE_method
        a: 0
        dba: version__S_102v
        i: 0
        min: 12345
        name: vnum
        r: 1
        rest: ''
        s: 0
      min: 12345
      quant:
      - '**'
      - ':'
      - !!perl/hash:RE_string
        a: 0
        dba: version__S_102v
        i: 0
        min: 1
        r: 1
        s: 0
        text: .
      - 1
    - !!perl/hash:RE_quantified_atom
      atom: !!perl/hash:RE_string
        a: 0
        dba: version__S_102v
        i: 0
        min: 1
        r: 1
        s: 0
        text: +
      min: 0
      quant:
      - '?'
      - ':'
      - ''
      - 0
vnum: !!perl/hash:RE_ast
  decl: []
  kind: token
  min: 1
  pkg: ~
  re: &119 !!perl/hash:RE_any
    a: 0
    altname: vnum_00
    dba: vnum
    i: 0
    min: 1
    name: vnum_00
    r: 1
    s: 0
    zyg:
    - !!perl/hash:RE_quantified_atom
      alt: vnum_00 0
      atom: !!perl/hash:RE_meta
        a: 0
        dba: vnum
        i: 0
        min: 1
        r: 1
        s: 0
        text: \d
      min: 1
      quant:
      - +
      - ':'
      - ''
      - 1
    - !!perl/hash:RE_string
      a: 0
      alt: vnum_00 1
      dba: vnum
      i: 0
      min: 1
      r: 1
      s: 0
      text: '*'
vnum_00: *119
xblock: !!perl/hash:RE_ast
  decl:
  - !!perl/hash:RE_decl
    a: 0
    dba: xblock
    i: 0
    max: 0
    min: 0
    r: 1
    s: 0
    text: my $*GOAL ::= '{'
  - !!perl/hash:RE_decl
    a: 0
    dba: xblock
    i: 0
    max: 0
    min: 0
    r: 1
    s: 0
    text: my $*BORG = {}
  kind: token
  min: 37035
  pkg: ~
  re: !!perl/hash:RE_sequence
    a: 0
    dba: xblock
    i: 0
    min: 37035
    r: 1
    s: 0
    zyg:
    - !!perl/hash:RE_method
      a: 0
      dba: xblock
      i: 0
      min: 12345
      name: EXPR
      r: 1
      rest: ''
      s: 0
    - !!perl/hash:RE_block
      a: 0
      context: void
      dba: xblock
      i: 0
      min: 0
      r: 1
      s: 0
      text: ' $*BORG.<culprit> //= $<EXPR>.cursor(self.pos) '
    - !!perl/hash:RE_method
      a: 0
      dba: xblock
      i: 0
      min: 12345
      name: ws
      nobind: 1
      r: 1
      rest: ''
      s: 0
    - !!perl/hash:RE_method
      a: 0
      dba: xblock
      i: 0
      min: 12345
      name: pblock
      r: 1
      rest: ''
      s: 0
RETREE_END
}
} ## end grammar

{ package STD::Q;
use Moose ':all' => { -prefix => "moose_" };
my $retree;
moose_extends(qw(STD));
{ package STD::Q::b1;
use Moose::Role ':all' => { -prefix => "moose_" };
my $retree;
##         token escape__S_413Back (:$*sym = <\\>)
##              token escape:sym<\\> { <sym> <item=.backslash> }

sub escape__S_413Back__PEEK { $_[0]->_AUTOLEXpeek('escape__S_413Back',$retree) }
sub escape__S_413Back {
no warnings 'recursion';
my $self = shift;
local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;
my %args = @_;
local $::sym = $args{sym} // q(\\);


my $C = $self->cursor_xact("RULE escape__S_413Back");
my $xact = $C->xact;
my $S = $C->{'_pos'};
$C->{'sym'} = ref $sym ? join(' ', @$sym) : $sym;

$self->_MATCHIFYr($S, "escape__S_413Back", 
do {
if (my ($C) = ($C->_PATTERN(qr/\G\\/))) {
$C->_SUBSUMEr(['item'], sub {
my $C = shift;
$C->backslash
});
}
else {
();
}
}
);
}
##         token backslash__S_414qq (:$*sym = 'qq')
##              token backslash:qq { <?before 'q'> { $<quote> = $.cursor_fresh(%*LANG<MAIN>).quote(); } }

sub backslash__S_414qq__PEEK { $_[0]->_AUTOLEXpeek('backslash__S_414qq',$retree) }
sub backslash__S_414qq {
no warnings 'recursion';
my $self = shift;
local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;
my %args = @_;
local $::sym = $args{sym} // 'qq';


my $C = $self->cursor_xact("RULE backslash__S_414qq");
my $xact = $C->xact;
my $S = $C->{'_pos'};
$C->{'sym'} = ref $sym ? join(' ', @$sym) : $sym;

$self->_MATCHIFYr($S, "backslash__S_414qq", 
do {
if (my ($C) = ($C->before(sub { my $C=shift;
$C->_EXACT('q')
}))) {
scalar(do {
my $M = $C;  $M->{'quote'} = $C->cursor_fresh($::LANG{'MAIN'})->quote(); ;
}, $C);
}
else {
();
}
}
);
}
##         token backslash__S_415Back (:$*sym = <\\>)
##              token backslash:sym<\\> { <text=.sym> }

sub backslash__S_415Back__PEEK { $_[0]->_AUTOLEXpeek('backslash__S_415Back',$retree) }
sub backslash__S_415Back {
no warnings 'recursion';
my $self = shift;
local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;
my %args = @_;
local $::sym = $args{sym} // q(\\);


my $C = $self->cursor_xact("RULE backslash__S_415Back");
my $xact = $C->xact;
my $S = $C->{'_pos'};
$C->{'sym'} = ref $sym ? join(' ', @$sym) : $sym;

$self->_MATCHIFYr($S, "backslash__S_415Back", 
$C->_PATTERN(qr/\G\\/)
);
}
##         token backslash__S_416stopper (:$*sym = 'stopper')
##              token backslash:stopper { <text=.stopper> }

sub backslash__S_416stopper__PEEK { $_[0]->_AUTOLEXpeek('backslash__S_416stopper',$retree) }
sub backslash__S_416stopper {
no warnings 'recursion';
my $self = shift;
local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;
my %args = @_;
local $::sym = $args{sym} // 'stopper';


my $C = $self->cursor_xact("RULE backslash__S_416stopper");
my $xact = $C->xact;
my $S = $C->{'_pos'};
$C->{'sym'} = ref $sym ? join(' ', @$sym) : $sym;

$self->_MATCHIFYr($S, "backslash__S_416stopper", 
$C->_SUBSUMEr(['text'], sub {
my $C = shift;
$C->stopper
})
);
}
##         token backslash__S_417a (:$*sym = 'a')
##              token backslash:a { <sym> }

sub backslash__S_417a__PEEK { $_[0]->_AUTOLEXpeek('backslash__S_417a',$retree) }
sub backslash__S_417a {
no warnings 'recursion';
my $self = shift;
local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;
my %args = @_;
local $::sym = $args{sym} // 'a';


my $C = $self->cursor_xact("RULE backslash__S_417a");
my $xact = $C->xact;
my $S = $C->{'_pos'};
$C->{'sym'} = ref $sym ? join(' ', @$sym) : $sym;

$self->_MATCHIFYr($S, "backslash__S_417a", 
$C->_PATTERN(qr/\Ga/)
);
}
##         token backslash__S_418b (:$*sym = 'b')
##              token backslash:b { <sym> }

sub backslash__S_418b__PEEK { $_[0]->_AUTOLEXpeek('backslash__S_418b',$retree) }
sub backslash__S_418b {
no warnings 'recursion';
my $self = shift;
local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;
my %args = @_;
local $::sym = $args{sym} // 'b';


my $C = $self->cursor_xact("RULE backslash__S_418b");
my $xact = $C->xact;
my $S = $C->{'_pos'};
$C->{'sym'} = ref $sym ? join(' ', @$sym) : $sym;

$self->_MATCHIFYr($S, "backslash__S_418b", 
$C->_PATTERN(qr/\Gb/)
);
}
##         token backslash__S_419c (:$*sym = 'c')
##              token backslash:c { <sym> <charspec> }

sub backslash__S_419c__PEEK { $_[0]->_AUTOLEXpeek('backslash__S_419c',$retree) }
sub backslash__S_419c {
no warnings 'recursion';
my $self = shift;
local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;
my %args = @_;
local $::sym = $args{sym} // 'c';


my $C = $self->cursor_xact("RULE backslash__S_419c");
my $xact = $C->xact;
my $S = $C->{'_pos'};
$C->{'sym'} = ref $sym ? join(' ', @$sym) : $sym;

$self->_MATCHIFYr($S, "backslash__S_419c", 
do {
if (my ($C) = ($C->_PATTERN(qr/\Gc/))) {
$C->_SUBSUMEr(['charspec'], sub {
my $C = shift;
$C->charspec
});
}
else {
();
}
}
);
}
##         token backslash__S_420e (:$*sym = 'e')
##              token backslash:e { <sym> }

sub backslash__S_420e__PEEK { $_[0]->_AUTOLEXpeek('backslash__S_420e',$retree) }
sub backslash__S_420e {
no warnings 'recursion';
my $self = shift;
local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;
my %args = @_;
local $::sym = $args{sym} // 'e';


my $C = $self->cursor_xact("RULE backslash__S_420e");
my $xact = $C->xact;
my $S = $C->{'_pos'};
$C->{'sym'} = ref $sym ? join(' ', @$sym) : $sym;

$self->_MATCHIFYr($S, "backslash__S_420e", 
$C->_PATTERN(qr/\Ge/)
);
}
##         token backslash__S_421f (:$*sym = 'f')
##              token backslash:f { <sym> }

sub backslash__S_421f__PEEK { $_[0]->_AUTOLEXpeek('backslash__S_421f',$retree) }
sub backslash__S_421f {
no warnings 'recursion';
my $self = shift;
local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;
my %args = @_;
local $::sym = $args{sym} // 'f';


my $C = $self->cursor_xact("RULE backslash__S_421f");
my $xact = $C->xact;
my $S = $C->{'_pos'};
$C->{'sym'} = ref $sym ? join(' ', @$sym) : $sym;

$self->_MATCHIFYr($S, "backslash__S_421f", 
$C->_PATTERN(qr/\Gf/)
);
}
##         token backslash__S_422n (:$*sym = 'n')
##              token backslash:n { <sym> }

sub backslash__S_422n__PEEK { $_[0]->_AUTOLEXpeek('backslash__S_422n',$retree) }
sub backslash__S_422n {
no warnings 'recursion';
my $self = shift;
local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;
my %args = @_;
local $::sym = $args{sym} // 'n';


my $C = $self->cursor_xact("RULE backslash__S_422n");
my $xact = $C->xact;
my $S = $C->{'_pos'};
$C->{'sym'} = ref $sym ? join(' ', @$sym) : $sym;

$self->_MATCHIFYr($S, "backslash__S_422n", 
$C->_PATTERN(qr/\Gn/)
);
}
##         token backslash__S_423o (:$*sym = 'o')
##              token backslash:o { :dba('octal character') <sym> [ <octint> | '[' ~ ']' <octints> ] }

sub backslash__S_423o__PEEK { $_[0]->_AUTOLEXpeek('backslash__S_423o',$retree) }
sub backslash__S_423o {
no warnings 'recursion';
my $self = shift;
local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;
my %args = @_;
local $::sym = $args{sym} // 'o';


my $C = $self->cursor_xact("RULE backslash__S_423o");
my $xact = $C->xact;
my $S = $C->{'_pos'};
$C->{'sym'} = ref $sym ? join(' ', @$sym) : $sym;

$self->_MATCHIFYr($S, "backslash__S_423o", 
do {
if (my ($C) = ($C->_PATTERN(qr/\Go/))) {
$C->_BRACKETr(sub {
my $C=shift;
do {
my @result = do {
my $trystate;
my ($tag, $try);
my @try;
my $relex;

my $fate;
my $x;
if ($fate = $C->{'_fate'} and $fate->[1] eq 'backslash__S_423o_01') {
$C->deb("Fate passed to backslash__S_423o_01: ", ::fatestr($fate)) if $::DEBUG & DEBUG::fates;
($C->{'_fate'}, $tag, $try) = @$fate;
@try = ($try);
$x = 'ALT backslash__S_423o_01';    # some outer ltm is controlling us
}
else {
$x = 'ALTLTM backslash__S_423o_01'; # we are top level ltm
}
my $C = $C->cursor_xact($x);
my $xact = $C->xact;

my @gather = ();
for (;;) {
if (not @try) {
$relex //= $C->cursor_fate('STD::Q::b1', 'backslash__S_423o_01', $retree);
@try = $relex->($C, $trystate);
}
last unless @try;
$try = shift(@try) // next;

if (ref $try eq 'ARRAY') {
($C->{'_fate'}, $tag, $try) = @$try;	# next candidate fate
}

$C->deb("backslash__S_423o_01 trying $tag $try") if $::DEBUG & DEBUG::try_processing;
push @gather, ((
sub { my $C=shift;
$C->_SUBSUMEr(['octint'], sub {
my $C = shift;
$C->octint
})
},
sub { my $C=shift;
do {
if (my ($C) = ($C->_EXACT('['))) {
do {
if (my ($C) = (((local $::GOAL = ']' ), $C)[-1])) {
do {
if (my ($C) = ($C->_SUBSUMEr(['octints'], sub {
my $C = shift;
$C->octints
}))) {
$C->_BRACKETr(sub {
my $C=shift;
do {
my $C = $C->cursor_xact('ALT ||');
my $xact = $C->xact;
my @gather;
do {
push @gather, $C->_EXACT(']')
}
or $xact->[-2] or
do {
push @gather, $C->FAILGOAL(']' , 'octal character')};
@gather;
}
});
}
else {
();
}
};
}
else {
();
}
};
}
else {
();
}
}
},
)[$try])->($C);
last if $xact->[-2];  # committed?
last if @gather;
}
@gather;
};
@result;
}

});
}
else {
();
}
}
);
}
##         token backslash__S_424r (:$*sym = 'r')
##              token backslash:r { <sym> }

sub backslash__S_424r__PEEK { $_[0]->_AUTOLEXpeek('backslash__S_424r',$retree) }
sub backslash__S_424r {
no warnings 'recursion';
my $self = shift;
local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;
my %args = @_;
local $::sym = $args{sym} // 'r';


my $C = $self->cursor_xact("RULE backslash__S_424r");
my $xact = $C->xact;
my $S = $C->{'_pos'};
$C->{'sym'} = ref $sym ? join(' ', @$sym) : $sym;

$self->_MATCHIFYr($S, "backslash__S_424r", 
$C->_PATTERN(qr/\Gr/)
);
}
##         token backslash__S_425t (:$*sym = 't')
##              token backslash:t { <sym> }

sub backslash__S_425t__PEEK { $_[0]->_AUTOLEXpeek('backslash__S_425t',$retree) }
sub backslash__S_425t {
no warnings 'recursion';
my $self = shift;
local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;
my %args = @_;
local $::sym = $args{sym} // 't';


my $C = $self->cursor_xact("RULE backslash__S_425t");
my $xact = $C->xact;
my $S = $C->{'_pos'};
$C->{'sym'} = ref $sym ? join(' ', @$sym) : $sym;

$self->_MATCHIFYr($S, "backslash__S_425t", 
$C->_PATTERN(qr/\Gt/)
);
}
##         token backslash__S_426x (:$*sym = 'x')
##              token backslash:x { :dba('hex character') <sym> [ <hexint> | '[' ~ ']' <hexints> ] }

sub backslash__S_426x__PEEK { $_[0]->_AUTOLEXpeek('backslash__S_426x',$retree) }
sub backslash__S_426x {
no warnings 'recursion';
my $self = shift;
local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;
my %args = @_;
local $::sym = $args{sym} // 'x';


my $C = $self->cursor_xact("RULE backslash__S_426x");
my $xact = $C->xact;
my $S = $C->{'_pos'};
$C->{'sym'} = ref $sym ? join(' ', @$sym) : $sym;

$self->_MATCHIFYr($S, "backslash__S_426x", 
do {
if (my ($C) = ($C->_PATTERN(qr/\Gx/))) {
$C->_BRACKETr(sub {
my $C=shift;
do {
my @result = do {
my $trystate;
my ($tag, $try);
my @try;
my $relex;

my $fate;
my $x;
if ($fate = $C->{'_fate'} and $fate->[1] eq 'backslash__S_426x_01') {
$C->deb("Fate passed to backslash__S_426x_01: ", ::fatestr($fate)) if $::DEBUG & DEBUG::fates;
($C->{'_fate'}, $tag, $try) = @$fate;
@try = ($try);
$x = 'ALT backslash__S_426x_01';    # some outer ltm is controlling us
}
else {
$x = 'ALTLTM backslash__S_426x_01'; # we are top level ltm
}
my $C = $C->cursor_xact($x);
my $xact = $C->xact;

my @gather = ();
for (;;) {
if (not @try) {
$relex //= $C->cursor_fate('STD::Q::b1', 'backslash__S_426x_01', $retree);
@try = $relex->($C, $trystate);
}
last unless @try;
$try = shift(@try) // next;

if (ref $try eq 'ARRAY') {
($C->{'_fate'}, $tag, $try) = @$try;	# next candidate fate
}

$C->deb("backslash__S_426x_01 trying $tag $try") if $::DEBUG & DEBUG::try_processing;
push @gather, ((
sub { my $C=shift;
$C->_SUBSUMEr(['hexint'], sub {
my $C = shift;
$C->hexint
})
},
sub { my $C=shift;
do {
if (my ($C) = ($C->_EXACT('['))) {
do {
if (my ($C) = (((local $::GOAL = ']' ), $C)[-1])) {
do {
if (my ($C) = ($C->_SUBSUMEr(['hexints'], sub {
my $C = shift;
$C->hexints
}))) {
$C->_BRACKETr(sub {
my $C=shift;
do {
my $C = $C->cursor_xact('ALT ||');
my $xact = $C->xact;
my @gather;
do {
push @gather, $C->_EXACT(']')
}
or $xact->[-2] or
do {
push @gather, $C->FAILGOAL(']' , 'hex character')};
@gather;
}
});
}
else {
();
}
};
}
else {
();
}
};
}
else {
();
}
}
},
)[$try])->($C);
last if $xact->[-2];  # committed?
last if @gather;
}
@gather;
};
@result;
}

});
}
else {
();
}
}
);
}
##         token backslash__S_4270 (:$*sym = <0>)
##              token backslash:sym<0> { <sym> }

sub backslash__S_4270__PEEK { $_[0]->_AUTOLEXpeek('backslash__S_4270',$retree) }
sub backslash__S_4270 {
no warnings 'recursion';
my $self = shift;
local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;
my %args = @_;
local $::sym = $args{sym} // q(0);


my $C = $self->cursor_xact("RULE backslash__S_4270");
my $xact = $C->xact;
my $S = $C->{'_pos'};

$self->_MATCHIFYr($S, "backslash__S_4270", 
$C->_PATTERN(qr/\G0/)
);
}
BEGIN {
$retree = YAML::XS::Load(Encode::encode_utf8(<<'RETREE_END'));
---
backslash__S_414qq: !!perl/hash:RE_ast
  decl: []
  kind: token
  min: 0
  pkg: ~
  re: !!perl/hash:RE_sequence
    a: 0
    dba: backslash__S_414qq
    i: 0
    min: 0
    r: 1
    s: 0
    zyg:
    - !!perl/hash:RE_assertion
      assert: '?'
      min: 0
      re: !!perl/hash:RE_method_re
        a: 0
        dba: backslash__S_414qq
        i: 0
        min: 0
        name: before
        nobind: 1
        r: 1
        re: !!perl/hash:RE_ast
          decl: []
          min: 1
          re: !!perl/hash:RE_string
            a: 0
            dba: backslash__S_414qq
            i: 0
            min: 1
            r: 1
            s: 0
            text: q
        s: 0
    - !!perl/hash:RE_block
      a: 0
      context: void
      dba: backslash__S_414qq
      i: 0
      min: 0
      r: 1
      s: 0
      text: ' $<quote> = $.cursor_fresh(%*LANG<MAIN>).quote(); '
backslash__S_415Back: !!perl/hash:RE_ast
  decl: []
  kind: token
  min: 12345
  pkg: ~
  re: !!perl/hash:RE_bindnamed
    a: 0
    atom: !!perl/hash:RE_method
      a: 0
      dba: backslash__S_415Back
      i: 0
      min: 12345
      name: sym
      nobind: 1
      r: 1
      rest: ''
      s: 0
      sym: \
    dba: backslash__S_415Back
    i: 0
    min: 12345
    r: 1
    s: 0
    var: text
backslash__S_416stopper: !!perl/hash:RE_ast
  decl: []
  kind: token
  min: 12345
  pkg: ~
  re: !!perl/hash:RE_bindnamed
    a: 0
    atom: !!perl/hash:RE_method
      a: 0
      dba: backslash__S_416stopper
      i: 0
      min: 12345
      name: stopper
      nobind: 1
      r: 1
      rest: ''
      s: 0
    dba: backslash__S_416stopper
    i: 0
    min: 12345
    r: 1
    s: 0
    var: text
backslash__S_417a: !!perl/hash:RE_ast
  decl: []
  kind: token
  min: 12345
  pkg: ~
  re: !!perl/hash:RE_method
    a: 0
    dba: backslash__S_417a
    i: 0
    min: 12345
    name: sym
    r: 1
    rest: ''
    s: 0
    sym: a
backslash__S_418b: !!perl/hash:RE_ast
  decl: []
  kind: token
  min: 12345
  pkg: ~
  re: !!perl/hash:RE_method
    a: 0
    dba: backslash__S_418b
    i: 0
    min: 12345
    name: sym
    r: 1
    rest: ''
    s: 0
    sym: b
backslash__S_419c: !!perl/hash:RE_ast
  decl: []
  kind: token
  min: 24690
  pkg: ~
  re: !!perl/hash:RE_sequence
    a: 0
    dba: backslash__S_419c
    i: 0
    min: 24690
    r: 1
    s: 0
    zyg:
    - !!perl/hash:RE_method
      a: 0
      dba: backslash__S_419c
      i: 0
      min: 12345
      name: sym
      r: 1
      rest: ''
      s: 0
      sym: c
    - !!perl/hash:RE_method
      a: 0
      dba: backslash__S_419c
      i: 0
      min: 12345
      name: charspec
      r: 1
      rest: ''
      s: 0
backslash__S_420e: !!perl/hash:RE_ast
  decl: []
  kind: token
  min: 12345
  pkg: ~
  re: !!perl/hash:RE_method
    a: 0
    dba: backslash__S_420e
    i: 0
    min: 12345
    name: sym
    r: 1
    rest: ''
    s: 0
    sym: e
backslash__S_421f: !!perl/hash:RE_ast
  decl: []
  kind: token
  min: 12345
  pkg: ~
  re: !!perl/hash:RE_method
    a: 0
    dba: backslash__S_421f
    i: 0
    min: 12345
    name: sym
    r: 1
    rest: ''
    s: 0
    sym: f
backslash__S_422n: !!perl/hash:RE_ast
  decl: []
  kind: token
  min: 12345
  pkg: ~
  re: !!perl/hash:RE_method
    a: 0
    dba: backslash__S_422n
    i: 0
    min: 12345
    name: sym
    r: 1
    rest: ''
    s: 0
    sym: n
backslash__S_423o: !!perl/hash:RE_ast
  decl: []
  kind: token
  min: 24690
  pkg: ~
  re: !!perl/hash:RE_sequence
    a: 0
    dba: octal character
    i: 0
    min: 24690
    r: 1
    s: 0
    zyg:
    - !!perl/hash:RE_method
      a: 0
      dba: octal character
      i: 0
      min: 12345
      name: sym
      r: 1
      rest: ''
      s: 0
      sym: o
    - !!perl/hash:RE_bracket
      decl: []
      min: 12345
      re: &1 !!perl/hash:RE_any
        a: 0
        altname: backslash__S_423o_01
        dba: octal character
        i: 0
        min: 12345
        name: backslash__S_423o_01
        r: 1
        s: 0
        zyg:
        - !!perl/hash:RE_method
          a: 0
          alt: backslash__S_423o_01 0
          dba: octal character
          i: 0
          min: 12345
          name: octint
          r: 1
          rest: ''
          s: 0
        - !!perl/hash:RE_sequence
          a: 0
          alt: backslash__S_423o_01 1
          dba: octal character
          i: 0
          min: 12347
          r: 1
          s: 0
          zyg:
          - !!perl/hash:RE_string
            a: 0
            dba: octal character
            i: 0
            min: 1
            r: 1
            s: 0
            text: '['
          - !!perl/hash:RE_meta
            a: 0
            dba: octal character
            extra: 'local $::GOAL = '']'' '
            i: 0
            min: 0
            r: 1
            s: 0
            text: ':'
          - !!perl/hash:RE_method
            a: 0
            dba: octal character
            i: 0
            min: 12345
            name: octints
            r: 1
            rest: ''
            s: 0
          - !!perl/hash:RE_bracket
            decl: []
            min: 1
            re: !!perl/hash:RE_first
              a: 0
              dba: octal character
              i: 0
              min: 1
              r: 1
              s: 0
              zyg:
              - !!perl/hash:RE_string
                a: 0
                dba: octal character
                i: 0
                min: 1
                r: 1
                s: 0
                text: ']'
              - !!perl/hash:RE_method
                min: 0
                name: FAILGOAL
                nobind: 1
                rest: (']' , 'octal character')
backslash__S_423o_01: *1
backslash__S_424r: !!perl/hash:RE_ast
  decl: []
  kind: token
  min: 12345
  pkg: ~
  re: !!perl/hash:RE_method
    a: 0
    dba: backslash__S_424r
    i: 0
    min: 12345
    name: sym
    r: 1
    rest: ''
    s: 0
    sym: r
backslash__S_425t: !!perl/hash:RE_ast
  decl: []
  kind: token
  min: 12345
  pkg: ~
  re: !!perl/hash:RE_method
    a: 0
    dba: backslash__S_425t
    i: 0
    min: 12345
    name: sym
    r: 1
    rest: ''
    s: 0
    sym: t
backslash__S_426x: !!perl/hash:RE_ast
  decl: []
  kind: token
  min: 24690
  pkg: ~
  re: !!perl/hash:RE_sequence
    a: 0
    dba: hex character
    i: 0
    min: 24690
    r: 1
    s: 0
    zyg:
    - !!perl/hash:RE_method
      a: 0
      dba: hex character
      i: 0
      min: 12345
      name: sym
      r: 1
      rest: ''
      s: 0
      sym: x
    - !!perl/hash:RE_bracket
      decl: []
      min: 12345
      re: &2 !!perl/hash:RE_any
        a: 0
        altname: backslash__S_426x_01
        dba: hex character
        i: 0
        min: 12345
        name: backslash__S_426x_01
        r: 1
        s: 0
        zyg:
        - !!perl/hash:RE_method
          a: 0
          alt: backslash__S_426x_01 0
          dba: hex character
          i: 0
          min: 12345
          name: hexint
          r: 1
          rest: ''
          s: 0
        - !!perl/hash:RE_sequence
          a: 0
          alt: backslash__S_426x_01 1
          dba: hex character
          i: 0
          min: 12347
          r: 1
          s: 0
          zyg:
          - !!perl/hash:RE_string
            a: 0
            dba: hex character
            i: 0
            min: 1
            r: 1
            s: 0
            text: '['
          - !!perl/hash:RE_meta
            a: 0
            dba: hex character
            extra: 'local $::GOAL = '']'' '
            i: 0
            min: 0
            r: 1
            s: 0
            text: ':'
          - !!perl/hash:RE_method
            a: 0
            dba: hex character
            i: 0
            min: 12345
            name: hexints
            r: 1
            rest: ''
            s: 0
          - !!perl/hash:RE_bracket
            decl: []
            min: 1
            re: !!perl/hash:RE_first
              a: 0
              dba: hex character
              i: 0
              min: 1
              r: 1
              s: 0
              zyg:
              - !!perl/hash:RE_string
                a: 0
                dba: hex character
                i: 0
                min: 1
                r: 1
                s: 0
                text: ']'
              - !!perl/hash:RE_method
                min: 0
                name: FAILGOAL
                nobind: 1
                rest: (']' , 'hex character')
backslash__S_426x_01: *2
backslash__S_4270: !!perl/hash:RE_ast
  decl: []
  kind: token
  min: 12345
  pkg: ~
  re: !!perl/hash:RE_method
    a: 0
    dba: backslash__S_4270
    i: 0
    min: 12345
    name: sym
    r: 1
    rest: ''
    s: 0
    sym: '0'
escape__S_413Back: !!perl/hash:RE_ast
  decl: []
  kind: token
  min: 24690
  pkg: ~
  re: !!perl/hash:RE_sequence
    a: 0
    dba: escape__S_413Back
    i: 0
    min: 24690
    r: 1
    s: 0
    zyg:
    - !!perl/hash:RE_method
      a: 0
      dba: escape__S_413Back
      i: 0
      min: 12345
      name: sym
      r: 1
      rest: ''
      s: 0
      sym: \
    - !!perl/hash:RE_bindnamed
      a: 0
      atom: !!perl/hash:RE_method
        a: 0
        dba: escape__S_413Back
        i: 0
        min: 12345
        name: backslash
        nobind: 1
        r: 1
        rest: ''
        s: 0
      dba: escape__S_413Back
      i: 0
      min: 12345
      r: 1
      s: 0
      var: item
RETREE_END
}
} ## end role

{ package STD::Q::b0;
use Moose::Role ':all' => { -prefix => "moose_" };
my $retree;
##         token escape__S_428Back (:$*sym = <\\>)
##              token escape:sym<\\> { <!> }

sub escape__S_428Back__PEEK { $_[0]->_AUTOLEXpeek('escape__S_428Back',$retree) }
sub escape__S_428Back {
no warnings 'recursion';
my $self = shift;
local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;
my %args = @_;
local $::sym = $args{sym} // q(\\);


my $C = $self->cursor_xact("RULE escape__S_428Back");
my $xact = $C->xact;
my $S = $C->{'_pos'};
$C->{'sym'} = ref $sym ? join(' ', @$sym) : $sym;

$self->_MATCHIFYr($S, "escape__S_428Back", 
$C->_NOTBEFORE( sub { my $C=shift;
$C
})
);
}
BEGIN {
$retree = YAML::XS::Load(Encode::encode_utf8(<<'RETREE_END'));
---
escape__S_428Back: !!perl/hash:RE_ast
  decl: []
  kind: token
  min: 0
  pkg: ~
  re: !!perl/hash:RE_assertion
    assert: '!'
    min: 0
    re: !!perl/hash:RE_noop
      a: 0
      dba: escape__S_428Back
      i: 0
      min: 0
      nobind: 1
      r: 1
      s: 0
RETREE_END
}
} ## end role

{ package STD::Q::c1;
use Moose::Role ':all' => { -prefix => "moose_" };
my $retree;
##         token escape__S_429Cur_Ly (:$*sym = <{ }>)
##              token escape:sym<{ }> { <?before '{'> [ :lang(%*LANG<MAIN>) <embeddedblock> ] }

sub escape__S_429Cur_Ly__PEEK { $_[0]->_AUTOLEXpeek('escape__S_429Cur_Ly',$retree) }
sub escape__S_429Cur_Ly {
no warnings 'recursion';
my $self = shift;
local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;
my %args = @_;
local $::sym = $args{sym} // [qw({ })];


my $C = $self->cursor_xact("RULE escape__S_429Cur_Ly");
my $xact = $C->xact;
my $S = $C->{'_pos'};
$C->{'sym'} = ref $sym ? join(' ', @$sym) : $sym;

$self->_MATCHIFYr($S, "escape__S_429Cur_Ly", 
do {
if (my ($C) = ($C->before(sub { my $C=shift;
$C->_EXACT('{')
}))) {
$C->_BRACKETr(sub {
my $C=shift;
my $newlang = ($::LANG{'MAIN'});  $C = $C->cursor_fresh($newlang); ;$C->_SUBSUMEr(['embeddedblock'], sub {
my $C = shift;
$C->embeddedblock
})
});
}
else {
();
}
}
);
}
BEGIN {
$retree = YAML::XS::Load(Encode::encode_utf8(<<'RETREE_END'));
---
escape__S_429Cur_Ly: !!perl/hash:RE_ast
  decl: []
  kind: token
  min: 12345
  pkg: ~
  re: !!perl/hash:RE_sequence
    a: 0
    dba: escape__S_429Cur_Ly
    i: 0
    min: 12345
    r: 1
    s: 0
    zyg:
    - !!perl/hash:RE_assertion
      assert: '?'
      min: 0
      re: !!perl/hash:RE_method_re
        a: 0
        dba: escape__S_429Cur_Ly
        i: 0
        min: 0
        name: before
        nobind: 1
        r: 1
        re: !!perl/hash:RE_ast
          decl: []
          min: 1
          re: !!perl/hash:RE_string
            a: 0
            dba: escape__S_429Cur_Ly
            i: 0
            min: 1
            r: 1
            s: 0
            text: '{'
        s: 0
    - !!perl/hash:RE_bracket
      decl: []
      min: 12345
      re: !!perl/hash:RE_sequence
        a: 0
        dba: escape__S_429Cur_Ly
        i: 0
        lang: ($::LANG{'MAIN'})
        min: 12345
        r: 1
        s: 0
        zyg:
        - !!perl/hash:RE_decl
          a: 0
          dba: escape__S_429Cur_Ly
          i: 0
          lang: ($::LANG{'MAIN'})
          max: 0
          min: 0
          noquant: 1
          r: 1
          s: 0
          text: 'my $newlang = ($::LANG{''MAIN''});  $C = $C->cursor_fresh($newlang); '
        - !!perl/hash:RE_method
          a: 0
          dba: escape__S_429Cur_Ly
          i: 0
          lang: ($::LANG{'MAIN'})
          min: 12345
          name: embeddedblock
          r: 1
          rest: ''
          s: 0
RETREE_END
}
} ## end role

{ package STD::Q::c0;
use Moose::Role ':all' => { -prefix => "moose_" };
my $retree;
##         token escape__S_430Cur_Ly (:$*sym = <{ }>)
##              token escape:sym<{ }> { <!> }

sub escape__S_430Cur_Ly__PEEK { $_[0]->_AUTOLEXpeek('escape__S_430Cur_Ly',$retree) }
sub escape__S_430Cur_Ly {
no warnings 'recursion';
my $self = shift;
local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;
my %args = @_;
local $::sym = $args{sym} // [qw({ })];


my $C = $self->cursor_xact("RULE escape__S_430Cur_Ly");
my $xact = $C->xact;
my $S = $C->{'_pos'};
$C->{'sym'} = ref $sym ? join(' ', @$sym) : $sym;

$self->_MATCHIFYr($S, "escape__S_430Cur_Ly", 
$C->_NOTBEFORE( sub { my $C=shift;
$C
})
);
}
BEGIN {
$retree = YAML::XS::Load(Encode::encode_utf8(<<'RETREE_END'));
---
escape__S_430Cur_Ly: !!perl/hash:RE_ast
  decl: []
  kind: token
  min: 0
  pkg: ~
  re: !!perl/hash:RE_assertion
    assert: '!'
    min: 0
    re: !!perl/hash:RE_noop
      a: 0
      dba: escape__S_430Cur_Ly
      i: 0
      min: 0
      nobind: 1
      r: 1
      s: 0
RETREE_END
}
} ## end role

{ package STD::Q::s1;
use Moose::Role ':all' => { -prefix => "moose_" };
my $retree;
##         token escape__S_431Dollar (:$*sym = <$>)
##              token escape:sym<$> {
##                  :my $*QSIGIL ::= '$';
##                  <?before '$'>
##                  [ :lang(%*LANG<MAIN>) <EXPR(item %methodcall)> ] || <.panic: "Non-variable \$ must be backslashed">
##              }

sub escape__S_431Dollar__PEEK { $_[0]->_AUTOLEXpeek('escape__S_431Dollar',$retree) }
sub escape__S_431Dollar {
no warnings 'recursion';
my $self = shift;
local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;
my %args = @_;
local $::sym = $args{sym} // q($);
local $::QSIGIL = '$';


my $C = $self->cursor_xact("RULE escape__S_431Dollar");
my $xact = $C->xact;
my $S = $C->{'_pos'};
$C->{'sym'} = ref $sym ? join(' ', @$sym) : $sym;

$self->_MATCHIFYr($S, "escape__S_431Dollar", 
do {
my $C = $C->cursor_xact('ALT ||');
my $xact = $C->xact;
my @gather;
do {
push @gather, do {
if (my ($C) = ($C->before(sub { my $C=shift;
$C->_EXACT('$')
}))) {
$C->_BRACKETr(sub {
my $C=shift;
my $newlang = ($::LANG{'MAIN'});  $C = $C->cursor_fresh($newlang); ;$C->_SUBSUMEr(['EXPR'], sub {
my $C = shift;
$C->EXPR(\%methodcall)
})
});
}
else {
();
}
}
}
or $xact->[-2] or
do {
push @gather, $C->panic("Non-variable \$ must be backslashed")};
@gather;
}
);
}
BEGIN {
$retree = YAML::XS::Load(Encode::encode_utf8(<<'RETREE_END'));
---
escape__S_431Dollar: !!perl/hash:RE_ast
  decl:
  - !!perl/hash:RE_decl
    a: 0
    dba: escape__S_431Dollar
    i: 0
    max: 0
    min: 0
    r: 1
    s: 0
    text: my $*QSIGIL ::= '$'
  kind: token
  min: 0
  pkg: ~
  re: !!perl/hash:RE_first
    a: 0
    dba: escape__S_431Dollar
    i: 0
    min: 0
    r: 1
    s: 0
    zyg:
    - !!perl/hash:RE_sequence
      a: 0
      dba: escape__S_431Dollar
      i: 0
      min: 0
      r: 1
      s: 0
      zyg:
      - !!perl/hash:RE_assertion
        assert: '?'
        min: 0
        re: !!perl/hash:RE_method_re
          a: 0
          dba: escape__S_431Dollar
          i: 0
          min: 0
          name: before
          nobind: 1
          r: 1
          re: !!perl/hash:RE_ast
            decl: []
            min: 1
            re: !!perl/hash:RE_string
              a: 0
              dba: escape__S_431Dollar
              i: 0
              min: 1
              r: 1
              s: 0
              text: $
          s: 0
      - !!perl/hash:RE_bracket
        decl: []
        min: 0
        re: !!perl/hash:RE_sequence
          a: 0
          dba: escape__S_431Dollar
          i: 0
          lang: ($::LANG{'MAIN'})
          min: 0
          r: 1
          s: 0
          zyg:
          - !!perl/hash:RE_decl
            a: 0
            dba: escape__S_431Dollar
            i: 0
            lang: ($::LANG{'MAIN'})
            max: 0
            min: 0
            noquant: 1
            r: 1
            s: 0
            text: 'my $newlang = ($::LANG{''MAIN''});  $C = $C->cursor_fresh($newlang); '
          - !!perl/hash:RE_method
            min: 0
            name: EXPR
            rest: (item %methodcall)
    - !!perl/hash:RE_method
      min: 0
      name: panic
      nobind: 1
      rest: ("Non-variable \$ must be backslashed")
RETREE_END
}
} ## end role

{ package STD::Q::s0;
use Moose::Role ':all' => { -prefix => "moose_" };
my $retree;
##         token escape__S_432Dollar (:$*sym = <$>)
##              token escape:sym<$> { <!> }

sub escape__S_432Dollar__PEEK { $_[0]->_AUTOLEXpeek('escape__S_432Dollar',$retree) }
sub escape__S_432Dollar {
no warnings 'recursion';
my $self = shift;
local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;
my %args = @_;
local $::sym = $args{sym} // q($);


my $C = $self->cursor_xact("RULE escape__S_432Dollar");
my $xact = $C->xact;
my $S = $C->{'_pos'};
$C->{'sym'} = ref $sym ? join(' ', @$sym) : $sym;

$self->_MATCHIFYr($S, "escape__S_432Dollar", 
$C->_NOTBEFORE( sub { my $C=shift;
$C
})
);
}
BEGIN {
$retree = YAML::XS::Load(Encode::encode_utf8(<<'RETREE_END'));
---
escape__S_432Dollar: !!perl/hash:RE_ast
  decl: []
  kind: token
  min: 0
  pkg: ~
  re: !!perl/hash:RE_assertion
    assert: '!'
    min: 0
    re: !!perl/hash:RE_noop
      a: 0
      dba: escape__S_432Dollar
      i: 0
      min: 0
      nobind: 1
      r: 1
      s: 0
RETREE_END
}
} ## end role

{ package STD::Q::a1;
use Moose::Role ':all' => { -prefix => "moose_" };
my $retree;
##         token escape__S_433At (:$*sym = <@>)
##              token escape:sym<@> {
##                  :my $*QSIGIL ::= '@';
##                  <?before '@'>
##                  [ :lang(%*LANG<MAIN>) <EXPR(item %methodcall)> | <!> ] # trap ABORTBRANCH from variable's ::
##              }

sub escape__S_433At__PEEK { $_[0]->_AUTOLEXpeek('escape__S_433At',$retree) }
sub escape__S_433At {
no warnings 'recursion';
my $self = shift;
local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;
my %args = @_;
local $::sym = $args{sym} // q(@);
local $::QSIGIL = '@';


my $C = $self->cursor_xact("RULE escape__S_433At");
my $xact = $C->xact;
my $S = $C->{'_pos'};
$C->{'sym'} = ref $sym ? join(' ', @$sym) : $sym;

$self->_MATCHIFYr($S, "escape__S_433At", 
do {
if (my ($C) = ($C->before(sub { my $C=shift;
$C->_EXACT('@')
}))) {
$C->_BRACKETr(sub {
my $C=shift;
do {
my @result = do {
my $trystate;
my ($tag, $try);
my @try;
my $relex;

my $fate;
my $x;
if ($fate = $C->{'_fate'} and $fate->[1] eq 'escape__S_433At_02') {
$C->deb("Fate passed to escape__S_433At_02: ", ::fatestr($fate)) if $::DEBUG & DEBUG::fates;
($C->{'_fate'}, $tag, $try) = @$fate;
@try = ($try);
$x = 'ALT escape__S_433At_02';    # some outer ltm is controlling us
}
else {
$x = 'ALTLTM escape__S_433At_02'; # we are top level ltm
}
my $C = $C->cursor_xact($x);
my $xact = $C->xact;

my @gather = ();
for (;;) {
if (not @try) {
$relex //= $C->cursor_fate('STD::Q::a1', 'escape__S_433At_02', $retree);
@try = $relex->($C, $trystate);
}
last unless @try;
$try = shift(@try) // next;

if (ref $try eq 'ARRAY') {
($C->{'_fate'}, $tag, $try) = @$try;	# next candidate fate
}

$C->deb("escape__S_433At_02 trying $tag $try") if $::DEBUG & DEBUG::try_processing;
push @gather, ((
sub { my $C=shift;
my $newlang = ($::LANG{'MAIN'});  $C = $C->cursor_fresh($newlang); ;$C->_SUBSUMEr(['EXPR'], sub {
my $C = shift;
$C->EXPR(\%methodcall)
})
},
sub { my $C=shift;
$C->_NOTBEFORE( sub { my $C=shift;
$C
})
},
)[$try])->($C);
last if $xact->[-2];  # committed?
last if @gather;
}
@gather;
};
@result;
}

});
}
else {
();
}
}
);
}
BEGIN {
$retree = YAML::XS::Load(Encode::encode_utf8(<<'RETREE_END'));
---
escape__S_433At: !!perl/hash:RE_ast
  decl:
  - !!perl/hash:RE_decl
    a: 0
    dba: escape__S_433At
    i: 0
    max: 0
    min: 0
    r: 1
    s: 0
    text: my $*QSIGIL ::= '@'
  kind: token
  min: 0
  pkg: ~
  re: !!perl/hash:RE_sequence
    a: 0
    dba: escape__S_433At
    i: 0
    min: 0
    r: 1
    s: 0
    zyg:
    - !!perl/hash:RE_assertion
      assert: '?'
      min: 0
      re: !!perl/hash:RE_method_re
        a: 0
        dba: escape__S_433At
        i: 0
        min: 0
        name: before
        nobind: 1
        r: 1
        re: !!perl/hash:RE_ast
          decl: []
          min: 1
          re: !!perl/hash:RE_string
            a: 0
            dba: escape__S_433At
            i: 0
            min: 1
            r: 1
            s: 0
            text: '@'
        s: 0
    - !!perl/hash:RE_bracket
      decl: []
      min: 0
      re: &1 !!perl/hash:RE_any
        a: 0
        altname: escape__S_433At_02
        dba: escape__S_433At
        i: 0
        lang: ($::LANG{'MAIN'})
        min: 0
        name: escape__S_433At_02
        r: 1
        s: 0
        zyg:
        - !!perl/hash:RE_sequence
          a: 0
          alt: escape__S_433At_02 0
          dba: escape__S_433At
          i: 0
          lang: ($::LANG{'MAIN'})
          min: 0
          r: 1
          s: 0
          zyg:
          - !!perl/hash:RE_decl
            a: 0
            dba: escape__S_433At
            i: 0
            lang: ($::LANG{'MAIN'})
            max: 0
            min: 0
            noquant: 1
            r: 1
            s: 0
            text: 'my $newlang = ($::LANG{''MAIN''});  $C = $C->cursor_fresh($newlang); '
          - !!perl/hash:RE_method
            min: 0
            name: EXPR
            rest: (item %methodcall)
        - !!perl/hash:RE_assertion
          alt: escape__S_433At_02 1
          assert: '!'
          min: 0
          re: !!perl/hash:RE_noop
            a: 0
            dba: escape__S_433At
            i: 0
            lang: ($::LANG{'MAIN'})
            min: 0
            nobind: 1
            r: 1
            s: 0
escape__S_433At_02: *1
RETREE_END
}
} ## end role

{ package STD::Q::a0;
use Moose::Role ':all' => { -prefix => "moose_" };
my $retree;
##         token escape__S_434At (:$*sym = <@>)
##              token escape:sym<@> { <!> }

sub escape__S_434At__PEEK { $_[0]->_AUTOLEXpeek('escape__S_434At',$retree) }
sub escape__S_434At {
no warnings 'recursion';
my $self = shift;
local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;
my %args = @_;
local $::sym = $args{sym} // q(@);


my $C = $self->cursor_xact("RULE escape__S_434At");
my $xact = $C->xact;
my $S = $C->{'_pos'};
$C->{'sym'} = ref $sym ? join(' ', @$sym) : $sym;

$self->_MATCHIFYr($S, "escape__S_434At", 
$C->_NOTBEFORE( sub { my $C=shift;
$C
})
);
}
BEGIN {
$retree = YAML::XS::Load(Encode::encode_utf8(<<'RETREE_END'));
---
escape__S_434At: !!perl/hash:RE_ast
  decl: []
  kind: token
  min: 0
  pkg: ~
  re: !!perl/hash:RE_assertion
    assert: '!'
    min: 0
    re: !!perl/hash:RE_noop
      a: 0
      dba: escape__S_434At
      i: 0
      min: 0
      nobind: 1
      r: 1
      s: 0
RETREE_END
}
} ## end role

{ package STD::Q::h1;
use Moose::Role ':all' => { -prefix => "moose_" };
my $retree;
##         token escape__S_435Percent (:$*sym = <%>)
##              token escape:sym<%> {
##                  :my $*QSIGIL ::= '%';
##                  <?before '%'>
##                  [ :lang(%*LANG<MAIN>) <EXPR(item %methodcall)> | <!> ]
##              }

sub escape__S_435Percent__PEEK { $_[0]->_AUTOLEXpeek('escape__S_435Percent',$retree) }
sub escape__S_435Percent {
no warnings 'recursion';
my $self = shift;
local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;
my %args = @_;
local $::sym = $args{sym} // q(%);
local $::QSIGIL = '%';


my $C = $self->cursor_xact("RULE escape__S_435Percent");
my $xact = $C->xact;
my $S = $C->{'_pos'};
$C->{'sym'} = ref $sym ? join(' ', @$sym) : $sym;

$self->_MATCHIFYr($S, "escape__S_435Percent", 
do {
if (my ($C) = ($C->before(sub { my $C=shift;
$C->_EXACT('%')
}))) {
$C->_BRACKETr(sub {
my $C=shift;
do {
my @result = do {
my $trystate;
my ($tag, $try);
my @try;
my $relex;

my $fate;
my $x;
if ($fate = $C->{'_fate'} and $fate->[1] eq 'escape__S_435Percent_02') {
$C->deb("Fate passed to escape__S_435Percent_02: ", ::fatestr($fate)) if $::DEBUG & DEBUG::fates;
($C->{'_fate'}, $tag, $try) = @$fate;
@try = ($try);
$x = 'ALT escape__S_435Percent_02';    # some outer ltm is controlling us
}
else {
$x = 'ALTLTM escape__S_435Percent_02'; # we are top level ltm
}
my $C = $C->cursor_xact($x);
my $xact = $C->xact;

my @gather = ();
for (;;) {
if (not @try) {
$relex //= $C->cursor_fate('STD::Q::h1', 'escape__S_435Percent_02', $retree);
@try = $relex->($C, $trystate);
}
last unless @try;
$try = shift(@try) // next;

if (ref $try eq 'ARRAY') {
($C->{'_fate'}, $tag, $try) = @$try;	# next candidate fate
}

$C->deb("escape__S_435Percent_02 trying $tag $try") if $::DEBUG & DEBUG::try_processing;
push @gather, ((
sub { my $C=shift;
my $newlang = ($::LANG{'MAIN'});  $C = $C->cursor_fresh($newlang); ;$C->_SUBSUMEr(['EXPR'], sub {
my $C = shift;
$C->EXPR(\%methodcall)
})
},
sub { my $C=shift;
$C->_NOTBEFORE( sub { my $C=shift;
$C
})
},
)[$try])->($C);
last if $xact->[-2];  # committed?
last if @gather;
}
@gather;
};
@result;
}

});
}
else {
();
}
}
);
}
BEGIN {
$retree = YAML::XS::Load(Encode::encode_utf8(<<'RETREE_END'));
---
escape__S_435Percent: !!perl/hash:RE_ast
  decl:
  - !!perl/hash:RE_decl
    a: 0
    dba: escape__S_435Percent
    i: 0
    max: 0
    min: 0
    r: 1
    s: 0
    text: my $*QSIGIL ::= '%'
  kind: token
  min: 0
  pkg: ~
  re: !!perl/hash:RE_sequence
    a: 0
    dba: escape__S_435Percent
    i: 0
    min: 0
    r: 1
    s: 0
    zyg:
    - !!perl/hash:RE_assertion
      assert: '?'
      min: 0
      re: !!perl/hash:RE_method_re
        a: 0
        dba: escape__S_435Percent
        i: 0
        min: 0
        name: before
        nobind: 1
        r: 1
        re: !!perl/hash:RE_ast
          decl: []
          min: 1
          re: !!perl/hash:RE_string
            a: 0
            dba: escape__S_435Percent
            i: 0
            min: 1
            r: 1
            s: 0
            text: '%'
        s: 0
    - !!perl/hash:RE_bracket
      decl: []
      min: 0
      re: &1 !!perl/hash:RE_any
        a: 0
        altname: escape__S_435Percent_02
        dba: escape__S_435Percent
        i: 0
        lang: ($::LANG{'MAIN'})
        min: 0
        name: escape__S_435Percent_02
        r: 1
        s: 0
        zyg:
        - !!perl/hash:RE_sequence
          a: 0
          alt: escape__S_435Percent_02 0
          dba: escape__S_435Percent
          i: 0
          lang: ($::LANG{'MAIN'})
          min: 0
          r: 1
          s: 0
          zyg:
          - !!perl/hash:RE_decl
            a: 0
            dba: escape__S_435Percent
            i: 0
            lang: ($::LANG{'MAIN'})
            max: 0
            min: 0
            noquant: 1
            r: 1
            s: 0
            text: 'my $newlang = ($::LANG{''MAIN''});  $C = $C->cursor_fresh($newlang); '
          - !!perl/hash:RE_method
            min: 0
            name: EXPR
            rest: (item %methodcall)
        - !!perl/hash:RE_assertion
          alt: escape__S_435Percent_02 1
          assert: '!'
          min: 0
          re: !!perl/hash:RE_noop
            a: 0
            dba: escape__S_435Percent
            i: 0
            lang: ($::LANG{'MAIN'})
            min: 0
            nobind: 1
            r: 1
            s: 0
escape__S_435Percent_02: *1
RETREE_END
}
} ## end role

{ package STD::Q::h0;
use Moose::Role ':all' => { -prefix => "moose_" };
my $retree;
##         token escape__S_436Percent (:$*sym = <%>)
##              token escape:sym<%> { <!> }

sub escape__S_436Percent__PEEK { $_[0]->_AUTOLEXpeek('escape__S_436Percent',$retree) }
sub escape__S_436Percent {
no warnings 'recursion';
my $self = shift;
local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;
my %args = @_;
local $::sym = $args{sym} // q(%);


my $C = $self->cursor_xact("RULE escape__S_436Percent");
my $xact = $C->xact;
my $S = $C->{'_pos'};
$C->{'sym'} = ref $sym ? join(' ', @$sym) : $sym;

$self->_MATCHIFYr($S, "escape__S_436Percent", 
$C->_NOTBEFORE( sub { my $C=shift;
$C
})
);
}
BEGIN {
$retree = YAML::XS::Load(Encode::encode_utf8(<<'RETREE_END'));
---
escape__S_436Percent: !!perl/hash:RE_ast
  decl: []
  kind: token
  min: 0
  pkg: ~
  re: !!perl/hash:RE_assertion
    assert: '!'
    min: 0
    re: !!perl/hash:RE_noop
      a: 0
      dba: escape__S_436Percent
      i: 0
      min: 0
      nobind: 1
      r: 1
      s: 0
RETREE_END
}
} ## end role

{ package STD::Q::f1;
use Moose::Role ':all' => { -prefix => "moose_" };
my $retree;
##         token escape__S_437Amp (:$*sym = <&>)
##              token escape:sym<&> {
##                  :my $*QSIGIL ::= '&';
##                  <?before '&'>
##                  [ :lang(%*LANG<MAIN>) <EXPR(item %methodcall)> | <!> ]
##              }

sub escape__S_437Amp__PEEK { $_[0]->_AUTOLEXpeek('escape__S_437Amp',$retree) }
sub escape__S_437Amp {
no warnings 'recursion';
my $self = shift;
local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;
my %args = @_;
local $::sym = $args{sym} // q(&);
local $::QSIGIL = '&';


my $C = $self->cursor_xact("RULE escape__S_437Amp");
my $xact = $C->xact;
my $S = $C->{'_pos'};
$C->{'sym'} = ref $sym ? join(' ', @$sym) : $sym;

$self->_MATCHIFYr($S, "escape__S_437Amp", 
do {
if (my ($C) = ($C->before(sub { my $C=shift;
$C->_EXACT('&')
}))) {
$C->_BRACKETr(sub {
my $C=shift;
do {
my @result = do {
my $trystate;
my ($tag, $try);
my @try;
my $relex;

my $fate;
my $x;
if ($fate = $C->{'_fate'} and $fate->[1] eq 'escape__S_437Amp_02') {
$C->deb("Fate passed to escape__S_437Amp_02: ", ::fatestr($fate)) if $::DEBUG & DEBUG::fates;
($C->{'_fate'}, $tag, $try) = @$fate;
@try = ($try);
$x = 'ALT escape__S_437Amp_02';    # some outer ltm is controlling us
}
else {
$x = 'ALTLTM escape__S_437Amp_02'; # we are top level ltm
}
my $C = $C->cursor_xact($x);
my $xact = $C->xact;

my @gather = ();
for (;;) {
if (not @try) {
$relex //= $C->cursor_fate('STD::Q::f1', 'escape__S_437Amp_02', $retree);
@try = $relex->($C, $trystate);
}
last unless @try;
$try = shift(@try) // next;

if (ref $try eq 'ARRAY') {
($C->{'_fate'}, $tag, $try) = @$try;	# next candidate fate
}

$C->deb("escape__S_437Amp_02 trying $tag $try") if $::DEBUG & DEBUG::try_processing;
push @gather, ((
sub { my $C=shift;
my $newlang = ($::LANG{'MAIN'});  $C = $C->cursor_fresh($newlang); ;$C->_SUBSUMEr(['EXPR'], sub {
my $C = shift;
$C->EXPR(\%methodcall)
})
},
sub { my $C=shift;
$C->_NOTBEFORE( sub { my $C=shift;
$C
})
},
)[$try])->($C);
last if $xact->[-2];  # committed?
last if @gather;
}
@gather;
};
@result;
}

});
}
else {
();
}
}
);
}
BEGIN {
$retree = YAML::XS::Load(Encode::encode_utf8(<<'RETREE_END'));
---
escape__S_437Amp: !!perl/hash:RE_ast
  decl:
  - !!perl/hash:RE_decl
    a: 0
    dba: escape__S_437Amp
    i: 0
    max: 0
    min: 0
    r: 1
    s: 0
    text: my $*QSIGIL ::= '&'
  kind: token
  min: 0
  pkg: ~
  re: !!perl/hash:RE_sequence
    a: 0
    dba: escape__S_437Amp
    i: 0
    min: 0
    r: 1
    s: 0
    zyg:
    - !!perl/hash:RE_assertion
      assert: '?'
      min: 0
      re: !!perl/hash:RE_method_re
        a: 0
        dba: escape__S_437Amp
        i: 0
        min: 0
        name: before
        nobind: 1
        r: 1
        re: !!perl/hash:RE_ast
          decl: []
          min: 1
          re: !!perl/hash:RE_string
            a: 0
            dba: escape__S_437Amp
            i: 0
            min: 1
            r: 1
            s: 0
            text: '&'
        s: 0
    - !!perl/hash:RE_bracket
      decl: []
      min: 0
      re: &1 !!perl/hash:RE_any
        a: 0
        altname: escape__S_437Amp_02
        dba: escape__S_437Amp
        i: 0
        lang: ($::LANG{'MAIN'})
        min: 0
        name: escape__S_437Amp_02
        r: 1
        s: 0
        zyg:
        - !!perl/hash:RE_sequence
          a: 0
          alt: escape__S_437Amp_02 0
          dba: escape__S_437Amp
          i: 0
          lang: ($::LANG{'MAIN'})
          min: 0
          r: 1
          s: 0
          zyg:
          - !!perl/hash:RE_decl
            a: 0
            dba: escape__S_437Amp
            i: 0
            lang: ($::LANG{'MAIN'})
            max: 0
            min: 0
            noquant: 1
            r: 1
            s: 0
            text: 'my $newlang = ($::LANG{''MAIN''});  $C = $C->cursor_fresh($newlang); '
          - !!perl/hash:RE_method
            min: 0
            name: EXPR
            rest: (item %methodcall)
        - !!perl/hash:RE_assertion
          alt: escape__S_437Amp_02 1
          assert: '!'
          min: 0
          re: !!perl/hash:RE_noop
            a: 0
            dba: escape__S_437Amp
            i: 0
            lang: ($::LANG{'MAIN'})
            min: 0
            nobind: 1
            r: 1
            s: 0
escape__S_437Amp_02: *1
RETREE_END
}
} ## end role

{ package STD::Q::f0;
use Moose::Role ':all' => { -prefix => "moose_" };
my $retree;
##         token escape__S_438Amp (:$*sym = <&>)
##              token escape:sym<&> { <!> }

sub escape__S_438Amp__PEEK { $_[0]->_AUTOLEXpeek('escape__S_438Amp',$retree) }
sub escape__S_438Amp {
no warnings 'recursion';
my $self = shift;
local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;
my %args = @_;
local $::sym = $args{sym} // q(&);


my $C = $self->cursor_xact("RULE escape__S_438Amp");
my $xact = $C->xact;
my $S = $C->{'_pos'};
$C->{'sym'} = ref $sym ? join(' ', @$sym) : $sym;

$self->_MATCHIFYr($S, "escape__S_438Amp", 
$C->_NOTBEFORE( sub { my $C=shift;
$C
})
);
}
BEGIN {
$retree = YAML::XS::Load(Encode::encode_utf8(<<'RETREE_END'));
---
escape__S_438Amp: !!perl/hash:RE_ast
  decl: []
  kind: token
  min: 0
  pkg: ~
  re: !!perl/hash:RE_assertion
    assert: '!'
    min: 0
    re: !!perl/hash:RE_noop
      a: 0
      dba: escape__S_438Amp
      i: 0
      min: 0
      nobind: 1
      r: 1
      s: 0
RETREE_END
}
} ## end role

{ package STD::Q::p1;
use Moose::Role ':all' => { -prefix => "moose_" };
my $retree;
##         method postprocess ($s)
sub postprocess {
my $self = shift;
my $s = shift;

$s->parsepath }
} ## end role

{ package STD::Q::p0;
use Moose::Role ':all' => { -prefix => "moose_" };
my $retree;
##         method postprocess ($s)
sub postprocess {
my $self = shift;
my $s = shift;

$s }
} ## end role

{ package STD::Q::w1;
use Moose::Role ':all' => { -prefix => "moose_" };
my $retree;
##         method postprocess ($s)
sub postprocess {
my $self = shift;
my $s = shift;

$s->words }
} ## end role

{ package STD::Q::w0;
use Moose::Role ':all' => { -prefix => "moose_" };
my $retree;
##         method postprocess ($s)
sub postprocess {
my $self = shift;
my $s = shift;

$s }
} ## end role

{ package STD::Q::ww1;
use Moose::Role ':all' => { -prefix => "moose_" };
my $retree;
##         method postprocess ($s)
sub postprocess {
my $self = shift;
my $s = shift;

$s->words }
} ## end role

{ package STD::Q::ww0;
use Moose::Role ':all' => { -prefix => "moose_" };
my $retree;
##         method postprocess ($s)
sub postprocess {
my $self = shift;
my $s = shift;

$s }
} ## end role

{ package STD::Q::x1;
use Moose::Role ':all' => { -prefix => "moose_" };
my $retree;
##         method postprocess ($s)
sub postprocess {
my $self = shift;
my $s = shift;

$s->run }
} ## end role

{ package STD::Q::x0;
use Moose::Role ':all' => { -prefix => "moose_" };
my $retree;
##         method postprocess ($s)
sub postprocess {
my $self = shift;
my $s = shift;

$s }
} ## end role

{ package STD::Q::q;
use Moose::Role ':all' => { -prefix => "moose_" };
my $retree;
##         token stopper
##              token stopper { \' }

sub stopper__PEEK { $_[0]->_AUTOLEXpeek('stopper',$retree) }
sub stopper {
no warnings 'recursion';
my $self = shift;
local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;


my $C = $self->cursor_xact("RULE stopper");
my $xact = $C->xact;
my $S = $C->{'_pos'};

$self->_MATCHIFYr($S, "stopper", 
$C->_EXACT('\'')
);
}

##         token escape__S_439Back (:$*sym = <\\>)
##              token escape:sym<\\> { <sym> <item=.backslash> }

sub escape__S_439Back__PEEK { $_[0]->_AUTOLEXpeek('escape__S_439Back',$retree) }
sub escape__S_439Back {
no warnings 'recursion';
my $self = shift;
local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;
my %args = @_;
local $::sym = $args{sym} // q(\\);


my $C = $self->cursor_xact("RULE escape__S_439Back");
my $xact = $C->xact;
my $S = $C->{'_pos'};
$C->{'sym'} = ref $sym ? join(' ', @$sym) : $sym;

$self->_MATCHIFYr($S, "escape__S_439Back", 
do {
if (my ($C) = ($C->_PATTERN(qr/\G\\/))) {
$C->_SUBSUMEr(['item'], sub {
my $C = shift;
$C->backslash
});
}
else {
();
}
}
);
}

##         token backslash__S_440qq (:$*sym = 'qq')
##              token backslash:qq { <?before 'q'> { $<quote> = $.cursor_fresh(%*LANG<MAIN>).quote(); } }

sub backslash__S_440qq__PEEK { $_[0]->_AUTOLEXpeek('backslash__S_440qq',$retree) }
sub backslash__S_440qq {
no warnings 'recursion';
my $self = shift;
local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;
my %args = @_;
local $::sym = $args{sym} // 'qq';


my $C = $self->cursor_xact("RULE backslash__S_440qq");
my $xact = $C->xact;
my $S = $C->{'_pos'};
$C->{'sym'} = ref $sym ? join(' ', @$sym) : $sym;

$self->_MATCHIFYr($S, "backslash__S_440qq", 
do {
if (my ($C) = ($C->before(sub { my $C=shift;
$C->_EXACT('q')
}))) {
scalar(do {
my $M = $C;  $M->{'quote'} = $C->cursor_fresh($::LANG{'MAIN'})->quote(); ;
}, $C);
}
else {
();
}
}
);
}
##         token backslash__S_441Back (:$*sym = <\\>)
##              token backslash:sym<\\> { <text=.sym> }

sub backslash__S_441Back__PEEK { $_[0]->_AUTOLEXpeek('backslash__S_441Back',$retree) }
sub backslash__S_441Back {
no warnings 'recursion';
my $self = shift;
local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;
my %args = @_;
local $::sym = $args{sym} // q(\\);


my $C = $self->cursor_xact("RULE backslash__S_441Back");
my $xact = $C->xact;
my $S = $C->{'_pos'};
$C->{'sym'} = ref $sym ? join(' ', @$sym) : $sym;

$self->_MATCHIFYr($S, "backslash__S_441Back", 
$C->_PATTERN(qr/\G\\/)
);
}
##         token backslash__S_442stopper (:$*sym = 'stopper')
##              token backslash:stopper { <text=.stopper> }

sub backslash__S_442stopper__PEEK { $_[0]->_AUTOLEXpeek('backslash__S_442stopper',$retree) }
sub backslash__S_442stopper {
no warnings 'recursion';
my $self = shift;
local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;
my %args = @_;
local $::sym = $args{sym} // 'stopper';


my $C = $self->cursor_xact("RULE backslash__S_442stopper");
my $xact = $C->xact;
my $S = $C->{'_pos'};
$C->{'sym'} = ref $sym ? join(' ', @$sym) : $sym;

$self->_MATCHIFYr($S, "backslash__S_442stopper", 
$C->_SUBSUMEr(['text'], sub {
my $C = shift;
$C->stopper
})
);
}

# in single quotes, keep backslash on random character by default
##         token backslash__S_443misc (:$*sym = 'misc')
##              token backslash:misc { {} (.) { $<text> = "\\" ~ $0.Str; } }

sub backslash__S_443misc__PEEK { $_[0]->_AUTOLEXpeek('backslash__S_443misc',$retree) }
sub backslash__S_443misc {
no warnings 'recursion';
my $self = shift;
local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;
my %args = @_;
local $::sym = $args{sym} // 'misc';


my $C = $self->cursor_xact("RULE backslash__S_443misc");
my $xact = $C->xact;
my $S = $C->{'_pos'};
$C->{'sym'} = ref $sym ? join(' ', @$sym) : $sym;

$self->_MATCHIFYr($S, "backslash__S_443misc", 
do {
if (my ($C) = (scalar(do {

}, $C))) {
do {
if (my ($C) = (  $C->_SUBSUMEr(['0'], sub {
my $C = shift;
do { $C->_PAREN( sub { my $C=shift;
$C->_PATTERN(qr/\G(?s:.)/)
})}
}))) {
scalar(do {
my $M = $C;  $M->{'text'} = "\\" . $C->{'0'}->Str; ;
}, $C);
}
else {
();
}
};
}
else {
();
}
}
);
}

sub multitweak { # begin tweaks
my $self = shift;
my ($k, $v) = @_;

if (0) {}
elsif ($k eq 'single' or $k eq 'q') {
my $q = $v;  $self->panic("Too late for :q") }
elsif ($k eq 'double' or $k eq 'qq') {
my $qq = $v;  $self->panic("Too late for :qq") }
elsif ($k eq 'trans' or $k eq 'tr') {
my $tr = $v;  $self->panic("Too late for :tr") }
else { die 'NOMATCH' }
} # end tweaks

BEGIN {
$retree = YAML::XS::Load(Encode::encode_utf8(<<'RETREE_END'));
---
backslash__S_440qq: !!perl/hash:RE_ast
  decl: []
  kind: token
  min: 0
  pkg: ~
  re: !!perl/hash:RE_sequence
    a: 0
    dba: backslash__S_440qq
    i: 0
    min: 0
    r: 1
    s: 0
    zyg:
    - !!perl/hash:RE_assertion
      assert: '?'
      min: 0
      re: !!perl/hash:RE_method_re
        a: 0
        dba: backslash__S_440qq
        i: 0
        min: 0
        name: before
        nobind: 1
        r: 1
        re: !!perl/hash:RE_ast
          decl: []
          min: 1
          re: !!perl/hash:RE_string
            a: 0
            dba: backslash__S_440qq
            i: 0
            min: 1
            r: 1
            s: 0
            text: q
        s: 0
    - !!perl/hash:RE_block
      a: 0
      context: void
      dba: backslash__S_440qq
      i: 0
      min: 0
      r: 1
      s: 0
      text: ' $<quote> = $.cursor_fresh(%*LANG<MAIN>).quote(); '
backslash__S_441Back: !!perl/hash:RE_ast
  decl: []
  kind: token
  min: 12345
  pkg: ~
  re: !!perl/hash:RE_bindnamed
    a: 0
    atom: !!perl/hash:RE_method
      a: 0
      dba: backslash__S_441Back
      i: 0
      min: 12345
      name: sym
      nobind: 1
      r: 1
      rest: ''
      s: 0
      sym: \
    dba: backslash__S_441Back
    i: 0
    min: 12345
    r: 1
    s: 0
    var: text
backslash__S_442stopper: !!perl/hash:RE_ast
  decl: []
  kind: token
  min: 12345
  pkg: ~
  re: !!perl/hash:RE_bindnamed
    a: 0
    atom: !!perl/hash:RE_method
      a: 0
      dba: backslash__S_442stopper
      i: 0
      min: 12345
      name: stopper
      nobind: 1
      r: 1
      rest: ''
      s: 0
    dba: backslash__S_442stopper
    i: 0
    min: 12345
    r: 1
    s: 0
    var: text
backslash__S_443misc: !!perl/hash:RE_ast
  decl: []
  kind: token
  min: 1
  pkg: ~
  re: !!perl/hash:RE_sequence
    a: 0
    dba: backslash__S_443misc
    i: 0
    min: 1
    r: 1
    s: 0
    zyg:
    - !!perl/hash:RE_block
      a: 0
      context: void
      dba: backslash__S_443misc
      i: 0
      min: 0
      r: 1
      s: 0
      text: ''
    - !!perl/hash:RE_bindpos
      atom: !!perl/hash:RE_paren
        decl: []
        min: 1
        re: !!perl/hash:RE_meta
          a: 0
          dba: backslash__S_443misc
          i: 0
          min: 1
          r: 1
          s: 0
          text: .
      min: 1
      var: 0
    - !!perl/hash:RE_block
      a: 0
      context: void
      dba: backslash__S_443misc
      i: 0
      min: 0
      r: 1
      s: 0
      text: ' $<text> = "\\" ~ $0.Str; '
escape__S_439Back: !!perl/hash:RE_ast
  decl: []
  kind: token
  min: 24690
  pkg: ~
  re: !!perl/hash:RE_sequence
    a: 0
    dba: escape__S_439Back
    i: 0
    min: 24690
    r: 1
    s: 0
    zyg:
    - !!perl/hash:RE_method
      a: 0
      dba: escape__S_439Back
      i: 0
      min: 12345
      name: sym
      r: 1
      rest: ''
      s: 0
      sym: \
    - !!perl/hash:RE_bindnamed
      a: 0
      atom: !!perl/hash:RE_method
        a: 0
        dba: escape__S_439Back
        i: 0
        min: 12345
        name: backslash
        nobind: 1
        r: 1
        rest: ''
        s: 0
      dba: escape__S_439Back
      i: 0
      min: 12345
      r: 1
      s: 0
      var: item
stopper: !!perl/hash:RE_ast
  decl: []
  kind: token
  min: 1
  pkg: ~
  re: !!perl/hash:RE_string
    a: 0
    dba: stopper
    i: 0
    min: 1
    r: 1
    s: 0
    text: ''''
RETREE_END
}
} ## end role

{ package STD::Q::qq;
use Moose::Role ':all' => { -prefix => "moose_" };
my $retree;
moose_with(qw(STD::Q::b1 STD::Q::c1 STD::Q::s1 STD::Q::a1 STD::Q::h1 STD::Q::f1));
##         token stopper
##              token stopper { \" }

sub stopper__PEEK { $_[0]->_AUTOLEXpeek('stopper',$retree) }
sub stopper {
no warnings 'recursion';
my $self = shift;
local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;


my $C = $self->cursor_xact("RULE stopper");
my $xact = $C->xact;
my $S = $C->{'_pos'};

$self->_MATCHIFYr($S, "stopper", 
$C->_EXACT('"')
);
}
# in double quotes, omit backslash on random \W backslash by default
##         token backslash__S_444misc (:$*sym = 'misc')
##              token backslash:misc { {} [ (\W) { $<text> = $0.Str; } | $<x>=(\w) <.panic("Unrecognized backslash sequence: '\\" ~ $<x>.Str ~ "'")> ] }

sub backslash__S_444misc__PEEK { $_[0]->_AUTOLEXpeek('backslash__S_444misc',$retree) }
sub backslash__S_444misc {
no warnings 'recursion';
my $self = shift;
local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;
my %args = @_;
local $::sym = $args{sym} // 'misc';


my $C = $self->cursor_xact("RULE backslash__S_444misc");
my $xact = $C->xact;
my $S = $C->{'_pos'};
$C->{'sym'} = ref $sym ? join(' ', @$sym) : $sym;

$self->_MATCHIFYr($S, "backslash__S_444misc", 
do {
if (my ($C) = (scalar(do {

}, $C))) {
$C->_BRACKETr(sub {
my $C=shift;
do {
my @result = do {
my $trystate;
my ($tag, $try);
my @try;
my $relex;

my $fate;
my $x;
if ($fate = $C->{'_fate'} and $fate->[1] eq 'backslash__S_444misc_01') {
$C->deb("Fate passed to backslash__S_444misc_01: ", ::fatestr($fate)) if $::DEBUG & DEBUG::fates;
($C->{'_fate'}, $tag, $try) = @$fate;
@try = ($try);
$x = 'ALT backslash__S_444misc_01';    # some outer ltm is controlling us
}
else {
$x = 'ALTLTM backslash__S_444misc_01'; # we are top level ltm
}
my $C = $C->cursor_xact($x);
my $xact = $C->xact;

my @gather = ();
for (;;) {
if (not @try) {
$relex //= $C->cursor_fate('STD::Q::qq', 'backslash__S_444misc_01', $retree);
@try = $relex->($C, $trystate);
}
last unless @try;
$try = shift(@try) // next;

if (ref $try eq 'ARRAY') {
($C->{'_fate'}, $tag, $try) = @$try;	# next candidate fate
}

$C->deb("backslash__S_444misc_01 trying $tag $try") if $::DEBUG & DEBUG::try_processing;
push @gather, ((
sub { my $C=shift;
do {
if (my ($C) = (  $C->_SUBSUMEr(['0'], sub {
my $C = shift;
do { $C->_PAREN( sub { my $C=shift;
$C->_NOTCHAR( sub { my $C=shift;
$C->_PATTERN(qr/\G\w/)
})
})}
}))) {
scalar(do {
my $M = $C;  $M->{'text'} = $C->{'0'}->Str; ;
}, $C);
}
else {
();
}
}
},
sub { my $C=shift;
do {
if (my ($C) = (  $C->_SUBSUMEr(['x'], sub {
my $C = shift;
do { $C->_PAREN( sub { my $C=shift;
$C->_PATTERN(qr/\G\w/)
})}
}))) {
do { my $M = $C;
$C->panic("Unrecognized backslash sequence: '\\" . $M->{'x'}->Str . "'")
; };
}
else {
();
}
}
},
)[$try])->($C);
last if $xact->[-2];  # committed?
last if @gather;
}
@gather;
};
@result;
}

});
}
else {
();
}
}
);
}

sub multitweak { # begin tweaks
my $self = shift;
my ($k, $v) = @_;

if (0) {}
elsif ($k eq 'single' or $k eq 'q') {
my $q = $v;  $self->panic("Too late for :q") }
elsif ($k eq 'double' or $k eq 'qq') {
my $qq = $v;  $self->panic("Too late for :qq") }
elsif ($k eq 'trans' or $k eq 'tr') {
my $tr = $v;  $self->panic("Too late for :tr") }
else { die 'NOMATCH' }
} # end tweaks

BEGIN {
$retree = YAML::XS::Load(Encode::encode_utf8(<<'RETREE_END'));
---
backslash__S_444misc: !!perl/hash:RE_ast
  decl: []
  kind: token
  min: 1
  pkg: ~
  re: !!perl/hash:RE_sequence
    a: 0
    dba: backslash__S_444misc
    i: 0
    min: 1
    r: 1
    s: 0
    zyg:
    - !!perl/hash:RE_block
      a: 0
      context: void
      dba: backslash__S_444misc
      i: 0
      min: 0
      r: 1
      s: 0
      text: ''
    - !!perl/hash:RE_bracket
      decl: []
      min: 1
      re: &1 !!perl/hash:RE_any
        a: 0
        altname: backslash__S_444misc_01
        dba: backslash__S_444misc
        i: 0
        min: 1
        name: backslash__S_444misc_01
        r: 1
        s: 0
        zyg:
        - !!perl/hash:RE_sequence
          a: 0
          alt: backslash__S_444misc_01 0
          dba: backslash__S_444misc
          i: 0
          min: 1
          r: 1
          s: 0
          zyg:
          - !!perl/hash:RE_bindpos
            atom: !!perl/hash:RE_paren
              decl: []
              min: 1
              re: !!perl/hash:RE_meta
                a: 0
                dba: backslash__S_444misc
                i: 0
                min: 1
                r: 1
                s: 0
                text: \W
            min: 1
            var: 0
          - !!perl/hash:RE_block
            a: 0
            context: void
            dba: backslash__S_444misc
            i: 0
            min: 0
            r: 1
            s: 0
            text: ' $<text> = $0.Str; '
        - !!perl/hash:RE_sequence
          a: 0
          alt: backslash__S_444misc_01 1
          dba: backslash__S_444misc
          i: 0
          min: 1
          r: 1
          s: 0
          zyg:
          - !!perl/hash:RE_bindnamed
            a: 0
            atom: !!perl/hash:RE_paren
              decl: []
              min: 1
              re: !!perl/hash:RE_meta
                a: 0
                dba: backslash__S_444misc
                i: 0
                min: 1
                r: 1
                s: 0
                text: \w
            dba: backslash__S_444misc
            i: 0
            min: 1
            r: 1
            s: 0
            var: x
          - !!perl/hash:RE_method
            min: 0
            name: panic
            nobind: 1
            rest: '("Unrecognized backslash sequence: ''\\" ~ $<x>.Str ~ "''")'
backslash__S_444misc_01: *1
stopper: !!perl/hash:RE_ast
  decl: []
  kind: token
  min: 1
  pkg: ~
  re: !!perl/hash:RE_string
    a: 0
    dba: stopper
    i: 0
    min: 1
    r: 1
    s: 0
    text: '"'
RETREE_END
}
} ## end role

{ package STD::Q::tr;
use Moose::Role ':all' => { -prefix => "moose_" };
my $retree;
##         token stopper
##              token stopper { \' }

sub stopper__PEEK { $_[0]->_AUTOLEXpeek('stopper',$retree) }
sub stopper {
no warnings 'recursion';
my $self = shift;
local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;


my $C = $self->cursor_xact("RULE stopper");
my $xact = $C->xact;
my $S = $C->{'_pos'};

$self->_MATCHIFYr($S, "stopper", 
$C->_EXACT('\'')
);
}

##         token escape__S_445Back (:$*sym = <\\>)
##              token escape:sym<\\> { <sym> <item=.backslash> }

sub escape__S_445Back__PEEK { $_[0]->_AUTOLEXpeek('escape__S_445Back',$retree) }
sub escape__S_445Back {
no warnings 'recursion';
my $self = shift;
local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;
my %args = @_;
local $::sym = $args{sym} // q(\\);


my $C = $self->cursor_xact("RULE escape__S_445Back");
my $xact = $C->xact;
my $S = $C->{'_pos'};
$C->{'sym'} = ref $sym ? join(' ', @$sym) : $sym;

$self->_MATCHIFYr($S, "escape__S_445Back", 
do {
if (my ($C) = ($C->_PATTERN(qr/\G\\/))) {
$C->_SUBSUMEr(['item'], sub {
my $C = shift;
$C->backslash
});
}
else {
();
}
}
);
}
##         token escape__S_446Minus (:$*sym = <->)
##              token escape:sym<-> { <sym> <.obs('- as character range','..')> }

sub escape__S_446Minus__PEEK { $_[0]->_AUTOLEXpeek('escape__S_446Minus',$retree) }
sub escape__S_446Minus {
no warnings 'recursion';
my $self = shift;
local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;
my %args = @_;
local $::sym = $args{sym} // q(-);


my $C = $self->cursor_xact("RULE escape__S_446Minus");
my $xact = $C->xact;
my $S = $C->{'_pos'};
$C->{'sym'} = ref $sym ? join(' ', @$sym) : $sym;

$self->_MATCHIFYr($S, "escape__S_446Minus", 
do {
if (my ($C) = ($C->_PATTERN(qr/\G\-/))) {
$C->obs('- as character range','..');
}
else {
();
}
}
);
}
##         token escape__S_447DotDot (:$*sym = <..>)
##              token escape:sym<..> { <sym> }

sub escape__S_447DotDot__PEEK { $_[0]->_AUTOLEXpeek('escape__S_447DotDot',$retree) }
sub escape__S_447DotDot {
no warnings 'recursion';
my $self = shift;
local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;
my %args = @_;
local $::sym = $args{sym} // q(..);


my $C = $self->cursor_xact("RULE escape__S_447DotDot");
my $xact = $C->xact;
my $S = $C->{'_pos'};
$C->{'sym'} = ref $sym ? join(' ', @$sym) : $sym;

$self->_MATCHIFYr($S, "escape__S_447DotDot", 
$C->_PATTERN(qr/\G\.\./)
);
}

##         token backslash__S_448qq (:$*sym = 'qq')
##              token backslash:qq { <?before 'q'> { $<quote> = $.cursor_fresh(%*LANG<MAIN>).quote(); } }

sub backslash__S_448qq__PEEK { $_[0]->_AUTOLEXpeek('backslash__S_448qq',$retree) }
sub backslash__S_448qq {
no warnings 'recursion';
my $self = shift;
local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;
my %args = @_;
local $::sym = $args{sym} // 'qq';


my $C = $self->cursor_xact("RULE backslash__S_448qq");
my $xact = $C->xact;
my $S = $C->{'_pos'};
$C->{'sym'} = ref $sym ? join(' ', @$sym) : $sym;

$self->_MATCHIFYr($S, "backslash__S_448qq", 
do {
if (my ($C) = ($C->before(sub { my $C=shift;
$C->_EXACT('q')
}))) {
scalar(do {
my $M = $C;  $M->{'quote'} = $C->cursor_fresh($::LANG{'MAIN'})->quote(); ;
}, $C);
}
else {
();
}
}
);
}
##         token backslash__S_449Back (:$*sym = <\\>)
##              token backslash:sym<\\> { <text=.sym> }

sub backslash__S_449Back__PEEK { $_[0]->_AUTOLEXpeek('backslash__S_449Back',$retree) }
sub backslash__S_449Back {
no warnings 'recursion';
my $self = shift;
local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;
my %args = @_;
local $::sym = $args{sym} // q(\\);


my $C = $self->cursor_xact("RULE backslash__S_449Back");
my $xact = $C->xact;
my $S = $C->{'_pos'};
$C->{'sym'} = ref $sym ? join(' ', @$sym) : $sym;

$self->_MATCHIFYr($S, "backslash__S_449Back", 
$C->_PATTERN(qr/\G\\/)
);
}
##         token backslash__S_450stopper (:$*sym = 'stopper')
##              token backslash:stopper { <text=.stopper> }

sub backslash__S_450stopper__PEEK { $_[0]->_AUTOLEXpeek('backslash__S_450stopper',$retree) }
sub backslash__S_450stopper {
no warnings 'recursion';
my $self = shift;
local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;
my %args = @_;
local $::sym = $args{sym} // 'stopper';


my $C = $self->cursor_xact("RULE backslash__S_450stopper");
my $xact = $C->xact;
my $S = $C->{'_pos'};
$C->{'sym'} = ref $sym ? join(' ', @$sym) : $sym;

$self->_MATCHIFYr($S, "backslash__S_450stopper", 
$C->_SUBSUMEr(['text'], sub {
my $C = shift;
$C->stopper
})
);
}

# keep random backslashes like q does
##         token backslash__S_451misc (:$*sym = 'misc')
##              token backslash:misc { {} (.) { $<text> = "\\" ~ $0.Str; } }

sub backslash__S_451misc__PEEK { $_[0]->_AUTOLEXpeek('backslash__S_451misc',$retree) }
sub backslash__S_451misc {
no warnings 'recursion';
my $self = shift;
local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;
my %args = @_;
local $::sym = $args{sym} // 'misc';


my $C = $self->cursor_xact("RULE backslash__S_451misc");
my $xact = $C->xact;
my $S = $C->{'_pos'};
$C->{'sym'} = ref $sym ? join(' ', @$sym) : $sym;

$self->_MATCHIFYr($S, "backslash__S_451misc", 
do {
if (my ($C) = (scalar(do {

}, $C))) {
do {
if (my ($C) = (  $C->_SUBSUMEr(['0'], sub {
my $C = shift;
do { $C->_PAREN( sub { my $C=shift;
$C->_PATTERN(qr/\G(?s:.)/)
})}
}))) {
scalar(do {
my $M = $C;  $M->{'text'} = "\\" . $C->{'0'}->Str; ;
}, $C);
}
else {
();
}
};
}
else {
();
}
}
);
}

sub multitweak { # begin tweaks
my $self = shift;
my ($k, $v) = @_;

if (0) {}
elsif ($k eq 'single' or $k eq 'q') {
my $q = $v;  $self->panic("Too late for :q") }
elsif ($k eq 'double' or $k eq 'qq') {
my $qq = $v;  $self->panic("Too late for :qq") }
elsif ($k eq 'trans' or $k eq 'tr') {
my $tr = $v;  $self->panic("Too late for :tr") }
else { die 'NOMATCH' }
} # end tweaks

BEGIN {
$retree = YAML::XS::Load(Encode::encode_utf8(<<'RETREE_END'));
---
backslash__S_448qq: !!perl/hash:RE_ast
  decl: []
  kind: token
  min: 0
  pkg: ~
  re: !!perl/hash:RE_sequence
    a: 0
    dba: backslash__S_448qq
    i: 0
    min: 0
    r: 1
    s: 0
    zyg:
    - !!perl/hash:RE_assertion
      assert: '?'
      min: 0
      re: !!perl/hash:RE_method_re
        a: 0
        dba: backslash__S_448qq
        i: 0
        min: 0
        name: before
        nobind: 1
        r: 1
        re: !!perl/hash:RE_ast
          decl: []
          min: 1
          re: !!perl/hash:RE_string
            a: 0
            dba: backslash__S_448qq
            i: 0
            min: 1
            r: 1
            s: 0
            text: q
        s: 0
    - !!perl/hash:RE_block
      a: 0
      context: void
      dba: backslash__S_448qq
      i: 0
      min: 0
      r: 1
      s: 0
      text: ' $<quote> = $.cursor_fresh(%*LANG<MAIN>).quote(); '
backslash__S_449Back: !!perl/hash:RE_ast
  decl: []
  kind: token
  min: 12345
  pkg: ~
  re: !!perl/hash:RE_bindnamed
    a: 0
    atom: !!perl/hash:RE_method
      a: 0
      dba: backslash__S_449Back
      i: 0
      min: 12345
      name: sym
      nobind: 1
      r: 1
      rest: ''
      s: 0
      sym: \
    dba: backslash__S_449Back
    i: 0
    min: 12345
    r: 1
    s: 0
    var: text
backslash__S_450stopper: !!perl/hash:RE_ast
  decl: []
  kind: token
  min: 12345
  pkg: ~
  re: !!perl/hash:RE_bindnamed
    a: 0
    atom: !!perl/hash:RE_method
      a: 0
      dba: backslash__S_450stopper
      i: 0
      min: 12345
      name: stopper
      nobind: 1
      r: 1
      rest: ''
      s: 0
    dba: backslash__S_450stopper
    i: 0
    min: 12345
    r: 1
    s: 0
    var: text
backslash__S_451misc: !!perl/hash:RE_ast
  decl: []
  kind: token
  min: 1
  pkg: ~
  re: !!perl/hash:RE_sequence
    a: 0
    dba: backslash__S_451misc
    i: 0
    min: 1
    r: 1
    s: 0
    zyg:
    - !!perl/hash:RE_block
      a: 0
      context: void
      dba: backslash__S_451misc
      i: 0
      min: 0
      r: 1
      s: 0
      text: ''
    - !!perl/hash:RE_bindpos
      atom: !!perl/hash:RE_paren
        decl: []
        min: 1
        re: !!perl/hash:RE_meta
          a: 0
          dba: backslash__S_451misc
          i: 0
          min: 1
          r: 1
          s: 0
          text: .
      min: 1
      var: 0
    - !!perl/hash:RE_block
      a: 0
      context: void
      dba: backslash__S_451misc
      i: 0
      min: 0
      r: 1
      s: 0
      text: ' $<text> = "\\" ~ $0.Str; '
escape__S_445Back: !!perl/hash:RE_ast
  decl: []
  kind: token
  min: 24690
  pkg: ~
  re: !!perl/hash:RE_sequence
    a: 0
    dba: escape__S_445Back
    i: 0
    min: 24690
    r: 1
    s: 0
    zyg:
    - !!perl/hash:RE_method
      a: 0
      dba: escape__S_445Back
      i: 0
      min: 12345
      name: sym
      r: 1
      rest: ''
      s: 0
      sym: \
    - !!perl/hash:RE_bindnamed
      a: 0
      atom: !!perl/hash:RE_method
        a: 0
        dba: escape__S_445Back
        i: 0
        min: 12345
        name: backslash
        nobind: 1
        r: 1
        rest: ''
        s: 0
      dba: escape__S_445Back
      i: 0
      min: 12345
      r: 1
      s: 0
      var: item
escape__S_446Minus: !!perl/hash:RE_ast
  decl: []
  kind: token
  min: 12345
  pkg: ~
  re: !!perl/hash:RE_sequence
    a: 0
    dba: escape__S_446Minus
    i: 0
    min: 12345
    r: 1
    s: 0
    zyg:
    - !!perl/hash:RE_method
      a: 0
      dba: escape__S_446Minus
      i: 0
      min: 12345
      name: sym
      r: 1
      rest: ''
      s: 0
      sym: '-'
    - !!perl/hash:RE_method
      min: 0
      name: obs
      nobind: 1
      rest: ('- as character range','..')
escape__S_447DotDot: !!perl/hash:RE_ast
  decl: []
  kind: token
  min: 12345
  pkg: ~
  re: !!perl/hash:RE_method
    a: 0
    dba: escape__S_447DotDot
    i: 0
    min: 12345
    name: sym
    r: 1
    rest: ''
    s: 0
    sym: ..
stopper: !!perl/hash:RE_ast
  decl: []
  kind: token
  min: 1
  pkg: ~
  re: !!perl/hash:RE_string
    a: 0
    dba: stopper
    i: 0
    min: 1
    r: 1
    s: 0
    text: ''''
RETREE_END
}
} ## end role

{ package STD::Q::p5;
use Moose::Role ':all' => { -prefix => "moose_" };
my $retree;
sub multitweak { # begin tweaks
my $self = shift;
my ($k, $v) = @_;

if (0) {}
elsif ($k eq 'g') {
my $g = $v;  $self }
elsif ($k eq 'i') {
my $i = $v;  $self }
elsif ($k eq 'm') {
my $m = $v;  $self }
elsif ($k eq 's') {
my $s = $v;  $self }
elsif ($k eq 'x') {
my $x = $v;  $self }
elsif ($k eq 'p') {
my $p = $v;  $self }
elsif ($k eq 'c') {
my $c = $v;  $self }
else { die 'NOMATCH' }
} # end tweaks
} ## end role

sub multitweak { # begin tweaks
my $self = shift;
my ($k, $v) = @_;

if (0) {}

elsif ($k eq 'single' or $k eq 'q') {
my $q = $v;  $self->truly($q,':q'); $self->mixin( 'STD::Q::q' ); }

elsif ($k eq 'double' or $k eq 'qq') {
my $qq = $v;  $self->truly($qq, ':qq'); $self->mixin( 'STD::Q::qq' ); }
elsif ($k eq 'trans' or $k eq 'tr') {
my $tr = $v;  $self->truly($tr, ':tr'); $self->mixin( 'STD::Q::tr' ); }

elsif ($k eq 'backslash' or $k eq 'b') {
my $b = $v;  $self->mixin($b ? 'STD::Q::b1' : 'STD::Q::b0') }
elsif ($k eq 'scalar' or $k eq 's') {
my $s = $v;  $self->mixin($s ? 'STD::Q::s1' : 'STD::Q::s0') }
elsif ($k eq 'array' or $k eq 'a') {
my $a = $v;  $self->mixin($a ? 'STD::Q::a1' : 'STD::Q::a0') }
elsif ($k eq 'hash' or $k eq 'h') {
my $h = $v;  $self->mixin($h ? 'STD::Q::h1' : 'STD::Q::h0') }
elsif ($k eq 'function' or $k eq 'f') {
my $f = $v;  $self->mixin($f ? 'STD::Q::f1' : 'STD::Q::f0') }
elsif ($k eq 'closure' or $k eq 'c') {
my $c = $v;  $self->mixin($c ? 'STD::Q::c1' : 'STD::Q::c0') }

elsif ($k eq 'path' or $k eq 'p') {
my $p = $v;  $self->mixin($p ? 'STD::Q::p1' : 'STD::Q::p0') }
elsif ($k eq 'exec' or $k eq 'x') {
my $x = $v;  $self->mixin($x ? 'STD::Q::x1' : 'STD::Q::x0') }
elsif ($k eq 'words' or $k eq 'w') {
my $w = $v;  $self->mixin($w ? 'STD::Q::w1' : 'STD::Q::w0') }
elsif ($k eq 'quotewords' or $k eq 'ww') {
my $ww = $v;  $self->mixin($ww ? 'STD::Q::ww1' : 'STD::Q::ww0') }

elsif ($k eq 'heredoc' or $k eq 'to') {
my $to = $v;  $self->truly($to, ':to'); $self->cursor_herelang; }

elsif ($k eq 'regex') {
my $regex = $v; 
return $::LANG{'Regex'};
}

elsif ($k eq 'trans') {
my $trans = $v; 
return $::LANG{'Trans'};
}

elsif (1) {
my %x = ($k, $v); 
my @k = keys(%x);
$self->panic("Unrecognized quote modifier: " . join('',@k));
}
else { die 'NOMATCH' }
} # end tweaks


} ## end grammar

{ package STD::Quasi;
use Moose ':all' => { -prefix => "moose_" };
my $retree;
moose_extends(qw(STD::P6));##     token term__S_452unquote (:$*sym = 'unquote')
##          token term:unquote {
##              :my $*QUASIMODO = 0;
##              <starter><starter><starter> <.ws>
##              [ <EXPR> <stopper><stopper><stopper> || <.panic: "Confused"> ]
##          }

sub term__S_452unquote__PEEK { $_[0]->_AUTOLEXpeek('term__S_452unquote',$retree) }
sub term__S_452unquote {
no warnings 'recursion';
my $self = shift;
local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;
my %args = @_;
local $::sym = $args{sym} // 'unquote';
local $::QUASIMODO = 0;


my $C = $self->cursor_xact("RULE term__S_452unquote");
my $xact = $C->xact;
my $S = $C->{'_pos'};
$C->{'stopper'} = [];
$C->{'starter'} = [];
$C->{'sym'} = ref $sym ? join(' ', @$sym) : $sym;

$self->_MATCHIFYr($S, "term__S_452unquote", 
do {
if (my ($C) = ($C->_SUBSUMEr(['starter'], sub {
my $C = shift;
$C->starter
}))) {
do {
if (my ($C) = ($C->_SUBSUMEr(['starter'], sub {
my $C = shift;
$C->starter
}))) {
do {
if (my ($C) = ($C->_SUBSUMEr(['starter'], sub {
my $C = shift;
$C->starter
}))) {
do {
if (my ($C) = ($C->ws)) {
$C->_BRACKETr(sub {
my $C=shift;
do {
my $C = $C->cursor_xact('ALT ||');
my $xact = $C->xact;
my @gather;
do {
push @gather, do {
if (my ($C) = ($C->_SUBSUMEr(['EXPR'], sub {
my $C = shift;
$C->EXPR
}))) {
do {
if (my ($C) = ($C->_SUBSUMEr(['stopper'], sub {
my $C = shift;
$C->stopper
}))) {
do {
if (my ($C) = ($C->_SUBSUMEr(['stopper'], sub {
my $C = shift;
$C->stopper
}))) {
$C->_SUBSUMEr(['stopper'], sub {
my $C = shift;
$C->stopper
});
}
else {
();
}
};
}
else {
();
}
};
}
else {
();
}
}
}
or $xact->[-2] or
do {
push @gather, $C->panic("Confused")};
@gather;
}
});
}
else {
();
}
};
}
else {
();
}
};
}
else {
();
}
};
}
else {
();
}
}
);
}

sub multitweak { # begin tweaks
my $self = shift;
my ($k, $v) = @_;

if (0) {}
elsif ($k eq 'ast') {
my $ast = $v;  $self; } # XXX some transformer operating on the normal AST?
elsif ($k eq 'lang') {
my $lang = $v;  $self->cursor_fresh( $lang ); }
elsif ($k eq 'unquote') {
my $unquote = $v;  $self; } # XXX needs to override unquote
elsif ($k eq 'COMPILING') {
my $COMPILING = $v;  $::QUASIMODO = 1; $self; } # XXX needs to lazify the lexical lookups somehow

elsif (1) {
my %x = ($k, $v); 
my @k = keys(%x);
$self->panic("Unrecognized quasiquote modifier: " . join('',@k));
}
else { die 'NOMATCH' }
} # end tweaks

BEGIN {
$retree = YAML::XS::Load(Encode::encode_utf8(<<'RETREE_END'));
---
term__S_452unquote: !!perl/hash:RE_ast
  decl:
  - !!perl/hash:RE_decl
    a: 0
    dba: term__S_452unquote
    i: 0
    max: 0
    min: 0
    r: 1
    s: 0
    text: my $*QUASIMODO = 0
  kind: token
  min: 49380
  pkg: ~
  re: !!perl/hash:RE_sequence
    a: 0
    dba: term__S_452unquote
    i: 0
    min: 49380
    r: 1
    s: 0
    zyg:
    - !!perl/hash:RE_method
      a: 0
      dba: term__S_452unquote
      i: 0
      min: 12345
      name: starter
      r: 1
      rest: ''
      s: 0
    - !!perl/hash:RE_method
      a: 0
      dba: term__S_452unquote
      i: 0
      min: 12345
      name: starter
      r: 1
      rest: ''
      s: 0
    - !!perl/hash:RE_method
      a: 0
      dba: term__S_452unquote
      i: 0
      min: 12345
      name: starter
      r: 1
      rest: ''
      s: 0
    - !!perl/hash:RE_method
      a: 0
      dba: term__S_452unquote
      i: 0
      min: 12345
      name: ws
      nobind: 1
      r: 1
      rest: ''
      s: 0
    - !!perl/hash:RE_bracket
      decl: []
      min: 0
      re: !!perl/hash:RE_first
        a: 0
        dba: term__S_452unquote
        i: 0
        min: 0
        r: 1
        s: 0
        zyg:
        - !!perl/hash:RE_sequence
          a: 0
          dba: term__S_452unquote
          i: 0
          min: 49380
          r: 1
          s: 0
          zyg:
          - !!perl/hash:RE_method
            a: 0
            dba: term__S_452unquote
            i: 0
            min: 12345
            name: EXPR
            r: 1
            rest: ''
            s: 0
          - !!perl/hash:RE_method
            a: 0
            dba: term__S_452unquote
            i: 0
            min: 12345
            name: stopper
            r: 1
            rest: ''
            s: 0
          - !!perl/hash:RE_method
            a: 0
            dba: term__S_452unquote
            i: 0
            min: 12345
            name: stopper
            r: 1
            rest: ''
            s: 0
          - !!perl/hash:RE_method
            a: 0
            dba: term__S_452unquote
            i: 0
            min: 12345
            name: stopper
            r: 1
            rest: ''
            s: 0
        - !!perl/hash:RE_method
          min: 0
          name: panic
          nobind: 1
          rest: ("Confused")
RETREE_END
}
} ## end grammar

##############################
# Operator Precedence Parser #
##############################

sub EXPR__PEEK { $_[0]->_AUTOLEXpeek('EXPR',$retree) }
## method EXPR ($preclvl)
sub EXPR {
my $self = shift;
my $preclvl = shift;


local $::CTX = $self->callm if $::DEBUG & DEBUG::trace_call;
if ($self->peek) {
return $self->_AUTOLEXpeek('EXPR');
}
my $preclim = $preclvl ? $preclvl->{'prec'} // $LOOSEST : $LOOSEST;
local $::LEFTSIGIL = '';
local $::PRECLIM = $preclim;
my @termstack;
my @opstack;
my $termish = 'termish';

push @opstack, { 'O' => \%terminator, 'sym' => '' };         # (just a sentinel value)

my $here = $self;
my $S = $here->{'_pos'};
$self->deb("In EXPR, at $S") if $::DEBUG & DEBUG::EXPR;

my $reduce = sub {
$self->deb("entering reduce, termstack == ", 0+@termstack, " opstack == ", 0+@opstack) if $::DEBUG & DEBUG::EXPR;
my $op = pop @opstack;
my $sym = $op->{'sym'};
given ($op->{'O'}{'assoc'} // 'unary') {
when ('chain') {
$self->deb("reducing chain") if $::DEBUG & DEBUG::EXPR;
my @chain;
push @chain, pop(@termstack);
push @chain, $op;
while (@opstack) {
last if $op->{'O'}{'prec'} ne $opstack[-1]{'O'}{'prec'};
push @chain, pop(@termstack);
push @chain, pop(@opstack);
}
push @chain, pop(@termstack);
my $endpos = $chain[0]{'_pos'};
@chain = reverse @chain if @chain > 1;
my $startpos = $chain[0]{'_from'};
my $nop = $op->cursor_fresh();
$nop->{'chain'} = [@chain];
$nop->{'_arity'} = 'CHAIN';
$nop->{'_from'} = $startpos;
$nop->{'_pos'} = $endpos;
my @caps;
my $i = 0;
for (@chain) {
push(@caps, $i++ % 2 ? 'op' : 'term' );
push(@caps, $_);
}
$nop->{'~CAPS'} = \@caps;
push @termstack, $nop->_REDUCE($startpos, 'CHAIN');
delete $termstack[-1]->{'PRE'};
delete $termstack[-1]->{'POST'};
}
when ('list') {
$self->deb("reducing list") if $::DEBUG & DEBUG::EXPR;
my @list;
my @delims = $op;
push @list, pop(@termstack);
while (@opstack) {
$self->deb($sym . " vs " . $opstack[-1]{'sym'}) if $::DEBUG & DEBUG::EXPR;
last if $sym ne $opstack[-1]{'sym'};
if (@termstack and defined $termstack[0]) {
push @list, pop(@termstack);
}
else {
$self->worry("Missing term in " . $sym . " list");
}
push @delims, pop(@opstack);
}
if (@termstack and defined $termstack[0]) {
push @list, pop(@termstack);
}
else {
$self->worry("Missing final term in '" . $sym . "' list");
}
my $endpos = $list[0]{'_pos'};
@list = reverse @list if @list > 1;
my $startpos = $list[0]{'_from'};
@delims = reverse @delims if @delims > 1;
my $nop = $op->cursor_fresh();
$nop->{'sym'} = $sym;
$nop->{'O'} = $op->{'O'};
$nop->{'list'} = [@list];
$nop->{'delims'} = [@delims];
$nop->{'_arity'} = 'LIST';
$nop->{'_from'} = $startpos;
$nop->{'_pos'} = $endpos;
if (@list) {
my @caps;
push @caps, 'elem', $list[0] if $list[0];
for (0..@delims-1) {
my $d = $delims[$_];
my $l = $list[$_+1];
push @caps, 'delim', $d;
push @caps, 'elem', $l if $l;  # nullterm?
}
$nop->{'~CAPS'} = \@caps;
}
push @termstack, $nop->_REDUCE($startpos, 'LIST');
delete $termstack[-1]->{'PRE'};
delete $termstack[-1]->{'POST'};
}
when ('unary') {
$self->deb("reducing") if $::DEBUG & DEBUG::EXPR;
$self->deb("Termstack size: ", 0+@termstack) if $::DEBUG & DEBUG::EXPR;

$self->deb($op->dump) if $::DEBUG & DEBUG::EXPR;
my $nop = $op->cursor_fresh();
my $arg = pop @termstack;
$op->{'arg'} = $arg;
my $a = $op->{'~CAPS'};
$op->{'_arity'} = 'UNARY';
if ($arg->{'_from'} < $op->{'_from'}) { # postfix
$op->{'_from'} = $arg->{'_from'};   # extend from to include arg
#                    warn "OOPS ", $arg.Str, "\n" if @acaps > 1;
unshift @$a, 'arg', $arg;
push @termstack, $op->_REDUCE($op->{'_from'}, 'POSTFIX');
delete $termstack[-1]->{'PRE'};
delete $termstack[-1]->{'POST'};
}
elsif ($arg->{'_pos'} > $op->{'_pos'}) {   # prefix
$op->{'_pos'} = $arg->{'_pos'};     # extend pos to include arg
#                    warn "OOPS ", $arg.Str, "\n" if @acaps > 1;
push @$a, 'arg', $arg;
push @termstack, $op->_REDUCE($op->{'_from'}, 'PREFIX');
delete $termstack[-1]->{'PRE'};
delete $termstack[-1]->{'POST'};
}
}
default {
$self->deb("reducing") if $::DEBUG & DEBUG::EXPR;
$self->deb("Termstack size: ", 0+@termstack) if $::DEBUG & DEBUG::EXPR;

my $right = pop @termstack;
my $left = pop @termstack;
$op->{'right'} = $right;
$op->{'left'} = $left;
$op->{'_from'} = $left->{'_from'};
$op->{'_pos'} = $right->{'_pos'};
$op->{'_arity'} = 'BINARY';

my $a = $op->{'~CAPS'};
unshift @$a, 'left', $left;
push @$a, 'right', $right;

$self->deb($op->dump) if $::DEBUG & DEBUG::EXPR;
my $ck;
if ($ck = $op->{'O'}{'_reducecheck'}) {
$op = $op->$ck;
}
push @termstack, $op->_REDUCE($op->{'_from'}, 'INFIX');
delete $termstack[-1]->{'PRE'};
delete $termstack[-1]->{'POST'};
}
}
};

TERM:
for (;;) {
$self->deb("In loop, at ", $here->{'_pos'}) if $::DEBUG & DEBUG::EXPR;
my $oldpos = $here->{'_pos'};
$here = $here->cursor_fresh();
$::LEFTSIGIL = $opstack[-1]{'O'}{'prec'} gt $item_assignment_prec ? '@' : '';
my @t = $here->$termish;

if (not @t or not $here = $t[0] or ($here->{'_pos'} == $oldpos and $termish eq 'termish')) {
$here->panic("Bogus term") if @opstack > 1;
return ();
# $here.panic("Failed to parse a required term");
}
$termish = 'termish';
my $PRE = delete $here->{'PRE'} // [];
my $POST = delete $here->{'POST'} // [];
my @PRE = @$PRE;
my @POST = reverse @$POST;

# interleave prefix and postfix, pretend they're infixish
my $M = $here;

# note that we push loose stuff onto opstack before tight stuff
while (@PRE and @POST) {
my $postO = $POST[0]{'O'};
my $preO = $PRE[0]{'O'};
if ($postO->{'prec'} lt $preO->{'prec'}) {
push @opstack, shift @POST;
}
elsif ($postO->{'prec'} gt $preO->{'prec'}) {
push @opstack, shift @PRE;
}
elsif ($postO->{'uassoc'} eq 'left') {
push @opstack, shift @POST;
}
elsif ($postO->{'uassoc'} eq 'right') {
push @opstack, shift @PRE;
}
else {
$here->panic('"' . $PRE[0]{'sym'} . '" and "' . $POST[0]{'sym'} . '" are not associative');
}
}
push @opstack, @PRE,@POST;

push @termstack, $here->{'term'};
delete $termstack[-1]->{'POST'};
$self->deb("after push: " . (0+@termstack)) if $::DEBUG & DEBUG::EXPR;

last TERM if $preclim eq $methodcall_prec; # in interpolation, probably

for (;;) {     # while we see adverbs
$oldpos = $here->{'_pos'};
last TERM if ($::MEMOS[$oldpos]{'endstmt'} // 0) == 2;
$here = $here->cursor_fresh->ws;
my @infix = $here->cursor_fresh->infixish();
last TERM unless @infix;
my $infix = $infix[0];
last TERM unless $infix->{'_pos'} > $oldpos;

if (not $infix->{'sym'}) {
die $infix->dump if $::DEBUG & DEBUG::EXPR;
}

my $inO = $infix->{'O'};
my $inprec = $inO->{'prec'};
if (not defined $inprec) {
$self->deb("No prec given in infix!") if $::DEBUG & DEBUG::EXPR;
die $infix->dump if $::DEBUG & DEBUG::EXPR;
$inprec = $terminator{'prec'};
}

if ($inprec le $preclim) {
if ($preclim ne $LOOSEST) {
my $dba = $preclvl->{'dba'};
my $h = $::HIGHEXPECT;
%$h = ();
$h->{"an infix operator with precedence tighter than $dba"} = 1;
}
last TERM;
}

$here = $infix->cursor_fresh->ws();

# substitute precedence for listops
$inO->{'prec'} = $inO->{'sub'} if $inO->{'sub'};

# Does new infix (or terminator) force any reductions?
while ($opstack[-1]{'O'}{'prec'} gt $inprec) {
$reduce->();
}

# Not much point in reducing the sentinels...
last if $inprec lt $LOOSEST;

if ($infix->{'fake'}) {
push @opstack, $infix;
$reduce->();
next;  # not really an infix, so keep trying
}

# Equal precedence, so use associativity to decide.
if ($opstack[-1]{'O'}{'prec'} eq $inprec) {
my $assoc = 1;
given ($inO->{'assoc'}) {
when ('non')   { $assoc = 0; }
when ('left')  { $reduce->() }   # reduce immediately
when ('right') { }            # just shift
when ('chain') { }            # just shift
when ('unary') { }            # just shift
when ('list')  {
$assoc = 0 unless $infix->{'sym'} eq $opstack[-1]{'sym'};
}
default { $here->panic('Unknown associativity "' . $_ . '" for "' . $infix->{'sym'} . '"') }
}
if (not $assoc) {
$here->panic('"' . $opstack[-1]{'sym'} . '" and "' . $infix->Str . '" are non-associative and require parens');
}
}

$termish = $inO->{'nextterm'} if $inO->{'nextterm'};
push @opstack, $infix;              # The Shift
last;
}
}
$reduce->() while 0+@opstack > 1;
if (@termstack) {
0+@termstack == 1 or $here->panic("Internal operator parser error, termstack == " . (0+@termstack));
$termstack[0]{'_from'} = $self->{'_pos'};
$termstack[0]{'_pos'} = $here->{'_pos'};
}
$self->_MATCHIFYr($S, "EXPR", @termstack);
}

##########
## Regex #
##########

{ package STD::Regex;
use Moose ':all' => { -prefix => "moose_" };
my $retree;
moose_extends(qw(STD));
sub multitweak { # begin tweaks
my $self = shift;
my ($k, $v) = @_;

if (0) {}
elsif ($k eq 'Perl5' or $k eq 'P5') {
my $P5 = $v;  $self->require_P5; $self->cursor_fresh( $::LANG{'Q'} )->mixin( 'STD::Q::q' )->mixin( 'STD::Q::p5' ) }
elsif ($k eq 'overlap' or $k eq 'ov') {
my $ov = $v;  $::RX{'ov'} = $ov; $self; }
elsif ($k eq 'exhaustive' or $k eq 'ex') {
my $ex = $v;  $::RX{'ex'} = $ex; $self; }
elsif ($k eq 'continue' or $k eq 'c') {
my $c = $v;  $::RX{'c'} = $c; $self; }
elsif ($k eq 'pos' or $k eq 'p') {
my $p = $v;  $::RX{'p'} = $p; $self; }
elsif ($k eq 'sigspace' or $k eq 's') {
my $s = $v;  $::RX{'s'} = $s; $self; }
elsif ($k eq 'ratchet' or $k eq 'r') {
my $r = $v;  $::RX{'r'} = $r; $self; }
elsif ($k eq 'global' or $k eq 'g') {
my $g = $v;  $::RX{'g'} = $g; $self; }
elsif ($k eq 'ignorecase' or $k eq 'i') {
my $i = $v;  $::RX{'i'} = $i; $self; }
elsif ($k eq 'ignoreaccent' or $k eq 'a') {
my $a = $v;  $::RX{'a'} = $a; $self; }
elsif ($k eq 'samecase' or $k eq 'ii') {
my $ii = $v;  $::RX{'ii'} = $ii; $self; }
elsif ($k eq 'sameaccent' or $k eq 'aa') {
my $aa = $v;  $::RX{'aa'} = $aa; $self; }
elsif ($k eq 'nth') {
my $nth = $v;  $::RX{'nth'} = $nth; $self; }
elsif ($k eq 'st' or $k eq 'nd') {
my $nd = $v;  $::RX{'nth'} = $nd; $self; }
elsif ($k eq 'rd' or $k eq 'th') {
my $th = $v;  $::RX{'nth'} = $th; $self; }
elsif ($k eq 'x') {
my $x = $v;  $::RX{'x'} = $x; $self; }
elsif ($k eq 'bytes') {
my $bytes = $v;  $::RX{'bytes'} = $bytes; $self; }
elsif ($k eq 'codes') {
my $codes = $v;  $::RX{'codes'} = $codes; $self; }
elsif ($k eq 'graphs') {
my $graphs = $v;  $::RX{'graphs'} = $graphs; $self; }
elsif ($k eq 'chars') {
my $chars = $v;  $::RX{'chars'} = $chars; $self; }
elsif ($k eq 'rw') {
my $rw = $v;  $::RX{'rw'} = $rw; $self; }
else { die 'NOMATCH' }
} # end tweaks

##     token category__S_453metachar (:$*sym = 'metachar')
##          token category:metachar { <sym> }

sub category__S_453metachar__PEEK { $_[0]->_AUTOLEXpeek('category__S_453metachar',$retree) }
sub category__S_453metachar {
no warnings 'recursion';
my $self = shift;
local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;
my %args = @_;
local $::sym = $args{sym} // 'metachar';


my $C = $self->cursor_xact("RULE category__S_453metachar");
my $xact = $C->xact;
my $S = $C->{'_pos'};
$C->{'sym'} = ref $sym ? join(' ', @$sym) : $sym;

$self->_MATCHIFYr($S, "category__S_453metachar", 
$C->_PATTERN(qr/\Gmetachar/)
);
}
#proto token metachar { <...> }
sub metachar__PEEK { $_[0]->_AUTOLEXpeek('metachar:*',$retree); }
sub metachar {
my $self = shift;
my $subs;

local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;

my $C = $self->cursor_xact('RULE metachar');
my $S = $C->{'_pos'};

my @result = do {
my $trystate;
my ($tag, $try);
my @try;
my $relex;
my $x;
if (my $fate = $C->{'_fate'}) {
if ($fate->[1] eq 'metachar') {
$C->deb("Fate passed to metachar: ", ::fatestr($fate)) if $::DEBUG & DEBUG::fates;
($C->{'_fate'}, $tag, $try) = @$fate;
@try = ($try);
$x = 'ALT metachar';
}
else {
$x = 'ALTLTM metachar';
}
}
else {
$x = 'ALTLTM metachar';
}
my $C = $C->cursor_xact($x);
my $xact = $C->xact;

my @gather = ();
for (;;) {
if (not @try) {
$relex //= $C->cursor_fate('STD::Regex', 'metachar:*', $retree);
@try = $relex->($C, $trystate);
}
last unless @try;
$try = shift(@try) // next;

if (ref $try eq 'ARRAY') {
($C->{'_fate'}, $tag, $try) = @$try;	# next candidate fate
}

$C->deb("metachar trying $tag $try") if $::DEBUG & DEBUG::try_processing;
push @gather, $C->$try(@_);
last if $xact->[-2];  # committed?
last if @gather;
}
$self->_MATCHIFYr($S, "metachar", @gather);
};
@result;
}


##     token category__S_454backslash (:$*sym = 'backslash')
##          token category:backslash { <sym> }

sub category__S_454backslash__PEEK { $_[0]->_AUTOLEXpeek('category__S_454backslash',$retree) }
sub category__S_454backslash {
no warnings 'recursion';
my $self = shift;
local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;
my %args = @_;
local $::sym = $args{sym} // 'backslash';


my $C = $self->cursor_xact("RULE category__S_454backslash");
my $xact = $C->xact;
my $S = $C->{'_pos'};
$C->{'sym'} = ref $sym ? join(' ', @$sym) : $sym;

$self->_MATCHIFYr($S, "category__S_454backslash", 
$C->_PATTERN(qr/\Gbackslash/)
);
}
#proto token backslash { <...> }
sub backslash__PEEK { $_[0]->_AUTOLEXpeek('backslash:*',$retree); }
sub backslash {
my $self = shift;
my $subs;

local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;

my $C = $self->cursor_xact('RULE backslash');
my $S = $C->{'_pos'};

my @result = do {
my $trystate;
my ($tag, $try);
my @try;
my $relex;
my $x;
if (my $fate = $C->{'_fate'}) {
if ($fate->[1] eq 'backslash') {
$C->deb("Fate passed to backslash: ", ::fatestr($fate)) if $::DEBUG & DEBUG::fates;
($C->{'_fate'}, $tag, $try) = @$fate;
@try = ($try);
$x = 'ALT backslash';
}
else {
$x = 'ALTLTM backslash';
}
}
else {
$x = 'ALTLTM backslash';
}
my $C = $C->cursor_xact($x);
my $xact = $C->xact;

my @gather = ();
for (;;) {
if (not @try) {
$relex //= $C->cursor_fate('STD::Regex', 'backslash:*', $retree);
@try = $relex->($C, $trystate);
}
last unless @try;
$try = shift(@try) // next;

if (ref $try eq 'ARRAY') {
($C->{'_fate'}, $tag, $try) = @$try;	# next candidate fate
}

$C->deb("backslash trying $tag $try") if $::DEBUG & DEBUG::try_processing;
push @gather, $C->$try(@_);
last if $xact->[-2];  # committed?
last if @gather;
}
$self->_MATCHIFYr($S, "backslash", @gather);
};
@result;
}


##     token category__S_455assertion (:$*sym = 'assertion')
##          token category:assertion { <sym> }

sub category__S_455assertion__PEEK { $_[0]->_AUTOLEXpeek('category__S_455assertion',$retree) }
sub category__S_455assertion {
no warnings 'recursion';
my $self = shift;
local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;
my %args = @_;
local $::sym = $args{sym} // 'assertion';


my $C = $self->cursor_xact("RULE category__S_455assertion");
my $xact = $C->xact;
my $S = $C->{'_pos'};
$C->{'sym'} = ref $sym ? join(' ', @$sym) : $sym;

$self->_MATCHIFYr($S, "category__S_455assertion", 
$C->_PATTERN(qr/\Gassertion/)
);
}
#proto token assertion { <...> }
sub assertion__PEEK { $_[0]->_AUTOLEXpeek('assertion:*',$retree); }
sub assertion {
my $self = shift;
my $subs;

local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;

my $C = $self->cursor_xact('RULE assertion');
my $S = $C->{'_pos'};

my @result = do {
my $trystate;
my ($tag, $try);
my @try;
my $relex;
my $x;
if (my $fate = $C->{'_fate'}) {
if ($fate->[1] eq 'assertion') {
$C->deb("Fate passed to assertion: ", ::fatestr($fate)) if $::DEBUG & DEBUG::fates;
($C->{'_fate'}, $tag, $try) = @$fate;
@try = ($try);
$x = 'ALT assertion';
}
else {
$x = 'ALTLTM assertion';
}
}
else {
$x = 'ALTLTM assertion';
}
my $C = $C->cursor_xact($x);
my $xact = $C->xact;

my @gather = ();
for (;;) {
if (not @try) {
$relex //= $C->cursor_fate('STD::Regex', 'assertion:*', $retree);
@try = $relex->($C, $trystate);
}
last unless @try;
$try = shift(@try) // next;

if (ref $try eq 'ARRAY') {
($C->{'_fate'}, $tag, $try) = @$try;	# next candidate fate
}

$C->deb("assertion trying $tag $try") if $::DEBUG & DEBUG::try_processing;
push @gather, $C->$try(@_);
last if $xact->[-2];  # committed?
last if @gather;
}
$self->_MATCHIFYr($S, "assertion", @gather);
};
@result;
}


##     token category__S_456quantifier (:$*sym = 'quantifier')
##          token category:quantifier { <sym> }

sub category__S_456quantifier__PEEK { $_[0]->_AUTOLEXpeek('category__S_456quantifier',$retree) }
sub category__S_456quantifier {
no warnings 'recursion';
my $self = shift;
local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;
my %args = @_;
local $::sym = $args{sym} // 'quantifier';


my $C = $self->cursor_xact("RULE category__S_456quantifier");
my $xact = $C->xact;
my $S = $C->{'_pos'};
$C->{'sym'} = ref $sym ? join(' ', @$sym) : $sym;

$self->_MATCHIFYr($S, "category__S_456quantifier", 
$C->_PATTERN(qr/\Gquantifier/)
);
}
#proto token quantifier { <...> }
sub quantifier__PEEK { $_[0]->_AUTOLEXpeek('quantifier:*',$retree); }
sub quantifier {
my $self = shift;
my $subs;

local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;

my $C = $self->cursor_xact('RULE quantifier');
my $S = $C->{'_pos'};

my @result = do {
my $trystate;
my ($tag, $try);
my @try;
my $relex;
my $x;
if (my $fate = $C->{'_fate'}) {
if ($fate->[1] eq 'quantifier') {
$C->deb("Fate passed to quantifier: ", ::fatestr($fate)) if $::DEBUG & DEBUG::fates;
($C->{'_fate'}, $tag, $try) = @$fate;
@try = ($try);
$x = 'ALT quantifier';
}
else {
$x = 'ALTLTM quantifier';
}
}
else {
$x = 'ALTLTM quantifier';
}
my $C = $C->cursor_xact($x);
my $xact = $C->xact;

my @gather = ();
for (;;) {
if (not @try) {
$relex //= $C->cursor_fate('STD::Regex', 'quantifier:*', $retree);
@try = $relex->($C, $trystate);
}
last unless @try;
$try = shift(@try) // next;

if (ref $try eq 'ARRAY') {
($C->{'_fate'}, $tag, $try) = @$try;	# next candidate fate
}

$C->deb("quantifier trying $tag $try") if $::DEBUG & DEBUG::try_processing;
push @gather, $C->$try(@_);
last if $xact->[-2];  # committed?
last if @gather;
}
$self->_MATCHIFYr($S, "quantifier", @gather);
};
@result;
}


##     token category__S_457mod_internal (:$*sym = 'mod_internal')
##          token category:mod_internal { <sym> }

sub category__S_457mod_internal__PEEK { $_[0]->_AUTOLEXpeek('category__S_457mod_internal',$retree) }
sub category__S_457mod_internal {
no warnings 'recursion';
my $self = shift;
local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;
my %args = @_;
local $::sym = $args{sym} // 'mod_internal';


my $C = $self->cursor_xact("RULE category__S_457mod_internal");
my $xact = $C->xact;
my $S = $C->{'_pos'};
$C->{'sym'} = ref $sym ? join(' ', @$sym) : $sym;

$self->_MATCHIFYr($S, "category__S_457mod_internal", 
$C->_PATTERN(qr/\Gmod_internal/)
);
}
#proto token mod_internal { <...> }
sub mod_internal__PEEK { $_[0]->_AUTOLEXpeek('mod_internal:*',$retree); }
sub mod_internal {
my $self = shift;
my $subs;

local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;

my $C = $self->cursor_xact('RULE mod_internal');
my $S = $C->{'_pos'};

my @result = do {
my $trystate;
my ($tag, $try);
my @try;
my $relex;
my $x;
if (my $fate = $C->{'_fate'}) {
if ($fate->[1] eq 'mod_internal') {
$C->deb("Fate passed to mod_internal: ", ::fatestr($fate)) if $::DEBUG & DEBUG::fates;
($C->{'_fate'}, $tag, $try) = @$fate;
@try = ($try);
$x = 'ALT mod_internal';
}
else {
$x = 'ALTLTM mod_internal';
}
}
else {
$x = 'ALTLTM mod_internal';
}
my $C = $C->cursor_xact($x);
my $xact = $C->xact;

my @gather = ();
for (;;) {
if (not @try) {
$relex //= $C->cursor_fate('STD::Regex', 'mod_internal:*', $retree);
@try = $relex->($C, $trystate);
}
last unless @try;
$try = shift(@try) // next;

if (ref $try eq 'ARRAY') {
($C->{'_fate'}, $tag, $try) = @$try;	# next candidate fate
}

$C->deb("mod_internal trying $tag $try") if $::DEBUG & DEBUG::try_processing;
push @gather, $C->$try(@_);
last if $xact->[-2];  # committed?
last if @gather;
}
$self->_MATCHIFYr($S, "mod_internal", @gather);
};
@result;
}


#proto token regex_infix { <...> }
sub regex_infix__PEEK { $_[0]->_AUTOLEXpeek('regex_infix:*',$retree); }
sub regex_infix {
my $self = shift;
my $subs;

local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;

my $C = $self->cursor_xact('RULE regex_infix');
my $S = $C->{'_pos'};

my @result = do {
my $trystate;
my ($tag, $try);
my @try;
my $relex;
my $x;
if (my $fate = $C->{'_fate'}) {
if ($fate->[1] eq 'regex_infix') {
$C->deb("Fate passed to regex_infix: ", ::fatestr($fate)) if $::DEBUG & DEBUG::fates;
($C->{'_fate'}, $tag, $try) = @$fate;
@try = ($try);
$x = 'ALT regex_infix';
}
else {
$x = 'ALTLTM regex_infix';
}
}
else {
$x = 'ALTLTM regex_infix';
}
my $C = $C->cursor_xact($x);
my $xact = $C->xact;

my @gather = ();
for (;;) {
if (not @try) {
$relex //= $C->cursor_fate('STD::Regex', 'regex_infix:*', $retree);
@try = $relex->($C, $trystate);
}
last unless @try;
$try = shift(@try) // next;

if (ref $try eq 'ARRAY') {
($C->{'_fate'}, $tag, $try) = @$try;	# next candidate fate
}

$C->deb("regex_infix trying $tag $try") if $::DEBUG & DEBUG::try_processing;
push @gather, $C->$try(@_);
last if $xact->[-2];  # committed?
last if @gather;
}
$self->_MATCHIFYr($S, "regex_infix", @gather);
};
@result;
}


##     token ws
##          token ws {
##              <?{ $*RX<s> }>
##              || [ <?before \s | '#'> <.nextsame> ]?   # still get all the pod goodness, hopefully
##          }

sub ws__PEEK { '' }
sub ws {
no warnings 'recursion';
my $self = shift;
my @origargs = @_;
local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;


my $C = $self->cursor_xact("RULE ws");
my $xact = $C->xact;
my $S = $C->{'_pos'};

$self->_MATCHIFYr($S, "ws", 
do {
my $C = $C->cursor_xact('ALT ||');
my $xact = $C->xact;
my @gather;
do {
push @gather, $C->before( sub { my $C=shift;
(($C) x !!do {
$::RX->{'s'} 
})
})
}
or $xact->[-2] or
do {
push @gather, $C->_OPTr(sub { my $C=shift;
$C->_BRACKETr(sub {
my $C=shift;
do {
if (my ($C) = ($C->before(sub { my $C=shift;
do {
my @result = do {
my $trystate;
my ($tag, $try);
my @try;
my $relex;

my $fate;
my $x;
if ($fate = $C->{'_fate'} and $fate->[1] eq 'ws_03') {
$C->deb("Fate passed to ws_03: ", ::fatestr($fate)) if $::DEBUG & DEBUG::fates;
($C->{'_fate'}, $tag, $try) = @$fate;
@try = ($try);
$x = 'ALT ws_03';    # some outer ltm is controlling us
}
else {
$x = 'ALTLTM ws_03'; # we are top level ltm
}
my $C = $C->cursor_xact($x);
my $xact = $C->xact;

my @gather = ();
for (;;) {
if (not @try) {
$relex //= $C->cursor_fate('STD::Regex', 'ws_03', $retree);
@try = $relex->($C, $trystate);
}
last unless @try;
$try = shift(@try) // next;

if (ref $try eq 'ARRAY') {
($C->{'_fate'}, $tag, $try) = @$try;	# next candidate fate
}

$C->deb("ws_03 trying $tag $try") if $::DEBUG & DEBUG::try_processing;
push @gather, ((
sub { my $C=shift;
$C->_PATTERN(qr/\G\s/)
},
sub { my $C=shift;
$C->_EXACT('#')
},
)[$try])->($C);
last if $xact->[-2];  # committed?
last if @gather;
}
@gather;
};
@result;
}

}))) {
$self->SUPER::ws(@origargs);
}
else {
();
}
}
})
})};
@gather;
}
);
}

##     token normspace
##          token normspace {
##              <?before \s | '#'> [ :lang($.cursor_fresh(%*LANG<MAIN>)) <.ws> ]
##          }

sub normspace__PEEK { $_[0]->_AUTOLEXpeek('normspace',$retree) }
sub normspace {
no warnings 'recursion';
my $self = shift;
local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;


my $C = $self->cursor_xact("RULE normspace");
my $xact = $C->xact;
my $S = $C->{'_pos'};

$self->_MATCHIFYr($S, "normspace", 
do {
if (my ($C) = ($C->before(sub { my $C=shift;
do {
my @result = do {
my $trystate;
my ($tag, $try);
my @try;
my $relex;

my $fate;
my $x;
if ($fate = $C->{'_fate'} and $fate->[1] eq 'normspace_01') {
$C->deb("Fate passed to normspace_01: ", ::fatestr($fate)) if $::DEBUG & DEBUG::fates;
($C->{'_fate'}, $tag, $try) = @$fate;
@try = ($try);
$x = 'ALT normspace_01';    # some outer ltm is controlling us
}
else {
$x = 'ALTLTM normspace_01'; # we are top level ltm
}
my $C = $C->cursor_xact($x);
my $xact = $C->xact;

my @gather = ();
for (;;) {
if (not @try) {
$relex //= $C->cursor_fate('STD::Regex', 'normspace_01', $retree);
@try = $relex->($C, $trystate);
}
last unless @try;
$try = shift(@try) // next;

if (ref $try eq 'ARRAY') {
($C->{'_fate'}, $tag, $try) = @$try;	# next candidate fate
}

$C->deb("normspace_01 trying $tag $try") if $::DEBUG & DEBUG::try_processing;
push @gather, ((
sub { my $C=shift;
$C->_PATTERN(qr/\G\s/)
},
sub { my $C=shift;
$C->_EXACT('#')
},
)[$try])->($C);
last if $xact->[-2];  # committed?
last if @gather;
}
@gather;
};
@result;
}

}))) {
$C->_BRACKETr(sub {
my $C=shift;
my $newlang = ($C->cursor_fresh($::LANG{'MAIN'}));  $C = $C->cursor_fresh($newlang); ;$C->ws
});
}
else {
();
}
}
);
}

##     token unsp
##          token unsp { '\\' <?before \s | '#'> <.panic: "No unspace allowed in regex; if you meant to match the literal character, please enclose in single quotes ('" ~ substr($::ORIG,$.pos,1) ~ "') or use a backslashed form like \\x" ~ sprintf("%02x", ord(substr($::ORIG,$.pos,1)))> }

sub unsp__PEEK { $_[0]->_AUTOLEXpeek('unsp',$retree) }
sub unsp {
no warnings 'recursion';
my $self = shift;
local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;


my $C = $self->cursor_xact("RULE unsp");
my $xact = $C->xact;
my $S = $C->{'_pos'};

$self->_MATCHIFYr($S, "unsp", 
do {
if (my ($C) = ($C->_EXACT('\\'))) {
do {
if (my ($C) = ($C->before(sub { my $C=shift;
do {
my @result = do {
my $trystate;
my ($tag, $try);
my @try;
my $relex;

my $fate;
my $x;
if ($fate = $C->{'_fate'} and $fate->[1] eq 'unsp_01') {
$C->deb("Fate passed to unsp_01: ", ::fatestr($fate)) if $::DEBUG & DEBUG::fates;
($C->{'_fate'}, $tag, $try) = @$fate;
@try = ($try);
$x = 'ALT unsp_01';    # some outer ltm is controlling us
}
else {
$x = 'ALTLTM unsp_01'; # we are top level ltm
}
my $C = $C->cursor_xact($x);
my $xact = $C->xact;

my @gather = ();
for (;;) {
if (not @try) {
$relex //= $C->cursor_fate('STD::Regex', 'unsp_01', $retree);
@try = $relex->($C, $trystate);
}
last unless @try;
$try = shift(@try) // next;

if (ref $try eq 'ARRAY') {
($C->{'_fate'}, $tag, $try) = @$try;	# next candidate fate
}

$C->deb("unsp_01 trying $tag $try") if $::DEBUG & DEBUG::try_processing;
push @gather, ((
sub { my $C=shift;
$C->_PATTERN(qr/\G\s/)
},
sub { my $C=shift;
$C->_EXACT('#')
},
)[$try])->($C);
last if $xact->[-2];  # committed?
last if @gather;
}
@gather;
};
@result;
}

}))) {
$C->panic("No unspace allowed in regex; if you meant to match the literal character, please enclose in single quotes ('" . substr($::ORIG,$C->{'_pos'},1) . "') or use a backslashed form like \\x" . sprintf("%02x", ord(substr($::ORIG,$C->{'_pos'},1))));
}
else {
();
}
};
}
else {
();
}
}
);
}  # no unspace in regexen

##     rule nibbler
##          rule nibbler {
##              :temp %*RX;
##              [ \s* < || | && & > ]?
##              <EXPR>
##              [ <?before <stopper> || $*GOAL > || <.panic: "Unrecognized regex metacharacter (must be quoted to match literally)"> ]
##          }

sub nibbler__PEEK { $_[0]->_AUTOLEXpeek('nibbler',$retree) }
sub nibbler {
no warnings 'recursion';
my $self = shift;
local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;
local %::RX = %::RX;


my $C = $self->cursor_xact("RULE nibbler");
my $xact = $C->xact;
my $S = $C->{'_pos'};

$self->_MATCHIFYr($S, "nibbler", 
do {
if (my ($C) = ($C->ws)) {
do {
if (my ($C) = ($C->_OPTr(sub { my $C=shift;
$C->_BRACKETr(sub {
my $C=shift;
do {
if (my ($C) = ($C->ws)) {
do {
if (my ($C) = ($C->_PATTERN(qr/\G((?:\s)*+)/))) {
do {
if (my ($C) = ($C->ws)) {
do {
if (my ($C) = ($C->_ARRAY( qw< || | && & > ))) {
$C->ws;
}
else {
();
}
};
}
else {
();
}
};
}
else {
();
}
};
}
else {
();
}
}
})
}))) {
do {
if (my ($C) = ($C->ws)) {
do {
if (my ($C) = ($C->_SUBSUMEr(['EXPR'], sub {
my $C = shift;
$C->EXPR
}))) {
do {
if (my ($C) = ($C->ws)) {
do {
if (my ($C) = ($C->_BRACKETr(sub {
my $C=shift;
do {
my $C = $C->cursor_xact('ALT ||');
my $xact = $C->xact;
my @gather;
do {
push @gather, do {
if (my ($C) = ($C->before(sub { my $C=shift;
do {
my $C = $C->cursor_xact('ALT ||');
my $xact = $C->xact;
my @gather;
do {
push @gather, do {
if (my ($C) = ($C->_SUBSUMEr(['stopper'], sub {
my $C = shift;
$C->stopper
}))) {
$C->ws;
}
else {
();
}
}
}
or $xact->[-2] or
do {
push @gather, do {
if (my ($C) = ($C->ws)) {
do {
if (my ($C) = ($C->_EXACT($::GOAL))) {
$C->ws;
}
else {
();
}
};
}
else {
();
}
}};
@gather;
}
}))) {
$C->ws;
}
else {
();
}
}
}
or $xact->[-2] or
do {
push @gather, do {
if (my ($C) = ($C->panic("Unrecognized regex metacharacter (must be quoted to match literally)"))) {
$C->ws;
}
else {
();
}
}};
@gather;
}
}))) {
$C->ws;
}
else {
();
}
};
}
else {
();
}
};
}
else {
();
}
};
}
else {
();
}
};
}
else {
();
}
};
}
else {
();
}
}
);
}

##     token termish
##          token termish {
##              <.ws>
##              [
##              || <term=.quant_atom_list>
##              || <?before <stopper> | <[&|~]>  >  <.panic: "Null pattern not allowed">
##              || <?before <[ \] \) \> ]> > <.panic: "Unmatched closing bracket">
##              || <.panic: "Unrecognized regex metacharacter (must be quoted to match literally)">
##              ]
##          }

sub termish__PEEK { $_[0]->_AUTOLEXpeek('termish',$retree) }
sub termish {
no warnings 'recursion';
my $self = shift;
local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;


my $C = $self->cursor_xact("RULE termish");
my $xact = $C->xact;
my $S = $C->{'_pos'};

$self->_MATCHIFYr($S, "termish", 
do {
if (my ($C) = ($C->ws)) {
$C->_BRACKETr(sub {
my $C=shift;
do {
my $C = $C->cursor_xact('ALT ||');
my $xact = $C->xact;
my @gather;
do {
push @gather, $C->_SUBSUMEr(['term'], sub {
my $C = shift;
$C->quant_atom_list
})
}
or $xact->[-2] or
do {
push @gather, do {
if (my ($C) = ($C->before(sub { my $C=shift;
do {
my @result = do {
my $trystate;
my ($tag, $try);
my @try;
my $relex;

my $fate;
my $x;
if ($fate = $C->{'_fate'} and $fate->[1] eq 'termish_03') {
$C->deb("Fate passed to termish_03: ", ::fatestr($fate)) if $::DEBUG & DEBUG::fates;
($C->{'_fate'}, $tag, $try) = @$fate;
@try = ($try);
$x = 'ALT termish_03';    # some outer ltm is controlling us
}
else {
$x = 'ALTLTM termish_03'; # we are top level ltm
}
my $C = $C->cursor_xact($x);
my $xact = $C->xact;

my @gather = ();
for (;;) {
if (not @try) {
$relex //= $C->cursor_fate('STD::Regex', 'termish_03', $retree);
@try = $relex->($C, $trystate);
}
last unless @try;
$try = shift(@try) // next;

if (ref $try eq 'ARRAY') {
($C->{'_fate'}, $tag, $try) = @$try;	# next candidate fate
}

$C->deb("termish_03 trying $tag $try") if $::DEBUG & DEBUG::try_processing;
push @gather, ((
sub { my $C=shift;
$C->_SUBSUMEr(['stopper'], sub {
my $C = shift;
$C->stopper
})
},
sub { my $C=shift;
$C->_PATTERN(qr/\G[&|~]/)
},
)[$try])->($C);
last if $xact->[-2];  # committed?
last if @gather;
}
@gather;
};
@result;
}

}))) {
$C->panic("Null pattern not allowed");
}
else {
();
}
}
}
or $xact->[-2] or
do {
push @gather, do {
if (my ($C) = ($C->before(sub { my $C=shift;
$C->_PATTERN(qr/\G[\]\)\>]/)
}))) {
$C->panic("Unmatched closing bracket");
}
else {
();
}
}
}
or $xact->[-2] or
do {
push @gather, $C->panic("Unrecognized regex metacharacter (must be quoted to match literally)")};
@gather;
}
});
}
else {
();
}
}
);
}
##     token quant_atom_list
##          token quant_atom_list {
##              <quantified_atom>+
##          }

sub quant_atom_list__PEEK { $_[0]->_AUTOLEXpeek('quant_atom_list',$retree) }
sub quant_atom_list {
no warnings 'recursion';
my $self = shift;
local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;


my $C = $self->cursor_xact("RULE quant_atom_list");
my $xact = $C->xact;
my $S = $C->{'_pos'};
$C->{'quantified_atom'} = [];

$self->_MATCHIFYr($S, "quant_atom_list", 
$C->_PLUSr(sub { my $C=shift;
$C->_SUBSUMEr(['quantified_atom'], sub {
my $C = shift;
$C->quantified_atom
})
})
);
}
##     token infixish
##          token infixish {
##              <!infixstopper>
##              <!stdstopper>
##              <regex_infix>
##              {
##                  $<O> = $<regex_infix><O>;
##                  $<sym> = $<regex_infix><sym>;
##              }
##          }

sub infixish__PEEK { $_[0]->_AUTOLEXpeek('infixish',$retree) }
sub infixish {
no warnings 'recursion';
my $self = shift;
local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;


my $C = $self->cursor_xact("RULE infixish");
my $xact = $C->xact;
my $S = $C->{'_pos'};

$self->_MATCHIFYr($S, "infixish", 
do {
if (my ($C) = ($C->_NOTBEFORE( sub { my $C=shift;
$C->infixstopper
}))) {
do {
if (my ($C) = ($C->_NOTBEFORE( sub { my $C=shift;
$C->stdstopper
}))) {
do {
if (my ($C) = ($C->_SUBSUMEr(['regex_infix'], sub {
my $C = shift;
$C->regex_infix
}))) {
scalar(do {
my $M = $C; 
$M->{'O'} = $M->{'regex_infix'}{'O'};
$M->{'sym'} = $M->{'regex_infix'}{'sym'};
;
}, $C);
}
else {
();
}
};
}
else {
();
}
};
}
else {
();
}
}
);
}
##     regex infixstopper
##          regex infixstopper {
##              :dba('infix stopper')
##              <?before <stopper> >
##          }

sub infixstopper__PEEK { $_[0]->_AUTOLEXpeek('infixstopper',$retree) }
sub infixstopper {
no warnings 'recursion';
my $self = shift;
local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;


my $C = $self->cursor_xact("RULE infixstopper");
my $xact = $C->xact;
my $S = $C->{'_pos'};

$self->_MATCHIFY($S, "infixstopper", 
$C->before(sub { my $C=shift;
$C->_SUBSUME(['stopper'], sub {
my $C = shift;
$C->stopper
})
})
);
}

##     token regex_infix__S_458VertVert (:$*sym = <||>)
##          token regex_infix:sym<||> { <sym> <O(|%tight_or)>  }

sub regex_infix__S_458VertVert__PEEK { $_[0]->_AUTOLEXpeek('regex_infix__S_458VertVert',$retree) }
sub regex_infix__S_458VertVert {
no warnings 'recursion';
my $self = shift;
local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;
my %args = @_;
local $::sym = $args{sym} // q(||);


my $C = $self->cursor_xact("RULE regex_infix__S_458VertVert");
my $xact = $C->xact;
my $S = $C->{'_pos'};
$C->{'sym'} = ref $sym ? join(' ', @$sym) : $sym;

$self->_MATCHIFYr($S, "regex_infix__S_458VertVert", 
do {
if (my ($C) = ($C->_PATTERN(qr/\G\|\|/))) {
$C->_SUBSUMEr(['O'], sub {
my $C = shift;
$C->O(%tight_or)
});
}
else {
();
}
}
);
}
##     token regex_infix__S_459AmpAmp (:$*sym = <&&>)
##          token regex_infix:sym<&&> { <sym> <O(|%tight_and)>  }

sub regex_infix__S_459AmpAmp__PEEK { $_[0]->_AUTOLEXpeek('regex_infix__S_459AmpAmp',$retree) }
sub regex_infix__S_459AmpAmp {
no warnings 'recursion';
my $self = shift;
local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;
my %args = @_;
local $::sym = $args{sym} // q(&&);


my $C = $self->cursor_xact("RULE regex_infix__S_459AmpAmp");
my $xact = $C->xact;
my $S = $C->{'_pos'};
$C->{'sym'} = ref $sym ? join(' ', @$sym) : $sym;

$self->_MATCHIFYr($S, "regex_infix__S_459AmpAmp", 
do {
if (my ($C) = ($C->_PATTERN(qr/\G\&\&/))) {
$C->_SUBSUMEr(['O'], sub {
my $C = shift;
$C->O(%tight_and)
});
}
else {
();
}
}
);
}
##     token regex_infix__S_460Vert (:$*sym = <|>)
##          token regex_infix:sym<|> { <sym> <O(|%junctive_or)>  }

sub regex_infix__S_460Vert__PEEK { $_[0]->_AUTOLEXpeek('regex_infix__S_460Vert',$retree) }
sub regex_infix__S_460Vert {
no warnings 'recursion';
my $self = shift;
local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;
my %args = @_;
local $::sym = $args{sym} // q(|);


my $C = $self->cursor_xact("RULE regex_infix__S_460Vert");
my $xact = $C->xact;
my $S = $C->{'_pos'};
$C->{'sym'} = ref $sym ? join(' ', @$sym) : $sym;

$self->_MATCHIFYr($S, "regex_infix__S_460Vert", 
do {
if (my ($C) = ($C->_PATTERN(qr/\G\|/))) {
$C->_SUBSUMEr(['O'], sub {
my $C = shift;
$C->O(%junctive_or)
});
}
else {
();
}
}
);
}
##     token regex_infix__S_461Amp (:$*sym = <&>)
##          token regex_infix:sym<&> { <sym> <O(|%junctive_and)>  }

sub regex_infix__S_461Amp__PEEK { $_[0]->_AUTOLEXpeek('regex_infix__S_461Amp',$retree) }
sub regex_infix__S_461Amp {
no warnings 'recursion';
my $self = shift;
local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;
my %args = @_;
local $::sym = $args{sym} // q(&);


my $C = $self->cursor_xact("RULE regex_infix__S_461Amp");
my $xact = $C->xact;
my $S = $C->{'_pos'};
$C->{'sym'} = ref $sym ? join(' ', @$sym) : $sym;

$self->_MATCHIFYr($S, "regex_infix__S_461Amp", 
do {
if (my ($C) = ($C->_PATTERN(qr/\G\&/))) {
$C->_SUBSUMEr(['O'], sub {
my $C = shift;
$C->O(%junctive_and)
});
}
else {
();
}
}
);
}
##     token regex_infix__S_462Tilde (:$*sym = <~>)
##          token regex_infix:sym<~> { <sym> <O(|%additive)>  }

sub regex_infix__S_462Tilde__PEEK { $_[0]->_AUTOLEXpeek('regex_infix__S_462Tilde',$retree) }
sub regex_infix__S_462Tilde {
no warnings 'recursion';
my $self = shift;
local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;
my %args = @_;
local $::sym = $args{sym} // q(~);


my $C = $self->cursor_xact("RULE regex_infix__S_462Tilde");
my $xact = $C->xact;
my $S = $C->{'_pos'};
$C->{'sym'} = ref $sym ? join(' ', @$sym) : $sym;

$self->_MATCHIFYr($S, "regex_infix__S_462Tilde", 
do {
if (my ($C) = ($C->_PATTERN(qr/\G\~/))) {
$C->_SUBSUMEr(['O'], sub {
my $C = shift;
$C->O(%additive)
});
}
else {
();
}
}
);
}

##     token quantified_atom
##          token quantified_atom {
##              <!stopper>
##              <!regex_infix>
##              <atom>
##              <.ws>
##              [ <quantifier> <.ws> ]?
##      #            <?{ $<atom>.max_width }>
##      #                || <.panic: "Can't quantify zero-width atom">
##          }

sub quantified_atom__PEEK { $_[0]->_AUTOLEXpeek('quantified_atom',$retree) }
sub quantified_atom {
no warnings 'recursion';
my $self = shift;
local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;


my $C = $self->cursor_xact("RULE quantified_atom");
my $xact = $C->xact;
my $S = $C->{'_pos'};
$C->{'quantifier'} = [];

$self->_MATCHIFYr($S, "quantified_atom", 
do {
if (my ($C) = ($C->_NOTBEFORE( sub { my $C=shift;
$C->stopper
}))) {
do {
if (my ($C) = ($C->_NOTBEFORE( sub { my $C=shift;
$C->regex_infix
}))) {
do {
if (my ($C) = ($C->_SUBSUMEr(['atom'], sub {
my $C = shift;
$C->atom
}))) {
do {
if (my ($C) = ($C->ws)) {
$C->_OPTr(sub { my $C=shift;
$C->_BRACKETr(sub {
my $C=shift;
do {
if (my ($C) = ($C->_SUBSUMEr(['quantifier'], sub {
my $C = shift;
$C->quantifier
}))) {
$C->ws;
}
else {
();
}
}
})
});
}
else {
();
}
};
}
else {
();
}
};
}
else {
();
}
};
}
else {
();
}
}
);
}

##     token atom
##          token atom {
##              :dba('regex atom')
##              [
##              | \w
##              | <metachar> ::
##              ]
##          }

sub atom__PEEK { $_[0]->_AUTOLEXpeek('atom',$retree) }
sub atom {
no warnings 'recursion';
my $self = shift;
local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;


my $C = $self->cursor_xact("RULE atom");
my $xact = $C->xact;
my $S = $C->{'_pos'};

$self->_MATCHIFYr($S, "atom", 
$C->_BRACKETr(sub {
my $C=shift;
do {
my @result = do {
my $trystate;
my ($tag, $try);
my @try;
my $relex;

my $fate;
my $x;
if ($fate = $C->{'_fate'} and $fate->[1] eq 'atom_01') {
$C->deb("Fate passed to atom_01: ", ::fatestr($fate)) if $::DEBUG & DEBUG::fates;
($C->{'_fate'}, $tag, $try) = @$fate;
@try = ($try);
$x = 'ALT atom_01';    # some outer ltm is controlling us
}
else {
$x = 'ALTLTM atom_01'; # we are top level ltm
}
my $C = $C->cursor_xact($x);
my $xact = $C->xact;

my @gather = ();
for (;;) {
if (not @try) {
$relex //= $C->cursor_fate('STD::Regex', 'atom_01', $retree);
@try = $relex->($C, $trystate);
}
last unless @try;
$try = shift(@try) // next;

if (ref $try eq 'ARRAY') {
($C->{'_fate'}, $tag, $try) = @$try;	# next candidate fate
}

$C->deb("atom_01 trying $tag $try") if $::DEBUG & DEBUG::try_processing;
push @gather, ((
sub { my $C=shift;
$C->_PATTERN(qr/\G\w/)
},
sub { my $C=shift;
do {
if (my ($C) = ($C->_SUBSUMEr(['metachar'], sub {
my $C = shift;
$C->metachar
}))) {
$C->_COMMITLTM();
}
else {
();
}
}
},
)[$try])->($C);
last if $xact->[-2];  # committed?
last if @gather;
}
@gather;
};
@result;
}

})
);
}

# sequence stoppers
##     token metachar__S_463Gt (:$*sym =  > )
##          token metachar:sym >  { '>'  :: <fail> }

sub metachar__S_463Gt__PEEK { $_[0]->_AUTOLEXpeek('metachar__S_463Gt',$retree) }
sub metachar__S_463Gt {
no warnings 'recursion';
my $self = shift;
local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;
my %args = @_;
local $::sym = $args{sym} //['>'];


my $C = $self->cursor_xact("RULE metachar__S_463Gt");
my $xact = $C->xact;
my $S = $C->{'_pos'};
$C->{'sym'} = ref $sym ? join(' ', @$sym) : $sym;

$self->_MATCHIFYr($S, "metachar__S_463Gt", 
do {
if (my ($C) = ($C->_EXACT('>'))) {
do {
if (my ($C) = ($C->_COMMITLTM())) {
$C->_SUBSUMEr(['fail'], sub {
my $C = shift;
$C->fail
});
}
else {
();
}
};
}
else {
();
}
}
);
}
##     token metachar__S_464AmpAmp (:$*sym = <&&>)
##          token metachar:sym<&&>  { '&&' :: <fail> }

sub metachar__S_464AmpAmp__PEEK { $_[0]->_AUTOLEXpeek('metachar__S_464AmpAmp',$retree) }
sub metachar__S_464AmpAmp {
no warnings 'recursion';
my $self = shift;
local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;
my %args = @_;
local $::sym = $args{sym} // q(&&);


my $C = $self->cursor_xact("RULE metachar__S_464AmpAmp");
my $xact = $C->xact;
my $S = $C->{'_pos'};
$C->{'sym'} = ref $sym ? join(' ', @$sym) : $sym;

$self->_MATCHIFYr($S, "metachar__S_464AmpAmp", 
do {
if (my ($C) = ($C->_EXACT('&&'))) {
do {
if (my ($C) = ($C->_COMMITLTM())) {
$C->_SUBSUMEr(['fail'], sub {
my $C = shift;
$C->fail
});
}
else {
();
}
};
}
else {
();
}
}
);
}
##     token metachar__S_465Amp (:$*sym = <&>)
##          token metachar:sym<&>   { '&'  :: <fail> }

sub metachar__S_465Amp__PEEK { $_[0]->_AUTOLEXpeek('metachar__S_465Amp',$retree) }
sub metachar__S_465Amp {
no warnings 'recursion';
my $self = shift;
local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;
my %args = @_;
local $::sym = $args{sym} // q(&);


my $C = $self->cursor_xact("RULE metachar__S_465Amp");
my $xact = $C->xact;
my $S = $C->{'_pos'};
$C->{'sym'} = ref $sym ? join(' ', @$sym) : $sym;

$self->_MATCHIFYr($S, "metachar__S_465Amp", 
do {
if (my ($C) = ($C->_EXACT('&'))) {
do {
if (my ($C) = ($C->_COMMITLTM())) {
$C->_SUBSUMEr(['fail'], sub {
my $C = shift;
$C->fail
});
}
else {
();
}
};
}
else {
();
}
}
);
}
##     token metachar__S_466VertVert (:$*sym = <||>)
##          token metachar:sym<||>  { '||' :: <fail> }

sub metachar__S_466VertVert__PEEK { $_[0]->_AUTOLEXpeek('metachar__S_466VertVert',$retree) }
sub metachar__S_466VertVert {
no warnings 'recursion';
my $self = shift;
local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;
my %args = @_;
local $::sym = $args{sym} // q(||);


my $C = $self->cursor_xact("RULE metachar__S_466VertVert");
my $xact = $C->xact;
my $S = $C->{'_pos'};
$C->{'sym'} = ref $sym ? join(' ', @$sym) : $sym;

$self->_MATCHIFYr($S, "metachar__S_466VertVert", 
do {
if (my ($C) = ($C->_EXACT('||'))) {
do {
if (my ($C) = ($C->_COMMITLTM())) {
$C->_SUBSUMEr(['fail'], sub {
my $C = shift;
$C->fail
});
}
else {
();
}
};
}
else {
();
}
}
);
}
##     token metachar__S_467Vert (:$*sym = <|>)
##          token metachar:sym<|>   { '|'  :: <fail> }

sub metachar__S_467Vert__PEEK { $_[0]->_AUTOLEXpeek('metachar__S_467Vert',$retree) }
sub metachar__S_467Vert {
no warnings 'recursion';
my $self = shift;
local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;
my %args = @_;
local $::sym = $args{sym} // q(|);


my $C = $self->cursor_xact("RULE metachar__S_467Vert");
my $xact = $C->xact;
my $S = $C->{'_pos'};
$C->{'sym'} = ref $sym ? join(' ', @$sym) : $sym;

$self->_MATCHIFYr($S, "metachar__S_467Vert", 
do {
if (my ($C) = ($C->_EXACT('|'))) {
do {
if (my ($C) = ($C->_COMMITLTM())) {
$C->_SUBSUMEr(['fail'], sub {
my $C = shift;
$C->fail
});
}
else {
();
}
};
}
else {
();
}
}
);
}
##     token metachar__S_468Ket (:$*sym = <]>)
##          token metachar:sym<]>   { ']'  :: <fail> }

sub metachar__S_468Ket__PEEK { $_[0]->_AUTOLEXpeek('metachar__S_468Ket',$retree) }
sub metachar__S_468Ket {
no warnings 'recursion';
my $self = shift;
local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;
my %args = @_;
local $::sym = $args{sym} // q(]);


my $C = $self->cursor_xact("RULE metachar__S_468Ket");
my $xact = $C->xact;
my $S = $C->{'_pos'};
$C->{'sym'} = ref $sym ? join(' ', @$sym) : $sym;

$self->_MATCHIFYr($S, "metachar__S_468Ket", 
do {
if (my ($C) = ($C->_EXACT(']'))) {
do {
if (my ($C) = ($C->_COMMITLTM())) {
$C->_SUBSUMEr(['fail'], sub {
my $C = shift;
$C->fail
});
}
else {
();
}
};
}
else {
();
}
}
);
}
##     token metachar__S_469Thesis (:$*sym = <)>)
##          token metachar:sym<)>   { ')'  :: <fail> }

sub metachar__S_469Thesis__PEEK { $_[0]->_AUTOLEXpeek('metachar__S_469Thesis',$retree) }
sub metachar__S_469Thesis {
no warnings 'recursion';
my $self = shift;
local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;
my %args = @_;
local $::sym = $args{sym} // q[)];


my $C = $self->cursor_xact("RULE metachar__S_469Thesis");
my $xact = $C->xact;
my $S = $C->{'_pos'};
$C->{'sym'} = ref $sym ? join(' ', @$sym) : $sym;

$self->_MATCHIFYr($S, "metachar__S_469Thesis", 
do {
if (my ($C) = ($C->_EXACT(')'))) {
do {
if (my ($C) = ($C->_COMMITLTM())) {
$C->_SUBSUMEr(['fail'], sub {
my $C = shift;
$C->fail
});
}
else {
();
}
};
}
else {
();
}
}
);
}
##     token metachar__S_470Semi (:$*sym = <;>)
##          token metachar:sym<;>   {
##              ';' {}
##              [
##              || <?before \N*? <stopper> > <.panic: "Semicolon must be quoted">
##              || <?before .> <.panic: "Regex missing terminator (or semicolon must be quoted?)">
##              || <.panic: "Regex missing terminator">   # the final fake ;
##              ]
##          }

sub metachar__S_470Semi__PEEK { $_[0]->_AUTOLEXpeek('metachar__S_470Semi',$retree) }
sub metachar__S_470Semi {
no warnings 'recursion';
my $self = shift;
local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;
my %args = @_;
local $::sym = $args{sym} // q(;);


my $C = $self->cursor_xact("RULE metachar__S_470Semi");
my $xact = $C->xact;
my $S = $C->{'_pos'};
$C->{'sym'} = ref $sym ? join(' ', @$sym) : $sym;

$self->_MATCHIFY($S, "metachar__S_470Semi", 
Cursor::lazymap(sub {
my $C=$_[0];
Cursor::lazymap(sub {
my $C=$_[0];
$C->_BRACKET(sub {
my $C=shift;
do {
my $C = $C->cursor_xact('ALT ||');
my $xact = $C->xact;
my @gather;
do {
push @gather, Cursor::lazymap(sub {
my $C=$_[0];
$C->panic("Semicolon must be quoted")
}, $C->before(sub { my $C=shift;
Cursor::lazymap(sub {
my $C=$_[0];
$C->_SUBSUME(['stopper'], sub {
my $C = shift;
$C->stopper
})
}, $C->_STARf(sub { my $C=shift;
$C->_NOTCHAR( sub { my $C=shift;
$C->_EXACT("\n")
})
}))
}))
}
or $xact->[-2] or
do {
push @gather, Cursor::lazymap(sub {
my $C=$_[0];
$C->panic("Regex missing terminator (or semicolon must be quoted?)")
}, $C->before(sub { my $C=shift;
$C->_PATTERN(qr/\G(?s:.)/)
}))
}
or $xact->[-2] or
do {
push @gather, $C->panic("Regex missing terminator")};
@gather;
}
})
}, scalar(do {

}, $C))
}, $C->_EXACT(';'))
);
}

##     token metachar__S_471quant (:$*sym = 'quant')
##          token metachar:quant { <quantifier> <.panic: "quantifier quantifies nothing"> }

sub metachar__S_471quant__PEEK { $_[0]->_AUTOLEXpeek('metachar__S_471quant',$retree) }
sub metachar__S_471quant {
no warnings 'recursion';
my $self = shift;
local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;
my %args = @_;
local $::sym = $args{sym} // 'quant';


my $C = $self->cursor_xact("RULE metachar__S_471quant");
my $xact = $C->xact;
my $S = $C->{'_pos'};
$C->{'sym'} = ref $sym ? join(' ', @$sym) : $sym;

$self->_MATCHIFYr($S, "metachar__S_471quant", 
do {
if (my ($C) = ($C->_SUBSUMEr(['quantifier'], sub {
my $C = shift;
$C->quantifier
}))) {
$C->panic("quantifier quantifies nothing");
}
else {
();
}
}
);
}

# "normal" metachars

##     token metachar__S_472sigwhite (:$*sym = 'sigwhite')
##          token metachar:sigwhite {
##              <normspace>
##          }

sub metachar__S_472sigwhite__PEEK { $_[0]->_AUTOLEXpeek('metachar__S_472sigwhite',$retree) }
sub metachar__S_472sigwhite {
no warnings 'recursion';
my $self = shift;
local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;
my %args = @_;
local $::sym = $args{sym} // 'sigwhite';


my $C = $self->cursor_xact("RULE metachar__S_472sigwhite");
my $xact = $C->xact;
my $S = $C->{'_pos'};
$C->{'sym'} = ref $sym ? join(' ', @$sym) : $sym;

$self->_MATCHIFYr($S, "metachar__S_472sigwhite", 
$C->_SUBSUMEr(['normspace'], sub {
my $C = shift;
$C->normspace
})
);
}
##     token metachar__S_473unsp (:$*sym = 'unsp')
##          token metachar:unsp   { <unsp> }

sub metachar__S_473unsp__PEEK { $_[0]->_AUTOLEXpeek('metachar__S_473unsp',$retree) }
sub metachar__S_473unsp {
no warnings 'recursion';
my $self = shift;
local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;
my %args = @_;
local $::sym = $args{sym} // 'unsp';


my $C = $self->cursor_xact("RULE metachar__S_473unsp");
my $xact = $C->xact;
my $S = $C->{'_pos'};
$C->{'sym'} = ref $sym ? join(' ', @$sym) : $sym;

$self->_MATCHIFYr($S, "metachar__S_473unsp", 
$C->_SUBSUMEr(['unsp'], sub {
my $C = shift;
$C->unsp
})
);
}

##     token metachar__S_474Cur_Ly (:$*sym = <{ }>)
##          token metachar:sym<{ }> {
##              <?before '{'>
##              <embeddedblock>
##              {{ $/<sym> := <{ }> }}
##          }

sub metachar__S_474Cur_Ly__PEEK { $_[0]->_AUTOLEXpeek('metachar__S_474Cur_Ly',$retree) }
sub metachar__S_474Cur_Ly {
no warnings 'recursion';
my $self = shift;
local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;
my %args = @_;
local $::sym = $args{sym} // [qw({ })];


my $C = $self->cursor_xact("RULE metachar__S_474Cur_Ly");
my $xact = $C->xact;
my $S = $C->{'_pos'};
$C->{'sym'} = ref $sym ? join(' ', @$sym) : $sym;

$self->_MATCHIFYr($S, "metachar__S_474Cur_Ly", 
do {
if (my ($C) = ($C->before(sub { my $C=shift;
$C->_EXACT('{')
}))) {
do {
if (my ($C) = ($C->_SUBSUMEr(['embeddedblock'], sub {
my $C = shift;
$C->embeddedblock
}))) {
scalar(do {
my $M = $C;  $M->{'sym'} = [qw({ })] ;
}, $C);
}
else {
();
}
};
}
else {
();
}
}
);
}

##     token metachar__S_475mod (:$*sym = 'mod')
##          token metachar:mod {
##              <mod_internal>
##              { $/<sym> := $<mod_internal><sym> }
##          }

sub metachar__S_475mod__PEEK { $_[0]->_AUTOLEXpeek('metachar__S_475mod',$retree) }
sub metachar__S_475mod {
no warnings 'recursion';
my $self = shift;
local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;
my %args = @_;
local $::sym = $args{sym} // 'mod';


my $C = $self->cursor_xact("RULE metachar__S_475mod");
my $xact = $C->xact;
my $S = $C->{'_pos'};
$C->{'sym'} = ref $sym ? join(' ', @$sym) : $sym;

$self->_MATCHIFYr($S, "metachar__S_475mod", 
do {
if (my ($C) = ($C->_SUBSUMEr(['mod_internal'], sub {
my $C = shift;
$C->mod_internal
}))) {
scalar(do {
my $M = $C;  $M->{'sym'} = $M->{'mod_internal'}{'sym'} ;
}, $C);
}
else {
();
}
}
);
}

##     token metachar__S_476Colon (:$*sym = <:>)
##          token metachar:sym<:> {
##              <sym>
##          }

sub metachar__S_476Colon__PEEK { $_[0]->_AUTOLEXpeek('metachar__S_476Colon',$retree) }
sub metachar__S_476Colon {
no warnings 'recursion';
my $self = shift;
local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;
my %args = @_;
local $::sym = $args{sym} // q(:);


my $C = $self->cursor_xact("RULE metachar__S_476Colon");
my $xact = $C->xact;
my $S = $C->{'_pos'};
$C->{'sym'} = ref $sym ? join(' ', @$sym) : $sym;

$self->_MATCHIFYr($S, "metachar__S_476Colon", 
$C->_PATTERN(qr/\G\:/)
);
}

##     token metachar__S_477ColonColon (:$*sym = <::>)
##          token metachar:sym<::> {
##              <sym>
##          }

sub metachar__S_477ColonColon__PEEK { $_[0]->_AUTOLEXpeek('metachar__S_477ColonColon',$retree) }
sub metachar__S_477ColonColon {
no warnings 'recursion';
my $self = shift;
local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;
my %args = @_;
local $::sym = $args{sym} // q(::);


my $C = $self->cursor_xact("RULE metachar__S_477ColonColon");
my $xact = $C->xact;
my $S = $C->{'_pos'};
$C->{'sym'} = ref $sym ? join(' ', @$sym) : $sym;

$self->_MATCHIFYr($S, "metachar__S_477ColonColon", 
$C->_PATTERN(qr/\G\:\:/)
);
}

##     token metachar__S_478ColonColonColon (:$*sym = <:::>)
##          token metachar:sym<:::> {
##              <sym>
##          }

sub metachar__S_478ColonColonColon__PEEK { $_[0]->_AUTOLEXpeek('metachar__S_478ColonColonColon',$retree) }
sub metachar__S_478ColonColonColon {
no warnings 'recursion';
my $self = shift;
local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;
my %args = @_;
local $::sym = $args{sym} // q(:::);


my $C = $self->cursor_xact("RULE metachar__S_478ColonColonColon");
my $xact = $C->xact;
my $S = $C->{'_pos'};
$C->{'sym'} = ref $sym ? join(' ', @$sym) : $sym;

$self->_MATCHIFYr($S, "metachar__S_478ColonColonColon", 
$C->_PATTERN(qr/\G\:\:\:/)
);
}

##     token metachar__S_479Bra_Ket (:$*sym = <[ ]>)
##          token metachar:sym<[ ]> {
##              '[' {} [:lang(self.unbalanced(']')) <nibbler>]
##              [ ']' || <.panic: "Unable to parse regex; couldn't find right bracket"> ]
##              { $/<sym> := <[ ]> }
##          }

sub metachar__S_479Bra_Ket__PEEK { $_[0]->_AUTOLEXpeek('metachar__S_479Bra_Ket',$retree) }
sub metachar__S_479Bra_Ket {
no warnings 'recursion';
my $self = shift;
local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;
my %args = @_;
local $::sym = $args{sym} // [qw([ ])];


my $C = $self->cursor_xact("RULE metachar__S_479Bra_Ket");
my $xact = $C->xact;
my $S = $C->{'_pos'};
$C->{'sym'} = ref $sym ? join(' ', @$sym) : $sym;

$self->_MATCHIFYr($S, "metachar__S_479Bra_Ket", 
do {
if (my ($C) = ($C->_EXACT('['))) {
do {
if (my ($C) = (scalar(do {

}, $C))) {
do {
if (my ($C) = ($C->_BRACKETr(sub {
my $C=shift;
my $newlang = ($self->unbalanced(']'));  $C = $C->cursor_fresh($newlang); ;$C->_SUBSUMEr(['nibbler'], sub {
my $C = shift;
$C->nibbler
})
}))) {
do {
if (my ($C) = ($C->_BRACKETr(sub {
my $C=shift;
do {
my $C = $C->cursor_xact('ALT ||');
my $xact = $C->xact;
my @gather;
do {
push @gather, $C->_EXACT(']')
}
or $xact->[-2] or
do {
push @gather, $C->panic("Unable to parse regex; couldn't find right bracket")};
@gather;
}
}))) {
scalar(do {
my $M = $C;  $M->{'sym'} = [qw([ ])] ;
}, $C);
}
else {
();
}
};
}
else {
();
}
};
}
else {
();
}
};
}
else {
();
}
}
);
}

##     token metachar__S_480Paren_Thesis (:$*sym = <( )>)
##          token metachar:sym<( )> {
##              '(' {} [:lang(self.unbalanced(')')) <nibbler>]
##              [ ')' || <.panic: "Unable to parse regex; couldn't find right parenthesis"> ]
##              { $/<sym> := <( )> }
##          }

sub metachar__S_480Paren_Thesis__PEEK { $_[0]->_AUTOLEXpeek('metachar__S_480Paren_Thesis',$retree) }
sub metachar__S_480Paren_Thesis {
no warnings 'recursion';
my $self = shift;
local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;
my %args = @_;
local $::sym = $args{sym} // [qw[( )]];


my $C = $self->cursor_xact("RULE metachar__S_480Paren_Thesis");
my $xact = $C->xact;
my $S = $C->{'_pos'};
$C->{'sym'} = ref $sym ? join(' ', @$sym) : $sym;

$self->_MATCHIFYr($S, "metachar__S_480Paren_Thesis", 
do {
if (my ($C) = ($C->_EXACT('('))) {
do {
if (my ($C) = (scalar(do {

}, $C))) {
do {
if (my ($C) = ($C->_BRACKETr(sub {
my $C=shift;
my $newlang = ($self->unbalanced(')'));  $C = $C->cursor_fresh($newlang); ;$C->_SUBSUMEr(['nibbler'], sub {
my $C = shift;
$C->nibbler
})
}))) {
do {
if (my ($C) = ($C->_BRACKETr(sub {
my $C=shift;
do {
my $C = $C->cursor_xact('ALT ||');
my $xact = $C->xact;
my @gather;
do {
push @gather, $C->_EXACT(')')
}
or $xact->[-2] or
do {
push @gather, $C->panic("Unable to parse regex; couldn't find right parenthesis")};
@gather;
}
}))) {
scalar(do {
my $M = $C;  $M->{'sym'} = [qw[( )]] ;
}, $C);
}
else {
();
}
};
}
else {
();
}
};
}
else {
();
}
};
}
else {
();
}
}
);
}

##     token metachar__S_481LtParen (:$*sym =  <( )
##          token metachar:sym <(  { '<(' }

sub metachar__S_481LtParen__PEEK { $_[0]->_AUTOLEXpeek('metachar__S_481LtParen',$retree) }
sub metachar__S_481LtParen {
no warnings 'recursion';
my $self = shift;
local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;
my %args = @_;
local $::sym = $args{sym} //['<('];


my $C = $self->cursor_xact("RULE metachar__S_481LtParen");
my $xact = $C->xact;
my $S = $C->{'_pos'};
$C->{'sym'} = ref $sym ? join(' ', @$sym) : $sym;

$self->_MATCHIFYr($S, "metachar__S_481LtParen", 
$C->_EXACT('<(')
);
}
##     token metachar__S_482ThesisGt (:$*sym =  )> )
##          token metachar:sym )>  { ')>' }

sub metachar__S_482ThesisGt__PEEK { $_[0]->_AUTOLEXpeek('metachar__S_482ThesisGt',$retree) }
sub metachar__S_482ThesisGt {
no warnings 'recursion';
my $self = shift;
local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;
my %args = @_;
local $::sym = $args{sym} //[')>'];


my $C = $self->cursor_xact("RULE metachar__S_482ThesisGt");
my $xact = $C->xact;
my $S = $C->{'_pos'};
$C->{'sym'} = ref $sym ? join(' ', @$sym) : $sym;

$self->_MATCHIFYr($S, "metachar__S_482ThesisGt", 
$C->_EXACT(')>')
);
}

##     token metachar__S_483LtLt (:$*sym =  << )
##          token metachar:sym <<  { '<<' }

sub metachar__S_483LtLt__PEEK { $_[0]->_AUTOLEXpeek('metachar__S_483LtLt',$retree) }
sub metachar__S_483LtLt {
no warnings 'recursion';
my $self = shift;
local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;
my %args = @_;
local $::sym = $args{sym} //['<<'];


my $C = $self->cursor_xact("RULE metachar__S_483LtLt");
my $xact = $C->xact;
my $S = $C->{'_pos'};
$C->{'sym'} = ref $sym ? join(' ', @$sym) : $sym;

$self->_MATCHIFYr($S, "metachar__S_483LtLt", 
$C->_EXACT('<<')
);
}
##     token metachar__S_484GtGt (:$*sym =  >> )
##          token metachar:sym >>  { '>>' }

sub metachar__S_484GtGt__PEEK { $_[0]->_AUTOLEXpeek('metachar__S_484GtGt',$retree) }
sub metachar__S_484GtGt {
no warnings 'recursion';
my $self = shift;
local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;
my %args = @_;
local $::sym = $args{sym} //['>>'];


my $C = $self->cursor_xact("RULE metachar__S_484GtGt");
my $xact = $C->xact;
my $S = $C->{'_pos'};
$C->{'sym'} = ref $sym ? join(' ', @$sym) : $sym;

$self->_MATCHIFYr($S, "metachar__S_484GtGt", 
$C->_EXACT('>>')
);
}
##     token metachar__S_485Fre (:$*sym = <  >)
##          token metachar:sym<  > { '' }

sub metachar__S_485Fre__PEEK { $_[0]->_AUTOLEXpeek('metachar__S_485Fre',$retree) }
sub metachar__S_485Fre {
no warnings 'recursion';
my $self = shift;
local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;
my %args = @_;
local $::sym = $args{sym} // [qw(  )];


my $C = $self->cursor_xact("RULE metachar__S_485Fre");
my $xact = $C->xact;
my $S = $C->{'_pos'};
$C->{'sym'} = ref $sym ? join(' ', @$sym) : $sym;

$self->_MATCHIFYr($S, "metachar__S_485Fre", 
$C->_EXACT('')
);
}
##     token metachar__S_486Nch (:$*sym = <  >)
##          token metachar:sym<  > { '' }

sub metachar__S_486Nch__PEEK { $_[0]->_AUTOLEXpeek('metachar__S_486Nch',$retree) }
sub metachar__S_486Nch {
no warnings 'recursion';
my $self = shift;
local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;
my %args = @_;
local $::sym = $args{sym} // [qw(  )];


my $C = $self->cursor_xact("RULE metachar__S_486Nch");
my $xact = $C->xact;
my $S = $C->{'_pos'};
$C->{'sym'} = ref $sym ? join(' ', @$sym) : $sym;

$self->_MATCHIFYr($S, "metachar__S_486Nch", 
$C->_EXACT('')
);
}

##     token metachar__S_487qw (:$*sym = 'qw')
##          token metachar:qw {
##              <?before '<' \s >  # (note required whitespace)
##              <circumfix>
##          }

sub metachar__S_487qw__PEEK { $_[0]->_AUTOLEXpeek('metachar__S_487qw',$retree) }
sub metachar__S_487qw {
no warnings 'recursion';
my $self = shift;
local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;
my %args = @_;
local $::sym = $args{sym} // 'qw';


my $C = $self->cursor_xact("RULE metachar__S_487qw");
my $xact = $C->xact;
my $S = $C->{'_pos'};
$C->{'sym'} = ref $sym ? join(' ', @$sym) : $sym;

$self->_MATCHIFYr($S, "metachar__S_487qw", 
do {
if (my ($C) = ($C->before(sub { my $C=shift;
do {
if (my ($C) = ($C->_EXACT('<'))) {
$C->_PATTERN(qr/\G\s/);
}
else {
();
}
}
}))) {
$C->_SUBSUMEr(['circumfix'], sub {
my $C = shift;
$C->circumfix
});
}
else {
();
}
}
);
}

##     token metachar__S_488Lt_Gt (:$*sym = < >)
##          token metachar:sym< > {
##              '<' ~ '>' <assertion>
##          }

sub metachar__S_488Lt_Gt__PEEK { $_[0]->_AUTOLEXpeek('metachar__S_488Lt_Gt',$retree) }
sub metachar__S_488Lt_Gt {
no warnings 'recursion';
my $self = shift;
local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;
my %args = @_;
local $::sym = $args{sym} //['<','>'];


my $C = $self->cursor_xact("RULE metachar__S_488Lt_Gt");
my $xact = $C->xact;
my $S = $C->{'_pos'};
$C->{'sym'} = ref $sym ? join(' ', @$sym) : $sym;

$self->_MATCHIFYr($S, "metachar__S_488Lt_Gt", 
do {
if (my ($C) = ($C->_EXACT('<'))) {
do {
if (my ($C) = (((local $::GOAL = '>' ), $C)[-1])) {
do {
if (my ($C) = ($C->_SUBSUMEr(['assertion'], sub {
my $C = shift;
$C->assertion
}))) {
$C->_BRACKETr(sub {
my $C=shift;
do {
my $C = $C->cursor_xact('ALT ||');
my $xact = $C->xact;
my @gather;
do {
push @gather, $C->_EXACT('>')
}
or $xact->[-2] or
do {
push @gather, $C->FAILGOAL('>' , 'metachar__S_488Lt_Gt')};
@gather;
}
});
}
else {
();
}
};
}
else {
();
}
};
}
else {
();
}
}
);
}

##     token metachar__S_489Back (:$*sym = <\\>)
##          token metachar:sym<\\> { <sym> <backslash> }

sub metachar__S_489Back__PEEK { $_[0]->_AUTOLEXpeek('metachar__S_489Back',$retree) }
sub metachar__S_489Back {
no warnings 'recursion';
my $self = shift;
local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;
my %args = @_;
local $::sym = $args{sym} // q(\\);


my $C = $self->cursor_xact("RULE metachar__S_489Back");
my $xact = $C->xact;
my $S = $C->{'_pos'};
$C->{'sym'} = ref $sym ? join(' ', @$sym) : $sym;

$self->_MATCHIFYr($S, "metachar__S_489Back", 
do {
if (my ($C) = ($C->_PATTERN(qr/\G\\/))) {
$C->_SUBSUMEr(['backslash'], sub {
my $C = shift;
$C->backslash
});
}
else {
();
}
}
);
}
##     token metachar__S_490Dot (:$*sym = <.>)
##          token metachar:sym<.>  { <sym> }

sub metachar__S_490Dot__PEEK { $_[0]->_AUTOLEXpeek('metachar__S_490Dot',$retree) }
sub metachar__S_490Dot {
no warnings 'recursion';
my $self = shift;
local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;
my %args = @_;
local $::sym = $args{sym} // q(.);


my $C = $self->cursor_xact("RULE metachar__S_490Dot");
my $xact = $C->xact;
my $S = $C->{'_pos'};
$C->{'sym'} = ref $sym ? join(' ', @$sym) : $sym;

$self->_MATCHIFYr($S, "metachar__S_490Dot", 
$C->_PATTERN(qr/\G\./)
);
}
##     token metachar__S_491CaretCaret (:$*sym = <^^>)
##          token metachar:sym<^^> { <sym> }

sub metachar__S_491CaretCaret__PEEK { $_[0]->_AUTOLEXpeek('metachar__S_491CaretCaret',$retree) }
sub metachar__S_491CaretCaret {
no warnings 'recursion';
my $self = shift;
local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;
my %args = @_;
local $::sym = $args{sym} // q(^^);


my $C = $self->cursor_xact("RULE metachar__S_491CaretCaret");
my $xact = $C->xact;
my $S = $C->{'_pos'};
$C->{'sym'} = ref $sym ? join(' ', @$sym) : $sym;

$self->_MATCHIFYr($S, "metachar__S_491CaretCaret", 
$C->_PATTERN(qr/\G\^\^/)
);
}
##     token metachar__S_492Caret (:$*sym = <^>)
##          token metachar:sym<^>  { <sym> }

sub metachar__S_492Caret__PEEK { $_[0]->_AUTOLEXpeek('metachar__S_492Caret',$retree) }
sub metachar__S_492Caret {
no warnings 'recursion';
my $self = shift;
local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;
my %args = @_;
local $::sym = $args{sym} // q(^);


my $C = $self->cursor_xact("RULE metachar__S_492Caret");
my $xact = $C->xact;
my $S = $C->{'_pos'};
$C->{'sym'} = ref $sym ? join(' ', @$sym) : $sym;

$self->_MATCHIFYr($S, "metachar__S_492Caret", 
$C->_PATTERN(qr/\G\^/)
);
}
##     token metachar__S_493DollarDollar (:$*sym = <$$>)
##          token metachar:sym<$$> {
##              <sym>
##              [ (\w+) <.obs("\$\$" ~ $0.Str ~ " to deref var inside a regex", "\$(\$" ~ $0.Str ~ ")")> ]?
##          }

sub metachar__S_493DollarDollar__PEEK { $_[0]->_AUTOLEXpeek('metachar__S_493DollarDollar',$retree) }
sub metachar__S_493DollarDollar {
no warnings 'recursion';
my $self = shift;
local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;
my %args = @_;
local $::sym = $args{sym} // q($$);


my $C = $self->cursor_xact("RULE metachar__S_493DollarDollar");
my $xact = $C->xact;
my $S = $C->{'_pos'};
$C->{'0'} = [];
$C->{'sym'} = ref $sym ? join(' ', @$sym) : $sym;

$self->_MATCHIFYr($S, "metachar__S_493DollarDollar", 
do {
if (my ($C) = ($C->_PATTERN(qr/\G\$\$/))) {
$C->_OPTr(sub { my $C=shift;
$C->_BRACKETr(sub {
my $C=shift;
do {
if (my ($C) = (  $C->_SUBSUMEr(['0'], sub {
my $C = shift;
do { $C->_PAREN( sub { my $C=shift;
$C->_PATTERN(qr/\G((?:\w)++)/)
})}
}))) {
$C->obs("\$\$" . $C->{'0'}->Str . " to deref var inside a regex", "\$(\$" . $C->{'0'}->Str . ")");
}
else {
();
}
}
})
});
}
else {
();
}
}
);
}
##     token metachar__S_494Dollar (:$*sym = <$>)
##          token metachar:sym<$>  {
##              '$'
##              <?before
##              | \s
##              | '|'
##              | '&'
##              | ')'
##              | ']'
##              | '>'
##              | $
##              | <.stopper>
##              >
##          }

sub metachar__S_494Dollar__PEEK { $_[0]->_AUTOLEXpeek('metachar__S_494Dollar',$retree) }
sub metachar__S_494Dollar {
no warnings 'recursion';
my $self = shift;
local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;
my %args = @_;
local $::sym = $args{sym} // q($);


my $C = $self->cursor_xact("RULE metachar__S_494Dollar");
my $xact = $C->xact;
my $S = $C->{'_pos'};
$C->{'sym'} = ref $sym ? join(' ', @$sym) : $sym;

$self->_MATCHIFYr($S, "metachar__S_494Dollar", 
do {
if (my ($C) = ($C->_EXACT('$'))) {
$C->before(sub { my $C=shift;
do {
my @result = do {
my $trystate;
my ($tag, $try);
my @try;
my $relex;

my $fate;
my $x;
if ($fate = $C->{'_fate'} and $fate->[1] eq 'metachar__S_494Dollar_01') {
$C->deb("Fate passed to metachar__S_494Dollar_01: ", ::fatestr($fate)) if $::DEBUG & DEBUG::fates;
($C->{'_fate'}, $tag, $try) = @$fate;
@try = ($try);
$x = 'ALT metachar__S_494Dollar_01';    # some outer ltm is controlling us
}
else {
$x = 'ALTLTM metachar__S_494Dollar_01'; # we are top level ltm
}
my $C = $C->cursor_xact($x);
my $xact = $C->xact;

my @gather = ();
for (;;) {
if (not @try) {
$relex //= $C->cursor_fate('STD::Regex', 'metachar__S_494Dollar_01', $retree);
@try = $relex->($C, $trystate);
}
last unless @try;
$try = shift(@try) // next;

if (ref $try eq 'ARRAY') {
($C->{'_fate'}, $tag, $try) = @$try;	# next candidate fate
}

$C->deb("metachar__S_494Dollar_01 trying $tag $try") if $::DEBUG & DEBUG::try_processing;
push @gather, ((
sub { my $C=shift;
$C->_PATTERN(qr/\G\s/)
},
sub { my $C=shift;
$C->_EXACT('|')
},
sub { my $C=shift;
$C->_EXACT('&')
},
sub { my $C=shift;
$C->_EXACT(')')
},
sub { my $C=shift;
$C->_EXACT(']')
},
sub { my $C=shift;
$C->_EXACT('>')
},
sub { my $C=shift;
$C->_PATTERN(qr/\G\z/)
},
sub { my $C=shift;
$C->stopper
},
)[$try])->($C);
last if $xact->[-2];  # committed?
last if @gather;
}
@gather;
};
@result;
}

});
}
else {
();
}
}
);
}

##     token metachar__S_495Single_Single (:$*sym = <' '>)
##          token metachar:sym<' '> { <?before "'"> [:lang($.cursor_fresh(%*LANG<MAIN>)) <quote>] }

sub metachar__S_495Single_Single__PEEK { $_[0]->_AUTOLEXpeek('metachar__S_495Single_Single',$retree) }
sub metachar__S_495Single_Single {
no warnings 'recursion';
my $self = shift;
local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;
my %args = @_;
local $::sym = $args{sym} // [qw(' ')];


my $C = $self->cursor_xact("RULE metachar__S_495Single_Single");
my $xact = $C->xact;
my $S = $C->{'_pos'};
$C->{'sym'} = ref $sym ? join(' ', @$sym) : $sym;

$self->_MATCHIFYr($S, "metachar__S_495Single_Single", 
do {
if (my ($C) = ($C->before(sub { my $C=shift;
$C->_PATTERN(qr/\G'/)
}))) {
$C->_BRACKETr(sub {
my $C=shift;
my $newlang = ($C->cursor_fresh($::LANG{'MAIN'}));  $C = $C->cursor_fresh($newlang); ;$C->_SUBSUMEr(['quote'], sub {
my $C = shift;
$C->quote
})
});
}
else {
();
}
}
);
}
##     token metachar__S_496Double_Double (:$*sym = <" ">)
##          token metachar:sym<" "> { <?before '"'> [:lang($.cursor_fresh(%*LANG<MAIN>)) <quote>] }

sub metachar__S_496Double_Double__PEEK { $_[0]->_AUTOLEXpeek('metachar__S_496Double_Double',$retree) }
sub metachar__S_496Double_Double {
no warnings 'recursion';
my $self = shift;
local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;
my %args = @_;
local $::sym = $args{sym} // [qw(" ")];


my $C = $self->cursor_xact("RULE metachar__S_496Double_Double");
my $xact = $C->xact;
my $S = $C->{'_pos'};
$C->{'sym'} = ref $sym ? join(' ', @$sym) : $sym;

$self->_MATCHIFYr($S, "metachar__S_496Double_Double", 
do {
if (my ($C) = ($C->before(sub { my $C=shift;
$C->_EXACT('"')
}))) {
$C->_BRACKETr(sub {
my $C=shift;
my $newlang = ($C->cursor_fresh($::LANG{'MAIN'}));  $C = $C->cursor_fresh($newlang); ;$C->_SUBSUMEr(['quote'], sub {
my $C = shift;
$C->quote
})
});
}
else {
();
}
}
);
}

##     token metachar__S_497var (:$*sym = 'var')
##          token metachar:var {
##              <!before '$$'>
##              <?before <sigil>>
##              [:lang($.cursor_fresh(%*LANG<MAIN>)) <variable> <.ws> <.check_variable($<variable>)> ]
##              $<binding> = ( <.ws> '=' <.ws> <quantified_atom> )?
##              { $<sym> = $<variable>.Str; }
##          }

sub metachar__S_497var__PEEK { $_[0]->_AUTOLEXpeek('metachar__S_497var',$retree) }
sub metachar__S_497var {
no warnings 'recursion';
my $self = shift;
local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;
my %args = @_;
local $::sym = $args{sym} // 'var';


my $C = $self->cursor_xact("RULE metachar__S_497var");
my $xact = $C->xact;
my $S = $C->{'_pos'};
$C->{'sym'} = ref $sym ? join(' ', @$sym) : $sym;

$self->_MATCHIFYr($S, "metachar__S_497var", 
do {
if (my ($C) = ($C->_NOTBEFORE( sub { my $C=shift;
$C->before(sub { my $C=shift;
$C->_EXACT('$$')
})
}))) {
do {
if (my ($C) = ($C->before(sub { my $C=shift;
$C->_SUBSUMEr(['sigil'], sub {
my $C = shift;
$C->sigil
})
}))) {
do {
if (my ($C) = ($C->_BRACKETr(sub {
my $C=shift;
my $newlang = ($C->cursor_fresh($::LANG{'MAIN'}));  $C = $C->cursor_fresh($newlang); ;do {
if (my ($C) = ($C->_SUBSUMEr(['variable'], sub {
my $C = shift;
$C->variable
}))) {
do {
if (my ($C) = ($C->ws)) {
do { my $M = $C;
$C->check_variable($M->{'variable'})
; };
}
else {
();
}
};
}
else {
();
}
}
}))) {
do {
if (my ($C) = (  $C->_OPTr(sub { my $C=shift;
$C->_SUBSUMEr(['binding'], sub {
my $C = shift;
do { $C->_PAREN( sub { my $C=shift;
do {
if (my ($C) = ($C->ws)) {
do {
if (my ($C) = ($C->_EXACT('='))) {
do {
if (my ($C) = ($C->ws)) {
$C->_SUBSUMEr(['quantified_atom'], sub {
my $C = shift;
$C->quantified_atom
});
}
else {
();
}
};
}
else {
();
}
};
}
else {
();
}
}
})}
})
}))) {
scalar(do {
my $M = $C;  $M->{'sym'} = $M->{'variable'}->Str; ;
}, $C);
}
else {
();
}
};
}
else {
();
}
};
}
else {
();
}
};
}
else {
();
}
}
);
}

##     token backslash__S_498unspace (:$*sym = 'unspace')
##          token backslash:unspace { <?before \s> <.SUPER::ws> }

sub backslash__S_498unspace__PEEK { $_[0]->_AUTOLEXpeek('backslash__S_498unspace',$retree) }
sub backslash__S_498unspace {
no warnings 'recursion';
my $self = shift;
local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;
my %args = @_;
local $::sym = $args{sym} // 'unspace';


my $C = $self->cursor_xact("RULE backslash__S_498unspace");
my $xact = $C->xact;
my $S = $C->{'_pos'};
$C->{'sym'} = ref $sym ? join(' ', @$sym) : $sym;

$self->_MATCHIFYr($S, "backslash__S_498unspace", 
do {
if (my ($C) = ($C->before(sub { my $C=shift;
$C->_PATTERN(qr/\G\s/)
}))) {
$C->SUPER::ws;
}
else {
();
}
}
);
}

##     token backslash__S_4990 (:$*sym = <0>)
##          token backslash:sym<0> { '0' <!before <[0..7]> > }

sub backslash__S_4990__PEEK { $_[0]->_AUTOLEXpeek('backslash__S_4990',$retree) }
sub backslash__S_4990 {
no warnings 'recursion';
my $self = shift;
local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;
my %args = @_;
local $::sym = $args{sym} // q(0);


my $C = $self->cursor_xact("RULE backslash__S_4990");
my $xact = $C->xact;
my $S = $C->{'_pos'};

$self->_MATCHIFYr($S, "backslash__S_4990", 
do {
if (my ($C) = ($C->_EXACT('0'))) {
$C->_NOTBEFORE( sub { my $C=shift;
$C->before(sub { my $C=shift;
$C->_PATTERN(qr/\G[0-7]/)
})
});
}
else {
();
}
}
);
}

##     token backslash__S_500A (:$*sym = 'A')
##          token backslash:A { <sym> <.obs('\\A as beginning-of-string matcher', '^')> }

sub backslash__S_500A__PEEK { $_[0]->_AUTOLEXpeek('backslash__S_500A',$retree) }
sub backslash__S_500A {
no warnings 'recursion';
my $self = shift;
local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;
my %args = @_;
local $::sym = $args{sym} // 'A';


my $C = $self->cursor_xact("RULE backslash__S_500A");
my $xact = $C->xact;
my $S = $C->{'_pos'};
$C->{'sym'} = ref $sym ? join(' ', @$sym) : $sym;

$self->_MATCHIFYr($S, "backslash__S_500A", 
do {
if (my ($C) = ($C->_PATTERN(qr/\GA/))) {
$C->obs('\\A as beginning-of-string matcher', '^');
}
else {
();
}
}
);
}
##     token backslash__S_501a (:$*sym = 'a')
##          token backslash:a { <sym> <.panic: "\\a is allowed only in strings, not regexes"> }

sub backslash__S_501a__PEEK { $_[0]->_AUTOLEXpeek('backslash__S_501a',$retree) }
sub backslash__S_501a {
no warnings 'recursion';
my $self = shift;
local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;
my %args = @_;
local $::sym = $args{sym} // 'a';


my $C = $self->cursor_xact("RULE backslash__S_501a");
my $xact = $C->xact;
my $S = $C->{'_pos'};
$C->{'sym'} = ref $sym ? join(' ', @$sym) : $sym;

$self->_MATCHIFYr($S, "backslash__S_501a", 
do {
if (my ($C) = ($C->_PATTERN(qr/\Ga/))) {
$C->panic("\\a is allowed only in strings, not regexes");
}
else {
();
}
}
);
}
##     token backslash__S_502B (:$*sym = 'B')
##          token backslash:B { <sym> <.obs('\\B as word non-boundary', '<!wb>')> }

sub backslash__S_502B__PEEK { $_[0]->_AUTOLEXpeek('backslash__S_502B',$retree) }
sub backslash__S_502B {
no warnings 'recursion';
my $self = shift;
local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;
my %args = @_;
local $::sym = $args{sym} // 'B';


my $C = $self->cursor_xact("RULE backslash__S_502B");
my $xact = $C->xact;
my $S = $C->{'_pos'};
$C->{'sym'} = ref $sym ? join(' ', @$sym) : $sym;

$self->_MATCHIFYr($S, "backslash__S_502B", 
do {
if (my ($C) = ($C->_PATTERN(qr/\GB/))) {
$C->obs('\\B as word non-boundary', '<!wb>');
}
else {
();
}
}
);
}
##     token backslash__S_503b (:$*sym = 'b')
##          token backslash:b { <sym> <.obs('\\b as word boundary', '<?wb> (or either of  or )')> }

sub backslash__S_503b__PEEK { $_[0]->_AUTOLEXpeek('backslash__S_503b',$retree) }
sub backslash__S_503b {
no warnings 'recursion';
my $self = shift;
local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;
my %args = @_;
local $::sym = $args{sym} // 'b';


my $C = $self->cursor_xact("RULE backslash__S_503b");
my $xact = $C->xact;
my $S = $C->{'_pos'};
$C->{'sym'} = ref $sym ? join(' ', @$sym) : $sym;

$self->_MATCHIFYr($S, "backslash__S_503b", 
do {
if (my ($C) = ($C->_PATTERN(qr/\Gb/))) {
$C->obs('\\b as word boundary', '<?wb> (or either of  or )');
}
else {
();
}
}
);
}
##     token backslash__S_504c (:$*sym = 'c')
##          token backslash:c { :i <sym> <charspec> }

sub backslash__S_504c__PEEK { $_[0]->_AUTOLEXpeek('backslash__S_504c',$retree) }
sub backslash__S_504c {
no warnings 'recursion';
my $self = shift;
local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;
my %args = @_;
local $::sym = $args{sym} // 'c';


my $C = $self->cursor_xact("RULE backslash__S_504c");
my $xact = $C->xact;
my $S = $C->{'_pos'};
$C->{'sym'} = ref $sym ? join(' ', @$sym) : $sym;

$self->_MATCHIFYr($S, "backslash__S_504c", 
do {
if (my ($C) = ($C->_PATTERN(qr/\G(?i:c)/))) {
$C->_SUBSUMEr(['charspec'], sub {
my $C = shift;
$C->charspec
});
}
else {
();
}
}
);
}
##     token backslash__S_505d (:$*sym = 'd')
##          token backslash:d { :i <sym> }

sub backslash__S_505d__PEEK { $_[0]->_AUTOLEXpeek('backslash__S_505d',$retree) }
sub backslash__S_505d {
no warnings 'recursion';
my $self = shift;
local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;
my %args = @_;
local $::sym = $args{sym} // 'd';


my $C = $self->cursor_xact("RULE backslash__S_505d");
my $xact = $C->xact;
my $S = $C->{'_pos'};
$C->{'sym'} = ref $sym ? join(' ', @$sym) : $sym;

$self->_MATCHIFYr($S, "backslash__S_505d", 
$C->_PATTERN(qr/\G(?i:d)/)
);
}
##     token backslash__S_506e (:$*sym = 'e')
##          token backslash:e { :i <sym> }

sub backslash__S_506e__PEEK { $_[0]->_AUTOLEXpeek('backslash__S_506e',$retree) }
sub backslash__S_506e {
no warnings 'recursion';
my $self = shift;
local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;
my %args = @_;
local $::sym = $args{sym} // 'e';


my $C = $self->cursor_xact("RULE backslash__S_506e");
my $xact = $C->xact;
my $S = $C->{'_pos'};
$C->{'sym'} = ref $sym ? join(' ', @$sym) : $sym;

$self->_MATCHIFYr($S, "backslash__S_506e", 
$C->_PATTERN(qr/\G(?i:e)/)
);
}
##     token backslash__S_507f (:$*sym = 'f')
##          token backslash:f { :i <sym> }

sub backslash__S_507f__PEEK { $_[0]->_AUTOLEXpeek('backslash__S_507f',$retree) }
sub backslash__S_507f {
no warnings 'recursion';
my $self = shift;
local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;
my %args = @_;
local $::sym = $args{sym} // 'f';


my $C = $self->cursor_xact("RULE backslash__S_507f");
my $xact = $C->xact;
my $S = $C->{'_pos'};
$C->{'sym'} = ref $sym ? join(' ', @$sym) : $sym;

$self->_MATCHIFYr($S, "backslash__S_507f", 
$C->_PATTERN(qr/\G(?i:f)/)
);
}
##     token backslash__S_508h (:$*sym = 'h')
##          token backslash:h { :i <sym> }

sub backslash__S_508h__PEEK { $_[0]->_AUTOLEXpeek('backslash__S_508h',$retree) }
sub backslash__S_508h {
no warnings 'recursion';
my $self = shift;
local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;
my %args = @_;
local $::sym = $args{sym} // 'h';


my $C = $self->cursor_xact("RULE backslash__S_508h");
my $xact = $C->xact;
my $S = $C->{'_pos'};
$C->{'sym'} = ref $sym ? join(' ', @$sym) : $sym;

$self->_MATCHIFYr($S, "backslash__S_508h", 
$C->_PATTERN(qr/\G(?i:h)/)
);
}
##     token backslash__S_509n (:$*sym = 'n')
##          token backslash:n { :i <sym> }

sub backslash__S_509n__PEEK { $_[0]->_AUTOLEXpeek('backslash__S_509n',$retree) }
sub backslash__S_509n {
no warnings 'recursion';
my $self = shift;
local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;
my %args = @_;
local $::sym = $args{sym} // 'n';


my $C = $self->cursor_xact("RULE backslash__S_509n");
my $xact = $C->xact;
my $S = $C->{'_pos'};
$C->{'sym'} = ref $sym ? join(' ', @$sym) : $sym;

$self->_MATCHIFYr($S, "backslash__S_509n", 
$C->_PATTERN(qr/\G(?i:n)/)
);
}
##     token backslash__S_510o (:$*sym = 'o')
##          token backslash:o { :i :dba('octal character') <sym> [ <octint> | '[' ~ ']' <octints> ] }

sub backslash__S_510o__PEEK { $_[0]->_AUTOLEXpeek('backslash__S_510o',$retree) }
sub backslash__S_510o {
no warnings 'recursion';
my $self = shift;
local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;
my %args = @_;
local $::sym = $args{sym} // 'o';


my $C = $self->cursor_xact("RULE backslash__S_510o");
my $xact = $C->xact;
my $S = $C->{'_pos'};
$C->{'sym'} = ref $sym ? join(' ', @$sym) : $sym;

$self->_MATCHIFYr($S, "backslash__S_510o", 
do {
if (my ($C) = ($C->_PATTERN(qr/\G(?i:o)/))) {
$C->_BRACKETr(sub {
my $C=shift;
do {
my @result = do {
my $trystate;
my ($tag, $try);
my @try;
my $relex;

my $fate;
my $x;
if ($fate = $C->{'_fate'} and $fate->[1] eq 'backslash__S_510o_01') {
$C->deb("Fate passed to backslash__S_510o_01: ", ::fatestr($fate)) if $::DEBUG & DEBUG::fates;
($C->{'_fate'}, $tag, $try) = @$fate;
@try = ($try);
$x = 'ALT backslash__S_510o_01';    # some outer ltm is controlling us
}
else {
$x = 'ALTLTM backslash__S_510o_01'; # we are top level ltm
}
my $C = $C->cursor_xact($x);
my $xact = $C->xact;

my @gather = ();
for (;;) {
if (not @try) {
$relex //= $C->cursor_fate('STD::Regex', 'backslash__S_510o_01', $retree);
@try = $relex->($C, $trystate);
}
last unless @try;
$try = shift(@try) // next;

if (ref $try eq 'ARRAY') {
($C->{'_fate'}, $tag, $try) = @$try;	# next candidate fate
}

$C->deb("backslash__S_510o_01 trying $tag $try") if $::DEBUG & DEBUG::try_processing;
push @gather, ((
sub { my $C=shift;
$C->_SUBSUMEr(['octint'], sub {
my $C = shift;
$C->octint
})
},
sub { my $C=shift;
do {
if (my ($C) = ($C->_PATTERN(qr/\G(?i:\[)/))) {
do {
if (my ($C) = (((local $::GOAL = ']' ), $C)[-1])) {
do {
if (my ($C) = ($C->_SUBSUMEr(['octints'], sub {
my $C = shift;
$C->octints
}))) {
$C->_BRACKETr(sub {
my $C=shift;
do {
my $C = $C->cursor_xact('ALT ||');
my $xact = $C->xact;
my @gather;
do {
push @gather, $C->_PATTERN(qr/\G(?i:\])/)
}
or $xact->[-2] or
do {
push @gather, $C->FAILGOAL(']' , 'octal character')};
@gather;
}
});
}
else {
();
}
};
}
else {
();
}
};
}
else {
();
}
}
},
)[$try])->($C);
last if $xact->[-2];  # committed?
last if @gather;
}
@gather;
};
@result;
}

});
}
else {
();
}
}
);
}
##     token backslash__S_511Q (:$*sym = 'Q')
##          token backslash:Q { <sym> <.obs('\\Q as quotemeta', 'quotes or literal variable match')> }

sub backslash__S_511Q__PEEK { $_[0]->_AUTOLEXpeek('backslash__S_511Q',$retree) }
sub backslash__S_511Q {
no warnings 'recursion';
my $self = shift;
local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;
my %args = @_;
local $::sym = $args{sym} // 'Q';


my $C = $self->cursor_xact("RULE backslash__S_511Q");
my $xact = $C->xact;
my $S = $C->{'_pos'};
$C->{'sym'} = ref $sym ? join(' ', @$sym) : $sym;

$self->_MATCHIFYr($S, "backslash__S_511Q", 
do {
if (my ($C) = ($C->_PATTERN(qr/\GQ/))) {
$C->obs('\\Q as quotemeta', 'quotes or literal variable match');
}
else {
();
}
}
);
}
##     token backslash__S_512r (:$*sym = 'r')
##          token backslash:r { :i <sym> }

sub backslash__S_512r__PEEK { $_[0]->_AUTOLEXpeek('backslash__S_512r',$retree) }
sub backslash__S_512r {
no warnings 'recursion';
my $self = shift;
local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;
my %args = @_;
local $::sym = $args{sym} // 'r';


my $C = $self->cursor_xact("RULE backslash__S_512r");
my $xact = $C->xact;
my $S = $C->{'_pos'};
$C->{'sym'} = ref $sym ? join(' ', @$sym) : $sym;

$self->_MATCHIFYr($S, "backslash__S_512r", 
$C->_PATTERN(qr/\G(?i:r)/)
);
}
##     token backslash__S_513s (:$*sym = 's')
##          token backslash:s { :i <sym> }

sub backslash__S_513s__PEEK { $_[0]->_AUTOLEXpeek('backslash__S_513s',$retree) }
sub backslash__S_513s {
no warnings 'recursion';
my $self = shift;
local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;
my %args = @_;
local $::sym = $args{sym} // 's';


my $C = $self->cursor_xact("RULE backslash__S_513s");
my $xact = $C->xact;
my $S = $C->{'_pos'};
$C->{'sym'} = ref $sym ? join(' ', @$sym) : $sym;

$self->_MATCHIFYr($S, "backslash__S_513s", 
$C->_PATTERN(qr/\G(?i:s)/)
);
}
##     token backslash__S_514t (:$*sym = 't')
##          token backslash:t { :i <sym> }

sub backslash__S_514t__PEEK { $_[0]->_AUTOLEXpeek('backslash__S_514t',$retree) }
sub backslash__S_514t {
no warnings 'recursion';
my $self = shift;
local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;
my %args = @_;
local $::sym = $args{sym} // 't';


my $C = $self->cursor_xact("RULE backslash__S_514t");
my $xact = $C->xact;
my $S = $C->{'_pos'};
$C->{'sym'} = ref $sym ? join(' ', @$sym) : $sym;

$self->_MATCHIFYr($S, "backslash__S_514t", 
$C->_PATTERN(qr/\G(?i:t)/)
);
}
##     token backslash__S_515v (:$*sym = 'v')
##          token backslash:v { :i <sym> }

sub backslash__S_515v__PEEK { $_[0]->_AUTOLEXpeek('backslash__S_515v',$retree) }
sub backslash__S_515v {
no warnings 'recursion';
my $self = shift;
local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;
my %args = @_;
local $::sym = $args{sym} // 'v';


my $C = $self->cursor_xact("RULE backslash__S_515v");
my $xact = $C->xact;
my $S = $C->{'_pos'};
$C->{'sym'} = ref $sym ? join(' ', @$sym) : $sym;

$self->_MATCHIFYr($S, "backslash__S_515v", 
$C->_PATTERN(qr/\G(?i:v)/)
);
}
##     token backslash__S_516w (:$*sym = 'w')
##          token backslash:w { :i <sym> }

sub backslash__S_516w__PEEK { $_[0]->_AUTOLEXpeek('backslash__S_516w',$retree) }
sub backslash__S_516w {
no warnings 'recursion';
my $self = shift;
local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;
my %args = @_;
local $::sym = $args{sym} // 'w';


my $C = $self->cursor_xact("RULE backslash__S_516w");
my $xact = $C->xact;
my $S = $C->{'_pos'};
$C->{'sym'} = ref $sym ? join(' ', @$sym) : $sym;

$self->_MATCHIFYr($S, "backslash__S_516w", 
$C->_PATTERN(qr/\G(?i:w)/)
);
}
##     token backslash__S_517x (:$*sym = 'x')
##          token backslash:x { :i :dba('hex character') <sym> [ <hexint> | '[' ~ ']' <hexints> ] }

sub backslash__S_517x__PEEK { $_[0]->_AUTOLEXpeek('backslash__S_517x',$retree) }
sub backslash__S_517x {
no warnings 'recursion';
my $self = shift;
local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;
my %args = @_;
local $::sym = $args{sym} // 'x';


my $C = $self->cursor_xact("RULE backslash__S_517x");
my $xact = $C->xact;
my $S = $C->{'_pos'};
$C->{'sym'} = ref $sym ? join(' ', @$sym) : $sym;

$self->_MATCHIFYr($S, "backslash__S_517x", 
do {
if (my ($C) = ($C->_PATTERN(qr/\G(?i:x)/))) {
$C->_BRACKETr(sub {
my $C=shift;
do {
my @result = do {
my $trystate;
my ($tag, $try);
my @try;
my $relex;

my $fate;
my $x;
if ($fate = $C->{'_fate'} and $fate->[1] eq 'backslash__S_517x_01') {
$C->deb("Fate passed to backslash__S_517x_01: ", ::fatestr($fate)) if $::DEBUG & DEBUG::fates;
($C->{'_fate'}, $tag, $try) = @$fate;
@try = ($try);
$x = 'ALT backslash__S_517x_01';    # some outer ltm is controlling us
}
else {
$x = 'ALTLTM backslash__S_517x_01'; # we are top level ltm
}
my $C = $C->cursor_xact($x);
my $xact = $C->xact;

my @gather = ();
for (;;) {
if (not @try) {
$relex //= $C->cursor_fate('STD::Regex', 'backslash__S_517x_01', $retree);
@try = $relex->($C, $trystate);
}
last unless @try;
$try = shift(@try) // next;

if (ref $try eq 'ARRAY') {
($C->{'_fate'}, $tag, $try) = @$try;	# next candidate fate
}

$C->deb("backslash__S_517x_01 trying $tag $try") if $::DEBUG & DEBUG::try_processing;
push @gather, ((
sub { my $C=shift;
$C->_SUBSUMEr(['hexint'], sub {
my $C = shift;
$C->hexint
})
},
sub { my $C=shift;
do {
if (my ($C) = ($C->_PATTERN(qr/\G(?i:\[)/))) {
do {
if (my ($C) = (((local $::GOAL = ']' ), $C)[-1])) {
do {
if (my ($C) = ($C->_SUBSUMEr(['hexints'], sub {
my $C = shift;
$C->hexints
}))) {
$C->_BRACKETr(sub {
my $C=shift;
do {
my $C = $C->cursor_xact('ALT ||');
my $xact = $C->xact;
my @gather;
do {
push @gather, $C->_PATTERN(qr/\G(?i:\])/)
}
or $xact->[-2] or
do {
push @gather, $C->FAILGOAL(']' , 'hex character')};
@gather;
}
});
}
else {
();
}
};
}
else {
();
}
};
}
else {
();
}
}
},
)[$try])->($C);
last if $xact->[-2];  # committed?
last if @gather;
}
@gather;
};
@result;
}

});
}
else {
();
}
}
);
}
##     token backslash__S_518z (:$*sym = 'z')
##          token backslash:z { <sym> <.obs('\\z as end-of-string matcher', '$')> }

sub backslash__S_518z__PEEK { $_[0]->_AUTOLEXpeek('backslash__S_518z',$retree) }
sub backslash__S_518z {
no warnings 'recursion';
my $self = shift;
local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;
my %args = @_;
local $::sym = $args{sym} // 'z';


my $C = $self->cursor_xact("RULE backslash__S_518z");
my $xact = $C->xact;
my $S = $C->{'_pos'};
$C->{'sym'} = ref $sym ? join(' ', @$sym) : $sym;

$self->_MATCHIFYr($S, "backslash__S_518z", 
do {
if (my ($C) = ($C->_PATTERN(qr/\Gz/))) {
$C->obs('\\z as end-of-string matcher', '$');
}
else {
();
}
}
);
}
##     token backslash__S_519Z (:$*sym = 'Z')
##          token backslash:Z { <sym> <.obs('\\Z as end-of-string matcher', '\\n?$')> }

sub backslash__S_519Z__PEEK { $_[0]->_AUTOLEXpeek('backslash__S_519Z',$retree) }
sub backslash__S_519Z {
no warnings 'recursion';
my $self = shift;
local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;
my %args = @_;
local $::sym = $args{sym} // 'Z';


my $C = $self->cursor_xact("RULE backslash__S_519Z");
my $xact = $C->xact;
my $S = $C->{'_pos'};
$C->{'sym'} = ref $sym ? join(' ', @$sym) : $sym;

$self->_MATCHIFYr($S, "backslash__S_519Z", 
do {
if (my ($C) = ($C->_PATTERN(qr/\GZ/))) {
$C->obs('\\Z as end-of-string matcher', '\\n?$');
}
else {
();
}
}
);
}
##     token backslash__S_520misc (:$*sym = 'misc')
##          token backslash:misc { $<litchar>=(\W) }

sub backslash__S_520misc__PEEK { $_[0]->_AUTOLEXpeek('backslash__S_520misc',$retree) }
sub backslash__S_520misc {
no warnings 'recursion';
my $self = shift;
local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;
my %args = @_;
local $::sym = $args{sym} // 'misc';


my $C = $self->cursor_xact("RULE backslash__S_520misc");
my $xact = $C->xact;
my $S = $C->{'_pos'};
$C->{'sym'} = ref $sym ? join(' ', @$sym) : $sym;

$self->_MATCHIFYr($S, "backslash__S_520misc", 
$C->_SUBSUMEr(['litchar'], sub {
my $C = shift;
do { $C->_PAREN( sub { my $C=shift;
$C->_NOTCHAR( sub { my $C=shift;
$C->_PATTERN(qr/\G\w/)
})
})}
})
);
}
##     token backslash__S_521oops (:$*sym = 'oops')
##          token backslash:oops { <.panic: "Unrecognized regex backslash sequence"> }

sub backslash__S_521oops__PEEK { $_[0]->_AUTOLEXpeek('backslash__S_521oops',$retree) }
sub backslash__S_521oops {
no warnings 'recursion';
my $self = shift;
local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;
my %args = @_;
local $::sym = $args{sym} // 'oops';


my $C = $self->cursor_xact("RULE backslash__S_521oops");
my $xact = $C->xact;
my $S = $C->{'_pos'};
$C->{'sym'} = ref $sym ? join(' ', @$sym) : $sym;

$self->_MATCHIFYr($S, "backslash__S_521oops", 
$C->panic("Unrecognized regex backslash sequence")
);
}

##     token assertion__S_522DotDotDot (:$*sym = <...>)
##          token assertion:sym<...> { <sym> }

sub assertion__S_522DotDotDot__PEEK { $_[0]->_AUTOLEXpeek('assertion__S_522DotDotDot',$retree) }
sub assertion__S_522DotDotDot {
no warnings 'recursion';
my $self = shift;
local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;
my %args = @_;
local $::sym = $args{sym} // q(...);


my $C = $self->cursor_xact("RULE assertion__S_522DotDotDot");
my $xact = $C->xact;
my $S = $C->{'_pos'};
$C->{'sym'} = ref $sym ? join(' ', @$sym) : $sym;

$self->_MATCHIFYr($S, "assertion__S_522DotDotDot", 
$C->_PATTERN(qr/\G\.\.\./)
);
}
##     token assertion__S_523QuestionQuestionQuestion (:$*sym = <???>)
##          token assertion:sym<???> { <sym> }

sub assertion__S_523QuestionQuestionQuestion__PEEK { $_[0]->_AUTOLEXpeek('assertion__S_523QuestionQuestionQuestion',$retree) }
sub assertion__S_523QuestionQuestionQuestion {
no warnings 'recursion';
my $self = shift;
local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;
my %args = @_;
local $::sym = $args{sym} // q(???);


my $C = $self->cursor_xact("RULE assertion__S_523QuestionQuestionQuestion");
my $xact = $C->xact;
my $S = $C->{'_pos'};
$C->{'sym'} = ref $sym ? join(' ', @$sym) : $sym;

$self->_MATCHIFYr($S, "assertion__S_523QuestionQuestionQuestion", 
$C->_PATTERN(qr/\G\?\?\?/)
);
}
##     token assertion__S_524BangBangBang (:$*sym = <!!!>)
##          token assertion:sym<!!!> { <sym> }

sub assertion__S_524BangBangBang__PEEK { $_[0]->_AUTOLEXpeek('assertion__S_524BangBangBang',$retree) }
sub assertion__S_524BangBangBang {
no warnings 'recursion';
my $self = shift;
local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;
my %args = @_;
local $::sym = $args{sym} // q(!!!);


my $C = $self->cursor_xact("RULE assertion__S_524BangBangBang");
my $xact = $C->xact;
my $S = $C->{'_pos'};
$C->{'sym'} = ref $sym ? join(' ', @$sym) : $sym;

$self->_MATCHIFYr($S, "assertion__S_524BangBangBang", 
$C->_PATTERN(qr/\G\!\!\!/)
);
}

##     token assertion__S_525Question (:$*sym = <?>)
##          token assertion:sym<?> { <sym> [ <?before '>'> | <assertion> ] }

sub assertion__S_525Question__PEEK { $_[0]->_AUTOLEXpeek('assertion__S_525Question',$retree) }
sub assertion__S_525Question {
no warnings 'recursion';
my $self = shift;
local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;
my %args = @_;
local $::sym = $args{sym} // q(?);


my $C = $self->cursor_xact("RULE assertion__S_525Question");
my $xact = $C->xact;
my $S = $C->{'_pos'};
$C->{'sym'} = ref $sym ? join(' ', @$sym) : $sym;

$self->_MATCHIFYr($S, "assertion__S_525Question", 
do {
if (my ($C) = ($C->_PATTERN(qr/\G\?/))) {
$C->_BRACKETr(sub {
my $C=shift;
do {
my @result = do {
my $trystate;
my ($tag, $try);
my @try;
my $relex;

my $fate;
my $x;
if ($fate = $C->{'_fate'} and $fate->[1] eq 'assertion__S_525Question_01') {
$C->deb("Fate passed to assertion__S_525Question_01: ", ::fatestr($fate)) if $::DEBUG & DEBUG::fates;
($C->{'_fate'}, $tag, $try) = @$fate;
@try = ($try);
$x = 'ALT assertion__S_525Question_01';    # some outer ltm is controlling us
}
else {
$x = 'ALTLTM assertion__S_525Question_01'; # we are top level ltm
}
my $C = $C->cursor_xact($x);
my $xact = $C->xact;

my @gather = ();
for (;;) {
if (not @try) {
$relex //= $C->cursor_fate('STD::Regex', 'assertion__S_525Question_01', $retree);
@try = $relex->($C, $trystate);
}
last unless @try;
$try = shift(@try) // next;

if (ref $try eq 'ARRAY') {
($C->{'_fate'}, $tag, $try) = @$try;	# next candidate fate
}

$C->deb("assertion__S_525Question_01 trying $tag $try") if $::DEBUG & DEBUG::try_processing;
push @gather, ((
sub { my $C=shift;
$C->before(sub { my $C=shift;
$C->_EXACT('>')
})
},
sub { my $C=shift;
$C->_SUBSUMEr(['assertion'], sub {
my $C = shift;
$C->assertion
})
},
)[$try])->($C);
last if $xact->[-2];  # committed?
last if @gather;
}
@gather;
};
@result;
}

});
}
else {
();
}
}
);
}
##     token assertion__S_526Bang (:$*sym = <!>)
##          token assertion:sym<!> { <sym> [ <?before '>'> | <assertion> ] }

sub assertion__S_526Bang__PEEK { $_[0]->_AUTOLEXpeek('assertion__S_526Bang',$retree) }
sub assertion__S_526Bang {
no warnings 'recursion';
my $self = shift;
local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;
my %args = @_;
local $::sym = $args{sym} // q(!);


my $C = $self->cursor_xact("RULE assertion__S_526Bang");
my $xact = $C->xact;
my $S = $C->{'_pos'};
$C->{'sym'} = ref $sym ? join(' ', @$sym) : $sym;

$self->_MATCHIFYr($S, "assertion__S_526Bang", 
do {
if (my ($C) = ($C->_PATTERN(qr/\G\!/))) {
$C->_BRACKETr(sub {
my $C=shift;
do {
my @result = do {
my $trystate;
my ($tag, $try);
my @try;
my $relex;

my $fate;
my $x;
if ($fate = $C->{'_fate'} and $fate->[1] eq 'assertion__S_526Bang_01') {
$C->deb("Fate passed to assertion__S_526Bang_01: ", ::fatestr($fate)) if $::DEBUG & DEBUG::fates;
($C->{'_fate'}, $tag, $try) = @$fate;
@try = ($try);
$x = 'ALT assertion__S_526Bang_01';    # some outer ltm is controlling us
}
else {
$x = 'ALTLTM assertion__S_526Bang_01'; # we are top level ltm
}
my $C = $C->cursor_xact($x);
my $xact = $C->xact;

my @gather = ();
for (;;) {
if (not @try) {
$relex //= $C->cursor_fate('STD::Regex', 'assertion__S_526Bang_01', $retree);
@try = $relex->($C, $trystate);
}
last unless @try;
$try = shift(@try) // next;

if (ref $try eq 'ARRAY') {
($C->{'_fate'}, $tag, $try) = @$try;	# next candidate fate
}

$C->deb("assertion__S_526Bang_01 trying $tag $try") if $::DEBUG & DEBUG::try_processing;
push @gather, ((
sub { my $C=shift;
$C->before(sub { my $C=shift;
$C->_EXACT('>')
})
},
sub { my $C=shift;
$C->_SUBSUMEr(['assertion'], sub {
my $C = shift;
$C->assertion
})
},
)[$try])->($C);
last if $xact->[-2];  # committed?
last if @gather;
}
@gather;
};
@result;
}

});
}
else {
();
}
}
);
}
##     token assertion__S_527Star (:$*sym = <*>)
##          token assertion:sym<*> { <sym> [ <?before '>'> | <.ws> <nibbler> ] }

sub assertion__S_527Star__PEEK { $_[0]->_AUTOLEXpeek('assertion__S_527Star',$retree) }
sub assertion__S_527Star {
no warnings 'recursion';
my $self = shift;
local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;
my %args = @_;
local $::sym = $args{sym} // q(*);


my $C = $self->cursor_xact("RULE assertion__S_527Star");
my $xact = $C->xact;
my $S = $C->{'_pos'};
$C->{'sym'} = ref $sym ? join(' ', @$sym) : $sym;

$self->_MATCHIFYr($S, "assertion__S_527Star", 
do {
if (my ($C) = ($C->_PATTERN(qr/\G\*/))) {
$C->_BRACKETr(sub {
my $C=shift;
do {
my @result = do {
my $trystate;
my ($tag, $try);
my @try;
my $relex;

my $fate;
my $x;
if ($fate = $C->{'_fate'} and $fate->[1] eq 'assertion__S_527Star_01') {
$C->deb("Fate passed to assertion__S_527Star_01: ", ::fatestr($fate)) if $::DEBUG & DEBUG::fates;
($C->{'_fate'}, $tag, $try) = @$fate;
@try = ($try);
$x = 'ALT assertion__S_527Star_01';    # some outer ltm is controlling us
}
else {
$x = 'ALTLTM assertion__S_527Star_01'; # we are top level ltm
}
my $C = $C->cursor_xact($x);
my $xact = $C->xact;

my @gather = ();
for (;;) {
if (not @try) {
$relex //= $C->cursor_fate('STD::Regex', 'assertion__S_527Star_01', $retree);
@try = $relex->($C, $trystate);
}
last unless @try;
$try = shift(@try) // next;

if (ref $try eq 'ARRAY') {
($C->{'_fate'}, $tag, $try) = @$try;	# next candidate fate
}

$C->deb("assertion__S_527Star_01 trying $tag $try") if $::DEBUG & DEBUG::try_processing;
push @gather, ((
sub { my $C=shift;
$C->before(sub { my $C=shift;
$C->_EXACT('>')
})
},
sub { my $C=shift;
do {
if (my ($C) = ($C->ws)) {
$C->_SUBSUMEr(['nibbler'], sub {
my $C = shift;
$C->nibbler
});
}
else {
();
}
}
},
)[$try])->($C);
last if $xact->[-2];  # committed?
last if @gather;
}
@gather;
};
@result;
}

});
}
else {
();
}
}
);
}

##     token assertion__S_528Cur_Ly (:$*sym = <{ }>)
##          token assertion:sym<{ }> { <embeddedblock> }

sub assertion__S_528Cur_Ly__PEEK { $_[0]->_AUTOLEXpeek('assertion__S_528Cur_Ly',$retree) }
sub assertion__S_528Cur_Ly {
no warnings 'recursion';
my $self = shift;
local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;
my %args = @_;
local $::sym = $args{sym} // [qw({ })];


my $C = $self->cursor_xact("RULE assertion__S_528Cur_Ly");
my $xact = $C->xact;
my $S = $C->{'_pos'};
$C->{'sym'} = ref $sym ? join(' ', @$sym) : $sym;

$self->_MATCHIFYr($S, "assertion__S_528Cur_Ly", 
$C->_SUBSUMEr(['embeddedblock'], sub {
my $C = shift;
$C->embeddedblock
})
);
}

##     token assertion__S_529variable (:$*sym = 'variable')
##          token assertion:variable {
##              <?before <sigil>>  # note: semantics must be determined per-sigil
##              [:lang($.cursor_fresh(%*LANG<MAIN>).unbalanced('>')) <variable=.EXPR(item %LOOSEST)>]
##          }

sub assertion__S_529variable__PEEK { $_[0]->_AUTOLEXpeek('assertion__S_529variable',$retree) }
sub assertion__S_529variable {
no warnings 'recursion';
my $self = shift;
local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;
my %args = @_;
local $::sym = $args{sym} // 'variable';


my $C = $self->cursor_xact("RULE assertion__S_529variable");
my $xact = $C->xact;
my $S = $C->{'_pos'};
$C->{'sym'} = ref $sym ? join(' ', @$sym) : $sym;

$self->_MATCHIFYr($S, "assertion__S_529variable", 
do {
if (my ($C) = ($C->before(sub { my $C=shift;
$C->_SUBSUMEr(['sigil'], sub {
my $C = shift;
$C->sigil
})
}))) {
$C->_BRACKETr(sub {
my $C=shift;
my $newlang = ($C->cursor_fresh($::LANG{'MAIN'})->unbalanced('>'));  $C = $C->cursor_fresh($newlang); ;  $C->_SUBSUMEr(['variable'], sub {
my $C = shift;
$C->EXPR(\%LOOSEST)
})
});
}
else {
();
}
}
);
}

##     token assertion__S_530method (:$*sym = 'method')
##          token assertion:method {
##              '.' [
##                  | <?before <alpha> > <assertion>
##                  | [ :lang($.cursor_fresh(%*LANG<MAIN>).unbalanced('>')) <dottyop> ]
##                  ]
##          }

sub assertion__S_530method__PEEK { $_[0]->_AUTOLEXpeek('assertion__S_530method',$retree) }
sub assertion__S_530method {
no warnings 'recursion';
my $self = shift;
local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;
my %args = @_;
local $::sym = $args{sym} // 'method';


my $C = $self->cursor_xact("RULE assertion__S_530method");
my $xact = $C->xact;
my $S = $C->{'_pos'};
$C->{'sym'} = ref $sym ? join(' ', @$sym) : $sym;

$self->_MATCHIFYr($S, "assertion__S_530method", 
do {
if (my ($C) = ($C->_EXACT('.'))) {
$C->_BRACKETr(sub {
my $C=shift;
do {
my @result = do {
my $trystate;
my ($tag, $try);
my @try;
my $relex;

my $fate;
my $x;
if ($fate = $C->{'_fate'} and $fate->[1] eq 'assertion__S_530method_01') {
$C->deb("Fate passed to assertion__S_530method_01: ", ::fatestr($fate)) if $::DEBUG & DEBUG::fates;
($C->{'_fate'}, $tag, $try) = @$fate;
@try = ($try);
$x = 'ALT assertion__S_530method_01';    # some outer ltm is controlling us
}
else {
$x = 'ALTLTM assertion__S_530method_01'; # we are top level ltm
}
my $C = $C->cursor_xact($x);
my $xact = $C->xact;

my @gather = ();
for (;;) {
if (not @try) {
$relex //= $C->cursor_fate('STD::Regex', 'assertion__S_530method_01', $retree);
@try = $relex->($C, $trystate);
}
last unless @try;
$try = shift(@try) // next;

if (ref $try eq 'ARRAY') {
($C->{'_fate'}, $tag, $try) = @$try;	# next candidate fate
}

$C->deb("assertion__S_530method_01 trying $tag $try") if $::DEBUG & DEBUG::try_processing;
push @gather, ((
sub { my $C=shift;
do {
if (my ($C) = ($C->before(sub { my $C=shift;
$C->_PATTERN(qr/\G[_[:alpha:]]/)
}))) {
$C->_SUBSUMEr(['assertion'], sub {
my $C = shift;
$C->assertion
});
}
else {
();
}
}
},
sub { my $C=shift;
$C->_BRACKETr(sub {
my $C=shift;
my $newlang = ($C->cursor_fresh($::LANG{'MAIN'})->unbalanced('>'));  $C = $C->cursor_fresh($newlang); ;$C->_SUBSUMEr(['dottyop'], sub {
my $C = shift;
$C->dottyop
})
})
},
)[$try])->($C);
last if $xact->[-2];  # committed?
last if @gather;
}
@gather;
};
@result;
}

});
}
else {
();
}
}
);
}

##     token assertion__S_531name (:$*sym = 'name')
##          token assertion:name { [ :lang($.cursor_fresh(%*LANG<MAIN>).unbalanced('>')) <longname> ]
##                                          [
##                                          | <?before '>' >
##                                          | <.ws> <nibbler>
##                                          | '=' <assertion>
##                                          | ':' <.ws>
##                                              [ :lang($.cursor_fresh(%*LANG<MAIN>).unbalanced('>')) <arglist> ]
##                                          | '(' {}
##                                              [ :lang($.cursor_fresh(%*LANG<MAIN>)) <arglist> ]
##                                              [ ')' || <.panic: "Assertion call missing right parenthesis"> ]
##                                          ]?
##          }

sub assertion__S_531name__PEEK { $_[0]->_AUTOLEXpeek('assertion__S_531name',$retree) }
sub assertion__S_531name {
no warnings 'recursion';
my $self = shift;
local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;
my %args = @_;
local $::sym = $args{sym} // 'name';


my $C = $self->cursor_xact("RULE assertion__S_531name");
my $xact = $C->xact;
my $S = $C->{'_pos'};
$C->{'arglist'} = [];
$C->{'nibbler'} = [];
$C->{'assertion'} = [];
$C->{'sym'} = ref $sym ? join(' ', @$sym) : $sym;

$self->_MATCHIFYr($S, "assertion__S_531name", 
do {
if (my ($C) = ($C->_BRACKETr(sub {
my $C=shift;
my $newlang = ($C->cursor_fresh($::LANG{'MAIN'})->unbalanced('>'));  $C = $C->cursor_fresh($newlang); ;$C->_SUBSUMEr(['longname'], sub {
my $C = shift;
$C->longname
})
}))) {
$C->_OPTr(sub { my $C=shift;
$C->_BRACKETr(sub {
my $C=shift;
do {
my @result = do {
my $trystate;
my ($tag, $try);
my @try;
my $relex;

my $fate;
my $x;
if ($fate = $C->{'_fate'} and $fate->[1] eq 'assertion__S_531name_02') {
$C->deb("Fate passed to assertion__S_531name_02: ", ::fatestr($fate)) if $::DEBUG & DEBUG::fates;
($C->{'_fate'}, $tag, $try) = @$fate;
@try = ($try);
$x = 'ALT assertion__S_531name_02';    # some outer ltm is controlling us
}
else {
$x = 'ALTLTM assertion__S_531name_02'; # we are top level ltm
}
my $C = $C->cursor_xact($x);
my $xact = $C->xact;

my @gather = ();
for (;;) {
if (not @try) {
$relex //= $C->cursor_fate('STD::Regex', 'assertion__S_531name_02', $retree);
@try = $relex->($C, $trystate);
}
last unless @try;
$try = shift(@try) // next;

if (ref $try eq 'ARRAY') {
($C->{'_fate'}, $tag, $try) = @$try;	# next candidate fate
}

$C->deb("assertion__S_531name_02 trying $tag $try") if $::DEBUG & DEBUG::try_processing;
push @gather, ((
sub { my $C=shift;
$C->before(sub { my $C=shift;
$C->_EXACT('>')
})
},
sub { my $C=shift;
do {
if (my ($C) = ($C->ws)) {
$C->_SUBSUMEr(['nibbler'], sub {
my $C = shift;
$C->nibbler
});
}
else {
();
}
}
},
sub { my $C=shift;
do {
if (my ($C) = ($C->_EXACT('='))) {
$C->_SUBSUMEr(['assertion'], sub {
my $C = shift;
$C->assertion
});
}
else {
();
}
}
},
sub { my $C=shift;
do {
if (my ($C) = ($C->_EXACT(':'))) {
do {
if (my ($C) = ($C->ws)) {
$C->_BRACKETr(sub {
my $C=shift;
my $newlang = ($C->cursor_fresh($::LANG{'MAIN'})->unbalanced('>'));  $C = $C->cursor_fresh($newlang); ;$C->_SUBSUMEr(['arglist'], sub {
my $C = shift;
$C->arglist
})
});
}
else {
();
}
};
}
else {
();
}
}
},
sub { my $C=shift;
do {
if (my ($C) = ($C->_EXACT('('))) {
do {
if (my ($C) = (scalar(do {

}, $C))) {
do {
if (my ($C) = ($C->_BRACKETr(sub {
my $C=shift;
my $newlang = ($C->cursor_fresh($::LANG{'MAIN'}));  $C = $C->cursor_fresh($newlang); ;$C->_SUBSUMEr(['arglist'], sub {
my $C = shift;
$C->arglist
})
}))) {
$C->_BRACKETr(sub {
my $C=shift;
do {
my $C = $C->cursor_xact('ALT ||');
my $xact = $C->xact;
my @gather;
do {
push @gather, $C->_EXACT(')')
}
or $xact->[-2] or
do {
push @gather, $C->panic("Assertion call missing right parenthesis")};
@gather;
}
});
}
else {
();
}
};
}
else {
();
}
};
}
else {
();
}
}
},
)[$try])->($C);
last if $xact->[-2];  # committed?
last if @gather;
}
@gather;
};
@result;
}

})
});
}
else {
();
}
}
);
}

##     token assertion__S_532Bra (:$*sym = <[>)
##          token assertion:sym<[> { <?before '['> <cclass_elem>+ }

sub assertion__S_532Bra__PEEK { $_[0]->_AUTOLEXpeek('assertion__S_532Bra',$retree) }
sub assertion__S_532Bra {
no warnings 'recursion';
my $self = shift;
local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;
my %args = @_;
local $::sym = $args{sym} // q([);


my $C = $self->cursor_xact("RULE assertion__S_532Bra");
my $xact = $C->xact;
my $S = $C->{'_pos'};
$C->{'cclass_elem'} = [];
$C->{'sym'} = ref $sym ? join(' ', @$sym) : $sym;

$self->_MATCHIFYr($S, "assertion__S_532Bra", 
do {
if (my ($C) = ($C->before(sub { my $C=shift;
$C->_EXACT('[')
}))) {
$C->_PLUSr(sub { my $C=shift;
$C->_SUBSUMEr(['cclass_elem'], sub {
my $C = shift;
$C->cclass_elem
})
});
}
else {
();
}
}
);
}
##     token assertion__S_533Plus (:$*sym = <+>)
##          token assertion:sym<+> { <?before '+'> <cclass_elem>+ }

sub assertion__S_533Plus__PEEK { $_[0]->_AUTOLEXpeek('assertion__S_533Plus',$retree) }
sub assertion__S_533Plus {
no warnings 'recursion';
my $self = shift;
local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;
my %args = @_;
local $::sym = $args{sym} // q(+);


my $C = $self->cursor_xact("RULE assertion__S_533Plus");
my $xact = $C->xact;
my $S = $C->{'_pos'};
$C->{'cclass_elem'} = [];
$C->{'sym'} = ref $sym ? join(' ', @$sym) : $sym;

$self->_MATCHIFYr($S, "assertion__S_533Plus", 
do {
if (my ($C) = ($C->before(sub { my $C=shift;
$C->_EXACT('+')
}))) {
$C->_PLUSr(sub { my $C=shift;
$C->_SUBSUMEr(['cclass_elem'], sub {
my $C = shift;
$C->cclass_elem
})
});
}
else {
();
}
}
);
}
##     token assertion__S_534Minus (:$*sym = <->)
##          token assertion:sym<-> { <?before '-'> <cclass_elem>+ }

sub assertion__S_534Minus__PEEK { $_[0]->_AUTOLEXpeek('assertion__S_534Minus',$retree) }
sub assertion__S_534Minus {
no warnings 'recursion';
my $self = shift;
local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;
my %args = @_;
local $::sym = $args{sym} // q(-);


my $C = $self->cursor_xact("RULE assertion__S_534Minus");
my $xact = $C->xact;
my $S = $C->{'_pos'};
$C->{'cclass_elem'} = [];
$C->{'sym'} = ref $sym ? join(' ', @$sym) : $sym;

$self->_MATCHIFYr($S, "assertion__S_534Minus", 
do {
if (my ($C) = ($C->before(sub { my $C=shift;
$C->_EXACT('-')
}))) {
$C->_PLUSr(sub { my $C=shift;
$C->_SUBSUMEr(['cclass_elem'], sub {
my $C = shift;
$C->cclass_elem
})
});
}
else {
();
}
}
);
}
##     token assertion__S_535Dot (:$*sym = <.>)
##          token assertion:sym<.> { <sym> }

sub assertion__S_535Dot__PEEK { $_[0]->_AUTOLEXpeek('assertion__S_535Dot',$retree) }
sub assertion__S_535Dot {
no warnings 'recursion';
my $self = shift;
local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;
my %args = @_;
local $::sym = $args{sym} // q(.);


my $C = $self->cursor_xact("RULE assertion__S_535Dot");
my $xact = $C->xact;
my $S = $C->{'_pos'};
$C->{'sym'} = ref $sym ? join(' ', @$sym) : $sym;

$self->_MATCHIFYr($S, "assertion__S_535Dot", 
$C->_PATTERN(qr/\G\./)
);
}
##     token assertion__S_536Comma (:$*sym = <,>)
##          token assertion:sym<,> { <sym> }

sub assertion__S_536Comma__PEEK { $_[0]->_AUTOLEXpeek('assertion__S_536Comma',$retree) }
sub assertion__S_536Comma {
no warnings 'recursion';
my $self = shift;
local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;
my %args = @_;
local $::sym = $args{sym} // q[,];


my $C = $self->cursor_xact("RULE assertion__S_536Comma");
my $xact = $C->xact;
my $S = $C->{'_pos'};
$C->{'sym'} = ref $sym ? join(' ', @$sym) : $sym;

$self->_MATCHIFYr($S, "assertion__S_536Comma", 
$C->_PATTERN(qr/\G\,/)
);
}
##     token assertion__S_537TildeTilde (:$*sym = <~~>)
##          token assertion:sym<~~> { <sym> [ <?before '>'> | \d+ | <desigilname> ] }

sub assertion__S_537TildeTilde__PEEK { $_[0]->_AUTOLEXpeek('assertion__S_537TildeTilde',$retree) }
sub assertion__S_537TildeTilde {
no warnings 'recursion';
my $self = shift;
local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;
my %args = @_;
local $::sym = $args{sym} // q(~~);


my $C = $self->cursor_xact("RULE assertion__S_537TildeTilde");
my $xact = $C->xact;
my $S = $C->{'_pos'};
$C->{'sym'} = ref $sym ? join(' ', @$sym) : $sym;

$self->_MATCHIFYr($S, "assertion__S_537TildeTilde", 
do {
if (my ($C) = ($C->_PATTERN(qr/\G\~\~/))) {
$C->_BRACKETr(sub {
my $C=shift;
do {
my @result = do {
my $trystate;
my ($tag, $try);
my @try;
my $relex;

my $fate;
my $x;
if ($fate = $C->{'_fate'} and $fate->[1] eq 'assertion__S_537TildeTilde_01') {
$C->deb("Fate passed to assertion__S_537TildeTilde_01: ", ::fatestr($fate)) if $::DEBUG & DEBUG::fates;
($C->{'_fate'}, $tag, $try) = @$fate;
@try = ($try);
$x = 'ALT assertion__S_537TildeTilde_01';    # some outer ltm is controlling us
}
else {
$x = 'ALTLTM assertion__S_537TildeTilde_01'; # we are top level ltm
}
my $C = $C->cursor_xact($x);
my $xact = $C->xact;

my @gather = ();
for (;;) {
if (not @try) {
$relex //= $C->cursor_fate('STD::Regex', 'assertion__S_537TildeTilde_01', $retree);
@try = $relex->($C, $trystate);
}
last unless @try;
$try = shift(@try) // next;

if (ref $try eq 'ARRAY') {
($C->{'_fate'}, $tag, $try) = @$try;	# next candidate fate
}

$C->deb("assertion__S_537TildeTilde_01 trying $tag $try") if $::DEBUG & DEBUG::try_processing;
push @gather, ((
sub { my $C=shift;
$C->before(sub { my $C=shift;
$C->_EXACT('>')
})
},
sub { my $C=shift;
$C->_PATTERN(qr/\G((?:\d)++)/)
},
sub { my $C=shift;
$C->_SUBSUMEr(['desigilname'], sub {
my $C = shift;
$C->desigilname
})
},
)[$try])->($C);
last if $xact->[-2];  # committed?
last if @gather;
}
@gather;
};
@result;
}

});
}
else {
();
}
}
);
}

##     token assertion__S_538bogus (:$*sym = 'bogus')
##          token assertion:bogus { <.panic: "Unrecognized regex assertion"> }

sub assertion__S_538bogus__PEEK { $_[0]->_AUTOLEXpeek('assertion__S_538bogus',$retree) }
sub assertion__S_538bogus {
no warnings 'recursion';
my $self = shift;
local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;
my %args = @_;
local $::sym = $args{sym} // 'bogus';


my $C = $self->cursor_xact("RULE assertion__S_538bogus");
my $xact = $C->xact;
my $S = $C->{'_pos'};
$C->{'sym'} = ref $sym ? join(' ', @$sym) : $sym;

$self->_MATCHIFYr($S, "assertion__S_538bogus", 
$C->panic("Unrecognized regex assertion")
);
}

##     token sign
##          token sign { '+' | '-' | <?> }

sub sign__PEEK { $_[0]->_AUTOLEXpeek('sign',$retree) }
sub sign {
no warnings 'recursion';
my $self = shift;
local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;


my $C = $self->cursor_xact("RULE sign");
my $xact = $C->xact;
my $S = $C->{'_pos'};

$self->_MATCHIFYr($S, "sign", 
do {
my @result = do {
my $trystate;
my ($tag, $try);
my @try;
my $relex;

my $fate;
my $x;
if ($fate = $C->{'_fate'} and $fate->[1] eq 'sign_00') {
$C->deb("Fate passed to sign_00: ", ::fatestr($fate)) if $::DEBUG & DEBUG::fates;
($C->{'_fate'}, $tag, $try) = @$fate;
@try = ($try);
$x = 'ALT sign_00';    # some outer ltm is controlling us
}
else {
$x = 'ALTLTM sign_00'; # we are top level ltm
}
my $C = $C->cursor_xact($x);
my $xact = $C->xact;

my @gather = ();
for (;;) {
if (not @try) {
$relex //= $C->cursor_fate('STD::Regex', 'sign_00', $retree);
@try = $relex->($C, $trystate);
}
last unless @try;
$try = shift(@try) // next;

if (ref $try eq 'ARRAY') {
($C->{'_fate'}, $tag, $try) = @$try;	# next candidate fate
}

$C->deb("sign_00 trying $tag $try") if $::DEBUG & DEBUG::try_processing;
push @gather, ((
sub { my $C=shift;
$C->_EXACT('+')
},
sub { my $C=shift;
$C->_EXACT('-')
},
sub { my $C=shift;
$C->before( sub { my $C=shift;
$C
})
},
)[$try])->($C);
last if $xact->[-2];  # committed?
last if @gather;
}
@gather;
};
@result;
}

);
}
##     token cclass_elem
##          token cclass_elem {
##              :dba('character class element')
##              <sign>
##              <.normspace>?
##              [
##              | <name>
##              | <before '['> <quibble($.cursor_fresh( %*LANG<Q> ).tweak(:q))> # XXX parse as q[] for now
##              ]
##              <.normspace>?
##          }

sub cclass_elem__PEEK { $_[0]->_AUTOLEXpeek('cclass_elem',$retree) }
sub cclass_elem {
no warnings 'recursion';
my $self = shift;
local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;


my $C = $self->cursor_xact("RULE cclass_elem");
my $xact = $C->xact;
my $S = $C->{'_pos'};

$self->_MATCHIFYr($S, "cclass_elem", 
do {
if (my ($C) = ($C->_SUBSUMEr(['sign'], sub {
my $C = shift;
$C->sign
}))) {
do {
if (my ($C) = ($C->_OPTr(sub { my $C=shift;
$C->normspace
}))) {
do {
if (my ($C) = ($C->_BRACKETr(sub {
my $C=shift;
do {
my @result = do {
my $trystate;
my ($tag, $try);
my @try;
my $relex;

my $fate;
my $x;
if ($fate = $C->{'_fate'} and $fate->[1] eq 'cclass_elem_01') {
$C->deb("Fate passed to cclass_elem_01: ", ::fatestr($fate)) if $::DEBUG & DEBUG::fates;
($C->{'_fate'}, $tag, $try) = @$fate;
@try = ($try);
$x = 'ALT cclass_elem_01';    # some outer ltm is controlling us
}
else {
$x = 'ALTLTM cclass_elem_01'; # we are top level ltm
}
my $C = $C->cursor_xact($x);
my $xact = $C->xact;

my @gather = ();
for (;;) {
if (not @try) {
$relex //= $C->cursor_fate('STD::Regex', 'cclass_elem_01', $retree);
@try = $relex->($C, $trystate);
}
last unless @try;
$try = shift(@try) // next;

if (ref $try eq 'ARRAY') {
($C->{'_fate'}, $tag, $try) = @$try;	# next candidate fate
}

$C->deb("cclass_elem_01 trying $tag $try") if $::DEBUG & DEBUG::try_processing;
push @gather, ((
sub { my $C=shift;
$C->_SUBSUMEr(['name'], sub {
my $C = shift;
$C->name
})
},
sub { my $C=shift;
do {
if (my ($C) = ($C->_SUBSUMEr(['before'], sub {
my $C = shift;
$C->before(sub { my $C=shift;
$C->_EXACT('[')
})
}))) {
$C->_SUBSUMEr(['quibble'], sub {
my $C = shift;
$C->quibble($C->cursor_fresh( $::LANG{'Q'} )->tweak('q' => 1))
});
}
else {
();
}
}
},
)[$try])->($C);
last if $xact->[-2];  # committed?
last if @gather;
}
@gather;
};
@result;
}

}))) {
$C->_OPTr(sub { my $C=shift;
$C->normspace
});
}
else {
();
}
};
}
else {
();
}
};
}
else {
();
}
}
);
}

##     token mod_arg
##          token mod_arg { :dba('modifier argument') '(' ~ ')' [:lang($.cursor_fresh(%*LANG<MAIN>)) <semilist> ] }

sub mod_arg__PEEK { $_[0]->_AUTOLEXpeek('mod_arg',$retree) }
sub mod_arg {
no warnings 'recursion';
my $self = shift;
local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;


my $C = $self->cursor_xact("RULE mod_arg");
my $xact = $C->xact;
my $S = $C->{'_pos'};

$self->_MATCHIFYr($S, "mod_arg", 
do {
if (my ($C) = ($C->_EXACT('('))) {
do {
if (my ($C) = (((local $::GOAL = ')' ), $C)[-1])) {
do {
if (my ($C) = ($C->_BRACKETr(sub {
my $C=shift;
my $newlang = ($C->cursor_fresh($::LANG{'MAIN'}));  $C = $C->cursor_fresh($newlang); ;$C->_SUBSUMEr(['semilist'], sub {
my $C = shift;
$C->semilist
})
}))) {
$C->_BRACKETr(sub {
my $C=shift;
do {
my $C = $C->cursor_xact('ALT ||');
my $xact = $C->xact;
my @gather;
do {
push @gather, $C->_EXACT(')')
}
or $xact->[-2] or
do {
push @gather, $C->FAILGOAL(')' , 'modifier argument')};
@gather;
}
});
}
else {
();
}
};
}
else {
();
}
};
}
else {
();
}
}
);
}

##     token mod_internal__S_539Colonmy (:$*sym = <:my>)
##          token mod_internal:sym<:my>    { ':' <?before ['my'|'state'|'our'|'anon'|'constant'|'temp'|'let'] \s > [:lang($.cursor_fresh(%*LANG<MAIN>)) <statement> <eat_terminator> ] }

sub mod_internal__S_539Colonmy__PEEK { $_[0]->_AUTOLEXpeek('mod_internal__S_539Colonmy',$retree) }
sub mod_internal__S_539Colonmy {
no warnings 'recursion';
my $self = shift;
local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;
my %args = @_;
local $::sym = $args{sym} // q(:my);


my $C = $self->cursor_xact("RULE mod_internal__S_539Colonmy");
my $xact = $C->xact;
my $S = $C->{'_pos'};
$C->{'sym'} = ref $sym ? join(' ', @$sym) : $sym;

$self->_MATCHIFYr($S, "mod_internal__S_539Colonmy", 
do {
if (my ($C) = ($C->_EXACT(':'))) {
do {
if (my ($C) = ($C->before(sub { my $C=shift;
do {
if (my ($C) = ($C->_BRACKETr(sub {
my $C=shift;
do {
my @result = do {
my $trystate;
my ($tag, $try);
my @try;
my $relex;

my $fate;
my $x;
if ($fate = $C->{'_fate'} and $fate->[1] eq 'mod_internal__S_539Colonmy_02') {
$C->deb("Fate passed to mod_internal__S_539Colonmy_02: ", ::fatestr($fate)) if $::DEBUG & DEBUG::fates;
($C->{'_fate'}, $tag, $try) = @$fate;
@try = ($try);
$x = 'ALT mod_internal__S_539Colonmy_02';    # some outer ltm is controlling us
}
else {
$x = 'ALTLTM mod_internal__S_539Colonmy_02'; # we are top level ltm
}
my $C = $C->cursor_xact($x);
my $xact = $C->xact;

my @gather = ();
for (;;) {
if (not @try) {
$relex //= $C->cursor_fate('STD::Regex', 'mod_internal__S_539Colonmy_02', $retree);
@try = $relex->($C, $trystate);
}
last unless @try;
$try = shift(@try) // next;

if (ref $try eq 'ARRAY') {
($C->{'_fate'}, $tag, $try) = @$try;	# next candidate fate
}

$C->deb("mod_internal__S_539Colonmy_02 trying $tag $try") if $::DEBUG & DEBUG::try_processing;
push @gather, ((
sub { my $C=shift;
$C->_EXACT('my')
},
sub { my $C=shift;
$C->_EXACT('state')
},
sub { my $C=shift;
$C->_EXACT('our')
},
sub { my $C=shift;
$C->_EXACT('anon')
},
sub { my $C=shift;
$C->_EXACT('constant')
},
sub { my $C=shift;
$C->_EXACT('temp')
},
sub { my $C=shift;
$C->_EXACT('let')
},
)[$try])->($C);
last if $xact->[-2];  # committed?
last if @gather;
}
@gather;
};
@result;
}

}))) {
$C->_PATTERN(qr/\G\s/);
}
else {
();
}
}
}))) {
$C->_BRACKETr(sub {
my $C=shift;
my $newlang = ($C->cursor_fresh($::LANG{'MAIN'}));  $C = $C->cursor_fresh($newlang); ;do {
if (my ($C) = ($C->_SUBSUMEr(['statement'], sub {
my $C = shift;
$C->statement
}))) {
$C->_SUBSUMEr(['eat_terminator'], sub {
my $C = shift;
$C->eat_terminator
});
}
else {
();
}
}
});
}
else {
();
}
};
}
else {
();
}
}
);
}

# XXX needs some generalization

##     token mod_internal__S_540Coloni (:$*sym = <:i>)
##          token mod_internal:sym<:i>    { $<sym>=[':i'|':ignorecase']  { %*RX<i> = 1 } }

sub mod_internal__S_540Coloni__PEEK { $_[0]->_AUTOLEXpeek('mod_internal__S_540Coloni',$retree) }
sub mod_internal__S_540Coloni {
no warnings 'recursion';
my $self = shift;
local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;
my %args = @_;
local $::sym = $args{sym} // q(:i);


my $C = $self->cursor_xact("RULE mod_internal__S_540Coloni");
my $xact = $C->xact;
my $S = $C->{'_pos'};
$C->{'sym'} = ref $sym ? join(' ', @$sym) : $sym;

$self->_MATCHIFYr($S, "mod_internal__S_540Coloni", 
do {
if (my ($C) = (  $C->_SUBSUMEr(['sym'], sub {
my $C = shift;
$C->_BRACKETr(sub {
my $C=shift;
do {
my @result = do {
my $trystate;
my ($tag, $try);
my @try;
my $relex;

my $fate;
my $x;
if ($fate = $C->{'_fate'} and $fate->[1] eq 'mod_internal__S_540Coloni_01') {
$C->deb("Fate passed to mod_internal__S_540Coloni_01: ", ::fatestr($fate)) if $::DEBUG & DEBUG::fates;
($C->{'_fate'}, $tag, $try) = @$fate;
@try = ($try);
$x = 'ALT mod_internal__S_540Coloni_01';    # some outer ltm is controlling us
}
else {
$x = 'ALTLTM mod_internal__S_540Coloni_01'; # we are top level ltm
}
my $C = $C->cursor_xact($x);
my $xact = $C->xact;

my @gather = ();
for (;;) {
if (not @try) {
$relex //= $C->cursor_fate('STD::Regex', 'mod_internal__S_540Coloni_01', $retree);
@try = $relex->($C, $trystate);
}
last unless @try;
$try = shift(@try) // next;

if (ref $try eq 'ARRAY') {
($C->{'_fate'}, $tag, $try) = @$try;	# next candidate fate
}

$C->deb("mod_internal__S_540Coloni_01 trying $tag $try") if $::DEBUG & DEBUG::try_processing;
push @gather, ((
sub { my $C=shift;
$C->_EXACT(':i')
},
sub { my $C=shift;
$C->_EXACT(':ignorecase')
},
)[$try])->($C);
last if $xact->[-2];  # committed?
last if @gather;
}
@gather;
};
@result;
}

})
}))) {
do {
if (my ($C) = ($C->_PATTERN(qr/\G\b/))) {
scalar(do {
$::RX{'i'} = 1 
}, $C);
}
else {
();
}
};
}
else {
();
}
}
);
}
##     token mod_internal__S_541ColonBangi (:$*sym = <:!i>)
##          token mod_internal:sym<:!i>   { $<sym>=[':!i'|':!ignorecase']  { %*RX<i> = 0 } }

sub mod_internal__S_541ColonBangi__PEEK { $_[0]->_AUTOLEXpeek('mod_internal__S_541ColonBangi',$retree) }
sub mod_internal__S_541ColonBangi {
no warnings 'recursion';
my $self = shift;
local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;
my %args = @_;
local $::sym = $args{sym} // q(:!i);


my $C = $self->cursor_xact("RULE mod_internal__S_541ColonBangi");
my $xact = $C->xact;
my $S = $C->{'_pos'};
$C->{'sym'} = ref $sym ? join(' ', @$sym) : $sym;

$self->_MATCHIFYr($S, "mod_internal__S_541ColonBangi", 
do {
if (my ($C) = (  $C->_SUBSUMEr(['sym'], sub {
my $C = shift;
$C->_BRACKETr(sub {
my $C=shift;
do {
my @result = do {
my $trystate;
my ($tag, $try);
my @try;
my $relex;

my $fate;
my $x;
if ($fate = $C->{'_fate'} and $fate->[1] eq 'mod_internal__S_541ColonBangi_01') {
$C->deb("Fate passed to mod_internal__S_541ColonBangi_01: ", ::fatestr($fate)) if $::DEBUG & DEBUG::fates;
($C->{'_fate'}, $tag, $try) = @$fate;
@try = ($try);
$x = 'ALT mod_internal__S_541ColonBangi_01';    # some outer ltm is controlling us
}
else {
$x = 'ALTLTM mod_internal__S_541ColonBangi_01'; # we are top level ltm
}
my $C = $C->cursor_xact($x);
my $xact = $C->xact;

my @gather = ();
for (;;) {
if (not @try) {
$relex //= $C->cursor_fate('STD::Regex', 'mod_internal__S_541ColonBangi_01', $retree);
@try = $relex->($C, $trystate);
}
last unless @try;
$try = shift(@try) // next;

if (ref $try eq 'ARRAY') {
($C->{'_fate'}, $tag, $try) = @$try;	# next candidate fate
}

$C->deb("mod_internal__S_541ColonBangi_01 trying $tag $try") if $::DEBUG & DEBUG::try_processing;
push @gather, ((
sub { my $C=shift;
$C->_EXACT(':!i')
},
sub { my $C=shift;
$C->_EXACT(':!ignorecase')
},
)[$try])->($C);
last if $xact->[-2];  # committed?
last if @gather;
}
@gather;
};
@result;
}

})
}))) {
do {
if (my ($C) = ($C->_PATTERN(qr/\G\b/))) {
scalar(do {
$::RX{'i'} = 0 
}, $C);
}
else {
();
}
};
}
else {
();
}
}
);
}
##     token mod_internal__S_542ColoniParen_Thesis (:$*sym = <:i( )>)
##          token mod_internal:sym<:i( )> { $<sym>=[':i'|':ignorecase'] <mod_arg> { %*RX<i> = eval $<mod_arg>.Str } }

sub mod_internal__S_542ColoniParen_Thesis__PEEK { $_[0]->_AUTOLEXpeek('mod_internal__S_542ColoniParen_Thesis',$retree) }
sub mod_internal__S_542ColoniParen_Thesis {
no warnings 'recursion';
my $self = shift;
local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;
my %args = @_;
local $::sym = $args{sym} // [qw[:i( )]];


my $C = $self->cursor_xact("RULE mod_internal__S_542ColoniParen_Thesis");
my $xact = $C->xact;
my $S = $C->{'_pos'};
$C->{'sym'} = ref $sym ? join(' ', @$sym) : $sym;

$self->_MATCHIFYr($S, "mod_internal__S_542ColoniParen_Thesis", 
do {
if (my ($C) = (  $C->_SUBSUMEr(['sym'], sub {
my $C = shift;
$C->_BRACKETr(sub {
my $C=shift;
do {
my @result = do {
my $trystate;
my ($tag, $try);
my @try;
my $relex;

my $fate;
my $x;
if ($fate = $C->{'_fate'} and $fate->[1] eq 'mod_internal__S_542ColoniParen_Thesis_01') {
$C->deb("Fate passed to mod_internal__S_542ColoniParen_Thesis_01: ", ::fatestr($fate)) if $::DEBUG & DEBUG::fates;
($C->{'_fate'}, $tag, $try) = @$fate;
@try = ($try);
$x = 'ALT mod_internal__S_542ColoniParen_Thesis_01';    # some outer ltm is controlling us
}
else {
$x = 'ALTLTM mod_internal__S_542ColoniParen_Thesis_01'; # we are top level ltm
}
my $C = $C->cursor_xact($x);
my $xact = $C->xact;

my @gather = ();
for (;;) {
if (not @try) {
$relex //= $C->cursor_fate('STD::Regex', 'mod_internal__S_542ColoniParen_Thesis_01', $retree);
@try = $relex->($C, $trystate);
}
last unless @try;
$try = shift(@try) // next;

if (ref $try eq 'ARRAY') {
($C->{'_fate'}, $tag, $try) = @$try;	# next candidate fate
}

$C->deb("mod_internal__S_542ColoniParen_Thesis_01 trying $tag $try") if $::DEBUG & DEBUG::try_processing;
push @gather, ((
sub { my $C=shift;
$C->_EXACT(':i')
},
sub { my $C=shift;
$C->_EXACT(':ignorecase')
},
)[$try])->($C);
last if $xact->[-2];  # committed?
last if @gather;
}
@gather;
};
@result;
}

})
}))) {
do {
if (my ($C) = ($C->_SUBSUMEr(['mod_arg'], sub {
my $C = shift;
$C->mod_arg
}))) {
scalar(do {
my $M = $C;  $::RX{'i'} = eval $M->{'mod_arg'}->Str ;
}, $C);
}
else {
();
}
};
}
else {
();
}
}
);
}
##     token mod_internal__S_543Colon0i (:$*sym = <:0i>)
##          token mod_internal:sym<:0i>   { ':' (\d+) ['i'|'ignorecase'] { %*RX<i> = $0 } }

sub mod_internal__S_543Colon0i__PEEK { $_[0]->_AUTOLEXpeek('mod_internal__S_543Colon0i',$retree) }
sub mod_internal__S_543Colon0i {
no warnings 'recursion';
my $self = shift;
local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;
my %args = @_;
local $::sym = $args{sym} // q(:0i);


my $C = $self->cursor_xact("RULE mod_internal__S_543Colon0i");
my $xact = $C->xact;
my $S = $C->{'_pos'};
$C->{'sym'} = ref $sym ? join(' ', @$sym) : $sym;

$self->_MATCHIFYr($S, "mod_internal__S_543Colon0i", 
do {
if (my ($C) = ($C->_EXACT(':'))) {
do {
if (my ($C) = (  $C->_SUBSUMEr(['0'], sub {
my $C = shift;
do { $C->_PAREN( sub { my $C=shift;
$C->_PATTERN(qr/\G((?:\d)++)/)
})}
}))) {
do {
if (my ($C) = ($C->_BRACKETr(sub {
my $C=shift;
do {
my @result = do {
my $trystate;
my ($tag, $try);
my @try;
my $relex;

my $fate;
my $x;
if ($fate = $C->{'_fate'} and $fate->[1] eq 'mod_internal__S_543Colon0i_02') {
$C->deb("Fate passed to mod_internal__S_543Colon0i_02: ", ::fatestr($fate)) if $::DEBUG & DEBUG::fates;
($C->{'_fate'}, $tag, $try) = @$fate;
@try = ($try);
$x = 'ALT mod_internal__S_543Colon0i_02';    # some outer ltm is controlling us
}
else {
$x = 'ALTLTM mod_internal__S_543Colon0i_02'; # we are top level ltm
}
my $C = $C->cursor_xact($x);
my $xact = $C->xact;

my @gather = ();
for (;;) {
if (not @try) {
$relex //= $C->cursor_fate('STD::Regex', 'mod_internal__S_543Colon0i_02', $retree);
@try = $relex->($C, $trystate);
}
last unless @try;
$try = shift(@try) // next;

if (ref $try eq 'ARRAY') {
($C->{'_fate'}, $tag, $try) = @$try;	# next candidate fate
}

$C->deb("mod_internal__S_543Colon0i_02 trying $tag $try") if $::DEBUG & DEBUG::try_processing;
push @gather, ((
sub { my $C=shift;
$C->_EXACT('i')
},
sub { my $C=shift;
$C->_EXACT('ignorecase')
},
)[$try])->($C);
last if $xact->[-2];  # committed?
last if @gather;
}
@gather;
};
@result;
}

}))) {
scalar(do {
$::RX{'i'} = $C->{'0'} 
}, $C);
}
else {
();
}
};
}
else {
();
}
};
}
else {
();
}
}
);
}

##     token mod_internal__S_544Colona (:$*sym = <:a>)
##          token mod_internal:sym<:a>    { $<sym>=[':a'|':ignoreaccent']  { %*RX<a> = 1 } }

sub mod_internal__S_544Colona__PEEK { $_[0]->_AUTOLEXpeek('mod_internal__S_544Colona',$retree) }
sub mod_internal__S_544Colona {
no warnings 'recursion';
my $self = shift;
local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;
my %args = @_;
local $::sym = $args{sym} // q(:a);


my $C = $self->cursor_xact("RULE mod_internal__S_544Colona");
my $xact = $C->xact;
my $S = $C->{'_pos'};
$C->{'sym'} = ref $sym ? join(' ', @$sym) : $sym;

$self->_MATCHIFYr($S, "mod_internal__S_544Colona", 
do {
if (my ($C) = (  $C->_SUBSUMEr(['sym'], sub {
my $C = shift;
$C->_BRACKETr(sub {
my $C=shift;
do {
my @result = do {
my $trystate;
my ($tag, $try);
my @try;
my $relex;

my $fate;
my $x;
if ($fate = $C->{'_fate'} and $fate->[1] eq 'mod_internal__S_544Colona_01') {
$C->deb("Fate passed to mod_internal__S_544Colona_01: ", ::fatestr($fate)) if $::DEBUG & DEBUG::fates;
($C->{'_fate'}, $tag, $try) = @$fate;
@try = ($try);
$x = 'ALT mod_internal__S_544Colona_01';    # some outer ltm is controlling us
}
else {
$x = 'ALTLTM mod_internal__S_544Colona_01'; # we are top level ltm
}
my $C = $C->cursor_xact($x);
my $xact = $C->xact;

my @gather = ();
for (;;) {
if (not @try) {
$relex //= $C->cursor_fate('STD::Regex', 'mod_internal__S_544Colona_01', $retree);
@try = $relex->($C, $trystate);
}
last unless @try;
$try = shift(@try) // next;

if (ref $try eq 'ARRAY') {
($C->{'_fate'}, $tag, $try) = @$try;	# next candidate fate
}

$C->deb("mod_internal__S_544Colona_01 trying $tag $try") if $::DEBUG & DEBUG::try_processing;
push @gather, ((
sub { my $C=shift;
$C->_EXACT(':a')
},
sub { my $C=shift;
$C->_EXACT(':ignoreaccent')
},
)[$try])->($C);
last if $xact->[-2];  # committed?
last if @gather;
}
@gather;
};
@result;
}

})
}))) {
do {
if (my ($C) = ($C->_PATTERN(qr/\G\b/))) {
scalar(do {
$::RX{'a'} = 1 
}, $C);
}
else {
();
}
};
}
else {
();
}
}
);
}
##     token mod_internal__S_545ColonBanga (:$*sym = <:!a>)
##          token mod_internal:sym<:!a>   { $<sym>=[':!a'|':!ignoreaccent']  { %*RX<a> = 0 } }

sub mod_internal__S_545ColonBanga__PEEK { $_[0]->_AUTOLEXpeek('mod_internal__S_545ColonBanga',$retree) }
sub mod_internal__S_545ColonBanga {
no warnings 'recursion';
my $self = shift;
local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;
my %args = @_;
local $::sym = $args{sym} // q(:!a);


my $C = $self->cursor_xact("RULE mod_internal__S_545ColonBanga");
my $xact = $C->xact;
my $S = $C->{'_pos'};
$C->{'sym'} = ref $sym ? join(' ', @$sym) : $sym;

$self->_MATCHIFYr($S, "mod_internal__S_545ColonBanga", 
do {
if (my ($C) = (  $C->_SUBSUMEr(['sym'], sub {
my $C = shift;
$C->_BRACKETr(sub {
my $C=shift;
do {
my @result = do {
my $trystate;
my ($tag, $try);
my @try;
my $relex;

my $fate;
my $x;
if ($fate = $C->{'_fate'} and $fate->[1] eq 'mod_internal__S_545ColonBanga_01') {
$C->deb("Fate passed to mod_internal__S_545ColonBanga_01: ", ::fatestr($fate)) if $::DEBUG & DEBUG::fates;
($C->{'_fate'}, $tag, $try) = @$fate;
@try = ($try);
$x = 'ALT mod_internal__S_545ColonBanga_01';    # some outer ltm is controlling us
}
else {
$x = 'ALTLTM mod_internal__S_545ColonBanga_01'; # we are top level ltm
}
my $C = $C->cursor_xact($x);
my $xact = $C->xact;

my @gather = ();
for (;;) {
if (not @try) {
$relex //= $C->cursor_fate('STD::Regex', 'mod_internal__S_545ColonBanga_01', $retree);
@try = $relex->($C, $trystate);
}
last unless @try;
$try = shift(@try) // next;

if (ref $try eq 'ARRAY') {
($C->{'_fate'}, $tag, $try) = @$try;	# next candidate fate
}

$C->deb("mod_internal__S_545ColonBanga_01 trying $tag $try") if $::DEBUG & DEBUG::try_processing;
push @gather, ((
sub { my $C=shift;
$C->_EXACT(':!a')
},
sub { my $C=shift;
$C->_EXACT(':!ignoreaccent')
},
)[$try])->($C);
last if $xact->[-2];  # committed?
last if @gather;
}
@gather;
};
@result;
}

})
}))) {
do {
if (my ($C) = ($C->_PATTERN(qr/\G\b/))) {
scalar(do {
$::RX{'a'} = 0 
}, $C);
}
else {
();
}
};
}
else {
();
}
}
);
}
##     token mod_internal__S_546ColonaParen_Thesis (:$*sym = <:a( )>)
##          token mod_internal:sym<:a( )> { $<sym>=[':a'|':ignoreaccent'] <mod_arg> { %*RX<a> = eval $<mod_arg>.Str } }

sub mod_internal__S_546ColonaParen_Thesis__PEEK { $_[0]->_AUTOLEXpeek('mod_internal__S_546ColonaParen_Thesis',$retree) }
sub mod_internal__S_546ColonaParen_Thesis {
no warnings 'recursion';
my $self = shift;
local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;
my %args = @_;
local $::sym = $args{sym} // [qw[:a( )]];


my $C = $self->cursor_xact("RULE mod_internal__S_546ColonaParen_Thesis");
my $xact = $C->xact;
my $S = $C->{'_pos'};
$C->{'sym'} = ref $sym ? join(' ', @$sym) : $sym;

$self->_MATCHIFYr($S, "mod_internal__S_546ColonaParen_Thesis", 
do {
if (my ($C) = (  $C->_SUBSUMEr(['sym'], sub {
my $C = shift;
$C->_BRACKETr(sub {
my $C=shift;
do {
my @result = do {
my $trystate;
my ($tag, $try);
my @try;
my $relex;

my $fate;
my $x;
if ($fate = $C->{'_fate'} and $fate->[1] eq 'mod_internal__S_546ColonaParen_Thesis_01') {
$C->deb("Fate passed to mod_internal__S_546ColonaParen_Thesis_01: ", ::fatestr($fate)) if $::DEBUG & DEBUG::fates;
($C->{'_fate'}, $tag, $try) = @$fate;
@try = ($try);
$x = 'ALT mod_internal__S_546ColonaParen_Thesis_01';    # some outer ltm is controlling us
}
else {
$x = 'ALTLTM mod_internal__S_546ColonaParen_Thesis_01'; # we are top level ltm
}
my $C = $C->cursor_xact($x);
my $xact = $C->xact;

my @gather = ();
for (;;) {
if (not @try) {
$relex //= $C->cursor_fate('STD::Regex', 'mod_internal__S_546ColonaParen_Thesis_01', $retree);
@try = $relex->($C, $trystate);
}
last unless @try;
$try = shift(@try) // next;

if (ref $try eq 'ARRAY') {
($C->{'_fate'}, $tag, $try) = @$try;	# next candidate fate
}

$C->deb("mod_internal__S_546ColonaParen_Thesis_01 trying $tag $try") if $::DEBUG & DEBUG::try_processing;
push @gather, ((
sub { my $C=shift;
$C->_EXACT(':a')
},
sub { my $C=shift;
$C->_EXACT(':ignoreaccent')
},
)[$try])->($C);
last if $xact->[-2];  # committed?
last if @gather;
}
@gather;
};
@result;
}

})
}))) {
do {
if (my ($C) = ($C->_SUBSUMEr(['mod_arg'], sub {
my $C = shift;
$C->mod_arg
}))) {
scalar(do {
my $M = $C;  $::RX{'a'} = eval $M->{'mod_arg'}->Str ;
}, $C);
}
else {
();
}
};
}
else {
();
}
}
);
}
##     token mod_internal__S_547Colon0a (:$*sym = <:0a>)
##          token mod_internal:sym<:0a>   { ':' (\d+) ['a'|'ignoreaccent'] { %*RX<a> = $0 } }

sub mod_internal__S_547Colon0a__PEEK { $_[0]->_AUTOLEXpeek('mod_internal__S_547Colon0a',$retree) }
sub mod_internal__S_547Colon0a {
no warnings 'recursion';
my $self = shift;
local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;
my %args = @_;
local $::sym = $args{sym} // q(:0a);


my $C = $self->cursor_xact("RULE mod_internal__S_547Colon0a");
my $xact = $C->xact;
my $S = $C->{'_pos'};
$C->{'sym'} = ref $sym ? join(' ', @$sym) : $sym;

$self->_MATCHIFYr($S, "mod_internal__S_547Colon0a", 
do {
if (my ($C) = ($C->_EXACT(':'))) {
do {
if (my ($C) = (  $C->_SUBSUMEr(['0'], sub {
my $C = shift;
do { $C->_PAREN( sub { my $C=shift;
$C->_PATTERN(qr/\G((?:\d)++)/)
})}
}))) {
do {
if (my ($C) = ($C->_BRACKETr(sub {
my $C=shift;
do {
my @result = do {
my $trystate;
my ($tag, $try);
my @try;
my $relex;

my $fate;
my $x;
if ($fate = $C->{'_fate'} and $fate->[1] eq 'mod_internal__S_547Colon0a_02') {
$C->deb("Fate passed to mod_internal__S_547Colon0a_02: ", ::fatestr($fate)) if $::DEBUG & DEBUG::fates;
($C->{'_fate'}, $tag, $try) = @$fate;
@try = ($try);
$x = 'ALT mod_internal__S_547Colon0a_02';    # some outer ltm is controlling us
}
else {
$x = 'ALTLTM mod_internal__S_547Colon0a_02'; # we are top level ltm
}
my $C = $C->cursor_xact($x);
my $xact = $C->xact;

my @gather = ();
for (;;) {
if (not @try) {
$relex //= $C->cursor_fate('STD::Regex', 'mod_internal__S_547Colon0a_02', $retree);
@try = $relex->($C, $trystate);
}
last unless @try;
$try = shift(@try) // next;

if (ref $try eq 'ARRAY') {
($C->{'_fate'}, $tag, $try) = @$try;	# next candidate fate
}

$C->deb("mod_internal__S_547Colon0a_02 trying $tag $try") if $::DEBUG & DEBUG::try_processing;
push @gather, ((
sub { my $C=shift;
$C->_EXACT('a')
},
sub { my $C=shift;
$C->_EXACT('ignoreaccent')
},
)[$try])->($C);
last if $xact->[-2];  # committed?
last if @gather;
}
@gather;
};
@result;
}

}))) {
scalar(do {
$::RX{'a'} = $C->{'0'} 
}, $C);
}
else {
();
}
};
}
else {
();
}
};
}
else {
();
}
}
);
}

##     token mod_internal__S_548Colons (:$*sym = <:s>)
##          token mod_internal:sym<:s>    { ':s' 'igspace'?  { %*RX<s> = 1 } }

sub mod_internal__S_548Colons__PEEK { $_[0]->_AUTOLEXpeek('mod_internal__S_548Colons',$retree) }
sub mod_internal__S_548Colons {
no warnings 'recursion';
my $self = shift;
local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;
my %args = @_;
local $::sym = $args{sym} // q(:s);


my $C = $self->cursor_xact("RULE mod_internal__S_548Colons");
my $xact = $C->xact;
my $S = $C->{'_pos'};
$C->{'sym'} = ref $sym ? join(' ', @$sym) : $sym;

$self->_MATCHIFYr($S, "mod_internal__S_548Colons", 
do {
if (my ($C) = ($C->_EXACT(':s'))) {
do {
if (my ($C) = ($C->_OPTr(sub { my $C=shift;
$C->_EXACT('igspace')
}))) {
do {
if (my ($C) = ($C->_PATTERN(qr/\G\b/))) {
scalar(do {
$::RX{'s'} = 1 
}, $C);
}
else {
();
}
};
}
else {
();
}
};
}
else {
();
}
}
);
}
##     token mod_internal__S_549ColonBangs (:$*sym = <:!s>)
##          token mod_internal:sym<:!s>   { ':!s' 'igspace'?  { %*RX<s> = 0 } }

sub mod_internal__S_549ColonBangs__PEEK { $_[0]->_AUTOLEXpeek('mod_internal__S_549ColonBangs',$retree) }
sub mod_internal__S_549ColonBangs {
no warnings 'recursion';
my $self = shift;
local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;
my %args = @_;
local $::sym = $args{sym} // q(:!s);


my $C = $self->cursor_xact("RULE mod_internal__S_549ColonBangs");
my $xact = $C->xact;
my $S = $C->{'_pos'};
$C->{'sym'} = ref $sym ? join(' ', @$sym) : $sym;

$self->_MATCHIFYr($S, "mod_internal__S_549ColonBangs", 
do {
if (my ($C) = ($C->_EXACT(':!s'))) {
do {
if (my ($C) = ($C->_OPTr(sub { my $C=shift;
$C->_EXACT('igspace')
}))) {
do {
if (my ($C) = ($C->_PATTERN(qr/\G\b/))) {
scalar(do {
$::RX{'s'} = 0 
}, $C);
}
else {
();
}
};
}
else {
();
}
};
}
else {
();
}
}
);
}
##     token mod_internal__S_550ColonsParen_Thesis (:$*sym = <:s( )>)
##          token mod_internal:sym<:s( )> { ':s' 'igspace'? <mod_arg> { %*RX<s> = eval $<mod_arg>.Str } }

sub mod_internal__S_550ColonsParen_Thesis__PEEK { $_[0]->_AUTOLEXpeek('mod_internal__S_550ColonsParen_Thesis',$retree) }
sub mod_internal__S_550ColonsParen_Thesis {
no warnings 'recursion';
my $self = shift;
local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;
my %args = @_;
local $::sym = $args{sym} // [qw[:s( )]];


my $C = $self->cursor_xact("RULE mod_internal__S_550ColonsParen_Thesis");
my $xact = $C->xact;
my $S = $C->{'_pos'};
$C->{'sym'} = ref $sym ? join(' ', @$sym) : $sym;

$self->_MATCHIFYr($S, "mod_internal__S_550ColonsParen_Thesis", 
do {
if (my ($C) = ($C->_EXACT(':s'))) {
do {
if (my ($C) = ($C->_OPTr(sub { my $C=shift;
$C->_EXACT('igspace')
}))) {
do {
if (my ($C) = ($C->_SUBSUMEr(['mod_arg'], sub {
my $C = shift;
$C->mod_arg
}))) {
scalar(do {
my $M = $C;  $::RX{'s'} = eval $M->{'mod_arg'}->Str ;
}, $C);
}
else {
();
}
};
}
else {
();
}
};
}
else {
();
}
}
);
}
##     token mod_internal__S_551Colon0s (:$*sym = <:0s>)
##          token mod_internal:sym<:0s>   { ':' (\d+) 's' 'igspace'?  { %*RX<s> = $0 } }

sub mod_internal__S_551Colon0s__PEEK { $_[0]->_AUTOLEXpeek('mod_internal__S_551Colon0s',$retree) }
sub mod_internal__S_551Colon0s {
no warnings 'recursion';
my $self = shift;
local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;
my %args = @_;
local $::sym = $args{sym} // q(:0s);


my $C = $self->cursor_xact("RULE mod_internal__S_551Colon0s");
my $xact = $C->xact;
my $S = $C->{'_pos'};
$C->{'sym'} = ref $sym ? join(' ', @$sym) : $sym;

$self->_MATCHIFYr($S, "mod_internal__S_551Colon0s", 
do {
if (my ($C) = ($C->_EXACT(':'))) {
do {
if (my ($C) = (  $C->_SUBSUMEr(['0'], sub {
my $C = shift;
do { $C->_PAREN( sub { my $C=shift;
$C->_PATTERN(qr/\G((?:\d)++)/)
})}
}))) {
do {
if (my ($C) = ($C->_EXACT('s'))) {
do {
if (my ($C) = ($C->_OPTr(sub { my $C=shift;
$C->_EXACT('igspace')
}))) {
do {
if (my ($C) = ($C->_PATTERN(qr/\G\b/))) {
scalar(do {
$::RX{'s'} = $C->{'0'} 
}, $C);
}
else {
();
}
};
}
else {
();
}
};
}
else {
();
}
};
}
else {
();
}
};
}
else {
();
}
}
);
}

##     token mod_internal__S_552Colonr (:$*sym = <:r>)
##          token mod_internal:sym<:r>    { ':r' 'atchet'?  { %*RX<r> = 1 } }

sub mod_internal__S_552Colonr__PEEK { $_[0]->_AUTOLEXpeek('mod_internal__S_552Colonr',$retree) }
sub mod_internal__S_552Colonr {
no warnings 'recursion';
my $self = shift;
local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;
my %args = @_;
local $::sym = $args{sym} // q(:r);


my $C = $self->cursor_xact("RULE mod_internal__S_552Colonr");
my $xact = $C->xact;
my $S = $C->{'_pos'};
$C->{'sym'} = ref $sym ? join(' ', @$sym) : $sym;

$self->_MATCHIFYr($S, "mod_internal__S_552Colonr", 
do {
if (my ($C) = ($C->_EXACT(':r'))) {
do {
if (my ($C) = ($C->_OPTr(sub { my $C=shift;
$C->_EXACT('atchet')
}))) {
do {
if (my ($C) = ($C->_PATTERN(qr/\G\b/))) {
scalar(do {
$::RX{'r'} = 1 
}, $C);
}
else {
();
}
};
}
else {
();
}
};
}
else {
();
}
}
);
}
##     token mod_internal__S_553ColonBangr (:$*sym = <:!r>)
##          token mod_internal:sym<:!r>   { ':!r' 'atchet'?  { %*RX<r> = 0 } }

sub mod_internal__S_553ColonBangr__PEEK { $_[0]->_AUTOLEXpeek('mod_internal__S_553ColonBangr',$retree) }
sub mod_internal__S_553ColonBangr {
no warnings 'recursion';
my $self = shift;
local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;
my %args = @_;
local $::sym = $args{sym} // q(:!r);


my $C = $self->cursor_xact("RULE mod_internal__S_553ColonBangr");
my $xact = $C->xact;
my $S = $C->{'_pos'};
$C->{'sym'} = ref $sym ? join(' ', @$sym) : $sym;

$self->_MATCHIFYr($S, "mod_internal__S_553ColonBangr", 
do {
if (my ($C) = ($C->_EXACT(':!r'))) {
do {
if (my ($C) = ($C->_OPTr(sub { my $C=shift;
$C->_EXACT('atchet')
}))) {
do {
if (my ($C) = ($C->_PATTERN(qr/\G\b/))) {
scalar(do {
$::RX{'r'} = 0 
}, $C);
}
else {
();
}
};
}
else {
();
}
};
}
else {
();
}
}
);
}
##     token mod_internal__S_554ColonrParen_Thesis (:$*sym = <:r( )>)
##          token mod_internal:sym<:r( )> { ':r' 'atchet'?  <mod_arg> { %*RX<r> = eval $<mod_arg>.Str } }

sub mod_internal__S_554ColonrParen_Thesis__PEEK { $_[0]->_AUTOLEXpeek('mod_internal__S_554ColonrParen_Thesis',$retree) }
sub mod_internal__S_554ColonrParen_Thesis {
no warnings 'recursion';
my $self = shift;
local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;
my %args = @_;
local $::sym = $args{sym} // [qw[:r( )]];


my $C = $self->cursor_xact("RULE mod_internal__S_554ColonrParen_Thesis");
my $xact = $C->xact;
my $S = $C->{'_pos'};
$C->{'sym'} = ref $sym ? join(' ', @$sym) : $sym;

$self->_MATCHIFYr($S, "mod_internal__S_554ColonrParen_Thesis", 
do {
if (my ($C) = ($C->_EXACT(':r'))) {
do {
if (my ($C) = ($C->_OPTr(sub { my $C=shift;
$C->_EXACT('atchet')
}))) {
do {
if (my ($C) = ($C->_PATTERN(qr/\G\b/))) {
do {
if (my ($C) = ($C->_SUBSUMEr(['mod_arg'], sub {
my $C = shift;
$C->mod_arg
}))) {
scalar(do {
my $M = $C;  $::RX{'r'} = eval $M->{'mod_arg'}->Str ;
}, $C);
}
else {
();
}
};
}
else {
();
}
};
}
else {
();
}
};
}
else {
();
}
}
);
}
##     token mod_internal__S_555Colon0r (:$*sym = <:0r>)
##          token mod_internal:sym<:0r>   { ':' (\d+) 'r' 'atchet'?  { %*RX<r> = $0 } }

sub mod_internal__S_555Colon0r__PEEK { $_[0]->_AUTOLEXpeek('mod_internal__S_555Colon0r',$retree) }
sub mod_internal__S_555Colon0r {
no warnings 'recursion';
my $self = shift;
local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;
my %args = @_;
local $::sym = $args{sym} // q(:0r);


my $C = $self->cursor_xact("RULE mod_internal__S_555Colon0r");
my $xact = $C->xact;
my $S = $C->{'_pos'};
$C->{'sym'} = ref $sym ? join(' ', @$sym) : $sym;

$self->_MATCHIFYr($S, "mod_internal__S_555Colon0r", 
do {
if (my ($C) = ($C->_EXACT(':'))) {
do {
if (my ($C) = (  $C->_SUBSUMEr(['0'], sub {
my $C = shift;
do { $C->_PAREN( sub { my $C=shift;
$C->_PATTERN(qr/\G((?:\d)++)/)
})}
}))) {
do {
if (my ($C) = ($C->_EXACT('r'))) {
do {
if (my ($C) = ($C->_OPTr(sub { my $C=shift;
$C->_EXACT('atchet')
}))) {
do {
if (my ($C) = ($C->_PATTERN(qr/\G\b/))) {
scalar(do {
$::RX{'r'} = $C->{'0'} 
}, $C);
}
else {
();
}
};
}
else {
();
}
};
}
else {
();
}
};
}
else {
();
}
};
}
else {
();
}
}
);
}

##     token mod_internal__S_556ColonPerl5 (:$*sym = <:Perl5>)
##          token mod_internal:sym<:Perl5>    { [':Perl5' | ':P5'] <.require_P5> [ :lang( $.cursor_fresh( %*LANG<P5Regex> ).unbalanced($*GOAL) ) <nibbler> ] }

sub mod_internal__S_556ColonPerl5__PEEK { $_[0]->_AUTOLEXpeek('mod_internal__S_556ColonPerl5',$retree) }
sub mod_internal__S_556ColonPerl5 {
no warnings 'recursion';
my $self = shift;
local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;
my %args = @_;
local $::sym = $args{sym} // q(:Perl5);


my $C = $self->cursor_xact("RULE mod_internal__S_556ColonPerl5");
my $xact = $C->xact;
my $S = $C->{'_pos'};
$C->{'sym'} = ref $sym ? join(' ', @$sym) : $sym;

$self->_MATCHIFYr($S, "mod_internal__S_556ColonPerl5", 
do {
if (my ($C) = ($C->_BRACKETr(sub {
my $C=shift;
do {
my @result = do {
my $trystate;
my ($tag, $try);
my @try;
my $relex;

my $fate;
my $x;
if ($fate = $C->{'_fate'} and $fate->[1] eq 'mod_internal__S_556ColonPerl5_01') {
$C->deb("Fate passed to mod_internal__S_556ColonPerl5_01: ", ::fatestr($fate)) if $::DEBUG & DEBUG::fates;
($C->{'_fate'}, $tag, $try) = @$fate;
@try = ($try);
$x = 'ALT mod_internal__S_556ColonPerl5_01';    # some outer ltm is controlling us
}
else {
$x = 'ALTLTM mod_internal__S_556ColonPerl5_01'; # we are top level ltm
}
my $C = $C->cursor_xact($x);
my $xact = $C->xact;

my @gather = ();
for (;;) {
if (not @try) {
$relex //= $C->cursor_fate('STD::Regex', 'mod_internal__S_556ColonPerl5_01', $retree);
@try = $relex->($C, $trystate);
}
last unless @try;
$try = shift(@try) // next;

if (ref $try eq 'ARRAY') {
($C->{'_fate'}, $tag, $try) = @$try;	# next candidate fate
}

$C->deb("mod_internal__S_556ColonPerl5_01 trying $tag $try") if $::DEBUG & DEBUG::try_processing;
push @gather, ((
sub { my $C=shift;
$C->_EXACT(':Perl5')
},
sub { my $C=shift;
$C->_EXACT(':P5')
},
)[$try])->($C);
last if $xact->[-2];  # committed?
last if @gather;
}
@gather;
};
@result;
}

}))) {
do {
if (my ($C) = ($C->require_P5)) {
$C->_BRACKETr(sub {
my $C=shift;
my $newlang = ( $C->cursor_fresh( $::LANG{'P5Regex'} )->unbalanced($::GOAL) );  $C = $C->cursor_fresh($newlang); ;$C->_SUBSUMEr(['nibbler'], sub {
my $C = shift;
$C->nibbler
})
});
}
else {
();
}
};
}
else {
();
}
}
);
}

##     token mod_internal__S_557adv (:$*sym = 'adv')
##          token mod_internal:adv {
##              <?before ':' <.identifier> > [ :lang($.cursor_fresh(%*LANG<MAIN>)) <quotepair> ] { $/<sym> := : $<quotepair><key> }
##          }

sub mod_internal__S_557adv__PEEK { $_[0]->_AUTOLEXpeek('mod_internal__S_557adv',$retree) }
sub mod_internal__S_557adv {
no warnings 'recursion';
my $self = shift;
local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;
my %args = @_;
local $::sym = $args{sym} // 'adv';


my $C = $self->cursor_xact("RULE mod_internal__S_557adv");
my $xact = $C->xact;
my $S = $C->{'_pos'};
$C->{'sym'} = ref $sym ? join(' ', @$sym) : $sym;

$self->_MATCHIFYr($S, "mod_internal__S_557adv", 
do {
if (my ($C) = ($C->before(sub { my $C=shift;
do {
if (my ($C) = ($C->_EXACT(':'))) {
$C->identifier;
}
else {
();
}
}
}))) {
do {
if (my ($C) = ($C->_BRACKETr(sub {
my $C=shift;
my $newlang = ($C->cursor_fresh($::LANG{'MAIN'}));  $C = $C->cursor_fresh($newlang); ;$C->_SUBSUMEr(['quotepair'], sub {
my $C = shift;
$C->quotepair
})
}))) {
scalar(do {
my $M = $C;  $M->{'sym'} =[':','$<quotepair><key>'] ;
}, $C);
}
else {
();
}
};
}
else {
();
}
}
);
}

##     token mod_internal__S_558oops (:$*sym = 'oops')
##          token mod_internal:oops { ':'\w+ <.panic: "Unrecognized regex modifier"> }

sub mod_internal__S_558oops__PEEK { $_[0]->_AUTOLEXpeek('mod_internal__S_558oops',$retree) }
sub mod_internal__S_558oops {
no warnings 'recursion';
my $self = shift;
local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;
my %args = @_;
local $::sym = $args{sym} // 'oops';


my $C = $self->cursor_xact("RULE mod_internal__S_558oops");
my $xact = $C->xact;
my $S = $C->{'_pos'};
$C->{'sym'} = ref $sym ? join(' ', @$sym) : $sym;

$self->_MATCHIFYr($S, "mod_internal__S_558oops", 
do {
if (my ($C) = ($C->_EXACT(':'))) {
do {
if (my ($C) = ($C->_PATTERN(qr/\G((?:\w)++)/))) {
$C->panic("Unrecognized regex modifier");
}
else {
();
}
};
}
else {
();
}
}
);
}

##     token quantifier__S_559Star (:$*sym = <*>)
##          token quantifier:sym<*>  { <sym> <quantmod> }

sub quantifier__S_559Star__PEEK { $_[0]->_AUTOLEXpeek('quantifier__S_559Star',$retree) }
sub quantifier__S_559Star {
no warnings 'recursion';
my $self = shift;
local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;
my %args = @_;
local $::sym = $args{sym} // q(*);


my $C = $self->cursor_xact("RULE quantifier__S_559Star");
my $xact = $C->xact;
my $S = $C->{'_pos'};
$C->{'sym'} = ref $sym ? join(' ', @$sym) : $sym;

$self->_MATCHIFYr($S, "quantifier__S_559Star", 
do {
if (my ($C) = ($C->_PATTERN(qr/\G\*/))) {
$C->_SUBSUMEr(['quantmod'], sub {
my $C = shift;
$C->quantmod
});
}
else {
();
}
}
);
}
##     token quantifier__S_560Plus (:$*sym = <+>)
##          token quantifier:sym<+>  { <sym> <quantmod> }

sub quantifier__S_560Plus__PEEK { $_[0]->_AUTOLEXpeek('quantifier__S_560Plus',$retree) }
sub quantifier__S_560Plus {
no warnings 'recursion';
my $self = shift;
local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;
my %args = @_;
local $::sym = $args{sym} // q(+);


my $C = $self->cursor_xact("RULE quantifier__S_560Plus");
my $xact = $C->xact;
my $S = $C->{'_pos'};
$C->{'sym'} = ref $sym ? join(' ', @$sym) : $sym;

$self->_MATCHIFYr($S, "quantifier__S_560Plus", 
do {
if (my ($C) = ($C->_PATTERN(qr/\G\+/))) {
$C->_SUBSUMEr(['quantmod'], sub {
my $C = shift;
$C->quantmod
});
}
else {
();
}
}
);
}
##     token quantifier__S_561Question (:$*sym = <?>)
##          token quantifier:sym<?>  { <sym> <quantmod> }

sub quantifier__S_561Question__PEEK { $_[0]->_AUTOLEXpeek('quantifier__S_561Question',$retree) }
sub quantifier__S_561Question {
no warnings 'recursion';
my $self = shift;
local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;
my %args = @_;
local $::sym = $args{sym} // q(?);


my $C = $self->cursor_xact("RULE quantifier__S_561Question");
my $xact = $C->xact;
my $S = $C->{'_pos'};
$C->{'sym'} = ref $sym ? join(' ', @$sym) : $sym;

$self->_MATCHIFYr($S, "quantifier__S_561Question", 
do {
if (my ($C) = ($C->_PATTERN(qr/\G\?/))) {
$C->_SUBSUMEr(['quantmod'], sub {
my $C = shift;
$C->quantmod
});
}
else {
();
}
}
);
}
##     token quantifier__S_562StarStar (:$*sym = <**>)
##          token quantifier:sym<**> { <sym> :: <normspace>? <quantmod> <normspace>?
##              [
##              | \d+ \s+ '..' <.panic: "Spaces not allowed in bare range">
##              | \d+ [ '..' [ \d+ | '*' | <.panic: "Malformed range"> ] ]?
##              | <embeddedblock>
##              | <quantified_atom>
##              ]
##          }

sub quantifier__S_562StarStar__PEEK { $_[0]->_AUTOLEXpeek('quantifier__S_562StarStar',$retree) }
sub quantifier__S_562StarStar {
no warnings 'recursion';
my $self = shift;
local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;
my %args = @_;
local $::sym = $args{sym} // q(**);


my $C = $self->cursor_xact("RULE quantifier__S_562StarStar");
my $xact = $C->xact;
my $S = $C->{'_pos'};
$C->{'normspace'} = [];
$C->{'sym'} = ref $sym ? join(' ', @$sym) : $sym;

$self->_MATCHIFYr($S, "quantifier__S_562StarStar", 
do {
if (my ($C) = ($C->_PATTERN(qr/\G\*\*/))) {
do {
if (my ($C) = ($C->_COMMITLTM())) {
do {
if (my ($C) = ($C->_OPTr(sub { my $C=shift;
$C->_SUBSUMEr(['normspace'], sub {
my $C = shift;
$C->normspace
})
}))) {
do {
if (my ($C) = ($C->_SUBSUMEr(['quantmod'], sub {
my $C = shift;
$C->quantmod
}))) {
do {
if (my ($C) = ($C->_OPTr(sub { my $C=shift;
$C->_SUBSUMEr(['normspace'], sub {
my $C = shift;
$C->normspace
})
}))) {
$C->_BRACKETr(sub {
my $C=shift;
do {
my @result = do {
my $trystate;
my ($tag, $try);
my @try;
my $relex;

my $fate;
my $x;
if ($fate = $C->{'_fate'} and $fate->[1] eq 'quantifier__S_562StarStar_01') {
$C->deb("Fate passed to quantifier__S_562StarStar_01: ", ::fatestr($fate)) if $::DEBUG & DEBUG::fates;
($C->{'_fate'}, $tag, $try) = @$fate;
@try = ($try);
$x = 'ALT quantifier__S_562StarStar_01';    # some outer ltm is controlling us
}
else {
$x = 'ALTLTM quantifier__S_562StarStar_01'; # we are top level ltm
}
my $C = $C->cursor_xact($x);
my $xact = $C->xact;

my @gather = ();
for (;;) {
if (not @try) {
$relex //= $C->cursor_fate('STD::Regex', 'quantifier__S_562StarStar_01', $retree);
@try = $relex->($C, $trystate);
}
last unless @try;
$try = shift(@try) // next;

if (ref $try eq 'ARRAY') {
($C->{'_fate'}, $tag, $try) = @$try;	# next candidate fate
}

$C->deb("quantifier__S_562StarStar_01 trying $tag $try") if $::DEBUG & DEBUG::try_processing;
push @gather, ((
sub { my $C=shift;
do {
if (my ($C) = ($C->_PATTERN(qr/\G((?:\d)++)/))) {
do {
if (my ($C) = ($C->_PATTERN(qr/\G((?:\s)++)/))) {
do {
if (my ($C) = ($C->_EXACT('..'))) {
$C->panic("Spaces not allowed in bare range");
}
else {
();
}
};
}
else {
();
}
};
}
else {
();
}
}
},
sub { my $C=shift;
do {
if (my ($C) = ($C->_PATTERN(qr/\G((?:\d)++)/))) {
$C->_OPTr(sub { my $C=shift;
$C->_BRACKETr(sub {
my $C=shift;
do {
if (my ($C) = ($C->_EXACT('..'))) {
$C->_BRACKETr(sub {
my $C=shift;
do {
my @result = do {
my $trystate;
my ($tag, $try);
my @try;
my $relex;

my $fate;
my $x;
if ($fate = $C->{'_fate'} and $fate->[1] eq 'quantifier__S_562StarStar_03') {
$C->deb("Fate passed to quantifier__S_562StarStar_03: ", ::fatestr($fate)) if $::DEBUG & DEBUG::fates;
($C->{'_fate'}, $tag, $try) = @$fate;
@try = ($try);
$x = 'ALT quantifier__S_562StarStar_03';    # some outer ltm is controlling us
}
else {
$x = 'ALTLTM quantifier__S_562StarStar_03'; # we are top level ltm
}
my $C = $C->cursor_xact($x);
my $xact = $C->xact;

my @gather = ();
for (;;) {
if (not @try) {
$relex //= $C->cursor_fate('STD::Regex', 'quantifier__S_562StarStar_03', $retree);
@try = $relex->($C, $trystate);
}
last unless @try;
$try = shift(@try) // next;

if (ref $try eq 'ARRAY') {
($C->{'_fate'}, $tag, $try) = @$try;	# next candidate fate
}

$C->deb("quantifier__S_562StarStar_03 trying $tag $try") if $::DEBUG & DEBUG::try_processing;
push @gather, ((
sub { my $C=shift;
$C->_PATTERN(qr/\G((?:\d)++)/)
},
sub { my $C=shift;
$C->_EXACT('*')
},
sub { my $C=shift;
$C->panic("Malformed range")
},
)[$try])->($C);
last if $xact->[-2];  # committed?
last if @gather;
}
@gather;
};
@result;
}

});
}
else {
();
}
}
})
});
}
else {
();
}
}
},
sub { my $C=shift;
$C->_SUBSUMEr(['embeddedblock'], sub {
my $C = shift;
$C->embeddedblock
})
},
sub { my $C=shift;
$C->_SUBSUMEr(['quantified_atom'], sub {
my $C = shift;
$C->quantified_atom
})
},
)[$try])->($C);
last if $xact->[-2];  # committed?
last if @gather;
}
@gather;
};
@result;
}

});
}
else {
();
}
};
}
else {
();
}
};
}
else {
();
}
};
}
else {
();
}
};
}
else {
();
}
}
);
}

##     token quantifier__S_563TildeTilde (:$*sym = <~~>)
##          token quantifier:sym<~~> {
##              [
##              | '!' <sym>
##              | <sym>
##              ]
##              <normspace> <quantified_atom> }

sub quantifier__S_563TildeTilde__PEEK { $_[0]->_AUTOLEXpeek('quantifier__S_563TildeTilde',$retree) }
sub quantifier__S_563TildeTilde {
no warnings 'recursion';
my $self = shift;
local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;
my %args = @_;
local $::sym = $args{sym} // q(~~);


my $C = $self->cursor_xact("RULE quantifier__S_563TildeTilde");
my $xact = $C->xact;
my $S = $C->{'_pos'};
$C->{'sym'} = ref $sym ? join(' ', @$sym) : $sym;

$self->_MATCHIFYr($S, "quantifier__S_563TildeTilde", 
do {
if (my ($C) = ($C->_BRACKETr(sub {
my $C=shift;
do {
my @result = do {
my $trystate;
my ($tag, $try);
my @try;
my $relex;

my $fate;
my $x;
if ($fate = $C->{'_fate'} and $fate->[1] eq 'quantifier__S_563TildeTilde_01') {
$C->deb("Fate passed to quantifier__S_563TildeTilde_01: ", ::fatestr($fate)) if $::DEBUG & DEBUG::fates;
($C->{'_fate'}, $tag, $try) = @$fate;
@try = ($try);
$x = 'ALT quantifier__S_563TildeTilde_01';    # some outer ltm is controlling us
}
else {
$x = 'ALTLTM quantifier__S_563TildeTilde_01'; # we are top level ltm
}
my $C = $C->cursor_xact($x);
my $xact = $C->xact;

my @gather = ();
for (;;) {
if (not @try) {
$relex //= $C->cursor_fate('STD::Regex', 'quantifier__S_563TildeTilde_01', $retree);
@try = $relex->($C, $trystate);
}
last unless @try;
$try = shift(@try) // next;

if (ref $try eq 'ARRAY') {
($C->{'_fate'}, $tag, $try) = @$try;	# next candidate fate
}

$C->deb("quantifier__S_563TildeTilde_01 trying $tag $try") if $::DEBUG & DEBUG::try_processing;
push @gather, ((
sub { my $C=shift;
do {
if (my ($C) = ($C->_EXACT('!'))) {
$C->_PATTERN(qr/\G\~\~/);
}
else {
();
}
}
},
sub { my $C=shift;
$C->_PATTERN(qr/\G\~\~/)
},
)[$try])->($C);
last if $xact->[-2];  # committed?
last if @gather;
}
@gather;
};
@result;
}

}))) {
do {
if (my ($C) = ($C->_SUBSUMEr(['normspace'], sub {
my $C = shift;
$C->normspace
}))) {
$C->_SUBSUMEr(['quantified_atom'], sub {
my $C = shift;
$C->quantified_atom
});
}
else {
();
}
};
}
else {
();
}
}
);
}

##     token quantmod
##          token quantmod { ':'? [ '?' | '!' | '+' ]? }

sub quantmod__PEEK { $_[0]->_AUTOLEXpeek('quantmod',$retree) }
sub quantmod {
no warnings 'recursion';
my $self = shift;
local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;


my $C = $self->cursor_xact("RULE quantmod");
my $xact = $C->xact;
my $S = $C->{'_pos'};

$self->_MATCHIFYr($S, "quantmod", 
do {
if (my ($C) = ($C->_OPTr(sub { my $C=shift;
$C->_EXACT(':')
}))) {
$C->_OPTr(sub { my $C=shift;
$C->_BRACKETr(sub {
my $C=shift;
do {
my @result = do {
my $trystate;
my ($tag, $try);
my @try;
my $relex;

my $fate;
my $x;
if ($fate = $C->{'_fate'} and $fate->[1] eq 'quantmod_01') {
$C->deb("Fate passed to quantmod_01: ", ::fatestr($fate)) if $::DEBUG & DEBUG::fates;
($C->{'_fate'}, $tag, $try) = @$fate;
@try = ($try);
$x = 'ALT quantmod_01';    # some outer ltm is controlling us
}
else {
$x = 'ALTLTM quantmod_01'; # we are top level ltm
}
my $C = $C->cursor_xact($x);
my $xact = $C->xact;

my @gather = ();
for (;;) {
if (not @try) {
$relex //= $C->cursor_fate('STD::Regex', 'quantmod_01', $retree);
@try = $relex->($C, $trystate);
}
last unless @try;
$try = shift(@try) // next;

if (ref $try eq 'ARRAY') {
($C->{'_fate'}, $tag, $try) = @$try;	# next candidate fate
}

$C->deb("quantmod_01 trying $tag $try") if $::DEBUG & DEBUG::try_processing;
push @gather, ((
sub { my $C=shift;
$C->_EXACT('?')
},
sub { my $C=shift;
$C->_EXACT('!')
},
sub { my $C=shift;
$C->_EXACT('+')
},
)[$try])->($C);
last if $xact->[-2];  # committed?
last if @gather;
}
@gather;
};
@result;
}

})
});
}
else {
();
}
}
);
}

BEGIN {
$retree = YAML::XS::Load(Encode::encode_utf8(<<'RETREE_END'));
---
assertion__S_522DotDotDot: !!perl/hash:RE_ast
  decl: []
  kind: token
  min: 12345
  pkg: ~
  re: !!perl/hash:RE_method
    a: 0
    dba: assertion__S_522DotDotDot
    i: 0
    min: 12345
    name: sym
    r: 1
    rest: ''
    s: 0
    sym: '...'
assertion__S_523QuestionQuestionQuestion: !!perl/hash:RE_ast
  decl: []
  kind: token
  min: 12345
  pkg: ~
  re: !!perl/hash:RE_method
    a: 0
    dba: assertion__S_523QuestionQuestionQuestion
    i: 0
    min: 12345
    name: sym
    r: 1
    rest: ''
    s: 0
    sym: ???
assertion__S_524BangBangBang: !!perl/hash:RE_ast
  decl: []
  kind: token
  min: 12345
  pkg: ~
  re: !!perl/hash:RE_method
    a: 0
    dba: assertion__S_524BangBangBang
    i: 0
    min: 12345
    name: sym
    r: 1
    rest: ''
    s: 0
    sym: '!!!'
assertion__S_525Question: !!perl/hash:RE_ast
  decl: []
  kind: token
  min: 12345
  pkg: ~
  re: !!perl/hash:RE_sequence
    a: 0
    dba: assertion__S_525Question
    i: 0
    min: 12345
    r: 1
    s: 0
    zyg:
    - !!perl/hash:RE_method
      a: 0
      dba: assertion__S_525Question
      i: 0
      min: 12345
      name: sym
      r: 1
      rest: ''
      s: 0
      sym: '?'
    - !!perl/hash:RE_bracket
      decl: []
      min: 0
      re: &1 !!perl/hash:RE_any
        a: 0
        altname: assertion__S_525Question_01
        dba: assertion__S_525Question
        i: 0
        min: 0
        name: assertion__S_525Question_01
        r: 1
        s: 0
        zyg:
        - !!perl/hash:RE_assertion
          alt: assertion__S_525Question_01 0
          assert: '?'
          min: 0
          re: !!perl/hash:RE_method_re
            a: 0
            dba: assertion__S_525Question
            i: 0
            min: 0
            name: before
            nobind: 1
            r: 1
            re: !!perl/hash:RE_ast
              decl: []
              min: 1
              re: !!perl/hash:RE_string
                a: 0
                dba: assertion__S_525Question
                i: 0
                min: 1
                r: 1
                s: 0
                text: '>'
            s: 0
        - !!perl/hash:RE_method
          a: 0
          alt: assertion__S_525Question_01 1
          dba: assertion__S_525Question
          i: 0
          min: 12345
          name: assertion
          r: 1
          rest: ''
          s: 0
assertion__S_525Question_01: *1
assertion__S_526Bang: !!perl/hash:RE_ast
  decl: []
  kind: token
  min: 12345
  pkg: ~
  re: !!perl/hash:RE_sequence
    a: 0
    dba: assertion__S_526Bang
    i: 0
    min: 12345
    r: 1
    s: 0
    zyg:
    - !!perl/hash:RE_method
      a: 0
      dba: assertion__S_526Bang
      i: 0
      min: 12345
      name: sym
      r: 1
      rest: ''
      s: 0
      sym: '!'
    - !!perl/hash:RE_bracket
      decl: []
      min: 0
      re: &2 !!perl/hash:RE_any
        a: 0
        altname: assertion__S_526Bang_01
        dba: assertion__S_526Bang
        i: 0
        min: 0
        name: assertion__S_526Bang_01
        r: 1
        s: 0
        zyg:
        - !!perl/hash:RE_assertion
          alt: assertion__S_526Bang_01 0
          assert: '?'
          min: 0
          re: !!perl/hash:RE_method_re
            a: 0
            dba: assertion__S_526Bang
            i: 0
            min: 0
            name: before
            nobind: 1
            r: 1
            re: !!perl/hash:RE_ast
              decl: []
              min: 1
              re: !!perl/hash:RE_string
                a: 0
                dba: assertion__S_526Bang
                i: 0
                min: 1
                r: 1
                s: 0
                text: '>'
            s: 0
        - !!perl/hash:RE_method
          a: 0
          alt: assertion__S_526Bang_01 1
          dba: assertion__S_526Bang
          i: 0
          min: 12345
          name: assertion
          r: 1
          rest: ''
          s: 0
assertion__S_526Bang_01: *2
assertion__S_527Star: !!perl/hash:RE_ast
  decl: []
  kind: token
  min: 12345
  pkg: ~
  re: !!perl/hash:RE_sequence
    a: 0
    dba: assertion__S_527Star
    i: 0
    min: 12345
    r: 1
    s: 0
    zyg:
    - !!perl/hash:RE_method
      a: 0
      dba: assertion__S_527Star
      i: 0
      min: 12345
      name: sym
      r: 1
      rest: ''
      s: 0
      sym: '*'
    - !!perl/hash:RE_bracket
      decl: []
      min: 0
      re: &3 !!perl/hash:RE_any
        a: 0
        altname: assertion__S_527Star_01
        dba: assertion__S_527Star
        i: 0
        min: 0
        name: assertion__S_527Star_01
        r: 1
        s: 0
        zyg:
        - !!perl/hash:RE_assertion
          alt: assertion__S_527Star_01 0
          assert: '?'
          min: 0
          re: !!perl/hash:RE_method_re
            a: 0
            dba: assertion__S_527Star
            i: 0
            min: 0
            name: before
            nobind: 1
            r: 1
            re: !!perl/hash:RE_ast
              decl: []
              min: 1
              re: !!perl/hash:RE_string
                a: 0
                dba: assertion__S_527Star
                i: 0
                min: 1
                r: 1
                s: 0
                text: '>'
            s: 0
        - !!perl/hash:RE_sequence
          a: 0
          alt: assertion__S_527Star_01 1
          dba: assertion__S_527Star
          i: 0
          min: 24690
          r: 1
          s: 0
          zyg:
          - !!perl/hash:RE_method
            a: 0
            dba: assertion__S_527Star
            i: 0
            min: 12345
            name: ws
            nobind: 1
            r: 1
            rest: ''
            s: 0
          - !!perl/hash:RE_method
            a: 0
            dba: assertion__S_527Star
            i: 0
            min: 12345
            name: nibbler
            r: 1
            rest: ''
            s: 0
assertion__S_527Star_01: *3
assertion__S_528Cur_Ly: !!perl/hash:RE_ast
  decl: []
  kind: token
  min: 12345
  pkg: ~
  re: !!perl/hash:RE_method
    a: 0
    dba: assertion__S_528Cur_Ly
    i: 0
    min: 12345
    name: embeddedblock
    r: 1
    rest: ''
    s: 0
assertion__S_529variable: !!perl/hash:RE_ast
  decl: []
  kind: token
  min: 0
  pkg: ~
  re: !!perl/hash:RE_sequence
    a: 0
    dba: assertion__S_529variable
    i: 0
    min: 0
    r: 1
    s: 0
    zyg:
    - !!perl/hash:RE_assertion
      assert: '?'
      min: 0
      re: !!perl/hash:RE_method_re
        a: 0
        dba: assertion__S_529variable
        i: 0
        min: 0
        name: before
        nobind: 1
        r: 1
        re: !!perl/hash:RE_ast
          decl: []
          min: 12345
          re: !!perl/hash:RE_method
            a: 0
            dba: assertion__S_529variable
            i: 0
            min: 12345
            name: sigil
            r: 1
            rest: ''
            s: 0
        s: 0
    - !!perl/hash:RE_bracket
      decl: []
      min: 0
      re: !!perl/hash:RE_sequence
        a: 0
        dba: assertion__S_529variable
        i: 0
        lang: ($C->cursor_fresh($::LANG{'MAIN'})->unbalanced('>'))
        min: 0
        r: 1
        s: 0
        zyg:
        - !!perl/hash:RE_decl
          a: 0
          dba: assertion__S_529variable
          i: 0
          lang: ($C->cursor_fresh($::LANG{'MAIN'})->unbalanced('>'))
          max: 0
          min: 0
          noquant: 1
          r: 1
          s: 0
          text: 'my $newlang = ($C->cursor_fresh($::LANG{''MAIN''})->unbalanced(''>''));  $C
            = $C->cursor_fresh($newlang); '
        - !!perl/hash:RE_bindnamed
          a: 0
          atom: !!perl/hash:RE_method
            min: 0
            name: EXPR
            nobind: 1
            rest: (item %LOOSEST)
          dba: assertion__S_529variable
          i: 0
          lang: ($C->cursor_fresh($::LANG{'MAIN'})->unbalanced('>'))
          min: 0
          r: 1
          s: 0
          var: variable
assertion__S_530method: !!perl/hash:RE_ast
  decl: []
  kind: token
  min: 12346
  pkg: ~
  re: !!perl/hash:RE_sequence
    a: 0
    dba: assertion__S_530method
    i: 0
    min: 12346
    r: 1
    s: 0
    zyg:
    - !!perl/hash:RE_string
      a: 0
      dba: assertion__S_530method
      i: 0
      min: 1
      r: 1
      s: 0
      text: .
    - !!perl/hash:RE_bracket
      decl: []
      min: 12345
      re: &4 !!perl/hash:RE_any
        a: 0
        altname: assertion__S_530method_01
        dba: assertion__S_530method
        i: 0
        min: 12345
        name: assertion__S_530method_01
        r: 1
        s: 0
        zyg:
        - !!perl/hash:RE_sequence
          a: 0
          alt: assertion__S_530method_01 0
          dba: assertion__S_530method
          i: 0
          min: 12345
          r: 1
          s: 0
          zyg:
          - !!perl/hash:RE_assertion
            assert: '?'
            min: 0
            re: !!perl/hash:RE_method_re
              a: 0
              dba: assertion__S_530method
              i: 0
              min: 0
              name: before
              nobind: 1
              r: 1
              re: !!perl/hash:RE_ast
                decl: []
                min: 12345
                re: !!perl/hash:RE_method
                  a: 0
                  dba: assertion__S_530method
                  i: 0
                  min: 12345
                  name: alpha
                  r: 1
                  rest: ''
                  s: 0
              s: 0
          - !!perl/hash:RE_method
            a: 0
            dba: assertion__S_530method
            i: 0
            min: 12345
            name: assertion
            r: 1
            rest: ''
            s: 0
        - !!perl/hash:RE_bracket
          alt: assertion__S_530method_01 1
          decl: []
          min: 12345
          re: !!perl/hash:RE_sequence
            a: 0
            dba: assertion__S_530method
            i: 0
            lang: ($C->cursor_fresh($::LANG{'MAIN'})->unbalanced('>'))
            min: 12345
            r: 1
            s: 0
            zyg:
            - !!perl/hash:RE_decl
              a: 0
              dba: assertion__S_530method
              i: 0
              lang: ($C->cursor_fresh($::LANG{'MAIN'})->unbalanced('>'))
              max: 0
              min: 0
              noquant: 1
              r: 1
              s: 0
              text: 'my $newlang = ($C->cursor_fresh($::LANG{''MAIN''})->unbalanced(''>''));  $C
                = $C->cursor_fresh($newlang); '
            - !!perl/hash:RE_method
              a: 0
              dba: assertion__S_530method
              i: 0
              lang: ($C->cursor_fresh($::LANG{'MAIN'})->unbalanced('>'))
              min: 12345
              name: dottyop
              r: 1
              rest: ''
              s: 0
assertion__S_530method_01: *4
assertion__S_531name: !!perl/hash:RE_ast
  decl: []
  kind: token
  min: 12345
  pkg: ~
  re: !!perl/hash:RE_sequence
    a: 0
    dba: assertion__S_531name
    i: 0
    min: 12345
    r: 1
    s: 0
    zyg:
    - !!perl/hash:RE_bracket
      decl: []
      min: 12345
      re: !!perl/hash:RE_sequence
        a: 0
        dba: assertion__S_531name
        i: 0
        lang: ($C->cursor_fresh($::LANG{'MAIN'})->unbalanced('>'))
        min: 12345
        r: 1
        s: 0
        zyg:
        - !!perl/hash:RE_decl
          a: 0
          dba: assertion__S_531name
          i: 0
          lang: ($C->cursor_fresh($::LANG{'MAIN'})->unbalanced('>'))
          max: 0
          min: 0
          noquant: 1
          r: 1
          s: 0
          text: 'my $newlang = ($C->cursor_fresh($::LANG{''MAIN''})->unbalanced(''>''));  $C
            = $C->cursor_fresh($newlang); '
        - !!perl/hash:RE_method
          a: 0
          dba: assertion__S_531name
          i: 0
          lang: ($C->cursor_fresh($::LANG{'MAIN'})->unbalanced('>'))
          min: 12345
          name: longname
          r: 1
          rest: ''
          s: 0
    - !!perl/hash:RE_quantified_atom
      atom: !!perl/hash:RE_bracket
        decl: []
        min: 0
        re: &5 !!perl/hash:RE_any
          a: 0
          altname: assertion__S_531name_02
          dba: assertion__S_531name
          i: 0
          min: 0
          name: assertion__S_531name_02
          r: 1
          s: 0
          zyg:
          - !!perl/hash:RE_assertion
            alt: assertion__S_531name_02 0
            assert: '?'
            min: 0
            re: !!perl/hash:RE_method_re
              a: 0
              dba: assertion__S_531name
              i: 0
              min: 0
              name: before
              nobind: 1
              r: 1
              re: !!perl/hash:RE_ast
                decl: []
                min: 1
                re: !!perl/hash:RE_string
                  a: 0
                  dba: assertion__S_531name
                  i: 0
                  min: 1
                  r: 1
                  s: 0
                  text: '>'
              s: 0
          - !!perl/hash:RE_sequence
            a: 0
            alt: assertion__S_531name_02 1
            dba: assertion__S_531name
            i: 0
            min: 24690
            r: 1
            s: 0
            zyg:
            - !!perl/hash:RE_method
              a: 0
              dba: assertion__S_531name
              i: 0
              min: 12345
              name: ws
              nobind: 1
              r: 1
              rest: ''
              s: 0
            - !!perl/hash:RE_method
              a: 0
              dba: assertion__S_531name
              i: 0
              min: 12345
              name: nibbler
              r: 1
              rest: ''
              s: 0
          - !!perl/hash:RE_sequence
            a: 0
            alt: assertion__S_531name_02 2
            dba: assertion__S_531name
            i: 0
            min: 12346
            r: 1
            s: 0
            zyg:
            - !!perl/hash:RE_string
              a: 0
              dba: assertion__S_531name
              i: 0
              min: 1
              r: 1
              s: 0
              text: =
            - !!perl/hash:RE_method
              a: 0
              dba: assertion__S_531name
              i: 0
              min: 12345
              name: assertion
              r: 1
              rest: ''
              s: 0
          - !!perl/hash:RE_sequence
            a: 0
            alt: assertion__S_531name_02 3
            dba: assertion__S_531name
            i: 0
            min: 24691
            r: 1
            s: 0
            zyg:
            - !!perl/hash:RE_string
              a: 0
              dba: assertion__S_531name
              i: 0
              min: 1
              r: 1
              s: 0
              text: ':'
            - !!perl/hash:RE_method
              a: 0
              dba: assertion__S_531name
              i: 0
              min: 12345
              name: ws
              nobind: 1
              r: 1
              rest: ''
              s: 0
            - !!perl/hash:RE_bracket
              decl: []
              min: 12345
              re: !!perl/hash:RE_sequence
                a: 0
                dba: assertion__S_531name
                i: 0
                lang: ($C->cursor_fresh($::LANG{'MAIN'})->unbalanced('>'))
                min: 12345
                r: 1
                s: 0
                zyg:
                - !!perl/hash:RE_decl
                  a: 0
                  dba: assertion__S_531name
                  i: 0
                  lang: ($C->cursor_fresh($::LANG{'MAIN'})->unbalanced('>'))
                  max: 0
                  min: 0
                  noquant: 1
                  r: 1
                  s: 0
                  text: 'my $newlang = ($C->cursor_fresh($::LANG{''MAIN''})->unbalanced(''>''));  $C
                    = $C->cursor_fresh($newlang); '
                - !!perl/hash:RE_method
                  a: 0
                  dba: assertion__S_531name
                  i: 0
                  lang: ($C->cursor_fresh($::LANG{'MAIN'})->unbalanced('>'))
                  min: 12345
                  name: arglist
                  r: 1
                  rest: ''
                  s: 0
          - !!perl/hash:RE_sequence
            a: 0
            alt: assertion__S_531name_02 4
            dba: assertion__S_531name
            i: 0
            min: 12346
            r: 1
            s: 0
            zyg:
            - !!perl/hash:RE_string
              a: 0
              dba: assertion__S_531name
              i: 0
              min: 1
              r: 1
              s: 0
              text: (
            - !!perl/hash:RE_block
              a: 0
              context: void
              dba: assertion__S_531name
              i: 0
              min: 0
              r: 1
              s: 0
              text: ''
            - !!perl/hash:RE_bracket
              decl: []
              min: 12345
              re: !!perl/hash:RE_sequence
                a: 0
                dba: assertion__S_531name
                i: 0
                lang: ($C->cursor_fresh($::LANG{'MAIN'}))
                min: 12345
                r: 1
                s: 0
                zyg:
                - !!perl/hash:RE_decl
                  a: 0
                  dba: assertion__S_531name
                  i: 0
                  lang: ($C->cursor_fresh($::LANG{'MAIN'}))
                  max: 0
                  min: 0
                  noquant: 1
                  r: 1
                  s: 0
                  text: 'my $newlang = ($C->cursor_fresh($::LANG{''MAIN''}));  $C
                    = $C->cursor_fresh($newlang); '
                - !!perl/hash:RE_method
                  a: 0
                  dba: assertion__S_531name
                  i: 0
                  lang: ($C->cursor_fresh($::LANG{'MAIN'}))
                  min: 12345
                  name: arglist
                  r: 1
                  rest: ''
                  s: 0
            - !!perl/hash:RE_bracket
              decl: []
              min: 0
              re: !!perl/hash:RE_first
                a: 0
                dba: assertion__S_531name
                i: 0
                min: 0
                r: 1
                s: 0
                zyg:
                - !!perl/hash:RE_string
                  a: 0
                  dba: assertion__S_531name
                  i: 0
                  min: 1
                  r: 1
                  s: 0
                  text: )
                - !!perl/hash:RE_method
                  min: 0
                  name: panic
                  nobind: 1
                  rest: ("Assertion call missing right parenthesis")
      min: 0
      quant:
      - '?'
      - ':'
      - ''
      - 0
assertion__S_531name_02: *5
assertion__S_532Bra: !!perl/hash:RE_ast
  decl: []
  kind: token
  min: 12345
  pkg: ~
  re: !!perl/hash:RE_sequence
    a: 0
    dba: assertion__S_532Bra
    i: 0
    min: 12345
    r: 1
    s: 0
    zyg:
    - !!perl/hash:RE_assertion
      assert: '?'
      min: 0
      re: !!perl/hash:RE_method_re
        a: 0
        dba: assertion__S_532Bra
        i: 0
        min: 0
        name: before
        nobind: 1
        r: 1
        re: !!perl/hash:RE_ast
          decl: []
          min: 1
          re: !!perl/hash:RE_string
            a: 0
            dba: assertion__S_532Bra
            i: 0
            min: 1
            r: 1
            s: 0
            text: '['
        s: 0
    - !!perl/hash:RE_quantified_atom
      atom: !!perl/hash:RE_method
        a: 0
        dba: assertion__S_532Bra
        i: 0
        min: 12345
        name: cclass_elem
        r: 1
        rest: ''
        s: 0
      min: 12345
      quant:
      - +
      - ':'
      - ''
      - 1
assertion__S_533Plus: !!perl/hash:RE_ast
  decl: []
  kind: token
  min: 12345
  pkg: ~
  re: !!perl/hash:RE_sequence
    a: 0
    dba: assertion__S_533Plus
    i: 0
    min: 12345
    r: 1
    s: 0
    zyg:
    - !!perl/hash:RE_assertion
      assert: '?'
      min: 0
      re: !!perl/hash:RE_method_re
        a: 0
        dba: assertion__S_533Plus
        i: 0
        min: 0
        name: before
        nobind: 1
        r: 1
        re: !!perl/hash:RE_ast
          decl: []
          min: 1
          re: !!perl/hash:RE_string
            a: 0
            dba: assertion__S_533Plus
            i: 0
            min: 1
            r: 1
            s: 0
            text: +
        s: 0
    - !!perl/hash:RE_quantified_atom
      atom: !!perl/hash:RE_method
        a: 0
        dba: assertion__S_533Plus
        i: 0
        min: 12345
        name: cclass_elem
        r: 1
        rest: ''
        s: 0
      min: 12345
      quant:
      - +
      - ':'
      - ''
      - 1
assertion__S_534Minus: !!perl/hash:RE_ast
  decl: []
  kind: token
  min: 12345
  pkg: ~
  re: !!perl/hash:RE_sequence
    a: 0
    dba: assertion__S_534Minus
    i: 0
    min: 12345
    r: 1
    s: 0
    zyg:
    - !!perl/hash:RE_assertion
      assert: '?'
      min: 0
      re: !!perl/hash:RE_method_re
        a: 0
        dba: assertion__S_534Minus
        i: 0
        min: 0
        name: before
        nobind: 1
        r: 1
        re: !!perl/hash:RE_ast
          decl: []
          min: 1
          re: !!perl/hash:RE_string
            a: 0
            dba: assertion__S_534Minus
            i: 0
            min: 1
            r: 1
            s: 0
            text: '-'
        s: 0
    - !!perl/hash:RE_quantified_atom
      atom: !!perl/hash:RE_method
        a: 0
        dba: assertion__S_534Minus
        i: 0
        min: 12345
        name: cclass_elem
        r: 1
        rest: ''
        s: 0
      min: 12345
      quant:
      - +
      - ':'
      - ''
      - 1
assertion__S_535Dot: !!perl/hash:RE_ast
  decl: []
  kind: token
  min: 12345
  pkg: ~
  re: !!perl/hash:RE_method
    a: 0
    dba: assertion__S_535Dot
    i: 0
    min: 12345
    name: sym
    r: 1
    rest: ''
    s: 0
    sym: .
assertion__S_536Comma: !!perl/hash:RE_ast
  decl: []
  kind: token
  min: 12345
  pkg: ~
  re: !!perl/hash:RE_method
    a: 0
    dba: assertion__S_536Comma
    i: 0
    min: 12345
    name: sym
    r: 1
    rest: ''
    s: 0
    sym: ','
assertion__S_537TildeTilde: !!perl/hash:RE_ast
  decl: []
  kind: token
  min: 12345
  pkg: ~
  re: !!perl/hash:RE_sequence
    a: 0
    dba: assertion__S_537TildeTilde
    i: 0
    min: 12345
    r: 1
    s: 0
    zyg:
    - !!perl/hash:RE_method
      a: 0
      dba: assertion__S_537TildeTilde
      i: 0
      min: 12345
      name: sym
      r: 1
      rest: ''
      s: 0
      sym: ~~
    - !!perl/hash:RE_bracket
      decl: []
      min: 0
      re: &6 !!perl/hash:RE_any
        a: 0
        altname: assertion__S_537TildeTilde_01
        dba: assertion__S_537TildeTilde
        i: 0
        min: 0
        name: assertion__S_537TildeTilde_01
        r: 1
        s: 0
        zyg:
        - !!perl/hash:RE_assertion
          alt: assertion__S_537TildeTilde_01 0
          assert: '?'
          min: 0
          re: !!perl/hash:RE_method_re
            a: 0
            dba: assertion__S_537TildeTilde
            i: 0
            min: 0
            name: before
            nobind: 1
            r: 1
            re: !!perl/hash:RE_ast
              decl: []
              min: 1
              re: !!perl/hash:RE_string
                a: 0
                dba: assertion__S_537TildeTilde
                i: 0
                min: 1
                r: 1
                s: 0
                text: '>'
            s: 0
        - !!perl/hash:RE_quantified_atom
          alt: assertion__S_537TildeTilde_01 1
          atom: !!perl/hash:RE_meta
            a: 0
            dba: assertion__S_537TildeTilde
            i: 0
            min: 1
            r: 1
            s: 0
            text: \d
          min: 1
          quant:
          - +
          - ':'
          - ''
          - 1
        - !!perl/hash:RE_method
          a: 0
          alt: assertion__S_537TildeTilde_01 2
          dba: assertion__S_537TildeTilde
          i: 0
          min: 12345
          name: desigilname
          r: 1
          rest: ''
          s: 0
assertion__S_537TildeTilde_01: *6
assertion__S_538bogus: !!perl/hash:RE_ast
  decl: []
  kind: token
  min: 0
  pkg: ~
  re: !!perl/hash:RE_method
    min: 0
    name: panic
    nobind: 1
    rest: ("Unrecognized regex assertion")
atom: !!perl/hash:RE_ast
  decl: []
  kind: token
  min: 1
  pkg: ~
  re: !!perl/hash:RE_bracket
    decl: []
    min: 1
    re: &7 !!perl/hash:RE_any
      a: 0
      altname: atom_01
      dba: regex atom
      i: 0
      min: 1
      name: atom_01
      r: 1
      s: 0
      zyg:
      - !!perl/hash:RE_meta
        a: 0
        alt: atom_01 0
        dba: regex atom
        i: 0
        min: 1
        r: 1
        s: 0
        text: \w
      - !!perl/hash:RE_sequence
        a: 0
        alt: atom_01 1
        dba: regex atom
        i: 0
        min: 12345
        r: 1
        s: 0
        zyg:
        - !!perl/hash:RE_method
          a: 0
          dba: regex atom
          i: 0
          min: 12345
          name: metachar
          r: 1
          rest: ''
          s: 0
        - !!perl/hash:RE_meta
          a: 0
          dba: regex atom
          i: 0
          min: 0
          r: 1
          s: 0
          text: '::'
atom_01: *7
backslash__S_498unspace: !!perl/hash:RE_ast
  decl: []
  kind: token
  min: 12345
  pkg: ~
  re: !!perl/hash:RE_sequence
    a: 0
    dba: backslash__S_498unspace
    i: 0
    min: 12345
    r: 1
    s: 0
    zyg:
    - !!perl/hash:RE_assertion
      assert: '?'
      min: 0
      re: !!perl/hash:RE_method_re
        a: 0
        dba: backslash__S_498unspace
        i: 0
        min: 0
        name: before
        nobind: 1
        r: 1
        re: !!perl/hash:RE_ast
          decl: []
          min: 1
          re: !!perl/hash:RE_meta
            a: 0
            dba: backslash__S_498unspace
            i: 0
            min: 1
            r: 1
            s: 0
            text: \s
        s: 0
    - !!perl/hash:RE_method
      a: 0
      dba: backslash__S_498unspace
      i: 0
      min: 12345
      name: SUPER::ws
      nobind: 1
      r: 1
      rest: ''
      s: 0
backslash__S_4990: !!perl/hash:RE_ast
  decl: []
  kind: token
  min: 1
  pkg: ~
  re: !!perl/hash:RE_sequence
    a: 0
    dba: backslash__S_4990
    i: 0
    min: 1
    r: 1
    s: 0
    zyg:
    - !!perl/hash:RE_string
      a: 0
      dba: backslash__S_4990
      i: 0
      min: 1
      r: 1
      s: 0
      text: '0'
    - !!perl/hash:RE_assertion
      assert: '!'
      min: 0
      re: !!perl/hash:RE_method_re
        a: 0
        dba: backslash__S_4990
        i: 0
        min: 0
        name: before
        nobind: 1
        r: 1
        re: !!perl/hash:RE_ast
          decl: []
          min: 1
          re: !!perl/hash:RE_cclass
            a: 0
            dba: backslash__S_4990
            i: 0
            min: 1
            r: 1
            s: 0
            text: '[0..7]'
        s: 0
backslash__S_500A: !!perl/hash:RE_ast
  decl: []
  kind: token
  min: 12345
  pkg: ~
  re: !!perl/hash:RE_sequence
    a: 0
    dba: backslash__S_500A
    i: 0
    min: 12345
    r: 1
    s: 0
    zyg:
    - !!perl/hash:RE_method
      a: 0
      dba: backslash__S_500A
      i: 0
      min: 12345
      name: sym
      r: 1
      rest: ''
      s: 0
      sym: A
    - !!perl/hash:RE_method
      min: 0
      name: obs
      nobind: 1
      rest: ('\\A as beginning-of-string matcher', '^')
backslash__S_501a: !!perl/hash:RE_ast
  decl: []
  kind: token
  min: 12345
  pkg: ~
  re: !!perl/hash:RE_sequence
    a: 0
    dba: backslash__S_501a
    i: 0
    min: 12345
    r: 1
    s: 0
    zyg:
    - !!perl/hash:RE_method
      a: 0
      dba: backslash__S_501a
      i: 0
      min: 12345
      name: sym
      r: 1
      rest: ''
      s: 0
      sym: a
    - !!perl/hash:RE_method
      min: 0
      name: panic
      nobind: 1
      rest: ("\\a is allowed only in strings, not regexes")
backslash__S_502B: !!perl/hash:RE_ast
  decl: []
  kind: token
  min: 12345
  pkg: ~
  re: !!perl/hash:RE_sequence
    a: 0
    dba: backslash__S_502B
    i: 0
    min: 12345
    r: 1
    s: 0
    zyg:
    - !!perl/hash:RE_method
      a: 0
      dba: backslash__S_502B
      i: 0
      min: 12345
      name: sym
      r: 1
      rest: ''
      s: 0
      sym: B
    - !!perl/hash:RE_method
      min: 0
      name: obs
      nobind: 1
      rest: ('\\B as word non-boundary', '<!wb>')
backslash__S_503b: !!perl/hash:RE_ast
  decl: []
  kind: token
  min: 12345
  pkg: ~
  re: !!perl/hash:RE_sequence
    a: 0
    dba: backslash__S_503b
    i: 0
    min: 12345
    r: 1
    s: 0
    zyg:
    - !!perl/hash:RE_method
      a: 0
      dba: backslash__S_503b
      i: 0
      min: 12345
      name: sym
      r: 1
      rest: ''
      s: 0
      sym: b
    - !!perl/hash:RE_method
      min: 0
      name: obs
      nobind: 1
      rest: ('\\b as word boundary', '<?wb> (or either of  or )')
backslash__S_504c: !!perl/hash:RE_ast
  decl: []
  kind: token
  min: 24690
  pkg: ~
  re: !!perl/hash:RE_sequence
    a: 0
    dba: backslash__S_504c
    i: 1
    min: 24690
    r: 1
    s: 0
    zyg:
    - !!perl/hash:RE_method
      a: 0
      dba: backslash__S_504c
      i: 1
      min: 12345
      name: sym
      r: 1
      rest: ''
      s: 0
      sym: c
    - !!perl/hash:RE_method
      a: 0
      dba: backslash__S_504c
      i: 1
      min: 12345
      name: charspec
      r: 1
      rest: ''
      s: 0
backslash__S_505d: !!perl/hash:RE_ast
  decl: []
  kind: token
  min: 12345
  pkg: ~
  re: !!perl/hash:RE_method
    a: 0
    dba: backslash__S_505d
    i: 1
    min: 12345
    name: sym
    r: 1
    rest: ''
    s: 0
    sym: d
backslash__S_506e: !!perl/hash:RE_ast
  decl: []
  kind: token
  min: 12345
  pkg: ~
  re: !!perl/hash:RE_method
    a: 0
    dba: backslash__S_506e
    i: 1
    min: 12345
    name: sym
    r: 1
    rest: ''
    s: 0
    sym: e
backslash__S_507f: !!perl/hash:RE_ast
  decl: []
  kind: token
  min: 12345
  pkg: ~
  re: !!perl/hash:RE_method
    a: 0
    dba: backslash__S_507f
    i: 1
    min: 12345
    name: sym
    r: 1
    rest: ''
    s: 0
    sym: f
backslash__S_508h: !!perl/hash:RE_ast
  decl: []
  kind: token
  min: 12345
  pkg: ~
  re: !!perl/hash:RE_method
    a: 0
    dba: backslash__S_508h
    i: 1
    min: 12345
    name: sym
    r: 1
    rest: ''
    s: 0
    sym: h
backslash__S_509n: !!perl/hash:RE_ast
  decl: []
  kind: token
  min: 12345
  pkg: ~
  re: !!perl/hash:RE_method
    a: 0
    dba: backslash__S_509n
    i: 1
    min: 12345
    name: sym
    r: 1
    rest: ''
    s: 0
    sym: n
backslash__S_510o: !!perl/hash:RE_ast
  decl: []
  kind: token
  min: 24690
  pkg: ~
  re: !!perl/hash:RE_sequence
    a: 0
    dba: octal character
    i: 1
    min: 24690
    r: 1
    s: 0
    zyg:
    - !!perl/hash:RE_method
      a: 0
      dba: octal character
      i: 1
      min: 12345
      name: sym
      r: 1
      rest: ''
      s: 0
      sym: o
    - !!perl/hash:RE_bracket
      decl: []
      min: 12345
      re: &8 !!perl/hash:RE_any
        a: 0
        altname: backslash__S_510o_01
        dba: octal character
        i: 1
        min: 12345
        name: backslash__S_510o_01
        r: 1
        s: 0
        zyg:
        - !!perl/hash:RE_method
          a: 0
          alt: backslash__S_510o_01 0
          dba: octal character
          i: 1
          min: 12345
          name: octint
          r: 1
          rest: ''
          s: 0
        - !!perl/hash:RE_sequence
          a: 0
          alt: backslash__S_510o_01 1
          dba: octal character
          i: 1
          min: 12347
          r: 1
          s: 0
          zyg:
          - !!perl/hash:RE_string
            a: 0
            dba: octal character
            i: 1
            min: 1
            r: 1
            s: 0
            text: '['
          - !!perl/hash:RE_meta
            a: 0
            dba: octal character
            extra: 'local $::GOAL = '']'' '
            i: 1
            min: 0
            r: 1
            s: 0
            text: ':'
          - !!perl/hash:RE_method
            a: 0
            dba: octal character
            i: 1
            min: 12345
            name: octints
            r: 1
            rest: ''
            s: 0
          - !!perl/hash:RE_bracket
            decl: []
            min: 1
            re: !!perl/hash:RE_first
              a: 0
              dba: octal character
              i: 1
              min: 1
              r: 1
              s: 0
              zyg:
              - !!perl/hash:RE_string
                a: 0
                dba: octal character
                i: 1
                min: 1
                r: 1
                s: 0
                text: ']'
              - !!perl/hash:RE_method
                min: 0
                name: FAILGOAL
                nobind: 1
                rest: (']' , 'octal character')
backslash__S_510o_01: *8
backslash__S_511Q: !!perl/hash:RE_ast
  decl: []
  kind: token
  min: 12345
  pkg: ~
  re: !!perl/hash:RE_sequence
    a: 0
    dba: backslash__S_511Q
    i: 0
    min: 12345
    r: 1
    s: 0
    zyg:
    - !!perl/hash:RE_method
      a: 0
      dba: backslash__S_511Q
      i: 0
      min: 12345
      name: sym
      r: 1
      rest: ''
      s: 0
      sym: Q
    - !!perl/hash:RE_method
      min: 0
      name: obs
      nobind: 1
      rest: ('\\Q as quotemeta', 'quotes or literal variable match')
backslash__S_512r: !!perl/hash:RE_ast
  decl: []
  kind: token
  min: 12345
  pkg: ~
  re: !!perl/hash:RE_method
    a: 0
    dba: backslash__S_512r
    i: 1
    min: 12345
    name: sym
    r: 1
    rest: ''
    s: 0
    sym: r
backslash__S_513s: !!perl/hash:RE_ast
  decl: []
  kind: token
  min: 12345
  pkg: ~
  re: !!perl/hash:RE_method
    a: 0
    dba: backslash__S_513s
    i: 1
    min: 12345
    name: sym
    r: 1
    rest: ''
    s: 0
    sym: s
backslash__S_514t: !!perl/hash:RE_ast
  decl: []
  kind: token
  min: 12345
  pkg: ~
  re: !!perl/hash:RE_method
    a: 0
    dba: backslash__S_514t
    i: 1
    min: 12345
    name: sym
    r: 1
    rest: ''
    s: 0
    sym: t
backslash__S_515v: !!perl/hash:RE_ast
  decl: []
  kind: token
  min: 12345
  pkg: ~
  re: !!perl/hash:RE_method
    a: 0
    dba: backslash__S_515v
    i: 1
    min: 12345
    name: sym
    r: 1
    rest: ''
    s: 0
    sym: v
backslash__S_516w: !!perl/hash:RE_ast
  decl: []
  kind: token
  min: 12345
  pkg: ~
  re: !!perl/hash:RE_method
    a: 0
    dba: backslash__S_516w
    i: 1
    min: 12345
    name: sym
    r: 1
    rest: ''
    s: 0
    sym: w
backslash__S_517x: !!perl/hash:RE_ast
  decl: []
  kind: token
  min: 24690
  pkg: ~
  re: !!perl/hash:RE_sequence
    a: 0
    dba: hex character
    i: 1
    min: 24690
    r: 1
    s: 0
    zyg:
    - !!perl/hash:RE_method
      a: 0
      dba: hex character
      i: 1
      min: 12345
      name: sym
      r: 1
      rest: ''
      s: 0
      sym: x
    - !!perl/hash:RE_bracket
      decl: []
      min: 12345
      re: &9 !!perl/hash:RE_any
        a: 0
        altname: backslash__S_517x_01
        dba: hex character
        i: 1
        min: 12345
        name: backslash__S_517x_01
        r: 1
        s: 0
        zyg:
        - !!perl/hash:RE_method
          a: 0
          alt: backslash__S_517x_01 0
          dba: hex character
          i: 1
          min: 12345
          name: hexint
          r: 1
          rest: ''
          s: 0
        - !!perl/hash:RE_sequence
          a: 0
          alt: backslash__S_517x_01 1
          dba: hex character
          i: 1
          min: 12347
          r: 1
          s: 0
          zyg:
          - !!perl/hash:RE_string
            a: 0
            dba: hex character
            i: 1
            min: 1
            r: 1
            s: 0
            text: '['
          - !!perl/hash:RE_meta
            a: 0
            dba: hex character
            extra: 'local $::GOAL = '']'' '
            i: 1
            min: 0
            r: 1
            s: 0
            text: ':'
          - !!perl/hash:RE_method
            a: 0
            dba: hex character
            i: 1
            min: 12345
            name: hexints
            r: 1
            rest: ''
            s: 0
          - !!perl/hash:RE_bracket
            decl: []
            min: 1
            re: !!perl/hash:RE_first
              a: 0
              dba: hex character
              i: 1
              min: 1
              r: 1
              s: 0
              zyg:
              - !!perl/hash:RE_string
                a: 0
                dba: hex character
                i: 1
                min: 1
                r: 1
                s: 0
                text: ']'
              - !!perl/hash:RE_method
                min: 0
                name: FAILGOAL
                nobind: 1
                rest: (']' , 'hex character')
backslash__S_517x_01: *9
backslash__S_518z: !!perl/hash:RE_ast
  decl: []
  kind: token
  min: 12345
  pkg: ~
  re: !!perl/hash:RE_sequence
    a: 0
    dba: backslash__S_518z
    i: 0
    min: 12345
    r: 1
    s: 0
    zyg:
    - !!perl/hash:RE_method
      a: 0
      dba: backslash__S_518z
      i: 0
      min: 12345
      name: sym
      r: 1
      rest: ''
      s: 0
      sym: z
    - !!perl/hash:RE_method
      min: 0
      name: obs
      nobind: 1
      rest: ('\\z as end-of-string matcher', '$')
backslash__S_519Z: !!perl/hash:RE_ast
  decl: []
  kind: token
  min: 12345
  pkg: ~
  re: !!perl/hash:RE_sequence
    a: 0
    dba: backslash__S_519Z
    i: 0
    min: 12345
    r: 1
    s: 0
    zyg:
    - !!perl/hash:RE_method
      a: 0
      dba: backslash__S_519Z
      i: 0
      min: 12345
      name: sym
      r: 1
      rest: ''
      s: 0
      sym: Z
    - !!perl/hash:RE_method
      min: 0
      name: obs
      nobind: 1
      rest: ('\\Z as end-of-string matcher', '\\n?$')
backslash__S_520misc: !!perl/hash:RE_ast
  decl: []
  kind: token
  min: 1
  pkg: ~
  re: !!perl/hash:RE_bindnamed
    a: 0
    atom: !!perl/hash:RE_paren
      decl: []
      min: 1
      re: !!perl/hash:RE_meta
        a: 0
        dba: backslash__S_520misc
        i: 0
        min: 1
        r: 1
        s: 0
        text: \W
    dba: backslash__S_520misc
    i: 0
    min: 1
    r: 1
    s: 0
    var: litchar
backslash__S_521oops: !!perl/hash:RE_ast
  decl: []
  kind: token
  min: 0
  pkg: ~
  re: !!perl/hash:RE_method
    min: 0
    name: panic
    nobind: 1
    rest: ("Unrecognized regex backslash sequence")
category__S_453metachar: !!perl/hash:RE_ast
  decl: []
  kind: token
  min: 12345
  pkg: ~
  re: !!perl/hash:RE_method
    a: 0
    dba: category__S_453metachar
    i: 0
    min: 12345
    name: sym
    r: 1
    rest: ''
    s: 0
    sym: metachar
category__S_454backslash: !!perl/hash:RE_ast
  decl: []
  kind: token
  min: 12345
  pkg: ~
  re: !!perl/hash:RE_method
    a: 0
    dba: category__S_454backslash
    i: 0
    min: 12345
    name: sym
    r: 1
    rest: ''
    s: 0
    sym: backslash
category__S_455assertion: !!perl/hash:RE_ast
  decl: []
  kind: token
  min: 12345
  pkg: ~
  re: !!perl/hash:RE_method
    a: 0
    dba: category__S_455assertion
    i: 0
    min: 12345
    name: sym
    r: 1
    rest: ''
    s: 0
    sym: assertion
category__S_456quantifier: !!perl/hash:RE_ast
  decl: []
  kind: token
  min: 12345
  pkg: ~
  re: !!perl/hash:RE_method
    a: 0
    dba: category__S_456quantifier
    i: 0
    min: 12345
    name: sym
    r: 1
    rest: ''
    s: 0
    sym: quantifier
category__S_457mod_internal: !!perl/hash:RE_ast
  decl: []
  kind: token
  min: 12345
  pkg: ~
  re: !!perl/hash:RE_method
    a: 0
    dba: category__S_457mod_internal
    i: 0
    min: 12345
    name: sym
    r: 1
    rest: ''
    s: 0
    sym: mod_internal
cclass_elem: !!perl/hash:RE_ast
  decl: []
  kind: token
  min: 12345
  pkg: ~
  re: !!perl/hash:RE_sequence
    a: 0
    dba: character class element
    i: 0
    min: 12345
    r: 1
    s: 0
    zyg:
    - !!perl/hash:RE_method
      a: 0
      dba: character class element
      i: 0
      min: 12345
      name: sign
      r: 1
      rest: ''
      s: 0
    - !!perl/hash:RE_quantified_atom
      atom: !!perl/hash:RE_method
        a: 0
        dba: character class element
        i: 0
        min: 12345
        name: normspace
        nobind: 1
        r: 1
        rest: ''
        s: 0
      min: 0
      quant:
      - '?'
      - ':'
      - ''
      - 0
    - !!perl/hash:RE_bracket
      decl: []
      min: 0
      re: &10 !!perl/hash:RE_any
        a: 0
        altname: cclass_elem_01
        dba: character class element
        i: 0
        min: 0
        name: cclass_elem_01
        r: 1
        s: 0
        zyg:
        - !!perl/hash:RE_method
          a: 0
          alt: cclass_elem_01 0
          dba: character class element
          i: 0
          min: 12345
          name: name
          r: 1
          rest: ''
          s: 0
        - !!perl/hash:RE_sequence
          a: 0
          alt: cclass_elem_01 1
          dba: character class element
          i: 0
          min: 0
          r: 1
          s: 0
          zyg:
          - !!perl/hash:RE_method_re
            a: 0
            dba: character class element
            i: 0
            min: 0
            name: before
            r: 1
            re: !!perl/hash:RE_ast
              decl: []
              min: 1
              re: !!perl/hash:RE_string
                a: 0
                dba: character class element
                i: 0
                min: 1
                r: 1
                s: 0
                text: '['
            s: 0
          - !!perl/hash:RE_method
            min: 0
            name: quibble
            rest: ($.cursor_fresh( %*LANG<Q> ).tweak(:q))
    - !!perl/hash:RE_quantified_atom
      atom: !!perl/hash:RE_method
        a: 0
        dba: character class element
        i: 0
        min: 12345
        name: normspace
        nobind: 1
        r: 1
        rest: ''
        s: 0
      min: 0
      quant:
      - '?'
      - ':'
      - ''
      - 0
cclass_elem_01: *10
infixish: !!perl/hash:RE_ast
  decl: []
  kind: token
  min: 12345
  pkg: ~
  re: !!perl/hash:RE_sequence
    a: 0
    dba: infixish
    i: 0
    min: 12345
    r: 1
    s: 0
    zyg:
    - !!perl/hash:RE_assertion
      assert: '!'
      min: 0
      re: !!perl/hash:RE_method
        a: 0
        dba: infixish
        i: 0
        min: 12345
        name: infixstopper
        nobind: 1
        r: 1
        rest: ''
        s: 0
    - !!perl/hash:RE_assertion
      assert: '!'
      min: 0
      re: !!perl/hash:RE_method
        a: 0
        dba: infixish
        i: 0
        min: 12345
        name: stdstopper
        nobind: 1
        r: 1
        rest: ''
        s: 0
    - !!perl/hash:RE_method
      a: 0
      dba: infixish
      i: 0
      min: 12345
      name: regex_infix
      r: 1
      rest: ''
      s: 0
    - !!perl/hash:RE_block
      a: 0
      context: void
      dba: infixish
      i: 0
      min: 0
      r: 1
      s: 0
      text: "\n            $<O> = $<regex_infix><O>;\n            $<sym> = $<regex_infix><sym>;\n
        \       "
infixstopper: !!perl/hash:RE_ast
  decl: []
  kind: regex
  min: 0
  pkg: ~
  re: !!perl/hash:RE_assertion
    assert: '?'
    min: 0
    re: !!perl/hash:RE_method_re
      a: 0
      dba: infix stopper
      i: 0
      min: 0
      name: before
      nobind: 1
      r: 0
      re: !!perl/hash:RE_ast
        decl: []
        min: 12345
        re: !!perl/hash:RE_method
          a: 0
          dba: infix stopper
          i: 0
          min: 12345
          name: stopper
          r: 0
          rest: ''
          s: 0
      s: 0
metachar__S_463Gt: !!perl/hash:RE_ast
  decl: []
  kind: token
  min: 12346
  pkg: ~
  re: !!perl/hash:RE_sequence
    a: 0
    dba: metachar__S_463Gt
    i: 0
    min: 12346
    r: 1
    s: 0
    zyg:
    - !!perl/hash:RE_string
      a: 0
      dba: metachar__S_463Gt
      i: 0
      min: 1
      r: 1
      s: 0
      text: '>'
    - !!perl/hash:RE_meta
      a: 0
      dba: metachar__S_463Gt
      i: 0
      min: 0
      r: 1
      s: 0
      text: '::'
    - !!perl/hash:RE_method
      a: 0
      dba: metachar__S_463Gt
      i: 0
      min: 12345
      name: fail
      r: 1
      rest: ''
      s: 0
metachar__S_464AmpAmp: !!perl/hash:RE_ast
  decl: []
  kind: token
  min: 12347
  pkg: ~
  re: !!perl/hash:RE_sequence
    a: 0
    dba: metachar__S_464AmpAmp
    i: 0
    min: 12347
    r: 1
    s: 0
    zyg:
    - !!perl/hash:RE_string
      a: 0
      dba: metachar__S_464AmpAmp
      i: 0
      min: 2
      r: 1
      s: 0
      text: '&&'
    - !!perl/hash:RE_meta
      a: 0
      dba: metachar__S_464AmpAmp
      i: 0
      min: 0
      r: 1
      s: 0
      text: '::'
    - !!perl/hash:RE_method
      a: 0
      dba: metachar__S_464AmpAmp
      i: 0
      min: 12345
      name: fail
      r: 1
      rest: ''
      s: 0
metachar__S_465Amp: !!perl/hash:RE_ast
  decl: []
  kind: token
  min: 12346
  pkg: ~
  re: !!perl/hash:RE_sequence
    a: 0
    dba: metachar__S_465Amp
    i: 0
    min: 12346
    r: 1
    s: 0
    zyg:
    - !!perl/hash:RE_string
      a: 0
      dba: metachar__S_465Amp
      i: 0
      min: 1
      r: 1
      s: 0
      text: '&'
    - !!perl/hash:RE_meta
      a: 0
      dba: metachar__S_465Amp
      i: 0
      min: 0
      r: 1
      s: 0
      text: '::'
    - !!perl/hash:RE_method
      a: 0
      dba: metachar__S_465Amp
      i: 0
      min: 12345
      name: fail
      r: 1
      rest: ''
      s: 0
metachar__S_466VertVert: !!perl/hash:RE_ast
  decl: []
  kind: token
  min: 12347
  pkg: ~
  re: !!perl/hash:RE_sequence
    a: 0
    dba: metachar__S_466VertVert
    i: 0
    min: 12347
    r: 1
    s: 0
    zyg:
    - !!perl/hash:RE_string
      a: 0
      dba: metachar__S_466VertVert
      i: 0
      min: 2
      r: 1
      s: 0
      text: '||'
    - !!perl/hash:RE_meta
      a: 0
      dba: metachar__S_466VertVert
      i: 0
      min: 0
      r: 1
      s: 0
      text: '::'
    - !!perl/hash:RE_method
      a: 0
      dba: metachar__S_466VertVert
      i: 0
      min: 12345
      name: fail
      r: 1
      rest: ''
      s: 0
metachar__S_467Vert: !!perl/hash:RE_ast
  decl: []
  kind: token
  min: 12346
  pkg: ~
  re: !!perl/hash:RE_sequence
    a: 0
    dba: metachar__S_467Vert
    i: 0
    min: 12346
    r: 1
    s: 0
    zyg:
    - !!perl/hash:RE_string
      a: 0
      dba: metachar__S_467Vert
      i: 0
      min: 1
      r: 1
      s: 0
      text: '|'
    - !!perl/hash:RE_meta
      a: 0
      dba: metachar__S_467Vert
      i: 0
      min: 0
      r: 1
      s: 0
      text: '::'
    - !!perl/hash:RE_method
      a: 0
      dba: metachar__S_467Vert
      i: 0
      min: 12345
      name: fail
      r: 1
      rest: ''
      s: 0
metachar__S_468Ket: !!perl/hash:RE_ast
  decl: []
  kind: token
  min: 12346
  pkg: ~
  re: !!perl/hash:RE_sequence
    a: 0
    dba: metachar__S_468Ket
    i: 0
    min: 12346
    r: 1
    s: 0
    zyg:
    - !!perl/hash:RE_string
      a: 0
      dba: metachar__S_468Ket
      i: 0
      min: 1
      r: 1
      s: 0
      text: ']'
    - !!perl/hash:RE_meta
      a: 0
      dba: metachar__S_468Ket
      i: 0
      min: 0
      r: 1
      s: 0
      text: '::'
    - !!perl/hash:RE_method
      a: 0
      dba: metachar__S_468Ket
      i: 0
      min: 12345
      name: fail
      r: 1
      rest: ''
      s: 0
metachar__S_469Thesis: !!perl/hash:RE_ast
  decl: []
  kind: token
  min: 12346
  pkg: ~
  re: !!perl/hash:RE_sequence
    a: 0
    dba: metachar__S_469Thesis
    i: 0
    min: 12346
    r: 1
    s: 0
    zyg:
    - !!perl/hash:RE_string
      a: 0
      dba: metachar__S_469Thesis
      i: 0
      min: 1
      r: 1
      s: 0
      text: )
    - !!perl/hash:RE_meta
      a: 0
      dba: metachar__S_469Thesis
      i: 0
      min: 0
      r: 1
      s: 0
      text: '::'
    - !!perl/hash:RE_method
      a: 0
      dba: metachar__S_469Thesis
      i: 0
      min: 12345
      name: fail
      r: 1
      rest: ''
      s: 0
metachar__S_470Semi: !!perl/hash:RE_ast
  decl: []
  kind: token
  min: 1
  pkg: ~
  re: !!perl/hash:RE_sequence
    a: 0
    dba: metachar__S_470Semi
    i: 0
    min: 1
    r: 1
    s: 0
    zyg:
    - !!perl/hash:RE_string
      a: 0
      dba: metachar__S_470Semi
      i: 0
      min: 1
      r: 1
      s: 0
      text: ;
    - !!perl/hash:RE_block
      a: 0
      context: void
      dba: metachar__S_470Semi
      i: 0
      min: 0
      r: 1
      s: 0
      text: ''
    - !!perl/hash:RE_bracket
      decl: []
      min: 0
      re: !!perl/hash:RE_first
        a: 0
        dba: metachar__S_470Semi
        i: 0
        min: 0
        r: 1
        s: 0
        zyg:
        - !!perl/hash:RE_sequence
          a: 0
          dba: metachar__S_470Semi
          i: 0
          min: 0
          r: 1
          s: 0
          zyg:
          - !!perl/hash:RE_assertion
            assert: '?'
            min: 0
            re: !!perl/hash:RE_method_re
              a: 0
              dba: metachar__S_470Semi
              i: 0
              min: 0
              name: before
              nobind: 1
              r: 1
              re: !!perl/hash:RE_ast
                decl: []
                min: 12345
                re: !!perl/hash:RE_sequence
                  a: 0
                  dba: metachar__S_470Semi
                  i: 0
                  min: 12345
                  r: 1
                  s: 0
                  zyg:
                  - !!perl/hash:RE_quantified_atom
                    atom: !!perl/hash:RE_meta
                      a: 0
                      dba: metachar__S_470Semi
                      i: 0
                      min: 1
                      r: 1
                      s: 0
                      text: \N
                    min: 0
                    quant:
                    - '*'
                    - '?'
                    - ''
                    - 0
                  - !!perl/hash:RE_method
                    a: 0
                    dba: metachar__S_470Semi
                    i: 0
                    min: 12345
                    name: stopper
                    r: 1
                    rest: ''
                    s: 0
              s: 0
          - !!perl/hash:RE_method
            min: 0
            name: panic
            nobind: 1
            rest: ("Semicolon must be quoted")
        - !!perl/hash:RE_sequence
          a: 0
          dba: metachar__S_470Semi
          i: 0
          min: 0
          r: 1
          s: 0
          zyg:
          - !!perl/hash:RE_assertion
            assert: '?'
            min: 0
            re: !!perl/hash:RE_method_re
              a: 0
              dba: metachar__S_470Semi
              i: 0
              min: 0
              name: before
              nobind: 1
              r: 1
              re: !!perl/hash:RE_ast
                decl: []
                min: 1
                re: !!perl/hash:RE_meta
                  a: 0
                  dba: metachar__S_470Semi
                  i: 0
                  min: 1
                  r: 1
                  s: 0
                  text: .
              s: 0
          - !!perl/hash:RE_method
            min: 0
            name: panic
            nobind: 1
            rest: ("Regex missing terminator (or semicolon must be quoted?)")
        - !!perl/hash:RE_method
          min: 0
          name: panic
          nobind: 1
          rest: ("Regex missing terminator")
metachar__S_471quant: !!perl/hash:RE_ast
  decl: []
  kind: token
  min: 12345
  pkg: ~
  re: !!perl/hash:RE_sequence
    a: 0
    dba: metachar__S_471quant
    i: 0
    min: 12345
    r: 1
    s: 0
    zyg:
    - !!perl/hash:RE_method
      a: 0
      dba: metachar__S_471quant
      i: 0
      min: 12345
      name: quantifier
      r: 1
      rest: ''
      s: 0
    - !!perl/hash:RE_method
      min: 0
      name: panic
      nobind: 1
      rest: ("quantifier quantifies nothing")
metachar__S_472sigwhite: !!perl/hash:RE_ast
  decl: []
  kind: token
  min: 12345
  pkg: ~
  re: !!perl/hash:RE_method
    a: 0
    dba: metachar__S_472sigwhite
    i: 0
    min: 12345
    name: normspace
    r: 1
    rest: ''
    s: 0
metachar__S_473unsp: !!perl/hash:RE_ast
  decl: []
  kind: token
  min: 12345
  pkg: ~
  re: !!perl/hash:RE_method
    a: 0
    dba: metachar__S_473unsp
    i: 0
    min: 12345
    name: unsp
    r: 1
    rest: ''
    s: 0
metachar__S_474Cur_Ly: !!perl/hash:RE_ast
  decl: []
  kind: token
  min: 12345
  pkg: ~
  re: !!perl/hash:RE_sequence
    a: 0
    dba: metachar__S_474Cur_Ly
    i: 0
    min: 12345
    r: 1
    s: 0
    zyg:
    - !!perl/hash:RE_assertion
      assert: '?'
      min: 0
      re: !!perl/hash:RE_method_re
        a: 0
        dba: metachar__S_474Cur_Ly
        i: 0
        min: 0
        name: before
        nobind: 1
        r: 1
        re: !!perl/hash:RE_ast
          decl: []
          min: 1
          re: !!perl/hash:RE_string
            a: 0
            dba: metachar__S_474Cur_Ly
            i: 0
            min: 1
            r: 1
            s: 0
            text: '{'
        s: 0
    - !!perl/hash:RE_method
      a: 0
      dba: metachar__S_474Cur_Ly
      i: 0
      min: 12345
      name: embeddedblock
      r: 1
      rest: ''
      s: 0
    - !!perl/hash:RE_block
      a: 0
      context: void
      dba: metachar__S_474Cur_Ly
      i: 0
      min: 0
      r: 1
      s: 0
      text: ' $/<sym> := <{ }> '
metachar__S_475mod: !!perl/hash:RE_ast
  decl: []
  kind: token
  min: 12345
  pkg: ~
  re: !!perl/hash:RE_sequence
    a: 0
    dba: metachar__S_475mod
    i: 0
    min: 12345
    r: 1
    s: 0
    zyg:
    - !!perl/hash:RE_method
      a: 0
      dba: metachar__S_475mod
      i: 0
      min: 12345
      name: mod_internal
      r: 1
      rest: ''
      s: 0
    - !!perl/hash:RE_block
      a: 0
      context: void
      dba: metachar__S_475mod
      i: 0
      min: 0
      r: 1
      s: 0
      text: ' $/<sym> := $<mod_internal><sym> '
metachar__S_476Colon: !!perl/hash:RE_ast
  decl: []
  kind: token
  min: 12345
  pkg: ~
  re: !!perl/hash:RE_method
    a: 0
    dba: metachar__S_476Colon
    i: 0
    min: 12345
    name: sym
    r: 1
    rest: ''
    s: 0
    sym: ':'
metachar__S_477ColonColon: !!perl/hash:RE_ast
  decl: []
  kind: token
  min: 12345
  pkg: ~
  re: !!perl/hash:RE_method
    a: 0
    dba: metachar__S_477ColonColon
    i: 0
    min: 12345
    name: sym
    r: 1
    rest: ''
    s: 0
    sym: '::'
metachar__S_478ColonColonColon: !!perl/hash:RE_ast
  decl: []
  kind: token
  min: 12345
  pkg: ~
  re: !!perl/hash:RE_method
    a: 0
    dba: metachar__S_478ColonColonColon
    i: 0
    min: 12345
    name: sym
    r: 1
    rest: ''
    s: 0
    sym: ':::'
metachar__S_479Bra_Ket: !!perl/hash:RE_ast
  decl: []
  kind: token
  min: 12346
  pkg: ~
  re: !!perl/hash:RE_sequence
    a: 0
    dba: metachar__S_479Bra_Ket
    i: 0
    min: 12346
    r: 1
    s: 0
    zyg:
    - !!perl/hash:RE_string
      a: 0
      dba: metachar__S_479Bra_Ket
      i: 0
      min: 1
      r: 1
      s: 0
      text: '['
    - !!perl/hash:RE_block
      a: 0
      context: void
      dba: metachar__S_479Bra_Ket
      i: 0
      min: 0
      r: 1
      s: 0
      text: ''
    - !!perl/hash:RE_bracket
      decl: []
      min: 12345
      re: !!perl/hash:RE_sequence
        a: 0
        dba: metachar__S_479Bra_Ket
        i: 0
        lang: ($self->unbalanced(']'))
        min: 12345
        r: 1
        s: 0
        zyg:
        - !!perl/hash:RE_decl
          a: 0
          dba: metachar__S_479Bra_Ket
          i: 0
          lang: ($self->unbalanced(']'))
          max: 0
          min: 0
          noquant: 1
          r: 1
          s: 0
          text: 'my $newlang = ($self->unbalanced('']''));  $C = $C->cursor_fresh($newlang); '
        - !!perl/hash:RE_method
          a: 0
          dba: metachar__S_479Bra_Ket
          i: 0
          lang: ($self->unbalanced(']'))
          min: 12345
          name: nibbler
          r: 1
          rest: ''
          s: 0
    - !!perl/hash:RE_bracket
      decl: []
      min: 0
      re: !!perl/hash:RE_first
        a: 0
        dba: metachar__S_479Bra_Ket
        i: 0
        min: 0
        r: 1
        s: 0
        zyg:
        - !!perl/hash:RE_string
          a: 0
          dba: metachar__S_479Bra_Ket
          i: 0
          min: 1
          r: 1
          s: 0
          text: ']'
        - !!perl/hash:RE_method
          min: 0
          name: panic
          nobind: 1
          rest: ("Unable to parse regex; couldn't find right bracket")
    - !!perl/hash:RE_block
      a: 0
      context: void
      dba: metachar__S_479Bra_Ket
      i: 0
      min: 0
      r: 1
      s: 0
      text: ' $/<sym> := <[ ]> '
metachar__S_480Paren_Thesis: !!perl/hash:RE_ast
  decl: []
  kind: token
  min: 12346
  pkg: ~
  re: !!perl/hash:RE_sequence
    a: 0
    dba: metachar__S_480Paren_Thesis
    i: 0
    min: 12346
    r: 1
    s: 0
    zyg:
    - !!perl/hash:RE_string
      a: 0
      dba: metachar__S_480Paren_Thesis
      i: 0
      min: 1
      r: 1
      s: 0
      text: (
    - !!perl/hash:RE_block
      a: 0
      context: void
      dba: metachar__S_480Paren_Thesis
      i: 0
      min: 0
      r: 1
      s: 0
      text: ''
    - !!perl/hash:RE_bracket
      decl: []
      min: 12345
      re: !!perl/hash:RE_sequence
        a: 0
        dba: metachar__S_480Paren_Thesis
        i: 0
        lang: ($self->unbalanced(')'))
        min: 12345
        r: 1
        s: 0
        zyg:
        - !!perl/hash:RE_decl
          a: 0
          dba: metachar__S_480Paren_Thesis
          i: 0
          lang: ($self->unbalanced(')'))
          max: 0
          min: 0
          noquant: 1
          r: 1
          s: 0
          text: 'my $newlang = ($self->unbalanced('')''));  $C = $C->cursor_fresh($newlang); '
        - !!perl/hash:RE_method
          a: 0
          dba: metachar__S_480Paren_Thesis
          i: 0
          lang: ($self->unbalanced(')'))
          min: 12345
          name: nibbler
          r: 1
          rest: ''
          s: 0
    - !!perl/hash:RE_bracket
      decl: []
      min: 0
      re: !!perl/hash:RE_first
        a: 0
        dba: metachar__S_480Paren_Thesis
        i: 0
        min: 0
        r: 1
        s: 0
        zyg:
        - !!perl/hash:RE_string
          a: 0
          dba: metachar__S_480Paren_Thesis
          i: 0
          min: 1
          r: 1
          s: 0
          text: )
        - !!perl/hash:RE_method
          min: 0
          name: panic
          nobind: 1
          rest: ("Unable to parse regex; couldn't find right parenthesis")
    - !!perl/hash:RE_block
      a: 0
      context: void
      dba: metachar__S_480Paren_Thesis
      i: 0
      min: 0
      r: 1
      s: 0
      text: ' $/<sym> := <( )> '
metachar__S_481LtParen: !!perl/hash:RE_ast
  decl: []
  kind: token
  min: 2
  pkg: ~
  re: !!perl/hash:RE_string
    a: 0
    dba: metachar__S_481LtParen
    i: 0
    min: 2
    r: 1
    s: 0
    text: <(
metachar__S_482ThesisGt: !!perl/hash:RE_ast
  decl: []
  kind: token
  min: 2
  pkg: ~
  re: !!perl/hash:RE_string
    a: 0
    dba: metachar__S_482ThesisGt
    i: 0
    min: 2
    r: 1
    s: 0
    text: )>
metachar__S_483LtLt: !!perl/hash:RE_ast
  decl: []
  kind: token
  min: 2
  pkg: ~
  re: !!perl/hash:RE_string
    a: 0
    dba: metachar__S_483LtLt
    i: 0
    min: 2
    r: 1
    s: 0
    text: <<
metachar__S_484GtGt: !!perl/hash:RE_ast
  decl: []
  kind: token
  min: 2
  pkg: ~
  re: !!perl/hash:RE_string
    a: 0
    dba: metachar__S_484GtGt
    i: 0
    min: 2
    r: 1
    s: 0
    text: '>>'
metachar__S_485Fre: !!perl/hash:RE_ast
  decl: []
  kind: token
  min: 1
  pkg: ~
  re: !!perl/hash:RE_string
    a: 0
    dba: metachar__S_485Fre
    i: 0
    min: 1
    r: 1
    s: 0
    text: 
metachar__S_486Nch: !!perl/hash:RE_ast
  decl: []
  kind: token
  min: 1
  pkg: ~
  re: !!perl/hash:RE_string
    a: 0
    dba: metachar__S_486Nch
    i: 0
    min: 1
    r: 1
    s: 0
    text: 
metachar__S_487qw: !!perl/hash:RE_ast
  decl: []
  kind: token
  min: 12345
  pkg: ~
  re: !!perl/hash:RE_sequence
    a: 0
    dba: metachar__S_487qw
    i: 0
    min: 12345
    r: 1
    s: 0
    zyg:
    - !!perl/hash:RE_assertion
      assert: '?'
      min: 0
      re: !!perl/hash:RE_method_re
        a: 0
        dba: metachar__S_487qw
        i: 0
        min: 0
        name: before
        nobind: 1
        r: 1
        re: !!perl/hash:RE_ast
          decl: []
          min: 2
          re: !!perl/hash:RE_sequence
            a: 0
            dba: metachar__S_487qw
            i: 0
            min: 2
            r: 1
            s: 0
            zyg:
            - !!perl/hash:RE_string
              a: 0
              dba: metachar__S_487qw
              i: 0
              min: 1
              r: 1
              s: 0
              text: <
            - !!perl/hash:RE_meta
              a: 0
              dba: metachar__S_487qw
              i: 0
              min: 1
              r: 1
              s: 0
              text: \s
        s: 0
    - !!perl/hash:RE_method
      a: 0
      dba: metachar__S_487qw
      i: 0
      min: 12345
      name: circumfix
      r: 1
      rest: ''
      s: 0
metachar__S_488Lt_Gt: !!perl/hash:RE_ast
  decl: []
  kind: token
  min: 12347
  pkg: ~
  re: !!perl/hash:RE_sequence
    a: 0
    dba: metachar__S_488Lt_Gt
    i: 0
    min: 12347
    r: 1
    s: 0
    zyg:
    - !!perl/hash:RE_string
      a: 0
      dba: metachar__S_488Lt_Gt
      i: 0
      min: 1
      r: 1
      s: 0
      text: <
    - !!perl/hash:RE_meta
      a: 0
      dba: metachar__S_488Lt_Gt
      extra: 'local $::GOAL = ''>'' '
      i: 0
      min: 0
      r: 1
      s: 0
      text: ':'
    - !!perl/hash:RE_method
      a: 0
      dba: metachar__S_488Lt_Gt
      i: 0
      min: 12345
      name: assertion
      r: 1
      rest: ''
      s: 0
    - !!perl/hash:RE_bracket
      decl: []
      min: 1
      re: !!perl/hash:RE_first
        a: 0
        dba: metachar__S_488Lt_Gt
        i: 0
        min: 1
        r: 1
        s: 0
        zyg:
        - !!perl/hash:RE_string
          a: 0
          dba: metachar__S_488Lt_Gt
          i: 0
          min: 1
          r: 1
          s: 0
          text: '>'
        - !!perl/hash:RE_method
          min: 0
          name: FAILGOAL
          nobind: 1
          rest: ('>' , 'metachar__S_488Lt_Gt')
metachar__S_489Back: !!perl/hash:RE_ast
  decl: []
  kind: token
  min: 24690
  pkg: ~
  re: !!perl/hash:RE_sequence
    a: 0
    dba: metachar__S_489Back
    i: 0
    min: 24690
    r: 1
    s: 0
    zyg:
    - !!perl/hash:RE_method
      a: 0
      dba: metachar__S_489Back
      i: 0
      min: 12345
      name: sym
      r: 1
      rest: ''
      s: 0
      sym: \
    - !!perl/hash:RE_method
      a: 0
      dba: metachar__S_489Back
      i: 0
      min: 12345
      name: backslash
      r: 1
      rest: ''
      s: 0
metachar__S_490Dot: !!perl/hash:RE_ast
  decl: []
  kind: token
  min: 12345
  pkg: ~
  re: !!perl/hash:RE_method
    a: 0
    dba: metachar__S_490Dot
    i: 0
    min: 12345
    name: sym
    r: 1
    rest: ''
    s: 0
    sym: .
metachar__S_491CaretCaret: !!perl/hash:RE_ast
  decl: []
  kind: token
  min: 12345
  pkg: ~
  re: !!perl/hash:RE_method
    a: 0
    dba: metachar__S_491CaretCaret
    i: 0
    min: 12345
    name: sym
    r: 1
    rest: ''
    s: 0
    sym: ^^
metachar__S_492Caret: !!perl/hash:RE_ast
  decl: []
  kind: token
  min: 12345
  pkg: ~
  re: !!perl/hash:RE_method
    a: 0
    dba: metachar__S_492Caret
    i: 0
    min: 12345
    name: sym
    r: 1
    rest: ''
    s: 0
    sym: ^
metachar__S_493DollarDollar: !!perl/hash:RE_ast
  decl: []
  kind: token
  min: 12345
  pkg: ~
  re: !!perl/hash:RE_sequence
    a: 0
    dba: metachar__S_493DollarDollar
    i: 0
    min: 12345
    r: 1
    s: 0
    zyg:
    - !!perl/hash:RE_method
      a: 0
      dba: metachar__S_493DollarDollar
      i: 0
      min: 12345
      name: sym
      r: 1
      rest: ''
      s: 0
      sym: $$
    - !!perl/hash:RE_quantified_atom
      atom: !!perl/hash:RE_bracket
        decl: []
        min: 1
        re: !!perl/hash:RE_sequence
          a: 0
          dba: metachar__S_493DollarDollar
          i: 0
          min: 1
          r: 1
          s: 0
          zyg:
          - !!perl/hash:RE_bindpos
            atom: !!perl/hash:RE_paren
              decl: []
              min: 1
              re: !!perl/hash:RE_quantified_atom
                atom: !!perl/hash:RE_meta
                  a: 0
                  dba: metachar__S_493DollarDollar
                  i: 0
                  min: 1
                  r: 1
                  s: 0
                  text: \w
                min: 1
                quant:
                - +
                - ':'
                - ''
                - 1
            min: 1
            var: 0
          - !!perl/hash:RE_method
            min: 0
            name: obs
            nobind: 1
            rest: ("\$\$" ~ $0.Str ~ " to deref var inside a regex", "\$(\$" ~ $0.Str
              ~ ")")
      min: 0
      quant:
      - '?'
      - ':'
      - ''
      - 0
metachar__S_494Dollar: !!perl/hash:RE_ast
  decl: []
  kind: token
  min: 1
  pkg: ~
  re: !!perl/hash:RE_sequence
    a: 0
    dba: metachar__S_494Dollar
    i: 0
    min: 1
    r: 1
    s: 0
    zyg:
    - !!perl/hash:RE_string
      a: 0
      dba: metachar__S_494Dollar
      i: 0
      min: 1
      r: 1
      s: 0
      text: $
    - !!perl/hash:RE_assertion
      assert: '?'
      min: 0
      re: !!perl/hash:RE_method_re
        a: 0
        dba: metachar__S_494Dollar
        i: 0
        min: 0
        name: before
        nobind: 1
        r: 1
        re: !!perl/hash:RE_ast
          decl: []
          min: 0
          re: &11 !!perl/hash:RE_any
            a: 0
            altname: metachar__S_494Dollar_01
            dba: metachar__S_494Dollar
            i: 0
            min: 0
            name: metachar__S_494Dollar_01
            r: 1
            s: 0
            zyg:
            - !!perl/hash:RE_meta
              a: 0
              alt: metachar__S_494Dollar_01 0
              dba: metachar__S_494Dollar
              i: 0
              min: 1
              r: 1
              s: 0
              text: \s
            - !!perl/hash:RE_string
              a: 0
              alt: metachar__S_494Dollar_01 1
              dba: metachar__S_494Dollar
              i: 0
              min: 1
              r: 1
              s: 0
              text: '|'
            - !!perl/hash:RE_string
              a: 0
              alt: metachar__S_494Dollar_01 2
              dba: metachar__S_494Dollar
              i: 0
              min: 1
              r: 1
              s: 0
              text: '&'
            - !!perl/hash:RE_string
              a: 0
              alt: metachar__S_494Dollar_01 3
              dba: metachar__S_494Dollar
              i: 0
              min: 1
              r: 1
              s: 0
              text: )
            - !!perl/hash:RE_string
              a: 0
              alt: metachar__S_494Dollar_01 4
              dba: metachar__S_494Dollar
              i: 0
              min: 1
              r: 1
              s: 0
              text: ']'
            - !!perl/hash:RE_string
              a: 0
              alt: metachar__S_494Dollar_01 5
              dba: metachar__S_494Dollar
              i: 0
              min: 1
              r: 1
              s: 0
              text: '>'
            - !!perl/hash:RE_meta
              a: 0
              alt: metachar__S_494Dollar_01 6
              dba: metachar__S_494Dollar
              i: 0
              min: 0
              r: 1
              s: 0
              text: $
            - !!perl/hash:RE_method
              a: 0
              alt: metachar__S_494Dollar_01 7
              dba: metachar__S_494Dollar
              i: 0
              min: 12345
              name: stopper
              nobind: 1
              r: 1
              rest: ''
              s: 0
        s: 0
metachar__S_494Dollar_01: *11
metachar__S_495Single_Single: !!perl/hash:RE_ast
  decl: []
  kind: token
  min: 12345
  pkg: ~
  re: !!perl/hash:RE_sequence
    a: 0
    dba: metachar__S_495Single_Single
    i: 0
    min: 12345
    r: 1
    s: 0
    zyg:
    - !!perl/hash:RE_assertion
      assert: '?'
      min: 0
      re: !!perl/hash:RE_method_re
        a: 0
        dba: metachar__S_495Single_Single
        i: 0
        min: 0
        name: before
        nobind: 1
        r: 1
        re: !!perl/hash:RE_ast
          decl: []
          min: 1
          re: !!perl/hash:RE_double
            a: 0
            dba: metachar__S_495Single_Single
            i: 0
            min: 1
            r: 1
            s: 0
            text: ''''
        s: 0
    - !!perl/hash:RE_bracket
      decl: []
      min: 12345
      re: !!perl/hash:RE_sequence
        a: 0
        dba: metachar__S_495Single_Single
        i: 0
        lang: ($C->cursor_fresh($::LANG{'MAIN'}))
        min: 12345
        r: 1
        s: 0
        zyg:
        - !!perl/hash:RE_decl
          a: 0
          dba: metachar__S_495Single_Single
          i: 0
          lang: ($C->cursor_fresh($::LANG{'MAIN'}))
          max: 0
          min: 0
          noquant: 1
          r: 1
          s: 0
          text: 'my $newlang = ($C->cursor_fresh($::LANG{''MAIN''}));  $C = $C->cursor_fresh($newlang); '
        - !!perl/hash:RE_method
          a: 0
          dba: metachar__S_495Single_Single
          i: 0
          lang: ($C->cursor_fresh($::LANG{'MAIN'}))
          min: 12345
          name: quote
          r: 1
          rest: ''
          s: 0
metachar__S_496Double_Double: !!perl/hash:RE_ast
  decl: []
  kind: token
  min: 12345
  pkg: ~
  re: !!perl/hash:RE_sequence
    a: 0
    dba: metachar__S_496Double_Double
    i: 0
    min: 12345
    r: 1
    s: 0
    zyg:
    - !!perl/hash:RE_assertion
      assert: '?'
      min: 0
      re: !!perl/hash:RE_method_re
        a: 0
        dba: metachar__S_496Double_Double
        i: 0
        min: 0
        name: before
        nobind: 1
        r: 1
        re: !!perl/hash:RE_ast
          decl: []
          min: 1
          re: !!perl/hash:RE_string
            a: 0
            dba: metachar__S_496Double_Double
            i: 0
            min: 1
            r: 1
            s: 0
            text: '"'
        s: 0
    - !!perl/hash:RE_bracket
      decl: []
      min: 12345
      re: !!perl/hash:RE_sequence
        a: 0
        dba: metachar__S_496Double_Double
        i: 0
        lang: ($C->cursor_fresh($::LANG{'MAIN'}))
        min: 12345
        r: 1
        s: 0
        zyg:
        - !!perl/hash:RE_decl
          a: 0
          dba: metachar__S_496Double_Double
          i: 0
          lang: ($C->cursor_fresh($::LANG{'MAIN'}))
          max: 0
          min: 0
          noquant: 1
          r: 1
          s: 0
          text: 'my $newlang = ($C->cursor_fresh($::LANG{''MAIN''}));  $C = $C->cursor_fresh($newlang); '
        - !!perl/hash:RE_method
          a: 0
          dba: metachar__S_496Double_Double
          i: 0
          lang: ($C->cursor_fresh($::LANG{'MAIN'}))
          min: 12345
          name: quote
          r: 1
          rest: ''
          s: 0
metachar__S_497var: !!perl/hash:RE_ast
  decl: []
  kind: token
  min: 24690
  pkg: ~
  re: !!perl/hash:RE_sequence
    a: 0
    dba: metachar__S_497var
    i: 0
    min: 24690
    r: 1
    s: 0
    zyg:
    - !!perl/hash:RE_assertion
      assert: '!'
      min: 0
      re: !!perl/hash:RE_method_re
        a: 0
        dba: metachar__S_497var
        i: 0
        min: 0
        name: before
        nobind: 1
        r: 1
        re: !!perl/hash:RE_ast
          decl: []
          min: 2
          re: !!perl/hash:RE_string
            a: 0
            dba: metachar__S_497var
            i: 0
            min: 2
            r: 1
            s: 0
            text: $$
        s: 0
    - !!perl/hash:RE_assertion
      assert: '?'
      min: 0
      re: !!perl/hash:RE_method_re
        a: 0
        dba: metachar__S_497var
        i: 0
        min: 0
        name: before
        nobind: 1
        r: 1
        re: !!perl/hash:RE_ast
          decl: []
          min: 12345
          re: !!perl/hash:RE_method
            a: 0
            dba: metachar__S_497var
            i: 0
            min: 12345
            name: sigil
            r: 1
            rest: ''
            s: 0
        s: 0
    - !!perl/hash:RE_bracket
      decl: []
      min: 24690
      re: !!perl/hash:RE_sequence
        a: 0
        dba: metachar__S_497var
        i: 0
        lang: ($C->cursor_fresh($::LANG{'MAIN'}))
        min: 24690
        r: 1
        s: 0
        zyg:
        - !!perl/hash:RE_decl
          a: 0
          dba: metachar__S_497var
          i: 0
          lang: ($C->cursor_fresh($::LANG{'MAIN'}))
          max: 0
          min: 0
          noquant: 1
          r: 1
          s: 0
          text: 'my $newlang = ($C->cursor_fresh($::LANG{''MAIN''}));  $C = $C->cursor_fresh($newlang); '
        - !!perl/hash:RE_method
          a: 0
          dba: metachar__S_497var
          i: 0
          lang: ($C->cursor_fresh($::LANG{'MAIN'}))
          min: 12345
          name: variable
          r: 1
          rest: ''
          s: 0
        - !!perl/hash:RE_method
          a: 0
          dba: metachar__S_497var
          i: 0
          lang: ($C->cursor_fresh($::LANG{'MAIN'}))
          min: 12345
          name: ws
          nobind: 1
          r: 1
          rest: ''
          s: 0
        - !!perl/hash:RE_method
          min: 0
          name: check_variable
          nobind: 1
          rest: ($<variable>)
    - !!perl/hash:RE_bindnamed
      a: 0
      atom: !!perl/hash:RE_quantified_atom
        atom: !!perl/hash:RE_paren
          decl: []
          min: 37036
          re: !!perl/hash:RE_sequence
            a: 0
            dba: metachar__S_497var
            i: 0
            min: 37036
            r: 1
            s: 0
            zyg:
            - !!perl/hash:RE_method
              a: 0
              dba: metachar__S_497var
              i: 0
              min: 12345
              name: ws
              nobind: 1
              r: 1
              rest: ''
              s: 0
            - !!perl/hash:RE_string
              a: 0
              dba: metachar__S_497var
              i: 0
              min: 1
              r: 1
              s: 0
              text: =
            - !!perl/hash:RE_method
              a: 0
              dba: metachar__S_497var
              i: 0
              min: 12345
              name: ws
              nobind: 1
              r: 1
              rest: ''
              s: 0
            - !!perl/hash:RE_method
              a: 0
              dba: metachar__S_497var
              i: 0
              min: 12345
              name: quantified_atom
              r: 1
              rest: ''
              s: 0
        min: 0
        quant:
        - '?'
        - ':'
        - ''
        - 0
      dba: metachar__S_497var
      i: 0
      min: 0
      r: 1
      s: 0
      var: binding
    - !!perl/hash:RE_block
      a: 0
      context: void
      dba: metachar__S_497var
      i: 0
      min: 0
      r: 1
      s: 0
      text: ' $<sym> = $<variable>.Str; '
mod_arg: !!perl/hash:RE_ast
  decl: []
  kind: token
  min: 12347
  pkg: ~
  re: !!perl/hash:RE_sequence
    a: 0
    dba: modifier argument
    i: 0
    min: 12347
    r: 1
    s: 0
    zyg:
    - !!perl/hash:RE_string
      a: 0
      dba: modifier argument
      i: 0
      min: 1
      r: 1
      s: 0
      text: (
    - !!perl/hash:RE_meta
      a: 0
      dba: modifier argument
      extra: 'local $::GOAL = '')'' '
      i: 0
      min: 0
      r: 1
      s: 0
      text: ':'
    - !!perl/hash:RE_bracket
      decl: []
      min: 12345
      re: !!perl/hash:RE_sequence
        a: 0
        dba: modifier argument
        i: 0
        lang: ($C->cursor_fresh($::LANG{'MAIN'}))
        min: 12345
        r: 1
        s: 0
        zyg:
        - !!perl/hash:RE_decl
          a: 0
          dba: modifier argument
          i: 0
          lang: ($C->cursor_fresh($::LANG{'MAIN'}))
          max: 0
          min: 0
          noquant: 1
          r: 1
          s: 0
          text: 'my $newlang = ($C->cursor_fresh($::LANG{''MAIN''}));  $C = $C->cursor_fresh($newlang); '
        - !!perl/hash:RE_method
          a: 0
          dba: modifier argument
          i: 0
          lang: ($C->cursor_fresh($::LANG{'MAIN'}))
          min: 12345
          name: semilist
          r: 1
          rest: ''
          s: 0
    - !!perl/hash:RE_bracket
      decl: []
      min: 1
      re: !!perl/hash:RE_first
        a: 0
        dba: modifier argument
        i: 0
        min: 1
        r: 1
        s: 0
        zyg:
        - !!perl/hash:RE_string
          a: 0
          dba: modifier argument
          i: 0
          min: 1
          r: 1
          s: 0
          text: )
        - !!perl/hash:RE_method
          min: 0
          name: FAILGOAL
          nobind: 1
          rest: (')' , 'modifier argument')
mod_internal__S_539Colonmy: !!perl/hash:RE_ast
  decl: []
  kind: token
  min: 24691
  pkg: ~
  re: !!perl/hash:RE_sequence
    a: 0
    dba: mod_internal__S_539Colonmy
    i: 0
    min: 24691
    r: 1
    s: 0
    zyg:
    - !!perl/hash:RE_string
      a: 0
      dba: mod_internal__S_539Colonmy
      i: 0
      min: 1
      r: 1
      s: 0
      text: ':'
    - !!perl/hash:RE_assertion
      assert: '?'
      min: 0
      re: !!perl/hash:RE_method_re
        a: 0
        dba: mod_internal__S_539Colonmy
        i: 0
        min: 0
        name: before
        nobind: 1
        r: 1
        re: !!perl/hash:RE_ast
          decl: []
          min: 3
          re: !!perl/hash:RE_sequence
            a: 0
            dba: mod_internal__S_539Colonmy
            i: 0
            min: 3
            r: 1
            s: 0
            zyg:
            - !!perl/hash:RE_bracket
              decl: []
              min: 2
              re: &12 !!perl/hash:RE_any
                a: 0
                altname: mod_internal__S_539Colonmy_02
                dba: mod_internal__S_539Colonmy
                i: 0
                min: 2
                name: mod_internal__S_539Colonmy_02
                r: 1
                s: 0
                zyg:
                - !!perl/hash:RE_string
                  a: 0
                  alt: mod_internal__S_539Colonmy_02 0
                  dba: mod_internal__S_539Colonmy
                  i: 0
                  min: 2
                  r: 1
                  s: 0
                  text: my
                - !!perl/hash:RE_string
                  a: 0
                  alt: mod_internal__S_539Colonmy_02 1
                  dba: mod_internal__S_539Colonmy
                  i: 0
                  min: 5
                  r: 1
                  s: 0
                  text: state
                - !!perl/hash:RE_string
                  a: 0
                  alt: mod_internal__S_539Colonmy_02 2
                  dba: mod_internal__S_539Colonmy
                  i: 0
                  min: 3
                  r: 1
                  s: 0
                  text: our
                - !!perl/hash:RE_string
                  a: 0
                  alt: mod_internal__S_539Colonmy_02 3
                  dba: mod_internal__S_539Colonmy
                  i: 0
                  min: 4
                  r: 1
                  s: 0
                  text: anon
                - !!perl/hash:RE_string
                  a: 0
                  alt: mod_internal__S_539Colonmy_02 4
                  dba: mod_internal__S_539Colonmy
                  i: 0
                  min: 8
                  r: 1
                  s: 0
                  text: constant
                - !!perl/hash:RE_string
                  a: 0
                  alt: mod_internal__S_539Colonmy_02 5
                  dba: mod_internal__S_539Colonmy
                  i: 0
                  min: 4
                  r: 1
                  s: 0
                  text: temp
                - !!perl/hash:RE_string
                  a: 0
                  alt: mod_internal__S_539Colonmy_02 6
                  dba: mod_internal__S_539Colonmy
                  i: 0
                  min: 3
                  r: 1
                  s: 0
                  text: let
            - !!perl/hash:RE_meta
              a: 0
              dba: mod_internal__S_539Colonmy
              i: 0
              min: 1
              r: 1
              s: 0
              text: \s
        s: 0
    - !!perl/hash:RE_bracket
      decl: []
      min: 24690
      re: !!perl/hash:RE_sequence
        a: 0
        dba: mod_internal__S_539Colonmy
        i: 0
        lang: ($C->cursor_fresh($::LANG{'MAIN'}))
        min: 24690
        r: 1
        s: 0
        zyg:
        - !!perl/hash:RE_decl
          a: 0
          dba: mod_internal__S_539Colonmy
          i: 0
          lang: ($C->cursor_fresh($::LANG{'MAIN'}))
          max: 0
          min: 0
          noquant: 1
          r: 1
          s: 0
          text: 'my $newlang = ($C->cursor_fresh($::LANG{''MAIN''}));  $C = $C->cursor_fresh($newlang); '
        - !!perl/hash:RE_method
          a: 0
          dba: mod_internal__S_539Colonmy
          i: 0
          lang: ($C->cursor_fresh($::LANG{'MAIN'}))
          min: 12345
          name: statement
          r: 1
          rest: ''
          s: 0
        - !!perl/hash:RE_method
          a: 0
          dba: mod_internal__S_539Colonmy
          i: 0
          lang: ($C->cursor_fresh($::LANG{'MAIN'}))
          min: 12345
          name: eat_terminator
          r: 1
          rest: ''
          s: 0
mod_internal__S_539Colonmy_02: *12
mod_internal__S_540Coloni: !!perl/hash:RE_ast
  decl: []
  kind: token
  min: 2
  pkg: ~
  re: !!perl/hash:RE_sequence
    a: 0
    dba: mod_internal__S_540Coloni
    i: 0
    min: 2
    r: 1
    s: 0
    zyg:
    - !!perl/hash:RE_bindnamed
      a: 0
      atom: !!perl/hash:RE_bracket
        decl: []
        min: 2
        re: &13 !!perl/hash:RE_any
          a: 0
          altname: mod_internal__S_540Coloni_01
          dba: mod_internal__S_540Coloni
          i: 0
          min: 2
          name: mod_internal__S_540Coloni_01
          r: 1
          s: 0
          zyg:
          - !!perl/hash:RE_string
            a: 0
            alt: mod_internal__S_540Coloni_01 0
            dba: mod_internal__S_540Coloni
            i: 0
            min: 2
            r: 1
            s: 0
            text: :i
          - !!perl/hash:RE_string
            a: 0
            alt: mod_internal__S_540Coloni_01 1
            dba: mod_internal__S_540Coloni
            i: 0
            min: 11
            r: 1
            s: 0
            text: :ignorecase
      dba: mod_internal__S_540Coloni
      i: 0
      min: 2
      r: 1
      s: 0
      var: sym
    - !!perl/hash:RE_meta
      a: 0
      dba: mod_internal__S_540Coloni
      i: 0
      min: 0
      r: 1
      s: 0
      text: 
    - !!perl/hash:RE_block
      a: 0
      context: void
      dba: mod_internal__S_540Coloni
      i: 0
      min: 0
      r: 1
      s: 0
      text: ' %*RX<i> = 1 '
mod_internal__S_540Coloni_01: *13
mod_internal__S_541ColonBangi: !!perl/hash:RE_ast
  decl: []
  kind: token
  min: 3
  pkg: ~
  re: !!perl/hash:RE_sequence
    a: 0
    dba: mod_internal__S_541ColonBangi
    i: 0
    min: 3
    r: 1
    s: 0
    zyg:
    - !!perl/hash:RE_bindnamed
      a: 0
      atom: !!perl/hash:RE_bracket
        decl: []
        min: 3
        re: &14 !!perl/hash:RE_any
          a: 0
          altname: mod_internal__S_541ColonBangi_01
          dba: mod_internal__S_541ColonBangi
          i: 0
          min: 3
          name: mod_internal__S_541ColonBangi_01
          r: 1
          s: 0
          zyg:
          - !!perl/hash:RE_string
            a: 0
            alt: mod_internal__S_541ColonBangi_01 0
            dba: mod_internal__S_541ColonBangi
            i: 0
            min: 3
            r: 1
            s: 0
            text: :!i
          - !!perl/hash:RE_string
            a: 0
            alt: mod_internal__S_541ColonBangi_01 1
            dba: mod_internal__S_541ColonBangi
            i: 0
            min: 12
            r: 1
            s: 0
            text: :!ignorecase
      dba: mod_internal__S_541ColonBangi
      i: 0
      min: 3
      r: 1
      s: 0
      var: sym
    - !!perl/hash:RE_meta
      a: 0
      dba: mod_internal__S_541ColonBangi
      i: 0
      min: 0
      r: 1
      s: 0
      text: 
    - !!perl/hash:RE_block
      a: 0
      context: void
      dba: mod_internal__S_541ColonBangi
      i: 0
      min: 0
      r: 1
      s: 0
      text: ' %*RX<i> = 0 '
mod_internal__S_541ColonBangi_01: *14
mod_internal__S_542ColoniParen_Thesis: !!perl/hash:RE_ast
  decl: []
  kind: token
  min: 12347
  pkg: ~
  re: !!perl/hash:RE_sequence
    a: 0
    dba: mod_internal__S_542ColoniParen_Thesis
    i: 0
    min: 12347
    r: 1
    s: 0
    zyg:
    - !!perl/hash:RE_bindnamed
      a: 0
      atom: !!perl/hash:RE_bracket
        decl: []
        min: 2
        re: &15 !!perl/hash:RE_any
          a: 0
          altname: mod_internal__S_542ColoniParen_Thesis_01
          dba: mod_internal__S_542ColoniParen_Thesis
          i: 0
          min: 2
          name: mod_internal__S_542ColoniParen_Thesis_01
          r: 1
          s: 0
          zyg:
          - !!perl/hash:RE_string
            a: 0
            alt: mod_internal__S_542ColoniParen_Thesis_01 0
            dba: mod_internal__S_542ColoniParen_Thesis
            i: 0
            min: 2
            r: 1
            s: 0
            text: :i
          - !!perl/hash:RE_string
            a: 0
            alt: mod_internal__S_542ColoniParen_Thesis_01 1
            dba: mod_internal__S_542ColoniParen_Thesis
            i: 0
            min: 11
            r: 1
            s: 0
            text: :ignorecase
      dba: mod_internal__S_542ColoniParen_Thesis
      i: 0
      min: 2
      r: 1
      s: 0
      var: sym
    - !!perl/hash:RE_method
      a: 0
      dba: mod_internal__S_542ColoniParen_Thesis
      i: 0
      min: 12345
      name: mod_arg
      r: 1
      rest: ''
      s: 0
    - !!perl/hash:RE_block
      a: 0
      context: void
      dba: mod_internal__S_542ColoniParen_Thesis
      i: 0
      min: 0
      r: 1
      s: 0
      text: ' %*RX<i> = eval $<mod_arg>.Str '
mod_internal__S_542ColoniParen_Thesis_01: *15
mod_internal__S_543Colon0i: !!perl/hash:RE_ast
  decl: []
  kind: token
  min: 3
  pkg: ~
  re: !!perl/hash:RE_sequence
    a: 0
    dba: mod_internal__S_543Colon0i
    i: 0
    min: 3
    r: 1
    s: 0
    zyg:
    - !!perl/hash:RE_string
      a: 0
      dba: mod_internal__S_543Colon0i
      i: 0
      min: 1
      r: 1
      s: 0
      text: ':'
    - !!perl/hash:RE_bindpos
      atom: !!perl/hash:RE_paren
        decl: []
        min: 1
        re: !!perl/hash:RE_quantified_atom
          atom: !!perl/hash:RE_meta
            a: 0
            dba: mod_internal__S_543Colon0i
            i: 0
            min: 1
            r: 1
            s: 0
            text: \d
          min: 1
          quant:
          - +
          - ':'
          - ''
          - 1
      min: 1
      var: 0
    - !!perl/hash:RE_bracket
      decl: []
      min: 1
      re: &16 !!perl/hash:RE_any
        a: 0
        altname: mod_internal__S_543Colon0i_02
        dba: mod_internal__S_543Colon0i
        i: 0
        min: 1
        name: mod_internal__S_543Colon0i_02
        r: 1
        s: 0
        zyg:
        - !!perl/hash:RE_string
          a: 0
          alt: mod_internal__S_543Colon0i_02 0
          dba: mod_internal__S_543Colon0i
          i: 0
          min: 1
          r: 1
          s: 0
          text: i
        - !!perl/hash:RE_string
          a: 0
          alt: mod_internal__S_543Colon0i_02 1
          dba: mod_internal__S_543Colon0i
          i: 0
          min: 10
          r: 1
          s: 0
          text: ignorecase
    - !!perl/hash:RE_block
      a: 0
      context: void
      dba: mod_internal__S_543Colon0i
      i: 0
      min: 0
      r: 1
      s: 0
      text: ' %*RX<i> = $0 '
mod_internal__S_543Colon0i_02: *16
mod_internal__S_544Colona: !!perl/hash:RE_ast
  decl: []
  kind: token
  min: 2
  pkg: ~
  re: !!perl/hash:RE_sequence
    a: 0
    dba: mod_internal__S_544Colona
    i: 0
    min: 2
    r: 1
    s: 0
    zyg:
    - !!perl/hash:RE_bindnamed
      a: 0
      atom: !!perl/hash:RE_bracket
        decl: []
        min: 2
        re: &17 !!perl/hash:RE_any
          a: 0
          altname: mod_internal__S_544Colona_01
          dba: mod_internal__S_544Colona
          i: 0
          min: 2
          name: mod_internal__S_544Colona_01
          r: 1
          s: 0
          zyg:
          - !!perl/hash:RE_string
            a: 0
            alt: mod_internal__S_544Colona_01 0
            dba: mod_internal__S_544Colona
            i: 0
            min: 2
            r: 1
            s: 0
            text: :a
          - !!perl/hash:RE_string
            a: 0
            alt: mod_internal__S_544Colona_01 1
            dba: mod_internal__S_544Colona
            i: 0
            min: 13
            r: 1
            s: 0
            text: :ignoreaccent
      dba: mod_internal__S_544Colona
      i: 0
      min: 2
      r: 1
      s: 0
      var: sym
    - !!perl/hash:RE_meta
      a: 0
      dba: mod_internal__S_544Colona
      i: 0
      min: 0
      r: 1
      s: 0
      text: 
    - !!perl/hash:RE_block
      a: 0
      context: void
      dba: mod_internal__S_544Colona
      i: 0
      min: 0
      r: 1
      s: 0
      text: ' %*RX<a> = 1 '
mod_internal__S_544Colona_01: *17
mod_internal__S_545ColonBanga: !!perl/hash:RE_ast
  decl: []
  kind: token
  min: 3
  pkg: ~
  re: !!perl/hash:RE_sequence
    a: 0
    dba: mod_internal__S_545ColonBanga
    i: 0
    min: 3
    r: 1
    s: 0
    zyg:
    - !!perl/hash:RE_bindnamed
      a: 0
      atom: !!perl/hash:RE_bracket
        decl: []
        min: 3
        re: &18 !!perl/hash:RE_any
          a: 0
          altname: mod_internal__S_545ColonBanga_01
          dba: mod_internal__S_545ColonBanga
          i: 0
          min: 3
          name: mod_internal__S_545ColonBanga_01
          r: 1
          s: 0
          zyg:
          - !!perl/hash:RE_string
            a: 0
            alt: mod_internal__S_545ColonBanga_01 0
            dba: mod_internal__S_545ColonBanga
            i: 0
            min: 3
            r: 1
            s: 0
            text: :!a
          - !!perl/hash:RE_string
            a: 0
            alt: mod_internal__S_545ColonBanga_01 1
            dba: mod_internal__S_545ColonBanga
            i: 0
            min: 14
            r: 1
            s: 0
            text: :!ignoreaccent
      dba: mod_internal__S_545ColonBanga
      i: 0
      min: 3
      r: 1
      s: 0
      var: sym
    - !!perl/hash:RE_meta
      a: 0
      dba: mod_internal__S_545ColonBanga
      i: 0
      min: 0
      r: 1
      s: 0
      text: 
    - !!perl/hash:RE_block
      a: 0
      context: void
      dba: mod_internal__S_545ColonBanga
      i: 0
      min: 0
      r: 1
      s: 0
      text: ' %*RX<a> = 0 '
mod_internal__S_545ColonBanga_01: *18
mod_internal__S_546ColonaParen_Thesis: !!perl/hash:RE_ast
  decl: []
  kind: token
  min: 12347
  pkg: ~
  re: !!perl/hash:RE_sequence
    a: 0
    dba: mod_internal__S_546ColonaParen_Thesis
    i: 0
    min: 12347
    r: 1
    s: 0
    zyg:
    - !!perl/hash:RE_bindnamed
      a: 0
      atom: !!perl/hash:RE_bracket
        decl: []
        min: 2
        re: &19 !!perl/hash:RE_any
          a: 0
          altname: mod_internal__S_546ColonaParen_Thesis_01
          dba: mod_internal__S_546ColonaParen_Thesis
          i: 0
          min: 2
          name: mod_internal__S_546ColonaParen_Thesis_01
          r: 1
          s: 0
          zyg:
          - !!perl/hash:RE_string
            a: 0
            alt: mod_internal__S_546ColonaParen_Thesis_01 0
            dba: mod_internal__S_546ColonaParen_Thesis
            i: 0
            min: 2
            r: 1
            s: 0
            text: :a
          - !!perl/hash:RE_string
            a: 0
            alt: mod_internal__S_546ColonaParen_Thesis_01 1
            dba: mod_internal__S_546ColonaParen_Thesis
            i: 0
            min: 13
            r: 1
            s: 0
            text: :ignoreaccent
      dba: mod_internal__S_546ColonaParen_Thesis
      i: 0
      min: 2
      r: 1
      s: 0
      var: sym
    - !!perl/hash:RE_method
      a: 0
      dba: mod_internal__S_546ColonaParen_Thesis
      i: 0
      min: 12345
      name: mod_arg
      r: 1
      rest: ''
      s: 0
    - !!perl/hash:RE_block
      a: 0
      context: void
      dba: mod_internal__S_546ColonaParen_Thesis
      i: 0
      min: 0
      r: 1
      s: 0
      text: ' %*RX<a> = eval $<mod_arg>.Str '
mod_internal__S_546ColonaParen_Thesis_01: *19
mod_internal__S_547Colon0a: !!perl/hash:RE_ast
  decl: []
  kind: token
  min: 3
  pkg: ~
  re: !!perl/hash:RE_sequence
    a: 0
    dba: mod_internal__S_547Colon0a
    i: 0
    min: 3
    r: 1
    s: 0
    zyg:
    - !!perl/hash:RE_string
      a: 0
      dba: mod_internal__S_547Colon0a
      i: 0
      min: 1
      r: 1
      s: 0
      text: ':'
    - !!perl/hash:RE_bindpos
      atom: !!perl/hash:RE_paren
        decl: []
        min: 1
        re: !!perl/hash:RE_quantified_atom
          atom: !!perl/hash:RE_meta
            a: 0
            dba: mod_internal__S_547Colon0a
            i: 0
            min: 1
            r: 1
            s: 0
            text: \d
          min: 1
          quant:
          - +
          - ':'
          - ''
          - 1
      min: 1
      var: 0
    - !!perl/hash:RE_bracket
      decl: []
      min: 1
      re: &20 !!perl/hash:RE_any
        a: 0
        altname: mod_internal__S_547Colon0a_02
        dba: mod_internal__S_547Colon0a
        i: 0
        min: 1
        name: mod_internal__S_547Colon0a_02
        r: 1
        s: 0
        zyg:
        - !!perl/hash:RE_string
          a: 0
          alt: mod_internal__S_547Colon0a_02 0
          dba: mod_internal__S_547Colon0a
          i: 0
          min: 1
          r: 1
          s: 0
          text: a
        - !!perl/hash:RE_string
          a: 0
          alt: mod_internal__S_547Colon0a_02 1
          dba: mod_internal__S_547Colon0a
          i: 0
          min: 12
          r: 1
          s: 0
          text: ignoreaccent
    - !!perl/hash:RE_block
      a: 0
      context: void
      dba: mod_internal__S_547Colon0a
      i: 0
      min: 0
      r: 1
      s: 0
      text: ' %*RX<a> = $0 '
mod_internal__S_547Colon0a_02: *20
mod_internal__S_548Colons: !!perl/hash:RE_ast
  decl: []
  kind: token
  min: 2
  pkg: ~
  re: !!perl/hash:RE_sequence
    a: 0
    dba: mod_internal__S_548Colons
    i: 0
    min: 2
    r: 1
    s: 0
    zyg:
    - !!perl/hash:RE_string
      a: 0
      dba: mod_internal__S_548Colons
      i: 0
      min: 2
      r: 1
      s: 0
      text: :s
    - !!perl/hash:RE_quantified_atom
      atom: !!perl/hash:RE_string
        a: 0
        dba: mod_internal__S_548Colons
        i: 0
        min: 7
        r: 1
        s: 0
        text: igspace
      min: 0
      quant:
      - '?'
      - ':'
      - ''
      - 0
    - !!perl/hash:RE_meta
      a: 0
      dba: mod_internal__S_548Colons
      i: 0
      min: 0
      r: 1
      s: 0
      text: 
    - !!perl/hash:RE_block
      a: 0
      context: void
      dba: mod_internal__S_548Colons
      i: 0
      min: 0
      r: 1
      s: 0
      text: ' %*RX<s> = 1 '
mod_internal__S_549ColonBangs: !!perl/hash:RE_ast
  decl: []
  kind: token
  min: 3
  pkg: ~
  re: !!perl/hash:RE_sequence
    a: 0
    dba: mod_internal__S_549ColonBangs
    i: 0
    min: 3
    r: 1
    s: 0
    zyg:
    - !!perl/hash:RE_string
      a: 0
      dba: mod_internal__S_549ColonBangs
      i: 0
      min: 3
      r: 1
      s: 0
      text: :!s
    - !!perl/hash:RE_quantified_atom
      atom: !!perl/hash:RE_string
        a: 0
        dba: mod_internal__S_549ColonBangs
        i: 0
        min: 7
        r: 1
        s: 0
        text: igspace
      min: 0
      quant:
      - '?'
      - ':'
      - ''
      - 0
    - !!perl/hash:RE_meta
      a: 0
      dba: mod_internal__S_549ColonBangs
      i: 0
      min: 0
      r: 1
      s: 0
      text: 
    - !!perl/hash:RE_block
      a: 0
      context: void
      dba: mod_internal__S_549ColonBangs
      i: 0
      min: 0
      r: 1
      s: 0
      text: ' %*RX<s> = 0 '
mod_internal__S_550ColonsParen_Thesis: !!perl/hash:RE_ast
  decl: []
  kind: token
  min: 12347
  pkg: ~
  re: !!perl/hash:RE_sequence
    a: 0
    dba: mod_internal__S_550ColonsParen_Thesis
    i: 0
    min: 12347
    r: 1
    s: 0
    zyg:
    - !!perl/hash:RE_string
      a: 0
      dba: mod_internal__S_550ColonsParen_Thesis
      i: 0
      min: 2
      r: 1
      s: 0
      text: :s
    - !!perl/hash:RE_quantified_atom
      atom: !!perl/hash:RE_string
        a: 0
        dba: mod_internal__S_550ColonsParen_Thesis
        i: 0
        min: 7
        r: 1
        s: 0
        text: igspace
      min: 0
      quant:
      - '?'
      - ':'
      - ''
      - 0
    - !!perl/hash:RE_method
      a: 0
      dba: mod_internal__S_550ColonsParen_Thesis
      i: 0
      min: 12345
      name: mod_arg
      r: 1
      rest: ''
      s: 0
    - !!perl/hash:RE_block
      a: 0
      context: void
      dba: mod_internal__S_550ColonsParen_Thesis
      i: 0
      min: 0
      r: 1
      s: 0
      text: ' %*RX<s> = eval $<mod_arg>.Str '
mod_internal__S_551Colon0s: !!perl/hash:RE_ast
  decl: []
  kind: token
  min: 3
  pkg: ~
  re: !!perl/hash:RE_sequence
    a: 0
    dba: mod_internal__S_551Colon0s
    i: 0
    min: 3
    r: 1
    s: 0
    zyg:
    - !!perl/hash:RE_string
      a: 0
      dba: mod_internal__S_551Colon0s
      i: 0
      min: 1
      r: 1
      s: 0
      text: ':'
    - !!perl/hash:RE_bindpos
      atom: !!perl/hash:RE_paren
        decl: []
        min: 1
        re: !!perl/hash:RE_quantified_atom
          atom: !!perl/hash:RE_meta
            a: 0
            dba: mod_internal__S_551Colon0s
            i: 0
            min: 1
            r: 1
            s: 0
            text: \d
          min: 1
          quant:
          - +
          - ':'
          - ''
          - 1
      min: 1
      var: 0
    - !!perl/hash:RE_string
      a: 0
      dba: mod_internal__S_551Colon0s
      i: 0
      min: 1
      r: 1
      s: 0
      text: s
    - !!perl/hash:RE_quantified_atom
      atom: !!perl/hash:RE_string
        a: 0
        dba: mod_internal__S_551Colon0s
        i: 0
        min: 7
        r: 1
        s: 0
        text: igspace
      min: 0
      quant:
      - '?'
      - ':'
      - ''
      - 0
    - !!perl/hash:RE_meta
      a: 0
      dba: mod_internal__S_551Colon0s
      i: 0
      min: 0
      r: 1
      s: 0
      text: 
    - !!perl/hash:RE_block
      a: 0
      context: void
      dba: mod_internal__S_551Colon0s
      i: 0
      min: 0
      r: 1
      s: 0
      text: ' %*RX<s> = $0 '
mod_internal__S_552Colonr: !!perl/hash:RE_ast
  decl: []
  kind: token
  min: 2
  pkg: ~
  re: !!perl/hash:RE_sequence
    a: 0
    dba: mod_internal__S_552Colonr
    i: 0
    min: 2
    r: 1
    s: 0
    zyg:
    - !!perl/hash:RE_string
      a: 0
      dba: mod_internal__S_552Colonr
      i: 0
      min: 2
      r: 1
      s: 0
      text: :r
    - !!perl/hash:RE_quantified_atom
      atom: !!perl/hash:RE_string
        a: 0
        dba: mod_internal__S_552Colonr
        i: 0
        min: 6
        r: 1
        s: 0
        text: atchet
      min: 0
      quant:
      - '?'
      - ':'
      - ''
      - 0
    - !!perl/hash:RE_meta
      a: 0
      dba: mod_internal__S_552Colonr
      i: 0
      min: 0
      r: 1
      s: 0
      text: 
    - !!perl/hash:RE_block
      a: 0
      context: void
      dba: mod_internal__S_552Colonr
      i: 0
      min: 0
      r: 1
      s: 0
      text: ' %*RX<r> = 1 '
mod_internal__S_553ColonBangr: !!perl/hash:RE_ast
  decl: []
  kind: token
  min: 3
  pkg: ~
  re: !!perl/hash:RE_sequence
    a: 0
    dba: mod_internal__S_553ColonBangr
    i: 0
    min: 3
    r: 1
    s: 0
    zyg:
    - !!perl/hash:RE_string
      a: 0
      dba: mod_internal__S_553ColonBangr
      i: 0
      min: 3
      r: 1
      s: 0
      text: :!r
    - !!perl/hash:RE_quantified_atom
      atom: !!perl/hash:RE_string
        a: 0
        dba: mod_internal__S_553ColonBangr
        i: 0
        min: 6
        r: 1
        s: 0
        text: atchet
      min: 0
      quant:
      - '?'
      - ':'
      - ''
      - 0
    - !!perl/hash:RE_meta
      a: 0
      dba: mod_internal__S_553ColonBangr
      i: 0
      min: 0
      r: 1
      s: 0
      text: 
    - !!perl/hash:RE_block
      a: 0
      context: void
      dba: mod_internal__S_553ColonBangr
      i: 0
      min: 0
      r: 1
      s: 0
      text: ' %*RX<r> = 0 '
mod_internal__S_554ColonrParen_Thesis: !!perl/hash:RE_ast
  decl: []
  kind: token
  min: 12347
  pkg: ~
  re: !!perl/hash:RE_sequence
    a: 0
    dba: mod_internal__S_554ColonrParen_Thesis
    i: 0
    min: 12347
    r: 1
    s: 0
    zyg:
    - !!perl/hash:RE_string
      a: 0
      dba: mod_internal__S_554ColonrParen_Thesis
      i: 0
      min: 2
      r: 1
      s: 0
      text: :r
    - !!perl/hash:RE_quantified_atom
      atom: !!perl/hash:RE_string
        a: 0
        dba: mod_internal__S_554ColonrParen_Thesis
        i: 0
        min: 6
        r: 1
        s: 0
        text: atchet
      min: 0
      quant:
      - '?'
      - ':'
      - ''
      - 0
    - !!perl/hash:RE_meta
      a: 0
      dba: mod_internal__S_554ColonrParen_Thesis
      i: 0
      min: 0
      r: 1
      s: 0
      text: 
    - !!perl/hash:RE_method
      a: 0
      dba: mod_internal__S_554ColonrParen_Thesis
      i: 0
      min: 12345
      name: mod_arg
      r: 1
      rest: ''
      s: 0
    - !!perl/hash:RE_block
      a: 0
      context: void
      dba: mod_internal__S_554ColonrParen_Thesis
      i: 0
      min: 0
      r: 1
      s: 0
      text: ' %*RX<r> = eval $<mod_arg>.Str '
mod_internal__S_555Colon0r: !!perl/hash:RE_ast
  decl: []
  kind: token
  min: 3
  pkg: ~
  re: !!perl/hash:RE_sequence
    a: 0
    dba: mod_internal__S_555Colon0r
    i: 0
    min: 3
    r: 1
    s: 0
    zyg:
    - !!perl/hash:RE_string
      a: 0
      dba: mod_internal__S_555Colon0r
      i: 0
      min: 1
      r: 1
      s: 0
      text: ':'
    - !!perl/hash:RE_bindpos
      atom: !!perl/hash:RE_paren
        decl: []
        min: 1
        re: !!perl/hash:RE_quantified_atom
          atom: !!perl/hash:RE_meta
            a: 0
            dba: mod_internal__S_555Colon0r
            i: 0
            min: 1
            r: 1
            s: 0
            text: \d
          min: 1
          quant:
          - +
          - ':'
          - ''
          - 1
      min: 1
      var: 0
    - !!perl/hash:RE_string
      a: 0
      dba: mod_internal__S_555Colon0r
      i: 0
      min: 1
      r: 1
      s: 0
      text: r
    - !!perl/hash:RE_quantified_atom
      atom: !!perl/hash:RE_string
        a: 0
        dba: mod_internal__S_555Colon0r
        i: 0
        min: 6
        r: 1
        s: 0
        text: atchet
      min: 0
      quant:
      - '?'
      - ':'
      - ''
      - 0
    - !!perl/hash:RE_meta
      a: 0
      dba: mod_internal__S_555Colon0r
      i: 0
      min: 0
      r: 1
      s: 0
      text: 
    - !!perl/hash:RE_block
      a: 0
      context: void
      dba: mod_internal__S_555Colon0r
      i: 0
      min: 0
      r: 1
      s: 0
      text: ' %*RX<r> = $0 '
mod_internal__S_556ColonPerl5: !!perl/hash:RE_ast
  decl: []
  kind: token
  min: 24693
  pkg: ~
  re: !!perl/hash:RE_sequence
    a: 0
    dba: mod_internal__S_556ColonPerl5
    i: 0
    min: 24693
    r: 1
    s: 0
    zyg:
    - !!perl/hash:RE_bracket
      decl: []
      min: 3
      re: &21 !!perl/hash:RE_any
        a: 0
        altname: mod_internal__S_556ColonPerl5_01
        dba: mod_internal__S_556ColonPerl5
        i: 0
        min: 3
        name: mod_internal__S_556ColonPerl5_01
        r: 1
        s: 0
        zyg:
        - !!perl/hash:RE_string
          a: 0
          alt: mod_internal__S_556ColonPerl5_01 0
          dba: mod_internal__S_556ColonPerl5
          i: 0
          min: 6
          r: 1
          s: 0
          text: :Perl5
        - !!perl/hash:RE_string
          a: 0
          alt: mod_internal__S_556ColonPerl5_01 1
          dba: mod_internal__S_556ColonPerl5
          i: 0
          min: 3
          r: 1
          s: 0
          text: :P5
    - !!perl/hash:RE_method
      a: 0
      dba: mod_internal__S_556ColonPerl5
      i: 0
      min: 12345
      name: require_P5
      nobind: 1
      r: 1
      rest: ''
      s: 0
    - !!perl/hash:RE_bracket
      decl: []
      min: 12345
      re: !!perl/hash:RE_sequence
        a: 0
        dba: mod_internal__S_556ColonPerl5
        i: 0
        lang: ( $C->cursor_fresh( $::LANG{'P5Regex'} )->unbalanced($::GOAL) )
        min: 12345
        r: 1
        s: 0
        zyg:
        - !!perl/hash:RE_decl
          a: 0
          dba: mod_internal__S_556ColonPerl5
          i: 0
          lang: ( $C->cursor_fresh( $::LANG{'P5Regex'} )->unbalanced($::GOAL) )
          max: 0
          min: 0
          noquant: 1
          r: 1
          s: 0
          text: 'my $newlang = ( $C->cursor_fresh( $::LANG{''P5Regex''} )->unbalanced($::GOAL)
            );  $C = $C->cursor_fresh($newlang); '
        - !!perl/hash:RE_method
          a: 0
          dba: mod_internal__S_556ColonPerl5
          i: 0
          lang: ( $C->cursor_fresh( $::LANG{'P5Regex'} )->unbalanced($::GOAL) )
          min: 12345
          name: nibbler
          r: 1
          rest: ''
          s: 0
mod_internal__S_556ColonPerl5_01: *21
mod_internal__S_557adv: !!perl/hash:RE_ast
  decl: []
  kind: token
  min: 12345
  pkg: ~
  re: !!perl/hash:RE_sequence
    a: 0
    dba: mod_internal__S_557adv
    i: 0
    min: 12345
    r: 1
    s: 0
    zyg:
    - !!perl/hash:RE_assertion
      assert: '?'
      min: 0
      re: !!perl/hash:RE_method_re
        a: 0
        dba: mod_internal__S_557adv
        i: 0
        min: 0
        name: before
        nobind: 1
        r: 1
        re: !!perl/hash:RE_ast
          decl: []
          min: 12346
          re: !!perl/hash:RE_sequence
            a: 0
            dba: mod_internal__S_557adv
            i: 0
            min: 12346
            r: 1
            s: 0
            zyg:
            - !!perl/hash:RE_string
              a: 0
              dba: mod_internal__S_557adv
              i: 0
              min: 1
              r: 1
              s: 0
              text: ':'
            - !!perl/hash:RE_method
              a: 0
              dba: mod_internal__S_557adv
              i: 0
              min: 12345
              name: identifier
              nobind: 1
              r: 1
              rest: ''
              s: 0
        s: 0
    - !!perl/hash:RE_bracket
      decl: []
      min: 12345
      re: !!perl/hash:RE_sequence
        a: 0
        dba: mod_internal__S_557adv
        i: 0
        lang: ($C->cursor_fresh($::LANG{'MAIN'}))
        min: 12345
        r: 1
        s: 0
        zyg:
        - !!perl/hash:RE_decl
          a: 0
          dba: mod_internal__S_557adv
          i: 0
          lang: ($C->cursor_fresh($::LANG{'MAIN'}))
          max: 0
          min: 0
          noquant: 1
          r: 1
          s: 0
          text: 'my $newlang = ($C->cursor_fresh($::LANG{''MAIN''}));  $C = $C->cursor_fresh($newlang); '
        - !!perl/hash:RE_method
          a: 0
          dba: mod_internal__S_557adv
          i: 0
          lang: ($C->cursor_fresh($::LANG{'MAIN'}))
          min: 12345
          name: quotepair
          r: 1
          rest: ''
          s: 0
    - !!perl/hash:RE_block
      a: 0
      context: void
      dba: mod_internal__S_557adv
      i: 0
      min: 0
      r: 1
      s: 0
      text: ' $/<sym> := : $<quotepair><key> '
mod_internal__S_558oops: !!perl/hash:RE_ast
  decl: []
  kind: token
  min: 2
  pkg: ~
  re: !!perl/hash:RE_sequence
    a: 0
    dba: mod_internal__S_558oops
    i: 0
    min: 2
    r: 1
    s: 0
    zyg:
    - !!perl/hash:RE_string
      a: 0
      dba: mod_internal__S_558oops
      i: 0
      min: 1
      r: 1
      s: 0
      text: ':'
    - !!perl/hash:RE_quantified_atom
      atom: !!perl/hash:RE_meta
        a: 0
        dba: mod_internal__S_558oops
        i: 0
        min: 1
        r: 1
        s: 0
        text: \w
      min: 1
      quant:
      - +
      - ':'
      - ''
      - 1
    - !!perl/hash:RE_method
      min: 0
      name: panic
      nobind: 1
      rest: ("Unrecognized regex modifier")
nibbler: !!perl/hash:RE_ast
  decl:
  - !!perl/hash:RE_decl
    a: 0
    dba: nibbler
    i: 0
    max: 0
    min: 0
    r: 1
    s: 1
    text: temp %*RX
  kind: rule
  min: 12345
  pkg: ~
  re: !!perl/hash:RE_sequence
    a: 0
    dba: nibbler
    i: 0
    min: 12345
    r: 1
    s: 1
    zyg:
    - !!perl/hash:RE_method
      min: 0
      name: ws
      nobind: 1
      noquant: 1
      rest: ''
    - !!perl/hash:RE_quantified_atom
      atom: !!perl/hash:RE_bracket
        decl: []
        min: 1
        re: !!perl/hash:RE_sequence
          a: 0
          dba: nibbler
          i: 0
          min: 1
          r: 1
          s: 1
          zyg:
          - !!perl/hash:RE_method
            min: 0
            name: ws
            nobind: 1
            noquant: 1
            rest: ''
          - !!perl/hash:RE_quantified_atom
            atom: !!perl/hash:RE_meta
              a: 0
              dba: nibbler
              i: 0
              min: 1
              r: 1
              s: 1
              text: \s
            min: 0
            quant:
            - '*'
            - ':'
            - ''
            - 0
          - !!perl/hash:RE_method
            min: 0
            name: ws
            nobind: 1
            noquant: 1
            rest: ''
          - !!perl/hash:RE_qw
            a: 0
            dba: nibbler
            i: 0
            min: 1
            r: 1
            s: 1
            text: < || | && & >
          - !!perl/hash:RE_method
            min: 0
            name: ws
            nobind: 1
            noquant: 1
            rest: ''
      min: 0
      quant:
      - '?'
      - ':'
      - ''
      - 0
    - !!perl/hash:RE_method
      min: 0
      name: ws
      nobind: 1
      noquant: 1
      rest: ''
    - !!perl/hash:RE_method
      a: 0
      dba: nibbler
      i: 0
      min: 12345
      name: EXPR
      r: 1
      rest: ''
      s: 1
    - !!perl/hash:RE_method
      min: 0
      name: ws
      nobind: 1
      noquant: 1
      rest: ''
    - !!perl/hash:RE_bracket
      decl: []
      min: 0
      re: !!perl/hash:RE_first
        a: 0
        dba: nibbler
        i: 0
        min: 0
        r: 1
        s: 1
        zyg:
        - !!perl/hash:RE_sequence
          a: 0
          dba: nibbler
          i: 0
          min: 0
          r: 1
          s: 1
          zyg:
          - !!perl/hash:RE_assertion
            assert: '?'
            min: 0
            re: !!perl/hash:RE_method_re
              a: 0
              dba: nibbler
              i: 0
              min: 0
              name: before
              nobind: 1
              r: 1
              re: !!perl/hash:RE_ast
                decl: []
                min: 0
                re: !!perl/hash:RE_first
                  a: 0
                  dba: nibbler
                  i: 0
                  min: 0
                  r: 1
                  s: 1
                  zyg:
                  - !!perl/hash:RE_sequence
                    a: 0
                    dba: nibbler
                    i: 0
                    min: 12345
                    r: 1
                    s: 1
                    zyg:
                    - !!perl/hash:RE_method
                      a: 0
                      dba: nibbler
                      i: 0
                      min: 12345
                      name: stopper
                      r: 1
                      rest: ''
                      s: 1
                    - !!perl/hash:RE_method
                      min: 0
                      name: ws
                      nobind: 1
                      noquant: 1
                      rest: ''
                  - !!perl/hash:RE_sequence
                    a: 0
                    dba: nibbler
                    i: 0
                    min: 0
                    r: 1
                    s: 1
                    zyg:
                    - !!perl/hash:RE_method
                      min: 0
                      name: ws
                      nobind: 1
                      noquant: 1
                      rest: ''
                    - !!perl/hash:RE_var
                      a: 0
                      dba: nibbler
                      i: 0
                      min: 0
                      r: 1
                      s: 1
                      var: $*GOAL
                    - !!perl/hash:RE_method
                      min: 0
                      name: ws
                      nobind: 1
                      noquant: 1
                      rest: ''
              s: 1
          - !!perl/hash:RE_method
            min: 0
            name: ws
            nobind: 1
            noquant: 1
            rest: ''
        - !!perl/hash:RE_sequence
          a: 0
          dba: nibbler
          i: 0
          min: 0
          r: 1
          s: 1
          zyg:
          - !!perl/hash:RE_method
            min: 0
            name: panic
            nobind: 1
            rest: ("Unrecognized regex metacharacter (must be quoted to match literally)")
          - !!perl/hash:RE_method
            min: 0
            name: ws
            nobind: 1
            noquant: 1
            rest: ''
    - !!perl/hash:RE_method
      min: 0
      name: ws
      nobind: 1
      noquant: 1
      rest: ''
normspace: !!perl/hash:RE_ast
  decl: []
  kind: token
  min: 12345
  pkg: ~
  re: !!perl/hash:RE_sequence
    a: 0
    dba: normspace
    i: 0
    min: 12345
    r: 1
    s: 0
    zyg:
    - !!perl/hash:RE_assertion
      assert: '?'
      min: 0
      re: !!perl/hash:RE_method_re
        a: 0
        dba: normspace
        i: 0
        min: 0
        name: before
        nobind: 1
        r: 1
        re: !!perl/hash:RE_ast
          decl: []
          min: 1
          re: &22 !!perl/hash:RE_any
            a: 0
            altname: normspace_01
            dba: normspace
            i: 0
            min: 1
            name: normspace_01
            r: 1
            s: 0
            zyg:
            - !!perl/hash:RE_meta
              a: 0
              alt: normspace_01 0
              dba: normspace
              i: 0
              min: 1
              r: 1
              s: 0
              text: \s
            - !!perl/hash:RE_string
              a: 0
              alt: normspace_01 1
              dba: normspace
              i: 0
              min: 1
              r: 1
              s: 0
              text: '#'
        s: 0
    - !!perl/hash:RE_bracket
      decl: []
      min: 12345
      re: !!perl/hash:RE_sequence
        a: 0
        dba: normspace
        i: 0
        lang: ($C->cursor_fresh($::LANG{'MAIN'}))
        min: 12345
        r: 1
        s: 0
        zyg:
        - !!perl/hash:RE_decl
          a: 0
          dba: normspace
          i: 0
          lang: ($C->cursor_fresh($::LANG{'MAIN'}))
          max: 0
          min: 0
          noquant: 1
          r: 1
          s: 0
          text: 'my $newlang = ($C->cursor_fresh($::LANG{''MAIN''}));  $C = $C->cursor_fresh($newlang); '
        - !!perl/hash:RE_method
          a: 0
          dba: normspace
          i: 0
          lang: ($C->cursor_fresh($::LANG{'MAIN'}))
          min: 12345
          name: ws
          nobind: 1
          r: 1
          rest: ''
          s: 0
normspace_01: *22
quant_atom_list: !!perl/hash:RE_ast
  decl: []
  kind: token
  min: 12345
  pkg: ~
  re: !!perl/hash:RE_quantified_atom
    atom: !!perl/hash:RE_method
      a: 0
      dba: quant_atom_list
      i: 0
      min: 12345
      name: quantified_atom
      r: 1
      rest: ''
      s: 0
    min: 12345
    quant:
    - +
    - ':'
    - ''
    - 1
quantified_atom: !!perl/hash:RE_ast
  decl: []
  kind: token
  min: 24690
  pkg: ~
  re: !!perl/hash:RE_sequence
    a: 0
    dba: quantified_atom
    i: 0
    min: 24690
    r: 1
    s: 0
    zyg:
    - !!perl/hash:RE_assertion
      assert: '!'
      min: 0
      re: !!perl/hash:RE_method
        a: 0
        dba: quantified_atom
        i: 0
        min: 12345
        name: stopper
        nobind: 1
        r: 1
        rest: ''
        s: 0
    - !!perl/hash:RE_assertion
      assert: '!'
      min: 0
      re: !!perl/hash:RE_method
        a: 0
        dba: quantified_atom
        i: 0
        min: 12345
        name: regex_infix
        nobind: 1
        r: 1
        rest: ''
        s: 0
    - !!perl/hash:RE_method
      a: 0
      dba: quantified_atom
      i: 0
      min: 12345
      name: atom
      r: 1
      rest: ''
      s: 0
    - !!perl/hash:RE_method
      a: 0
      dba: quantified_atom
      i: 0
      min: 12345
      name: ws
      nobind: 1
      r: 1
      rest: ''
      s: 0
    - !!perl/hash:RE_quantified_atom
      atom: !!perl/hash:RE_bracket
        decl: []
        min: 24690
        re: !!perl/hash:RE_sequence
          a: 0
          dba: quantified_atom
          i: 0
          min: 24690
          r: 1
          s: 0
          zyg:
          - !!perl/hash:RE_method
            a: 0
            dba: quantified_atom
            i: 0
            min: 12345
            name: quantifier
            r: 1
            rest: ''
            s: 0
          - !!perl/hash:RE_method
            a: 0
            dba: quantified_atom
            i: 0
            min: 12345
            name: ws
            nobind: 1
            r: 1
            rest: ''
            s: 0
      min: 0
      quant:
      - '?'
      - ':'
      - ''
      - 0
quantifier__S_559Star: !!perl/hash:RE_ast
  decl: []
  kind: token
  min: 24690
  pkg: ~
  re: !!perl/hash:RE_sequence
    a: 0
    dba: quantifier__S_559Star
    i: 0
    min: 24690
    r: 1
    s: 0
    zyg:
    - !!perl/hash:RE_method
      a: 0
      dba: quantifier__S_559Star
      i: 0
      min: 12345
      name: sym
      r: 1
      rest: ''
      s: 0
      sym: '*'
    - !!perl/hash:RE_method
      a: 0
      dba: quantifier__S_559Star
      i: 0
      min: 12345
      name: quantmod
      r: 1
      rest: ''
      s: 0
quantifier__S_560Plus: !!perl/hash:RE_ast
  decl: []
  kind: token
  min: 24690
  pkg: ~
  re: !!perl/hash:RE_sequence
    a: 0
    dba: quantifier__S_560Plus
    i: 0
    min: 24690
    r: 1
    s: 0
    zyg:
    - !!perl/hash:RE_method
      a: 0
      dba: quantifier__S_560Plus
      i: 0
      min: 12345
      name: sym
      r: 1
      rest: ''
      s: 0
      sym: +
    - !!perl/hash:RE_method
      a: 0
      dba: quantifier__S_560Plus
      i: 0
      min: 12345
      name: quantmod
      r: 1
      rest: ''
      s: 0
quantifier__S_561Question: !!perl/hash:RE_ast
  decl: []
  kind: token
  min: 24690
  pkg: ~
  re: !!perl/hash:RE_sequence
    a: 0
    dba: quantifier__S_561Question
    i: 0
    min: 24690
    r: 1
    s: 0
    zyg:
    - !!perl/hash:RE_method
      a: 0
      dba: quantifier__S_561Question
      i: 0
      min: 12345
      name: sym
      r: 1
      rest: ''
      s: 0
      sym: '?'
    - !!perl/hash:RE_method
      a: 0
      dba: quantifier__S_561Question
      i: 0
      min: 12345
      name: quantmod
      r: 1
      rest: ''
      s: 0
quantifier__S_562StarStar: !!perl/hash:RE_ast
  decl: []
  kind: token
  min: 24691
  pkg: ~
  re: !!perl/hash:RE_sequence
    a: 0
    dba: quantifier__S_562StarStar
    i: 0
    min: 24691
    r: 1
    s: 0
    zyg:
    - !!perl/hash:RE_method
      a: 0
      dba: quantifier__S_562StarStar
      i: 0
      min: 12345
      name: sym
      r: 1
      rest: ''
      s: 0
      sym: '**'
    - !!perl/hash:RE_meta
      a: 0
      dba: quantifier__S_562StarStar
      i: 0
      min: 0
      r: 1
      s: 0
      text: '::'
    - !!perl/hash:RE_quantified_atom
      atom: !!perl/hash:RE_method
        a: 0
        dba: quantifier__S_562StarStar
        i: 0
        min: 12345
        name: normspace
        r: 1
        rest: ''
        s: 0
      min: 0
      quant:
      - '?'
      - ':'
      - ''
      - 0
    - !!perl/hash:RE_method
      a: 0
      dba: quantifier__S_562StarStar
      i: 0
      min: 12345
      name: quantmod
      r: 1
      rest: ''
      s: 0
    - !!perl/hash:RE_quantified_atom
      atom: !!perl/hash:RE_method
        a: 0
        dba: quantifier__S_562StarStar
        i: 0
        min: 12345
        name: normspace
        r: 1
        rest: ''
        s: 0
      min: 0
      quant:
      - '?'
      - ':'
      - ''
      - 0
    - !!perl/hash:RE_bracket
      decl: []
      min: 1
      re: &23 !!perl/hash:RE_any
        a: 0
        altname: quantifier__S_562StarStar_01
        dba: quantifier__S_562StarStar
        i: 0
        min: 1
        name: quantifier__S_562StarStar_01
        r: 1
        s: 0
        zyg:
        - !!perl/hash:RE_sequence
          a: 0
          alt: quantifier__S_562StarStar_01 0
          dba: quantifier__S_562StarStar
          i: 0
          min: 4
          r: 1
          s: 0
          zyg:
          - !!perl/hash:RE_quantified_atom
            atom: !!perl/hash:RE_meta
              a: 0
              dba: quantifier__S_562StarStar
              i: 0
              min: 1
              r: 1
              s: 0
              text: \d
            min: 1
            quant:
            - +
            - ':'
            - ''
            - 1
          - !!perl/hash:RE_quantified_atom
            atom: !!perl/hash:RE_meta
              a: 0
              dba: quantifier__S_562StarStar
              i: 0
              min: 1
              r: 1
              s: 0
              text: \s
            min: 1
            quant:
            - +
            - ':'
            - ''
            - 1
          - !!perl/hash:RE_string
            a: 0
            dba: quantifier__S_562StarStar
            i: 0
            min: 2
            r: 1
            s: 0
            text: ..
          - !!perl/hash:RE_method
            min: 0
            name: panic
            nobind: 1
            rest: ("Spaces not allowed in bare range")
        - !!perl/hash:RE_sequence
          a: 0
          alt: quantifier__S_562StarStar_01 1
          dba: quantifier__S_562StarStar
          i: 0
          min: 1
          r: 1
          s: 0
          zyg:
          - !!perl/hash:RE_quantified_atom
            atom: !!perl/hash:RE_meta
              a: 0
              dba: quantifier__S_562StarStar
              i: 0
              min: 1
              r: 1
              s: 0
              text: \d
            min: 1
            quant:
            - +
            - ':'
            - ''
            - 1
          - !!perl/hash:RE_quantified_atom
            atom: !!perl/hash:RE_bracket
              decl: []
              min: 2
              re: !!perl/hash:RE_sequence
                a: 0
                dba: quantifier__S_562StarStar
                i: 0
                min: 2
                r: 1
                s: 0
                zyg:
                - !!perl/hash:RE_string
                  a: 0
                  dba: quantifier__S_562StarStar
                  i: 0
                  min: 2
                  r: 1
                  s: 0
                  text: ..
                - !!perl/hash:RE_bracket
                  decl: []
                  min: 0
                  re: &24 !!perl/hash:RE_any
                    a: 0
                    altname: quantifier__S_562StarStar_03
                    dba: quantifier__S_562StarStar
                    i: 0
                    min: 0
                    name: quantifier__S_562StarStar_03
                    r: 1
                    s: 0
                    zyg:
                    - !!perl/hash:RE_quantified_atom
                      alt: quantifier__S_562StarStar_03 0
                      atom: !!perl/hash:RE_meta
                        a: 0
                        dba: quantifier__S_562StarStar
                        i: 0
                        min: 1
                        r: 1
                        s: 0
                        text: \d
                      min: 1
                      quant:
                      - +
                      - ':'
                      - ''
                      - 1
                    - !!perl/hash:RE_string
                      a: 0
                      alt: quantifier__S_562StarStar_03 1
                      dba: quantifier__S_562StarStar
                      i: 0
                      min: 1
                      r: 1
                      s: 0
                      text: '*'
                    - !!perl/hash:RE_method
                      alt: quantifier__S_562StarStar_03 2
                      min: 0
                      name: panic
                      nobind: 1
                      rest: ("Malformed range")
            min: 0
            quant:
            - '?'
            - ':'
            - ''
            - 0
        - !!perl/hash:RE_method
          a: 0
          alt: quantifier__S_562StarStar_01 2
          dba: quantifier__S_562StarStar
          i: 0
          min: 12345
          name: embeddedblock
          r: 1
          rest: ''
          s: 0
        - !!perl/hash:RE_method
          a: 0
          alt: quantifier__S_562StarStar_01 3
          dba: quantifier__S_562StarStar
          i: 0
          min: 12345
          name: quantified_atom
          r: 1
          rest: ''
          s: 0
quantifier__S_562StarStar_01: *23
quantifier__S_562StarStar_03: *24
quantifier__S_563TildeTilde: !!perl/hash:RE_ast
  decl: []
  kind: token
  min: 37035
  pkg: ~
  re: !!perl/hash:RE_sequence
    a: 0
    dba: quantifier__S_563TildeTilde
    i: 0
    min: 37035
    r: 1
    s: 0
    zyg:
    - !!perl/hash:RE_bracket
      decl: []
      min: 12345
      re: &25 !!perl/hash:RE_any
        a: 0
        altname: quantifier__S_563TildeTilde_01
        dba: quantifier__S_563TildeTilde
        i: 0
        min: 12345
        name: quantifier__S_563TildeTilde_01
        r: 1
        s: 0
        zyg:
        - !!perl/hash:RE_sequence
          a: 0
          alt: quantifier__S_563TildeTilde_01 0
          dba: quantifier__S_563TildeTilde
          i: 0
          min: 12346
          r: 1
          s: 0
          zyg:
          - !!perl/hash:RE_string
            a: 0
            dba: quantifier__S_563TildeTilde
            i: 0
            min: 1
            r: 1
            s: 0
            text: '!'
          - !!perl/hash:RE_method
            a: 0
            dba: quantifier__S_563TildeTilde
            i: 0
            min: 12345
            name: sym
            r: 1
            rest: ''
            s: 0
            sym: ~~
        - !!perl/hash:RE_method
          a: 0
          alt: quantifier__S_563TildeTilde_01 1
          dba: quantifier__S_563TildeTilde
          i: 0
          min: 12345
          name: sym
          r: 1
          rest: ''
          s: 0
          sym: ~~
    - !!perl/hash:RE_method
      a: 0
      dba: quantifier__S_563TildeTilde
      i: 0
      min: 12345
      name: normspace
      r: 1
      rest: ''
      s: 0
    - !!perl/hash:RE_method
      a: 0
      dba: quantifier__S_563TildeTilde
      i: 0
      min: 12345
      name: quantified_atom
      r: 1
      rest: ''
      s: 0
quantifier__S_563TildeTilde_01: *25
quantmod: !!perl/hash:RE_ast
  decl: []
  kind: token
  min: 0
  pkg: ~
  re: !!perl/hash:RE_sequence
    a: 0
    dba: quantmod
    i: 0
    min: 0
    r: 1
    s: 0
    zyg:
    - !!perl/hash:RE_quantified_atom
      atom: !!perl/hash:RE_string
        a: 0
        dba: quantmod
        i: 0
        min: 1
        r: 1
        s: 0
        text: ':'
      min: 0
      quant:
      - '?'
      - ':'
      - ''
      - 0
    - !!perl/hash:RE_quantified_atom
      atom: !!perl/hash:RE_bracket
        decl: []
        min: 1
        re: &26 !!perl/hash:RE_any
          a: 0
          altname: quantmod_01
          dba: quantmod
          i: 0
          min: 1
          name: quantmod_01
          r: 1
          s: 0
          zyg:
          - !!perl/hash:RE_string
            a: 0
            alt: quantmod_01 0
            dba: quantmod
            i: 0
            min: 1
            r: 1
            s: 0
            text: '?'
          - !!perl/hash:RE_string
            a: 0
            alt: quantmod_01 1
            dba: quantmod
            i: 0
            min: 1
            r: 1
            s: 0
            text: '!'
          - !!perl/hash:RE_string
            a: 0
            alt: quantmod_01 2
            dba: quantmod
            i: 0
            min: 1
            r: 1
            s: 0
            text: +
      min: 0
      quant:
      - '?'
      - ':'
      - ''
      - 0
quantmod_01: *26
regex_infix__S_458VertVert: !!perl/hash:RE_ast
  decl: []
  kind: token
  min: 12345
  pkg: ~
  re: !!perl/hash:RE_sequence
    a: 0
    dba: regex_infix__S_458VertVert
    i: 0
    min: 12345
    r: 1
    s: 0
    zyg:
    - !!perl/hash:RE_method
      a: 0
      dba: regex_infix__S_458VertVert
      i: 0
      min: 12345
      name: sym
      r: 1
      rest: ''
      s: 0
      sym: '||'
    - !!perl/hash:RE_method
      min: 0
      name: O
      rest: (|%tight_or)
regex_infix__S_459AmpAmp: !!perl/hash:RE_ast
  decl: []
  kind: token
  min: 12345
  pkg: ~
  re: !!perl/hash:RE_sequence
    a: 0
    dba: regex_infix__S_459AmpAmp
    i: 0
    min: 12345
    r: 1
    s: 0
    zyg:
    - !!perl/hash:RE_method
      a: 0
      dba: regex_infix__S_459AmpAmp
      i: 0
      min: 12345
      name: sym
      r: 1
      rest: ''
      s: 0
      sym: '&&'
    - !!perl/hash:RE_method
      min: 0
      name: O
      rest: (|%tight_and)
regex_infix__S_460Vert: !!perl/hash:RE_ast
  decl: []
  kind: token
  min: 12345
  pkg: ~
  re: !!perl/hash:RE_sequence
    a: 0
    dba: regex_infix__S_460Vert
    i: 0
    min: 12345
    r: 1
    s: 0
    zyg:
    - !!perl/hash:RE_method
      a: 0
      dba: regex_infix__S_460Vert
      i: 0
      min: 12345
      name: sym
      r: 1
      rest: ''
      s: 0
      sym: '|'
    - !!perl/hash:RE_method
      min: 0
      name: O
      rest: (|%junctive_or)
regex_infix__S_461Amp: !!perl/hash:RE_ast
  decl: []
  kind: token
  min: 12345
  pkg: ~
  re: !!perl/hash:RE_sequence
    a: 0
    dba: regex_infix__S_461Amp
    i: 0
    min: 12345
    r: 1
    s: 0
    zyg:
    - !!perl/hash:RE_method
      a: 0
      dba: regex_infix__S_461Amp
      i: 0
      min: 12345
      name: sym
      r: 1
      rest: ''
      s: 0
      sym: '&'
    - !!perl/hash:RE_method
      min: 0
      name: O
      rest: (|%junctive_and)
regex_infix__S_462Tilde: !!perl/hash:RE_ast
  decl: []
  kind: token
  min: 12345
  pkg: ~
  re: !!perl/hash:RE_sequence
    a: 0
    dba: regex_infix__S_462Tilde
    i: 0
    min: 12345
    r: 1
    s: 0
    zyg:
    - !!perl/hash:RE_method
      a: 0
      dba: regex_infix__S_462Tilde
      i: 0
      min: 12345
      name: sym
      r: 1
      rest: ''
      s: 0
      sym: '~'
    - !!perl/hash:RE_method
      min: 0
      name: O
      rest: (|%additive)
sign: !!perl/hash:RE_ast
  decl: []
  kind: token
  min: 0
  pkg: ~
  re: &27 !!perl/hash:RE_any
    a: 0
    altname: sign_00
    dba: sign
    i: 0
    min: 0
    name: sign_00
    r: 1
    s: 0
    zyg:
    - !!perl/hash:RE_string
      a: 0
      alt: sign_00 0
      dba: sign
      i: 0
      min: 1
      r: 1
      s: 0
      text: +
    - !!perl/hash:RE_string
      a: 0
      alt: sign_00 1
      dba: sign
      i: 0
      min: 1
      r: 1
      s: 0
      text: '-'
    - !!perl/hash:RE_assertion
      alt: sign_00 2
      assert: '?'
      min: 0
      re: !!perl/hash:RE_noop
        a: 0
        dba: sign
        i: 0
        min: 0
        nobind: 1
        r: 1
        s: 0
sign_00: *27
termish: !!perl/hash:RE_ast
  decl: []
  kind: token
  min: 12345
  pkg: ~
  re: !!perl/hash:RE_sequence
    a: 0
    dba: termish
    i: 0
    min: 12345
    r: 1
    s: 0
    zyg:
    - !!perl/hash:RE_method
      a: 0
      dba: termish
      i: 0
      min: 12345
      name: ws
      nobind: 1
      r: 1
      rest: ''
      s: 0
    - !!perl/hash:RE_bracket
      decl: []
      min: 0
      re: !!perl/hash:RE_first
        a: 0
        dba: termish
        i: 0
        min: 0
        r: 1
        s: 0
        zyg:
        - !!perl/hash:RE_bindnamed
          a: 0
          atom: !!perl/hash:RE_method
            a: 0
            dba: termish
            i: 0
            min: 12345
            name: quant_atom_list
            nobind: 1
            r: 1
            rest: ''
            s: 0
          dba: termish
          i: 0
          min: 12345
          r: 1
          s: 0
          var: term
        - !!perl/hash:RE_sequence
          a: 0
          dba: termish
          i: 0
          min: 0
          r: 1
          s: 0
          zyg:
          - !!perl/hash:RE_assertion
            assert: '?'
            min: 0
            re: !!perl/hash:RE_method_re
              a: 0
              dba: termish
              i: 0
              min: 0
              name: before
              nobind: 1
              r: 1
              re: !!perl/hash:RE_ast
                decl: []
                min: 1
                re: &28 !!perl/hash:RE_any
                  a: 0
                  altname: termish_03
                  dba: termish
                  i: 0
                  min: 1
                  name: termish_03
                  r: 1
                  s: 0
                  zyg:
                  - !!perl/hash:RE_method
                    a: 0
                    alt: termish_03 0
                    dba: termish
                    i: 0
                    min: 12345
                    name: stopper
                    r: 1
                    rest: ''
                    s: 0
                  - !!perl/hash:RE_cclass
                    a: 0
                    alt: termish_03 1
                    dba: termish
                    i: 0
                    min: 1
                    r: 1
                    s: 0
                    text: '[&|~]'
              s: 0
          - !!perl/hash:RE_method
            min: 0
            name: panic
            nobind: 1
            rest: ("Null pattern not allowed")
        - !!perl/hash:RE_sequence
          a: 0
          dba: termish
          i: 0
          min: 0
          r: 1
          s: 0
          zyg:
          - !!perl/hash:RE_assertion
            assert: '?'
            min: 0
            re: !!perl/hash:RE_method_re
              a: 0
              dba: termish
              i: 0
              min: 0
              name: before
              nobind: 1
              r: 1
              re: !!perl/hash:RE_ast
                decl: []
                min: 1
                re: !!perl/hash:RE_cclass
                  a: 0
                  dba: termish
                  i: 0
                  min: 1
                  r: 1
                  s: 0
                  text: '[ \] \) \> ]'
              s: 0
          - !!perl/hash:RE_method
            min: 0
            name: panic
            nobind: 1
            rest: ("Unmatched closing bracket")
        - !!perl/hash:RE_method
          min: 0
          name: panic
          nobind: 1
          rest: ("Unrecognized regex metacharacter (must be quoted to match literally)")
termish_03: *28
unsp: !!perl/hash:RE_ast
  decl: []
  kind: token
  min: 1
  pkg: ~
  re: !!perl/hash:RE_sequence
    a: 0
    dba: unsp
    i: 0
    min: 1
    r: 1
    s: 0
    zyg:
    - !!perl/hash:RE_string
      a: 0
      dba: unsp
      i: 0
      min: 1
      r: 1
      s: 0
      text: \
    - !!perl/hash:RE_assertion
      assert: '?'
      min: 0
      re: !!perl/hash:RE_method_re
        a: 0
        dba: unsp
        i: 0
        min: 0
        name: before
        nobind: 1
        r: 1
        re: !!perl/hash:RE_ast
          decl: []
          min: 1
          re: &29 !!perl/hash:RE_any
            a: 0
            altname: unsp_01
            dba: unsp
            i: 0
            min: 1
            name: unsp_01
            r: 1
            s: 0
            zyg:
            - !!perl/hash:RE_meta
              a: 0
              alt: unsp_01 0
              dba: unsp
              i: 0
              min: 1
              r: 1
              s: 0
              text: \s
            - !!perl/hash:RE_string
              a: 0
              alt: unsp_01 1
              dba: unsp
              i: 0
              min: 1
              r: 1
              s: 0
              text: '#'
        s: 0
    - !!perl/hash:RE_method
      min: 0
      name: panic
      nobind: 1
      rest: ("No unspace allowed in regex; if you meant to match the literal character,
        please enclose in single quotes ('" ~ substr($::ORIG,$.pos,1) ~ "') or use
        a backslashed form like \\x" ~ sprintf("%02x", ord(substr($::ORIG,$.pos,1))))
unsp_01: *29
ws: !!perl/hash:RE_ast
  decl: []
  kind: token
  min: 0
  pkg: ~
  re: !!perl/hash:RE_first
    a: 0
    dba: ws
    i: 0
    min: 0
    r: 1
    s: 0
    zyg:
    - !!perl/hash:RE_assertion
      assert: '?'
      min: 0
      re: !!perl/hash:RE_block
        a: 0
        context: bool
        dba: ws
        i: 0
        min: 0
        nobind: 1
        r: 1
        s: 0
        text: ' $*RX<s> '
    - !!perl/hash:RE_quantified_atom
      atom: !!perl/hash:RE_bracket
        decl: []
        min: 12345
        re: !!perl/hash:RE_sequence
          a: 0
          dba: ws
          i: 0
          min: 12345
          r: 1
          s: 0
          zyg:
          - !!perl/hash:RE_assertion
            assert: '?'
            min: 0
            re: !!perl/hash:RE_method_re
              a: 0
              dba: ws
              i: 0
              min: 0
              name: before
              nobind: 1
              r: 1
              re: !!perl/hash:RE_ast
                decl: []
                min: 1
                re: &30 !!perl/hash:RE_any
                  a: 0
                  altname: ws_03
                  dba: ws
                  i: 0
                  min: 1
                  name: ws_03
                  r: 1
                  s: 0
                  zyg:
                  - !!perl/hash:RE_meta
                    a: 0
                    alt: ws_03 0
                    dba: ws
                    i: 0
                    min: 1
                    r: 1
                    s: 0
                    text: \s
                  - !!perl/hash:RE_string
                    a: 0
                    alt: ws_03 1
                    dba: ws
                    i: 0
                    min: 1
                    r: 1
                    s: 0
                    text: '#'
              s: 0
          - !!perl/hash:RE_method
            a: 0
            dba: ws
            i: 0
            min: 12345
            name: nextsame
            nobind: 1
            r: 1
            rest: ''
            s: 0
      min: 0
      quant:
      - '?'
      - ':'
      - ''
      - 0
ws_03: *30
RETREE_END
}
} ## end grammar
## method require_P5
sub require_P5 {
my $self = shift;


require STD_P5;
$self;
}

## method require_P6
sub require_P6 {
my $self = shift;


require STD_P6;
$self;
}

#################
# Symbol tables #
#################

## method newpad ($needsig = 0)
sub newpad {
my $self = shift;
my $needsig = shift() // 0;


my $oid = $::CURPAD->id;
$ALL->{$oid} == $::CURPAD or die "internal error: current pad id is invalid";
my $line = $self->lineof($self->{'_pos'});
my $id;
if ($::NEWPAD) {
$::NEWPAD->{'OUTER::'} = $::CURPAD->idref;
$::CURPAD = $::NEWPAD;
$::NEWPAD = 0;
$id = $::CURPAD->id;
}
else {
$id = 'MY:file<' . $::FILE->{'name'} . '>:line(' . $line . '):pos(' . $self->{'_pos'} . ')';
$::CURPAD = Stash->new(
'OUTER::' => [$oid],
'!file' => $::FILE, '!line' => $line,
'!id' => [$id],
);
}
$::CURPAD->{'!NEEDSIG'} = 1 if $needsig;
$ALL->{$id} = $::CURPAD;
$self;
}

## method finishpad
sub finishpad {
my $self = shift;


my $line = $self->lineof($self->{'_pos'});
$::CURPAD->{'$_'} //= NAME->new( name => '$_', file => $::FILE, line => $line );
$::CURPAD->{'$/'} //= NAME->new( name => '$/', file => $::FILE, line => $line );
$::CURPAD->{'$!'} //= NAME->new( name => '$!', file => $::FILE, line => $line );
$::SIGNUM = 0;
$self;
}

## method getsig
sub getsig {
my $self = shift;


my $pv = $::CURPAD->{'%?PLACEHOLDERS'};
my $sig;
if (delete $::CURPAD->{'!NEEDSIG'}) {
if ($pv) {
my $h_ = delete $pv->{'%_'};
my $a_ = delete $pv->{'@_'};
$sig = join ', ', sort { substr($a,1) cmp substr($b,1) } keys %$pv;
$sig .= ', *@_' if $a_;
$sig .= ', *%_' if $h_;
}
else {
$sig = '$_ is ref = OUTER::<$_>';
}
$::CURPAD->{'$?SIGNATURE'} = $sig;
}
else {
$sig = $::CURPAD->{'$?SIGNATURE'};
}
$self->{'sig'} = $self->makestr(TEXT => $sig);
$self->{'pad'} = $::CURPAD->idref;
$self;
}

## method getdecl
sub getdecl {
my $self = shift;


$self->{'decl'} = $::DECLARAND;
$self;
}

## method is_name ($n, $curpad = $*CURPAD)
sub is_name {
my $self = shift;
my $n = shift;
my $curpad = shift() // $::CURPAD;


my $name = $n;
$self->deb("is_name $name") if $::DEBUG & DEBUG::symtab;

my $curpkg = $::CURPKG;
return 1 if $name =~ qr/\:\:\(/;
my @components = $self->canonicalize_name($name);
if (@components > 1) {
return 1 if $components[0] eq 'COMPILING::';
return 1 if $components[0] eq 'CALLER::';
return 1 if $components[0] eq 'CONTEXT::';
if ($curpkg = $self->find_top_pkg($components[0])) {
$self->deb("Found lexical package ", $components[0]) if $::DEBUG & DEBUG::symtab;
shift @components;
}
else {
$self->deb("Looking for GLOBAL::<$name>") if $::DEBUG & DEBUG::symtab;
$curpkg = $::GLOBAL;
}
while (@components > 1) {
my $pkg = shift @components;
$curpkg = $curpkg->{$pkg};
return 0 unless $curpkg;
eval {
my $outpadid = $curpkg->[0];
return 0 unless $outpadid;
$curpkg = $ALL->{$outpadid};
return 0 unless $curpkg;
};
$self->deb("Found $pkg okay") if $::DEBUG & DEBUG::symtab;
}
}
$name = shift(@components)//'';
$self->deb("Looking for $name") if $::DEBUG & DEBUG::symtab;
return 1 if $name eq '';
my $pad = $curpad;
while ($pad) {
$self->deb("Looking in ", $pad->id) if $::DEBUG & DEBUG::symtab;
if ($pad->{$name}) {
$self->deb("Found $name in ", $pad->id) if $::DEBUG & DEBUG::symtab;
return 1;
}
my $oid = $pad->{'OUTER::'}[0] || last;
$pad = $ALL->{$oid};
}
return 1 if $curpkg->{$name};
return 1 if $::GLOBAL->{$name};
$self->deb("$name not found") if $::DEBUG & DEBUG::symtab;
return 0;
}

## method find_stash ($n, $curpad = $*CURPAD)
sub find_stash {
my $self = shift;
my $n = shift;
my $curpad = shift() // $::CURPAD;


my $name = $n;
$self->deb("find_stash $name") if $::DEBUG & DEBUG::symtab;

return () if $name =~ qr/\:\:\(/;
my @components = $self->canonicalize_name($name);
if (@components > 1) {
return () if $components[0] eq 'COMPILING::';
return () if $components[0] eq 'CALLER::';
return () if $components[0] eq 'CONTEXT::';
if ($curpad = $self->find_top_pkg($components[0])) {
$self->deb("Found lexical package ", $components[0]) if $::DEBUG & DEBUG::symtab;
shift @components;
}
else {
$self->deb("Looking for GLOBAL::<$name>") if $::DEBUG & DEBUG::symtab;
$curpad = $::GLOBAL;
}
while (@components > 1) {
my $pad = shift @components;
$curpad = $curpad->{$pad};
return () unless $curpad;
eval {
my $outpadid = $curpad->[0];
return 0 unless $outpadid;
$curpad = $ALL->{$outpadid};
return () unless $curpad;
};
$self->deb("Found $pad okay") if $::DEBUG & DEBUG::symtab;
}
}
$name = shift(@components)//'';
return $curpad if $name eq '';

my $pad = $curpad;
while ($pad) {
return $_ if $_ = $pad->{$name};
my $oid = $pad->{'OUTER::'}[0] || last;
$pad = $ALL->{$oid};
}
return $_ if $_ = $curpad->{$name};
return $_ if $_ = $::GLOBAL->{$name};
return ();
}

## method find_top_pkg ($name)
sub find_top_pkg {
my $self = shift;
my $name = shift;


$self->deb("find_top_pkg $name") if $::DEBUG & DEBUG::symtab;
$name .= '::' unless $name =~ qr/\:\:$/;
if ($name eq 'OUR::') {
return $::CURPKG;
}
elsif ($name eq 'MY::') {
return $::CURPAD;
}
elsif ($name eq 'OUTER::') {
return $ALL->{$::CURPAD->{'OUTER::'}[0]};
}
elsif ($name eq 'CORE::') {
return $::CORE;
}
elsif ($name eq 'SETTING::') {
return $::SETTING;
}
elsif ($name eq 'UNIT::') {
return $::UNIT;
}
# everything is somewhere in lexical scope (we hope)
my $pad = $::CURPAD;
while ($pad) {
return $pad->{$name} if $pad->{$name};
my $oid = $pad->{'OUTER::'}[0] || last;
$pad = $ALL->{$oid};
}
return 0;
}

## method add_name ($name)
sub add_name {
my $self = shift;
my $name = shift;


my $scope = $::SCOPE || 'my';
my $pkgdecl = $::PKGDECL || 'symbol';
return $self if $scope eq 'anon' or $pkgdecl eq 'slang';
$self->deb("Adding $scope $name") if $::DEBUG & DEBUG::symtab;
if ($scope eq 'augment' or $scope eq 'supersede') {
$self->is_name($name) or
$self->worry("Can't $scope $pkgdecl $name because it doesn't exist");
$::MONKEY_TYPING or
$self->panic("Can't $scope $pkgdecl $name without MONKEY_TYPING");
}
else {
if ($scope eq 'our') {
$self->add_our_name($name);
}
else {
$self->add_my_name($name);
}
}
$self;
}

## method add_my_name ($n, $d = Nil, $p = Nil)
sub add_my_name {
my $self = shift;
my $n = shift;
my $d = shift() // ();
my $p = shift() // ();

# XXX gimme doesn't handle optionals right
my $name = $n;
$self->deb("add_my_name $name in ", $::CURPAD->id) if $::DEBUG & DEBUG::symtab;
return $self if $name =~ qr/\:\:\(/;
my $curstash = $::CURPAD;
my @components = $self->canonicalize_name($name);
my $sid = $curstash->id // '???';
while (@components > 1) {
my $pkg = shift @components;
$sid .= "::$pkg";
my $newstash = $curstash->{$pkg} //= Stash->new(
'PARENT::' => $curstash->idref,
'!stub' => 1,
'!id' => [$sid] );
$self->deb("Adding new package $pkg in ", $curstash->id) if $::DEBUG & DEBUG::symtab;
$curstash = $newstash;
}
$name = my $shortname = shift @components;
return $self unless defined $name and $name ne '';
return $self if $name eq '$' or $name eq '@' or $name eq '%';
if ($shortname =~ qr/\:/) {
$shortname =~ s/\:.*//;
}

# This may just be a lexical alias to "our" and such,
# so reuse $::DECLARAND pointer if it's there.
my $declaring = $d // NAME->new(
xpad => $curstash->idref,
name => $name,
file => $::FILE, line => $self->line,
mult => ($::MULTINESS||'only'),
);
my $old = $curstash->{$name};
if ($old and $old->{'line'} and not $old->{'stub'}) {
$self->deb("$name exists, curstash = ", $curstash->id) if $::DEBUG & DEBUG::symtab;
my $omult = $old->{'mult'} // '';
if ($declaring == $old) {}  # already did this, probably enum
elsif ($::SCOPE eq 'use') {}
elsif ($::MULTINESS eq 'multi' and $omult ne 'only') {}
elsif ($omult eq 'proto') {}
elsif ($::PKGDECL eq 'role') {}
elsif ($::SIGNUM and $old->{'signum'} and $::SIGNUM != $old->{'signum'}) {
$old->{'signum'} = $::SIGNUM;
}
else {
my $ofile = $old->file // 0;
my $oline = $old->line // '???';
my $loc = '';
if ($ofile) {
if ($ofile != $::FILE) {
my $oname = $ofile->{'name'};
$loc = " (see $oname line $oline)";
}
else {
$loc = " (see line $oline)";
}
}
if ($old->opad) {
my $rebind = $old->{'rebind'};
my $truename = $old->{'varbind'}{'truename'};
$self->panic("Lexical symbol '$name' is already bound to an outer symbol$loc;\n  the implicit outer binding at line $rebind must be rewritten as $truename\n  before you can unambiguously declare a new '$name' in this scope");
}
elsif ($name =~ qr/^\w/) {
$self->panic("Illegal redeclaration of symbol '$name'$loc");
}
elsif ($name =~ s/^\&//) {
$self->panic("Illegal redeclaration of routine '$name'$loc") unless $name eq '';
}
else {  # XXX eventually check for conformant arrays here
$self->worry("Useless redeclaration of variable $name$loc");
}
}
}
else {
$::DECLARAND = $curstash->{$name} = $declaring;
$curstash->{$shortname} = $declaring unless $shortname eq $name;
$::DECLARAND->{'inpad'} = $curstash->idref;
$::DECLARAND->{'signum'} = $::SIGNUM if $::SIGNUM;
$::DECLARAND->{'const'} ||= 1 if $::IN_DECL eq 'constant';
if (!$::DECLARAND->{'const'} and $shortname =~ qr/^\w+$/) {
$curstash->{"&$shortname"} //= $curstash->{$shortname};
$sid .= "::$name";
$::NEWPAD = $curstash->{$name . '::'} //= ($p // Stash->new(
'PARENT::' => $curstash->idref,
'!file' => $::FILE, '!line' => $self->line,
'!id' => [$sid] ));
}
}
$self;
}

## method add_our_name ($n)
sub add_our_name {
my $self = shift;
my $n = shift;


my $name = $n;
$self->deb("add_our_name $name in " . $::CURPKG->id) if $::DEBUG & DEBUG::symtab;
return $self if $name =~ qr/\:\:\(/;
my $curstash = $::CURPKG;
$self->deb("curstash $curstash global $::GLOBAL ", join ' ', %$::GLOBAL) if $::DEBUG & DEBUG::symtab;
$name =~ s/\:ver\<.*?\>//;
$name =~ s/\:auth\<.*?\>//;
my @components = $self->canonicalize_name($name);
if (@components > 1) {
my $c = $self->find_top_pkg($components[0]);
if ($c) {
shift @components;
$curstash = $c;
}
}
my $sid = $curstash->id // '???';
while (@components > 1) {
my $pkg = shift @components;
$sid .= "::$pkg";
my $newstash = $curstash->{$pkg} //= Stash->new(
'PARENT::' => $curstash->idref,
'!stub' => 1,
'!id' => [$sid] );
$curstash = $newstash;
$self->deb("Adding new package $pkg in $curstash ") if $::DEBUG & DEBUG::symtab;
}
$name = my $shortname = shift @components;
return $self unless defined $name and $name ne '';
if ($shortname =~ qr/\:/) {
$shortname =~ s/\:.*//;
}

my $declaring = $::DECLARAND // NAME->new(
xpad => $curstash->idref,
name => $name,
file => $::FILE, line => $self->line,
mult => ($::MULTINESS||'only'),
);
my $old = $curstash->{$name};
if ($old and $old->{'line'} and not $old->{'stub'}) {
my $omult = $old->{'mult'} // '';
if ($declaring == $old) {} # already did it somehow
elsif ($::SCOPE eq 'use') {}
elsif ($::MULTINESS eq 'multi' and $omult ne 'only') {}
elsif ($omult eq 'proto') {}
elsif ($::PKGDECL eq 'role') {}
else {
my $ofile = $old->file // 0;
my $oline = $old->line // '???';
my $loc = '';
if ($ofile) {
if ($ofile != $::FILE) {
my $oname = $ofile->{'name'};
$loc = " (from $oname line $oline)";
}
else {
$loc = " (from line $oline)";
}
}
$sid = $self->clean_id($sid, $name);
if ($name =~ qr/^\w/) {
$self->panic("Illegal redeclaration of symbol '$sid'$loc");
}
elsif ($name =~ qr/^\&/) {
$self->panic("Illegal redeclaration of routine '$sid'$loc") unless $name eq '';
}
else {  # XXX eventually check for conformant arrays here
# (redeclaration of identical package vars is not useless)
}
}
}
else {
$::DECLARAND = $curstash->{$name} = $declaring;
$curstash->{$shortname} //= $declaring unless $shortname eq $name;
$::DECLARAND->{'inpkg'} = $curstash->idref;
if ($shortname =~ qr/^\w+$/ and $::IN_DECL ne 'constant') {
$curstash->{"&$shortname"} //= $declaring;
$sid .= "::$name";
$::NEWPKG = $curstash->{$name . '::'} //= Stash->new(
'PARENT::' => $curstash->idref,
'!file' => $::FILE, '!line' => $self->line,
'!id' => [$sid] );
}
}
$self->add_my_name($n, $declaring, $curstash->{$name . '::'}) if $curstash == $::CURPKG;   # the lexical alias
$self;
}

## method add_mystery ($name,$pos,$ctx)
sub add_mystery {
my $self = shift;
my $name = shift;
my $pos = shift;
my $ctx = shift;


return $self if $::IN_PANIC;
if (not $self->is_known($name)) {
$self->deb("add_mystery $name $::CURPAD") if $::DEBUG & DEBUG::symtab;
$::MYSTERY{$name}->{'pad'} = $::CURPAD;
$::MYSTERY{$name}->{'ctx'} = $ctx;
$::MYSTERY{$name}->{'line'} .= ',' if $::MYSTERY{$name}->{'line'};
$::MYSTERY{$name}->{'line'} .= $self->lineof($pos);
}
else {
$self->deb("$name is known") if $::DEBUG & DEBUG::symtab;
}
$self;
}

## method explain_mystery()
sub explain_mystery {
my $self = shift;


my %post_types;
my %unk_types;
my %unk_routines;
my $m = '';
for (keys(%::MYSTERY)) {
my $p = $::MYSTERY{$_}->{'pad'};
if ($self->is_name($_, $p)) {
# types may not be post-declared
$post_types{$_} = $::MYSTERY{$_};
next;
}

next if $self->is_known($_, $p) or $self->is_known('&' . $_, $p);

# just a guess, but good enough to improve error reporting
if ($_ lt 'a') {
$unk_types{$_} = $::MYSTERY{$_};
}
else {
$unk_routines{$_} = $::MYSTERY{$_};
}
}
if (%post_types) {
my @tmp = sort keys(%post_types);
$m .= "Illegally post-declared type" . ('s' x (@tmp != 1)) . ":\n";
for (@tmp) {
$m .= "\t'$_' used at line " . $post_types{$_}->{'line'} . "\n";
}
}
if (%unk_types) {
my @tmp = sort keys(%unk_types);
$m .= "Undeclared name" . ('s' x (@tmp != 1)) . ":\n";
for (@tmp) {
$m .= "\t'$_' used at line " . $unk_types{$_}->{'line'} . "\n";
}
}
if (%unk_routines) {
my @tmp = sort keys(%unk_routines);
$m .= "Undeclared routine" . ('s' x (@tmp != 1)) . ":\n";
for (@tmp) {
$m .= "\t'$_' used at line " . $unk_routines{$_}->{'line'} . "\n";
}
}
$m;
}

## method load_setting ($setting)
sub load_setting {
my $self = shift;
my $setting = shift;


$ALL = $self->load_pad($setting);

$::CORE = $ALL->{'CORE'};
$::CORE->{'!id'} //= ['CORE'];

$::SETTING = $ALL->{'SETTING'};
$::CURPAD = $::SETTING;

$::GLOBAL = $::CORE->{'GLOBAL::'} = Stash->new(
'!file' => $::FILE, '!line' => 1,
'!id' => ['GLOBAL'],
);
$::CURPKG = $::GLOBAL;
}

## method is_known ($n, $curpad = $*CURPAD)
sub is_known {
my $self = shift;
my $n = shift;
my $curpad = shift() // $::CURPAD;


my $name = $n;
$self->deb("is_known $name") if $::DEBUG & DEBUG::symtab;
return 1 if $::QUASIMODO;
return 1 if $::CURPKG->{$name};
return 0 if $name =~ qr/\:\:\(/;
my $curpkg = $::CURPKG;
my @components = $self->canonicalize_name($name);
if (@components > 1) {
return 1 if $components[0] eq 'COMPILING::';
return 1 if $components[0] eq 'CALLER::';
return 1 if $components[0] eq 'CONTEXT::';
if ($curpkg = $self->find_top_pkg($components[0])) {
$self->deb("Found lexical package ", $components[0]) if $::DEBUG & DEBUG::symtab;
shift @components;
}
else {
$self->deb("Looking for GLOBAL::<$name>") if $::DEBUG & DEBUG::symtab;
$curpkg = $::GLOBAL;
}
while (@components > 1) {
my $pkg = shift @components;
$self->deb("Looking for $pkg in $curpkg ", join ' ', keys(%$curpkg)) if $::DEBUG & DEBUG::symtab;
$curpkg = $curpkg->{$pkg};
return 0 unless $curpkg;
eval {
my $outpadid = $curpkg->[0];
return 0 unless $outpadid;
$curpkg = $ALL->{$outpadid};
return 0 unless $curpkg;
};
$self->deb("Found $pkg okay, now in $curpkg ") if $::DEBUG & DEBUG::symtab;
}
}

$name = shift(@components)//'';
$self->deb("Final component is $name") if $::DEBUG & DEBUG::symtab;
return 1 if $name eq '';
if ($curpkg->{$name}) {
$self->deb("Found") if $::DEBUG & DEBUG::symtab;
return 1;
}
# leading components take us non-lexical?  assume we can't know
return 0 if $curpkg != $::CURPKG and $curpkg->{'!id'}[0] =~ qr/^GLOBAL($|\:\:)/;

my $varbind = { truename => '???' };
return 1 if $n !~ qr/\:\:/ and $self->pad_can_find_name($curpad,$name,$varbind);
$self->deb("Not Found") if $::DEBUG & DEBUG::symtab;

return 0;
}

## method pad_can_find_name ($pad, $name, $varbind)
sub pad_can_find_name {
my $self = shift;
my $pad = shift;
my $name = shift;
my $varbind = shift;


$self->deb("Looking in ", $pad->id) if $::DEBUG & DEBUG::symtab;
if ($pad->{$name}) {
$self->deb("Found $name in ", $pad->id) if $::DEBUG & DEBUG::symtab;
return 1;
}

my $outpadid = $pad->{'OUTER::'}[0];
return 0 unless $outpadid;
my $outpad = $ALL->{$outpadid};

if ($self->pad_can_find_name($outpad,$name,$varbind)) {
# fake up an alias to outer symbol to catch reclaration
my $outname = $outpad->{$name}{'name'};
my $outfile = $outpad->{$name}{'file'};
my $outline = $outpad->{$name}{'line'};
$outname = '<' . $outname . '>' unless $outname =~ qr/\:\:\</;
$outname = "OUTER::" . $outname;
$pad->{$name} = NAME->new(
xpad => $pad->idref,
opad => $pad->idref,
name => $outname,
file => $outfile, line => $outline,
rebind => $self->line,
varbind => $varbind,
mult => 'only',
);
# the innermost pad sets this last to get correct # of OUTER::s
$varbind->{'truename'} = $outname;
return 1;
}

return 0;
}

## method add_routine ($name)
sub add_routine {
my $self = shift;
my $name = shift;


my $vname = '&' . $name;
$self->add_name($vname);
$self;
}

## method add_variable ($name)
sub add_variable {
my $self = shift;
my $name = shift;


my $scope = $::SCOPE || 'our';
return $self if $scope eq 'anon';
if ($scope eq 'our') {
$self->add_our_name($name);
}
else {
$self->add_my_name($name);
}
$self;
}

## method add_constant($name,$value)
sub add_constant {
my $self = shift;
my $name = shift;
my $value = shift;


$self->deb("add_constant $name = $value in", $::CURPAD->id) if $::DEBUG & DEBUG::symtab;
local $::DECLARAND;
$self->add_my_name($name);
$::DECLARAND->{'value'} = $value;
$self;
}

## method add_placeholder($name)
sub add_placeholder {
my $self = shift;
my $name = shift;


local $::IN_DECL = 'variable';
if ($::SIGNUM) {
$self->panic("Placeholder variable $name not allowed in signature");
}
elsif (my $siggy = $::CURPAD->{'$?SIGNATURE'}) {
$self->panic("Placeholder variable $name cannot override existing signature $siggy");
}
if (not $::CURPAD->{'!NEEDSIG'}) {
$self->panic("Placeholder variable $name cannot be used in this kind of block");
}
$self->add_my_name($name);
$name =~ s/\^//;
$name = ':' . $name if $name =~ s/\://;
$::CURPAD->{'%?PLACEHOLDERS'}{$name}++;
$self;
}

## method check_variable ($variable)
sub check_variable {
my $self = shift;
my $variable = shift;


my $name = $variable->Str;
$self->deb("check_variable $name") if $::DEBUG & DEBUG::symtab;
my ($sigil, $twigil, $first) = $name =~ qr/(\$|\@|\%|\&)(\W*)(.?)/;
given ($twigil) {
when ('') {
my $ok = 0;
$ok ||= $::IN_DECL;
$ok ||= $sigil eq '&';
$ok ||= $first lt 'A';
$ok ||= $self->is_known($name);
$ok ||= $name =~ qr/.\:\:/ && $name !~ qr/MY|UNIT|OUTER|SETTING|CORE/;
if (not $ok) {
my $id = $name;
$id =~ s/^\W\W?//;
if ($name eq '@_' or $name eq '%_') {
$variable->add_placeholder($name);
}
else {  # guaranteed fail now
if (my $scope = $::MEMOS[$variable->from]{'declend'}) {
$variable->panic("Variable $name is not predeclared (declarators are tighter than comma, so maybe your '$scope' signature needs parens?)");
}
elsif ($id !~ qr/\:\:/) {
if ($self->is_known('@' . $id)) {
$variable->panic("Variable $name is not predeclared (did you mean \@$id?)");
}
elsif ($self->is_known('%' . $id)) {
$variable->panic("Variable $name is not predeclared (did you mean \%$id?)");
}
}
$variable->panic("Variable $name is not predeclared");
}
}
}
when ('^') {
local $::MULTINESS = 'multi';
$variable->add_placeholder($name);
}
when (':') {
local $::MULTINESS = 'multi';
$variable->add_placeholder($name);
}
when ('~') {
return $::LANG{substr($name,2)};
}
when ('?') {
if ($name =~ qr/\:\:/) {
my ($first) = $self->canonicalize_name($name);
$variable->worry("Unrecognized variable: $name") unless $first =~ qr/^(CALLER|CONTEXT|OUTER|MY|SETTING|CORE)$/;
}
else {
# search upward through languages to STD
my $v = $variable->lookup_compiler_var($name);
$variable->{'value'} = $v if $v;
}
}
}
$self;
}

## method lookup_compiler_var($name, $default = Nil)
sub lookup_compiler_var {
my $self = shift;
my $name = shift;
my $default = shift() // ();



# see if they did "constant $?FOO = something" earlier
my $lex = $::CURPAD->{$name};
if (defined $lex) {
if (exists $lex->{'thunk'}) {
return $lex->{'thunk'}->();
}
else {
return $lex->{'value'};
}
}

given ($name) {
when ('$?FILE')     { return $::FILE->{'name'}; }
when ('$?LINE')     { return $self->lineof($self->{'_pos'}); }
when ('$?POSITION') { return $self->{'_pos'}; }

when ('$?LANG')     { return \%::LANG; }

when ('$?LEXPAD')   { return $::CURPAD; }

when ('$?PACKAGE')  { return $::CURPKG; }
when ('$?MODULE')   { return $::CURPKG; } #  XXX should scan
when ('$?CLASS')    { return $::CURPKG; } #  XXX should scan
when ('$?ROLE')     { return $::CURPKG; } #  XXX should scan
when ('$?GRAMMAR')  { return $::CURPKG; } #  XXX should scan

when ('$?PACKAGENAME') { return $::CURPKG->id }

when ('$?OS')       { return 'unimpl'; }
when ('$?DISTRO')   { return 'unimpl'; }
when ('$?VM')       { return 'unimpl'; }
when ('$?XVM')      { return 'unimpl'; }
when ('$?PERL')     { return 'unimpl'; }

when ('$?USAGE')    { return 'unimpl'; }

when ('&?ROUTINE')  { return 'unimpl'; }
when ('&?BLOCK')    { return 'unimpl'; }

when ('%?CONFIG')    { return 'unimpl'; }
when ('%?DEEPMAGIC') { return 'unimpl'; }

my $dynvar = $self->lookup_dynvar($name);
return $dynvar if defined $dynvar;

return $default if defined $default;
# (derived grammars should default to nextsame, terminating here)
default { $self->worry("Unrecognized variable: $name"); return 0; }
}
}

####################
# Service Routines #
####################

## method panic (Str $s)
sub panic {
my $self = shift;
my $s = shift;


my $m;
my $here = $self;

# Have we backed off recently?
my $highvalid = $self->{'_pos'} <= $::HIGHWATER;

$here = $self->cursor($::HIGHWATER) if $highvalid;

my $first = $here->lineof($::LAST_NIBBLE->{'_from'});
my $last = $here->lineof($::LAST_NIBBLE->{'_pos'});
if ($first != $last) {
if ($here->lineof($here->{'_pos'}) == $last) {
$m .= "\n(Possible runaway string from line $first)";
}
else {
$first = $here->lineof($::LAST_NIBBLE_MULTILINE->{'_from'});
$last = $here->lineof($::LAST_NIBBLE_MULTILINE->{'_pos'});
# the bigger the string (in lines), the further back we suspect it
if ($here->lineof($here->{'_pos'}) - $last < $last - $first)  {
$m .= "\n(Possible runaway string from line $first to line $last)";
}
}
}

$m .= "\n" . $s;

if ($highvalid) {
$m .= $::HIGHMESS if $::HIGHMESS;
$::HIGHMESS = $m;
}
else {
# not in backoff, so at "bleeding edge", as it were... therefore probably
# the exception will be caught and re-panicked later, so remember message
$::HIGHMESS .= "\n" . $s;
}

$m .= $here->locmess;

if ($highvalid and %$::HIGHEXPECT) {
my @keys = sort keys %$::HIGHEXPECT;
if (@keys > 1) {
$m .= "\n    expecting any of:\n\t" . join("\n\t", sort keys %$::HIGHEXPECT);
}
else {
$m .= "\n    expecting @keys" unless $keys[0] eq 'whitespace';
}
}
if ($m =~ qr/infix|nofun/ and not $m =~ qr/regex/) {
die "Recursive panic" if $::IN_PANIC;
$::IN_PANIC++;
my @t = eval { $here->termish };
$::IN_PANIC--;
if (@t) {
my $endpos = $here->{'_pos'};
my $startpos = $::MEMOS[$endpos]{'ws'} // $endpos;

if ($self->lineof($startpos) != $self->lineof($endpos)) {
$m =~ s|Confused|Two terms in a row (previous line missing its semicolon?)|;
}
elsif ($::MEMOS[$here->{'_pos'} - 1]{'baremeth'}) {
$m =~ s|Confused|Two terms in a row (method call requires colon or parens to take arguments)|;
}
elsif ($::MEMOS[$here->{'_pos'} - 1]{'arraycomp'}) {
$m =~ s|Confused|Two terms in a row (preceding is not a valid reduce operator)|;
}
else {
$m =~ s|Confused|Two terms in a row|;
}
}
}

if (@::WORRIES) {
$m .= "\nOther potential difficulties:\n  " . join( "\n  ", @::WORRIES);
}
$m .= "\n";
$m .= $self->explain_mystery();

die $Cursor::RED . '===' . $Cursor::CLEAR . 'SORRY!' . $Cursor::RED . '===' . $Cursor::CLEAR . $m;
}

## method worry (Str $s)
sub worry {
my $self = shift;
my $s = shift;


push @::WORRIES, $s . $self->locmess;
$self;
}

## method locmess ()
sub locmess {
my $self = shift;


my $pos = $self->{'_pos'};
my $line = $self->lineof($pos);
if ($pos >= @::MEMOS - 2) {
$pos = @::MEMOS - 3;
$line = ($line - 1) . " (EOF)";
}
my $pre = substr($::ORIG, 0, $pos);
$pre = substr($pre, -40, 40);
1 while $pre =~ s!.*\n!!;
$pre = '<BOL>' if $pre eq '';
my $post = substr($::ORIG, $pos, 40);
1 while $post =~ s!(\n.*)!!;
$post = '<EOL>' if $post eq '';
" at " . $::FILE->{'name'} . " line $line:\n------> " . $Cursor::GREEN . $pre . $Cursor::YELLOW . $::PERL6HERE . $Cursor::RED . 
"$post$Cursor::CLEAR";
}

## method line
sub line {
my $self = shift;


$self->lineof($self->{'_pos'});
}

## method lineof ($p)
sub lineof {
my $self = shift;
my $p = shift;


return 1 unless defined $p;
my $line = $::MEMOS[$p]{'L'};
return $line if $line;
$line = 0;
my $pos = 0;
my @text = split(qr/^/,$::ORIG);   # XXX p5ism, should be ^^
for (@text) {
$line++;
$::MEMOS[$pos++]{'L'} = $line
for 1 .. length($_);
}
$::MEMOS[$pos++]{'L'} = $line;
return $::MEMOS[$p]{'L'} // 0;
}

## method SETGOAL
sub SETGOAL {
my $self = shift;

}
## method FAILGOAL (Str $stop, Str $name)
sub FAILGOAL {
my $self = shift;
my $stop = shift;
my $name = shift;


$self->panic("Unable to parse $name; couldn't find final '$stop'");
}

# "when" arg assumes more things will become obsolete after Perl 6 comes out...
## method obs (Str $old, Str $new, Str $when = ' in Perl 6')
sub obs {
my $self = shift;
my $old = shift;
my $new = shift;
my $when = shift() // ' in Perl 6';


%$::HIGHEXPECT = ();
$self->panic("Unsupported use of $old;$when please use $new");
}

## method worryobs (Str $old, Str $new, Str $when = ' in Perl 6')
sub worryobs {
my $self = shift;
my $old = shift;
my $new = shift;
my $when = shift() // ' in Perl 6';


$self->worry("Unsupported use of $old;$when please use $new");
$self;
}

## method badinfix (Str $bad = $*sym)
sub badinfix {
my $self = shift;
my $bad = shift() // $::sym;


$self->panic("Preceding context expects a term, but found infix $bad instead");
}

# Since most keys are valid prefix operators or terms, this rule is difficult
# to reach ('say +' works), but it's okay as a last-ditch default anyway.
## token term__S_564miscbad (:$*sym = <miscbad>)
##      token term:sym<miscbad> {
##          {} <!{ $*QSIGIL }>
##          {{
##              my ($bad) = try {
##                  $.infixish;
##              };
##              $*HIGHWATER = -1;
##              $*HIGHMESS = '';
##              self.badinfix($bad.Str) if $bad;
##          }}
##          <!>
##      }

sub term__S_564miscbad__PEEK { $_[0]->_AUTOLEXpeek('term__S_564miscbad',$retree) }
sub term__S_564miscbad {
no warnings 'recursion';
my $self = shift;
local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;
my %args = @_;
local $::sym = $args{sym} // q(miscbad);


my $C = $self->cursor_xact("RULE term__S_564miscbad");
my $xact = $C->xact;
my $S = $C->{'_pos'};
$C->{'sym'} = ref $sym ? join(' ', @$sym) : $sym;

$self->_MATCHIFYr($S, "term__S_564miscbad", 
do {
if (my ($C) = (scalar(do {

}, $C))) {
do {
if (my ($C) = ($C->_NOTBEFORE( sub { my $C=shift;
(($C) x !!do {
$::QSIGIL 
})
}))) {
do {
if (my ($C) = (scalar(do {

my ($bad) = eval {
$C->infixish;
};
$::HIGHWATER = -1;
$::HIGHMESS = '';
$self->badinfix($bad->Str) if $bad;

}, $C))) {
$C->_NOTBEFORE( sub { my $C=shift;
$C
});
}
else {
();
}
};
}
else {
();
}
};
}
else {
();
}
}
);
}

## vim: expandtab sw=4 ft=perl6
BEGIN {
$retree = YAML::XS::Load(Encode::encode_utf8(<<'RETREE_END'));
---
alnumint: !!perl/hash:RE_ast
  decl: []
  kind: token
  min: 1
  pkg: ~
  re: !!perl/hash:RE_bracket
    decl: []
    min: 1
    re: !!perl/hash:RE_sequence
      a: 0
      dba: alnumint
      i: 0
      min: 1
      r: 1
      s: 0
      zyg:
      - !!perl/hash:RE_quantified_atom
        atom: !!perl/hash:RE_cclass
          a: 0
          dba: alnumint
          i: 0
          min: 1
          r: 1
          s: 0
          text: '[ 0..9 a..z A..Z ]'
        min: 1
        quant:
        - +
        - ':'
        - ''
        - 1
      - !!perl/hash:RE_quantified_atom
        atom: !!perl/hash:RE_bracket
          decl: []
          min: 2
          re: !!perl/hash:RE_sequence
            a: 0
            dba: alnumint
            i: 0
            min: 2
            r: 1
            s: 0
            zyg:
            - !!perl/hash:RE_string
              a: 0
              dba: alnumint
              i: 0
              min: 1
              r: 1
              s: 0
              text: _
            - !!perl/hash:RE_quantified_atom
              atom: !!perl/hash:RE_cclass
                a: 0
                dba: alnumint
                i: 0
                min: 1
                r: 1
                s: 0
                text: '[ 0..9 a..z A..Z ]'
              min: 1
              quant:
              - +
              - ':'
              - ''
              - 1
        min: 0
        quant:
        - '*'
        - ':'
        - ''
        - 0
apostrophe: !!perl/hash:RE_ast
  decl: []
  kind: token
  min: 1
  pkg: ~
  re: !!perl/hash:RE_cclass
    a: 0
    dba: apostrophe
    i: 0
    min: 1
    r: 1
    s: 0
    text: '[ '' \- ]'
babble: !!perl/hash:RE_ast
  decl:
  - !!perl/hash:RE_decl
    a: 0
    dba: babble
    i: 0
    max: 0
    min: 0
    r: 1
    s: 0
    text: my $lang = $l
  - !!perl/hash:RE_decl
    a: 0
    dba: babble
    i: 0
    max: 0
    min: 0
    r: 1
    s: 0
    text: my $start
  - !!perl/hash:RE_decl
    a: 0
    dba: babble
    i: 0
    max: 0
    min: 0
    r: 1
    s: 0
    text: my $stop
  kind: token
  min: 12345
  pkg: ~
  re: !!perl/hash:RE_sequence
    a: 0
    dba: babble
    i: 0
    min: 12345
    r: 1
    s: 0
    zyg:
    - !!perl/hash:RE_method
      a: 0
      dba: babble
      i: 0
      min: 12345
      name: ws
      nobind: 1
      r: 1
      rest: ''
      s: 0
    - !!perl/hash:RE_quantified_atom
      atom: !!perl/hash:RE_bracket
        decl: []
        min: 24690
        re: !!perl/hash:RE_sequence
          a: 0
          dba: babble
          i: 0
          min: 24690
          r: 1
          s: 0
          zyg:
          - !!perl/hash:RE_method
            a: 0
            dba: babble
            i: 0
            min: 12345
            name: quotepair
            r: 1
            rest: ''
            s: 0
          - !!perl/hash:RE_method
            a: 0
            dba: babble
            i: 0
            min: 12345
            name: ws
            nobind: 1
            r: 1
            rest: ''
            s: 0
          - !!perl/hash:RE_block
            a: 0
            context: void
            dba: babble
            i: 0
            min: 0
            r: 1
            s: 0
            text: "\n            my $kv = $<quotepair>[*-1];\n            $lang =
              $lang.tweak($kv.<k>, $kv.<v>)\n                or self.panic(\"Unrecognized
              adverb :\" ~ $kv.<k> ~ '(' ~ $kv.<v> ~ ')');\n        "
      min: 0
      quant:
      - '*'
      - ':'
      - ''
      - 0
    - !!perl/hash:RE_block
      a: 0
      context: void
      dba: babble
      i: 0
      min: 0
      r: 1
      s: 0
      text: "\n        ($start,$stop) = $.peek_delimiters();\n        $lang = $start
        ne $stop ?? $lang.balanced($start,$stop)\n                                !!
        $lang.unbalanced($stop);\n        $<B> = [$lang,$start,$stop];\n    "
begid: !!perl/hash:RE_ast
  decl: []
  kind: token
  min: 0
  pkg: ~
  re: !!perl/hash:RE_assertion
    assert: '?'
    min: 0
    re: !!perl/hash:RE_method_re
      a: 0
      dba: begid
      i: 0
      min: 0
      name: before
      nobind: 1
      r: 1
      re: !!perl/hash:RE_ast
        decl: []
        min: 1
        re: !!perl/hash:RE_meta
          a: 0
          dba: begid
          i: 0
          min: 1
          r: 1
          s: 0
          text: \w
      s: 0
binint: !!perl/hash:RE_ast
  decl: []
  kind: token
  min: 1
  pkg: ~
  re: !!perl/hash:RE_sequence
    a: 0
    dba: binint
    i: 0
    min: 1
    r: 1
    s: 0
    zyg:
    - !!perl/hash:RE_quantified_atom
      atom: !!perl/hash:RE_cclass
        a: 0
        dba: binint
        i: 0
        min: 1
        r: 1
        s: 0
        text: '[ 0..1 ]'
      min: 1
      quant:
      - +
      - ':'
      - ''
      - 1
    - !!perl/hash:RE_quantified_atom
      atom: !!perl/hash:RE_bracket
        decl: []
        min: 2
        re: !!perl/hash:RE_sequence
          a: 0
          dba: binint
          i: 0
          min: 2
          r: 1
          s: 0
          zyg:
          - !!perl/hash:RE_string
            a: 0
            dba: binint
            i: 0
            min: 1
            r: 1
            s: 0
            text: _
          - !!perl/hash:RE_quantified_atom
            atom: !!perl/hash:RE_cclass
              a: 0
              dba: binint
              i: 0
              min: 1
              r: 1
              s: 0
              text: '[ 0..1 ]'
            min: 1
            quant:
            - +
            - ':'
            - ''
            - 1
      min: 0
      quant:
      - '*'
      - ':'
      - ''
      - 0
binints: !!perl/hash:RE_ast
  decl: []
  kind: token
  min: 37035
  pkg: ~
  re: !!perl/hash:RE_quantified_atom
    atom: !!perl/hash:RE_bracket
      decl: []
      min: 37035
      re: !!perl/hash:RE_sequence
        a: 0
        dba: binints
        i: 0
        min: 37035
        r: 1
        s: 0
        zyg:
        - !!perl/hash:RE_method
          a: 0
          dba: binints
          i: 0
          min: 12345
          name: ws
          nobind: 1
          r: 1
          rest: ''
          s: 0
        - !!perl/hash:RE_method
          a: 0
          dba: binints
          i: 0
          min: 12345
          name: binint
          r: 1
          rest: ''
          s: 0
        - !!perl/hash:RE_method
          a: 0
          dba: binints
          i: 0
          min: 12345
          name: ws
          nobind: 1
          r: 1
          rest: ''
          s: 0
    min: 37035
    quant:
    - '**'
    - ':'
    - !!perl/hash:RE_string
      a: 0
      dba: binints
      i: 0
      min: 1
      r: 1
      s: 0
      text: ','
    - 1
category__S_000category: !!perl/hash:RE_ast
  decl: []
  kind: token
  min: 12345
  pkg: ~
  re: !!perl/hash:RE_method
    a: 0
    dba: category__S_000category
    i: 0
    min: 12345
    name: sym
    r: 1
    rest: ''
    s: 0
    sym: category
category__S_001sigil: !!perl/hash:RE_ast
  decl: []
  kind: token
  min: 12345
  pkg: ~
  re: !!perl/hash:RE_method
    a: 0
    dba: category__S_001sigil
    i: 0
    min: 12345
    name: sym
    r: 1
    rest: ''
    s: 0
    sym: sigil
category__S_002twigil: !!perl/hash:RE_ast
  decl: []
  kind: token
  min: 12345
  pkg: ~
  re: !!perl/hash:RE_method
    a: 0
    dba: category__S_002twigil
    i: 0
    min: 12345
    name: sym
    r: 1
    rest: ''
    s: 0
    sym: twigil
category__S_003special_variable: !!perl/hash:RE_ast
  decl: []
  kind: token
  min: 12345
  pkg: ~
  re: !!perl/hash:RE_method
    a: 0
    dba: category__S_003special_variable
    i: 0
    min: 12345
    name: sym
    r: 1
    rest: ''
    s: 0
    sym: special_variable
category__S_004comment: !!perl/hash:RE_ast
  decl: []
  kind: token
  min: 12345
  pkg: ~
  re: !!perl/hash:RE_method
    a: 0
    dba: category__S_004comment
    i: 0
    min: 12345
    name: sym
    r: 1
    rest: ''
    s: 0
    sym: comment
category__S_005version: !!perl/hash:RE_ast
  decl: []
  kind: token
  min: 12345
  pkg: ~
  re: !!perl/hash:RE_method
    a: 0
    dba: category__S_005version
    i: 0
    min: 12345
    name: sym
    r: 1
    rest: ''
    s: 0
    sym: version
category__S_006module_name: !!perl/hash:RE_ast
  decl: []
  kind: token
  min: 12345
  pkg: ~
  re: !!perl/hash:RE_method
    a: 0
    dba: category__S_006module_name
    i: 0
    min: 12345
    name: sym
    r: 1
    rest: ''
    s: 0
    sym: module_name
category__S_007value: !!perl/hash:RE_ast
  decl: []
  kind: token
  min: 12345
  pkg: ~
  re: !!perl/hash:RE_method
    a: 0
    dba: category__S_007value
    i: 0
    min: 12345
    name: sym
    r: 1
    rest: ''
    s: 0
    sym: value
category__S_008term: !!perl/hash:RE_ast
  decl: []
  kind: token
  min: 12345
  pkg: ~
  re: !!perl/hash:RE_method
    a: 0
    dba: category__S_008term
    i: 0
    min: 12345
    name: sym
    r: 1
    rest: ''
    s: 0
    sym: term
category__S_009strtonum: !!perl/hash:RE_ast
  decl: []
  kind: token
  min: 12345
  pkg: ~
  re: !!perl/hash:RE_method
    a: 0
    dba: category__S_009strtonum
    i: 0
    min: 12345
    name: sym
    r: 1
    rest: ''
    s: 0
    sym: strtonum
category__S_010quote: !!perl/hash:RE_ast
  decl: []
  kind: token
  min: 12345
  pkg: ~
  re: !!perl/hash:RE_method
    a: 0
    dba: category__S_010quote
    i: 0
    min: 12345
    name: sym
    r: 1
    rest: ''
    s: 0
    sym: quote
category__S_011prefix: !!perl/hash:RE_ast
  decl: []
  kind: token
  min: 12345
  pkg: ~
  re: !!perl/hash:RE_method
    a: 0
    dba: category__S_011prefix
    i: 0
    min: 12345
    name: sym
    r: 1
    rest: ''
    s: 0
    sym: prefix
category__S_012infix: !!perl/hash:RE_ast
  decl: []
  kind: token
  min: 12345
  pkg: ~
  re: !!perl/hash:RE_method
    a: 0
    dba: category__S_012infix
    i: 0
    min: 12345
    name: sym
    r: 1
    rest: ''
    s: 0
    sym: infix
category__S_013postfix: !!perl/hash:RE_ast
  decl: []
  kind: token
  min: 12345
  pkg: ~
  re: !!perl/hash:RE_method
    a: 0
    dba: category__S_013postfix
    i: 0
    min: 12345
    name: sym
    r: 1
    rest: ''
    s: 0
    sym: postfix
category__S_014dotty: !!perl/hash:RE_ast
  decl: []
  kind: token
  min: 12345
  pkg: ~
  re: !!perl/hash:RE_method
    a: 0
    dba: category__S_014dotty
    i: 0
    min: 12345
    name: sym
    r: 1
    rest: ''
    s: 0
    sym: dotty
category__S_015circumfix: !!perl/hash:RE_ast
  decl: []
  kind: token
  min: 12345
  pkg: ~
  re: !!perl/hash:RE_method
    a: 0
    dba: category__S_015circumfix
    i: 0
    min: 12345
    name: sym
    r: 1
    rest: ''
    s: 0
    sym: circumfix
category__S_016postcircumfix: !!perl/hash:RE_ast
  decl: []
  kind: token
  min: 12345
  pkg: ~
  re: !!perl/hash:RE_method
    a: 0
    dba: category__S_016postcircumfix
    i: 0
    min: 12345
    name: sym
    r: 1
    rest: ''
    s: 0
    sym: postcircumfix
category__S_017quote_mod: !!perl/hash:RE_ast
  decl: []
  kind: token
  min: 12345
  pkg: ~
  re: !!perl/hash:RE_method
    a: 0
    dba: category__S_017quote_mod
    i: 0
    min: 12345
    name: sym
    r: 1
    rest: ''
    s: 0
    sym: quote_mod
category__S_018trait_mod: !!perl/hash:RE_ast
  decl: []
  kind: token
  min: 12345
  pkg: ~
  re: !!perl/hash:RE_method
    a: 0
    dba: category__S_018trait_mod
    i: 0
    min: 12345
    name: sym
    r: 1
    rest: ''
    s: 0
    sym: trait_mod
category__S_019type_declarator: !!perl/hash:RE_ast
  decl: []
  kind: token
  min: 12345
  pkg: ~
  re: !!perl/hash:RE_method
    a: 0
    dba: category__S_019type_declarator
    i: 0
    min: 12345
    name: sym
    r: 1
    rest: ''
    s: 0
    sym: type_declarator
category__S_020scope_declarator: !!perl/hash:RE_ast
  decl: []
  kind: token
  min: 12345
  pkg: ~
  re: !!perl/hash:RE_method
    a: 0
    dba: category__S_020scope_declarator
    i: 0
    min: 12345
    name: sym
    r: 1
    rest: ''
    s: 0
    sym: scope_declarator
category__S_021package_declarator: !!perl/hash:RE_ast
  decl: []
  kind: token
  min: 12345
  pkg: ~
  re: !!perl/hash:RE_method
    a: 0
    dba: category__S_021package_declarator
    i: 0
    min: 12345
    name: sym
    r: 1
    rest: ''
    s: 0
    sym: package_declarator
category__S_022multi_declarator: !!perl/hash:RE_ast
  decl: []
  kind: token
  min: 12345
  pkg: ~
  re: !!perl/hash:RE_method
    a: 0
    dba: category__S_022multi_declarator
    i: 0
    min: 12345
    name: sym
    r: 1
    rest: ''
    s: 0
    sym: multi_declarator
category__S_023routine_declarator: !!perl/hash:RE_ast
  decl: []
  kind: token
  min: 12345
  pkg: ~
  re: !!perl/hash:RE_method
    a: 0
    dba: category__S_023routine_declarator
    i: 0
    min: 12345
    name: sym
    r: 1
    rest: ''
    s: 0
    sym: routine_declarator
category__S_024regex_declarator: !!perl/hash:RE_ast
  decl: []
  kind: token
  min: 12345
  pkg: ~
  re: !!perl/hash:RE_method
    a: 0
    dba: category__S_024regex_declarator
    i: 0
    min: 12345
    name: sym
    r: 1
    rest: ''
    s: 0
    sym: regex_declarator
category__S_025statement_prefix: !!perl/hash:RE_ast
  decl: []
  kind: token
  min: 12345
  pkg: ~
  re: !!perl/hash:RE_method
    a: 0
    dba: category__S_025statement_prefix
    i: 0
    min: 12345
    name: sym
    r: 1
    rest: ''
    s: 0
    sym: statement_prefix
category__S_026statement_control: !!perl/hash:RE_ast
  decl: []
  kind: token
  min: 12345
  pkg: ~
  re: !!perl/hash:RE_method
    a: 0
    dba: category__S_026statement_control
    i: 0
    min: 12345
    name: sym
    r: 1
    rest: ''
    s: 0
    sym: statement_control
category__S_027statement_mod_cond: !!perl/hash:RE_ast
  decl: []
  kind: token
  min: 12345
  pkg: ~
  re: !!perl/hash:RE_method
    a: 0
    dba: category__S_027statement_mod_cond
    i: 0
    min: 12345
    name: sym
    r: 1
    rest: ''
    s: 0
    sym: statement_mod_cond
category__S_028statement_mod_loop: !!perl/hash:RE_ast
  decl: []
  kind: token
  min: 12345
  pkg: ~
  re: !!perl/hash:RE_method
    a: 0
    dba: category__S_028statement_mod_loop
    i: 0
    min: 12345
    name: sym
    r: 1
    rest: ''
    s: 0
    sym: statement_mod_loop
category__S_029infix_prefix_meta_operator: !!perl/hash:RE_ast
  decl: []
  kind: token
  min: 12345
  pkg: ~
  re: !!perl/hash:RE_method
    a: 0
    dba: category__S_029infix_prefix_meta_operator
    i: 0
    min: 12345
    name: sym
    r: 1
    rest: ''
    s: 0
    sym: infix_prefix_meta_operator
category__S_030infix_postfix_meta_operator: !!perl/hash:RE_ast
  decl: []
  kind: token
  min: 12345
  pkg: ~
  re: !!perl/hash:RE_method
    a: 0
    dba: category__S_030infix_postfix_meta_operator
    i: 0
    min: 12345
    name: sym
    r: 1
    rest: ''
    s: 0
    sym: infix_postfix_meta_operator
category__S_031infix_circumfix_meta_operator: !!perl/hash:RE_ast
  decl: []
  kind: token
  min: 12345
  pkg: ~
  re: !!perl/hash:RE_method
    a: 0
    dba: category__S_031infix_circumfix_meta_operator
    i: 0
    min: 12345
    name: sym
    r: 1
    rest: ''
    s: 0
    sym: infix_circumfix_meta_operator
category__S_032postfix_prefix_meta_operator: !!perl/hash:RE_ast
  decl: []
  kind: token
  min: 12345
  pkg: ~
  re: !!perl/hash:RE_method
    a: 0
    dba: category__S_032postfix_prefix_meta_operator
    i: 0
    min: 12345
    name: sym
    r: 1
    rest: ''
    s: 0
    sym: postfix_prefix_meta_operator
category__S_033prefix_postfix_meta_operator: !!perl/hash:RE_ast
  decl: []
  kind: token
  min: 12345
  pkg: ~
  re: !!perl/hash:RE_method
    a: 0
    dba: category__S_033prefix_postfix_meta_operator
    i: 0
    min: 12345
    name: sym
    r: 1
    rest: ''
    s: 0
    sym: prefix_postfix_meta_operator
category__S_034prefix_circumfix_meta_operator: !!perl/hash:RE_ast
  decl: []
  kind: token
  min: 12345
  pkg: ~
  re: !!perl/hash:RE_method
    a: 0
    dba: category__S_034prefix_circumfix_meta_operator
    i: 0
    min: 12345
    name: sym
    r: 1
    rest: ''
    s: 0
    sym: prefix_circumfix_meta_operator
category__S_035terminator: !!perl/hash:RE_ast
  decl: []
  kind: token
  min: 12345
  pkg: ~
  re: !!perl/hash:RE_method
    a: 0
    dba: category__S_035terminator
    i: 0
    min: 12345
    name: sym
    r: 1
    rest: ''
    s: 0
    sym: terminator
charname: !!perl/hash:RE_ast
  decl: []
  kind: token
  min: 0
  pkg: ~
  re: !!perl/hash:RE_first
    a: 0
    dba: charname
    i: 0
    min: 0
    r: 1
    s: 0
    zyg:
    - !!perl/hash:RE_bracket
      decl: []
      min: 2
      re: &1 !!perl/hash:RE_any
        a: 0
        altname: charname_01
        dba: charname
        i: 0
        min: 2
        name: charname_01
        r: 1
        s: 0
        zyg:
        - !!perl/hash:RE_method
          a: 0
          alt: charname_01 0
          dba: charname
          i: 0
          min: 12345
          name: radint
          r: 1
          rest: ''
          s: 0
        - !!perl/hash:RE_sequence
          a: 0
          alt: charname_01 1
          dba: charname
          i: 0
          min: 2
          r: 1
          s: 0
          zyg:
          - !!perl/hash:RE_cclass
            a: 0
            dba: charname
            i: 0
            min: 1
            r: 1
            s: 0
            text: '[a..z A..Z]'
          - !!perl/hash:RE_quantified_atom
            atom: !!perl/hash:RE_cclass
              a: 0
              dba: charname
              i: 0
              min: 1
              r: 1
              s: 0
              text: '-[ \] , # ]'
            min: 0
            quant:
            - '*'
            - '?'
            - ''
            - 0
          - !!perl/hash:RE_cclass
            a: 0
            dba: charname
            i: 0
            min: 1
            r: 1
            s: 0
            text: '[a..z A..Z ) ]'
          - !!perl/hash:RE_assertion
            assert: '?'
            min: 0
            re: !!perl/hash:RE_method_re
              a: 0
              dba: charname
              i: 0
              min: 0
              name: before
              nobind: 1
              r: 1
              re: !!perl/hash:RE_ast
                decl: []
                min: 1
                re: !!perl/hash:RE_sequence
                  a: 0
                  dba: charname
                  i: 0
                  min: 1
                  r: 1
                  s: 0
                  zyg:
                  - !!perl/hash:RE_quantified_atom
                    atom: !!perl/hash:RE_meta
                      a: 0
                      dba: charname
                      i: 0
                      min: 1
                      r: 1
                      s: 0
                      text: \s
                    min: 0
                    quant:
                    - '*'
                    - ':'
                    - ''
                    - 0
                  - !!perl/hash:RE_cclass
                    a: 0
                    dba: charname
                    i: 0
                    min: 1
                    r: 1
                    s: 0
                    text: '[ \] , # ]'
              s: 0
    - !!perl/hash:RE_method
      min: 0
      name: panic
      nobind: 1
      rest: ("Unrecognized character name")
charname_01: *1
charnames: !!perl/hash:RE_ast
  decl: []
  kind: token
  min: 37035
  pkg: ~
  re: !!perl/hash:RE_quantified_atom
    atom: !!perl/hash:RE_bracket
      decl: []
      min: 37035
      re: !!perl/hash:RE_sequence
        a: 0
        dba: charnames
        i: 0
        min: 37035
        r: 1
        s: 0
        zyg:
        - !!perl/hash:RE_method
          a: 0
          dba: charnames
          i: 0
          min: 12345
          name: ws
          nobind: 1
          r: 1
          rest: ''
          s: 0
        - !!perl/hash:RE_method
          a: 0
          dba: charnames
          i: 0
          min: 12345
          name: charname
          r: 1
          rest: ''
          s: 0
        - !!perl/hash:RE_method
          a: 0
          dba: charnames
          i: 0
          min: 12345
          name: ws
          nobind: 1
          r: 1
          rest: ''
          s: 0
    min: 37035
    quant:
    - '**'
    - ':'
    - !!perl/hash:RE_string
      a: 0
      dba: charnames
      i: 0
      min: 1
      r: 1
      s: 0
      text: ','
    - 1
charspec: !!perl/hash:RE_ast
  decl: []
  kind: token
  min: 0
  pkg: ~
  re: !!perl/hash:RE_bracket
    decl: []
    min: 0
    re: &2 !!perl/hash:RE_any
      a: 0
      altname: charspec_01
      dba: character name
      i: 0
      min: 0
      name: charspec_01
      r: 1
      s: 0
      zyg:
      - !!perl/hash:RE_sequence
        a: 0
        alt: charspec_01 0
        dba: character name
        i: 0
        min: 12347
        r: 1
        s: 0
        zyg:
        - !!perl/hash:RE_string
          a: 0
          dba: character name
          i: 0
          min: 1
          r: 1
          s: 0
          text: '['
        - !!perl/hash:RE_meta
          a: 0
          dba: character name
          extra: 'local $::GOAL = '']'' '
          i: 0
          min: 0
          r: 1
          s: 0
          text: ':'
        - !!perl/hash:RE_method
          a: 0
          dba: character name
          i: 0
          min: 12345
          name: charnames
          r: 1
          rest: ''
          s: 0
        - !!perl/hash:RE_bracket
          decl: []
          min: 1
          re: !!perl/hash:RE_first
            a: 0
            dba: character name
            i: 0
            min: 1
            r: 1
            s: 0
            zyg:
            - !!perl/hash:RE_string
              a: 0
              dba: character name
              i: 0
              min: 1
              r: 1
              s: 0
              text: ']'
            - !!perl/hash:RE_method
              min: 0
              name: FAILGOAL
              nobind: 1
              rest: (']' , 'character name')
      - !!perl/hash:RE_quantified_atom
        alt: charspec_01 1
        atom: !!perl/hash:RE_meta
          a: 0
          dba: character name
          i: 0
          min: 1
          r: 1
          s: 0
          text: \d
        min: 1
        quant:
        - +
        - ':'
        - ''
        - 1
      - !!perl/hash:RE_cclass
        a: 0
        alt: charspec_01 2
        dba: character name
        i: 0
        min: 1
        r: 1
        s: 0
        text: '[ ?..Z \\.._ ]'
      - !!perl/hash:RE_sequence
        a: 0
        alt: charspec_01 3
        dba: character name
        i: 0
        min: 0
        r: 1
        s: 0
        zyg:
        - !!perl/hash:RE_assertion
          assert: '?'
          min: 0
          re: !!perl/hash:RE_noop
            a: 0
            dba: character name
            i: 0
            min: 0
            nobind: 1
            r: 1
            s: 0
        - !!perl/hash:RE_method
          min: 0
          name: panic
          nobind: 1
          rest: ("Unrecognized \\c character")
charspec_01: *2
circumfix__S_051Fre_Nch: !!perl/hash:RE_ast
  decl: []
  kind: token
  min: 2
  pkg: ~
  re: !!perl/hash:RE_sequence
    a: 0
    dba: circumfix__S_051Fre_Nch
    i: 0
    min: 2
    r: 1
    s: 0
    zyg:
    - !!perl/hash:RE_string
      a: 0
      dba: circumfix__S_051Fre_Nch
      i: 0
      min: 1
      r: 1
      s: 0
      text: 
    - !!perl/hash:RE_method
      min: 0
      name: nibble
      rest: ($.cursor_fresh( %*LANG<Q> ).tweak(:qq).tweak(:ww).balanced('',''))
    - !!perl/hash:RE_string
      a: 0
      dba: circumfix__S_051Fre_Nch
      i: 0
      min: 1
      r: 1
      s: 0
      text: 
circumfix__S_052LtLt_GtGt: !!perl/hash:RE_ast
  decl: []
  kind: token
  min: 4
  pkg: ~
  re: !!perl/hash:RE_sequence
    a: 0
    dba: circumfix__S_052LtLt_GtGt
    i: 0
    min: 4
    r: 1
    s: 0
    zyg:
    - !!perl/hash:RE_string
      a: 0
      dba: circumfix__S_052LtLt_GtGt
      i: 0
      min: 2
      r: 1
      s: 0
      text: <<
    - !!perl/hash:RE_method
      min: 0
      name: nibble
      rest: ($.cursor_fresh( %*LANG<Q> ).tweak(:qq).tweak(:ww).balanced('<<','>>'))
    - !!perl/hash:RE_string
      a: 0
      dba: circumfix__S_052LtLt_GtGt
      i: 0
      min: 2
      r: 1
      s: 0
      text: '>>'
circumfix__S_053Lt_Gt: !!perl/hash:RE_ast
  decl: []
  kind: token
  min: 2
  pkg: ~
  re: !!perl/hash:RE_sequence
    a: 0
    dba: circumfix__S_053Lt_Gt
    i: 0
    min: 2
    r: 1
    s: 0
    zyg:
    - !!perl/hash:RE_string
      a: 0
      dba: circumfix__S_053Lt_Gt
      i: 0
      min: 1
      r: 1
      s: 0
      text: <
    - !!perl/hash:RE_quantified_atom
      atom: !!perl/hash:RE_bracket
        decl: []
        min: 0
        re: !!perl/hash:RE_sequence
          a: 0
          dba: circumfix__S_053Lt_Gt
          i: 0
          min: 0
          r: 1
          s: 0
          zyg:
          - !!perl/hash:RE_assertion
            assert: '?'
            min: 0
            re: !!perl/hash:RE_method_re
              a: 0
              dba: circumfix__S_053Lt_Gt
              i: 0
              min: 0
              name: before
              nobind: 1
              r: 1
              re: !!perl/hash:RE_ast
                decl: []
                min: 6
                re: !!perl/hash:RE_string
                  a: 0
                  dba: circumfix__S_053Lt_Gt
                  i: 0
                  min: 6
                  r: 1
                  s: 0
                  text: STDIN>
              s: 0
          - !!perl/hash:RE_method
            min: 0
            name: obs
            nobind: 1
            rest: ('<STDIN>', '$' ~ '*IN.lines')
      min: 0
      quant:
      - '?'
      - ':'
      - ''
      - 0
    - !!perl/hash:RE_quantified_atom
      atom: !!perl/hash:RE_bracket
        decl: []
        min: 0
        re: !!perl/hash:RE_sequence
          a: 0
          dba: circumfix__S_053Lt_Gt
          i: 0
          min: 0
          r: 1
          s: 0
          zyg:
          - !!perl/hash:RE_assertion
            assert: '?'
            min: 0
            re: !!perl/hash:RE_method_re
              a: 0
              dba: circumfix__S_053Lt_Gt
              i: 0
              min: 0
              name: before
              nobind: 1
              r: 1
              re: !!perl/hash:RE_ast
                decl: []
                min: 1
                re: !!perl/hash:RE_string
                  a: 0
                  dba: circumfix__S_053Lt_Gt
                  i: 0
                  min: 1
                  r: 1
                  s: 0
                  text: '>'
              s: 0
          - !!perl/hash:RE_method
            min: 0
            name: obs
            nobind: 1
            rest: ('<>', 'lines() or ()')
      min: 0
      quant:
      - '?'
      - ':'
      - ''
      - 0
    - !!perl/hash:RE_method
      min: 0
      name: nibble
      rest: ($.cursor_fresh( %*LANG<Q> ).tweak(:q).tweak(:w).balanced('<','>'))
    - !!perl/hash:RE_string
      a: 0
      dba: circumfix__S_053Lt_Gt
      i: 0
      min: 1
      r: 1
      s: 0
      text: '>'
comment__S_054SharpGraveParenDotDotDotThesis: !!perl/hash:RE_ast
  decl: []
  kind: token
  min: 2
  pkg: ~
  re: !!perl/hash:RE_sequence
    a: 0
    dba: comment__S_054SharpGraveParenDotDotDotThesis
    i: 0
    min: 2
    r: 1
    s: 0
    zyg:
    - !!perl/hash:RE_string
      a: 0
      dba: comment__S_054SharpGraveParenDotDotDotThesis
      i: 0
      min: 2
      r: 1
      s: 0
      text: '#`'
    - !!perl/hash:RE_meta
      a: 0
      dba: comment__S_054SharpGraveParenDotDotDotThesis
      i: 0
      min: 0
      r: 1
      s: 0
      text: '::'
    - !!perl/hash:RE_bracket
      decl: []
      min: 0
      re: !!perl/hash:RE_first
        a: 0
        dba: comment__S_054SharpGraveParenDotDotDotThesis
        i: 0
        min: 0
        r: 1
        s: 0
        zyg:
        - !!perl/hash:RE_assertion
          assert: '?'
          min: 0
          re: !!perl/hash:RE_method
            a: 0
            dba: comment__S_054SharpGraveParenDotDotDotThesis
            i: 0
            min: 12345
            name: opener
            nobind: 1
            r: 1
            rest: ''
            s: 0
        - !!perl/hash:RE_method
          min: 0
          name: panic
          nobind: 1
          rest: '("Opening bracket is required for #` comment")'
    - !!perl/hash:RE_method
      min: 0
      name: quibble
      nobind: 1
      rest: ($.cursor_fresh( %*LANG<Q> ))
comment__S_055SharpParenDotDotDotThesis: !!perl/hash:RE_ast
  decl: []
  kind: token
  min: 1
  pkg: ~
  re: !!perl/hash:RE_sequence
    a: 0
    dba: comment__S_055SharpParenDotDotDotThesis
    i: 0
    min: 1
    r: 1
    s: 0
    zyg:
    - !!perl/hash:RE_string
      a: 0
      dba: comment__S_055SharpParenDotDotDotThesis
      i: 0
      min: 1
      r: 1
      s: 0
      text: '#'
    - !!perl/hash:RE_assertion
      assert: '?'
      min: 0
      re: !!perl/hash:RE_method
        a: 0
        dba: comment__S_055SharpParenDotDotDotThesis
        i: 0
        min: 12345
        name: opener
        nobind: 1
        r: 1
        rest: ''
        s: 0
    - !!perl/hash:RE_method
      min: 0
      name: worry
      nobind: 1
      rest: ("Embedded comment without backtick is deprecated")
    - !!perl/hash:RE_assertion
      assert: '!'
      min: 0
      re: !!perl/hash:RE_noop
        a: 0
        dba: comment__S_055SharpParenDotDotDotThesis
        i: 0
        min: 0
        nobind: 1
        r: 1
        s: 0
    - !!perl/hash:RE_method
      min: 0
      name: quibble
      nobind: 1
      rest: ($.cursor_fresh( %*LANG<Q> ))
comment__S_056SharpEqualParenDotDotDotThesis: !!perl/hash:RE_ast
  decl: []
  kind: token
  min: 2
  pkg: ~
  re: !!perl/hash:RE_sequence
    a: 0
    dba: comment__S_056SharpEqualParenDotDotDotThesis
    i: 0
    min: 2
    r: 1
    s: 0
    zyg:
    - !!perl/hash:RE_string
      a: 0
      dba: comment__S_056SharpEqualParenDotDotDotThesis
      i: 0
      min: 2
      r: 1
      s: 0
      text: '#='
    - !!perl/hash:RE_assertion
      assert: '?'
      min: 0
      re: !!perl/hash:RE_method
        a: 0
        dba: comment__S_056SharpEqualParenDotDotDotThesis
        i: 0
        min: 12345
        name: opener
        nobind: 1
        r: 1
        rest: ''
        s: 0
    - !!perl/hash:RE_meta
      a: 0
      dba: comment__S_056SharpEqualParenDotDotDotThesis
      i: 0
      min: 0
      r: 1
      s: 0
      text: '::'
    - !!perl/hash:RE_method
      min: 0
      name: quibble
      rest: ($.cursor_fresh( %*LANG<Q> ))
comment__S_057SharpEqual: !!perl/hash:RE_ast
  decl: []
  kind: token
  min: 2
  pkg: ~
  re: !!perl/hash:RE_sequence
    a: 0
    dba: comment__S_057SharpEqual
    i: 0
    min: 2
    r: 1
    s: 0
    zyg:
    - !!perl/hash:RE_string
      a: 0
      dba: comment__S_057SharpEqual
      i: 0
      min: 2
      r: 1
      s: 0
      text: '#='
    - !!perl/hash:RE_meta
      a: 0
      dba: comment__S_057SharpEqual
      i: 0
      min: 0
      r: 1
      s: 0
      text: '::'
    - !!perl/hash:RE_bindnamed
      a: 0
      atom: !!perl/hash:RE_bracket
        decl: []
        min: 0
        re: !!perl/hash:RE_quantified_atom
          atom: !!perl/hash:RE_meta
            a: 0
            dba: comment__S_057SharpEqual
            i: 0
            min: 1
            r: 1
            s: 0
            text: \N
          min: 0
          quant:
          - '*'
          - ':'
          - ''
          - 0
      dba: comment__S_057SharpEqual
      i: 0
      min: 0
      r: 1
      s: 0
      var: attachment
comment__S_058Sharp: !!perl/hash:RE_ast
  decl: []
  kind: token
  min: 1
  pkg: ~
  re: !!perl/hash:RE_sequence
    a: 0
    dba: comment__S_058Sharp
    i: 0
    min: 1
    r: 1
    s: 0
    zyg:
    - !!perl/hash:RE_string
      a: 0
      dba: comment__S_058Sharp
      i: 0
      min: 1
      r: 1
      s: 0
      text: '#'
    - !!perl/hash:RE_block
      a: 0
      context: void
      dba: comment__S_058Sharp
      i: 0
      min: 0
      r: 1
      s: 0
      text: ''
    - !!perl/hash:RE_quantified_atom
      atom: !!perl/hash:RE_meta
        a: 0
        dba: comment__S_058Sharp
        i: 0
        min: 1
        r: 1
        s: 0
        text: \N
      min: 0
      quant:
      - '*'
      - ':'
      - ''
      - 0
dec_number: !!perl/hash:RE_ast
  decl: []
  kind: token
  min: 12346
  pkg: ~
  re: !!perl/hash:RE_sequence
    a: 0
    dba: decimal number
    i: 0
    min: 12346
    r: 1
    s: 0
    zyg:
    - !!perl/hash:RE_bracket
      decl: []
      min: 12346
      re: &3 !!perl/hash:RE_any
        a: 0
        altname: dec_number_01
        dba: decimal number
        i: 0
        min: 12346
        name: dec_number_01
        r: 1
        s: 0
        zyg:
        - !!perl/hash:RE_sequence
          a: 0
          alt: dec_number_01 0
          dba: decimal number
          i: 0
          min: 12346
          r: 1
          s: 0
          zyg:
          - !!perl/hash:RE_bindnamed
            a: 0
            atom: !!perl/hash:RE_bracket
              decl: []
              min: 12346
              re: !!perl/hash:RE_sequence
                a: 0
                dba: decimal number
                i: 0
                min: 12346
                r: 1
                s: 0
                zyg:
                - !!perl/hash:RE_string
                  a: 0
                  dba: decimal number
                  i: 0
                  min: 1
                  r: 1
                  s: 0
                  text: .
                - !!perl/hash:RE_bindnamed
                  a: 0
                  atom: !!perl/hash:RE_method
                    a: 0
                    dba: decimal number
                    i: 0
                    min: 12345
                    name: decint
                    nobind: 1
                    r: 1
                    rest: ''
                    s: 0
                  dba: decimal number
                  i: 0
                  min: 12345
                  r: 1
                  s: 0
                  var: frac
            dba: decimal number
            i: 0
            min: 12346
            r: 1
            s: 0
            var: coeff
          - !!perl/hash:RE_quantified_atom
            atom: !!perl/hash:RE_method
              a: 0
              dba: decimal number
              i: 0
              min: 12345
              name: escale
              r: 1
              rest: ''
              s: 0
            min: 0
            quant:
            - '?'
            - ':'
            - ''
            - 0
        - !!perl/hash:RE_sequence
          a: 0
          alt: dec_number_01 1
          dba: decimal number
          i: 0
          min: 24691
          r: 1
          s: 0
          zyg:
          - !!perl/hash:RE_bindnamed
            a: 0
            atom: !!perl/hash:RE_bracket
              decl: []
              min: 24691
              re: !!perl/hash:RE_sequence
                a: 0
                dba: decimal number
                i: 0
                min: 24691
                r: 1
                s: 0
                zyg:
                - !!perl/hash:RE_bindnamed
                  a: 0
                  atom: !!perl/hash:RE_method
                    a: 0
                    dba: decimal number
                    i: 0
                    min: 12345
                    name: decint
                    nobind: 1
                    r: 1
                    rest: ''
                    s: 0
                  dba: decimal number
                  i: 0
                  min: 12345
                  r: 1
                  s: 0
                  var: int
                - !!perl/hash:RE_string
                  a: 0
                  dba: decimal number
                  i: 0
                  min: 1
                  r: 1
                  s: 0
                  text: .
                - !!perl/hash:RE_bindnamed
                  a: 0
                  atom: !!perl/hash:RE_method
                    a: 0
                    dba: decimal number
                    i: 0
                    min: 12345
                    name: decint
                    nobind: 1
                    r: 1
                    rest: ''
                    s: 0
                  dba: decimal number
                  i: 0
                  min: 12345
                  r: 1
                  s: 0
                  var: frac
            dba: decimal number
            i: 0
            min: 24691
            r: 1
            s: 0
            var: coeff
          - !!perl/hash:RE_quantified_atom
            atom: !!perl/hash:RE_method
              a: 0
              dba: decimal number
              i: 0
              min: 12345
              name: escale
              r: 1
              rest: ''
              s: 0
            min: 0
            quant:
            - '?'
            - ':'
            - ''
            - 0
        - !!perl/hash:RE_sequence
          a: 0
          alt: dec_number_01 2
          dba: decimal number
          i: 0
          min: 24690
          r: 1
          s: 0
          zyg:
          - !!perl/hash:RE_bindnamed
            a: 0
            atom: !!perl/hash:RE_bracket
              decl: []
              min: 12345
              re: !!perl/hash:RE_bindnamed
                a: 0
                atom: !!perl/hash:RE_method
                  a: 0
                  dba: decimal number
                  i: 0
                  min: 12345
                  name: decint
                  nobind: 1
                  r: 1
                  rest: ''
                  s: 0
                dba: decimal number
                i: 0
                min: 12345
                r: 1
                s: 0
                var: int
            dba: decimal number
            i: 0
            min: 12345
            r: 1
            s: 0
            var: coeff
          - !!perl/hash:RE_method
            a: 0
            dba: decimal number
            i: 0
            min: 12345
            name: escale
            r: 1
            rest: ''
            s: 0
    - !!perl/hash:RE_assertion
      assert: '!'
      min: 0
      re: !!perl/hash:RE_assertion
        assert: '!'
        min: 0
        nobind: 1
        re: !!perl/hash:RE_method_re
          a: 0
          dba: decimal number
          i: 0
          min: 0
          name: before
          nobind: 1
          r: 1
          re: !!perl/hash:RE_ast
            decl: []
            min: 0
            re: !!perl/hash:RE_quantified_atom
              atom: !!perl/hash:RE_bracket
                decl: []
                min: 1
                re: !!perl/hash:RE_sequence
                  a: 0
                  dba: decimal number
                  i: 0
                  min: 1
                  r: 1
                  s: 0
                  zyg:
                  - !!perl/hash:RE_string
                    a: 0
                    dba: decimal number
                    i: 0
                    min: 1
                    r: 1
                    s: 0
                    text: .
                  - !!perl/hash:RE_assertion
                    assert: '?'
                    min: 0
                    re: !!perl/hash:RE_method_re
                      a: 0
                      dba: decimal number
                      i: 0
                      min: 0
                      name: before
                      nobind: 1
                      r: 1
                      re: !!perl/hash:RE_ast
                        decl: []
                        min: 1
                        re: !!perl/hash:RE_meta
                          a: 0
                          dba: decimal number
                          i: 0
                          min: 1
                          r: 1
                          s: 0
                          text: \d
                      s: 0
                  - !!perl/hash:RE_method
                    min: 0
                    name: panic
                    nobind: 1
                    rest: ("Number contains two decimal points (missing 'v' for version
                      number?)")
              min: 0
              quant:
              - '?'
              - ':'
              - ''
              - 0
          s: 0
dec_number_01: *3
decint: !!perl/hash:RE_ast
  decl: []
  kind: token
  min: 1
  pkg: ~
  re: !!perl/hash:RE_sequence
    a: 0
    dba: decint
    i: 0
    min: 1
    r: 1
    s: 0
    zyg:
    - !!perl/hash:RE_quantified_atom
      atom: !!perl/hash:RE_meta
        a: 0
        dba: decint
        i: 0
        min: 1
        r: 1
        s: 0
        text: \d
      min: 1
      quant:
      - +
      - ':'
      - ''
      - 1
    - !!perl/hash:RE_quantified_atom
      atom: !!perl/hash:RE_bracket
        decl: []
        min: 2
        re: !!perl/hash:RE_sequence
          a: 0
          dba: decint
          i: 0
          min: 2
          r: 1
          s: 0
          zyg:
          - !!perl/hash:RE_string
            a: 0
            dba: decint
            i: 0
            min: 1
            r: 1
            s: 0
            text: _
          - !!perl/hash:RE_quantified_atom
            atom: !!perl/hash:RE_meta
              a: 0
              dba: decint
              i: 0
              min: 1
              r: 1
              s: 0
              text: \d
            min: 1
            quant:
            - +
            - ':'
            - ''
            - 1
      min: 0
      quant:
      - '*'
      - ':'
      - ''
      - 0
decints: !!perl/hash:RE_ast
  decl: []
  kind: token
  min: 37035
  pkg: ~
  re: !!perl/hash:RE_quantified_atom
    atom: !!perl/hash:RE_bracket
      decl: []
      min: 37035
      re: !!perl/hash:RE_sequence
        a: 0
        dba: decints
        i: 0
        min: 37035
        r: 1
        s: 0
        zyg:
        - !!perl/hash:RE_method
          a: 0
          dba: decints
          i: 0
          min: 12345
          name: ws
          nobind: 1
          r: 1
          rest: ''
          s: 0
        - !!perl/hash:RE_method
          a: 0
          dba: decints
          i: 0
          min: 12345
          name: decint
          r: 1
          rest: ''
          s: 0
        - !!perl/hash:RE_method
          a: 0
          dba: decints
          i: 0
          min: 12345
          name: ws
          nobind: 1
          r: 1
          rest: ''
          s: 0
    min: 37035
    quant:
    - '**'
    - ':'
    - !!perl/hash:RE_string
      a: 0
      dba: decints
      i: 0
      min: 1
      r: 1
      s: 0
      text: ','
    - 1
embeddedblock: !!perl/hash:RE_ast
  decl:
  - !!perl/hash:RE_decl
    a: 0
    dba: embeddedblock
    i: 0
    max: 0
    min: 0
    r: 1
    s: 0
    text: temp %*LANG
  - !!perl/hash:RE_decl
    a: 0
    dba: embeddedblock
    i: 0
    max: 0
    min: 0
    r: 1
    s: 0
    text: my $*SIGNUM
  - !!perl/hash:RE_decl
    a: 0
    dba: embeddedblock
    i: 0
    max: 0
    min: 0
    r: 1
    s: 0
    text: my $*GOAL ::= '}'
  - !!perl/hash:RE_decl
    a: 0
    dba: embeddedblock
    i: 0
    max: 0
    min: 0
    r: 1
    s: 0
    text: temp $*CURPAD
  kind: token
  min: 37036
  pkg: ~
  re: !!perl/hash:RE_sequence
    a: 0
    dba: embedded block
    i: 0
    min: 37036
    r: 1
    s: 0
    zyg:
    - !!perl/hash:RE_method
      a: 0
      dba: embedded block
      i: 0
      min: 12345
      name: newpad
      nobind: 1
      r: 1
      rest: ''
      s: 0
    - !!perl/hash:RE_method
      a: 0
      dba: embedded block
      i: 0
      min: 12345
      name: finishpad
      nobind: 1
      r: 1
      rest: ''
      s: 0
    - !!perl/hash:RE_string
      a: 0
      dba: embedded block
      i: 0
      min: 1
      r: 1
      s: 0
      text: '{'
    - !!perl/hash:RE_meta
      a: 0
      dba: embedded block
      i: 0
      min: 0
      r: 1
      s: 0
      text: '::'
    - !!perl/hash:RE_bracket
      decl: []
      min: 12345
      re: !!perl/hash:RE_sequence
        a: 0
        dba: embedded block
        i: 0
        lang: ($C->cursor_fresh($::LANG{'MAIN'}))
        min: 12345
        r: 1
        s: 0
        zyg:
        - !!perl/hash:RE_decl
          a: 0
          dba: embedded block
          i: 0
          lang: ($C->cursor_fresh($::LANG{'MAIN'}))
          max: 0
          min: 0
          noquant: 1
          r: 1
          s: 0
          text: 'my $newlang = ($C->cursor_fresh($::LANG{''MAIN''}));  $C = $C->cursor_fresh($newlang); '
        - !!perl/hash:RE_method
          a: 0
          dba: embedded block
          i: 0
          lang: ($C->cursor_fresh($::LANG{'MAIN'}))
          min: 12345
          name: statementlist
          r: 1
          rest: ''
          s: 0
    - !!perl/hash:RE_bracket
      decl: []
      min: 0
      re: !!perl/hash:RE_first
        a: 0
        dba: embedded block
        i: 0
        min: 0
        r: 1
        s: 0
        zyg:
        - !!perl/hash:RE_string
          a: 0
          dba: embedded block
          i: 0
          min: 1
          r: 1
          s: 0
          text: '}'
        - !!perl/hash:RE_method
          min: 0
          name: panic
          nobind: 1
          rest: ("Unable to parse statement list; couldn't find right brace")
endid: !!perl/hash:RE_ast
  decl: []
  kind: token
  min: 0
  pkg: ~
  re: !!perl/hash:RE_assertion
    assert: '?'
    min: 0
    re: !!perl/hash:RE_method_re
      a: 0
      dba: endid
      i: 0
      min: 0
      name: before
      nobind: 1
      r: 1
      re: !!perl/hash:RE_ast
        decl: []
        min: 1
        re: !!perl/hash:RE_cclass
          a: 0
          dba: endid
          i: 0
          min: 1
          r: 1
          s: 0
          text: -[ \- \' \w ]
      s: 0
escale: !!perl/hash:RE_ast
  decl: []
  kind: token
  min: 12346
  pkg: ~
  re: !!perl/hash:RE_sequence
    a: 0
    dba: escale
    i: 0
    min: 12346
    r: 1
    s: 0
    zyg:
    - !!perl/hash:RE_cclass
      a: 0
      dba: escale
      i: 0
      min: 1
      r: 1
      s: 0
      text: '[Ee]'
    - !!perl/hash:RE_quantified_atom
      atom: !!perl/hash:RE_cclass
        a: 0
        dba: escale
        i: 0
        min: 1
        r: 1
        s: 0
        text: '[+\-]'
      min: 0
      quant:
      - '?'
      - ':'
      - ''
      - 0
    - !!perl/hash:RE_method
      a: 0
      dba: escale
      i: 0
      min: 12345
      name: decint
      r: 1
      rest: ''
      s: 0
escape__S_048none: !!perl/hash:RE_ast
  decl: []
  kind: token
  min: 0
  pkg: ~
  re: !!perl/hash:RE_assertion
    assert: '!'
    min: 0
    re: !!perl/hash:RE_noop
      a: 0
      dba: escape__S_048none
      i: 0
      min: 0
      nobind: 1
      r: 1
      s: 0
hexint: !!perl/hash:RE_ast
  decl: []
  kind: token
  min: 1
  pkg: ~
  re: !!perl/hash:RE_sequence
    a: 0
    dba: hexint
    i: 0
    min: 1
    r: 1
    s: 0
    zyg:
    - !!perl/hash:RE_quantified_atom
      atom: !!perl/hash:RE_cclass
        a: 0
        dba: hexint
        i: 0
        min: 1
        r: 1
        s: 0
        text: '[ 0..9 a..f A..F ]'
      min: 1
      quant:
      - +
      - ':'
      - ''
      - 1
    - !!perl/hash:RE_quantified_atom
      atom: !!perl/hash:RE_bracket
        decl: []
        min: 2
        re: !!perl/hash:RE_sequence
          a: 0
          dba: hexint
          i: 0
          min: 2
          r: 1
          s: 0
          zyg:
          - !!perl/hash:RE_string
            a: 0
            dba: hexint
            i: 0
            min: 1
            r: 1
            s: 0
            text: _
          - !!perl/hash:RE_quantified_atom
            atom: !!perl/hash:RE_cclass
              a: 0
              dba: hexint
              i: 0
              min: 1
              r: 1
              s: 0
              text: '[ 0..9 a..f A..F ]'
            min: 1
            quant:
            - +
            - ':'
            - ''
            - 1
      min: 0
      quant:
      - '*'
      - ':'
      - ''
      - 0
hexints: !!perl/hash:RE_ast
  decl: []
  kind: token
  min: 37035
  pkg: ~
  re: !!perl/hash:RE_quantified_atom
    atom: !!perl/hash:RE_bracket
      decl: []
      min: 37035
      re: !!perl/hash:RE_sequence
        a: 0
        dba: hexints
        i: 0
        min: 37035
        r: 1
        s: 0
        zyg:
        - !!perl/hash:RE_method
          a: 0
          dba: hexints
          i: 0
          min: 12345
          name: ws
          nobind: 1
          r: 1
          rest: ''
          s: 0
        - !!perl/hash:RE_method
          a: 0
          dba: hexints
          i: 0
          min: 12345
          name: hexint
          r: 1
          rest: ''
          s: 0
        - !!perl/hash:RE_method
          a: 0
          dba: hexints
          i: 0
          min: 12345
          name: ws
          nobind: 1
          r: 1
          rest: ''
          s: 0
    min: 37035
    quant:
    - '**'
    - ':'
    - !!perl/hash:RE_string
      a: 0
      dba: hexints
      i: 0
      min: 1
      r: 1
      s: 0
      text: ','
    - 1
ident: !!perl/hash:RE_ast
  decl: []
  kind: token
  min: 12345
  pkg: ~
  re: !!perl/hash:RE_sequence
    a: 0
    dba: ident
    i: 0
    min: 12345
    r: 1
    s: 0
    zyg:
    - !!perl/hash:RE_method
      a: 0
      dba: ident
      i: 0
      min: 12345
      name: alpha
      nobind: 1
      r: 1
      rest: ''
      s: 0
    - !!perl/hash:RE_quantified_atom
      atom: !!perl/hash:RE_meta
        a: 0
        dba: ident
        i: 0
        min: 1
        r: 1
        s: 0
        text: \w
      min: 0
      quant:
      - '*'
      - ':'
      - ''
      - 0
identifier: !!perl/hash:RE_ast
  decl: []
  kind: token
  min: 12345
  pkg: ~
  re: !!perl/hash:RE_sequence
    a: 0
    dba: identifier
    i: 0
    min: 12345
    r: 1
    s: 0
    zyg:
    - !!perl/hash:RE_method
      a: 0
      dba: identifier
      i: 0
      min: 12345
      name: ident
      nobind: 1
      r: 1
      rest: ''
      s: 0
    - !!perl/hash:RE_quantified_atom
      atom: !!perl/hash:RE_bracket
        decl: []
        min: 24690
        re: !!perl/hash:RE_sequence
          a: 0
          dba: identifier
          i: 0
          min: 24690
          r: 1
          s: 0
          zyg:
          - !!perl/hash:RE_method
            a: 0
            dba: identifier
            i: 0
            min: 12345
            name: apostrophe
            nobind: 1
            r: 1
            rest: ''
            s: 0
          - !!perl/hash:RE_method
            a: 0
            dba: identifier
            i: 0
            min: 12345
            name: ident
            nobind: 1
            r: 1
            rest: ''
            s: 0
      min: 0
      quant:
      - '*'
      - ':'
      - ''
      - 0
integer: !!perl/hash:RE_ast
  decl: []
  kind: token
  min: 12345
  pkg: ~
  re: !!perl/hash:RE_sequence
    a: 0
    dba: integer
    i: 0
    min: 12345
    r: 1
    s: 0
    zyg:
    - !!perl/hash:RE_bracket
      decl: []
      min: 12345
      re: &4 !!perl/hash:RE_any
        a: 0
        altname: integer_01
        dba: integer
        i: 0
        min: 12345
        name: integer_01
        r: 1
        s: 0
        zyg:
        - !!perl/hash:RE_sequence
          a: 0
          alt: integer_01 0
          dba: integer
          i: 0
          min: 12346
          r: 1
          s: 0
          zyg:
          - !!perl/hash:RE_string
            a: 0
            dba: integer
            i: 0
            min: 1
            r: 1
            s: 0
            text: '0'
          - !!perl/hash:RE_bracket
            decl: []
            min: 12345
            re: &5 !!perl/hash:RE_any
              a: 0
              altname: integer_02
              dba: integer
              i: 0
              min: 12345
              name: integer_02
              r: 1
              s: 0
              zyg:
              - !!perl/hash:RE_sequence
                a: 0
                alt: integer_02 0
                dba: integer
                i: 0
                min: 12346
                r: 1
                s: 0
                zyg:
                - !!perl/hash:RE_string
                  a: 0
                  dba: integer
                  i: 0
                  min: 1
                  r: 1
                  s: 0
                  text: b
                - !!perl/hash:RE_method
                  a: 0
                  dba: integer
                  i: 0
                  min: 12345
                  name: binint
                  r: 1
                  rest: ''
                  s: 0
              - !!perl/hash:RE_sequence
                a: 0
                alt: integer_02 1
                dba: integer
                i: 0
                min: 12346
                r: 1
                s: 0
                zyg:
                - !!perl/hash:RE_string
                  a: 0
                  dba: integer
                  i: 0
                  min: 1
                  r: 1
                  s: 0
                  text: o
                - !!perl/hash:RE_method
                  a: 0
                  dba: integer
                  i: 0
                  min: 12345
                  name: octint
                  r: 1
                  rest: ''
                  s: 0
              - !!perl/hash:RE_sequence
                a: 0
                alt: integer_02 2
                dba: integer
                i: 0
                min: 12346
                r: 1
                s: 0
                zyg:
                - !!perl/hash:RE_string
                  a: 0
                  dba: integer
                  i: 0
                  min: 1
                  r: 1
                  s: 0
                  text: x
                - !!perl/hash:RE_method
                  a: 0
                  dba: integer
                  i: 0
                  min: 12345
                  name: hexint
                  r: 1
                  rest: ''
                  s: 0
              - !!perl/hash:RE_sequence
                a: 0
                alt: integer_02 3
                dba: integer
                i: 0
                min: 12346
                r: 1
                s: 0
                zyg:
                - !!perl/hash:RE_string
                  a: 0
                  dba: integer
                  i: 0
                  min: 1
                  r: 1
                  s: 0
                  text: d
                - !!perl/hash:RE_method
                  a: 0
                  dba: integer
                  i: 0
                  min: 12345
                  name: decint
                  r: 1
                  rest: ''
                  s: 0
              - !!perl/hash:RE_sequence
                a: 0
                alt: integer_02 4
                dba: integer
                i: 0
                min: 12345
                r: 1
                s: 0
                zyg:
                - !!perl/hash:RE_method
                  a: 0
                  dba: integer
                  i: 0
                  min: 12345
                  name: decint
                  r: 1
                  rest: ''
                  s: 0
                - !!perl/hash:RE_assertion
                  assert: '!'
                  min: 0
                  re: !!perl/hash:RE_assertion
                    assert: '!'
                    min: 0
                    nobind: 1
                    re: !!perl/hash:RE_block
                      a: 0
                      context: bool
                      dba: integer
                      i: 0
                      min: 0
                      nobind: 1
                      r: 1
                      s: 0
                      text: ' $.worry("Leading 0 does not indicate octal in Perl
                        6") '
        - !!perl/hash:RE_method
          a: 0
          alt: integer_01 1
          dba: integer
          i: 0
          min: 12345
          name: decint
          r: 1
          rest: ''
          s: 0
    - !!perl/hash:RE_assertion
      assert: '!'
      min: 0
      re: !!perl/hash:RE_assertion
        assert: '!'
        min: 0
        nobind: 1
        re: !!perl/hash:RE_method_re
          a: 0
          dba: integer
          i: 0
          min: 0
          name: before
          nobind: 1
          r: 1
          re: !!perl/hash:RE_ast
            decl: []
            min: 0
            re: !!perl/hash:RE_quantified_atom
              atom: !!perl/hash:RE_bracket
                decl: []
                min: 1
                re: !!perl/hash:RE_sequence
                  a: 0
                  dba: integer
                  i: 0
                  min: 1
                  r: 1
                  s: 0
                  zyg:
                  - !!perl/hash:RE_string
                    a: 0
                    dba: integer
                    i: 0
                    min: 1
                    r: 1
                    s: 0
                    text: .
                  - !!perl/hash:RE_assertion
                    assert: '?'
                    min: 0
                    re: !!perl/hash:RE_method_re
                      a: 0
                      dba: integer
                      i: 0
                      min: 0
                      name: before
                      nobind: 1
                      r: 1
                      re: !!perl/hash:RE_ast
                        decl: []
                        min: 1
                        re: &6 !!perl/hash:RE_any
                          a: 0
                          altname: integer_05
                          dba: integer
                          i: 0
                          min: 1
                          name: integer_05
                          r: 1
                          s: 0
                          zyg:
                          - !!perl/hash:RE_meta
                            a: 0
                            alt: integer_05 0
                            dba: integer
                            i: 0
                            min: 1
                            r: 1
                            s: 0
                            text: \s
                          - !!perl/hash:RE_string
                            a: 0
                            alt: integer_05 1
                            dba: integer
                            i: 0
                            min: 1
                            r: 1
                            s: 0
                            text: ','
                          - !!perl/hash:RE_string
                            a: 0
                            alt: integer_05 2
                            dba: integer
                            i: 0
                            min: 1
                            r: 1
                            s: 0
                            text: =
                          - !!perl/hash:RE_method
                            a: 0
                            alt: integer_05 3
                            dba: integer
                            i: 0
                            min: 12345
                            name: terminator
                            r: 1
                            rest: ''
                            s: 0
                      s: 0
                  - !!perl/hash:RE_method
                    min: 0
                    name: panic
                    nobind: 1
                    rest: ("Decimal point must be followed by digit")
              min: 0
              quant:
              - '?'
              - ':'
              - ''
              - 0
          s: 0
integer_01: *4
integer_02: *5
integer_05: *6
longname: !!perl/hash:RE_ast
  decl: []
  kind: token
  min: 12345
  pkg: ~
  re: !!perl/hash:RE_sequence
    a: 0
    dba: longname
    i: 0
    min: 12345
    r: 1
    s: 0
    zyg:
    - !!perl/hash:RE_method
      a: 0
      dba: longname
      i: 0
      min: 12345
      name: name
      r: 1
      rest: ''
      s: 0
    - !!perl/hash:RE_quantified_atom
      atom: !!perl/hash:RE_method
        a: 0
        dba: longname
        i: 0
        min: 12345
        name: colonpair
        r: 1
        rest: ''
        s: 0
      min: 0
      quant:
      - '*'
      - ':'
      - ''
      - 0
morename: !!perl/hash:RE_ast
  decl:
  - !!perl/hash:RE_decl
    a: 0
    dba: morename
    i: 0
    max: 0
    min: 0
    r: 1
    s: 0
    text: my $*QSIGIL ::= ''
  kind: token
  min: 2
  pkg: ~
  re: !!perl/hash:RE_sequence
    a: 0
    dba: morename
    i: 0
    min: 2
    r: 1
    s: 0
    zyg:
    - !!perl/hash:RE_string
      a: 0
      dba: morename
      i: 0
      min: 2
      r: 1
      s: 0
      text: '::'
    - !!perl/hash:RE_quantified_atom
      atom: !!perl/hash:RE_bracket
        decl: []
        min: 0
        re: !!perl/hash:RE_first
          a: 0
          dba: morename
          i: 0
          min: 0
          r: 1
          s: 0
          zyg:
          - !!perl/hash:RE_sequence
            a: 0
            dba: morename
            i: 0
            min: 12345
            r: 1
            s: 0
            zyg:
            - !!perl/hash:RE_assertion
              assert: '?'
              min: 0
              re: !!perl/hash:RE_method_re
                a: 0
                dba: morename
                i: 0
                min: 0
                name: before
                nobind: 1
                r: 1
                re: !!perl/hash:RE_ast
                  decl: []
                  min: 1
                  re: &7 !!perl/hash:RE_any
                    a: 0
                    altname: morename_02
                    dba: morename
                    i: 0
                    min: 1
                    name: morename_02
                    r: 1
                    s: 0
                    zyg:
                    - !!perl/hash:RE_string
                      a: 0
                      alt: morename_02 0
                      dba: morename
                      i: 0
                      min: 1
                      r: 1
                      s: 0
                      text: (
                    - !!perl/hash:RE_method
                      a: 0
                      alt: morename_02 1
                      dba: morename
                      i: 0
                      min: 12345
                      name: alpha
                      r: 1
                      rest: ''
                      s: 0
                s: 0
            - !!perl/hash:RE_bracket
              decl: []
              min: 12345
              re: &8 !!perl/hash:RE_any
                a: 0
                altname: morename_03
                dba: indirect name
                i: 0
                min: 12345
                name: morename_03
                r: 1
                s: 0
                zyg:
                - !!perl/hash:RE_method
                  a: 0
                  alt: morename_03 0
                  dba: morename
                  i: 0
                  min: 12345
                  name: identifier
                  r: 1
                  rest: ''
                  s: 0
                - !!perl/hash:RE_sequence
                  a: 0
                  alt: morename_03 1
                  dba: indirect name
                  i: 0
                  min: 12347
                  r: 1
                  s: 0
                  zyg:
                  - !!perl/hash:RE_string
                    a: 0
                    dba: indirect name
                    i: 0
                    min: 1
                    r: 1
                    s: 0
                    text: (
                  - !!perl/hash:RE_meta
                    a: 0
                    dba: indirect name
                    extra: 'local $::GOAL = '')'' '
                    i: 0
                    min: 0
                    r: 1
                    s: 0
                    text: ':'
                  - !!perl/hash:RE_method
                    a: 0
                    dba: indirect name
                    i: 0
                    min: 12345
                    name: EXPR
                    r: 1
                    rest: ''
                    s: 0
                  - !!perl/hash:RE_bracket
                    decl: []
                    min: 1
                    re: !!perl/hash:RE_first
                      a: 0
                      dba: indirect name
                      i: 0
                      min: 1
                      r: 1
                      s: 0
                      zyg:
                      - !!perl/hash:RE_string
                        a: 0
                        dba: indirect name
                        i: 0
                        min: 1
                        r: 1
                        s: 0
                        text: )
                      - !!perl/hash:RE_method
                        min: 0
                        name: FAILGOAL
                        nobind: 1
                        rest: (')' , 'indirect name')
          - !!perl/hash:RE_sequence
            a: 0
            dba: morename
            i: 0
            min: 0
            r: 1
            s: 0
            zyg:
            - !!perl/hash:RE_assertion
              assert: '?'
              min: 0
              re: !!perl/hash:RE_method_re
                a: 0
                dba: morename
                i: 0
                min: 0
                name: before
                nobind: 1
                r: 1
                re: !!perl/hash:RE_ast
                  decl: []
                  min: 2
                  re: !!perl/hash:RE_string
                    a: 0
                    dba: morename
                    i: 0
                    min: 2
                    r: 1
                    s: 0
                    text: '::'
                s: 0
            - !!perl/hash:RE_method
              min: 0
              name: panic
              nobind: 1
              rest: ("Name component may not be null")
      min: 0
      quant:
      - '?'
      - ':'
      - ''
      - 0
morename_02: *7
morename_03: *8
name: !!perl/hash:RE_ast
  decl: []
  kind: token
  min: 12345
  pkg: ~
  re: !!perl/hash:RE_bracket
    decl: []
    min: 12345
    re: &9 !!perl/hash:RE_any
      a: 0
      altname: name_01
      dba: name
      i: 0
      min: 12345
      name: name_01
      r: 1
      s: 0
      zyg:
      - !!perl/hash:RE_sequence
        a: 0
        alt: name_01 0
        dba: name
        i: 0
        min: 12345
        r: 1
        s: 0
        zyg:
        - !!perl/hash:RE_method
          a: 0
          dba: name
          i: 0
          min: 12345
          name: identifier
          r: 1
          rest: ''
          s: 0
        - !!perl/hash:RE_quantified_atom
          atom: !!perl/hash:RE_method
            a: 0
            dba: name
            i: 0
            min: 12345
            name: morename
            r: 1
            rest: ''
            s: 0
          min: 0
          quant:
          - '*'
          - ':'
          - ''
          - 0
      - !!perl/hash:RE_quantified_atom
        alt: name_01 1
        atom: !!perl/hash:RE_method
          a: 0
          dba: name
          i: 0
          min: 12345
          name: morename
          r: 1
          rest: ''
          s: 0
        min: 12345
        quant:
        - +
        - ':'
        - ''
        - 1
name_01: *9
nibbler: !!perl/hash:RE_ast
  decl:
  - !!perl/hash:RE_decl
    a: 0
    dba: nibbler
    i: 0
    max: 0
    min: 0
    r: 1
    s: 0
    text: my $text = ''
  - !!perl/hash:RE_decl
    a: 0
    dba: nibbler
    i: 0
    max: 0
    min: 0
    r: 1
    s: 0
    text: my $from = self.pos
  - !!perl/hash:RE_decl
    a: 0
    dba: nibbler
    i: 0
    max: 0
    min: 0
    r: 1
    s: 0
    text: my $to = $from
  - !!perl/hash:RE_decl
    a: 0
    dba: nibbler
    i: 0
    max: 0
    min: 0
    r: 1
    s: 0
    text: my @nibbles = ()
  - !!perl/hash:RE_decl
    a: 0
    dba: nibbler
    i: 0
    max: 0
    min: 0
    r: 1
    s: 0
    text: my $multiline = 0
  - !!perl/hash:RE_decl
    a: 0
    dba: nibbler
    i: 0
    max: 0
    min: 0
    r: 1
    s: 0
    text: my $nibble
  kind: token
  min: 0
  pkg: ~
  re: !!perl/hash:RE_sequence
    a: 0
    dba: nibbler
    i: 0
    min: 0
    r: 1
    s: 0
    zyg:
    - !!perl/hash:RE_block
      a: 0
      context: void
      dba: nibbler
      i: 0
      min: 0
      r: 1
      s: 0
      text: ' $<_from> = self.pos; '
    - !!perl/hash:RE_quantified_atom
      atom: !!perl/hash:RE_bracket
        decl: []
        min: 1
        re: !!perl/hash:RE_sequence
          a: 0
          dba: nibbler
          i: 0
          min: 1
          r: 1
          s: 0
          zyg:
          - !!perl/hash:RE_assertion
            assert: '!'
            min: 0
            re: !!perl/hash:RE_method_re
              a: 0
              dba: nibbler
              i: 0
              min: 0
              name: before
              nobind: 1
              r: 1
              re: !!perl/hash:RE_ast
                decl: []
                min: 12345
                re: !!perl/hash:RE_method
                  a: 0
                  dba: nibbler
                  i: 0
                  min: 12345
                  name: stopper
                  r: 1
                  rest: ''
                  s: 0
              s: 0
          - !!perl/hash:RE_bracket
            decl: []
            min: 1
            re: !!perl/hash:RE_first
              a: 0
              dba: nibbler
              i: 0
              min: 1
              r: 1
              s: 0
              zyg:
              - !!perl/hash:RE_sequence
                a: 0
                dba: nibbler
                i: 0
                min: 37035
                r: 1
                s: 0
                zyg:
                - !!perl/hash:RE_method
                  a: 0
                  dba: nibbler
                  i: 0
                  min: 12345
                  name: starter
                  r: 1
                  rest: ''
                  s: 0
                - !!perl/hash:RE_method
                  a: 0
                  dba: nibbler
                  i: 0
                  min: 12345
                  name: nibbler
                  r: 1
                  rest: ''
                  s: 0
                - !!perl/hash:RE_method
                  a: 0
                  dba: nibbler
                  i: 0
                  min: 12345
                  name: stopper
                  r: 1
                  rest: ''
                  s: 0
                - !!perl/hash:RE_block
                  a: 0
                  context: void
                  dba: nibbler
                  i: 0
                  min: 0
                  r: 1
                  s: 0
                  text: "\n                            push @nibbles, $.makestr(TEXT
                    => $text, _from => $from, _pos => $to ) if $from != $to;\n\n                            my
                    $n = $<nibbler>[*-1]<nibbles>;\n                            my
                    @n = @$n;\n\n                            push @nibbles, $<starter>;\n
                    \                           push @nibbles, @n;\n                            push
                    @nibbles, $<stopper>;\n\n                            $text = '';\n
                    \                           $to = $from = $.pos;\n                        "
              - !!perl/hash:RE_sequence
                a: 0
                dba: nibbler
                i: 0
                min: 12345
                r: 1
                s: 0
                zyg:
                - !!perl/hash:RE_method
                  a: 0
                  dba: nibbler
                  i: 0
                  min: 12345
                  name: escape
                  r: 1
                  rest: ''
                  s: 0
                - !!perl/hash:RE_block
                  a: 0
                  context: void
                  dba: nibbler
                  i: 0
                  min: 0
                  r: 1
                  s: 0
                  text: "\n                            push @nibbles, $.makestr(TEXT
                    => $text, _from => $from, _pos => $to ) if $from != $to;\n                            push
                    @nibbles, $<escape>[*-1];\n                            $text =
                    '';\n                            $to = $from = $.pos;\n                        "
              - !!perl/hash:RE_sequence
                a: 0
                dba: nibbler
                i: 0
                min: 1
                r: 1
                s: 0
                zyg:
                - !!perl/hash:RE_meta
                  a: 0
                  dba: nibbler
                  i: 0
                  min: 1
                  r: 1
                  s: 0
                  text: .
                - !!perl/hash:RE_block
                  a: 0
                  context: void
                  dba: nibbler
                  i: 0
                  min: 0
                  r: 1
                  s: 0
                  text: "\n                            my $ch = substr($*ORIG, $.pos-1,
                    1);\n                            $text ~= $ch;\n                            $to
                    = $.pos;\n                            if $ch ~~ \"\\n\" {\n                                $multiline++;\n
                    \                           }\n                        "
      min: 0
      quant:
      - '*'
      - ':'
      - ''
      - 0
    - !!perl/hash:RE_block
      a: 0
      context: void
      dba: nibbler
      i: 0
      min: 0
      r: 1
      s: 0
      text: "\n        push @nibbles, $.makestr(TEXT => $text, _from => $from, _pos
        => $to ) if $from != $to or !@nibbles;\n        $<nibbles> = \\@nibbles;\n
        \       $<_pos> = $.pos;\n        $<nibbler> :delete;\n        $<escape>
        :delete;\n        $<starter> :delete;\n        $<stopper> :delete;\n        $*LAST_NIBBLE
        = $;\n        $*LAST_NIBBLE_MULTILINE = $ if $multiline;\n    "
nofun: !!perl/hash:RE_ast
  decl: []
  kind: token
  min: 0
  pkg: ~
  re: !!perl/hash:RE_assertion
    assert: '!'
    min: 0
    re: !!perl/hash:RE_method_re
      a: 0
      dba: nofun
      i: 0
      min: 0
      name: before
      nobind: 1
      r: 1
      re: !!perl/hash:RE_ast
        decl: []
        min: 1
        re: &10 !!perl/hash:RE_any
          a: 0
          altname: nofun_01
          dba: nofun
          i: 0
          min: 1
          name: nofun_01
          r: 1
          s: 0
          zyg:
          - !!perl/hash:RE_string
            a: 0
            alt: nofun_01 0
            dba: nofun
            i: 0
            min: 1
            r: 1
            s: 0
            text: (
          - !!perl/hash:RE_string
            a: 0
            alt: nofun_01 1
            dba: nofun
            i: 0
            min: 2
            r: 1
            s: 0
            text: .(
          - !!perl/hash:RE_string
            a: 0
            alt: nofun_01 2
            dba: nofun
            i: 0
            min: 1
            r: 1
            s: 0
            text: \
          - !!perl/hash:RE_string
            a: 0
            alt: nofun_01 3
            dba: nofun
            i: 0
            min: 1
            r: 1
            s: 0
            text: ''''
          - !!perl/hash:RE_string
            a: 0
            alt: nofun_01 4
            dba: nofun
            i: 0
            min: 1
            r: 1
            s: 0
            text: '-'
          - !!perl/hash:RE_double
            a: 0
            alt: nofun_01 5
            dba: nofun
            i: 0
            min: 1
            r: 1
            s: 0
            text: ''''
          - !!perl/hash:RE_meta
            a: 0
            alt: nofun_01 6
            dba: nofun
            i: 0
            min: 1
            r: 1
            s: 0
            text: \w
      s: 0
nofun_01: *10
octint: !!perl/hash:RE_ast
  decl: []
  kind: token
  min: 1
  pkg: ~
  re: !!perl/hash:RE_sequence
    a: 0
    dba: octint
    i: 0
    min: 1
    r: 1
    s: 0
    zyg:
    - !!perl/hash:RE_quantified_atom
      atom: !!perl/hash:RE_cclass
        a: 0
        dba: octint
        i: 0
        min: 1
        r: 1
        s: 0
        text: '[ 0..7 ]'
      min: 1
      quant:
      - +
      - ':'
      - ''
      - 1
    - !!perl/hash:RE_quantified_atom
      atom: !!perl/hash:RE_bracket
        decl: []
        min: 2
        re: !!perl/hash:RE_sequence
          a: 0
          dba: octint
          i: 0
          min: 2
          r: 1
          s: 0
          zyg:
          - !!perl/hash:RE_string
            a: 0
            dba: octint
            i: 0
            min: 1
            r: 1
            s: 0
            text: _
          - !!perl/hash:RE_quantified_atom
            atom: !!perl/hash:RE_cclass
              a: 0
              dba: octint
              i: 0
              min: 1
              r: 1
              s: 0
              text: '[ 0..7 ]'
            min: 1
            quant:
            - +
            - ':'
            - ''
            - 1
      min: 0
      quant:
      - '*'
      - ':'
      - ''
      - 0
octints: !!perl/hash:RE_ast
  decl: []
  kind: token
  min: 37035
  pkg: ~
  re: !!perl/hash:RE_quantified_atom
    atom: !!perl/hash:RE_bracket
      decl: []
      min: 37035
      re: !!perl/hash:RE_sequence
        a: 0
        dba: octints
        i: 0
        min: 37035
        r: 1
        s: 0
        zyg:
        - !!perl/hash:RE_method
          a: 0
          dba: octints
          i: 0
          min: 12345
          name: ws
          nobind: 1
          r: 1
          rest: ''
          s: 0
        - !!perl/hash:RE_method
          a: 0
          dba: octints
          i: 0
          min: 12345
          name: octint
          r: 1
          rest: ''
          s: 0
        - !!perl/hash:RE_method
          a: 0
          dba: octints
          i: 0
          min: 12345
          name: ws
          nobind: 1
          r: 1
          rest: ''
          s: 0
    min: 37035
    quant:
    - '**'
    - ':'
    - !!perl/hash:RE_string
      a: 0
      dba: octints
      i: 0
      min: 1
      r: 1
      s: 0
      text: ','
    - 1
opener: !!perl/hash:RE_ast
  decl: []
  kind: token
  min: 1
  pkg: ~
  re: !!perl/hash:RE_cclass
    a: 0
    dba: opener
    i: 0
    min: 1
    r: 1
    s: 0
    text: "[\n\\x{0028}\n\\x{003C}\n\\x{005B}\n\\x{007B}\n\\x{00AB}\n\\x{0F3A}\n\\x{0F3C}\n\\x{169B}\n\\x{2018}\n\\x{201A}\n\\x{201B}\n\\x{201C}\n\\x{201E}\n\\x{201F}\n\\x{2039}\n\\x{2045}\n\\x{207D}\n\\x{208D}\n\\x{2208}\n\\x{2209}\n\\x{220A}\n\\x{2215}\n\\x{223C}\n\\x{2243}\n\\x{2252}\n\\x{2254}\n\\x{2264}\n\\x{2266}\n\\x{2268}\n\\x{226A}\n\\x{226E}\n\\x{2270}\n\\x{2272}\n\\x{2274}\n\\x{2276}\n\\x{2278}\n\\x{227A}\n\\x{227C}\n\\x{227E}\n\\x{2280}\n\\x{2282}\n\\x{2284}\n\\x{2286}\n\\x{2288}\n\\x{228A}\n\\x{228F}\n\\x{2291}\n\\x{2298}\n\\x{22A2}\n\\x{22A6}\n\\x{22A8}\n\\x{22A9}\n\\x{22AB}\n\\x{22B0}\n\\x{22B2}\n\\x{22B4}\n\\x{22B6}\n\\x{22C9}\n\\x{22CB}\n\\x{22D0}\n\\x{22D6}\n\\x{22D8}\n\\x{22DA}\n\\x{22DC}\n\\x{22DE}\n\\x{22E0}\n\\x{22E2}\n\\x{22E4}\n\\x{22E6}\n\\x{22E8}\n\\x{22EA}\n\\x{22EC}\n\\x{22F0}\n\\x{22F2}\n\\x{22F3}\n\\x{22F4}\n\\x{22F6}\n\\x{22F7}\n\\x{2308}\n\\x{230A}\n\\x{2329}\n\\x{23B4}\n\\x{2768}\n\\x{276A}\n\\x{276C}\n\\x{276E}\n\\x{2770}\n\\x{2772}\n\\x{2774}\n\\x{27C3}\n\\x{27C5}\n\\x{27D5}\n\\x{27DD}\n\\x{27E2}\n\\x{27E4}\n\\x{27E6}\n\\x{27E8}\n\\x{27EA}\n\\x{2983}\n\\x{2985}\n\\x{2987}\n\\x{2989}\n\\x{298B}\n\\x{298D}\n\\x{298F}\n\\x{2991}\n\\x{2993}\n\\x{2995}\n\\x{2997}\n\\x{29C0}\n\\x{29C4}\n\\x{29CF}\n\\x{29D1}\n\\x{29D4}\n\\x{29D8}\n\\x{29DA}\n\\x{29F8}\n\\x{29FC}\n\\x{2A2B}\n\\x{2A2D}\n\\x{2A34}\n\\x{2A3C}\n\\x{2A64}\n\\x{2A79}\n\\x{2A7D}\n\\x{2A7F}\n\\x{2A81}\n\\x{2A83}\n\\x{2A8B}\n\\x{2A91}\n\\x{2A93}\n\\x{2A95}\n\\x{2A97}\n\\x{2A99}\n\\x{2A9B}\n\\x{2AA1}\n\\x{2AA6}\n\\x{2AA8}\n\\x{2AAA}\n\\x{2AAC}\n\\x{2AAF}\n\\x{2AB3}\n\\x{2ABB}\n\\x{2ABD}\n\\x{2ABF}\n\\x{2AC1}\n\\x{2AC3}\n\\x{2AC5}\n\\x{2ACD}\n\\x{2ACF}\n\\x{2AD1}\n\\x{2AD3}\n\\x{2AD5}\n\\x{2AEC}\n\\x{2AF7}\n\\x{2AF9}\n\\x{2E02}\n\\x{2E04}\n\\x{2E09}\n\\x{2E0C}\n\\x{2E1C}\n\\x{2E20}\n\\x{3008}\n\\x{300A}\n\\x{300C}\n\\x{300E}\n\\x{3010}\n\\x{3014}\n\\x{3016}\n\\x{3018}\n\\x{301A}\n\\x{301D}\n\\x{FD3E}\n\\x{FE17}\n\\x{FE35}\n\\x{FE37}\n\\x{FE39}\n\\x{FE3B}\n\\x{FE3D}\n\\x{FE3F}\n\\x{FE41}\n\\x{FE43}\n\\x{FE47}\n\\x{FE59}\n\\x{FE5B}\n\\x{FE5D}\n\\x{FF08}\n\\x{FF1C}\n\\x{FF3B}\n\\x{FF5B}\n\\x{FF5F}\n\\x{FF62}\n
      \ ]"
pod_comment: !!perl/hash:RE_ast
  decl: []
  kind: token
  min: 1
  pkg: ~
  re: !!perl/hash:RE_sequence
    a: 0
    dba: pod_comment
    i: 0
    min: 1
    r: 1
    s: 0
    zyg:
    - !!perl/hash:RE_meta
      a: 0
      dba: pod_comment
      i: 0
      min: 0
      r: 1
      s: 0
      text: ^^
    - !!perl/hash:RE_quantified_atom
      atom: !!perl/hash:RE_meta
        a: 0
        dba: pod_comment
        i: 0
        min: 1
        r: 1
        s: 0
        text: \h
      min: 0
      quant:
      - '*'
      - ':'
      - ''
      - 0
    - !!perl/hash:RE_string
      a: 0
      dba: pod_comment
      i: 0
      min: 1
      r: 1
      s: 0
      text: =
    - !!perl/hash:RE_quantified_atom
      atom: !!perl/hash:RE_method
        a: 0
        dba: pod_comment
        i: 0
        min: 12345
        name: unsp
        nobind: 1
        r: 1
        rest: ''
        s: 0
      min: 0
      quant:
      - '?'
      - ':'
      - ''
      - 0
    - !!perl/hash:RE_bracket
      decl: []
      min: 0
      re: &11 !!perl/hash:RE_any
        a: 0
        altname: pod_comment_01
        dba: pod_comment
        i: 0
        min: 0
        name: pod_comment_01
        r: 1
        s: 0
        zyg:
        - !!perl/hash:RE_sequence
          a: 0
          alt: pod_comment_01 0
          dba: pod_comment
          i: 0
          min: 12351
          r: 1
          s: 0
          zyg:
          - !!perl/hash:RE_string
            a: 0
            dba: pod_comment
            i: 0
            min: 5
            r: 1
            s: 0
            text: begin
          - !!perl/hash:RE_quantified_atom
            atom: !!perl/hash:RE_meta
              a: 0
              dba: pod_comment
              i: 0
              min: 1
              r: 1
              s: 0
              text: \h
            min: 1
            quant:
            - +
            - ':'
            - ''
            - 1
          - !!perl/hash:RE_method
            a: 0
            dba: pod_comment
            i: 0
            min: 12345
            name: identifier
            r: 1
            rest: ''
            s: 0
          - !!perl/hash:RE_meta
            a: 0
            dba: pod_comment
            i: 0
            min: 0
            r: 1
            s: 0
            text: '::'
          - !!perl/hash:RE_bracket
            decl: []
            min: 0
            re: !!perl/hash:RE_first
              a: 0
              dba: pod_comment
              i: 0
              min: 0
              r: 1
              s: 0
              zyg:
              - !!perl/hash:RE_sequence
                a: 0
                dba: pod_comment
                i: 0
                min: 7
                r: 1
                s: 0
                zyg:
                - !!perl/hash:RE_meta
                  a: 0
                  dba: pod_comment
                  i: 0
                  min: 1
                  r: 1
                  s: 0
                  text: .*?
                - !!perl/hash:RE_double
                  a: 0
                  dba: pod_comment
                  i: 0
                  min: 1
                  r: 1
                  s: 0
                  text: \n
                - !!perl/hash:RE_bracket
                  decl: []
                  min: 5
                  re: !!perl/hash:RE_sequence
                    a: 0
                    dba: pod_comment
                    i: 0
                    min: 5
                    r: 1
                    s: 0
                    zyg:
                    - !!perl/hash:RE_quantified_atom
                      atom: !!perl/hash:RE_meta
                        a: 0
                        dba: pod_comment
                        i: 0
                        min: 1
                        r: 1
                        s: 0
                        text: \h
                      min: 0
                      quant:
                      - '*'
                      - ':'
                      - ''
                      - 0
                    - !!perl/hash:RE_string
                      a: 0
                      dba: pod_comment
                      i: 0
                      min: 1
                      r: 1
                      s: 0
                      text: =
                    - !!perl/hash:RE_quantified_atom
                      atom: !!perl/hash:RE_method
                        a: 0
                        dba: pod_comment
                        i: 0
                        min: 12345
                        name: unsp
                        nobind: 1
                        r: 1
                        rest: ''
                        s: 0
                      min: 0
                      quant:
                      - '?'
                      - ':'
                      - ''
                      - 0
                    - !!perl/hash:RE_string
                      a: 0
                      dba: pod_comment
                      i: 0
                      min: 3
                      r: 1
                      s: 0
                      text: end
                    - !!perl/hash:RE_quantified_atom
                      atom: !!perl/hash:RE_meta
                        a: 0
                        dba: pod_comment
                        i: 0
                        min: 1
                        r: 1
                        s: 0
                        text: \h
                      min: 1
                      quant:
                      - +
                      - ':'
                      - ''
                      - 1
                    - !!perl/hash:RE_var
                      a: 0
                      dba: pod_comment
                      i: 0
                      min: 0
                      r: 1
                      s: 0
                      var: $<identifier>
                    - !!perl/hash:RE_meta
                      a: 0
                      dba: pod_comment
                      i: 0
                      min: 0
                      r: 1
                      s: 0
                      text: 
                    - !!perl/hash:RE_quantified_atom
                      atom: !!perl/hash:RE_meta
                        a: 0
                        dba: pod_comment
                        i: 0
                        min: 1
                        r: 1
                        s: 0
                        text: \N
                      min: 0
                      quant:
                      - '*'
                      - ':'
                      - ''
                      - 0
              - !!perl/hash:RE_sequence
                a: 0
                dba: pod_comment
                i: 0
                min: 1
                r: 1
                s: 0
                zyg:
                - !!perl/hash:RE_assertion
                  assert: '?'
                  min: 0
                  re: !!perl/hash:RE_block
                    a: 0
                    context: bool
                    dba: pod_comment
                    i: 0
                    min: 0
                    nobind: 1
                    r: 1
                    s: 0
                    text: ' $<identifier>.Str eq ''END'''
                - !!perl/hash:RE_meta
                  a: 0
                  dba: pod_comment
                  i: 0
                  min: 1
                  r: 1
                  s: 0
                  text: .*
              - !!perl/hash:RE_block
                a: 0
                context: void
                dba: pod_comment
                i: 0
                min: 0
                r: 1
                s: 0
                text: ' my $id = $<identifier>.Str; self.panic("=begin $id without
                  matching =end $id"); '
        - !!perl/hash:RE_sequence
          a: 0
          alt: pod_comment_01 1
          dba: pod_comment
          i: 0
          min: 5
          r: 1
          s: 0
          zyg:
          - !!perl/hash:RE_string
            a: 0
            dba: pod_comment
            i: 0
            min: 5
            r: 1
            s: 0
            text: begin
          - !!perl/hash:RE_meta
            a: 0
            dba: pod_comment
            i: 0
            min: 0
            r: 1
            s: 0
            text: 
          - !!perl/hash:RE_meta
            a: 0
            dba: pod_comment
            i: 0
            min: 0
            r: 1
            s: 0
            text: '::'
          - !!perl/hash:RE_quantified_atom
            atom: !!perl/hash:RE_meta
              a: 0
              dba: pod_comment
              i: 0
              min: 1
              r: 1
              s: 0
              text: \h
            min: 0
            quant:
            - '*'
            - ':'
            - ''
            - 0
          - !!perl/hash:RE_bracket
            decl: []
            min: 0
            re: !!perl/hash:RE_first
              a: 0
              dba: pod_comment
              i: 0
              min: 0
              r: 1
              s: 0
              zyg:
              - !!perl/hash:RE_meta
                a: 0
                dba: pod_comment
                i: 0
                min: 0
                r: 1
                s: 0
                text: $$
              - !!perl/hash:RE_string
                a: 0
                dba: pod_comment
                i: 0
                min: 1
                r: 1
                s: 0
                text: '#'
              - !!perl/hash:RE_method
                min: 0
                name: panic
                nobind: 1
                rest: ("Unrecognized token after =begin")
          - !!perl/hash:RE_bracket
            decl: []
            min: 0
            re: !!perl/hash:RE_first
              a: 0
              dba: pod_comment
              i: 0
              min: 0
              r: 1
              s: 0
              zyg:
              - !!perl/hash:RE_sequence
                a: 0
                dba: pod_comment
                i: 0
                min: 6
                r: 1
                s: 0
                zyg:
                - !!perl/hash:RE_meta
                  a: 0
                  dba: pod_comment
                  i: 0
                  min: 1
                  r: 1
                  s: 0
                  text: .*?
                - !!perl/hash:RE_double
                  a: 0
                  dba: pod_comment
                  i: 0
                  min: 1
                  r: 1
                  s: 0
                  text: \n
                - !!perl/hash:RE_quantified_atom
                  atom: !!perl/hash:RE_meta
                    a: 0
                    dba: pod_comment
                    i: 0
                    min: 1
                    r: 1
                    s: 0
                    text: \h
                  min: 0
                  quant:
                  - '*'
                  - ':'
                  - ''
                  - 0
                - !!perl/hash:RE_string
                  a: 0
                  dba: pod_comment
                  i: 0
                  min: 1
                  r: 1
                  s: 0
                  text: =
                - !!perl/hash:RE_quantified_atom
                  atom: !!perl/hash:RE_method
                    a: 0
                    dba: pod_comment
                    i: 0
                    min: 12345
                    name: unsp
                    nobind: 1
                    r: 1
                    rest: ''
                    s: 0
                  min: 0
                  quant:
                  - '?'
                  - ':'
                  - ''
                  - 0
                - !!perl/hash:RE_string
                  a: 0
                  dba: pod_comment
                  i: 0
                  min: 3
                  r: 1
                  s: 0
                  text: end
                - !!perl/hash:RE_meta
                  a: 0
                  dba: pod_comment
                  i: 0
                  min: 0
                  r: 1
                  s: 0
                  text: 
                - !!perl/hash:RE_quantified_atom
                  atom: !!perl/hash:RE_meta
                    a: 0
                    dba: pod_comment
                    i: 0
                    min: 1
                    r: 1
                    s: 0
                    text: \N
                  min: 0
                  quant:
                  - '*'
                  - ':'
                  - ''
                  - 0
              - !!perl/hash:RE_block
                a: 0
                context: void
                dba: pod_comment
                i: 0
                min: 0
                r: 1
                s: 0
                text: ' self.panic("=begin without matching =end"); '
        - !!perl/hash:RE_sequence
          a: 0
          alt: pod_comment_01 2
          dba: pod_comment
          i: 0
          min: 4
          r: 1
          s: 0
          zyg:
          - !!perl/hash:RE_string
            a: 0
            dba: pod_comment
            i: 0
            min: 3
            r: 1
            s: 0
            text: for
          - !!perl/hash:RE_meta
            a: 0
            dba: pod_comment
            i: 0
            min: 0
            r: 1
            s: 0
            text: 
          - !!perl/hash:RE_meta
            a: 0
            dba: pod_comment
            i: 0
            min: 0
            r: 1
            s: 0
            text: '::'
          - !!perl/hash:RE_quantified_atom
            atom: !!perl/hash:RE_meta
              a: 0
              dba: pod_comment
              i: 0
              min: 1
              r: 1
              s: 0
              text: \h
            min: 0
            quant:
            - '*'
            - ':'
            - ''
            - 0
          - !!perl/hash:RE_bracket
            decl: []
            min: 0
            re: !!perl/hash:RE_first
              a: 0
              dba: pod_comment
              i: 0
              min: 0
              r: 1
              s: 0
              zyg:
              - !!perl/hash:RE_method
                a: 0
                dba: pod_comment
                i: 0
                min: 12345
                name: identifier
                r: 1
                rest: ''
                s: 0
              - !!perl/hash:RE_meta
                a: 0
                dba: pod_comment
                i: 0
                min: 0
                r: 1
                s: 0
                text: $$
              - !!perl/hash:RE_string
                a: 0
                dba: pod_comment
                i: 0
                min: 1
                r: 1
                s: 0
                text: '#'
              - !!perl/hash:RE_method
                min: 0
                name: panic
                nobind: 1
                rest: ("Unrecognized token after =for")
          - !!perl/hash:RE_bracket
            decl: []
            min: 1
            re: !!perl/hash:RE_first
              a: 0
              dba: pod_comment
              i: 0
              min: 1
              r: 1
              s: 0
              zyg:
              - !!perl/hash:RE_sequence
                a: 0
                dba: pod_comment
                i: 0
                min: 1
                r: 1
                s: 0
                zyg:
                - !!perl/hash:RE_meta
                  a: 0
                  dba: pod_comment
                  i: 0
                  min: 1
                  r: 1
                  s: 0
                  text: .*?
                - !!perl/hash:RE_meta
                  a: 0
                  dba: pod_comment
                  i: 0
                  min: 0
                  r: 1
                  s: 0
                  text: ^^
                - !!perl/hash:RE_quantified_atom
                  atom: !!perl/hash:RE_meta
                    a: 0
                    dba: pod_comment
                    i: 0
                    min: 1
                    r: 1
                    s: 0
                    text: \h
                  min: 0
                  quant:
                  - '*'
                  - ':'
                  - ''
                  - 0
                - !!perl/hash:RE_meta
                  a: 0
                  dba: pod_comment
                  i: 0
                  min: 0
                  r: 1
                  s: 0
                  text: $$
              - !!perl/hash:RE_meta
                a: 0
                dba: pod_comment
                i: 0
                min: 1
                r: 1
                s: 0
                text: .*
        - !!perl/hash:RE_sequence
          a: 0
          alt: pod_comment_01 3
          dba: pod_comment
          i: 0
          min: 0
          r: 1
          s: 0
          zyg:
          - !!perl/hash:RE_meta
            a: 0
            dba: pod_comment
            i: 0
            min: 0
            r: 1
            s: 0
            text: '::'
          - !!perl/hash:RE_quantified_atom
            atom: !!perl/hash:RE_bracket
              decl: []
              min: 0
              re: !!perl/hash:RE_sequence
                a: 0
                dba: pod_comment
                i: 0
                min: 0
                r: 1
                s: 0
                zyg:
                - !!perl/hash:RE_assertion
                  assert: '?'
                  min: 0
                  re: !!perl/hash:RE_method_re
                    a: 0
                    dba: pod_comment
                    i: 0
                    min: 0
                    name: before
                    nobind: 1
                    r: 1
                    re: !!perl/hash:RE_ast
                      decl: []
                      min: 5
                      re: !!perl/hash:RE_sequence
                        a: 0
                        dba: pod_comment
                        i: 0
                        min: 5
                        r: 1
                        s: 0
                        zyg:
                        - !!perl/hash:RE_meta
                          a: 0
                          dba: pod_comment
                          i: 0
                          min: 1
                          r: 1
                          s: 0
                          text: .*?
                        - !!perl/hash:RE_meta
                          a: 0
                          dba: pod_comment
                          i: 0
                          min: 0
                          r: 1
                          s: 0
                          text: ^^
                        - !!perl/hash:RE_string
                          a: 0
                          dba: pod_comment
                          i: 0
                          min: 4
                          r: 1
                          s: 0
                          text: =cut
                        - !!perl/hash:RE_meta
                          a: 0
                          dba: pod_comment
                          i: 0
                          min: 0
                          r: 1
                          s: 0
                          text: 
                    s: 0
                - !!perl/hash:RE_method
                  min: 0
                  name: panic
                  nobind: 1
                  rest: ("Obsolescent pod format, please use =begin/=end instead")
            min: 0
            quant:
            - '?'
            - ':'
            - ''
            - 0
          - !!perl/hash:RE_bracket
            decl: []
            min: 0
            re: !!perl/hash:RE_first
              a: 0
              dba: pod_comment
              i: 0
              min: 0
              r: 1
              s: 0
              zyg:
              - !!perl/hash:RE_method
                a: 0
                dba: pod_comment
                i: 0
                min: 12345
                name: alpha
                r: 1
                rest: ''
                s: 0
              - !!perl/hash:RE_meta
                a: 0
                dba: pod_comment
                i: 0
                min: 1
                r: 1
                s: 0
                text: \s
              - !!perl/hash:RE_method
                min: 0
                name: panic
                nobind: 1
                rest: ("Illegal pod directive")
          - !!perl/hash:RE_quantified_atom
            atom: !!perl/hash:RE_meta
              a: 0
              dba: pod_comment
              i: 0
              min: 1
              r: 1
              s: 0
              text: \N
            min: 0
            quant:
            - '*'
            - ':'
            - ''
            - 0
pod_comment_01: *11
quibble: !!perl/hash:RE_ast
  decl:
  - !!perl/hash:RE_decl
    a: 0
    dba: quibble
    i: 0
    max: 0
    min: 0
    r: 1
    s: 0
    text: my ($lang, $start, $stop)
  kind: token
  min: 0
  pkg: ~
  re: !!perl/hash:RE_sequence
    a: 0
    dba: quibble
    i: 0
    min: 0
    r: 1
    s: 0
    zyg:
    - !!perl/hash:RE_method
      min: 0
      name: babble
      rest: ($l)
    - !!perl/hash:RE_block
      a: 0
      context: void
      dba: quibble
      i: 0
      min: 0
      r: 1
      s: 0
      text: ' my $B = $<babble><B>; ($lang,$start,$stop) = @$B; '
    - !!perl/hash:RE_var
      a: 0
      dba: quibble
      i: 0
      min: 0
      r: 1
      s: 0
      var: $start
    - !!perl/hash:RE_method
      min: 0
      name: nibble
      rest: ($lang)
    - !!perl/hash:RE_bracket
      decl: []
      min: 0
      re: !!perl/hash:RE_first
        a: 0
        dba: quibble
        i: 0
        min: 0
        r: 1
        s: 0
        zyg:
        - !!perl/hash:RE_var
          a: 0
          dba: quibble
          i: 0
          min: 0
          r: 1
          s: 0
          var: $stop
        - !!perl/hash:RE_method
          min: 0
          name: panic
          nobind: 1
          rest: ("Couldn't find terminator $stop")
    - !!perl/hash:RE_block
      a: 0
      context: void
      dba: quibble
      i: 0
      min: 0
      r: 1
      s: 0
      text: "\n        if $lang<_herelang> {\n            push @herestub_queue,\n
        \               ::Herestub.new(\n                    delim => $<nibble><nibbles>[0]<TEXT>,\n
        \                   orignode => $,\n                    lang => $lang<_herelang>,\n
        \               );\n        }\n    "
quote__S_049Single_Single: !!perl/hash:RE_ast
  decl: []
  kind: token
  min: 2
  pkg: ~
  re: !!perl/hash:RE_sequence
    a: 0
    dba: quote__S_049Single_Single
    i: 0
    min: 2
    r: 1
    s: 0
    zyg:
    - !!perl/hash:RE_double
      a: 0
      dba: quote__S_049Single_Single
      i: 0
      min: 1
      r: 1
      s: 0
      text: ''''
    - !!perl/hash:RE_method
      min: 0
      name: nibble
      rest: ($.cursor_fresh( %*LANG<Q> ).tweak(:q).unbalanced("'"))
    - !!perl/hash:RE_double
      a: 0
      dba: quote__S_049Single_Single
      i: 0
      min: 1
      r: 1
      s: 0
      text: ''''
quote__S_050Double_Double: !!perl/hash:RE_ast
  decl: []
  kind: token
  min: 2
  pkg: ~
  re: !!perl/hash:RE_sequence
    a: 0
    dba: quote__S_050Double_Double
    i: 0
    min: 2
    r: 1
    s: 0
    zyg:
    - !!perl/hash:RE_string
      a: 0
      dba: quote__S_050Double_Double
      i: 0
      min: 1
      r: 1
      s: 0
      text: '"'
    - !!perl/hash:RE_method
      min: 0
      name: nibble
      rest: ($.cursor_fresh( %*LANG<Q> ).tweak(:qq).unbalanced('"'))
    - !!perl/hash:RE_string
      a: 0
      dba: quote__S_050Double_Double
      i: 0
      min: 1
      r: 1
      s: 0
      text: '"'
quotepair: !!perl/hash:RE_ast
  decl:
  - !!perl/hash:RE_decl
    a: 0
    dba: quotepair
    i: 0
    max: 0
    min: 0
    r: 1
    s: 0
    text: my $key
  - !!perl/hash:RE_decl
    a: 0
    dba: quotepair
    i: 0
    max: 0
    min: 0
    r: 1
    s: 0
    text: my $value
  kind: token
  min: 3
  pkg: ~
  re: !!perl/hash:RE_sequence
    a: 0
    dba: colon pair (restricted)
    i: 0
    min: 3
    r: 1
    s: 0
    zyg:
    - !!perl/hash:RE_string
      a: 0
      dba: quotepair
      i: 0
      min: 1
      r: 1
      s: 0
      text: ':'
    - !!perl/hash:RE_bracket
      decl: []
      min: 2
      re: &12 !!perl/hash:RE_any
        a: 0
        altname: quotepair_01
        dba: colon pair (restricted)
        i: 0
        min: 2
        name: quotepair_01
        r: 1
        s: 0
        zyg:
        - !!perl/hash:RE_sequence
          a: 0
          alt: quotepair_01 0
          dba: colon pair (restricted)
          i: 0
          min: 12346
          r: 1
          s: 0
          zyg:
          - !!perl/hash:RE_string
            a: 0
            dba: colon pair (restricted)
            i: 0
            min: 1
            r: 1
            s: 0
            text: '!'
          - !!perl/hash:RE_method
            a: 0
            dba: colon pair (restricted)
            i: 0
            min: 12345
            name: identifier
            r: 1
            rest: ''
            s: 0
          - !!perl/hash:RE_quantified_atom
            atom: !!perl/hash:RE_bracket
              decl: []
              min: 1
              re: !!perl/hash:RE_sequence
                a: 0
                dba: colon pair (restricted)
                i: 0
                min: 1
                r: 1
                s: 0
                zyg:
                - !!perl/hash:RE_string
                  a: 0
                  dba: colon pair (restricted)
                  i: 0
                  min: 1
                  r: 1
                  s: 0
                  text: (
                - !!perl/hash:RE_method
                  min: 0
                  name: panic
                  nobind: 1
                  rest: ("Argument not allowed on negated pair")
            min: 0
            quant:
            - '?'
            - ':'
            - ''
            - 0
          - !!perl/hash:RE_block
            a: 0
            context: void
            dba: colon pair (restricted)
            i: 0
            min: 0
            r: 1
            s: 0
            text: ' $key = $<identifier>.Str; $value = 0; '
        - !!perl/hash:RE_sequence
          a: 0
          alt: quotepair_01 1
          dba: colon pair (restricted)
          i: 0
          min: 12345
          r: 1
          s: 0
          zyg:
          - !!perl/hash:RE_method
            a: 0
            dba: colon pair (restricted)
            i: 0
            min: 12345
            name: identifier
            r: 1
            rest: ''
            s: 0
          - !!perl/hash:RE_block
            a: 0
            context: void
            dba: colon pair (restricted)
            i: 0
            min: 0
            r: 1
            s: 0
            text: ' $key = $<identifier>.Str; '
          - !!perl/hash:RE_bracket
            decl: []
            min: 0
            re: !!perl/hash:RE_first
              a: 0
              dba: colon pair (restricted)
              i: 0
              min: 0
              r: 1
              s: 0
              zyg:
              - !!perl/hash:RE_sequence
                a: 0
                dba: colon pair (restricted)
                i: 0
                min: 12345
                r: 1
                s: 0
                zyg:
                - !!perl/hash:RE_quantified_atom
                  atom: !!perl/hash:RE_method
                    a: 0
                    dba: colon pair (restricted)
                    i: 0
                    min: 12345
                    name: unsp
                    nobind: 1
                    r: 1
                    rest: ''
                    s: 0
                  min: 0
                  quant:
                  - '?'
                  - ':'
                  - ''
                  - 0
                - !!perl/hash:RE_assertion
                  assert: '?'
                  min: 0
                  re: !!perl/hash:RE_method_re
                    a: 0
                    dba: colon pair (restricted)
                    i: 0
                    min: 0
                    name: before
                    nobind: 1
                    r: 1
                    re: !!perl/hash:RE_ast
                      decl: []
                      min: 1
                      re: !!perl/hash:RE_string
                        a: 0
                        dba: colon pair (restricted)
                        i: 0
                        min: 1
                        r: 1
                        s: 0
                        text: (
                    s: 0
                - !!perl/hash:RE_method
                  a: 0
                  dba: colon pair (restricted)
                  i: 0
                  min: 12345
                  name: circumfix
                  r: 1
                  rest: ''
                  s: 0
                - !!perl/hash:RE_block
                  a: 0
                  context: void
                  dba: colon pair (restricted)
                  i: 0
                  min: 0
                  r: 1
                  s: 0
                  text: ' $value = $<circumfix>; '
              - !!perl/hash:RE_block
                a: 0
                context: void
                dba: colon pair (restricted)
                i: 0
                min: 0
                r: 1
                s: 0
                text: ' $value = 1; '
        - !!perl/hash:RE_sequence
          a: 0
          alt: quotepair_01 2
          dba: colon pair (restricted)
          i: 0
          min: 2
          r: 1
          s: 0
          zyg:
          - !!perl/hash:RE_bindnamed
            a: 0
            atom: !!perl/hash:RE_paren
              decl: []
              min: 1
              re: !!perl/hash:RE_quantified_atom
                atom: !!perl/hash:RE_meta
                  a: 0
                  dba: colon pair (restricted)
                  i: 0
                  min: 1
                  r: 1
                  s: 0
                  text: \d
                min: 1
                quant:
                - +
                - ':'
                - ''
                - 1
            dba: colon pair (restricted)
            i: 0
            min: 1
            r: 1
            s: 0
            var: n
          - !!perl/hash:RE_bindnamed
            a: 0
            atom: !!perl/hash:RE_paren
              decl: []
              min: 1
              re: !!perl/hash:RE_quantified_atom
                atom: !!perl/hash:RE_cclass
                  a: 0
                  dba: colon pair (restricted)
                  i: 0
                  min: 1
                  r: 1
                  s: 0
                  text: '[a..z]'
                min: 1
                quant:
                - +
                - ':'
                - ''
                - 1
            dba: colon pair (restricted)
            i: 0
            min: 1
            r: 1
            s: 0
            var: id
          - !!perl/hash:RE_quantified_atom
            atom: !!perl/hash:RE_bracket
              decl: []
              min: 1
              re: !!perl/hash:RE_sequence
                a: 0
                dba: colon pair (restricted)
                i: 0
                min: 1
                r: 1
                s: 0
                zyg:
                - !!perl/hash:RE_string
                  a: 0
                  dba: colon pair (restricted)
                  i: 0
                  min: 1
                  r: 1
                  s: 0
                  text: (
                - !!perl/hash:RE_method
                  min: 0
                  name: panic
                  nobind: 1
                  rest: ("2nd argument not allowed on pair")
            min: 0
            quant:
            - '?'
            - ':'
            - ''
            - 0
          - !!perl/hash:RE_block
            a: 0
            context: void
            dba: colon pair (restricted)
            i: 0
            min: 0
            r: 1
            s: 0
            text: ' $key = $<id>.Str; $value = $<n>.Str; '
    - !!perl/hash:RE_block
      a: 0
      context: void
      dba: colon pair (restricted)
      i: 0
      min: 0
      r: 1
      s: 0
      text: ' $<k> = $key; $<v> = $value; '
quotepair_01: *12
rad_number: !!perl/hash:RE_ast
  decl: []
  kind: token
  min: 2
  pkg: ~
  re: !!perl/hash:RE_sequence
    a: 0
    dba: number in radix notation
    i: 0
    min: 2
    r: 1
    s: 0
    zyg:
    - !!perl/hash:RE_string
      a: 0
      dba: rad_number
      i: 0
      min: 1
      r: 1
      s: 0
      text: ':'
    - !!perl/hash:RE_bindnamed
      a: 0
      atom: !!perl/hash:RE_bracket
        decl: []
        min: 1
        re: !!perl/hash:RE_quantified_atom
          atom: !!perl/hash:RE_meta
            a: 0
            dba: rad_number
            i: 0
            min: 1
            r: 1
            s: 0
            text: \d
          min: 1
          quant:
          - +
          - ':'
          - ''
          - 1
      dba: rad_number
      i: 0
      min: 1
      r: 1
      s: 0
      var: radix
    - !!perl/hash:RE_quantified_atom
      atom: !!perl/hash:RE_method
        a: 0
        dba: rad_number
        i: 0
        min: 12345
        name: unsp
        nobind: 1
        r: 1
        rest: ''
        s: 0
      min: 0
      quant:
      - '?'
      - ':'
      - ''
      - 0
    - !!perl/hash:RE_block
      a: 0
      context: void
      dba: rad_number
      i: 0
      min: 0
      r: 1
      s: 0
      text: ''
    - !!perl/hash:RE_bracket
      decl: []
      min: 0
      re: !!perl/hash:RE_first
        a: 0
        dba: number in radix notation
        i: 0
        min: 0
        r: 1
        s: 0
        zyg:
        - !!perl/hash:RE_sequence
          a: 0
          dba: number in radix notation
          i: 0
          min: 12347
          r: 1
          s: 0
          zyg:
          - !!perl/hash:RE_string
            a: 0
            dba: number in radix notation
            i: 0
            min: 1
            r: 1
            s: 0
            text: <
          - !!perl/hash:RE_bracket
            decl: []
            min: 12345
            re: &13 !!perl/hash:RE_any
              a: 0
              altname: rad_number_03
              dba: number in radix notation
              i: 0
              min: 12345
              name: rad_number_03
              r: 1
              s: 0
              zyg:
              - !!perl/hash:RE_bindnamed
                a: 0
                alt: rad_number_03 0
                atom: !!perl/hash:RE_bracket
                  decl: []
                  min: 12346
                  re: !!perl/hash:RE_sequence
                    a: 0
                    dba: number in radix notation
                    i: 0
                    min: 12346
                    r: 1
                    s: 0
                    zyg:
                    - !!perl/hash:RE_string
                      a: 0
                      dba: number in radix notation
                      i: 0
                      min: 1
                      r: 1
                      s: 0
                      text: .
                    - !!perl/hash:RE_bindnamed
                      a: 0
                      atom: !!perl/hash:RE_method
                        a: 0
                        dba: number in radix notation
                        i: 0
                        min: 12345
                        name: alnumint
                        nobind: 1
                        r: 1
                        rest: ''
                        s: 0
                      dba: number in radix notation
                      i: 0
                      min: 12345
                      r: 1
                      s: 0
                      var: frac
                dba: number in radix notation
                i: 0
                min: 12346
                r: 1
                s: 0
                var: coeff
              - !!perl/hash:RE_bindnamed
                a: 0
                alt: rad_number_03 1
                atom: !!perl/hash:RE_bracket
                  decl: []
                  min: 24691
                  re: !!perl/hash:RE_sequence
                    a: 0
                    dba: number in radix notation
                    i: 0
                    min: 24691
                    r: 1
                    s: 0
                    zyg:
                    - !!perl/hash:RE_bindnamed
                      a: 0
                      atom: !!perl/hash:RE_method
                        a: 0
                        dba: number in radix notation
                        i: 0
                        min: 12345
                        name: alnumint
                        nobind: 1
                        r: 1
                        rest: ''
                        s: 0
                      dba: number in radix notation
                      i: 0
                      min: 12345
                      r: 1
                      s: 0
                      var: int
                    - !!perl/hash:RE_string
                      a: 0
                      dba: number in radix notation
                      i: 0
                      min: 1
                      r: 1
                      s: 0
                      text: .
                    - !!perl/hash:RE_bindnamed
                      a: 0
                      atom: !!perl/hash:RE_method
                        a: 0
                        dba: number in radix notation
                        i: 0
                        min: 12345
                        name: alnumint
                        nobind: 1
                        r: 1
                        rest: ''
                        s: 0
                      dba: number in radix notation
                      i: 0
                      min: 12345
                      r: 1
                      s: 0
                      var: frac
                dba: number in radix notation
                i: 0
                min: 24691
                r: 1
                s: 0
                var: coeff
              - !!perl/hash:RE_bindnamed
                a: 0
                alt: rad_number_03 2
                atom: !!perl/hash:RE_bracket
                  decl: []
                  min: 12345
                  re: !!perl/hash:RE_bindnamed
                    a: 0
                    atom: !!perl/hash:RE_method
                      a: 0
                      dba: number in radix notation
                      i: 0
                      min: 12345
                      name: alnumint
                      nobind: 1
                      r: 1
                      rest: ''
                      s: 0
                    dba: number in radix notation
                    i: 0
                    min: 12345
                    r: 1
                    s: 0
                    var: int
                dba: number in radix notation
                i: 0
                min: 12345
                r: 1
                s: 0
                var: coeff
          - !!perl/hash:RE_quantified_atom
            atom: !!perl/hash:RE_bracket
              decl: []
              min: 24691
              re: !!perl/hash:RE_sequence
                a: 0
                dba: number in radix notation
                i: 0
                min: 24691
                r: 1
                s: 0
                zyg:
                - !!perl/hash:RE_string
                  a: 0
                  dba: number in radix notation
                  i: 0
                  min: 1
                  r: 1
                  s: 0
                  text: '*'
                - !!perl/hash:RE_bindnamed
                  a: 0
                  atom: !!perl/hash:RE_method
                    a: 0
                    dba: number in radix notation
                    i: 0
                    min: 12345
                    name: radint
                    nobind: 1
                    r: 1
                    rest: ''
                    s: 0
                  dba: number in radix notation
                  i: 0
                  min: 12345
                  r: 1
                  s: 0
                  var: base
                - !!perl/hash:RE_bracket
                  decl: []
                  min: 0
                  re: !!perl/hash:RE_first
                    a: 0
                    dba: number in radix notation
                    i: 0
                    min: 0
                    r: 1
                    s: 0
                    zyg:
                    - !!perl/hash:RE_string
                      a: 0
                      dba: number in radix notation
                      i: 0
                      min: 2
                      r: 1
                      s: 0
                      text: '**'
                    - !!perl/hash:RE_method
                      min: 0
                      name: panic
                      nobind: 1
                      rest: ("Base is missing ** exponent part")
                - !!perl/hash:RE_bindnamed
                  a: 0
                  atom: !!perl/hash:RE_method
                    a: 0
                    dba: number in radix notation
                    i: 0
                    min: 12345
                    name: radint
                    nobind: 1
                    r: 1
                    rest: ''
                    s: 0
                  dba: number in radix notation
                  i: 0
                  min: 12345
                  r: 1
                  s: 0
                  var: exp
            min: 0
            quant:
            - '?'
            - ':'
            - ''
            - 0
          - !!perl/hash:RE_string
            a: 0
            dba: number in radix notation
            i: 0
            min: 1
            r: 1
            s: 0
            text: '>'
        - !!perl/hash:RE_sequence
          a: 0
          dba: number in radix notation
          i: 0
          min: 12345
          r: 1
          s: 0
          zyg:
          - !!perl/hash:RE_assertion
            assert: '?'
            min: 0
            re: !!perl/hash:RE_method_re
              a: 0
              dba: number in radix notation
              i: 0
              min: 0
              name: before
              nobind: 1
              r: 1
              re: !!perl/hash:RE_ast
                decl: []
                min: 1
                re: !!perl/hash:RE_string
                  a: 0
                  dba: number in radix notation
                  i: 0
                  min: 1
                  r: 1
                  s: 0
                  text: '['
              s: 0
          - !!perl/hash:RE_method
            a: 0
            dba: number in radix notation
            i: 0
            min: 12345
            name: circumfix
            r: 1
            rest: ''
            s: 0
        - !!perl/hash:RE_sequence
          a: 0
          dba: number in radix notation
          i: 0
          min: 12345
          r: 1
          s: 0
          zyg:
          - !!perl/hash:RE_assertion
            assert: '?'
            min: 0
            re: !!perl/hash:RE_method_re
              a: 0
              dba: number in radix notation
              i: 0
              min: 0
              name: before
              nobind: 1
              r: 1
              re: !!perl/hash:RE_ast
                decl: []
                min: 1
                re: !!perl/hash:RE_string
                  a: 0
                  dba: number in radix notation
                  i: 0
                  min: 1
                  r: 1
                  s: 0
                  text: (
              s: 0
          - !!perl/hash:RE_method
            a: 0
            dba: number in radix notation
            i: 0
            min: 12345
            name: circumfix
            r: 1
            rest: ''
            s: 0
        - !!perl/hash:RE_method
          min: 0
          name: panic
          nobind: 1
          rest: ("Malformed radix number")
rad_number_03: *13
radint: !!perl/hash:RE_ast
  decl: []
  kind: token
  min: 12345
  pkg: ~
  re: !!perl/hash:RE_bracket
    decl: []
    min: 12345
    re: &14 !!perl/hash:RE_any
      a: 0
      altname: radint_01
      dba: radint
      i: 0
      min: 12345
      name: radint_01
      r: 1
      s: 0
      zyg:
      - !!perl/hash:RE_method
        a: 0
        alt: radint_01 0
        dba: radint
        i: 0
        min: 12345
        name: integer
        r: 1
        rest: ''
        s: 0
      - !!perl/hash:RE_sequence
        a: 0
        alt: radint_01 1
        dba: radint
        i: 0
        min: 12345
        r: 1
        s: 0
        zyg:
        - !!perl/hash:RE_assertion
          assert: '?'
          min: 0
          re: !!perl/hash:RE_method_re
            a: 0
            dba: radint
            i: 0
            min: 0
            name: before
            nobind: 1
            r: 1
            re: !!perl/hash:RE_ast
              decl: []
              min: 2
              re: !!perl/hash:RE_sequence
                a: 0
                dba: radint
                i: 0
                min: 2
                r: 1
                s: 0
                zyg:
                - !!perl/hash:RE_string
                  a: 0
                  dba: radint
                  i: 0
                  min: 1
                  r: 1
                  s: 0
                  text: ':'
                - !!perl/hash:RE_meta
                  a: 0
                  dba: radint
                  i: 0
                  min: 1
                  r: 1
                  s: 0
                  text: \d
            s: 0
        - !!perl/hash:RE_method
          a: 0
          dba: radint
          i: 0
          min: 12345
          name: rad_number
          r: 1
          rest: ''
          s: 0
        - !!perl/hash:RE_assertion
          assert: '?'
          min: 0
          re: !!perl/hash:RE_block
            a: 0
            context: bool
            dba: radint
            i: 0
            min: 0
            nobind: 1
            r: 1
            s: 0
            text: "\n                        defined $<rad_number><intpart>\n                        and\n
              \                       not defined $<rad_number><fracpart>\n                    "
radint_01: *14
sigil__S_036Dollar: !!perl/hash:RE_ast
  decl: []
  kind: token
  min: 12345
  pkg: ~
  re: !!perl/hash:RE_method
    a: 0
    dba: sigil__S_036Dollar
    i: 0
    min: 12345
    name: sym
    r: 1
    rest: ''
    s: 0
    sym: $
sigil__S_037At: !!perl/hash:RE_ast
  decl: []
  kind: token
  min: 12345
  pkg: ~
  re: !!perl/hash:RE_method
    a: 0
    dba: sigil__S_037At
    i: 0
    min: 12345
    name: sym
    r: 1
    rest: ''
    s: 0
    sym: '@'
sigil__S_038Percent: !!perl/hash:RE_ast
  decl: []
  kind: token
  min: 12345
  pkg: ~
  re: !!perl/hash:RE_method
    a: 0
    dba: sigil__S_038Percent
    i: 0
    min: 12345
    name: sym
    r: 1
    rest: ''
    s: 0
    sym: '%'
sigil__S_039Amp: !!perl/hash:RE_ast
  decl: []
  kind: token
  min: 12345
  pkg: ~
  re: !!perl/hash:RE_method
    a: 0
    dba: sigil__S_039Amp
    i: 0
    min: 12345
    name: sym
    r: 1
    rest: ''
    s: 0
    sym: '&'
spacey: !!perl/hash:RE_ast
  decl: []
  kind: token
  min: 0
  pkg: ~
  re: !!perl/hash:RE_assertion
    assert: '?'
    min: 0
    re: !!perl/hash:RE_method_re
      a: 0
      dba: spacey
      i: 0
      min: 0
      name: before
      nobind: 1
      r: 1
      re: !!perl/hash:RE_ast
        decl: []
        min: 1
        re: !!perl/hash:RE_cclass
          a: 0
          dba: spacey
          i: 0
          min: 1
          r: 1
          s: 0
          text: '[ \s \# ]'
      s: 0
starter: !!perl/hash:RE_ast
  decl: []
  kind: token
  min: 0
  pkg: ~
  re: !!perl/hash:RE_assertion
    assert: '!'
    min: 0
    re: !!perl/hash:RE_noop
      a: 0
      dba: starter
      i: 0
      min: 0
      nobind: 1
      r: 1
      s: 0
stdstopper: !!perl/hash:RE_ast
  decl:
  - !!perl/hash:RE_decl
    a: 0
    dba: stdstopper
    i: 0
    max: 0
    min: 0
    r: 0
    s: 0
    text: my @stub = return self if @*MEMOS[self.pos]<endstmt> :exists
  kind: regex
  min: 0
  pkg: ~
  re: !!perl/hash:RE_sequence
    a: 0
    dba: standard stopper
    i: 0
    min: 0
    r: 0
    s: 0
    zyg:
    - !!perl/hash:RE_bracket
      decl: []
      min: 0
      re: &15 !!perl/hash:RE_any
        a: 0
        altname: stdstopper_01
        dba: standard stopper
        i: 0
        min: 0
        name: stdstopper_01
        r: 0
        s: 0
        zyg:
        - !!perl/hash:RE_assertion
          alt: stdstopper_01 0
          assert: '?'
          min: 0
          re: !!perl/hash:RE_method
            a: 0
            dba: standard stopper
            i: 0
            min: 12345
            name: terminator
            nobind: 1
            r: 0
            rest: ''
            s: 0
        - !!perl/hash:RE_assertion
          alt: stdstopper_01 1
          assert: '?'
          min: 0
          re: !!perl/hash:RE_method
            a: 0
            dba: standard stopper
            i: 0
            min: 12345
            name: unitstopper
            nobind: 1
            r: 0
            rest: ''
            s: 0
        - !!perl/hash:RE_meta
          a: 0
          alt: stdstopper_01 2
          dba: standard stopper
          i: 0
          min: 0
          r: 0
          s: 0
          text: $
    - !!perl/hash:RE_block
      a: 0
      context: void
      dba: standard stopper
      i: 0
      min: 0
      r: 0
      s: 0
      text: ' @*MEMOS[$.pos]<endstmt> ||= 1; '
stdstopper_01: *15
stopper: !!perl/hash:RE_ast
  decl: []
  kind: token
  min: 0
  pkg: ~
  re: !!perl/hash:RE_assertion
    assert: '!'
    min: 0
    re: !!perl/hash:RE_noop
      a: 0
      dba: stopper
      i: 0
      min: 0
      nobind: 1
      r: 1
      s: 0
term__S_564miscbad: !!perl/hash:RE_ast
  decl: []
  kind: token
  min: 0
  pkg: ~
  re: !!perl/hash:RE_sequence
    a: 0
    dba: term__S_564miscbad
    i: 0
    min: 0
    r: 1
    s: 0
    zyg:
    - !!perl/hash:RE_block
      a: 0
      context: void
      dba: term__S_564miscbad
      i: 0
      min: 0
      r: 1
      s: 0
      text: ''
    - !!perl/hash:RE_assertion
      assert: '!'
      min: 0
      re: !!perl/hash:RE_block
        a: 0
        context: bool
        dba: term__S_564miscbad
        i: 0
        min: 0
        nobind: 1
        r: 1
        s: 0
        text: ' $*QSIGIL '
    - !!perl/hash:RE_block
      a: 0
      context: void
      dba: term__S_564miscbad
      i: 0
      min: 0
      r: 1
      s: 0
      text: "\n        my ($bad) = try {\n            $.infixish;\n        };\n        $*HIGHWATER
        = -1;\n        $*HIGHMESS = '';\n        self.badinfix($bad.Str) if $bad;\n
        \   "
    - !!perl/hash:RE_assertion
      assert: '!'
      min: 0
      re: !!perl/hash:RE_noop
        a: 0
        dba: term__S_564miscbad
        i: 0
        min: 0
        nobind: 1
        r: 1
        s: 0
terminator__S_059Thesis: !!perl/hash:RE_ast
  decl: []
  kind: token
  min: 12345
  pkg: ~
  re: !!perl/hash:RE_sequence
    a: 0
    dba: terminator__S_059Thesis
    i: 0
    min: 12345
    r: 1
    s: 0
    zyg:
    - !!perl/hash:RE_method
      a: 0
      dba: terminator__S_059Thesis
      i: 0
      min: 12345
      name: sym
      r: 1
      rest: ''
      s: 0
      sym: )
    - !!perl/hash:RE_method
      min: 0
      name: O
      rest: (|%terminator)
terminator__S_060Ket: !!perl/hash:RE_ast
  decl: []
  kind: token
  min: 1
  pkg: ~
  re: !!perl/hash:RE_sequence
    a: 0
    dba: terminator__S_060Ket
    i: 0
    min: 1
    r: 1
    s: 0
    zyg:
    - !!perl/hash:RE_string
      a: 0
      dba: terminator__S_060Ket
      i: 0
      min: 1
      r: 1
      s: 0
      text: ']'
    - !!perl/hash:RE_method
      min: 0
      name: O
      rest: (|%terminator)
terminator__S_061Ly: !!perl/hash:RE_ast
  decl: []
  kind: token
  min: 1
  pkg: ~
  re: !!perl/hash:RE_sequence
    a: 0
    dba: terminator__S_061Ly
    i: 0
    min: 1
    r: 1
    s: 0
    zyg:
    - !!perl/hash:RE_string
      a: 0
      dba: terminator__S_061Ly
      i: 0
      min: 1
      r: 1
      s: 0
      text: '}'
    - !!perl/hash:RE_method
      min: 0
      name: O
      rest: (|%terminator)
twigil__S_040Dot: !!perl/hash:RE_ast
  decl: []
  kind: token
  min: 24690
  pkg: ~
  re: !!perl/hash:RE_sequence
    a: 0
    dba: twigil__S_040Dot
    i: 0
    min: 24690
    r: 1
    s: 0
    zyg:
    - !!perl/hash:RE_method
      a: 0
      dba: twigil__S_040Dot
      endsym: begid
      i: 0
      min: 12345
      name: sym
      r: 1
      rest: ''
      s: 0
      sym: .
    - !!perl/hash:RE_method
      a: 0
      dba: twigil__S_040Dot
      i: 0
      min: 12345
      name: begid
      nobind: 1
      r: 1
      rest: ''
      s: 0
twigil__S_041Bang: !!perl/hash:RE_ast
  decl: []
  kind: token
  min: 24690
  pkg: ~
  re: !!perl/hash:RE_sequence
    a: 0
    dba: twigil__S_041Bang
    i: 0
    min: 24690
    r: 1
    s: 0
    zyg:
    - !!perl/hash:RE_method
      a: 0
      dba: twigil__S_041Bang
      endsym: begid
      i: 0
      min: 12345
      name: sym
      r: 1
      rest: ''
      s: 0
      sym: '!'
    - !!perl/hash:RE_method
      a: 0
      dba: twigil__S_041Bang
      i: 0
      min: 12345
      name: begid
      nobind: 1
      r: 1
      rest: ''
      s: 0
twigil__S_042Caret: !!perl/hash:RE_ast
  decl: []
  kind: token
  min: 24690
  pkg: ~
  re: !!perl/hash:RE_sequence
    a: 0
    dba: twigil__S_042Caret
    i: 0
    min: 24690
    r: 1
    s: 0
    zyg:
    - !!perl/hash:RE_method
      a: 0
      dba: twigil__S_042Caret
      endsym: begid
      i: 0
      min: 12345
      name: sym
      r: 1
      rest: ''
      s: 0
      sym: ^
    - !!perl/hash:RE_method
      a: 0
      dba: twigil__S_042Caret
      i: 0
      min: 12345
      name: begid
      nobind: 1
      r: 1
      rest: ''
      s: 0
twigil__S_043Colon: !!perl/hash:RE_ast
  decl: []
  kind: token
  min: 24690
  pkg: ~
  re: !!perl/hash:RE_sequence
    a: 0
    dba: twigil__S_043Colon
    i: 0
    min: 24690
    r: 1
    s: 0
    zyg:
    - !!perl/hash:RE_method
      a: 0
      dba: twigil__S_043Colon
      endsym: begid
      i: 0
      min: 12345
      name: sym
      r: 1
      rest: ''
      s: 0
      sym: ':'
    - !!perl/hash:RE_method
      a: 0
      dba: twigil__S_043Colon
      i: 0
      min: 12345
      name: begid
      nobind: 1
      r: 1
      rest: ''
      s: 0
twigil__S_044Star: !!perl/hash:RE_ast
  decl: []
  kind: token
  min: 24690
  pkg: ~
  re: !!perl/hash:RE_sequence
    a: 0
    dba: twigil__S_044Star
    i: 0
    min: 24690
    r: 1
    s: 0
    zyg:
    - !!perl/hash:RE_method
      a: 0
      dba: twigil__S_044Star
      endsym: begid
      i: 0
      min: 12345
      name: sym
      r: 1
      rest: ''
      s: 0
      sym: '*'
    - !!perl/hash:RE_method
      a: 0
      dba: twigil__S_044Star
      i: 0
      min: 12345
      name: begid
      nobind: 1
      r: 1
      rest: ''
      s: 0
twigil__S_045Question: !!perl/hash:RE_ast
  decl: []
  kind: token
  min: 24690
  pkg: ~
  re: !!perl/hash:RE_sequence
    a: 0
    dba: twigil__S_045Question
    i: 0
    min: 24690
    r: 1
    s: 0
    zyg:
    - !!perl/hash:RE_method
      a: 0
      dba: twigil__S_045Question
      endsym: begid
      i: 0
      min: 12345
      name: sym
      r: 1
      rest: ''
      s: 0
      sym: '?'
    - !!perl/hash:RE_method
      a: 0
      dba: twigil__S_045Question
      i: 0
      min: 12345
      name: begid
      nobind: 1
      r: 1
      rest: ''
      s: 0
twigil__S_046Equal: !!perl/hash:RE_ast
  decl: []
  kind: token
  min: 24690
  pkg: ~
  re: !!perl/hash:RE_sequence
    a: 0
    dba: twigil__S_046Equal
    i: 0
    min: 24690
    r: 1
    s: 0
    zyg:
    - !!perl/hash:RE_method
      a: 0
      dba: twigil__S_046Equal
      endsym: begid
      i: 0
      min: 12345
      name: sym
      r: 1
      rest: ''
      s: 0
      sym: =
    - !!perl/hash:RE_method
      a: 0
      dba: twigil__S_046Equal
      i: 0
      min: 12345
      name: begid
      nobind: 1
      r: 1
      rest: ''
      s: 0
twigil__S_047Tilde: !!perl/hash:RE_ast
  decl: []
  kind: token
  min: 24690
  pkg: ~
  re: !!perl/hash:RE_sequence
    a: 0
    dba: twigil__S_047Tilde
    i: 0
    min: 24690
    r: 1
    s: 0
    zyg:
    - !!perl/hash:RE_method
      a: 0
      dba: twigil__S_047Tilde
      endsym: begid
      i: 0
      min: 12345
      name: sym
      r: 1
      rest: ''
      s: 0
      sym: '~'
    - !!perl/hash:RE_method
      a: 0
      dba: twigil__S_047Tilde
      i: 0
      min: 12345
      name: begid
      nobind: 1
      r: 1
      rest: ''
      s: 0
unitstopper: !!perl/hash:RE_ast
  decl: []
  kind: token
  min: 0
  pkg: ~
  re: !!perl/hash:RE_meta
    a: 0
    dba: unitstopper
    i: 0
    min: 0
    r: 1
    s: 0
    text: $
unsp: !!perl/hash:RE_ast
  decl: []
  kind: token
  min: 1
  pkg: ~
  re: !!perl/hash:RE_sequence
    a: 0
    dba: unspace
    i: 0
    min: 1
    r: 1
    s: 0
    zyg:
    - !!perl/hash:RE_string
      a: 0
      dba: unsp
      i: 0
      min: 1
      r: 1
      s: 0
      text: \
    - !!perl/hash:RE_assertion
      assert: '?'
      min: 0
      re: !!perl/hash:RE_method_re
        a: 0
        dba: unsp
        i: 0
        min: 0
        name: before
        nobind: 1
        r: 1
        re: !!perl/hash:RE_ast
          decl: []
          min: 1
          re: !!perl/hash:RE_bracket
            decl: []
            min: 1
            re: &16 !!perl/hash:RE_any
              a: 0
              altname: unsp_02
              dba: unsp
              i: 0
              min: 1
              name: unsp_02
              r: 1
              s: 0
              zyg:
              - !!perl/hash:RE_meta
                a: 0
                alt: unsp_02 0
                dba: unsp
                i: 0
                min: 1
                r: 1
                s: 0
                text: \s
              - !!perl/hash:RE_string
                a: 0
                alt: unsp_02 1
                dba: unsp
                i: 0
                min: 1
                r: 1
                s: 0
                text: '#'
        s: 0
    - !!perl/hash:RE_quantified_atom
      atom: !!perl/hash:RE_bracket
        decl: []
        min: 0
        re: &17 !!perl/hash:RE_any
          a: 0
          altname: unsp_03
          dba: unspace
          i: 0
          min: 0
          name: unsp_03
          r: 1
          s: 0
          zyg:
          - !!perl/hash:RE_method
            a: 0
            alt: unsp_03 0
            dba: unspace
            i: 0
            min: 12345
            name: vws
            nobind: 1
            r: 1
            rest: ''
            s: 0
          - !!perl/hash:RE_method
            a: 0
            alt: unsp_03 1
            dba: unspace
            i: 0
            min: 12345
            name: unv
            nobind: 1
            r: 1
            rest: ''
            s: 0
          - !!perl/hash:RE_sequence
            a: 0
            alt: unsp_03 2
            dba: unspace
            i: 0
            min: 0
            r: 1
            s: 0
            zyg:
            - !!perl/hash:RE_meta
              a: 0
              dba: unspace
              i: 0
              min: 0
              r: 1
              s: 0
              text: $
            - !!perl/hash:RE_block
              a: 0
              context: void
              dba: unspace
              i: 0
              min: 0
              r: 1
              s: 0
              text: ' $.moreinput '
      min: 0
      quant:
      - '*'
      - ':'
      - ''
      - 0
unsp_02: *16
unsp_03: *17
unspacey: !!perl/hash:RE_ast
  decl: []
  kind: token
  min: 0
  pkg: ~
  re: !!perl/hash:RE_quantified_atom
    atom: !!perl/hash:RE_method
      a: 0
      dba: unspacey
      i: 0
      min: 12345
      name: unsp
      nobind: 1
      r: 1
      rest: ''
      s: 0
    min: 0
    quant:
    - '?'
    - ':'
    - ''
    - 0
unv: !!perl/hash:RE_ast
  decl: []
  kind: token
  min: 1
  pkg: ~
  re: !!perl/hash:RE_bracket
    decl: []
    min: 1
    re: &18 !!perl/hash:RE_any
      a: 0
      altname: unv_01
      dba: horizontal whitespace
      i: 0
      min: 1
      name: unv_01
      r: 1
      s: 0
      zyg:
      - !!perl/hash:RE_quantified_atom
        alt: unv_01 0
        atom: !!perl/hash:RE_meta
          a: 0
          dba: horizontal whitespace
          i: 0
          min: 1
          r: 1
          s: 0
          text: \h
        min: 1
        quant:
        - +
        - ':'
        - ''
        - 1
      - !!perl/hash:RE_sequence
        a: 0
        alt: unv_01 1
        dba: horizontal whitespace
        i: 0
        min: 12345
        r: 1
        s: 0
        zyg:
        - !!perl/hash:RE_assertion
          assert: '?'
          min: 0
          re: !!perl/hash:RE_method_re
            a: 0
            dba: horizontal whitespace
            i: 0
            min: 0
            name: before
            nobind: 1
            r: 1
            re: !!perl/hash:RE_ast
              decl: []
              min: 2
              re: !!perl/hash:RE_sequence
                a: 0
                dba: horizontal whitespace
                i: 0
                min: 2
                r: 1
                s: 0
                zyg:
                - !!perl/hash:RE_quantified_atom
                  atom: !!perl/hash:RE_meta
                    a: 0
                    dba: horizontal whitespace
                    i: 0
                    min: 1
                    r: 1
                    s: 0
                    text: \h
                  min: 0
                  quant:
                  - '*'
                  - ':'
                  - ''
                  - 0
                - !!perl/hash:RE_string
                  a: 0
                  dba: horizontal whitespace
                  i: 0
                  min: 1
                  r: 1
                  s: 0
                  text: =
                - !!perl/hash:RE_bracket
                  decl: []
                  min: 1
                  re: &19 !!perl/hash:RE_any
                    a: 0
                    altname: unv_03
                    dba: horizontal whitespace
                    i: 0
                    min: 1
                    name: unv_03
                    r: 1
                    s: 0
                    zyg:
                    - !!perl/hash:RE_meta
                      a: 0
                      alt: unv_03 0
                      dba: horizontal whitespace
                      i: 0
                      min: 1
                      r: 1
                      s: 0
                      text: \w
                    - !!perl/hash:RE_string
                      a: 0
                      alt: unv_03 1
                      dba: horizontal whitespace
                      i: 0
                      min: 1
                      r: 1
                      s: 0
                      text: \
            s: 0
        - !!perl/hash:RE_meta
          a: 0
          dba: horizontal whitespace
          i: 0
          min: 0
          r: 1
          s: 0
          text: ^^
        - !!perl/hash:RE_method
          a: 0
          dba: horizontal whitespace
          i: 0
          min: 12345
          name: pod_comment
          nobind: 1
          r: 1
          rest: ''
          s: 0
      - !!perl/hash:RE_sequence
        a: 0
        alt: unv_01 2
        dba: horizontal whitespace
        i: 0
        min: 12345
        r: 1
        s: 0
        zyg:
        - !!perl/hash:RE_quantified_atom
          atom: !!perl/hash:RE_meta
            a: 0
            dba: horizontal whitespace
            i: 0
            min: 1
            r: 1
            s: 0
            text: \h
          min: 0
          quant:
          - '*'
          - ':'
          - ''
          - 0
        - !!perl/hash:RE_method
          a: 0
          dba: horizontal whitespace
          i: 0
          min: 12345
          name: comment
          r: 1
          rest: ''
          s: 0
unv_01: *18
unv_03: *19
vws: !!perl/hash:RE_ast
  decl: []
  kind: token
  min: 1
  pkg: ~
  re: !!perl/hash:RE_sequence
    a: 0
    dba: vertical whitespace
    i: 0
    min: 1
    r: 1
    s: 0
    zyg:
    - !!perl/hash:RE_meta
      a: 0
      dba: vertical whitespace
      i: 0
      min: 1
      r: 1
      s: 0
      text: \v
    - !!perl/hash:RE_quantified_atom
      atom: !!perl/hash:RE_bracket
        decl: []
        min: 9
        re: !!perl/hash:RE_sequence
          a: 0
          dba: vertical whitespace
          i: 0
          min: 9
          r: 1
          s: 0
          zyg:
          - !!perl/hash:RE_string
            a: 0
            dba: vertical whitespace
            i: 0
            min: 9
            r: 1
            s: 0
            text: '#DEBUG -1'
          - !!perl/hash:RE_block
            a: 0
            context: void
            dba: vertical whitespace
            i: 0
            min: 0
            r: 1
            s: 0
            text: ' say "DEBUG"; $*DEBUG = -1; '
      min: 0
      quant:
      - '?'
      - ':'
      - ''
      - 0
ws: !!perl/hash:RE_ast
  decl:
  - !!perl/hash:RE_decl
    a: 0
    dba: ws
    i: 0
    max: 0
    min: 0
    r: 1
    s: 0
    text: my @stub = return self if @*MEMOS[self.pos]<ws> :exists
  - !!perl/hash:RE_decl
    a: 0
    dba: ws
    i: 0
    max: 0
    min: 0
    r: 1
    s: 0
    text: my $startpos = self.pos
  - !!perl/hash:RE_decl
    a: 0
    dba: ws
    i: 0
    max: 0
    min: 0
    r: 1
    s: 0
    text: my $*HIGHEXPECT = {}
  kind: token
  min: 0
  pkg: ~
  re: !!perl/hash:RE_first
    a: 0
    dba: whitespace
    i: 0
    min: 0
    r: 1
    s: 0
    zyg:
    - !!perl/hash:RE_bracket
      decl: []
      min: 0
      re: &20 !!perl/hash:RE_any
        a: 0
        altname: ws_01
        dba: whitespace
        i: 0
        min: 0
        name: ws_01
        r: 1
        s: 0
        zyg:
        - !!perl/hash:RE_sequence
          a: 0
          alt: ws_01 0
          dba: whitespace
          i: 0
          min: 1
          r: 1
          s: 0
          zyg:
          - !!perl/hash:RE_quantified_atom
            atom: !!perl/hash:RE_meta
              a: 0
              dba: whitespace
              i: 0
              min: 1
              r: 1
              s: 0
              text: \h
            min: 1
            quant:
            - +
            - ':'
            - ''
            - 1
          - !!perl/hash:RE_assertion
            assert: '!'
            min: 0
            re: !!perl/hash:RE_cclass
              a: 0
              dba: whitespace
              i: 0
              min: 1
              nobind: 1
              r: 1
              s: 0
              text: '[#\s\\]'
          - !!perl/hash:RE_block
            a: 0
            context: void
            dba: whitespace
            i: 0
            min: 0
            r: 1
            s: 0
            text: ' @*MEMOS[$.pos]<ws> = $startpos; '
        - !!perl/hash:RE_sequence
          a: 0
          alt: ws_01 1
          dba: whitespace
          i: 0
          min: 0
          r: 1
          s: 0
          zyg:
          - !!perl/hash:RE_assertion
            assert: '?'
            min: 0
            re: !!perl/hash:RE_method_re
              a: 0
              dba: whitespace
              i: 0
              min: 0
              name: before
              nobind: 1
              r: 1
              re: !!perl/hash:RE_ast
                decl: []
                min: 1
                re: !!perl/hash:RE_meta
                  a: 0
                  dba: whitespace
                  i: 0
                  min: 1
                  r: 1
                  s: 0
                  text: \w
              s: 0
          - !!perl/hash:RE_assertion
            assert: '?'
            min: 0
            re: !!perl/hash:RE_method_re
              a: 0
              dba: whitespace
              i: 0
              min: 0
              name: after
              nobind: 1
              r: 1
              re: !!perl/hash:RE_ast
                decl: []
                min: 1
                re: !!perl/hash:RE_meta
                  a: 0
                  dba: whitespace
                  i: 0
                  min: 1
                  r: 1
                  s: 0
                  text: \w
              s: 0
          - !!perl/hash:RE_meta
            a: 0
            dba: whitespace
            i: 0
            min: 0
            r: 1
            s: 0
            text: ':::'
          - !!perl/hash:RE_block
            a: 0
            context: void
            dba: whitespace
            i: 0
            min: 0
            r: 1
            s: 0
            text: ' @*MEMOS[$startpos]<ws>:delete; '
          - !!perl/hash:RE_method
            min: 0
            name: panic
            nobind: 1
            rest: ("Whitespace is required between alphanumeric tokens")
    - !!perl/hash:RE_sequence
      a: 0
      dba: whitespace
      i: 0
      min: 0
      r: 1
      s: 0
      zyg:
      - !!perl/hash:RE_quantified_atom
        atom: !!perl/hash:RE_bracket
          decl: []
          min: 0
          re: &21 !!perl/hash:RE_any
            a: 0
            altname: ws_05
            dba: whitespace
            i: 0
            min: 0
            name: ws_05
            r: 1
            s: 0
            zyg:
            - !!perl/hash:RE_method
              a: 0
              alt: ws_05 0
              dba: whitespace
              i: 0
              min: 12345
              name: unsp
              nobind: 1
              r: 1
              rest: ''
              s: 0
            - !!perl/hash:RE_sequence
              a: 0
              alt: ws_05 1
              dba: whitespace
              i: 0
              min: 24690
              r: 1
              s: 0
              zyg:
              - !!perl/hash:RE_method
                a: 0
                dba: whitespace
                i: 0
                min: 12345
                name: vws
                nobind: 1
                r: 1
                rest: ''
                s: 0
              - !!perl/hash:RE_method
                a: 0
                dba: whitespace
                i: 0
                min: 12345
                name: heredoc
                nobind: 1
                r: 1
                rest: ''
                s: 0
            - !!perl/hash:RE_method
              a: 0
              alt: ws_05 2
              dba: whitespace
              i: 0
              min: 12345
              name: unv
              nobind: 1
              r: 1
              rest: ''
              s: 0
            - !!perl/hash:RE_sequence
              a: 0
              alt: ws_05 3
              dba: whitespace
              i: 0
              min: 0
              r: 1
              s: 0
              zyg:
              - !!perl/hash:RE_meta
                a: 0
                dba: whitespace
                i: 0
                min: 0
                r: 1
                s: 0
                text: $
              - !!perl/hash:RE_block
                a: 0
                context: void
                dba: whitespace
                i: 0
                min: 0
                r: 1
                s: 0
                text: ' $.moreinput '
        min: 0
        quant:
        - '*'
        - ':'
        - ''
        - 0
      - !!perl/hash:RE_block
        a: 0
        context: void
        dba: whitespace
        i: 0
        min: 0
        r: 1
        s: 0
        text: "\n        if ($.pos == $startpos) {\n            @*MEMOS[$.pos]<ws>:delete;\n
          \       }\n        else {\n            @*MEMOS[$.pos]<ws> = $startpos;\n
          \           @*MEMOS[$.pos]<endstmt> = @*MEMOS[$startpos]<endstmt>\n                if
          @*MEMOS[$startpos]<endstmt> :exists;\n        }\n    "
ws_01: *20
ws_05: *21
RETREE_END
}

1;
# vim: sw=4 ft=perl
